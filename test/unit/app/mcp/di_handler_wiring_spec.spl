# DI Handler Wiring Specification
#
# Tests for the DI-wired handler adapter system that replaced
# subprocess dispatch in the MCP server.
#
# Tests config parsing and dispatch routing logic.
# Note: In interpreter mode, it-block bodies don't execute.
# Use test/scripts/test_di_handler_wiring.spl for executable tests.
#
# feature_id: mcp_di_wiring_001
# category: mcp
# difficulty: medium
# status: active

# Inline config mirrors config/di.sdn exactly
fn get_config_text() -> text:
    "di:\n  default_profile: dev\n\n  profiles:\n    dev:\n      lazy: false\n    prod:\n      lazy: true\n    test:\n      lazy: false\n\n  services:\n    json_helpers:\n      module: app.mcp.helpers\n      factory: init_json_helpers\n      lazy: auto\n      singleton: true\n    protocol:\n      module: std.mcp.protocol\n      factory: create_protocol_state\n      lazy: auto\n      singleton: true\n    debug_handler:\n      module: app.mcp.handler_adapters.debug_adapter\n      factory: create_debug_handler\n      lazy: auto\n      singleton: true\n    debug_log_handler:\n      module: app.mcp.handler_adapters.debug_log_adapter\n      factory: create_debug_log_handler\n      lazy: auto\n      singleton: true\n    diag_handler:\n      module: app.mcp.handler_adapters.diag_adapter\n      factory: create_diag_handler\n      lazy: auto\n      singleton: true"

# Count occurrences of a substring in a text
fn count_occurrences(haystack: text, needle: text) -> i64:
    var count = 0
    var pos = 0
    val n_len = needle.len()
    val h_len = haystack.len()
    while pos + n_len <= h_len:
        val ch = haystack.substring(pos, pos + n_len)
        if ch == needle:
            count = count + 1
            pos = pos + n_len
        else:
            pos = pos + 1
    count

# Count service entries in config text (count "      module:" occurrences)
fn count_services(cfg: text) -> i64:
    count_occurrences(cfg, "      module:")

# Check if config contains a service section for the given name
fn has_service(cfg: text, name: text) -> bool:
    cfg.contains("    " + name + ":\n")

# Extract the module path for a named service from config text
fn extract_service_module(cfg: text, service_name: text) -> text:
    val marker = "    " + service_name + ":\n      module: "
    val idx = cfg.index_of(marker) ?? -1
    if idx < 0:
        return ""
    val after = cfg.substring(idx + marker.len())
    val nl = after.index_of("\n") ?? after.len()
    after.substring(0, nl)

# Extract the factory name for a named service from config text
fn extract_service_factory(cfg: text, service_name: text) -> text:
    val module_marker = "    " + service_name + ":\n      module: "
    val mod_idx = cfg.index_of(module_marker) ?? -1
    if mod_idx < 0:
        return ""
    # After module line, find factory
    val after_mod = cfg.substring(mod_idx + module_marker.len())
    val factory_prefix = "\n      factory: "
    val fact_idx = after_mod.index_of(factory_prefix) ?? -1
    if fact_idx < 0:
        return ""
    val after_fact = after_mod.substring(fact_idx + factory_prefix.len())
    val nl = after_fact.index_of("\n") ?? after_fact.len()
    after_fact.substring(0, nl)

# Check if a service is configured as singleton
fn is_service_singleton(cfg: text, service_name: text) -> bool:
    val module_marker = "    " + service_name + ":\n      module: "
    val mod_idx = cfg.index_of(module_marker) ?? -1
    if mod_idx < 0:
        return false
    # Find the singleton: true entry within reasonable range after module
    val after_mod = cfg.substring(mod_idx + module_marker.len())
    # Check the next ~200 chars for "singleton: true"
    val check_len = 200
    val actual_len = after_mod.len()
    val limit = if check_len < actual_len: check_len else: actual_len
    val section = after_mod.substring(0, limit)
    section.contains("singleton: true")

# Determine lazy behavior given lazy_mode string and profile default
fn should_be_lazy_mode(lazy_mode: text, profile_lazy: bool) -> bool:
    if lazy_mode == "true":
        return true
    if lazy_mode == "false":
        return false
    profile_lazy

# Local routing function mirrors dispatch_tool in main.spl.
# Order matters: debug_log_ must be checked before debug_.
fn route_tool(tool_name: text) -> text:
    if tool_name.starts_with("debug_log_"):
        return "debug_log_handler"
    elif tool_name.starts_with("debug_"):
        return "debug_handler"
    elif tool_name.starts_with("simple_"):
        return "diag_handler"
    ""

describe "DI Handler Config":
    # ## Config Structure
    #
    # Verifies that `config/di.sdn` contains the 3 handler entries
    # (debug_handler, debug_log_handler, diag_handler) and 2 shared
    # service entries (json_helpers, protocol) after the DI wiring refactor.

    context "when parsing config/di.sdn":
        it "has exactly 5 service entries":
            val cfg = get_config_text()
            val count = count_services(cfg)
            expect(count).to_equal(5)

        it "debug_handler maps to debug_adapter module":
            val cfg = get_config_text()
            val mod_path = extract_service_module(cfg, "debug_handler")
            expect(mod_path).to_equal("app.mcp.handler_adapters.debug_adapter")

        it "debug_log_handler maps to debug_log_adapter module":
            val cfg = get_config_text()
            val mod_path = extract_service_module(cfg, "debug_log_handler")
            expect(mod_path).to_equal("app.mcp.handler_adapters.debug_log_adapter")

        it "diag_handler maps to diag_adapter module":
            val cfg = get_config_text()
            val mod_path = extract_service_module(cfg, "diag_handler")
            expect(mod_path).to_equal("app.mcp.handler_adapters.diag_adapter")

    context "profile behavior":
        it "prod profile makes auto services lazy":
            # auto + prod(lazy=true) = lazy
            val result = should_be_lazy_mode("auto", true)
            expect(result).to_equal(true)

        it "dev profile makes auto services eager":
            # auto + dev(lazy=false) = eager
            val result = should_be_lazy_mode("auto", false)
            expect(result).to_equal(false)

        it "explicit lazy=true overrides dev profile":
            val result = should_be_lazy_mode("true", false)
            expect(result).to_equal(true)

        it "explicit lazy=false overrides prod profile":
            val result = should_be_lazy_mode("false", true)
            expect(result).to_equal(false)

describe "Dispatch Routing":
    # ## Tool Prefix Routing
    #
    # Verifies that dispatch_tool routing logic correctly routes
    # tool names to the right handler based on prefix.
    # Order matters: debug_log_ must be checked before debug_.

    context "prefix matching":
        it "debug_log_ prefix routes to debug_log_handler":
            val result = route_tool("debug_log_status")
            expect(result).to_equal("debug_log_handler")

        it "debug_ prefix routes to debug_handler":
            val result = route_tool("debug_create_session")
            expect(result).to_equal("debug_handler")

        it "simple_ prefix routes to diag_handler":
            val result = route_tool("simple_status")
            expect(result).to_equal("diag_handler")

        it "debug_log_ checked before debug_ (order matters)":
            val result = route_tool("debug_log_enable")
            expect(result).to_equal("debug_log_handler")

        it "unknown prefix returns error":
            val result = route_tool("unknown_tool")
            expect(result).to_equal("")

    context "all tool names":
        it "all 16 debug tools route to debug_handler":
            val debug_tools = [
                "debug_create_session",
                "debug_list_sessions",
                "debug_close_session",
                "debug_set_breakpoint",
                "debug_remove_breakpoint",
                "debug_continue",
                "debug_step",
                "debug_get_variables",
                "debug_stack_trace",
                "debug_evaluate",
                "debug_set_function_breakpoint",
                "debug_enable_breakpoint",
                "debug_get_source",
                "debug_watch",
                "debug_set_variable",
                "debug_set_data_breakpoint",
                "debug_list_data_breakpoints",
                "debug_remove_data_breakpoint",
                "debug_terminate"
            ]
            var all_ok = true
            var idx = 0
            while idx < debug_tools.len():
                if route_tool(debug_tools[idx]) != "debug_handler":
                    all_ok = false
                idx = idx + 1
            expect(all_ok).to_equal(true)

        it "all 6 debug_log tools route to debug_log_handler":
            val log_tools = [
                "debug_log_enable",
                "debug_log_disable",
                "debug_log_clear",
                "debug_log_query",
                "debug_log_tree",
                "debug_log_status"
            ]
            var all_ok = true
            var idx = 0
            while idx < log_tools.len():
                if route_tool(log_tools[idx]) != "debug_log_handler":
                    all_ok = false
                idx = idx + 1
            expect(all_ok).to_equal(true)

        it "all 12 diag tools route to diag_handler":
            val diag_tools = [
                "simple_read",
                "simple_check",
                "simple_symbols",
                "simple_status",
                "simple_expand_at",
                "simple_edit",
                "simple_multi_edit",
                "simple_run",
                "simple_diff",
                "simple_log",
                "simple_squash",
                "simple_new"
            ]
            var all_ok = true
            var idx = 0
            while idx < diag_tools.len():
                if route_tool(diag_tools[idx]) != "diag_handler":
                    all_ok = false
                idx = idx + 1
            expect(all_ok).to_equal(true)

describe "DI Wiring Lifecycle":
    # ## Full Wiring
    #
    # Simulates init_di() from main.spl: config loads placeholders,
    # then real factories override them, and DI-resolved handlers dispatch.

    context "init_di simulation":
        it "config loads placeholders for all 3 handlers":
            # The config defines all 3 handler services that init_di() will register
            val cfg = get_config_text()
            expect(has_service(cfg, "debug_handler")).to_equal(true)
            expect(has_service(cfg, "debug_log_handler")).to_equal(true)
            expect(has_service(cfg, "diag_handler")).to_equal(true)

        it "real factories override placeholders":
            # Config defines factory names; init_di() overrides with real factories.
            # The factory names in config match the exported function names in adapters.
            val cfg = get_config_text()
            expect(extract_service_factory(cfg, "debug_handler")).to_equal("create_debug_handler")
            expect(extract_service_factory(cfg, "debug_log_handler")).to_equal("create_debug_log_handler")
            expect(extract_service_factory(cfg, "diag_handler")).to_equal("create_diag_handler")

        it "DI returns singleton on repeated resolve":
            # All handler services are configured as singletons (singleton: true)
            val cfg = get_config_text()
            expect(is_service_singleton(cfg, "debug_handler")).to_equal(true)
            expect(is_service_singleton(cfg, "debug_log_handler")).to_equal(true)
            expect(is_service_singleton(cfg, "diag_handler")).to_equal(true)

    context "handler dispatch":
        it "debug_handler dispatches debug_list_sessions":
            val result = route_tool("debug_list_sessions")
            expect(result).to_equal("debug_handler")

        it "debug_log_handler dispatches debug_log_status":
            val result = route_tool("debug_log_status")
            expect(result).to_equal("debug_log_handler")

        it "diag_handler dispatches simple_status":
            val result = route_tool("simple_status")
            expect(result).to_equal("diag_handler")
