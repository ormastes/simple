# MCP Pagination Tests
# Feature: MCP Cursor-Based Pagination
# Category: MCP, Protocol
# Status: Complete
#
# Tests for pagination helpers using MCP JSON builders and response formatting.

use std.spec
use app.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, extract_json_string, extract_json_value, make_result_response, log_level_to_int, min_int}

describe "Pagination - page building with JSON helpers":
    it "builds paginated response with items":
        val items = "[" + js("item1") + "," + js("item2") + "," + js("item3") + "]"
        val result = jo1(jp("items", items))
        val response = make_result_response("1", result)
        expect(response.contains("items")).to_equal(true)
        expect(response.contains("item1")).to_equal(true)
        expect(response.contains("item3")).to_equal(true)

    it "builds empty page response":
        val result = jo1(jp("items", "[]"))
        val response = make_result_response("1", result)
        expect(response.contains("items")).to_equal(true)

    it "builds page with next cursor":
        val result = jo2(
            jp("items", "[" + js("a") + "]"),
            jp("nextCursor", js("o10l10"))
        )
        val response = make_result_response("1", result)
        expect(response.contains("nextCursor")).to_equal(true)
        expect(response.contains("o10l10")).to_equal(true)

    it "builds page without next cursor when at end":
        val result = jo1(jp("items", "[" + js("last") + "]"))
        val response = make_result_response("1", result)
        expect(response.contains("nextCursor")).to_equal(false)

describe "Pagination - cursor encoding":
    it "cursor format includes offset and limit":
        val cursor = "o10l20"
        expect(cursor.starts_with("o")).to_equal(true)
        expect(cursor.contains("l")).to_equal(true)

    it "first page cursor starts at zero":
        val cursor = "o0l50"
        expect(cursor.starts_with("o0")).to_equal(true)

    it "next page cursor advances offset":
        val page_size = 10
        val offset = 0
        val next_offset = offset + page_size
        expect(next_offset).to_equal(10)

    it "previous page cursor decreases offset":
        val page_size = 10
        val offset = 20
        val prev_offset = offset - page_size
        expect(prev_offset).to_equal(10)

    it "previous at start returns no cursor":
        val offset = 0
        val has_previous = offset > 0
        expect(has_previous).to_equal(false)

describe "Pagination - page size clamping":
    it "clamps page size to maximum":
        val requested = 2000
        val max_size = 1000
        val clamped = min_int(requested, max_size)
        expect(clamped).to_equal(1000)

    it "accepts valid page size":
        val requested = 50
        val max_size = 1000
        val clamped = min_int(requested, max_size)
        expect(clamped).to_equal(50)

    it "handles zero page size with default":
        val requested = 0
        val default_size = 100
        var page_size = requested
        if page_size <= 0:
            page_size = default_size
        expect(page_size).to_equal(100)

    it "handles negative page size with default":
        val requested = -10
        val default_size = 100
        var page_size = requested
        if page_size <= 0:
            page_size = default_size
        expect(page_size).to_equal(100)

describe "Pagination - extract cursor from params":
    it "extracts cursor from params JSON":
        val params = jo1(jp("cursor", js("o10l20")))
        val cursor = extract_json_string(params, "cursor")
        expect(cursor).to_equal("o10l20")

    it "returns empty for missing cursor":
        val params = jo1(jp("other", js("value")))
        val cursor = extract_json_string(params, "cursor")
        expect(cursor).to_equal("")

    it "extracts empty cursor value":
        val params = jo1(jp("cursor", js("")))
        val cursor = extract_json_string(params, "cursor")
        expect(cursor).to_equal("")

describe "Pagination - total count":
    it "includes total count in response":
        val result = jo2(
            jp("items", "[" + js("a") + "," + js("b") + "]"),
            jp("totalCount", "100")
        )
        val response = make_result_response("1", result)
        expect(response.contains("totalCount")).to_equal(true)
        expect(response.contains("100")).to_equal(true)

    it "extracts total count":
        val result = jo2(jp("items", "[]"), jp("totalCount", "42"))
        expect(extract_json_value(result, "totalCount")).to_equal("42")

describe "Pagination - page iteration":
    it "calculates total pages":
        val total_items = 25
        val page_size = 10
        var total_pages = total_items / page_size
        if total_items % page_size > 0:
            total_pages = total_pages + 1
        expect(total_pages).to_equal(3)

    it "handles exact page boundary":
        val total_items = 30
        val page_size = 10
        var total_pages = total_items / page_size
        if total_items % page_size > 0:
            total_pages = total_pages + 1
        expect(total_pages).to_equal(3)

    it "handles empty list":
        val total_items = 0
        val is_empty = total_items == 0
        expect(is_empty).to_equal(true)

    it "handles single item":
        val total_items = 1
        val page_size = 10
        val has_more = total_items > page_size
        expect(has_more).to_equal(false)

describe "Pagination - config with log levels":
    it "debug level for pagination trace":
        expect(log_level_to_int("debug")).to_equal(0)

    it "info level for page access":
        expect(log_level_to_int("info")).to_equal(1)

    it "warning level for invalid cursor":
        expect(log_level_to_int("warning")).to_equal(3)
