use std.spec
use std.string.{NL}

# MCP Prompts Extended Specification
#
# Tests for prompt manager types, prompt dispatch, argument validation,
# and prompt template generation logic.
# Locally replicates pure functions from app.mcp.prompts.

# =========================================================================
# Local type definitions (mirrors prompts.spl)
# =========================================================================

struct PromptArgument:
    name: text
    description: text
    required: bool

struct PromptInfo:
    name: text
    description: text
    arg_count: i64

enum PromptRole:
    User
    Assistant

struct PromptMessage:
    role: PromptRole
    content: text

struct PromptResult:
    description: text
    messages: [PromptMessage]

# =========================================================================
# Prompt dispatch logic (mirrors get_prompt routing)
# =========================================================================

fn dispatch_prompt(name: text) -> text:
    if name == "refactor-rename":
        return "refactor"
    elif name == "refactor-extract-function":
        return "refactor"
    elif name == "refactor-inline":
        return "refactor"
    elif name == "generate-tests":
        return "generate"
    elif name == "generate-trait-impl":
        return "generate"
    elif name == "generate-constructor":
        return "generate"
    elif name == "docs-add-docstrings":
        return "docs"
    elif name == "docs-explain-code":
        return "docs"
    elif name == "docs-generate-readme":
        return "docs"
    elif name == "analyze-find-bugs":
        return "analyze"
    elif name == "analyze-suggest-improvements":
        return "analyze"
    elif name == "analyze-performance":
        return "analyze"
    "unknown"

# =========================================================================
# Argument validation helpers (mirrors required arg checking)
# =========================================================================

fn validate_rename_args(args: dict) -> text:
    if not args.contains("old_name"):
        return "Missing required argument: old_name"
    if not args.contains("new_name"):
        return "Missing required argument: new_name"
    ""

fn validate_extract_function_args(args: dict) -> text:
    if not args.contains("code"):
        return "Missing required argument: code"
    if not args.contains("function_name"):
        return "Missing required argument: function_name"
    if not args.contains("file"):
        return "Missing required argument: file"
    ""

fn validate_inline_args(args: dict) -> text:
    if not args.contains("name"):
        return "Missing required argument: name"
    if not args.contains("file"):
        return "Missing required argument: file"
    ""

fn validate_generate_tests_args(args: dict) -> text:
    if not args.contains("target"):
        return "Missing required argument: target"
    if not args.contains("file"):
        return "Missing required argument: file"
    ""

fn validate_trait_impl_args(args: dict) -> text:
    if not args.contains("class_name"):
        return "Missing required argument: class_name"
    if not args.contains("trait_name"):
        return "Missing required argument: trait_name"
    if not args.contains("file"):
        return "Missing required argument: file"
    ""

fn validate_constructor_args(args: dict) -> text:
    if not args.contains("class_name"):
        return "Missing required argument: class_name"
    if not args.contains("file"):
        return "Missing required argument: file"
    ""

fn validate_docstrings_args(args: dict) -> text:
    if not args.contains("file"):
        return "Missing required argument: file"
    ""

fn validate_find_bugs_args(args: dict) -> text:
    if not args.contains("file"):
        return "Missing required argument: file"
    ""

# =========================================================================
# Prompt content generation (mirrors template logic)
# =========================================================================

fn build_rename_content(old_name: text, new_name: text, file: text) -> text:
    var content = "Rename the symbol '" + old_name + "' to '" + new_name + "' in " + file + ". Please:{NL}"
    content = content + "1. Find all occurrences of '" + old_name + "'{NL}"
    content = content + "2. Rename to '" + new_name + "' while preserving functionality{NL}"
    content = content + "3. Update any documentation or comments{NL}"
    content = content + "4. Ensure no naming conflicts are introduced"
    content

fn build_inline_content(name: text, file: text) -> text:
    var content = "Inline the symbol '" + name + "' in " + file + ". Please:{NL}"
    content = content + "1. Find the definition of '" + name + "'{NL}"
    content = content + "2. Replace all usages with the inline code{NL}"
    content = content + "3. Remove the original definition{NL}"
    content = content + "4. Ensure the code still works correctly"
    content

fn build_generate_tests_content(target: text, file: text) -> text:
    var content = "Generate comprehensive SSpec tests for '" + target + "' in " + file + ". Please:{NL}"
    content = content + "1. Read the implementation of '" + target + "'{NL}"
    content = content + "2. Identify edge cases and important scenarios{NL}"
    content = content + "3. Write tests using the SSpec framework (it/describe blocks){NL}"
    content = content + "4. Include positive and negative test cases{NL}"
    content = content + "5. Test boundary conditions{NL}"
    content = content + "6. Follow Simple's testing conventions in CLAUDE.md"
    content

fn build_find_bugs_content(file: text) -> text:
    var content = "Analyze " + file + " for potential bugs. Please look for:{NL}"
    content = content + "1. Off-by-one errors{NL}"
    content = content + "2. Null/None dereferences{NL}"
    content = content + "3. Resource leaks{NL}"
    content

# =========================================================================
# Tests
# =========================================================================

describe "PromptArgument":
    it "creates with all fields":
        val arg = PromptArgument(
            name: "file_path",
            description: "Path to the file",
            required: true
        )
        expect(arg.name).to_equal("file_path")
        expect(arg.description).to_equal("Path to the file")
        expect(arg.required).to_equal(true)

    it "creates optional argument":
        val arg = PromptArgument(
            name: "target",
            description: "Optional target",
            required: false
        )
        expect(arg.required).to_equal(false)

    it "stores different argument names":
        val args = [
            PromptArgument(name: "old_name", description: "Current name", required: true),
            PromptArgument(name: "new_name", description: "New name", required: true),
            PromptArgument(name: "file", description: "File path", required: false)
        ]
        expect(args.len()).to_equal(3)
        expect(args[0].name).to_equal("old_name")
        expect(args[1].name).to_equal("new_name")
        expect(args[2].name).to_equal("file")

describe "PromptRole":
    it "creates User role":
        val role = PromptRole.User
        expect(role == PromptRole.User).to_equal(true)

    it "creates Assistant role":
        val role = PromptRole.Assistant
        expect(role == PromptRole.Assistant).to_equal(true)

    it "distinguishes User from Assistant":
        expect(PromptRole.User == PromptRole.Assistant).to_equal(false)

describe "PromptMessage":
    it "creates with User role and content":
        val msg = PromptMessage(
            role: PromptRole.User,
            content: "Please refactor this code"
        )
        expect(msg.role == PromptRole.User).to_equal(true)
        expect(msg.content).to_equal("Please refactor this code")

    it "creates with Assistant role":
        val msg = PromptMessage(
            role: PromptRole.Assistant,
            content: "I will help you refactor"
        )
        expect(msg.role == PromptRole.Assistant).to_equal(true)
        expect(msg.content).to_contain("refactor")

    it "handles empty content":
        val msg = PromptMessage(
            role: PromptRole.User,
            content: ""
        )
        expect(msg.content).to_equal("")

    it "handles multiline content":
        val content = "Line 1{NL}Line 2{NL}Line 3"
        val msg = PromptMessage(
            role: PromptRole.User,
            content: content
        )
        expect(msg.content).to_contain("Line 1")
        expect(msg.content).to_contain("Line 3")

describe "PromptResult":
    it "creates with description and messages":
        val result = PromptResult(
            description: "Rename symbol",
            messages: [
                PromptMessage(role: PromptRole.User, content: "Rename foo to bar")
            ]
        )
        expect(result.description).to_equal("Rename symbol")
        expect(result.messages.len()).to_equal(1)

    it "creates with multiple messages":
        val result = PromptResult(
            description: "Multi-turn prompt",
            messages: [
                PromptMessage(role: PromptRole.User, content: "Help me"),
                PromptMessage(role: PromptRole.Assistant, content: "Sure"),
                PromptMessage(role: PromptRole.User, content: "Thanks")
            ]
        )
        expect(result.messages.len()).to_equal(3)
        expect(result.messages[0].role == PromptRole.User).to_equal(true)
        expect(result.messages[1].role == PromptRole.Assistant).to_equal(true)
        expect(result.messages[2].role == PromptRole.User).to_equal(true)

    it "creates with empty messages":
        val result = PromptResult(
            description: "Empty",
            messages: []
        )
        expect(result.messages.len()).to_equal(0)

describe "Prompt dispatch routing":
    it "routes refactor-rename to refactor category":
        expect(dispatch_prompt("refactor-rename")).to_equal("refactor")

    it "routes refactor-extract-function to refactor category":
        expect(dispatch_prompt("refactor-extract-function")).to_equal("refactor")

    it "routes refactor-inline to refactor category":
        expect(dispatch_prompt("refactor-inline")).to_equal("refactor")

    it "routes generate-tests to generate category":
        expect(dispatch_prompt("generate-tests")).to_equal("generate")

    it "routes generate-trait-impl to generate category":
        expect(dispatch_prompt("generate-trait-impl")).to_equal("generate")

    it "routes generate-constructor to generate category":
        expect(dispatch_prompt("generate-constructor")).to_equal("generate")

    it "routes docs-add-docstrings to docs category":
        expect(dispatch_prompt("docs-add-docstrings")).to_equal("docs")

    it "routes docs-explain-code to docs category":
        expect(dispatch_prompt("docs-explain-code")).to_equal("docs")

    it "routes docs-generate-readme to docs category":
        expect(dispatch_prompt("docs-generate-readme")).to_equal("docs")

    it "routes analyze-find-bugs to analyze category":
        expect(dispatch_prompt("analyze-find-bugs")).to_equal("analyze")

    it "routes analyze-suggest-improvements to analyze category":
        expect(dispatch_prompt("analyze-suggest-improvements")).to_equal("analyze")

    it "routes analyze-performance to analyze category":
        expect(dispatch_prompt("analyze-performance")).to_equal("analyze")

    it "returns unknown for unrecognized prompt":
        expect(dispatch_prompt("nonexistent-prompt")).to_equal("unknown")

    it "returns unknown for empty string":
        expect(dispatch_prompt("")).to_equal("unknown")

describe "Prompt argument validation":
    describe "refactor-rename validation":
        it "accepts valid args":
            var args = {}
            args["old_name"] = "foo"
            args["new_name"] = "bar"
            expect(validate_rename_args(args)).to_equal("")

        it "rejects missing old_name":
            var args = {}
            args["new_name"] = "bar"
            expect(validate_rename_args(args)).to_contain("old_name")

        it "rejects missing new_name":
            var args = {}
            args["old_name"] = "foo"
            expect(validate_rename_args(args)).to_contain("new_name")

        it "rejects empty args":
            var args = {}
            expect(validate_rename_args(args)).to_contain("old_name")

    describe "refactor-extract-function validation":
        it "accepts valid args":
            var args = {}
            args["code"] = "val x = 42"
            args["function_name"] = "get_value"
            args["file"] = "test.spl"
            expect(validate_extract_function_args(args)).to_equal("")

        it "rejects missing code":
            var args = {}
            args["function_name"] = "get_value"
            args["file"] = "test.spl"
            expect(validate_extract_function_args(args)).to_contain("code")

        it "rejects missing function_name":
            var args = {}
            args["code"] = "val x = 42"
            args["file"] = "test.spl"
            expect(validate_extract_function_args(args)).to_contain("function_name")

        it "rejects missing file":
            var args = {}
            args["code"] = "val x = 42"
            args["function_name"] = "get_value"
            expect(validate_extract_function_args(args)).to_contain("file")

    describe "refactor-inline validation":
        it "accepts valid args":
            var args = {}
            args["name"] = "helper"
            args["file"] = "test.spl"
            expect(validate_inline_args(args)).to_equal("")

        it "rejects missing name":
            var args = {}
            args["file"] = "test.spl"
            expect(validate_inline_args(args)).to_contain("name")

        it "rejects missing file":
            var args = {}
            args["name"] = "helper"
            expect(validate_inline_args(args)).to_contain("file")

    describe "generate-tests validation":
        it "accepts valid args":
            var args = {}
            args["target"] = "MyClass"
            args["file"] = "src/my_class.spl"
            expect(validate_generate_tests_args(args)).to_equal("")

        it "rejects missing target":
            var args = {}
            args["file"] = "src/my_class.spl"
            expect(validate_generate_tests_args(args)).to_contain("target")

        it "rejects missing file":
            var args = {}
            args["target"] = "MyClass"
            expect(validate_generate_tests_args(args)).to_contain("file")

    describe "generate-trait-impl validation":
        it "accepts valid args":
            var args = {}
            args["class_name"] = "Point"
            args["trait_name"] = "Serializable"
            args["file"] = "src/point.spl"
            expect(validate_trait_impl_args(args)).to_equal("")

        it "rejects missing class_name":
            var args = {}
            args["trait_name"] = "Serializable"
            args["file"] = "src/point.spl"
            expect(validate_trait_impl_args(args)).to_contain("class_name")

        it "rejects missing trait_name":
            var args = {}
            args["class_name"] = "Point"
            args["file"] = "src/point.spl"
            expect(validate_trait_impl_args(args)).to_contain("trait_name")

    describe "generate-constructor validation":
        it "accepts valid args":
            var args = {}
            args["class_name"] = "Point"
            args["file"] = "src/point.spl"
            expect(validate_constructor_args(args)).to_equal("")

        it "rejects missing class_name":
            var args = {}
            args["file"] = "src/point.spl"
            expect(validate_constructor_args(args)).to_contain("class_name")

    describe "docs-add-docstrings validation":
        it "accepts valid args":
            var args = {}
            args["file"] = "src/utils.spl"
            expect(validate_docstrings_args(args)).to_equal("")

        it "rejects missing file":
            var args = {}
            expect(validate_docstrings_args(args)).to_contain("file")

    describe "analyze-find-bugs validation":
        it "accepts valid args":
            var args = {}
            args["file"] = "src/parser.spl"
            expect(validate_find_bugs_args(args)).to_equal("")

        it "rejects missing file":
            var args = {}
            expect(validate_find_bugs_args(args)).to_contain("file")

describe "Prompt content generation":
    describe "rename prompt content":
        it "includes old and new names":
            val content = build_rename_content("oldFunc", "newFunc", "test.spl")
            expect(content).to_contain("oldFunc")
            expect(content).to_contain("newFunc")

        it "includes target file":
            val content = build_rename_content("foo", "bar", "src/main.spl")
            expect(content).to_contain("src/main.spl")

        it "includes all steps":
            val content = build_rename_content("x", "y", "file.spl")
            expect(content).to_contain("Find all occurrences")
            expect(content).to_contain("Rename to")
            expect(content).to_contain("documentation")
            expect(content).to_contain("naming conflicts")

        it "formats as numbered list":
            val content = build_rename_content("a", "b", "c.spl")
            expect(content).to_contain("1.")
            expect(content).to_contain("2.")
            expect(content).to_contain("3.")
            expect(content).to_contain("4.")

    describe "inline prompt content":
        it "includes symbol name and file":
            val content = build_inline_content("helperFunc", "src/utils.spl")
            expect(content).to_contain("helperFunc")
            expect(content).to_contain("src/utils.spl")

        it "includes all steps":
            val content = build_inline_content("x", "f.spl")
            expect(content).to_contain("Find the definition")
            expect(content).to_contain("Replace all usages")
            expect(content).to_contain("Remove the original definition")
            expect(content).to_contain("works correctly")

    describe "generate tests prompt content":
        it "includes target and file":
            val content = build_generate_tests_content("MyParser", "src/parser.spl")
            expect(content).to_contain("MyParser")
            expect(content).to_contain("src/parser.spl")

        it "mentions SSpec framework":
            val content = build_generate_tests_content("X", "x.spl")
            expect(content).to_contain("SSpec")

        it "mentions edge cases":
            val content = build_generate_tests_content("X", "x.spl")
            expect(content).to_contain("edge cases")

        it "mentions positive and negative tests":
            val content = build_generate_tests_content("X", "x.spl")
            expect(content).to_contain("positive and negative")

        it "mentions boundary conditions":
            val content = build_generate_tests_content("X", "x.spl")
            expect(content).to_contain("boundary conditions")

        it "references CLAUDE.md conventions":
            val content = build_generate_tests_content("X", "x.spl")
            expect(content).to_contain("CLAUDE.md")

    describe "find bugs prompt content":
        it "includes target file":
            val content = build_find_bugs_content("src/compiler.spl")
            expect(content).to_contain("src/compiler.spl")

        it "mentions common bug categories":
            val content = build_find_bugs_content("f.spl")
            expect(content).to_contain("Off-by-one")
            expect(content).to_contain("Null")
            expect(content).to_contain("Resource leaks")

describe "Prompt list completeness":
    it "has exactly 12 default prompts":
        val prompt_names = [
            "refactor-rename",
            "refactor-extract-function",
            "refactor-inline",
            "generate-tests",
            "generate-trait-impl",
            "generate-constructor",
            "docs-add-docstrings",
            "docs-explain-code",
            "docs-generate-readme",
            "analyze-find-bugs",
            "analyze-suggest-improvements",
            "analyze-performance"
        ]
        expect(prompt_names.len()).to_equal(12)

    it "has 3 refactoring prompts":
        var count = 0
        val names = ["refactor-rename", "refactor-extract-function", "refactor-inline"]
        for name in names:
            if dispatch_prompt(name) == "refactor":
                count = count + 1
        expect(count).to_equal(3)

    it "has 3 generation prompts":
        var count = 0
        val names = ["generate-tests", "generate-trait-impl", "generate-constructor"]
        for name in names:
            if dispatch_prompt(name) == "generate":
                count = count + 1
        expect(count).to_equal(3)

    it "has 3 documentation prompts":
        var count = 0
        val names = ["docs-add-docstrings", "docs-explain-code", "docs-generate-readme"]
        for name in names:
            if dispatch_prompt(name) == "docs":
                count = count + 1
        expect(count).to_equal(3)

    it "has 3 analysis prompts":
        var count = 0
        val names = ["analyze-find-bugs", "analyze-suggest-improvements", "analyze-performance"]
        for name in names:
            if dispatch_prompt(name) == "analyze":
                count = count + 1
        expect(count).to_equal(3)

    it "all prompt names use hyphen-separated format":
        val names = [
            "refactor-rename",
            "refactor-extract-function",
            "refactor-inline",
            "generate-tests",
            "generate-trait-impl",
            "generate-constructor",
            "docs-add-docstrings",
            "docs-explain-code",
            "docs-generate-readme",
            "analyze-find-bugs",
            "analyze-suggest-improvements",
            "analyze-performance"
        ]
        for name in names:
            expect(name).to_contain("-")

    it "all prompt names have category prefix":
        val names = [
            "refactor-rename",
            "refactor-extract-function",
            "refactor-inline",
            "generate-tests",
            "generate-trait-impl",
            "generate-constructor",
            "docs-add-docstrings",
            "docs-explain-code",
            "docs-generate-readme",
            "analyze-find-bugs",
            "analyze-suggest-improvements",
            "analyze-performance"
        ]
        for name in names:
            val has_prefix = name.starts_with("refactor-") or name.starts_with("generate-") or name.starts_with("docs-") or name.starts_with("analyze-")
            expect(has_prefix).to_equal(true)
