# @pending
"""
MCP Server End-to-End Integration Tests
Feature: MCP Server E2E
Category: MCP, Integration, E2E
Status: In Progress

End-to-end tests with real file I/O for MCP tool implementations.
"""


extern fn native_fs_read_string(path: String) -> String

fn LB() -> String:
    123 as char

fn RB() -> String:
    125 as char

fn Q() -> String:
    "\""

fn unwrap_idx(opt) -> Int:
    match opt:
        case Some(i):
            return i
        case None:
            return -1

fn unwrap_str(result) -> String:
    match result:
        case Ok(s):
            return s
        case Err(_):
            return ""

fn escape_json(text: String) -> String:
    var result = text
    result = result.replace("\\", "\\\\")
    result = result.replace(Q(), "\\" + Q())
    result = result.replace("\n", "\\n")
    result = result.replace("\r", "\\r")
    result = result.replace("\t", "\\t")
    result

fn read_file_safe(path: String) -> String:
    val content = unwrap_str(native_fs_read_string(path))
    if content == "":
        return "Error: could not read file: " + path
    content

fn get_file_info(path: String) -> String:
    val content = unwrap_str(native_fs_read_string(path))
    if content == "":
        return "Error: could not read file: " + path
    val lines = content.split("\n")
    var line_count = lines.len()
    var fn_count = 0
    var class_count = 0
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("fn ") or trimmed.starts_with("me ") or trimmed.starts_with("static fn "):
            fn_count = fn_count + 1
        elif trimmed.starts_with("class ") or trimmed.starts_with("struct "):
            class_count = class_count + 1
    var r = "File: "
    r = r + path
    r = r + "\\nLines: "
    r = r + line_count.to_string()
    r = r + "\\nFunctions: "
    r = r + fn_count.to_string()
    r = r + "\\nClasses/Structs: "
    r = r + class_count.to_string()
    r

# ----------- Tests -----------

describe "MCP E2E - read_file_safe":
    it "reads an existing file":
        val content = read_file_safe("/etc/hostname")
        expect(content.len() > 0)
        expect(not content.starts_with("Error:"))

    it "returns error for missing file":
        val content = read_file_safe("nonexistent_xyz_abc.spl")
        expect(content.starts_with("Error:"))

    it "reads a Simple source file":
        val content = read_file_safe("test/lib/std/unit/mcp/mcp_e2e_spec.spl")
        expect(content.contains("MCP Server"))
        expect(content.contains("import std.spec"))

describe "MCP E2E - get_file_info":
    it "returns file path":
        val info = get_file_info("test/lib/std/unit/mcp/mcp_e2e_spec.spl")
        expect(info.contains("File: test/lib/std/unit/mcp/mcp_e2e_spec.spl"))

    it "counts lines":
        val info = get_file_info("test/lib/std/unit/mcp/mcp_e2e_spec.spl")
        expect(info.contains("Lines:"))
        expect(not info.contains("Lines: 0"))

    it "counts functions in this file":
        val info = get_file_info("test/lib/std/unit/mcp/mcp_e2e_spec.spl")
        expect(info.contains("Functions:"))
        expect(not info.contains("Functions: 0"))

    it "returns error for missing file":
        val info = get_file_info("no_such_file_xyz.spl")
        expect(info.starts_with("Error:"))

describe "MCP E2E - escape_json":
    it "escapes real file content":
        val content = read_file_safe("test/lib/std/unit/mcp/mcp_e2e_spec.spl")
        val escaped = escape_json(content)
        # Escaped content should not contain raw newlines
        expect(not escaped.contains("\n"))
        # But should contain escaped newlines
        expect(escaped.contains("\\n"))

    it "escapes content with quotes":
        val content = read_file_safe("test/lib/std/unit/mcp/mcp_e2e_spec.spl")
        val escaped = escape_json(content)
        # Should contain escaped quotes (source has string literals)
        expect(escaped.len() > content.len())

    it "produces valid JSON string content":
        val content = read_file_safe("/etc/hostname")
        val escaped = escape_json(content)
        # Wrapping in quotes should look like a JSON string
        var json_str = Q()
        json_str = json_str + escaped
        json_str = json_str + Q()
        expect(json_str.starts_with(Q()))
        expect(json_str.ends_with(Q()))

describe "MCP E2E - file_info accuracy":
    it "correctly counts fn definitions":
        # Create known content and test
        val content = "fn foo():\n    pass\nfn bar():\n    pass\nme update():\n    pass"
        val lines = content.split("\n")
        var fn_count = 0
        for line in lines:
            val trimmed = line.trim()
            if trimmed.starts_with("fn ") or trimmed.starts_with("me ") or trimmed.starts_with("static fn "):
                fn_count = fn_count + 1
        expect(fn_count == 3)

    it "correctly counts class/struct definitions":
        val content = "class Foo:\n    x: Int\nstruct Bar:\n    y: Int"
        val lines = content.split("\n")
        var class_count = 0
        for line in lines:
            val trimmed = line.trim()
            if trimmed.starts_with("class ") or trimmed.starts_with("struct "):
                class_count = class_count + 1
        expect(class_count == 2)

    it "self-referential test: this file has functions":
        val info = get_file_info("test/lib/std/unit/mcp/mcp_e2e_spec.spl")
        # This file defines: LB, RB, Q, unwrap_idx, unwrap_str, escape_json,
        # read_file_safe, get_file_info = 8 fn definitions
        expect(info.contains("Functions:"))
