# MCP Rename Tool - Edge Cases Specification
#
# **Feature IDs:** #MCP-LSP-002
# **Category:** Tooling
# **Difficulty:** 3/5
# **Status:** Implemented
#
# ## Overview
#
# Tests rename symbol edge cases: same-name, keyword collision, multi-file,
# identifier validation, and command construction variants.
#
# ## Key Concepts
#
# | Concept          | Description                                        |
# |------------------|----------------------------------------------------|
# | Rename           | Replaces symbol name across all references          |
# | Keyword check    | New name must not collide with language keywords     |
# | Identifier rules | Must start with letter or underscore, no spaces      |
# | Destructive      | Rename modifies source files                         |
# | Dry-run          | Preview mode that shows changes without applying     |

use std.spec

# ============================================================================
# Test Group 1: Same-name and no-op detection
# ============================================================================

describe "rename tool edge cases":
    it "detects same-name rename as no-op":
        val old_name = "query_main"
        val new_name = "query_main"
        val is_noop = old_name == new_name
        expect(is_noop).to_equal(true)

    it "detects different names as non-noop":
        val old_name = "query_main"
        val new_name = "process_query"
        val is_noop = old_name == new_name
        expect(is_noop).to_equal(false)

    it "case-different name is not a no-op":
        val old_name = "queryMain"
        val new_name = "querymain"
        val is_noop = old_name == new_name
        expect(is_noop).to_equal(false)

# ============================================================================
# Test Group 2: Keyword collision detection
# ============================================================================

describe "rename keyword collision":
    it "detects fn keyword collision":
        val keywords = ["fn", "class", "struct", "enum", "val", "var", "if", "else", "for", "while", "match", "return", "import", "use", "trait", "impl", "static", "me", "self", "nil", "true", "false"]
        val new_name = "fn"
        val is_keyword = keywords.contains(new_name)
        expect(is_keyword).to_equal(true)

    it "detects class keyword collision":
        val keywords = ["fn", "class", "struct", "enum", "val", "var", "if", "else", "for", "while", "match", "return", "import", "use", "trait", "impl", "static", "me", "self", "nil", "true", "false"]
        val new_name = "class"
        val is_keyword = keywords.contains(new_name)
        expect(is_keyword).to_equal(true)

    it "detects val keyword collision":
        val keywords = ["fn", "class", "struct", "enum", "val", "var", "if", "else", "for", "while", "match", "return", "import", "use", "trait", "impl", "static", "me", "self", "nil", "true", "false"]
        val new_name = "val"
        val is_keyword = keywords.contains(new_name)
        expect(is_keyword).to_equal(true)

    it "detects var keyword collision":
        val keywords = ["fn", "class", "struct", "enum", "val", "var", "if", "else", "for", "while", "match", "return", "import", "use", "trait", "impl", "static", "me", "self", "nil", "true", "false"]
        val new_name = "var"
        val is_keyword = keywords.contains(new_name)
        expect(is_keyword).to_equal(true)

    it "detects self keyword collision":
        val keywords = ["fn", "class", "struct", "enum", "val", "var", "if", "else", "for", "while", "match", "return", "import", "use", "trait", "impl", "static", "me", "self", "nil", "true", "false"]
        val new_name = "self"
        val is_keyword = keywords.contains(new_name)
        expect(is_keyword).to_equal(true)

    it "detects nil keyword collision":
        val keywords = ["fn", "class", "struct", "enum", "val", "var", "if", "else", "for", "while", "match", "return", "import", "use", "trait", "impl", "static", "me", "self", "nil", "true", "false"]
        val new_name = "nil"
        val is_keyword = keywords.contains(new_name)
        expect(is_keyword).to_equal(true)

    it "detects true keyword collision":
        val keywords = ["fn", "class", "struct", "enum", "val", "var", "if", "else", "for", "while", "match", "return", "import", "use", "trait", "impl", "static", "me", "self", "nil", "true", "false"]
        val new_name = "true"
        val is_keyword = keywords.contains(new_name)
        expect(is_keyword).to_equal(true)

    it "detects match keyword collision":
        val keywords = ["fn", "class", "struct", "enum", "val", "var", "if", "else", "for", "while", "match", "return", "import", "use", "trait", "impl", "static", "me", "self", "nil", "true", "false"]
        val new_name = "match"
        val is_keyword = keywords.contains(new_name)
        expect(is_keyword).to_equal(true)

    it "allows valid identifier as new_name":
        val keywords = ["fn", "class", "struct", "enum", "val", "var", "if", "else", "for", "while", "match", "return", "import", "use", "trait", "impl", "static", "me", "self", "nil", "true", "false"]
        val new_name = "better_name"
        val is_keyword = keywords.contains(new_name)
        expect(is_keyword).to_equal(false)

    it "allows snake_case identifier":
        val keywords = ["fn", "class", "struct", "enum", "val", "var"]
        val new_name = "parse_expression"
        val is_keyword = keywords.contains(new_name)
        expect(is_keyword).to_equal(false)

    it "allows PascalCase identifier":
        val keywords = ["fn", "class", "struct", "enum", "val", "var"]
        val new_name = "TokenParser"
        val is_keyword = keywords.contains(new_name)
        expect(is_keyword).to_equal(false)

# ============================================================================
# Test Group 3: Identifier validation
# ============================================================================

describe "rename identifier validation":
    it "validates new_name is not empty":
        val new_name = ""
        expect(new_name == "").to_equal(true)

    it "validates new_name has no spaces":
        val new_name = "has space"
        val has_space = new_name.contains(" ")
        expect(has_space).to_equal(true)

    it "validates new_name starts with letter or underscore":
        val valid_starts = ["a", "z", "A", "Z", "_"]
        val name = "_private"
        val first = name.substring(0, 1)
        expect(valid_starts).to_contain(first)

    it "validates uppercase start is valid":
        val name = "ClassName"
        val first = name.substring(0, 1)
        val is_upper = first >= "A"
        val is_upper_end = first <= "Z"
        expect(is_upper).to_equal(true)
        expect(is_upper_end).to_equal(true)

    it "validates lowercase start is valid":
        val valid_starts = ["a", "z", "A", "Z", "_"]
        val name = "method_name"
        val first = name.substring(0, 1)
        # "m" is between "a" and "z" so it should be a valid start
        val is_lower = first >= "a"
        expect(is_lower).to_equal(true)

    it "detects name starting with digit as invalid":
        val name = "3invalid"
        val first = name.substring(0, 1)
        val is_digit = first >= "0"
        val is_not_alpha = first < "A"
        val starts_with_digit = is_digit and is_not_alpha
        expect(starts_with_digit).to_equal(true)

    it "detects name with special characters":
        val name = "invalid-name"
        val has_hyphen = name.contains("-")
        expect(has_hyphen).to_equal(true)

    it "detects name with dots":
        val name = "module.name"
        val has_dot = name.contains(".")
        expect(has_dot).to_equal(true)

    it "allows name with underscores":
        val name = "my_var_name"
        val has_space = name.contains(" ")
        val has_hyphen = name.contains("-")
        val has_dot = name.contains(".")
        expect(has_space).to_equal(false)
        expect(has_hyphen).to_equal(false)
        expect(has_dot).to_equal(false)

    it "allows single character name":
        val name = "x"
        val is_valid_length = name.len() > 0
        expect(is_valid_length).to_equal(true)

    it "allows single underscore name":
        val name = "_"
        val is_valid_length = name.len() > 0
        val starts_ok = name.substring(0, 1) == "_"
        expect(is_valid_length).to_equal(true)
        expect(starts_ok).to_equal(true)

# ============================================================================
# Test Group 4: Command construction
# ============================================================================

describe "rename command construction":
    it "builds dry-run rename command":
        val file = "src/test.spl"
        val line = "10"
        val new_name = "renamed"
        var cmd = "timeout 30 bin/simple query rename " + file + " " + line + " --new-name " + new_name + " 2>&1"
        expect(cmd).to_contain("query rename")
        expect(cmd).to_contain("--new-name renamed")

    it "builds command with column":
        val file = "src/test.spl"
        val line = "10"
        val column = "5"
        val new_name = "renamed"
        var cmd = "timeout 30 bin/simple query rename " + file + " " + line + " " + column
        cmd = cmd + " --new-name " + new_name + " 2>&1"
        expect(cmd).to_contain("10 5 --new-name renamed")

    it "preserves long file paths":
        val file = "src/compiler/10.frontend/core/parser.spl"
        val line = "250"
        val new_name = "parse_expr"
        var cmd = "timeout 30 bin/simple query rename " + file + " " + line + " --new-name " + new_name
        expect(cmd).to_contain("src/compiler/10.frontend/core/parser.spl")

    it "handles underscore-prefixed new name":
        val file = "test.spl"
        val line = "1"
        val new_name = "_internal"
        var cmd = "timeout 30 bin/simple query rename " + file + " " + line + " --new-name " + new_name
        expect(cmd).to_contain("--new-name _internal")

    it "handles long snake_case name":
        val file = "test.spl"
        val line = "1"
        val new_name = "parse_expression_from_token_stream"
        var cmd = "timeout 30 bin/simple query rename " + file + " " + line + " --new-name " + new_name
        expect(cmd).to_contain("--new-name parse_expression_from_token_stream")

    it "uses 30 second timeout":
        val cmd = "timeout 30 bin/simple query rename test.spl 1 --new-name x"
        expect(cmd).to_start_with("timeout 30")

    it "redirects stderr to stdout":
        val file = "test.spl"
        val line = "1"
        val new_name = "x"
        var cmd = "timeout 30 bin/simple query rename " + file + " " + line
        cmd = cmd + " --new-name " + new_name + " 2>&1"
        expect(cmd).to_end_with("2>&1")

# ============================================================================
# Test Group 5: Multi-file rename scenarios
# ============================================================================

describe "rename tool multi-file scenarios":
    it "builds command targeting project-wide search":
        val file = "src/lib/common/text/mod.spl"
        val line = "15"
        val new_name = "format_text"
        var cmd = "timeout 30 bin/simple query rename " + file + " " + line + " --new-name " + new_name + " 2>&1"
        expect(cmd).to_contain(file)
        expect(cmd).to_contain("--new-name format_text")

    it "includes src directory in search scope":
        val search_dir = "src/"
        val scope = "src/ --include='*.spl'"
        expect(scope).to_contain(search_dir)

    it "respects word boundaries in search":
        val symbol = "parse"
        val pattern = "\\b" + symbol + "\\b"
        expect(pattern).to_contain("\\b")

    it "distinguishes similar symbol names":
        val symbols = ["parse", "parser", "parse_expr", "parse_stmt"]
        val target = "parse"
        expect(symbols).to_contain(target)
        val count = symbols.len()
        expect(count).to_be_greater_than(1)

    it "handles symbols in different directories":
        val files = ["src/app/cli/main.spl", "src/lib/common/text/mod.spl", "src/compiler/10.frontend/core/parser.spl"]
        expect(files.len()).to_equal(3)

    it "rename in lib affects importers":
        val lib_file = "src/lib/common/text/mod.spl"
        val is_lib = lib_file.contains("src/lib/")
        expect(is_lib).to_equal(true)

    it "rename in compiler affects internal refs only":
        val compiler_file = "src/compiler/10.frontend/core/parser.spl"
        val is_compiler = compiler_file.contains("src/compiler/")
        expect(is_compiler).to_equal(true)

# ============================================================================
# Test Group 6: Special naming conventions
# ============================================================================

describe "rename naming conventions":
    it "preserves snake_case convention":
        val new_name = "process_input"
        val has_underscore = new_name.contains("_")
        val has_uppercase = new_name.contains("P")
        expect(has_underscore).to_equal(true)
        expect(has_uppercase).to_equal(false)

    it "preserves PascalCase convention for types":
        val new_name = "TokenParser"
        val first = new_name.substring(0, 1)
        expect(first).to_equal("T")

    it "allows SCREAMING_SNAKE_CASE for constants":
        val new_name = "MAX_BUFFER_SIZE"
        val has_underscore = new_name.contains("_")
        expect(has_underscore).to_equal(true)

    it "detects mixed convention":
        val new_name = "camelCase"
        val first = new_name.substring(0, 1)
        val is_lower_start = first >= "a"
        expect(is_lower_start).to_equal(true)

    it "handles single-letter names":
        val names = ["x", "y", "z", "i", "n", "k"]
        expect(names.len()).to_equal(6)
        expect(names).to_contain("x")

    it "handles numeric suffix names":
        val new_name = "result2"
        val is_valid = new_name.len() > 0
        expect(is_valid).to_equal(true)

# ============================================================================
# Test Group 7: Destructive operation warnings
# ============================================================================

describe "rename destructive operation safety":
    it "rename is a destructive operation":
        val destructive = ["simple_rename", "simple_document_formatting"]
        expect(destructive).to_contain("simple_rename")

    it "non-destructive tools do not include rename":
        val safe_tools = ["simple_signature_help", "simple_code_actions", "simple_workspace_symbols", "simple_call_hierarchy", "simple_type_hierarchy", "simple_semantic_tokens", "simple_inlay_hints", "simple_selection_range"]
        val has_rename = safe_tools.contains("simple_rename")
        expect(has_rename).to_equal(false)

    it "destructive tools list is exhaustive":
        val destructive = ["simple_rename", "simple_document_formatting"]
        expect(destructive.len()).to_equal(2)

    it "read-only tools outnumber destructive tools":
        val read_only_count = 8
        val destructive_count = 2
        expect(read_only_count).to_be_greater_than(destructive_count)
