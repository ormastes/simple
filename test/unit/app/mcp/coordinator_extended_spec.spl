# Debug Coordinator Extended Tests
# Feature: Debug Backend Coordination - Lifecycle & Error Handling
# Category: MCP, Debug
# Status: Complete
#
# Extended tests for DebugCoordinator routing, backend lifecycle,
# error propagation, and multi-backend scenarios.

use std.spec

# ----------- Inline type definitions -----------

class FrameInfo:
    index: Int
    function_name: String
    file: String
    line: Int
    column: Int

    static fn of(index: Int, function_name: String, file: String, line: Int) -> FrameInfo:
        FrameInfo(index: index, function_name: function_name, file: file, line: line, column: 0)

class VarInfo:
    name: String
    value: String
    type_name: String

    static fn of(name: String, value: String, type_name: String) -> VarInfo:
        VarInfo(name: name, value: value, type_name: type_name)

class LocationInfo:
    file: String
    line: Int
    column: Int
    function_name: String

    static fn at(file: String, line: Int, function_name: String) -> LocationInfo:
        LocationInfo(file: file, line: line, column: 0, function_name: function_name)

# Mock backend with error injection
class MockBackend:
    name_val: String
    attached: Bool
    running: Bool
    paused: Bool
    breakpoints: [String]
    step_count: Int
    last_step_mode: String
    fail_attach: Bool
    fail_run: Bool

    static fn create(name: String) -> MockBackend:
        MockBackend(
            name_val: name,
            attached: false,
            running: false,
            paused: false,
            breakpoints: [],
            step_count: 0,
            last_step_mode: "",
            fail_attach: false,
            fail_run: false
        )

    static fn failing(name: String) -> MockBackend:
        MockBackend(
            name_val: name,
            attached: false,
            running: false,
            paused: false,
            breakpoints: [],
            step_count: 0,
            last_step_mode: "",
            fail_attach: true,
            fail_run: true
        )

impl MockBackend:
    fn name() -> String:
        self.name_val

    me attach(program_path: String, args: [String]) -> Result<Nil, String>:
        if self.fail_attach:
            return Err("Attach failed: {program_path}")
        self.attached = true
        Ok(nil)

    me detach() -> Result<Nil, String>:
        self.attached = false
        self.running = false
        Ok(nil)

    me run() -> Result<Nil, String>:
        if not self.attached:
            return Err("Not attached")
        if self.fail_run:
            return Err("Run failed")
        self.running = true
        Ok(nil)

    me pause() -> Result<Nil, String>:
        self.paused = true
        self.running = false
        Ok(nil)

    me resume() -> Result<Nil, String>:
        self.paused = false
        self.running = true
        Ok(nil)

    me step_over() -> Result<Nil, String>:
        self.step_count = self.step_count + 1
        self.last_step_mode = "over"
        Ok(nil)

    me step_in() -> Result<Nil, String>:
        self.step_count = self.step_count + 1
        self.last_step_mode = "in"
        Ok(nil)

    me step_out() -> Result<Nil, String>:
        self.step_count = self.step_count + 1
        self.last_step_mode = "out"
        Ok(nil)

    me add_breakpoint(file: String, line: Int) -> Result<Int, String>:
        val key = "{file}:{line}"
        self.breakpoints.push(key)
        Ok(self.breakpoints.len())

    me remove_breakpoint(file: String, line: Int) -> Result<Nil, String>:
        val key = "{file}:{line}"
        self.breakpoints = self.breakpoints.filter(\bp: bp != key)
        Ok(nil)

    fn stack_trace() -> Result<[FrameInfo], String>:
        Ok([
            FrameInfo.of(0, "main", "test.spl", 1),
            FrameInfo.of(1, "helper", "test.spl", 10),
            FrameInfo.of(2, "deep", "lib.spl", 42)
        ])

    fn locals() -> Result<[VarInfo], String>:
        Ok([
            VarInfo.of("x", "42", "Int"),
            VarInfo.of("name", "Alice", "String"),
            VarInfo.of("flag", "true", "Bool")
        ])

    fn evaluate(expr: String) -> Result<String, String>:
        if expr == "error":
            return Err("Evaluation failed")
        Ok("(result of {expr})")

    fn current_location() -> Result<LocationInfo, String>:
        Ok(LocationInfo.at("test.spl", 5, "main"))

# ----------- Tests -----------

describe "MockBackend lifecycle":
    context "attach and run":
        it "full lifecycle: attach -> run -> pause -> resume -> detach":
            var backend = MockBackend.create("test")
            backend.attach("prog.spl", [])
            expect(backend.attached).to_equal(true)
            backend.run()
            expect(backend.running).to_equal(true)
            backend.pause()
            expect(backend.paused).to_equal(true)
            expect(backend.running).to_equal(false)
            backend.resume()
            expect(backend.running).to_equal(true)
            expect(backend.paused).to_equal(false)
            backend.detach()
            expect(backend.attached).to_equal(false)
            expect(backend.running).to_equal(false)

        it "fails to run when not attached":
            var backend = MockBackend.create("test")
            match backend.run():
                case Ok(_): expect(false).to_equal(true)
                case Err(e): expect(e).to_equal("Not attached")

    context "error injection":
        it "failing backend returns attach error":
            var backend = MockBackend.failing("fail")
            match backend.attach("prog.spl", []):
                case Ok(_): expect(false).to_equal(true)
                case Err(e): expect(e.contains("Attach failed")).to_equal(true)

        it "failing backend returns run error after forced attach":
            var backend = MockBackend.failing("fail")
            backend.fail_attach = false
            backend.attach("prog.spl", [])
            match backend.run():
                case Ok(_): expect(false).to_equal(true)
                case Err(e): expect(e.contains("Run failed")).to_equal(true)

describe "MockBackend stepping":
    it "step modes are independent":
        var backend = MockBackend.create("test")
        backend.step_over()
        expect(backend.last_step_mode).to_equal("over")
        backend.step_in()
        expect(backend.last_step_mode).to_equal("in")
        backend.step_out()
        expect(backend.last_step_mode).to_equal("out")

    it "step count accumulates correctly":
        var backend = MockBackend.create("test")
        backend.step_over()
        backend.step_over()
        backend.step_in()
        backend.step_out()
        backend.step_over()
        expect(backend.step_count).to_equal(5)

describe "MockBackend breakpoints":
    it "adds breakpoints with increasing ids":
        var backend = MockBackend.create("test")
        match backend.add_breakpoint("test.spl", 10):
            case Ok(id1):
                match backend.add_breakpoint("test.spl", 20):
                    case Ok(id2): expect(id2 > id1).to_equal(true)
                    case Err(_): expect(false).to_equal(true)
            case Err(_): expect(false).to_equal(true)

    it "removes specific breakpoint":
        var backend = MockBackend.create("test")
        backend.add_breakpoint("test.spl", 10)
        backend.add_breakpoint("test.spl", 20)
        backend.add_breakpoint("test.spl", 30)
        backend.remove_breakpoint("test.spl", 20)
        expect(backend.breakpoints.len()).to_equal(2)

    it "remove non-existent breakpoint is safe":
        var backend = MockBackend.create("test")
        backend.add_breakpoint("test.spl", 10)
        backend.remove_breakpoint("other.spl", 99)
        expect(backend.breakpoints.len()).to_equal(1)

    it "clear all breakpoints by removing each":
        var backend = MockBackend.create("test")
        backend.add_breakpoint("a.spl", 1)
        backend.add_breakpoint("b.spl", 2)
        backend.add_breakpoint("c.spl", 3)
        backend.remove_breakpoint("a.spl", 1)
        backend.remove_breakpoint("b.spl", 2)
        backend.remove_breakpoint("c.spl", 3)
        expect(backend.breakpoints.len()).to_equal(0)

describe "MockBackend inspection":
    context "stack trace":
        it "returns three frames":
            val backend = MockBackend.create("test")
            match backend.stack_trace():
                case Ok(frames):
                    expect(frames.len()).to_equal(3)
                case Err(_): expect(false).to_equal(true)

        it "frames have correct indices":
            val backend = MockBackend.create("test")
            match backend.stack_trace():
                case Ok(frames):
                    expect(frames[0].index).to_equal(0)
                    expect(frames[1].index).to_equal(1)
                    expect(frames[2].index).to_equal(2)
                case Err(_): expect(false).to_equal(true)

        it "frames span multiple files":
            val backend = MockBackend.create("test")
            match backend.stack_trace():
                case Ok(frames):
                    expect(frames[0].file).to_equal("test.spl")
                    expect(frames[2].file).to_equal("lib.spl")
                case Err(_): expect(false).to_equal(true)

    context "locals":
        it "returns three variables":
            val backend = MockBackend.create("test")
            match backend.locals():
                case Ok(vars):
                    expect(vars.len()).to_equal(3)
                case Err(_): expect(false).to_equal(true)

        it "variables have correct types":
            val backend = MockBackend.create("test")
            match backend.locals():
                case Ok(vars):
                    expect(vars[0].type_name).to_equal("Int")
                    expect(vars[1].type_name).to_equal("String")
                    expect(vars[2].type_name).to_equal("Bool")
                case Err(_): expect(false).to_equal(true)

        it "variables have correct values":
            val backend = MockBackend.create("test")
            match backend.locals():
                case Ok(vars):
                    expect(vars[0].value).to_equal("42")
                    expect(vars[1].value).to_equal("Alice")
                case Err(_): expect(false).to_equal(true)

    context "evaluate":
        it "evaluates simple expression":
            val backend = MockBackend.create("test")
            match backend.evaluate("x + 1"):
                case Ok(result): expect(result).to_contain("x + 1")
                case Err(_): expect(false).to_equal(true)

        it "returns error for error expression":
            val backend = MockBackend.create("test")
            match backend.evaluate("error"):
                case Ok(_): expect(false).to_equal(true)
                case Err(e): expect(e).to_contain("Evaluation failed")

    context "location":
        it "returns current file and line":
            val backend = MockBackend.create("test")
            match backend.current_location():
                case Ok(loc):
                    expect(loc.file).to_equal("test.spl")
                    expect(loc.line).to_equal(5)
                    expect(loc.function_name).to_equal("main")
                case Err(_): expect(false).to_equal(true)

        it "location has zero column default":
            val backend = MockBackend.create("test")
            match backend.current_location():
                case Ok(loc): expect(loc.column).to_equal(0)
                case Err(_): expect(false).to_equal(true)

describe "FrameInfo":
    it "creates with all fields":
        val f = FrameInfo.of(3, "process", "worker.spl", 99)
        expect(f.index).to_equal(3)
        expect(f.function_name).to_equal("process")
        expect(f.file).to_equal("worker.spl")
        expect(f.line).to_equal(99)
        expect(f.column).to_equal(0)

describe "VarInfo":
    it "stores name value and type":
        val v = VarInfo.of("counter", "100", "Int")
        expect(v.name).to_equal("counter")
        expect(v.value).to_equal("100")
        expect(v.type_name).to_equal("Int")

describe "LocationInfo":
    it "stores file line and function":
        val loc = LocationInfo.at("app.spl", 42, "handle_request")
        expect(loc.file).to_equal("app.spl")
        expect(loc.line).to_equal(42)
        expect(loc.function_name).to_equal("handle_request")
        expect(loc.column).to_equal(0)
