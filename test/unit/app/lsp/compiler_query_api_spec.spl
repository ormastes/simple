# Compiler Query API Integration Tests
#
# Tests the CompilerQueryContext and its integration with the Rust FFI layer.
# This validates parsing, symbol extraction, type checking, and code intelligence.

fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")
import compiler.query_api.{
    CompilerQueryContext,
    Position,
    Location,
    Range,
    Symbol,
    SymbolKind,
    Completion,
    CompletionKind,
    Diagnostic,
    DiagnosticSeverity,
    HoverInfo,
    DefinitionResult
}

describe "CompilerQueryContext":
    describe "Creation and Initialization":
        it "creates a new query context":
            val ctx = CompilerQueryContext.create("/tmp/test_project")

            # Should start with empty caches
            check(ctx.cached_asts.length == 0)
            check(ctx.cached_symbols.length == 0)
            check(ctx.cached_types.length == 0)

            # Should have project root set
            check(ctx.project_root == "/tmp/test_project")

            # Should have incremental enabled by default
            check(ctx.incremental)

        it "creates context with project root":
            val ctx = CompilerQueryContext.create("/path/to/project")

            check(ctx.project_root == "/path/to/project")

    describe "Cache Management":
        it "invalidates file cache":
            val ctx = CompilerQueryContext.create("/tmp/test")

            # Add some fake cache entries
            # (In real implementation, these would be populated by parsing)

            # Invalidate a file
            ctx.invalidate_file("test.spl")

            # Verify cache is cleared for that file
            check(not ctx.cached_asts.contains("test.spl"))

        it "checks cache validity":
            val ctx = CompilerQueryContext.create("/tmp/test")

            # New file - cache not valid
            val valid = ctx.is_cache_valid("nonexistent.spl")
            check(not valid)

    describe "Parsing Integration":
        it "parses source text":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn main():
                print "Hello, World!"
            """

            val result = ctx.parse_source_text(source, "test.spl")

            # Should parse successfully (if parser works)
            # Result is Result<AST, ParseError>
            # Can't assert ok/err without knowing parser state

        it "handles parse errors gracefully":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val invalid_source = """
            fn main(
                # Missing closing paren
            """

            val result = ctx.parse_source_text(invalid_source, "test.spl")

            # Should return an error
            # (Exact behavior depends on parser implementation)

    describe "Symbol Resolution":
        it "extracts symbols from parsed AST":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn hello():
                pass

            class MyClass:
                x: i32
            """

            # Parse source
            val ast_result = ctx.parse_source_text(source, "test.spl")

            # If parsing succeeded, try to extract symbols
            if ast_result.ok.?:
                val ast = ast_result.unwrap()
                val symbol_table = ctx.build_symbol_table(ast)

                # Symbol table should exist
                check(symbol_table != nil)

        it "finds symbol at position":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn hello():
                val x = 5
                print x
            """

            # Parse and build symbol table
            val ast_result = ctx.parse_source_text(source, "test.spl")

            if ast_result.ok.?:
                val ast = ast_result.unwrap()
                val symbol_table = ctx.build_symbol_table(ast)

                # Try to find symbol at position
                val pos = Position(line: 1, column: 8)  # On "hello"
                val symbol_opt = ctx.find_symbol_at_position(symbol_table, pos)

                # May or may not find depending on implementation

    describe "Completions":
        it "provides completions at position":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn main():
                val x = 5
                val y = 10
                # Cursor here: complete x, y
            """

            # Get completions at end of file
            val pos = Position(line: 3, column: 20)
            val completions = ctx.completions_at("test.spl", pos)

            # Should return some completions (keywords, variables, etc.)
            check(completions.length >= 0)

        it "includes keywords in completions":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = "fn main():\n    "

            val pos = Position(line: 1, column: 4)
            val completions = ctx.completions_at("test.spl", pos)

            # Should include keywords like if, while, for, etc.
            # (Exact set depends on implementation)

        it "includes variables in completions":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn main():
                val myVariable = 5
                val result = myV
            """

            val pos = Position(line: 2, column: 25)  # After "myV"
            val completions = ctx.completions_at("test.spl", pos)

            # Should suggest myVariable

    describe "Hover Information":
        it "provides hover info at position":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn add(a: i32, b: i32) -> i32:
                a + b
            """

            # Hover over function name
            val pos = Position(line: 0, column: 3)  # On "add"
            val hover_opt = ctx.hover_at("test.spl", pos)

            # May return hover info (signature, docs)

        it "shows type information in hover":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            val x: i32 = 5
            """

            val pos = Position(line: 0, column: 4)  # On "x"
            val hover_opt = ctx.hover_at("test.spl", pos)

            # Should show type i32

        it "returns None for invalid position":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = "fn main(): pass"

            val pos = Position(line: 10, column: 50)  # Out of bounds
            val hover_opt = ctx.hover_at("test.spl", pos)

            check(not hover_opt.?)

    describe "Go to Definition":
        it "finds definition of symbol":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn hello():
                pass

            fn main():
                hello()  # Go to definition here
            """

            val pos = Position(line: 4, column: 4)  # On "hello" call
            val def_opt = ctx.find_definition("test.spl", pos)

            # Should find definition at line 0

        it "returns None for undefined symbol":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = "fn main(): pass"

            val pos = Position(line: 0, column: 15)  # Random position
            val def_opt = ctx.find_definition("test.spl", pos)

            # May return None

    describe "Find References":
        it "finds all references to symbol":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            val x = 5
            val y = x + 1
            val z = x + 2
            print x
            """

            # Find references to "x"
            val pos = Position(line: 0, column: 4)  # On definition
            val symbol_opt = ctx.symbol_at("test.spl", pos)

            if symbol_opt.?:
                val symbol = symbol_opt.unwrap()
                val refs = ctx.find_references("test.spl", symbol)

                # Should find multiple references

    describe "Diagnostics":
        it "reports parse errors":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val invalid_source = """
            fn main(
                # Missing closing paren
            """

            # Write to a temp file to test diagnostics
            # (In real usage, file would be on disk)

            val diagnostics = ctx.get_diagnostics("test.spl")

            # Should have at least one error

        it "reports type errors":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn main():
                val x: i32 = "hello"  # Type error
            """

            val diagnostics = ctx.get_diagnostics("test.spl")

            # Should report type mismatch

        it "returns empty diagnostics for valid code":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn main():
                val x = 5
                print x
            """

            val diagnostics = ctx.get_diagnostics("test.spl")

            # Should have no errors for valid code

    describe "Document Symbols":
        it "extracts all symbols from document":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn func1(): pass
            fn func2(): pass

            class MyClass:
                x: i32

            enum MyEnum:
                A, B, C
            """

            val symbols = ctx.document_symbols("test.spl")

            # Should find functions, classes, enums

    describe "Performance and Caching":
        it "caches parsed ASTs":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = "fn main(): pass"

            # Parse once
            val result1 = ctx.parse_source_text(source, "test.spl")

            # Parse again - should use cache
            val result2 = ctx.parse_source_text(source, "test.spl")

            # Both should succeed (if parser works)

        it "invalidates cache on file change":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source1 = "fn main(): pass"

            # Parse first version
            ctx.parse_source_text(source1, "test.spl")

            # Invalidate
            ctx.invalidate_file("test.spl")

            # Parse new version
            val source2 = "fn main(): print 'hello'"
            ctx.parse_source_text(source2, "test.spl")

            # Should parse the new version

describe "FFI Integration":
    describe "Parse Source FFI":
        it "calls rt_parse_source successfully":
            import app.io.rt_parse_source

            val source = "fn main(): pass"

            val result = rt_parse_source(source, "test.spl")

            # Should return a Result
            # (Success depends on parser implementation)

    describe "Symbol Table FFI":
        it "builds symbol table from AST":
            import app.io.{rt_parse_source, rt_build_symbol_table}

            val source = "fn hello(): pass"

            val ast_result = rt_parse_source(source, "test.spl")

            if ast_result.ok.?:
                val ast = ast_result.unwrap()
                val symbol_table = rt_build_symbol_table(ast)

                # Should create symbol table
                check(symbol_table != nil)

    describe "Symbol Lookup FFI":
        it "finds symbol at position":
            import app.io.{rt_parse_source, rt_build_symbol_table, rt_find_symbol_at_position}

            val source = """
            fn hello():
                pass
            """

            val ast_result = rt_parse_source(source, "test.spl")

            if ast_result.ok.?:
                val ast = ast_result.unwrap()
                val table = rt_build_symbol_table(ast)

                val pos = Position(line: 0, column: 3)
                val symbol_opt = rt_find_symbol_at_position(table, pos)

                # May find "hello" function

    describe "Type Checking FFI":
        it "type checks AST":
            import app.io.{rt_parse_source, rt_type_check_ast}

            val source = "fn main(): pass"

            val ast_result = rt_parse_source(source, "test.spl")

            if ast_result.ok.?:
                val ast = ast_result.unwrap()
                val errors = rt_type_check_ast(ast)

                # Should return list of type errors (empty for valid code)
                check(errors.length >= 0)

describe "LSP Server Integration":
    describe "Completion Handler":
        it "provides completions via query context":
            val ctx = CompilerQueryContext.create("/tmp/test")

            # Simulate LSP textDocument/completion request
            val uri = "file:///test.spl"
            val position = Position(line: 1, column: 4)

            val completions = ctx.completions_at("test.spl", position)

            # Should return completion items

    describe "Hover Handler":
        it "provides hover info via query context":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val position = Position(line: 0, column: 5)

            val hover_opt = ctx.hover_at("test.spl", position)

            # May return hover info

    describe "Definition Handler":
        it "finds definition via query context":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val position = Position(line: 2, column: 4)

            val def_opt = ctx.find_definition("test.spl", position)

            # May find definition

    describe "Diagnostics Handler":
        it "provides diagnostics via query context":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val diagnostics = ctx.get_diagnostics("test.spl")

            # Should return list of diagnostics

describe "Real Code Integration":
    describe "Simple Language Files":
        it "parses Simple standard library":
            val ctx = CompilerQueryContext.create("/path/to/simple/src")

            # Try parsing a real Simple file
            val source = """
            fn factorial(n: i64) -> i64:
                if n <= 1:
                    1
                else:
                    n * factorial(n - 1)
            """

            val result = ctx.parse_source_text(source, "factorial.spl")

            # Should parse successfully

        it "extracts symbols from realistic code":
            val ctx = CompilerQueryContext.create("/path/to/simple/src")

            val source = """
            class Point:
                x: f64
                y: f64

                fn distance() -> f64:
                    (self.x * self.x + self.y * self.y).sqrt()

            fn main():
                val p = Point(x: 3.0, y: 4.0)
                print p.distance()
            """

            val symbols = ctx.document_symbols("example.spl")

            # Should extract Point class, distance method, main function

describe "Error Handling":
    describe "Parse Errors":
        it "handles syntax errors gracefully":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val bad_syntax = "fn main() invalid print"

            val result = ctx.parse_source_text(bad_syntax, "test.spl")

            # Should return Err(ParseError)
            if result.err.?:
                val error = result.err.unwrap()
                # Should have line, column, message

    describe "Invalid Positions":
        it "handles out-of-bounds positions":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = "fn main(): pass"

            val pos = Position(line: 100, column: 100)

            val symbol_opt = ctx.symbol_at("test.spl", pos)

            check(not symbol_opt.?)

    describe "Missing Files":
        it "handles missing file gracefully":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val diagnostics = ctx.get_diagnostics("nonexistent.spl")

            # Should handle gracefully (empty or error)

describe "Concurrency and Thread Safety":
    describe "Concurrent Access":
        it "handles concurrent parse requests":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = "fn main(): pass"

            # Multiple concurrent parses
            val result1 = ctx.parse_source_text(source, "test1.spl")
            val result2 = ctx.parse_source_text(source, "test2.spl")

            # Both should work independently

        it "handles concurrent completions":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val pos1 = Position(line: 1, column: 5)
            val pos2 = Position(line: 2, column: 10)

            val comp1 = ctx.completions_at("test.spl", pos1)
            val comp2 = ctx.completions_at("test.spl", pos2)

            # Both should work independently
