"""
LSP Protocol Types Implementation Tests
Feature: LSP Protocol Type Validation
Category: LSP, Type System
Status: Complete

Unit tests for LSP protocol type implementations.
Verifies that protocol types work correctly without imports.
"""

# Local protocol type definitions (matching src/app/lsp/protocol.spl)

struct Position:
    line: i64
    character: i64

struct Range:
    start: Position
    end: Position

enum DiagnosticSeverity:
    Error
    Warning
    Information
    Hint

struct Diagnostic:
    range: Range
    severity: DiagnosticSeverity
    message: str
    source: str

describe "Position Type":
    """
    Tests for LSP Position type implementation.
    """

    it "creates position with line and character":
        val pos = Position { line: 10, character: 5 }
        expect pos.line == 10
        expect pos.character == 5

    it "handles zero-based positions":
        val origin = Position { line: 0, character: 0 }
        expect origin.line == 0
        expect origin.character == 0

    it "handles large line numbers":
        val large_pos = Position { line: 10000, character: 100 }
        expect large_pos.line == 10000
        expect large_pos.character == 100

    it "compares positions":
        val pos1 = Position { line: 5, character: 10 }
        val pos2 = Position { line: 5, character: 10 }
        val pos3 = Position { line: 5, character: 15 }

        expect pos1.line == pos2.line
        expect pos1.character == pos2.character
        expect pos3.character != pos1.character

describe "Range Type":
    """
    Tests for LSP Range type implementation.
    """

    it "creates range from two positions":
        val start = Position { line: 0, character: 0 }
        val end = Position { line: 0, character: 10 }
        val range = Range { start: start, end: end }

        expect range.start.line == 0
        expect range.end.character == 10

    it "handles single-line ranges":
        val start = Position { line: 5, character: 0 }
        val end = Position { line: 5, character: 20 }
        val range = Range { start: start, end: end }

        expect range.start.line == range.end.line

    it "handles multi-line ranges":
        val start = Position { line: 5, character: 0 }
        val end = Position { line: 10, character: 20 }
        val range = Range { start: start, end: end }

        expect range.start.line < range.end.line

    it "calculates range length for single line":
        val start = Position { line: 0, character: 5 }
        val end = Position { line: 0, character: 15 }
        val range = Range { start: start, end: end }

        val length = end.character - start.character
        expect length == 10

describe "DiagnosticSeverity Enum":
    """
    Tests for LSP DiagnosticSeverity enum.
    """

    it "has Error severity":
        val severity = DiagnosticSeverity.Error
        match severity:
            case DiagnosticSeverity.Error:
                expect true
            _ =>
                fail "Should be Error"

    it "has Warning severity":
        val severity = DiagnosticSeverity.Warning
        match severity:
            case DiagnosticSeverity.Warning:
                expect true
            _ =>
                fail "Should be Warning"

    it "has Information severity":
        val severity = DiagnosticSeverity.Information
        match severity:
            case DiagnosticSeverity.Information:
                expect true
            _ =>
                fail "Should be Information"

    it "has Hint severity":
        val severity = DiagnosticSeverity.Hint
        match severity:
            case DiagnosticSeverity.Hint:
                expect true
            _ =>
                fail "Should be Hint"

    it "distinguishes between severities":
        val error = DiagnosticSeverity.Error
        val warning = DiagnosticSeverity.Warning

        match error:
            case DiagnosticSeverity.Error:
                expect true
            case DiagnosticSeverity.Warning:
                fail "Should be Error, not Warning"
            _ =>
                fail "Unexpected severity"

describe "Diagnostic Type":
    """
    Tests for LSP Diagnostic message type.
    """

    it "creates diagnostic with all fields":
        val range = Range {
            start: Position { line: 0, character: 0 },
            end: Position { line: 0, character: 5 }
        }
        val diag = Diagnostic {
            range: range,
            severity: DiagnosticSeverity.Error,
            message: "Undefined variable",
            source: "simple-compiler"
        }

        expect diag.message == "Undefined variable"
        expect diag.source == "simple-compiler"

    it "creates error diagnostic":
        val range = Range {
            start: Position { line: 5, character: 10 },
            end: Position { line: 5, character: 15 }
        }
        val error = Diagnostic {
            range: range,
            severity: DiagnosticSeverity.Error,
            message: "Syntax error",
            source: "parser"
        }

        match error.severity:
            case DiagnosticSeverity.Error:
                expect true
            _ =>
                fail "Should be Error severity"

    it "creates warning diagnostic":
        val range = Range {
            start: Position { line: 10, character: 0 },
            end: Position { line: 10, character: 20 }
        }
        val warning = Diagnostic {
            range: range,
            severity: DiagnosticSeverity.Warning,
            message: "Unused variable",
            source: "linter"
        }

        match warning.severity:
            case DiagnosticSeverity.Warning:
                expect true
            _ =>
                fail "Should be Warning severity"

    it "stores diagnostic message":
        val range = Range {
            start: Position { line: 0, character: 0 },
            end: Position { line: 0, character: 1 }
        }
        val diag = Diagnostic {
            range: range,
            severity: DiagnosticSeverity.Information,
            message: "Consider using const",
            source: "advisor"
        }

        expect diag.message.len() > 0
        expect diag.message.contains("const")

describe "Protocol Type Integration":
    """
    Tests for using protocol types together.
    """

    it "builds diagnostic with position and range":
        val pos_start = Position { line: 5, character: 0 }
        val pos_end = Position { line: 5, character: 10 }
        val range = Range { start: pos_start, end: pos_end }
        val diagnostic = Diagnostic {
            range: range,
            severity: DiagnosticSeverity.Error,
            message: "Type mismatch",
            source: "type-checker"
        }

        expect diagnostic.range.start.line == 5
        expect diagnostic.range.end.character == 10
        expect diagnostic.message == "Type mismatch"

    it "creates multiple diagnostics for same range":
        val range = Range {
            start: Position { line: 10, character: 5 },
            end: Position { line: 10, character: 15 }
        }

        val error = Diagnostic {
            range: range,
            severity: DiagnosticSeverity.Error,
            message: "Error 1",
            source: "source1"
        }

        val warning = Diagnostic {
            range: range,
            severity: DiagnosticSeverity.Warning,
            message: "Warning 1",
            source: "source2"
        }

        expect error.range.start.line == warning.range.start.line
        expect error.severity != warning.severity
