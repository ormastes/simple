# Unit tests for BDD DSL module
# Tests describe, context, it, hooks, let, and shared examples

import spec.dsl.{describe, context, it, skip, ignore_it, before_each, after_each, before_all, after_all, let_lazy, get_let, has_let, given, given_lazy, shared_examples, it_behaves_like, include_examples, context_def}
import spec.registry.{get_all_groups, reset_registry, get_shared_examples, get_context}
import spec.{expect}
import spec.matchers.{eq, be_empty, be_nil, gt}
import shell.env

describe "BDD DSL":
    before_each:
        reset_registry()

    context "describe":
        it "registers a top-level example group":
            describe "Calculator":
                pass

            val groups = get_all_groups()
            expect(groups.len()).to eq(1)
            expect(groups[0].description).to eq("Calculator")

        it "can contain nested contexts":
            describe "Calculator":
                context "addition":
                    pass

            val groups = get_all_groups()
            val calc_group = groups[0]
            expect(calc_group.children.len()).to eq(1)
            expect(calc_group.children[0].description).to eq("addition")

        it "can contain multiple nested contexts":
            describe "Calculator":
                context "addition":
                    pass
                context "subtraction":
                    pass

            val groups = get_all_groups()
            expect(groups[0].children.len()).to eq(2)

    context "context":
        it "creates nested example groups within describe":
            describe "Calculator":
                context "when adding":
                    pass

            val groups = get_all_groups()
            expect(groups[0].children.len()).to eq(1)
            expect(groups[0].children[0].description).to eq("when adding")

        it "can be nested multiple levels":
            describe "Calculator":
                context "addition":
                    context "with positive numbers":
                        pass

            val groups = get_all_groups()
            val calc = groups[0]
            val addition = calc.children[0]
            expect(addition.children.len()).to eq(1)
            expect(addition.children[0].description).to eq("with positive numbers")

        it "creates top-level group if called outside describe":
            context "standalone context":
                pass

            val groups = get_all_groups()
            expect(groups.len()).to eq(1)
            expect(groups[0].description).to eq("standalone context")

    context "it":
        it "registers an example within a group":
            describe "Calculator":
                it "adds numbers":
                    pass

            val groups = get_all_groups()
            expect(groups[0].test_examples.len()).to eq(1)
            expect(groups[0].test_examples[0].description).to eq("adds numbers")

        it "can register multiple examples":
            describe "Calculator":
                it "adds numbers":
                    pass
                it "subtracts numbers":
                    pass

            val groups = get_all_groups()
            expect(groups[0].test_examples.len()).to eq(2)

        it "executes the example block when run":
            var executed = false
            describe "Test":
                it "runs the block":
                    executed = true

            val groups = get_all_groups()
            groups[0].test_examples[0].run()
            expect(executed).to eq(true)

    context "skip":
        it "registers a skipped example":
            describe "Test":
                skip "not yet implemented":
                    pass

            val groups = get_all_groups()
            val example = groups[0].test_examples[0]
            expect(example.is_skipped).to eq(true)
            expect(example.is_pending()).to eq(true)

    context "ignore_it":
        ignore_it "registers an ignored example":
            describe "Test":
                ignore_it "takes a long time":
                    pass

            val groups = get_all_groups()
            val example = groups[0].test_examples[0]
            expect(example.is_ignored).to eq(true)

        ignore_it "ignored tests are never run":
            # Ignored tests are intentionally disabled
            describe "Test":
                ignore_it "takes forever":
                    pass

            val groups = get_all_groups()
            val example = groups[0].test_examples[0]
            # Should always be ignored
            expect(example.is_ignored).to eq(true)

    context "Hooks - before_each":
        it "registers a BeforeEach hook":
            describe "Test":
                before_each:
                    pass

            val groups = get_all_groups()
            val hooks = groups[0].get_before_each_hooks()
            expect(hooks.len()).to eq(1)

        it "can register multiple before_each hooks":
            describe "Test":
                before_each:
                    pass
                before_each:
                    pass

            val groups = get_all_groups()
            expect(groups[0].get_before_each_hooks().len()).to eq(2)

    context "Hooks - after_each":
        it "registers an AfterEach hook":
            describe "Test":
                after_each:
                    pass

            val groups = get_all_groups()
            val hooks = groups[0].get_after_each_hooks()
            expect(hooks.len()).to eq(1)

    context "Hooks - before_all":
        it "registers a BeforeAll hook":
            describe "Test":
                before_all:
                    pass

            val groups = get_all_groups()
            val hooks = groups[0].get_before_all_hooks()
            expect(hooks.len()).to eq(1)

    context "Hooks - after_all":
        it "registers an AfterAll hook":
            describe "Test":
                after_all:
                    pass

            val groups = get_all_groups()
            val hooks = groups[0].get_after_all_hooks()
            expect(hooks.len()).to eq(1)

    context "let_lazy":
        it "registers a lazy memoized value":
            describe "Test":
                let_lazy :value, \: 42

            val groups = get_all_groups()
            # let_lazy creates a before_each hook that sets up memoization
            val hooks = groups[0].get_before_each_hooks()
            expect(hooks.len()).to eq(1)

        it "can register multiple lazy values":
            describe "Test":
                let_lazy :value1, \: 42
                let_lazy :value2, \: "hello"

            val groups = get_all_groups()
            expect(groups[0].get_before_each_hooks().len()).to eq(2)

    context "given":
        it "registers an eager setup block as before_each":
            describe "Test":
                given:
                    pass

            val groups = get_all_groups()
            expect(groups[0].get_before_each_hooks().len()).to eq(1)

        it "can register multiple given blocks":
            describe "Test":
                given:
                    pass
                given:
                    pass

            val groups = get_all_groups()
            expect(groups[0].get_before_each_hooks().len()).to eq(2)

    context "given_lazy":
        it "registers a lazy fixture in context definition":
            context_def :test_context:
                given_lazy :data, \: "test data"

            match get_context(:test_context):
                case Some(ctx_def):
                    expect(ctx_def.givens.len()).to eq(1)
                case None:
                    fail("Expected context definition to be registered")

        it "registers a before_each hook in regular context":
            describe "Test":
                given_lazy :user, \: "admin"

            val groups = get_all_groups()
            expect(groups[0].get_before_each_hooks().len()).to eq(1)

    context "context_def":
        it "registers a reusable context definition":
            context_def :admin_user:
                given_lazy :user, \: "admin"

            match get_context(:admin_user):
                case Some(ctx_def):
                    expect(ctx_def.name.to_string()).to eq("admin_user")
                case None:
                    fail("Expected context to be registered")

        it "can contain multiple givens":
            context_def :test_context:
                given:
                    pass
                given_lazy :data, \: "test"

            match get_context(:test_context):
                case Some(ctx_def):
                    expect(ctx_def.givens.len()).to eq(2)
                case None:
                    fail("Expected context to be registered")

    context "shared_examples":
        it "registers a shared example definition":
            shared_examples "stack-like":
                it "supports push":
                    pass

            match get_shared_examples("stack-like"):
                case Some(shared_def):
                    expect(shared_def.name).to eq("stack-like")
                case None:
                    fail("Expected shared example to be registered")

        it "can have a description":
            shared_examples "stack-like", "Container with stack operations":
                pass

            match get_shared_examples("stack-like"):
                case Some(shared_def):
                    match shared_def.description:
                        case Some(desc):
                            expect(desc).to eq("Container with stack operations")
                        case None:
                            fail("Expected description to be set")
                case None:
                    fail("Expected shared example to be registered")

    context "it_behaves_like":
        it "includes shared examples in current context":
            shared_examples "collection-like":
                it "has size":
                    pass

            describe "Array":
                it_behaves_like "collection-like"

            val groups = get_all_groups()
            val array_group = groups[0]
            # it_behaves_like creates a nested context
            expect(array_group.children.len()).to eq(1)
            expect(array_group.children[0].description).to eq("behaves like collection-like")

        it "shared examples have access to parent context":
            shared_examples "addable":
                it "adds numbers":
                    # In real usage, this would access parent context helpers
                    pass

            describe "Calculator":
                it_behaves_like "addable"

            val groups = get_all_groups()
            val calc_group = groups[0]
            val behaves_context = calc_group.children[0]
            expect(behaves_context.test_examples.len()).to eq(1)

    context "include_examples":
        it "is an alias for it_behaves_like":
            shared_examples "enumerable":
                it "supports each":
                    pass

            describe "Array":
                include_examples "enumerable"

            val groups = get_all_groups()
            expect(groups[0].children.len()).to eq(1)
            expect(groups[0].children[0].description).to eq("behaves like enumerable")

    context "Full integration":
        it "supports complex nested structure with hooks and examples":
            describe "Calculator":
                before_all:
                    pass
                before_each:
                    pass

                context "addition":
                    before_each:
                        pass

                    it "adds positive numbers":
                        pass

                    it "adds negative numbers":
                        pass

                context "subtraction":
                    it "subtracts numbers":
                        pass

                after_each:
                    pass
                after_all:
                    pass

            val groups = get_all_groups()
            val calc = groups[0]

            # Check top-level hooks
            expect(calc.get_before_all_hooks().len()).to eq(1)
            expect(calc.get_before_each_hooks().len()).to eq(1)
            expect(calc.get_after_each_hooks().len()).to eq(1)
            expect(calc.get_after_all_hooks().len()).to eq(1)

            # Check nested contexts
            expect(calc.children.len()).to eq(2)

            # Check addition context
            val addition = calc.children[0]
            expect(addition.description).to eq("addition")
            expect(addition.test_examples.len()).to eq(2)
            expect(addition.get_before_each_hooks().len()).to eq(1)

            # Check subtraction context
            val subtraction = calc.children[1]
            expect(subtraction.description).to eq("subtraction")
            expect(subtraction.test_examples.len()).to eq(1)
