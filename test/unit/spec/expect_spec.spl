# Unit tests for BDD Expect module
# Tests Expectation, expect, to, not_to, and expect_raises

import spec.expect.{Expectation, expect, expect_raises, fail}
import spec.matchers.{eq, be, be_nil, gt, lt, be_true, be_false, include, be_empty}
import spec.{describe, context, it, before_each}
import spec.registry.{reset_registry}

describe "BDD Expect":
    before_each:
        reset_registry()

    context "Expectation class":
        it "creates an expectation with actual value":
            val expectation = Expectation.new(42)
            expect(expectation.actual).to eq(42)
            expect(expectation.negated).to eq(false)

        it "starts with negated as false":
            val expectation = Expectation.new("test")
            expect(expectation.negated).to eq(false)

    context "expect function":
        it "creates an Expectation wrapping the value":
            val expectation = expect(42)
            expect(expectation.actual).to eq(42)

        it "works with different types":
            val int_exp = expect(42)
            expect(int_exp.actual).to eq(42)

            val str_exp = expect("hello")
            expect(str_exp.actual).to eq("hello")

            val arr_exp = expect([1, 2, 3])
            expect(arr_exp.actual.len()).to eq(3)

    context "to - positive assertions":
        it "passes when matcher succeeds":
            # This should not panic
            expect(42).to eq(42)

        it "passes with gt matcher":
            expect(10).to gt(5)

        it "passes with lt matcher":
            expect(5).to lt(10)

        it "passes with be_true matcher":
            expect(true).to be_true()

        it "passes with be_empty matcher":
            expect([]).to be_empty()

        it "passes with include matcher":
            expect([1, 2, 3]).to include(2)

        # Note: Testing failure cases would require catching panics
        # which Simple doesn't support yet

    context "not_to - negative assertions":
        it "sets negated flag and calls to":
            # Create expectation manually to test negated flag
            val expectation = Expectation.new(42)
            expectation.not_to(eq(10))
            # If we get here without panic, negation worked

        it "passes when negated matcher fails":
            expect(42).not_to eq(10)

        it "passes with negated gt matcher":
            expect(5).not_to gt(10)

        it "passes with negated be_true matcher":
            expect(false).not_to be_true()

        it "passes with negated be_empty matcher":
            expect([1, 2, 3]).not_to be_empty()

        it "passes with negated include matcher":
            expect([1, 2, 3]).not_to include(5)

    context "Chaining expectations":
        it "can chain multiple expectations":
            val value = 42
            expect(value).to eq(42)
            expect(value).to gt(40)
            expect(value).to lt(50)

        it "can mix positive and negative expectations":
            val value = 42
            expect(value).to eq(42)
            expect(value).not_to eq(10)
            expect(value).to gt(40)
            expect(value).not_to gt(100)

    context "expect_raises":
        it "accepts error type and block":
            # Note: Simple doesn't support exceptions yet
            # This test verifies the function signature
            var executed = false
            expect_raises(ValueError, \:
                executed = true
            )
            # The block should execute
            expect(executed).to eq(true)

    context "fail helper":
        it "can be called with a message":
            # Note: Testing this would require catching panics
            # Just verify it's callable
            # fail("test message")  # Would panic
            pass

    context "Complex assertions":
        it "handles nested structures":
            val data = {
                name: "Alice",
                age: 30,
                scores: [95, 87, 92]
            }
            expect(data.name).to eq("Alice")
            expect(data.age).to gt(25)
            expect(data.scores).to include(95)
            expect(data.scores.len()).to eq(3)

        it "handles Option types":
            val some_value = Some(42)
            val none_value = None

            expect(some_value).not_to be_nil()
            expect(none_value).to be_nil()

        it "handles comparisons":
            val a = 10
            val b = 20
            val c = 10

            expect(a).to eq(c)
            expect(a).not_to eq(b)
            expect(a).to lt(b)
            expect(b).to gt(a)
            expect(a).to lt(b)
            expect(b).not_to lt(a)

    context "Edge cases":
        it "handles zero values":
            expect(0).to eq(0)
            expect(0).to lt(1)
            expect(0).to gt(-1)

        it "handles empty collections":
            expect([]).to be_empty()
            expect([]).not_to include(1)

        it "handles empty strings":
            expect("").to eq("")
            expect("").not_to eq("hello")

        it "handles None values":
            expect(None).to be_nil()
            expect(Some(42)).not_to be_nil()

    context "Type safety":
        it "works with integers":
            expect(42).to eq(42)
            expect(42).to gt(40)

        it "works with strings":
            expect("hello").to eq("hello")
            expect("hello").not_to eq("world")

        it "works with booleans":
            expect(true).to be_true()
            expect(false).to be_false()

        it "works with arrays":
            expect([1, 2, 3]).to include(2)
            expect([]).to be_empty()

        it "works with Option types":
            expect(Some(42)).not_to be_nil()
            expect(None).to be_nil()

    context "Fluent API":
        it "reads naturally with to":
            expect(10).to gt(5)
            expect(5).to lt(10)
            expect(true).to be_true()
            expect([1, 2, 3]).to include(2)

        it "reads naturally with not_to":
            expect(10).not_to eq(5)
            expect(5).not_to gt(10)
            expect(false).not_to be_true()
            expect([1, 2, 3]).not_to include(5)

    context "Integration with matchers":
        it "works with equality matcher":
            expect(42).to eq(42)
            expect(42).not_to eq(10)

        it "works with comparison matchers":
            expect(10).to gt(5)
            expect(10).to lt(20)
            expect(10).not_to gt(15)

        it "works with collection matchers":
            expect([1, 2, 3]).to include(2)
            expect([]).to be_empty()
            expect([1, 2]).not_to be_empty()

        it "works with boolean matchers":
            expect(true).to be_true()
            expect(false).to be_false()
            expect(false).not_to be_true()

        it "works with nil matcher":
            expect(None).to be_nil()
            expect(Some(42)).not_to be_nil()
