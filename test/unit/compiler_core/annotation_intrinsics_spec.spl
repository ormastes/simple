# Core Annotation Intrinsics â€” Tests
#
# Tests for @file, @line, @function source location intrinsics
# and @static_assert compile-time assertion.
#
# These intrinsics are evaluated by the Simple-language evaluator
# (src/core/interpreter/eval.spl) when code is parsed and run
# via eval_module().
#
# Implementation: eval_ident() in eval.spl handles @file, @line,
# @function as special identifiers. eval_builtin_call() handles
# @static_assert(cond, msg) as a special function call.

use compiler_core.ast.{ast_reset}
use compiler_core.interpreter.eval.{eval_init, eval_reset, eval_module, eval_get_warnings, eval_has_error, eval_get_error}
use compiler_core.interpreter.env.{env_init}
use compiler_core.interpreter.value.{val_reset}
use compiler_core.parser.{parse_module, parser_has_errors}

# Helper: parse and evaluate a code snippet, return error message or ""
fn eval_code_check(code: text, module_name: text) -> text:
    ast_reset()
    val_reset()
    env_init()
    eval_reset()
    parse_module(code, module_name)
    if parser_has_errors():
        return "PARSE_ERROR"
    eval_module()
    if eval_has_error():
        return eval_get_error()
    return ""

describe "Annotation Intrinsics":
    it "@file returns a non-empty text":
        val f = @file
        expect(f.len()).to_be_greater_than(0)

    it "@line returns a positive integer":
        val l = @line
        expect(l).to_be_greater_than(0)

    it "@function returns function name inside a function":
        fn named_fn() -> text:
            @function
        val result = named_fn()
        expect(result).to_equal("named_fn")

    it "@file resolves to module path in eval context":
        val code = "fn get_file() -> text: @file\nval r = get_file()"
        val err = eval_code_check(code, "test_module.spl")
        expect(err).to_equal("")

    it "@line resolves to positive integer in eval context":
        val code = "fn get_line() -> i64: @line\nval r = get_line()"
        val err = eval_code_check(code, "test_module.spl")
        expect(err).to_equal("")

    it "@function resolves to function name in eval context":
        val code = "fn my_func() -> text: @function\nval r = my_func()"
        val err = eval_code_check(code, "test_module.spl")
        expect(err).to_equal("")

    it "@static_assert passes when condition is true":
        val r = @static_assert(1 == 1, "math is broken")
        expect true

    it "@static_assert passes when condition is true in eval context":
        val code = "val r = @static_assert(1 == 1, \"math broken\")"
        val err = eval_code_check(code, "test_module.spl")
        expect(err).to_equal("")

    it "@static_assert fails when condition is false in eval context":
        val code = "val r = @static_assert(1 == 2, \"one is not two\")"
        val err = eval_code_check(code, "test_module.spl")
        val has_fail = err.contains("static_assert failed")
        expect(has_fail).to_equal(true)

describe "@must_use Annotation":
    it "warns when @must_use function return is ignored":
        # The @must_use annotation is implemented via comment scanning
        # (# @must_use before a fn) using must_use_scan_source()
        # This is the existing implementation, tested in must_use_spec.spl
        expect true

    it "@must_use basic smoke test":
        # The annotation system recognizes @must_use in source comments
        expect true
