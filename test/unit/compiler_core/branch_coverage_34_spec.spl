# # Branch Coverage Test Suite - Struct Arrays & Nested Types
#
# **Feature IDs:** #BRANCH #STRUCT_ARRAY #NESTED_TYPES
# **Category:** Testing
# **Status:** Implemented
#
# ## Overview
#
# Tests struct arrays and nested type structures to cover
# emit_array_literal_pushes (lines 1901, 1911) and array_elem_stype (line 416).

fn check(condition: bool):
    expect(condition).to_equal(true)

describe "Struct Arrays":
    it "array of simple structs":
        struct Point:
            x: i64
            y: i64

        val points = [Point(x: 1, y: 2), Point(x: 3, y: 4)]
        check(points.len() == 2)
        check(points[0].x == 1)
        check(points[1].y == 4)

    it "array of structs with multiple fields":
        struct Data:
            id: i64
            value: i64
            active: bool

        val items = [
            Data(id: 1, value: 100, active: true),
            Data(id: 2, value: 200, active: false)
        ]
        check(items.len() == 2)
        check(items[0].active)
        check(not items[1].active)

    it "empty struct array":
        struct Empty:
            pass

        val arr: [Empty] = []
        check(arr.len() == 0)

describe "Nested Arrays":
    it "2d integer array":
        val arr2d: [[i64]] = [[1, 2], [3, 4], [5, 6]]
        check(arr2d.len() == 3)
        check(arr2d[0].len() == 2)
        check(arr2d[0][0] == 1)
        check(arr2d[2][1] == 6)

    it "3d array":
        val arr3d: [[[i64]]] = [[[1, 2]], [[3, 4]]]
        check(arr3d.len() == 2)
        check(arr3d[0][0][0] == 1)

    it "jagged arrays":
        val jagged = [[1], [2, 3], [4, 5, 6]]
        check(jagged[0].len() == 1)
        check(jagged[1].len() == 2)
        check(jagged[2].len() == 3)

    it "nested array of strings":
        val strs: [[text]] = [["a", "b"], ["c", "d"]]
        check(strs[0][0] == "a")
        check(strs[1][1] == "d")

describe "Arrays of Optional Types":
    it "optional integer array":
        val opts: [i64?] = [Some(1), nil, Some(3)]
        check(opts.len() == 3)
        check(opts[0].?)
        check(not opts[1].?)
        check(opts[2].?)

    it "optional struct array":
        struct Value:
            n: i64

        val items: [Value?] = [Some(Value(n: 1)), nil]
        check(items[0].?)
        check(not items[1].?)

describe "Complex Nested Structures":
    it "array of arrays of optionals":
        val complex: [[i64?]] = [[Some(1), nil], [Some(2), Some(3)]]
        check(complex[0][0].?)
        check(not complex[0][1].?)

    it "struct containing arrays":
        struct Container:
            values: [i64]

        val c = Container(values: [1, 2, 3])
        check(c.values.len() == 3)

    it "nested struct array":
        struct Inner:
            x: i64

        struct Outer:
            inner: Inner

        val items = [Outer(inner: Inner(x: 1)), Outer(inner: Inner(x: 2))]
        check(items[0].inner.x == 1)

describe "Array Element Type Extraction":
    it "simple type arrays":
        val ints: [i64] = [1, 2, 3]
        val floats: [f64] = [1.0, 2.0]
        val bools: [bool] = [true, false]
        check(ints.len() > 0)
        check(floats.len() > 0)
        check(bools.len() > 0)

    it "text arrays":
        val texts: [text] = ["a", "b", "c"]
        check(texts[0] == "a")

describe "Array Literal Initialization":
    it "mixed expressions in array":
        val x = 5
        val arr = [x, x + 1, x + 2, x * 2]
        check(arr[0] == 5)
        check(arr[1] == 6)
        check(arr[3] == 10)

    it "nested literals":
        val nested = [
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
        ]
        check(nested[1][1] == 5)

    it "deep nesting":
        val deep = [
            [[1, 2], [3, 4]],
            [[5, 6], [7, 8]]
        ]
        check(deep[0][0][0] == 1)
        check(deep[1][1][1] == 8)
