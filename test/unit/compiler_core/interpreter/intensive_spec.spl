describe "Intensive":
    it "skipped":
        skip("imports compiler modules - causes OOM via numbered directory resolution")

# # Core Interpreter â€” Intensive Unit Tests
# use compiler.core.interpreter.value.*
# use compiler.core.interpreter.env.*
# use compiler.core.interpreter.ops.*
# 
# 
# describe "core.interpreter.value (intensive)":
#     it "covers value kinds and truthiness":
#         val_reset()
#         val nil_id = val_make_nil()
#         expect(val_is_truthy(nil_id)).to_equal(false)
# 
#         val bool_t = val_make_bool(true)
#         val bool_f = val_make_bool(false)
#         expect(val_is_truthy(bool_t)).to_equal(true)
#         expect(val_is_truthy(bool_f)).to_equal(false)
# 
#         val int1 = val_make_int(1)
#         val int0 = val_make_int(0)
#         expect(val_is_truthy(int1)).to_equal(true)
#         expect(val_is_truthy(int0)).to_equal(false)
# 
#         val f1 = val_make_float(1.25)
#         val f0 = val_make_float(0.0)
#         expect(val_is_truthy(f1)).to_equal(true)
#         expect(val_is_truthy(f0)).to_equal(false)
# 
#         val t1 = val_make_text("x")
#         val t0 = val_make_text("")
#         expect(val_is_truthy(t1)).to_equal(true)
#         expect(val_is_truthy(t0)).to_equal(false)
# 
#         val empty_arr = val_make_array([])
#         val non_empty = val_make_array([val_make_int(1)])
#         expect(val_is_truthy(empty_arr)).to_equal(false)
#         expect(val_is_truthy(non_empty)).to_equal(true)
# 
#         val s = val_make_struct("Point", ["x"], [val_make_int(1)])
#         expect(val_is_truthy(s)).to_equal(true)
#         val fnv = val_make_function("f", 0)
#         expect(val_is_truthy(fnv)).to_equal(true)
# 
#     it "covers struct field access and mutation":
#         val_reset()
#         val s = val_make_struct("Point", ["x", "y"], [val_make_int(1), val_make_int(2)])
#         val vx = val_struct_get_field(s, "x")
#         expect(val_get_int(vx)).to_equal(1)
#         val vy = val_struct_get_field(s, "y")
#         expect(val_get_int(vy)).to_equal(2)
#         val missing = val_struct_get_field(s, "z")
#         expect(missing).to_equal(VAL_NONE)
#         val_struct_set_field(s, "x", val_make_int(42))
#         val vx2 = val_struct_get_field(s, "x")
#         expect(val_get_int(vx2)).to_equal(42)
# 
#     it "covers value to text and equality":
#         val_reset()
#         val a = val_make_int(3)
#         val b = val_make_int(3)
#         val c = val_make_int(4)
#         expect(val_equals(a, b)).to_equal(true)
#         expect(val_equals(a, c)).to_equal(false)
#         val arr = val_make_array([val_make_int(1), val_make_int(2)])
#         expect(val_to_text(arr)).to_equal("[1, 2]")
#         val s = val_make_struct("Point", ["x"], [val_make_int(1)])
#         expect(val_to_text(s).contains("Point")).to_equal(true)
#         val fnv = val_make_function("f", 0)
#         expect(val_to_text(fnv).contains("<fn")).to_equal(true)
#         val unk = val_alloc(999)
#         expect(val_kind_name(val_get_kind(unk))).to_equal("unknown")
#         expect(val_to_text(unk)).to_equal("unknown")
# 
#     it "covers JIT bridge accessors":
#         val_reset()
#         val i = core_val_make_int(7)
#         expect(core_val_get_int(i)).to_equal(7)
#         val s = core_val_make_string("hi")
#         expect(core_val_get_string(s)).to_equal("hi")
#         # Wrong type
#         expect(core_val_get_int(s)).to_equal(0)
#         expect(core_val_get_string(i)).to_equal("")
# 
# 
# describe "core.interpreter.env (intensive)":
#     it "covers scope and globals":
#         env_init()
#         env_define("x", val_make_int(1))
#         expect(val_get_int(env_lookup("x"))).to_equal(1)
#         env_define("x", val_make_int(2))
#         expect(val_get_int(env_lookup("x"))).to_equal(2)
#         env_push_scope()
#         env_define("y", val_make_int(3))
#         expect(val_get_int(env_lookup("y"))).to_equal(3)
#         expect(val_get_int(env_lookup("x"))).to_equal(2)
#         env_pop_scope()
#         expect(env_lookup("y")).to_equal(VAL_NONE)
#         env_define_global("g", val_make_int(9))
#         expect(val_get_int(env_lookup_global("g"))).to_equal(9)
#         expect(val_get_int(env_lookup("g"))).to_equal(9)
# 
#     it "covers assignment failure and depth pop":
#         env_init()
#         env_define("x", val_make_int(1))
#         expect(env_assign("x", val_make_int(2))).to_equal(true)
#         expect(env_assign("missing", val_make_int(3))).to_equal(false)
#         # popping at depth 1 should be a no-op
#         env_pop_scope()
#         expect(env_scope_depth()).to_equal(1)
# 
# 
# describe "core.interpreter.ops (intensive)":
#     it "covers arithmetic and errors":
#         val_reset()
#         ops_clear_error()
#         val a = val_make_int(10)
#         val b = val_make_int(3)
#         val f = val_make_float(1.5)
#         val t = val_make_text("hi")
#         expect(val_get_int(val_add(a, b))).to_equal(13)
#         expect(val_get_float(val_add(a, f)) > 0.0).to_equal(true)
#         expect(val_get_float(val_add(f, a)) > 0.0).to_equal(true)
#         expect(val_get_float(val_add(f, val_make_float(2.5)))).to_equal(4.0)
#         expect(val_get_text(val_add(t, val_make_text("!")))).to_equal("hi!")
#         val bad_add = val_add(t, a)
#         expect(bad_add).to_equal(VAL_NONE)
#         expect(ops_get_error().contains("cannot add")).to_equal(true)
# 
#         ops_clear_error()
#         expect(val_get_int(val_sub(a, b))).to_equal(7)
#         val bad_sub = val_sub(a, f)
#         expect(bad_sub).to_equal(VAL_NONE)
#         expect(ops_get_error().contains("cannot subtract")).to_equal(true)
# 
#         ops_clear_error()
#         expect(val_get_int(val_mul(a, b))).to_equal(30)
#         val bad_mul = val_mul(a, f)
#         expect(bad_mul).to_equal(VAL_NONE)
#         expect(ops_get_error().contains("cannot multiply")).to_equal(true)
# 
#         ops_clear_error()
#         expect(val_get_int(val_div(a, b))).to_equal(3)
#         val div0 = val_div(a, val_make_int(0))
#         expect(div0).to_equal(VAL_NONE)
#         expect(ops_get_error().contains("division by zero")).to_equal(true)
# 
#         ops_clear_error()
#         expect(val_get_int(val_mod(a, b))).to_equal(1)
#         val mod0 = val_mod(a, val_make_int(0))
#         expect(mod0).to_equal(VAL_NONE)
#         expect(ops_get_error().contains("modulo by zero")).to_equal(true)
# 
#     it "covers comparisons and logical ops":
#         val_reset()
#         ops_clear_error()
#         val a = val_make_int(1)
#         val b = val_make_int(2)
#         val fa = val_make_float(1.0)
#         val fb = val_make_float(2.0)
#         val ta = val_make_text("a")
#         val tb = val_make_text("b")
#         expect(val_get_bool(val_lt(a, b))).to_equal(true)
#         expect(val_get_bool(val_gt(b, a))).to_equal(true)
#         expect(val_get_bool(val_lteq(a, a))).to_equal(true)
#         expect(val_get_bool(val_gteq(b, a))).to_equal(true)
#         expect(val_get_bool(val_lt(fa, fb))).to_equal(true)
#         expect(val_get_bool(val_gt(fb, fa))).to_equal(true)
#         expect(val_get_bool(val_lt(ta, tb))).to_equal(true)
#         val bad_cmp = val_lt(a, ta)
#         expect(bad_cmp).to_equal(VAL_NONE)
#         expect(ops_get_error().contains("cannot compare")).to_equal(true)
# 
#         val andv = val_and(val_make_bool(true), val_make_bool(false))
#         expect(val_get_bool(andv)).to_equal(false)
#         val orv = val_or(val_make_bool(true), val_make_bool(false))
#         expect(val_get_bool(orv)).to_equal(true)
#         val notv = val_not(val_make_bool(true))
#         expect(val_get_bool(notv)).to_equal(false)
# 
#     it "covers unary, binary, and compound dispatch":
#         val_reset()
#         ops_clear_error()
#         val a = val_make_int(5)
#         val b = val_make_int(3)
#         expect(val_get_int(val_unary_op(61, a))).to_equal(-5)  # TOK_MINUS
#         val bad_un = val_unary_op(999, a)
#         expect(bad_un).to_equal(VAL_NONE)
#         expect(ops_get_error().contains("unknown unary operator")).to_equal(true)
# 
#         ops_clear_error()
#         expect(val_get_int(val_binary_op(60, a, b))).to_equal(8)
#         val bad_bin = val_binary_op(999, a, b)
#         expect(bad_bin).to_equal(VAL_NONE)
#         expect(ops_get_error().contains("unknown binary operator")).to_equal(true)
# 
#         ops_clear_error()
#         expect(val_get_int(val_compound_op(101, a, b))).to_equal(8)
#         val bad_cmpd = val_compound_op(999, a, b)
#         expect(bad_cmpd).to_equal(VAL_NONE)
#         expect(ops_get_error().contains("unknown compound operator")).to_equal(true)
