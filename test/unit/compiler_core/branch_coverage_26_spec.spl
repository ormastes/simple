"""
# Branch Coverage Test Suite - Parser Error Paths

**Feature IDs:** #BRANCH #PARSER #ERROR_HANDLING
**Category:** Testing
**Status:** Implemented

## Overview

Tests error handling and edge case branches in parser.
Improves seed compiler coverage by exercising error paths.
"""

use std.spec.{check}
use std.text.{NL}

describe "Parser Error Handling Coverage":
    it "handles empty input gracefully":
        # Tests parser with minimal input
        val result = 0 + 0
        check(result == 0)

    it "handles single token":
        val x = 42
        check(x == 42)

    it "handles maximum nesting depth":
        # Deeply nested parentheses
        val result = ((((((((1))))))))
        check(result == 1)

    it "handles long identifier names":
        val very_long_variable_name_that_tests_buffer_limits_in_lexer = 123
        check(very_long_variable_name_that_tests_buffer_limits_in_lexer == 123)

    it "handles edge case - negative zero":
        val x = -0
        check(x == 0)

    it "handles edge case - empty string":
        val s = ""
        check(s.len() == 0)

    it "handles edge case - string with only escape":
        val s = "{NL}"
        check(s.len() > 0)

    it "handles multiple string interpolations":
        val a = 1
        val b = 2
        val s = "{a} and {b}"
        check(s.contains("1"))

    it "handles nested string interpolations":
        val x = 5
        val s = "value: {x + 10}"
        check(s.contains("15"))


describe "Expression Edge Cases Coverage":
    it "handles precedence - multiplication before addition":
        val result = 2 + 3 * 4
        check(result == 14)

    it "handles precedence - parentheses override":
        val result = (2 + 3) * 4
        check(result == 20)

    it "handles unary negation with expression":
        val result = -(5 + 3)
        check(result == -8)

    it "handles double negation":
        val result = -(-10)
        check(result == 10)

    it "handles not operator":
        val result = not false
        check(result == true)

    it "handles not with comparison":
        val result = not (5 > 10)
        check(result == true)

    it "handles chain comparisons - all true":
        val result = 1 < 2 and 2 < 3
        check(result == true)

    it "handles chain comparisons - one false":
        val result = 1 < 2 and 2 > 3
        check(result == false)


describe "Match Statement Edge Cases Coverage":
    it "match with single case":
        val x = 1
        val result = match x:
            1: "one"
            _: "other"
        check(result == "one")

    it "match with no default - nil case":
        val x = Some(5)
        match x:
            Some(v):
                check(v == 5)
            nil:
                check(false)

    it "match with wildcard only":
        val x = 99
        val result = match x:
            _: "always"
        check(result == "always")

    it "match with boolean patterns":
        val b = true
        val result = match b:
            true: 1
            false: 0
        check(result == 1)


describe "Loop Edge Cases Coverage":
    it "for loop with zero iterations":
        var count = 0
        for i in 0..0:
            count = count + 1
        check(count == 0)

    it "for loop with one iteration":
        var count = 0
        for i in 0..1:
            count = count + 1
        check(count == 1)

    it "for loop with negative range handled":
        var count = 0
        for i in 5..5:
            count = count + 1
        check(count == 0)

    it "while loop never enters":
        var executed = false
        while false:
            executed = true
        check(executed == false)

    it "while loop with immediate break":
        var count = 0
        while true:
            count = count + 1
            break
        check(count == 1)

    it "nested loops with break in inner":
        var outer_count = 0
        var inner_count = 0
        for i in 0..3:
            outer_count = outer_count + 1
            for j in 0..3:
                inner_count = inner_count + 1
                break
        check(outer_count == 3)
        check(inner_count == 3)


describe "Optional Chaining Edge Cases Coverage":
    it "optional chain with nil":
        val x: i64? = nil
        val result = x ?? 99
        check(result == 99)

    it "optional chain with value":
        val x: i64? = Some(42)
        val result = x ?? 99
        check(result == 42)

    it "nested optional with nil":
        val x: i64?? = nil
        check(not x.?)

    it "nested optional with some":
        val x: i64?? = Some(Some(10))
        check(x.?)


describe "Array Edge Cases Coverage":
    it "empty array creation":
        val arr = []
        check(arr.len() == 0)

    it "array with one element":
        val arr = [42]
        check(arr.len() == 1)
        check(arr[0] == 42)

    it "array negative index":
        val arr = [1, 2, 3]
        check(arr[-1] == 3)
        check(arr[-2] == 2)

    it "array slice empty result":
        val arr = [1, 2, 3]
        val slice = arr[0..0]
        check(slice.len() == 0)

    it "array slice full":
        val arr = [1, 2, 3]
        val slice = arr[0..3]
        check(slice.len() == 3)


describe "Type Edge Cases Coverage":
    it "boolean true literal":
        check(true == true)

    it "boolean false literal":
        check(false == false)

    it "nil literal type":
        val x = nil
        check(not x.?)

    it "integer zero":
        check(0 == 0)

    it "integer negative":
        check(-1 < 0)

    it "integer positive":
        check(1 > 0)

    it "float zero":
        val f: f64 = 0.0
        check(f == 0.0)

    it "float negative":
        val f: f64 = -1.5
        check(f < 0.0)

    it "float positive":
        val f: f64 = 1.5
        check(f > 0.0)
