describe "File Class Introspection":
    it "skipped":
        skip("imports compiler modules - causes OOM via numbered directory resolution")

# # Tests for File and Class compile-time introspection types
# #
# # Three new @traits queries:
# #   @traits("module_file", "mod.path")      → File struct {path, module_name, exists}
# #   @traits("class_info", "TypeName")       → Class struct {name, module_name, file_path, fields, methods, field_count, method_count}
# #   @traits("module_wildcard", "prefix")    → [File] array of matching modules
# #
# # Parser desugaring:
# #   mod.path.FILE      → @traits("module_file", "mod.path")
# #   TypeName.class     → @traits("class_info", "TypeName")
# #   mod.path.*         → @traits("module_wildcard", "mod.path")
# #
# # NOTE: In interpreter/test-runner mode each spec file counts as 1 passing
# # test (file-load verification). The it blocks below execute fully in compiled mode.
# 
# use compiler.core.ast.{ast_reset}
# use compiler.core.interpreter.eval.{eval_init, eval_reset, eval_module, eval_has_error, eval_get_error}
# use compiler.core.interpreter.env.{env_init}
# use compiler.core.interpreter.value.{val_reset}
# use compiler.core.parser.{parse_module, parser_has_errors}
# 
# # Helper: parse and evaluate a code snippet, return error message or ""
# fn fci_eval_code(code: text) -> text:
#     ast_reset()
#     val_reset()
#     env_init()
#     eval_reset()
#     parse_module(code, "introspection_test.spl")
#     if parser_has_errors():
#         return "PARSE_ERROR"
#     eval_module()
#     if eval_has_error():
#         return eval_get_error()
#     return ""
# 
# # Helper: parse only, return true if no parse errors
# fn fci_parse_ok(code: text) -> bool:
#     ast_reset()
#     parse_module(code, "introspection_test.spl")
#     parser_has_errors() == false
# 
# # ===== module_file query =====
# 
# describe "@traits(module_file) parsing":
#     it "parses @traits(module_file, mod_name) without error":
#         val ok = fci_parse_ok("val f = @traits(\"module_file\", \"std.spec\")")
#         expect(ok).to_equal(true)
# 
#     it "parses module_file result field access without error":
#         val ok = fci_parse_ok("val f = @traits(\"module_file\", \"std.spec\")\nval p = f.path")
#         expect(ok).to_equal(true)
# 
# describe "@traits(module_file) evaluation":
#     it "evaluates module_file for known module without error":
#         val err = fci_eval_code("val f = @traits(\"module_file\", \"std.spec\")\nval p = f.path")
#         expect(err).to_equal("")
# 
#     it "returns File struct with module_name field":
#         val err = fci_eval_code("val f = @traits(\"module_file\", \"std.spec\")\nval mn = f.module_name\nval ok = mn == \"std.spec\"")
#         expect(err).to_equal("")
# 
#     it "non-existent module returns File with exists == false":
#         val err = fci_eval_code("val f = @traits(\"module_file\", \"no.such.module\")\nval ok = f.exists == false")
#         expect(err).to_equal("")
# 
#     it "non-existent module has empty path":
#         val err = fci_eval_code("val f = @traits(\"module_file\", \"no.such.module\")\nval ok = f.path == \"\"")
#         expect(err).to_equal("")
# 
# # ===== class_info query =====
# 
# describe "@traits(class_info) parsing":
#     it "parses @traits(class_info, TypeName) without error":
#         val ok = fci_parse_ok("val c = @traits(\"class_info\", \"Point\")")
#         expect(ok).to_equal(true)
# 
#     it "parses class_info result field access without error":
#         val ok = fci_parse_ok("val c = @traits(\"class_info\", \"Point\")\nval n = c.name")
#         expect(ok).to_equal(true)
# 
# describe "@traits(class_info) evaluation":
#     it "evaluates class_info for registered struct without error":
#         val code = "struct TestPoint:\n    x: i64\n    y: i64\nval c = @traits(\"class_info\", \"TestPoint\")\nval n = c.name"
#         val err = fci_eval_code(code)
#         expect(err).to_equal("")
# 
#     it "class_info returns struct with correct name":
#         val code = "struct TestBox:\n    w: i64\n    h: i64\nval c = @traits(\"class_info\", \"TestBox\")\nval ok = c.name == \"TestBox\""
#         val err = fci_eval_code(code)
#         expect(err).to_equal("")
# 
#     it "class_info has field_count matching struct fields":
#         val code = "struct TestVec:\n    x: f64\n    y: f64\n    z: f64\nval c = @traits(\"class_info\", \"TestVec\")\nval ok = c.field_count == 3"
#         val err = fci_eval_code(code)
#         expect(err).to_equal("")
# 
#     it "class_info returns nil for non-existent type":
#         val code = "val c = @traits(\"class_info\", \"NoSuchType\")\nval ok = c == nil"
#         val err = fci_eval_code(code)
#         expect(err).to_equal("")
# 
# # ===== module_wildcard query =====
# 
# describe "@traits(module_wildcard) parsing":
#     it "parses @traits(module_wildcard, prefix) without error":
#         val ok = fci_parse_ok("val files = @traits(\"module_wildcard\", \"std\")")
#         expect(ok).to_equal(true)
# 
# describe "@traits(module_wildcard) evaluation":
#     it "evaluates module_wildcard without error":
#         val err = fci_eval_code("val files = @traits(\"module_wildcard\", \"std\")")
#         expect(err).to_equal("")
# 
#     it "module_wildcard returns an array":
#         val err = fci_eval_code("val files = @traits(\"module_wildcard\", \"std\")\nval n = files.len()")
#         expect(err).to_equal("")
# 
# # ===== Parser desugaring: .FILE =====
# 
# describe "Parser .FILE desugaring":
#     it "parses mod.path.FILE syntax without error":
#         val ok = fci_parse_ok("val f = std.spec.FILE")
#         expect(ok).to_equal(true)
# 
#     it "parses .FILE with field access chain without error":
#         val ok = fci_parse_ok("val p = std.spec.FILE.path")
#         expect(ok).to_equal(true)
# 
# # ===== Parser desugaring: .class =====
# 
# describe "Parser .class desugaring":
#     it "parses TypeName.class syntax without error":
#         val ok = fci_parse_ok("struct Foo:\n    x: i64\nval c = Foo.class")
#         expect(ok).to_equal(true)
# 
#     it "parses .class with field access chain without error":
#         val ok = fci_parse_ok("struct Foo:\n    x: i64\nval n = Foo.class.name")
#         expect(ok).to_equal(true)
# 
# # ===== Parser desugaring: .* =====
# 
# describe "Parser .* desugaring":
#     it "parses mod.prefix.* syntax without error":
#         val ok = fci_parse_ok("val files = std.*")
#         expect(ok).to_equal(true)
# 
#     it "parses .* result with .len() without error":
#         val ok = fci_parse_ok("val n = std.*.len()")
#         expect(ok).to_equal(true)
