# Type System Integration Tests
#
# Tests for advanced type system integration (type_checker, type_erasure, type_inference)

use std.spec.{describe, it, expect}

describe "Type Inference in Variable Declarations":
    it "infers i64 from integer literal":
        val x = 42
        expect(x).to_equal(42)

    it "infers f64 from float literal":
        val pi = 3.14
        expect(pi).to_equal(3.14)

    it "infers text from string literal":
        val greeting = "Hello"
        expect(greeting).to_equal("Hello")

    it "infers bool from boolean literal":
        val flag = true
        expect(flag).to_equal(true)

    it "infers type from binary operation":
        val sum = 10 + 20
        expect(sum).to_equal(30)

    it "infers bool from comparison":
        val is_greater = 5 > 3
        expect(is_greater).to_equal(true)

    it "infers bool from logical operation":
        val both_true = true and true
        expect(both_true).to_equal(true)

describe "Type Checking in Function Calls":
    it "validates correct parameter types":
        fn multiply(a: i64, b: i64) -> i64:
            a * b
        val result = multiply(6, 7)
        expect(result).to_equal(42)

    it "works with mixed parameter types":
        fn format_number(num: i64, suffix: text) -> text:
            str(num) + suffix
        val result = format_number(100, " units")
        expect(result).to_equal("100 units")

    it "handles bool parameters":
        fn negate(x: bool) -> bool:
            not x
        val result = negate(false)
        expect(result).to_equal(true)

    it "handles f64 parameters":
        fn square(x: f64) -> f64:
            x * x
        val result = square(4.0)
        expect(result).to_equal(16.0)

describe "Monomorphization Cache":
    it "caches function calls with same types":
        fn identity(x):
            x
        val result1 = identity(10)
        val result2 = identity(20)
        expect(result1).to_equal(10)
        expect(result2).to_equal(20)

    it "handles different type instantiations":
        fn first(a, b):
            a
        val int_result = first(42, 100)
        val text_result = first("hello", "world")
        expect(int_result).to_equal(42)
        expect(text_result).to_equal("hello")

describe "Complex Type System Features":
    it "combines type inference with type checking":
        fn process(value: i64) -> i64:
            value * 2
        val input = 21
        val output = process(input)
        expect(output).to_equal(42)

    it "works with nested function calls":
        fn add_ten(x: i64) -> i64:
            x + 10
        fn double_it(y: i64) -> i64:
            y * 2
        val result = double_it(add_ten(5))
        expect(result).to_equal(30)

    it "handles array types":
        val numbers = [1, 2, 3, 4, 5]
        var sum: i64 = 0
        for n in numbers:
            sum = sum + n
        expect(sum).to_equal(15)

    it "infers types in control flow":
        val condition = 10 > 5
        val message = if condition: "yes" else: "no"
        expect(message).to_equal("yes")
