# # Branch Coverage Test Suite - Optional Functions & Type System
#
# **Feature IDs:** #BRANCH #OPTIONAL_FUNCTIONS #TYPE_INFERENCE
# **Category:** Testing
# **Status:** Implemented
#
# ## Overview
#
# Tests functions returning Optional types and type inference paths
# to cover expr_is_option (line 504) and option_base_stype (lines 208-213).

fn check(condition: bool):
    expect(condition).to_equal(true)

describe "Functions Returning Optional":
    it "function with optional return":
        fn maybe_value() -> i64?:
            Some(42)

        val result = maybe_value()
        check(result.?)

    it "function returning nil":
        fn get_none() -> i64?:
            nil

        val result = get_none()
        check(not result.?)

    it "conditional optional return":
        fn conditional(flag: bool) -> i64?:
            if flag:
                return Some(100)
            nil

        check(conditional(true).?)
        check(not conditional(false).?)

describe "Optional in Expressions":
    it "optional function in if":
        fn maybe_positive() -> i64?:
            Some(5)

        if maybe_positive().:
            check(true)
        else:
            check(false)

    it "optional chaining":
        fn get_optional() -> i64?:
            Some(10)

        val result = get_optional()
        if val x = result:
            check(x == 10)

    it "optional with default":
        fn might_fail() -> i64?:
            nil

        val value = might_fail() ?? 99
        check(value == 99)

describe "Type Inference for Optionals":
    it "infer from Some":
        val x = Some(42)
        check(x.?)

    it "infer from nil":
        val n: i64? = nil
        check(not n.?)

    it "infer from function":
        fn returns_opt() -> text?:
            Some("hello")

        val s = returns_opt()
        check(s.?)

describe "Long Type Names":
    it "struct with long name":
        struct VeryLongStructNameForTestingBufferLimits:
            value: i64

        val item = VeryLongStructNameForTestingBufferLimits(value: 42)
        check(item.value == 42)

    it "optional of long struct":
        struct AnotherVeryLongNameToTestOptionalHandling:
            id: i64

        val opt: AnotherVeryLongNameToTestOptionalHandling? = nil
        check(not opt.?)

describe "Nested Optional Types":
    it "optional of optional":
        val o1: i64?? = Some(Some(42))
        check(o1.?)

    it "optional of optional - nil inner":
        val o2: i64?? = Some(nil)
        check(o2.?)

    it "function returning nested optional":
        fn nested_opt() -> i64??:
            Some(Some(100))

        val result = nested_opt()
        check(result.?)

describe "Optional Struct Fields":
    it "struct with optional field":
        struct Record:
            id: i64
            optional_value: i64?

        val r1 = Record(id: 1, optional_value: Some(10))
        val r2 = Record(id: 2, optional_value: nil)

        check(r1.optional_value.?)
        check(not r2.optional_value.?)

describe "Optional in Collections":
    it "array of optionals":
        val arr: [i64?] = [Some(1), nil, Some(3)]
        check(arr[0].?)
        check(not arr[1].?)

    it "optional array":
        val opt_arr: [i64]? = Some([1, 2, 3])
        check(opt_arr.?)

describe "Type Base Extraction":
    it "extract base from optional":
        val x: i64? = Some(42)
        if val unwrapped = x:
            check(unwrapped == 42)

    it "non-optional type":
        val y: i64 = 42
        check(y == 42)

    it "text type":
        val s: text = "hello"
        check(s == "hello")

    it "bool type":
        val b: bool = true
        check(b)
