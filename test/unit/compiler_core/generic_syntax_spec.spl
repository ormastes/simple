# Generic Syntax Support Tests
#
# Tests that the runtime parser accepts generic <T> syntax in:
# - Class declarations: class Foo<T>:
# - Function declarations: fn bar<T, U>(...)
# - Type annotations: Option<Box<i64>>
# - Mixed with comparison operators: if x < 5:

use compiler_core.parser.{parse_module, parser_has_errors, parser_get_errors, parser_init}

describe "Generic Syntax Parser":
    it "parses class with single type parameter":
        val source = "class Box<T>:\n    value: T\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses class with multiple type parameters":
        val source = "class Pair<T, U>:\n    first: T\n    second: U\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses class with three type parameters":
        val source = "class Triple<A, B, C>:\n    a: A\n    b: B\n    c: C\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses struct with type parameter":
        val source = "struct Node<T>:\n    data: T\n    next: Node<T>\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses function with single type parameter":
        val source = "fn identity<T>(x: T) -> T:\n    x\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses function with multiple type parameters":
        val source = "fn swap<T, U>(a: T, b: U) -> (U, T):\n    (b, a)\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses method with type parameter":
        val source = "class List<T>:\n    items: [T]\nimpl List:\n    fn map<U>(f: fn(T) -> U) -> List<U>:\n        List(items: [])\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses extern function with type parameter":
        val source = "extern fn rt_alloc<T>(size: i64) -> T\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses nested generic types":
        val source = "fn create() -> Option<Box<i64>>:\n    nil\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses deeply nested generic types":
        val source = "fn deep() -> Option<Result<Box<[i64]>, text>>:\n    nil\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "distinguishes generics from comparison in function body":
        val source = "fn check<T>(x: i64) -> bool:\n    if x < 5:\n        true\n    else:\n        false\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "distinguishes generics from comparison with Box":
        val source = "class Box<T>:\n    value: T\nfn test(x: i64):\n    if x < 5:\n        Box(value: x)\n    else:\n        Box(value: 0)\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses generic function with comparison operators":
        val source = "fn min<T>(a: T, b: T) -> T:\n    if a < b:\n        a\n    else:\n        b\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses generic function with shift operators":
        val source = "fn shift<T>(x: i64) -> i64:\n    x << 2\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses async function with generics":
        val source = "async fn fetch<T>(url: text) -> T:\n    pass\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses static method with generics":
        val source = "class Factory:\n    x: i64\nimpl Factory:\n    static fn create<T>() -> T:\n        pass\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses mutable method with generics":
        val source = "class Container<T>:\n    items: [T]\nimpl Container:\n    me push<U>(item: U):\n        pass\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses type parameter with single letter names":
        val source = "class Map<K, V>:\n    keys: [K]\n    values: [V]\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses type parameter with descriptive names":
        val source = "class Either<Left, Right>:\n    left: Left\n    right: Right\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses generic function returning generic type":
        val source = "fn wrap<T>(x: T) -> Box<T>:\n    Box(value: x)\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses multiple generic functions in module":
        val source = "fn id<T>(x: T) -> T:\n    x\nfn const<T, U>(x: T, y: U) -> T:\n    x\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses generic class with generic methods":
        val source = "class List<T>:\n    items: [T]\nimpl List:\n    fn map<U>(f: fn(T) -> U) -> List<U>:\n        List(items: [])\n    fn filter<P>(pred: fn(T) -> bool) -> List<T>:\n        List(items: [])\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses enum with generic type parameters":
        val source = "enum Result<T, E>:\n    Ok(value: T)\n    Err(error: E)\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses comparison after generic type annotation":
        val source = "fn compare<T>(container: Box<T>, threshold: i64) -> bool:\n    threshold < 10\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses multiple comparisons with generics":
        val source = "fn range_check<T>(x: i64) -> bool:\n    if x < 5:\n        true\n    elif x > 10:\n        false\n    else:\n        x >= 5 and x <= 10\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses generic type in parameter and return type":
        val source = "fn transform<T, U>(input: Option<T>, f: fn(T) -> U) -> Option<U>:\n    nil\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses complex generic type chain":
        val source = "fn chain<T>() -> Option<Result<Box<[T]>, text>>:\n    nil\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses generic array type":
        val source = "class Container<T>:\n    items: [T]\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses generic function type":
        val source = "fn higher_order<T, U>(f: fn(T) -> U) -> fn(T) -> U:\n    f\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)

    it "parses generic with constraint syntax placeholder":
        val source = "fn constrained<T>(x: T) -> T:\n    x\n"
        parse_module(source, "test.spl")
        val has_err = parser_has_errors()
        expect(has_err).to_equal(false)
