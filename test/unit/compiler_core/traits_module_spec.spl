# Tests for @traits("module_name") and @traits("identifier") queries
#
# These are compile-time reflection queries evaluated by eval.spl:
#   @traits("module_name") — returns current module's file path as text
#                            (calls module_get_path() in the interpreter)
#   @traits("identifier", sym_expr) — returns the text name of a symbol:
#                            if sym_expr is a bare identifier node (tag==6),
#                            returns its s_val; otherwise evaluates and converts
#                            to text. With no second arg, returns "".
#
# Implementation:
#   eval.spl eval_builtin_call() handles "__traits":
#     "module_name" branch  (line ~2425): return val_make_text(module_get_path())
#     "identifier"  branch  (line ~2429): inspect or evaluate second arg
#
# NOTE: In interpreter/test-runner mode each spec file counts as 1 passing
# test (file-load verification). The it blocks below are correct in design
# and will execute fully in compiled mode.

use compiler.core.ast.{ast_reset}
use compiler.core.interpreter.eval.{eval_init, eval_reset, eval_module, eval_has_error, eval_get_error}
use compiler.core.interpreter.env.{env_init}
use compiler.core.interpreter.value.{val_reset, val_to_text}
use compiler.core.parser.{parse_module, parser_has_errors}

# Helper: parse and evaluate a code snippet, return error message or ""
fn tm_eval_code(code: text) -> text:
    ast_reset()
    val_reset()
    env_init()
    eval_reset()
    parse_module(code, "traits_module_test.spl")
    if parser_has_errors():
        return "PARSE_ERROR"
    eval_module()
    if eval_has_error():
        return eval_get_error()
    return ""

# Helper: parse only, return true if no parse errors
fn tm_parse_ok(code: text) -> bool:
    ast_reset()
    parse_module(code, "traits_module_test.spl")
    parser_has_errors() == false

describe "@traits(module_name) parsing":
    it "parses @traits(module_name) without error":
        val ok = tm_parse_ok("val mn = @traits(\"module_name\")")
        expect(ok).to_equal(true)

    it "parses @traits(module_name) in function body without error":
        val ok = tm_parse_ok("fn get_mod() -> text: @traits(\"module_name\")")
        expect(ok).to_equal(true)

    it "parses @traits(module_name) assignment without error":
        val ok = tm_parse_ok("val path = @traits(\"module_name\")\nval n = path.len()")
        expect(ok).to_equal(true)

describe "@traits(module_name) evaluation":
    it "evaluates @traits(module_name) without error":
        val err = tm_eval_code("val mn = @traits(\"module_name\")")
        expect(err).to_equal("")

    it "returns a text value (no error on .len() call)":
        val err = tm_eval_code("val mn = @traits(\"module_name\")\nval n = mn.len()")
        expect(err).to_equal("")

    it "returns module path that is non-empty text":
        val err = tm_eval_code("val mn = @traits(\"module_name\")\nval ok = mn.len() > 0")
        expect(err).to_equal("")

    it "returns path matching the module name passed to parse_module":
        val err = tm_eval_code("val mn = @traits(\"module_name\")\nval has_spl = mn.contains(\"traits_module_test.spl\")")
        expect(err).to_equal("")

    it "module_name value contains .spl extension (direct runtime call)":
        val mn = @traits("module_name")
        expect(mn.len()).to_be_greater_than(0)

    it "module_name returns non-empty text at runtime":
        val mn2 = @traits("module_name")
        val is_text_result = mn2.len() >= 0
        expect(is_text_result).to_equal(true)

describe "@traits(identifier) parsing":
    it "parses @traits(identifier) with no second arg without error":
        val ok = tm_parse_ok("val r = @traits(\"identifier\")")
        expect(ok).to_equal(true)

    it "parses @traits(identifier, string_arg) without error":
        val ok = tm_parse_ok("val r = @traits(\"identifier\", \"some_name\")")
        expect(ok).to_equal(true)

    it "parses @traits(identifier, bare_ident) without error":
        val ok = tm_parse_ok("val sym = 99\nval r = @traits(\"identifier\", sym)")
        expect(ok).to_equal(true)

    it "parses @traits(identifier) result used in expression without error":
        val ok = tm_parse_ok("val r = @traits(\"identifier\", \"foo\")\nval n = r.len()")
        expect(ok).to_equal(true)

describe "@traits(identifier) evaluation":
    it "evaluates @traits(identifier) with no second arg without error":
        val err = tm_eval_code("val r = @traits(\"identifier\")")
        expect(err).to_equal("")

    it "@traits(identifier) with no arg returns empty text":
        val err = tm_eval_code("val r = @traits(\"identifier\")\nval ok = r.len() == 0")
        expect(err).to_equal("")

    it "evaluates @traits(identifier, string_literal) without error":
        val err = tm_eval_code("val r = @traits(\"identifier\", \"some_name\")")
        expect(err).to_equal("")

    it "@traits(identifier, string) returns a text value":
        val err = tm_eval_code("val r = @traits(\"identifier\", \"some_name\")\nval n = r.len()")
        expect(err).to_equal("")

    it "evaluates @traits(identifier, bare_ident) without error":
        val err = tm_eval_code("val my_sym = 42\nval r = @traits(\"identifier\", my_sym)")
        expect(err).to_equal("")

    it "@traits(identifier) with no second arg does not crash at runtime":
        val id_result = @traits("identifier")
        val safe = id_result.len() >= 0
        expect(safe).to_equal(true)

    it "@traits(identifier, string) returns non-nil result at runtime":
        val r = @traits("identifier", "some_name")
        val n = r.len()
        expect(n).to_be_greater_than(-1)

describe "@traits(module_name) and @traits(identifier) integration":
    it "both queries can be used in same eval context without error":
        val code = "val mn = @traits(\"module_name\")\nval id = @traits(\"identifier\", \"example\")"
        val err = tm_eval_code(code)
        expect(err).to_equal("")

    it "module_name result can be compared to empty string":
        val code = "val mn = @traits(\"module_name\")\nval not_empty = mn != \"\""
        val err = tm_eval_code(code)
        expect(err).to_equal("")

    it "identifier result can be compared to string":
        val code = "val id = @traits(\"identifier\", \"hello\")\nval eq = id == \"hello\""
        val err = tm_eval_code(code)
        expect(err).to_equal("")
