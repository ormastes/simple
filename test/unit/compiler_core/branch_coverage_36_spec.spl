"""
# Branch Coverage Test Suite - Control Flow & Lambdas

**Feature IDs:** #BRANCH #CONTROL_FLOW #LAMBDA #MATCH
**Category:** Testing
**Status:** Implemented

## Overview

Tests complex control flow, match with guards, and lambda expressions
to cover translate_block branches (lines 1972, 1981, 2029).
"""

use std.spec.{check}

describe "Match with Complex Patterns":
    it "match with multiple patterns":
        fn classify(x: i64) -> text:
            match x:
                0: "zero"
                1: "one"
                2: "two"
                3: "three"
                4: "four"
                5: "five"
                _: "other"

        check(classify(0) == "zero")
        check(classify(3) == "three")
        check(classify(99) == "other")

    it "match on optional":
        fn process(opt: i64?) -> i64:
            match opt:
                Some(x): x * 2
                nil: 0

        check(process(Some(5)) == 10)
        check(process(nil) == 0)

    it "match on tuple":
        fn tuple_match(t: (i64, i64)) -> i64:
            match t:
                (0, 0): 0
                (a, b): a + b

        check(tuple_match((0, 0)) == 0)
        check(tuple_match((3, 4)) == 7)

describe "Nested Match":
    it "match within match":
        fn double_match(x: i64, y: i64) -> text:
            match x:
                0:
                    match y:
                        0: "both zero"
                        _: "x zero"
                _:
                    match y:
                        0: "y zero"
                        _: "neither zero"

        check(double_match(0, 0) == "both zero")
        check(double_match(0, 1) == "x zero")
        check(double_match(1, 0) == "y zero")
        check(double_match(1, 1) == "neither zero")

describe "Lambda Expressions":
    it "simple lambda":
        val f = \x: x * 2
        check(f(5) == 10)

    it "lambda with multiple params":
        val add = \a, b: a + b
        check(add(3, 4) == 7)

    it "nested lambda":
        val outer = \x: \y: x + y
        val inner = outer(10)
        check(inner(5) == 15)

    it "lambda in method":
        val nums = [1, 2, 3, 4, 5]
        val doubled = nums.map(\x: x * 2)
        check(doubled[0] == 2)
        check(doubled[4] == 10)

describe "Complex Conditionals":
    it "nested if-else":
        fn classify_number(n: i64) -> text:
            if n < 0:
                if n < -100:
                    "very negative"
                else:
                    "negative"
            else:
                if n > 100:
                    "very positive"
                else:
                    "positive or zero"

        check(classify_number(-200) == "very negative")
        check(classify_number(-50) == "negative")
        check(classify_number(50) == "positive or zero")
        check(classify_number(200) == "very positive")

    it "multiple elif":
        fn grade(score: i64) -> text:
            if score >= 90:
                "A"
            else: if score >= 80:
                "B"
            else: if score >= 70:
                "C"
            else: if score >= 60:
                "D"
            else:
                "F"

        check(grade(95) == "A")
        check(grade(85) == "B")
        check(grade(75) == "C")
        check(grade(65) == "D")
        check(grade(55) == "F")

describe "Loop Edge Cases":
    it "nested for loops with break":
        var found = false
        var i_found = 0
        var j_found = 0

        for i in 0..10:
            for j in 0..10:
                if i * j == 24:
                    found = true
                    i_found = i
                    j_found = j
                    break
            if found:
                break

        check(found)
        check(i_found * j_found == 24)

    it "while with complex condition":
        var count = 0
        var sum = 0
        while count < 10 and sum < 30:
            sum = sum + count
            count = count + 1
        check(count > 0)
        check(sum >= 30 or count == 10)

describe "Early Returns":
    it "return in nested if":
        fn find_first_positive(nums: [i64]) -> i64:
            for n in nums:
                if n > 0:
                    return n
            -1

        check(find_first_positive([0, -1, 5, 10]) == 5)
        check(find_first_positive([-1, -2, -3]) == -1)

    it "multiple return paths":
        fn categorize(x: i64) -> text:
            if x == 0:
                return "zero"
            if x > 0:
                return "positive"
            "negative"

        check(categorize(0) == "zero")
        check(categorize(5) == "positive")
        check(categorize(-5) == "negative")

describe "Block Indentation":
    it "consistent indentation":
        fn test() -> i64:
            val x = 1
            val y = 2
            val z = 3
            x + y + z

        check(test() == 6)

    it "deeply nested blocks":
        fn deep() -> i64:
            if true:
                if true:
                    if true:
                        if true:
                            42
                        else:
                            0
                    else:
                        0
                else:
                    0
            else:
                0

        check(deep() == 42)
