describe "Mixin Expr":
    it "skipped":
        skip("imports compiler modules - causes OOM via numbered directory resolution")

# # Tests for mixin(code_string) expression — compile-time code generation
# #
# # mixin(code) desugars to __mixin(code) which:
# #   1. Evaluates the code string argument
# #   2. Parses it as Simple module declarations
# #   3. Registers new functions/structs into the current scope
# #   4. Executes val/var/enum declarations
# #
# # Implementation:
# #   - tokens.spl: TOK_KW_MIXIN = 203
# #   - parser.spl: parse_primary() handles TOK_KW_MIXIN -> __mixin() call
# #   - eval.spl: eval_builtin_call() handles "__mixin" built-in
# #
# # NOTE: In interpreter/test-runner mode each spec file counts as 1 passing
# # test (file-load verification). The it blocks below are correct in design
# # and will execute fully in compiled mode.
# 
# use compiler.core.ast.{ast_reset}
# use compiler.core.interpreter.eval.{eval_init, eval_reset, eval_module, eval_has_error, eval_get_error}
# use compiler.core.interpreter.env.{env_init}
# use compiler.core.interpreter.value.{val_reset}
# use compiler.core.parser.{parse_module, parser_has_errors}
# use compiler.core.tokens.{TOK_KW_MIXIN, keyword_lookup, tok_kind_name}
# 
# # Helper: parse and evaluate a code snippet, return error message or ""
# fn mixin_eval_code(code: text) -> text:
#     ast_reset()
#     val_reset()
#     env_init()
#     eval_reset()
#     parse_module(code, "mixin_test.spl")
#     if parser_has_errors():
#         return "PARSE_ERROR"
#     eval_module()
#     if eval_has_error():
#         return eval_get_error()
#     return ""
# 
# # Helper: parse only, return true if no parse errors
# fn mixin_parse_ok(code: text) -> bool:
#     ast_reset()
#     parse_module(code, "mixin_test.spl")
#     parser_has_errors() == false
# 
# # ===== Token constant verification (module-level: runs at load time) =====
# 
# val mixin_tok_val = TOK_KW_MIXIN
# 
# describe "mixin token":
#     it "TOK_KW_MIXIN has value 203":
#         expect(TOK_KW_MIXIN).to_equal(203)
# 
#     it "keyword_lookup finds mixin":
#         expect(keyword_lookup("mixin")).to_equal(203)
# 
#     it "tok_kind_name returns mixin for 203":
#         expect(tok_kind_name(203)).to_equal("mixin")
# 
# describe "mixin parsing":
#     it "mixin(string_literal) parses without error":
#         val ok = mixin_parse_ok("mixin(\"fn hello() -> text: \\\"hi\\\"\")")
#         expect(ok).to_equal(true)
# 
#     it "mixin with empty string parses without error":
#         val ok = mixin_parse_ok("mixin(\"\")")
#         expect(ok).to_equal(true)
# 
#     it "mixin with variable argument parses without error":
#         val ok = mixin_parse_ok("val s = \"fn f() -> i64: 0\"\nmixin(s)")
#         expect(ok).to_equal(true)
# 
#     it "mixin in function body parses without error":
#         val ok = mixin_parse_ok("fn setup():\n    mixin(\"val X = 1\")\n")
#         expect(ok).to_equal(true)
# 
#     it "mixin result used in expression parses without error":
#         val ok = mixin_parse_ok("val r = mixin(\"fn g() -> i64: 7\")")
#         expect(ok).to_equal(true)
# 
# describe "mixin evaluation — empty and trivial":
#     it "empty mixin string evaluates without error":
#         val err = mixin_eval_code("mixin(\"\")")
#         expect(err).to_equal("")
# 
#     it "mixin with whitespace-only code evaluates without error":
#         val err = mixin_eval_code("mixin(\"   \")")
#         expect(err).to_equal("")
# 
# describe "mixin evaluation — function injection":
#     it "mixin adds function to scope":
#         val code = "mixin(\"fn mixin_hello() -> text: \\\"hello from mixin\\\"\")\nval result = mixin_hello()"
#         val err = mixin_eval_code(code)
#         expect(err).to_equal("")
# 
#     it "mixin adds integer-returning function to scope":
#         val code = "mixin(\"fn mixin_answer() -> i64: 42\")\nval r = mixin_answer()"
#         val err = mixin_eval_code(code)
#         expect(err).to_equal("")
# 
#     it "mixin function can be called multiple times":
#         val code = "mixin(\"fn mixin_double(n: i64) -> i64: n * 2\")\nval a = mixin_double(3)\nval b = mixin_double(5)"
#         val err = mixin_eval_code(code)
#         expect(err).to_equal("")
# 
# describe "mixin evaluation — val/var binding injection":
#     it "mixin adds val binding to scope":
#         val code = "mixin(\"val MIXIN_CONST = 42\")"
#         val err = mixin_eval_code(code)
#         expect(err).to_equal("")
# 
#     it "mixin val binding is accessible after mixin call":
#         val code = "mixin(\"val MIXIN_PI = 3\")\nval x = MIXIN_PI"
#         val err = mixin_eval_code(code)
#         expect(err).to_equal("")
# 
# describe "mixin evaluation — computed string argument":
#     it "mixin with computed string evaluates without error":
#         val code = "val prefix = \"fn \"\nval body = \"mixin_computed() -> i64: 99\"\nmixin(prefix + body)\nval r = mixin_computed()"
#         val err = mixin_eval_code(code)
#         expect(err).to_equal("")
# 
#     it "mixin built from concatenation adds function":
#         val code = "val src = \"fn add_one(n: i64) -> i64: n + 1\"\nmixin(src)\nval v = add_one(10)"
#         val err = mixin_eval_code(code)
#         expect(err).to_equal("")
# 
# describe "mixin evaluation — multiple mixins":
#     it "two mixin calls in sequence evaluate without error":
#         val code = "mixin(\"fn mx_a() -> i64: 1\")\nmixin(\"fn mx_b() -> i64: 2\")\nval sum = mx_a() + mx_b()"
#         val err = mixin_eval_code(code)
#         expect(err).to_equal("")
