# Structural Subtyping Tests (Go-style Interface Satisfaction)
#
# Tests that a struct with all fields of another struct can be passed
# where that other struct is expected (structural subtyping / duck typing).
#
# The runtime already duck-types struct field access by name.
# The type_check_value function now enforces structural compatibility:
# - A struct with all required fields satisfies the expected type.
# - A struct missing required fields is rejected with a type error.

describe "Structural Subtyping":
    describe "basic compatibility":
        it "accepts exact type match":
            struct OrderRepoPort:
                save_fn: fn(text)
                find_fn: fn(text) -> text

            fn process_exact(repo: OrderRepoPort) -> text:
                val f = repo.find_fn
                f("id-1")

            val repo = OrderRepoPort(
                save_fn: fn(x): (),
                find_fn: fn(x): "found:" + x
            )
            val result = process_exact(repo)
            expect(result).to_equal("found:id-1")

        it "accepts struct with extra fields (structural subtyping)":
            struct BasePort:
                save_fn: fn(text)
                find_fn: fn(text) -> text

            struct ExtendedRepo:
                save_fn: fn(text)
                find_fn: fn(text) -> text
                count_fn: fn() -> i64

            fn process_base(repo: BasePort) -> text:
                val f = repo.find_fn
                f("item-42")

            val extended = ExtendedRepo(
                save_fn: fn(x): (),
                find_fn: fn(x): "ext:" + x,
                count_fn: fn(): 99
            )
            val result = process_base(extended)
            expect(result).to_equal("ext:item-42")

        it "calls functions on structurally-compatible struct":
            struct PortA:
                name_fn: fn() -> text

            struct ImplA:
                name_fn: fn() -> text
                id_fn: fn() -> i64

            fn get_name(p: PortA) -> text:
                val f = p.name_fn
                f()

            val impl = ImplA(
                name_fn: fn(): "impl-name",
                id_fn: fn(): 7
            )
            val result = get_name(impl)
            expect(result).to_equal("impl-name")

    describe "field access after structural pass":
        it "can access fields on the passed struct":
            struct ReaderPort:
                read_fn: fn() -> text

            struct FileReader:
                read_fn: fn() -> text
                path_fn: fn() -> text

            fn do_read(r: ReaderPort) -> text:
                val f = r.read_fn
                f()

            var captured: text = ""
            val reader = FileReader(
                read_fn: fn(): "file-content",
                path_fn: fn(): "/tmp/test.txt"
            )
            val content = do_read(reader)
            expect(content).to_equal("file-content")

    describe "multiple params, structural subtyping":
        it "structural subtyping works for multiple struct params":
            struct LogPort:
                log_fn: fn(text)

            struct StoragePort:
                store_fn: fn(text)

            struct ExtendedLog:
                log_fn: fn(text)
                level_fn: fn() -> i64

            struct ExtendedStorage:
                store_fn: fn(text)
                flush_fn: fn() -> bool

            fn pipeline(logger: LogPort, storage: StoragePort) -> text:
                val lf = logger.log_fn
                lf("start")
                val sf = storage.store_fn
                sf("data")
                "done"

            val ext_log = ExtendedLog(
                log_fn: fn(msg): (),
                level_fn: fn(): 2
            )
            val ext_storage = ExtendedStorage(
                store_fn: fn(d): (),
                flush_fn: fn(): true
            )
            val result = pipeline(ext_log, ext_storage)
            expect(result).to_equal("done")

    describe "exact struct type always works":
        it "passing same type still works after structural subtyping addition":
            struct SimplePort:
                value_fn: fn() -> i64

            fn get_value(p: SimplePort) -> i64:
                val f = p.value_fn
                f()

            val port = SimplePort(value_fn: fn(): 42)
            val result = get_value(port)
            expect(result).to_equal(42)

    describe "struct with i64 and text fields":
        it "struct with extra non-fn field satisfies port":
            struct DataPort:
                name: text
                count: i64

            struct RichData:
                name: text
                count: i64
                extra: text

            fn read_data(d: DataPort) -> text:
                d.name + ":" + str(d.count)

            val rich = RichData(name: "test", count: 5, extra: "unused")
            val result = read_data(rich)
            expect(result).to_equal("test:5")
