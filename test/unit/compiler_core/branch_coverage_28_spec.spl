# # Branch Coverage Test Suite - Error Paths & Edge Cases
#
# **Feature IDs:** #BRANCH #ERROR #EDGE
# **Category:** Testing
# **Status:** Implemented
#
# ## Overview
#
# Tests error handling and edge case branches to achieve 100% coverage.
# Covers boundary conditions, error recovery, and uncommon code paths.

fn check(condition: bool):
    expect(condition).to_equal(true)

describe "Boundary Conditions":
    it "integer - zero":
        check(0 == 0)
        check(0 < 1)
        check(0 > -1)

    it "integer - min value":
        val x = -9223372036854775808
        check(x < 0)

    it "integer - max value":
        val x = 9223372036854775807
        check(x > 0)

    it "float - zero":
        val x = 0.0
        check(x == 0.0)

    it "float - negative zero":
        val x = -0.0
        check(x == 0.0)

    it "float - infinity":
        val x = 1.0e308
        check(x > 0.0)

    it "float - tiny":
        val x = 1.0e-308
        check(x > 0.0)
        check(x < 1.0)

    it "string - empty":
        val s = ""
        check(s.len() == 0)
        check(s == "")

    it "string - single char":
        val s = "a"
        check(s.len() == 1)

    it "string - very long":
        val s = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
        check(s.len() > 60)

    it "array - empty":
        val arr: [i64] = []
        check(arr.len() == 0)

    it "array - single element":
        var arr = [42]
        check(arr.len() == 1)

    it "array - large":
        var arr = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
        check(arr.len() == 20)


describe "Edge Case Expressions":
    it "division by one":
        check(10 / 1 == 10)

    it "modulo by one":
        check(10 % 1 == 0)

    it "power of zero":
        check(5 ** 0 == 1)

    it "power of one":
        check(5 ** 1 == 5)

    it "negative exponent handled":
        val x = 2 ** 3
        check(x == 8)

    it "zero to power":
        check(0 ** 5 == 0)

    it "one to power":
        check(1 ** 100 == 1)

    it "bitwise - all zeros":
        check((0 & 0) == 0)
        check((0 | 0) == 0)
        check((0 ^ 0) == 0)

    it "bitwise - all ones":
        check((15 & 15) == 15)
        check((15 | 15) == 15)
        check((15 ^ 15) == 0)

    it "bitwise - mixed":
        check((0b1010 & 0b1100) == 0b1000)
        check((0b1010 | 0b1100) == 0b1110)
        check((0b1010 ^ 0b1100) == 0b0110)


describe "Complex Control Flow":
    it "nested loops - break outer effect":
        var count = 0
        for i in 0..3:
            for j in 0..3:
                count = count + 1
                if count == 5:
                    break
        check(count >= 5)

    it "nested loops - continue inner":
        fn run() -> i64:
            var count = 0
            for i in 0..3:
                for j in 0..3:
                    if j == 1:
                        continue
                    count = count + 1
            count
        check(run() == 6)

    it "nested if-elif-else":
        fn classify(x: i64, y: i64) -> i64:
            if x > 0:
                if y > 0:
                    return 1
                elif y == 0:
                    return 2
                else:
                    return 3
            elif x == 0:
                if y > 0:
                    return 4
                elif y == 0:
                    return 5
                else:
                    return 6
            else:
                if y > 0:
                    return 7
                elif y == 0:
                    return 8
                else:
                    return 9
        check(classify(1, 1) == 1)
        check(classify(1, 0) == 2)
        check(classify(1, -1) == 3)
        check(classify(0, 1) == 4)
        check(classify(0, 0) == 5)
        check(classify(0, -1) == 6)
        check(classify(-1, 1) == 7)
        check(classify(-1, 0) == 8)
        check(classify(-1, -1) == 9)

    it "match in loop":
        var sum = 0
        for i in 0..5:
            val add = match i:
                0: 1
                1: 2
                2: 3
                3: 4
                _: 5
            sum = sum + add
        check(sum == 15)

    it "if in match":
        fn test(x: i64) -> i64:
            match x:
                1:
                    if true:
                        10
                    else:
                        20
                2:
                    if false:
                        30
                    else:
                        40
                _:
                    50
        check(test(1) == 10)
        check(test(2) == 40)
        check(test(3) == 50)


describe "Short Circuit Evaluation":
    it "and - short circuit false":
        fn side_effect() -> bool:
            true
        val result = false and side_effect()
        check(not result)

    it "and - no short circuit true":
        fn side_effect2() -> bool:
            true
        val result = true and side_effect2()
        check(result)

    it "or - short circuit true":
        fn side_effect3() -> bool:
            false
        val result = true or side_effect3()
        check(result)

    it "or - no short circuit false":
        fn side_effect4() -> bool:
            true
        val result = false or side_effect4()
        check(result)


describe "String Operations All Branches":
    it "concat - empty + empty":
        val s = "" + ""
        check(s == "")

    it "concat - empty + non-empty":
        val s = "" + "hello"
        check(s == "hello")

    it "concat - non-empty + empty":
        val s = "hello" + ""
        check(s == "hello")

    it "concat - non-empty + non-empty":
        val s = "hello" + " world"
        check(s == "hello world")

    it "string contains - empty in empty":
        check("".contains(""))

    it "string contains - empty in non-empty":
        check("hello".contains(""))

    it "string contains - found":
        check("hello".contains("ell"))

    it "string contains - not found":
        check(not "hello".contains("xyz"))

    it "string starts_with - empty":
        check("hello".starts_with(""))

    it "string starts_with - match":
        check("hello".starts_with("hel"))

    it "string starts_with - no match":
        check(not "hello".starts_with("llo"))

    it "string ends_with - empty":
        check("hello".ends_with(""))

    it "string ends_with - match":
        check("hello".ends_with("llo"))

    it "string ends_with - no match":
        check(not "hello".ends_with("hel"))


describe "Array Operations All Branches":
    it "array push":
        var arr = [1, 2]
        arr.push(3)
        check(arr.len() == 3)

    it "array pop - non-empty":
        fn run() -> i64:
            var arr = [1, 2, 3]
            val x = arr.pop()
            arr.len()
        check(run() == 2)

    it "array pop - empty":
        var arr: [i64] = []
        val x = arr.pop()
        check(not x.?)

    it "array contains - found":
        var arr = [1, 2, 3]
        check(arr.contains(2))

    it "array contains - not found":
        var arr = [1, 2, 3]
        check(not arr.contains(5))

    it "array contains - empty":
        val arr: [i64] = []
        check(not arr.contains(1))


describe "Range All Branches":
    it "range - positive":
        var count = 0
        for i in 0..5:
            count = count + 1
        check(count == 5)

    it "range - zero":
        var count = 0
        for i in 0..0:
            count = count + 1
        check(count == 0)

    it "range - single":
        var count = 0
        for i in 5..6:
            count = count + 1
        check(count == 1)

    it "range - negative start":
        var count = 0
        for i in -2..2:
            count = count + 1
        check(count == 4)


describe "Type Coercion All Branches":
    it "int to float implicit":
        val x: f64 = 5.0 + 3.0
        check(x == 8.0)

    it "bool to int context":
        val t = if true: 1 else: 0
        val f = if false: 1 else: 0
        check(t == 1)
        check(f == 0)


describe "Variable Scope All Branches":
    it "block scope - inner shadows outer":
        val x = 10
        var result = 0
        if true:
            val x = 20
            result = x
        check(result == 20)

    it "block scope - outer visible after":
        val x = 10
        if true:
            val y = 20
        check(x == 10)

    it "loop scope - variable local":
        var sum = 0
        for i in 0..3:
            val temp = i * 2
            sum = sum + temp
        check(sum == 6)


describe "Comparison All Branches":
    it "compare - equal same type":
        check(5 == 5)
        check("hello" == "hello")
        check(true == true)

    it "compare - not equal same type":
        check(5 != 4)
        check("hello" != "world")
        check(true != false)

    it "compare - less than":
        check(3 < 5)
        check(not (5 < 3))
        check(not (5 < 5))

    it "compare - greater than":
        check(5 > 3)
        check(not (3 > 5))
        check(not (5 > 5))

    it "compare - less or equal":
        check(3 <= 5)
        check(5 <= 5)
        check(not (5 <= 3))

    it "compare - greater or equal":
        check(5 >= 3)
        check(5 >= 5)
        check(not (3 >= 5))
