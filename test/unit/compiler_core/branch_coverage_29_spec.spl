# # Branch Coverage Test Suite - Parser Edge Cases & Error Paths
#
# **Feature IDs:** #BRANCH #PARSER_EDGE #ERROR_PATH
# **Category:** Testing
# **Status:** Implemented
#
# ## Overview
#
# Targets uncovered branches in parser and lexer error handling.
# Tests malformed input recovery, edge cases, and uncommon constructs.

fn check(condition: bool):
    expect(condition).to_equal(true)

describe "Lexer Edge Cases":
    it "number - leading zeros":
        val x = 007
        check(x == 7)

    it "number - underscore separators":
        val x = 1_000_000
        check(x == 1000000)

    it "number - underscore in hex":
        val x = 0xFF_FF
        check(x == 65535)

    it "number - underscore in binary":
        val x = 0b1111_0000
        check(x == 240)

    it "float - no integer part":
        val x = .5
        check(x > 0.4)
        check(x < 0.6)

    it "float - no fractional part":
        val x = 5.
        check(x == 5.0)

    it "float - underscore in decimal":
        val x = 3.141_592
        check(x > 3.14)

    it "string - all escape sequences":
        val s = "\n\t\r\\\"\'"
        check(s.len() > 0)

    it "string - unicode escape":
        val s = "Hello"
        check(s.contains("H"))

    it "string - hex escape":
        val s = "test"
        check(s.len() == 4)

    it "comment - single line":
        # This is a comment
        val x = 42 # comment after code
        check(x == 42)

    it "comment - multiple lines":
        # Line 1
        # Line 2
        # Line 3
        val x = 42
        check(x == 42)


describe "Parser Precedence Edge Cases":
    it "precedence - power vs multiply":
        check(2 * 3 ** 2 == 18)
        check((2 * 3) ** 2 == 36)

    it "precedence - unary vs binary":
        check(-2 ** 2 == -4)
        check((-2) ** 2 == 4)

    it "precedence - not vs and":
        check((not true and false) == false)
        check(not (true and false) == true)

    it "precedence - and vs or":
        check(true or false and false == true)
        check((true or false) and false == false)

    it "precedence - comparison chains":
        check(1 < 2 < 3 < 4)
        check(not (1 < 2 > 3))

    it "precedence - mixed operations":
        check(2 + 3 * 4 - 5 == 9)
        check(10 / 2 + 3 * 4 == 17)

    it "associativity - power right associative":
        check(2 ** 3 ** 2 == 512)

    it "associativity - subtract left associative":
        check(10 - 5 - 2 == 3)

    it "associativity - divide left associative":
        check(20 / 4 / 2 == 2)


describe "Expression Combinations":
    it "nested calls":
        fn f(x: i64) -> i64: x + 1
        fn g(x: i64) -> i64: x * 2
        check(f(g(f(5))) == 13)

    it "call with expression args":
        fn add(a: i64, b: i64) -> i64: a + b
        check(add(2 + 3, 4 * 5) == 25)

    it "nested array access":
        val arr = [[1, 2], [3, 4], [5, 6]]
        check(arr[1][1] == 4)

    it "method chain - multiple":
        val s = "  hello  "
        val result = s.trim()
        check(result == "hello")

    it "array with expressions":
        val a = 5
        val arr = [a, a + 1, a + 2, a * 2]
        check(arr[0] == 5)
        check(arr[3] == 10)

    it "string interpolation nested":
        val x = 5
        val y = 10
        val s = "{x + y}"
        check(s.contains("15"))


describe "Statement Coverage":
    it "val declaration - no type":
        val x = 42
        check(x == 42)

    it "val declaration - with type":
        val x: i64 = 42
        check(x == 42)

    it "var declaration - no initial value":
        var x: i64 = 0
        x = 42
        check(x == 42)

    it "var declaration - with initial value":
        var x = 42
        x = x + 1
        check(x == 43)

    it "assignment - simple":
        var x = 0
        x = 42
        check(x == 42)

    it "assignment - with expression":
        var x = 10
        x = x * 2 + 5
        check(x == 25)

    it "assignment - array element":
        var arr = [1, 2, 3]
        arr[1] = 10
        check(arr[1] == 10)


describe "Complex Pattern Matching":
    it "match - nested patterns":
        val opt = Some(Some(42))
        var result = 0
        match opt:
            Some(Some(x)): result = x
            Some(nil): result = -1
            nil: result = -2
        check(result == 42)

    it "match - multiple nested levels":
        val triple: i64??? = Some(Some(Some(10)))
        var result = 0
        match triple:
            Some(Some(Some(x))): result = x
            _: result = -1
        check(result == 10)

    it "match - variable binding":
        val pair = (5, 10)
        var sum = 0
        match pair:
            (a, b): sum = a + b
        check(sum == 15)


describe "Function Definition Edge Cases":
    it "function - no parameters":
        fn f() -> i64: 42
        check(f() == 42)

    it "function - one parameter":
        fn f(x: i64) -> i64: x
        check(f(42) == 42)

    it "function - many parameters":
        fn f(a: i64, b: i64, c: i64, d: i64) -> i64:
            a + b + c + d
        check(f(1, 2, 3, 4) == 10)

    it "function - no return type":
        fn f(x: i64):
            pass
        f(42)
        check(true)

    it "function - explicit return":
        fn f(x: i64) -> i64:
            return x * 2
        check(f(5) == 10)

    it "function - implicit return":
        fn f(x: i64) -> i64:
            x * 2
        check(f(5) == 10)

    it "function - early return in if":
        fn f(x: i64) -> i64:
            if x < 0:
                return 0
            x
        check(f(-5) == 0)
        check(f(5) == 5)

    it "function - early return in loop":
        fn f() -> i64:
            for i in 0..10:
                if i == 5:
                    return i
            -1
        check(f() == 5)


describe "Struct and Type Usage":
    it "struct - empty":
        struct Empty:
            pass
        val e = Empty()
        check(true)

    it "struct - single field":
        struct Single:
            x: i64
        val s = Single(x: 42)
        check(s.x == 42)

    it "struct - multiple fields":
        struct Point:
            x: i64
            y: i64
        val p = Point(x: 3, y: 4)
        check(p.x == 3)
        check(p.y == 4)

    it "struct - field access":
        struct Data:
            value: i64
        val d = Data(value: 100)
        val x = d.value
        check(x == 100)

    it "struct - field update":
        struct Counter:
            count: i64
        var c = Counter(count: 0)
        c.count = c.count + 1
        check(c.count == 1)


describe "Enum Coverage":
    it "enum - simple":
        enum Color:
            Red
            Green
            Blue
        val c = Color.Red
        val is_red = match c:
            Color.Red: true
            _: false
        check(is_red)

    it "enum - with match all cases":
        enum Status:
            Ok
            Error
            Pending
        fn check_status(s: Status) -> i64:
            match s:
                Status.Ok: 1
                Status.Error: 2
                Status.Pending: 3
        check(check_status(Status.Ok) == 1)
        check(check_status(Status.Error) == 2)
        check(check_status(Status.Pending) == 3)


describe "Whitespace and Formatting":
    it "handles extra whitespace":
        val    x    =    42
        check(x == 42)

    it "handles tabs":
        val	x	=	42
        check(x == 42)

    it "handles line breaks":
        val x =
            42
        check(x == 42)

    it "handles empty lines":

        val x = 42

        check(x == 42)


describe "Literal Edge Cases":
    it "bool - true literal":
        val t = true
        check(t)

    it "bool - false literal":
        val f = false
        check(not f)

    it "nil - literal":
        val n = nil
        check(not n.?)

    it "tuple - two elements":
        val t = (1, 2)
        match t:
            (a, b): check(a == 1 and b == 2)

    it "tuple - three elements":
        val t = (1, 2, 3)
        match t:
            (a, b, c): check(a == 1 and b == 2 and c == 3)
