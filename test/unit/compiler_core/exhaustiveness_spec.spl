# Core Simple â€” Match Exhaustiveness Checking Tests

use compiler_core.lexer.{lex_init}
use compiler_core.parser.{parse_module, parser_has_errors}
use compiler_core.ast.{ast_reset}
use compiler_core.interpreter.eval.{eval_reset, eval_module, eval_get_warnings}
use compiler_core.interpreter.env.{env_init}
use compiler_core.interpreter.value.{val_reset}

describe "Match Exhaustiveness Checking":

    describe "non-exhaustive match warns":
        it "warns when one enum variant is missing":
            val code = "enum Status:\n    Ok\n    Warn\n    Error\nfn handle(s: i64) -> text:\n    match s:\n        case Status.Ok: \"ok\"\n        case Status.Warn: \"warn\"\nhandle(0)"
            val warnings = check_warnings(code)
            val found = warnings_contain(warnings, "non-exhaustive")
            expect(found).to_equal(true)

        it "warning message includes enum type name":
            val code = "enum Status:\n    Ok\n    Warn\n    Error\nfn check(s: i64) -> text:\n    match s:\n        case Status.Ok: \"ok\"\n        case Status.Warn: \"warn\"\ncheck(0)"
            val warnings = check_warnings(code)
            val has_status = warnings_contain(warnings, "Status")
            expect(has_status).to_equal(true)

        it "warning message includes the missing variant name":
            val code = "enum Color:\n    Red\n    Green\n    Blue\nfn pick(c: i64) -> text:\n    match c:\n        case Color.Red: \"red\"\n        case Color.Green: \"green\"\npick(0)"
            val warnings = check_warnings(code)
            val has_blue = warnings_contain(warnings, "Blue")
            expect(has_blue).to_equal(true)

        it "warning starts with 'warning:' prefix":
            val code = "enum Status:\n    Ok\n    Error\nfn check(s: i64):\n    match s:\n        case Status.Ok: ()\ncheck(0)"
            val warnings = check_warnings(code)
            val has_warn_prefix = warnings_contain_prefix(warnings, "warning:")
            expect(has_warn_prefix).to_equal(true)

        it "warns for match statement (not just expression)":
            val code = "enum Status:\n    Ok\n    Error\nval s = 0\nmatch s:\n    case Status.Ok: ()"
            val warnings = check_warnings(code)
            val found = warnings_contain(warnings, "non-exhaustive")
            expect(found).to_equal(true)

    describe "exhaustive match does not warn":
        it "no warning when all variants covered":
            val code = "enum Status:\n    Ok\n    Warn\n    Error\nfn handle(s: i64) -> text:\n    match s:\n        case Status.Ok: \"ok\"\n        case Status.Warn: \"warn\"\n        case Status.Error: \"error\"\nhandle(0)"
            val warnings = check_warnings(code)
            val found = warnings_contain(warnings, "non-exhaustive")
            expect(found).to_equal(false)

        it "no warning when wildcard _ is present":
            val code = "enum Status:\n    Ok\n    Warn\n    Error\nfn handle(s: i64) -> text:\n    match s:\n        case Status.Ok: \"ok\"\n        case _: \"other\"\nhandle(0)"
            val warnings = check_warnings(code)
            val found = warnings_contain(warnings, "non-exhaustive")
            expect(found).to_equal(false)

        it "no warning when binding pattern is present":
            val code = "enum Status:\n    Ok\n    Warn\n    Error\nfn handle(s: i64) -> text:\n    match s:\n        case Status.Ok: \"ok\"\n        case x: \"other\"\nhandle(0)"
            val warnings = check_warnings(code)
            val found = warnings_contain(warnings, "non-exhaustive")
            expect(found).to_equal(false)

    describe "two-variant enum":
        it "warns when only one of two variants covered":
            val code = "enum Bool2:\n    Yes\n    No\nval b = 0\nmatch b:\n    case Bool2.Yes: ()"
            val warnings = check_warnings(code)
            val found = warnings_contain(warnings, "non-exhaustive")
            expect(found).to_equal(true)

        it "no warning for two-variant enum fully covered":
            val code = "enum Bool2:\n    Yes\n    No\nval b = 0\nmatch b:\n    case Bool2.Yes: ()\n    case Bool2.No: ()"
            val warnings = check_warnings(code)
            val found = warnings_contain(warnings, "non-exhaustive")
            expect(found).to_equal(false)

    describe "match on non-enum does not warn":
        it "no exhaustiveness warning for integer match":
            val code = "val x = 5\nmatch x:\n    case 1: ()\n    case 2: ()"
            val warnings = check_warnings(code)
            val found = warnings_contain(warnings, "non-exhaustive match on")
            expect(found).to_equal(false)

        it "no exhaustiveness warning for string match":
            val code = "val s = \"hello\"\nmatch s:\n    case \"a\": ()\n    case \"b\": ()"
            val warnings = check_warnings(code)
            val found = warnings_contain(warnings, "non-exhaustive match on")
            expect(found).to_equal(false)

# Helper: run code and return warnings
fn check_warnings(code: text) -> [text]:
    ast_reset()
    val_reset()
    env_init()
    eval_reset()

    parse_module(code, "test.spl")
    if parser_has_errors():
        return []

    eval_module()

    eval_get_warnings()

# Helper: check if any warning contains a substring
fn warnings_contain(warnings: [text], substr: text) -> bool:
    for w in warnings:
        if w.contains(substr):
            return true
    false

# Helper: check if any warning starts with a prefix
fn warnings_contain_prefix(warnings: [text], prefix: text) -> bool:
    for w in warnings:
        if w.starts_with(prefix):
            return true
    false
