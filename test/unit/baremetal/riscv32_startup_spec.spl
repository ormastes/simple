# @platform: baremetal(riscv32)
# RISC-V 32-bit Baremetal Startup Unit Tests
#
# Tests for RV32 startup code: TrapFrame32 structure, memory constants,
# UART configuration, CSR addresses, interrupt handling, and stack setup.

# ============================================================================
# Memory Configuration Constants
# ============================================================================

describe "RV32 Startup - Memory Configuration":
    it "RAM base address is 0x80000000":
        val ram_base = 0x80000000
        expect(ram_base).to_equal(0x80000000)

    it "RAM size is 128MB":
        val ram_size = 128 * 1024 * 1024
        expect(ram_size).to_equal(134217728)

    it "stack size is 64KB per hart":
        val stack_size = 65536
        expect(stack_size).to_equal(65536)

# ============================================================================
# UART Constants
# ============================================================================

describe "RV32 Startup - UART Constants":
    it "UART base address is 0x10000000":
        val uart_base = 0x10000000
        expect(uart_base).to_equal(0x10000000)

    it "PLIC base address is 0x0C000000":
        val plic_base = 0x0C000000
        expect(plic_base).to_equal(0x0C000000)

# ============================================================================
# CSR Address Constants
# ============================================================================

describe "RV32 Startup - CSR Addresses":
    it "mstatus CSR is 0x300":
        val csr_mstatus = 0x300
        expect(csr_mstatus).to_equal(0x300)

    it "misa CSR is 0x301":
        val csr_misa = 0x301
        expect(csr_misa).to_equal(0x301)

    it "mie CSR is 0x304":
        val csr_mie = 0x304
        expect(csr_mie).to_equal(0x304)

    it "mtvec CSR is 0x305":
        val csr_mtvec = 0x305
        expect(csr_mtvec).to_equal(0x305)

    it "mscratch CSR is 0x340":
        val csr_mscratch = 0x340
        expect(csr_mscratch).to_equal(0x340)

    it "mepc CSR is 0x341":
        val csr_mepc = 0x341
        expect(csr_mepc).to_equal(0x341)

    it "mcause CSR is 0x342":
        val csr_mcause = 0x342
        expect(csr_mcause).to_equal(0x342)

    it "mtval CSR is 0x343":
        val csr_mtval = 0x343
        expect(csr_mtval).to_equal(0x343)

    it "mip CSR is 0x344":
        val csr_mip = 0x344
        expect(csr_mip).to_equal(0x344)

    it "mhartid CSR is 0xF14":
        val csr_mhartid = 0xF14
        expect(csr_mhartid).to_equal(0xF14)

# ============================================================================
# Interrupt Bit - RV32 Specific (bit 31, NOT bit 63)
# ============================================================================

describe "RV32 Startup - Interrupt Cause Bits":
    it "interrupt bit is 0x80000000 (bit 31 for RV32)":
        val cause_interrupt_bit = 0x80000000
        expect(cause_interrupt_bit).to_equal(0x80000000)

    it "interrupt bit is NOT 0x8000000000000000 (that is RV64)":
        # RV32 uses bit 31, RV64 uses bit 63
        val rv32_bit = 0x80000000
        val is_32bit_range = rv32_bit <= 0xFFFFFFFF
        expect(is_32bit_range).to_equal(true)

    it "M-mode software interrupt code is 3":
        val cause_m_software = 0x80000000 | 3
        val code = cause_m_software & 0x7FFFFFFF
        expect(code).to_equal(3)

    it "M-mode timer interrupt code is 7":
        val cause_m_timer = 0x80000000 | 7
        val code = cause_m_timer & 0x7FFFFFFF
        expect(code).to_equal(7)

    it "M-mode external interrupt code is 11":
        val cause_m_external = 0x80000000 | 11
        val code = cause_m_external & 0x7FFFFFFF
        expect(code).to_equal(11)

    it "interrupt flag is detected by checking bit 31":
        val mcause_interrupt = 0x80000000 | 7
        val is_interrupt = (mcause_interrupt & 0x80000000) != 0
        expect(is_interrupt).to_equal(true)

    it "exception has no interrupt flag":
        val mcause_exception = 5  # e.g. load access fault
        val is_interrupt = (mcause_exception & 0x80000000) != 0
        expect(is_interrupt).to_equal(false)

# ============================================================================
# MSTATUS Bits
# ============================================================================

describe "RV32 Startup - MSTATUS Bits":
    it "MIE bit is 0x08 (bit 3)":
        val mstatus_mie = 0x08
        expect(mstatus_mie).to_equal(8)

    it "MPIE bit is 0x80 (bit 7)":
        val mstatus_mpie = 0x80
        expect(mstatus_mpie).to_equal(128)

# ============================================================================
# MIE (Machine Interrupt Enable) Bits
# ============================================================================

describe "RV32 Startup - MIE Bits":
    it "MSIE bit is 0x08":
        val mie_msie = 0x08
        expect(mie_msie).to_equal(8)

    it "MTIE bit is 0x80":
        val mie_mtie = 0x80
        expect(mie_mtie).to_equal(128)

    it "MEIE bit is 0x800":
        val mie_meie = 0x800
        expect(mie_meie).to_equal(2048)

    it "all interrupts enabled is MSIE | MTIE | MEIE":
        val mie_all = 0x08 | 0x80 | 0x800
        expect(mie_all).to_equal(0x888)

# ============================================================================
# TrapFrame32 Structure (32-bit fields)
# ============================================================================

describe "RV32 Startup - TrapFrame32 Structure":
    it "TrapFrame32 has 32 fields (x1-x31 + mepc + mstatus)":
        # 31 registers (x1-x31, x0 is hardwired zero) + mepc + mstatus = 33
        val field_count = 33
        expect(field_count).to_equal(33)

    it "all fields are u32 (not u64)":
        # On RV32, all registers are 32-bit
        val field_width = 32
        expect(field_width).to_equal(32)

    it "each field occupies 4 bytes":
        val field_size = 4
        expect(field_size).to_equal(4)

    it "total TrapFrame32 size is 33 fields * 4 bytes = 132 bytes":
        # x1-x31 (31 regs) + mepc + mstatus = 33 fields
        val total_size = 33 * 4
        expect(total_size).to_equal(132)

    it "x1 (ra) is at offset 0":
        val offset = 0 * 4
        expect(offset).to_equal(0)

    it "x10 (a0) is at offset 36":
        # x10 is the 10th field (0-indexed: x1=0, x2=1, ..., x10=9)
        val offset = 9 * 4
        expect(offset).to_equal(36)

    it "mepc is at offset 124":
        # After x1-x31 (31 fields * 4 bytes = 124)
        val offset = 31 * 4
        expect(offset).to_equal(124)

    it "mstatus is at offset 128":
        # After mepc (31 * 4 + 4 = 128)
        val offset = 32 * 4
        expect(offset).to_equal(128)

# ============================================================================
# Stack Alignment
# ============================================================================

describe "RV32 Startup - Stack Alignment":
    it "stack alignment is 16 bytes":
        val align = 16
        expect(align).to_equal(16)

    it "stack buffer supports 4 harts":
        val hart_count = 4
        val stack_per_hart = 65536
        val total = hart_count * stack_per_hart
        expect(total).to_equal(262144)

    it "trap frame array supports 4 harts":
        val hart_count = 4
        expect(hart_count).to_equal(4)

# ============================================================================
# Trap Vector - 32-bit Register Saves/Restores
# ============================================================================

describe "RV32 Startup - Trap Vector Register Operations":
    it "trap vector saves registers using sw (4-byte stores)":
        # The trap_vector function uses sw for all register saves
        val save_inst = "sw"
        expect(save_inst).to_equal("sw")

    it "trap vector restores registers using lw (4-byte loads)":
        val restore_inst = "lw"
        expect(restore_inst).to_equal("lw")

    it "register offsets are 4 bytes apart (not 8)":
        # On RV32, registers are 4 bytes, offsets increment by 4
        val x1_offset = 0
        val x2_offset = 4
        val x3_offset = 8
        val spacing = x2_offset - x1_offset
        expect(spacing).to_equal(4)

    it "x31 offset is 120 (30 * 4)":
        # x1 at 0, x2 at 4, ..., x31 at 30*4 = 120
        val x31_offset = 30 * 4
        expect(x31_offset).to_equal(120)

    it "mepc saved at offset 124":
        val mepc_offset = 31 * 4
        expect(mepc_offset).to_equal(124)

    it "mstatus saved at offset 128":
        val mstatus_offset = 32 * 4
        expect(mstatus_offset).to_equal(128)

    it "uses csrrw to swap sp with mscratch":
        val swap_inst = "csrrw sp, mscratch, sp"
        expect(swap_inst).to_contain("csrrw")
        expect(swap_inst).to_contain("mscratch")

    it "trap return uses mret":
        val ret_inst = "mret"
        expect(ret_inst).to_equal("mret")

# ============================================================================
# UART Driver
# ============================================================================

describe "RV32 Startup - UART Driver":
    it "UART DLAB enable is 0x80":
        val dlab_enable = 0x80
        expect(dlab_enable).to_equal(128)

    it "UART 8N1 config is 0x03":
        val uart_8n1 = 0x03
        expect(uart_8n1).to_equal(3)

    it "UART divisor for 38400 baud is 0x03":
        val divisor_lsb = 0x03
        expect(divisor_lsb).to_equal(3)

    it "UART transmitter ready mask is 0x20":
        val thr_empty_mask = 0x20
        expect(thr_empty_mask).to_equal(32)

    it "UART IER register is at offset 1":
        val ier_offset = 1
        expect(ier_offset).to_equal(1)

    it "UART LCR register is at offset 3":
        val lcr_offset = 3
        expect(lcr_offset).to_equal(3)

    it "UART LSR register is at offset 5":
        val lsr_offset = 5
        expect(lsr_offset).to_equal(5)
