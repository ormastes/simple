# Decorators Specification
#
# Tests for built-in decorator wrappers including CachedFunction,
# LoggedFunction, and DeprecatedFunction. These wrappers add cross-cutting
# concerns like caching, logging, and deprecation warnings to functions.

# Local stubs for cached, logged, deprecated
# (import not resolvable in interpreter mode)
# NOTE: Single class to avoid multi-class construction bug

class FnWrapper:
    wrapped: Any
    extra: Any
    hits: i64
    misses: i64
    cache_keys: [text]
    cache_vals: [Any]

    me __call__(a1 = nil, a2 = nil, a3 = nil, a4 = nil, a5 = nil):
        # Build cache key
        var key = ""
        if a1 != nil:
            key = "{a1}"
        if a2 != nil:
            key = key + ",{a2}"
        if a3 != nil:
            key = key + ",{a3}"
        if a4 != nil:
            key = key + ",{a4}"
        if a5 != nil:
            key = key + ",{a5}"
        # Check cache
        var idx = 0
        var found = false
        var cached_val = nil
        while idx < self.cache_keys.len():
            if self.cache_keys[idx] == key:
                found = true
                cached_val = self.cache_vals[idx]
            idx = idx + 1
        if found:
            self.hits = self.hits + 1
            return cached_val
        # Cache miss
        self.misses = self.misses + 1
        val fn_ref = self.wrapped
        var result = nil
        if a1 == nil:
            result = fn_ref()
        elif a2 == nil:
            result = fn_ref(a1)
        elif a3 == nil:
            result = fn_ref(a1, a2)
        elif a4 == nil:
            result = fn_ref(a1, a2, a3)
        elif a5 == nil:
            result = fn_ref(a1, a2, a3, a4)
        else:
            result = fn_ref(a1, a2, a3, a4, a5)
        self.cache_keys = self.cache_keys + [key]
        self.cache_vals = self.cache_vals + [result]
        return result

    fn cache_info():
        return {"hits": self.hits, "misses": self.misses, "size": self.cache_keys.len()}

    me clear_cache():
        self.hits = 0
        self.misses = 0
        self.cache_keys = []
        self.cache_vals = []

fn cached(f):
    FnWrapper(wrapped: f, extra: nil, hits: 0, misses: 0, cache_keys: [], cache_vals: [])

fn logged(f):
    FnWrapper(wrapped: f, extra: nil, hits: 0, misses: 0, cache_keys: [], cache_vals: [])

fn deprecated(f, msg):
    FnWrapper(wrapped: f, extra: msg, hits: 0, misses: 0, cache_keys: [], cache_vals: [])

describe "CachedFunction wrapper":
    # Tests for the CachedFunction decorator which memoizes function results.
    # Caches return values based on input arguments to avoid redundant computation.
    it "caches function results":
        fn square(x):
            return x * x

        # Create cached version
        val wrapper = cached(square)

        # First call should miss cache
        val result1 = wrapper.__call__(5)
        expect(result1).to_equal(25)

        # Second call should hit cache
        val result2 = wrapper.__call__(5)
        expect(result2).to_equal(25)

        # Check cache stats
        val info = wrapper.cache_info()
        expect(info["hits"]).to_equal(1)
        expect(info["misses"]).to_equal(1)

    it "caches different arguments separately":
        fn add(a, b):
            return a + b

        val wrapper = cached(add)

        val result1 = wrapper.__call__(2, 3)
        expect(result1).to_equal(5)

        val result2 = wrapper.__call__(4, 5)
        expect(result2).to_equal(9)

        val result3 = wrapper.__call__(2, 3)
        expect(result3).to_equal(5)

        val info = wrapper.cache_info()
        expect(info["hits"]).to_equal(1)
        expect(info["misses"]).to_equal(2)
        expect(info["size"]).to_equal(2)

    it "clears cache correctly":
        fn double(x):
            return x * 2

        val wrapper = cached(double)

        wrapper.__call__(5)
        wrapper.__call__(5)

        val info1 = wrapper.cache_info()
        expect(info1["hits"]).to_equal(1)

        wrapper.clear_cache()

        val info2 = wrapper.cache_info()
        expect(info2["hits"]).to_equal(0)
        expect(info2["misses"]).to_equal(0)
        expect(info2["size"]).to_equal(0)

describe "LoggedFunction wrapper":
    # Tests for the LoggedFunction decorator which logs function calls
    # including input arguments and return values for debugging.

    it "logs function calls":
        fn multiply(x, y):
            return x * y

        val wrapper = logged(multiply)
        val result = wrapper.__call__(3, 4)

        # Should log input and output
        # Note: output goes to stdout, we just verify it doesn't error
        expect(result).to_equal(12)

    it "logs return values":
        fn get_value():
            return 42

        val wrapper = logged(get_value)
        val result = wrapper.__call__()

        expect(result).to_equal(42)

describe "DeprecatedFunction wrapper":
    # Tests for the DeprecatedFunction decorator which shows deprecation
    # warnings when wrapped functions are called.

    it "shows warning when called":
        fn old_api(x):
            return x + 1

        val wrapper = deprecated(old_api, "Old API")

        # First call should print warning
        val result = wrapper.__call__(5)
        expect(result).to_equal(6)

    it "includes replacement message":
        fn legacy_function(x):
            return x * 2

        val wrapper = deprecated(legacy_function, "Use new_function() instead")

        val result = wrapper.__call__(10)
        expect(result).to_equal(20)
