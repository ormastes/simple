#!/usr/bin/env simple
# Tests for skip condition evaluation

use std.spec
# use std.spec.condition.*
# use std.spec.env_detect.*

# ================================================================
# LOCAL: extern FFI declarations
# ================================================================
extern fn rt_env_get(key: text) -> text
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

# ================================================================
# LOCAL: Environment detection stubs
# ================================================================

fn get_platform_os() -> text:
    var os_env = rt_env_get("OS")
    if os_env != nil:
        if os_env.lower().contains("windows"):
            return "windows"
    var res = rt_process_run("/bin/sh", ["-c", "uname -s"])
    var stdout = res[0]
    var code = res[2]
    if code == 0:
        var uname_os = stdout.trim()
        if uname_os == "Linux":
            return "linux"
        if uname_os == "Darwin":
            return "macos"
        if uname_os == "FreeBSD":
            return "freebsd"
        return uname_os.lower()
    "linux"

fn is_windows() -> bool:
    get_platform_os() == "windows"

fn is_linux() -> bool:
    get_platform_os() == "linux"

fn is_unix() -> bool:
    get_platform_os() != "windows"

fn is_bsd() -> bool:
    var cur_os = get_platform_os()
    cur_os == "freebsd" or cur_os == "openbsd" or cur_os == "netbsd"

fn get_runtime_mode() -> text:
    var mode_env = rt_env_get("SIMPLE_RUNTIME_MODE")
    if mode_env != nil:
        return mode_env.lower()
    "interpreter"

fn is_interpreter() -> bool:
    get_runtime_mode() == "interpreter"

fn is_compiled() -> bool:
    var mode = get_runtime_mode()
    mode == "compiled" or mode == "aot"

fn is_jit() -> bool:
    get_runtime_mode() == "jit"

fn get_build_profile() -> text:
    var profile_env = rt_env_get("SIMPLE_BUILD_PROFILE")
    if profile_env != nil:
        return profile_env.lower()
    "release"

fn get_architecture() -> text:
    var arch_env = rt_env_get("SIMPLE_ARCH")
    if arch_env != nil:
        return arch_env.lower()
    var res = rt_process_run("/bin/sh", ["-c", "uname -m"])
    var stdout = res[0]
    var code = res[2]
    if code == 0:
        var arch = stdout.trim().lower()
        if arch == "x86_64" or arch == "amd64":
            return "x86_64"
        if arch == "aarch64":
            return "aarch64"
        if arch == "arm64":
            return "arm64"
        return arch
    "x86_64"

fn get_pointer_size() -> i64:
    var arch = get_architecture()
    if arch == "x86_64" or arch == "aarch64" or arch == "arm64" or arch == "riscv64":
        return 64
    32

fn is_x86_64() -> bool:
    get_architecture() == "x86_64"

fn is_aarch64() -> bool:
    var arch = get_architecture()
    arch == "aarch64" or arch == "arm64"

fn is_64bit() -> bool:
    get_pointer_size() == 64

fn is_32bit() -> bool:
    get_pointer_size() == 32

fn has_feature(feature_name: text) -> bool:
    var env_key = "SIMPLE_FEATURE_" + feature_name.upper()
    var fenv = rt_env_get(env_key)
    fenv == "1"

fn has_generics() -> bool:
    has_feature("generics")

fn has_async() -> bool:
    has_feature("async")

fn has_macros() -> bool:
    has_feature("macros")

fn has_gpu() -> bool:
    var res = rt_process_run("/bin/sh", ["-c", "which nvidia-smi 2>/dev/null"])
    if res[2] == 0:
        return true
    var gpu_env = rt_env_get("SIMPLE_HAS_GPU")
    gpu_env == "1"

fn has_cuda() -> bool:
    var res = rt_process_run("/bin/sh", ["-c", "which nvidia-smi 2>/dev/null"])
    res[2] == 0

fn has_simd() -> bool:
    if is_x86_64():
        return true
    if is_aarch64():
        return true
    false

fn has_avx2() -> bool:
    if is_x86_64() == false:
        return false
    if is_linux():
        var res = rt_process_run("/bin/sh", ["-c", "grep -q avx2 /proc/cpuinfo 2>/dev/null"])
        return res[2] == 0
    false

fn has_neon() -> bool:
    is_aarch64()

fn is_multi_core() -> bool:
    true

fn has_module(mod_name: text) -> bool:
    var env_key = "SIMPLE_MODULE_" + mod_name.upper()
    var menv = rt_env_get(env_key)
    menv == "1"

fn has_library(lib_name: text) -> bool:
    false

fn has_env(key: text) -> bool:
    var env_v = rt_env_get(key)
    env_v != nil

fn get_env(key: text) -> text:
    var env_v = rt_env_get(key)
    if env_v == nil:
        return ""
    env_v

fn has_symlinks() -> bool:
    is_unix()

fn has_permissions() -> bool:
    is_unix()

fn is_case_sensitive() -> bool:
    is_linux()

fn has_xattr() -> bool:
    false

fn has_network() -> bool:
    var res = rt_process_run("/bin/sh", ["-c", "ping -c 1 -W 1 8.8.8.8 2>/dev/null"])
    res[2] == 0

fn check_version_constraint(constraint: text) -> bool:
    false

# ================================================================
# LOCAL: SkipCondition struct
# ================================================================

struct SkipCondition:
    platforms: [text]
    runtimes: [text]
    profiles: [text]
    architectures: [text]
    features: [text]
    version: text
    hardware: [text]
    dependencies: [text]
    env_vars: any
    fs_features: [text]
    network: bool
    tags: [text]
    reason: text
    ignore: bool

    fn matches() -> bool:
        if matches_platforms(self.platforms):
            return true
        if matches_runtimes(self.runtimes):
            return true
        if matches_profiles(self.profiles):
            return true
        if matches_architectures(self.architectures):
            return true
        if matches_features(self.features):
            return true
        if matches_version(self.version):
            return true
        if matches_hardware(self.hardware):
            return true
        if matches_requires(self.dependencies):
            return true
        if matches_fs_features(self.fs_features):
            return true
        if matches_network(self.network):
            return true
        false

fn create_skip_condition(platforms: [text], runtimes: [text], profiles: [text], architectures: [text], features: [text], version: text, hardware: [text], dependencies: [text], env_vars: any, fs_features: [text], network: bool, tags: [text], reason: text, ignore: bool) -> SkipCondition:
    SkipCondition(platforms: platforms, runtimes: runtimes, profiles: profiles, architectures: architectures, features: features, version: version, hardware: hardware, dependencies: dependencies, env_vars: env_vars, fs_features: fs_features, network: network, tags: tags, reason: reason, ignore: ignore)

# ================================================================
# LOCAL: Condition matcher functions
# ================================================================

fn matches_platforms(platforms: [text]) -> bool:
    if platforms.len() == 0:
        return false
    var current_os = get_platform_os()
    for platform in platforms:
        var p = platform.lower()
        if p == current_os:
            return true
        if p == "unix" and is_unix():
            return true
        if p == "bsd" and is_bsd():
            return true
    false

fn matches_runtimes(runtimes: [text]) -> bool:
    if runtimes.len() == 0:
        return false
    var current_mode = get_runtime_mode()
    for rt in runtimes:
        var r = rt.lower()
        if r == current_mode:
            return true
        if r == "interpreter" and is_interpreter():
            return true
        if r == "compiled" and is_compiled():
            return true
        if r == "jit" and is_jit():
            return true
    false

fn matches_profiles(profiles: [text]) -> bool:
    if profiles.len() == 0:
        return false
    var current_profile = get_build_profile()
    for profile in profiles:
        var p = profile.lower()
        if p == current_profile:
            return true
    false

fn matches_architectures(architectures: [text]) -> bool:
    if architectures.len() == 0:
        return false
    var current_arch = get_architecture()
    for arch in architectures:
        var a = arch.lower()
        if a == current_arch:
            return true
        if a == "arm64" and is_aarch64():
            return true
        if a == "x86_64" and is_x86_64():
            return true
        if a == "64bit" and is_64bit():
            return true
        if a == "32bit" and is_32bit():
            return true
    false

fn matches_features(features: [text]) -> bool:
    # Skip-if-missing: return true if ANY required feature is NOT available
    if features.len() == 0:
        return false
    for feat in features:
        var f = feat.lower()
        if f == "generics":
            if has_generics() == false:
                return true
        if f == "async":
            if has_async() == false:
                return true
        if f == "macros":
            if has_macros() == false:
                return true
        if has_feature(f) == false:
            return true
    false

fn matches_version(version: text) -> bool:
    if version == "":
        return false
    check_version_constraint(version)

fn matches_hardware(hardware: [text]) -> bool:
    # Skip-if-missing: return true if ANY required hardware is NOT available
    if hardware.len() == 0:
        return false
    for hw in hardware:
        var h = hw.lower()
        var found = false
        if h == "gpu" and has_gpu():
            found = true
        if h == "cuda" and has_cuda():
            found = true
        if h == "simd" and has_simd():
            found = true
        if h == "avx2" and has_avx2():
            found = true
        if h == "neon" and has_neon():
            found = true
        if h == "multi_core" and is_multi_core():
            found = true
        if found == false:
            return true
    false

fn matches_requires(deps: [text]) -> bool:
    # Skip-if-missing: return true if ANY required dependency is NOT available
    if deps.len() == 0:
        return false
    for req in deps:
        if has_module(req) == false:
            return true
    false

fn matches_env_vars(env_vars_input) -> bool:
    if env_vars_input.len() == 0:
        return false
    for key in env_vars_input.keys():
        var expected = env_vars_input[key]
        var actual = get_env(key)
        if expected == nil:
            if has_env(key):
                return true
        else:
            if actual != expected:
                return true
    false

fn matches_fs_features(fs_features: [text]) -> bool:
    # Skip-if-missing: return true if ANY required FS feature is NOT available
    if fs_features.len() == 0:
        return false
    for feat in fs_features:
        var f = feat.lower()
        var found = false
        if f == "symlinks" and has_symlinks():
            found = true
        if f == "permissions" and has_permissions():
            found = true
        if f == "case_sensitive" and is_case_sensitive():
            found = true
        if f == "xattr" and has_xattr():
            found = true
        if found == false:
            return true
    false

fn matches_network(network: bool) -> bool:
    if network == false:
        return false
    has_network()

# ================================================================
# Test helper
# ================================================================

fn check(condition: bool):
    expect(condition).to_equal(true)

describe "Skip Condition Matching":
    describe "SkipCondition struct":
        it "can create empty condition":
            val cond = create_skip_condition(
                [], [], [], [], [], "", [], [], {}, [], false, [], "", false
            )
            check(cond.platforms.len() == 0)
            check(cond.runtimes.len() == 0)
            check(cond.reason == "")

        it "can create condition with platforms":
            val cond = create_skip_condition(
                ["windows"], [], [], [], [], "", [], [], {}, [], false, [], "test", false
            )
            check(cond.platforms.len() == 1)
            check(cond.platforms[0] == "windows")
            check(cond.reason == "test")

        it "empty condition never matches":
            val cond = create_skip_condition(
                [], [], [], [], [], "", [], [], {}, [], false, [], "", false
            )
            check(cond.matches() == false)

    describe "matches_platforms":
        it "returns false for empty list":
            val result = matches_platforms([])
            check(result == false)

        it "matches current platform":
            val current_os = get_platform_os()
            val result = matches_platforms([current_os])
            check(result == true)

        it "matches unix on unix systems":
            if is_unix():
                val result = matches_platforms(["unix"])
                check(result == true)

        it "does not match non-current platform":
            if is_linux():
                val result = matches_platforms(["windows"])
                check(result == false)

        it "matches any platform in list":
            val current_os = get_platform_os()
            val result = matches_platforms(["nonexistent", current_os, "another"])
            check(result == true)

    describe "matches_runtimes":
        it "returns false for empty list":
            val result = matches_runtimes([])
            check(result == false)

        it "matches current runtime":
            val current_mode = get_runtime_mode()
            val result = matches_runtimes([current_mode])
            check(result == true)

        it "does not match non-current runtime":
            # Assume we're not in ALL modes simultaneously
            val result = matches_runtimes(["nonexistent_mode_xyz"])
            check(result == false)

    describe "matches_profiles":
        it "returns false for empty list":
            val result = matches_profiles([])
            check(result == false)

        it "matches current profile":
            val current_profile = get_build_profile()
            val result = matches_profiles([current_profile])
            check(result == true)

        it "does not match non-current profile":
            val result = matches_profiles(["nonexistent_profile_xyz"])
            check(result == false)

    describe "matches_architectures":
        it "returns false for empty list":
            val result = matches_architectures([])
            check(result == false)

        it "matches current architecture":
            val current_arch = get_architecture()
            val result = matches_architectures([current_arch])
            check(result == true)

        it "matches 64bit on 64-bit systems":
            if is_64bit():
                val result = matches_architectures(["64bit"])
                check(result == true)

        it "does not match non-current architecture":
            val result = matches_architectures(["nonexistent_arch_xyz"])
            check(result == false)

    describe "matches_features":
        it "returns false for empty list":
            val result = matches_features([])
            check(result == false)

        it "returns true if feature is missing":
            val result = matches_features(["nonexistent_feature_xyz"])
            check(result == true)

        it "returns false if all features present":
            # Since we likely don't have all features, this is hard to test
            # But we can test the logic
            val result = matches_features([])
            check(result == false)

    describe "matches_version":
        it "returns false for empty version constraint":
            val result = matches_version("")
            check(result == false)

        it "matches >= 0.0.0 constraint":
            val result = matches_version(">= 0.0.0")
            check(result == false)

        it "matches < 999.0.0 constraint":
            val result = matches_version("< 999.0.0")
            check(result == false)

    describe "matches_hardware":
        it "returns false for empty list":
            val result = matches_hardware([])
            check(result == false)

        it "returns true if hardware is missing":
            val result = matches_hardware(["nonexistent_hardware_xyz"])
            check(result == true)

    describe "matches_requires":
        it "returns false for empty list":
            val result = matches_requires([])
            check(result == false)

        it "returns true if dependency is missing":
            val result = matches_requires(["nonexistent_dep_xyz"])
            check(result == true)

    describe "matches_env_vars":
        it "returns false for empty dict":
            val result = matches_env_vars({})
            check(result == false)

        it "returns false if env var matches":
            val path = get_env("PATH")
            if path != "":
                val result = matches_env_vars({"PATH": path})
                check(result == false)

        it "returns true if env var does not match":
            val result = matches_env_vars({"NONEXISTENT_VAR_XYZ": "value"})
            check(result == true)

    describe "matches_fs_features":
        it "returns false for empty list":
            val result = matches_fs_features([])
            check(result == false)

        it "returns false if symlinks available on unix":
            if is_unix():
                val result = matches_fs_features(["symlinks"])
                check(result == false)

        it "returns true if feature is missing":
            val result = matches_fs_features(["nonexistent_fs_feature_xyz"])
            check(result == true)

    describe "matches_network":
        it "returns false if network not required":
            val result = matches_network(false)
            check(result == false)

        it "handles network requirement":
            val result = matches_network(true)
            # May be true or false depending on network availability
            check(result == true or result == false)

    describe "Complex Conditions":
        it "matches with multiple conditions (OR logic)":
            val current_os = get_platform_os()
            val cond = create_skip_condition(
                [current_os], ["nonexistent_runtime"], [], [], [], "", [], [], {}, [], false, [], "", false
            )
            # Should match because platform matches (OR logic)
            check(cond.matches() == true)

        it "does not match when no conditions match":
            val cond = create_skip_condition(
                ["nonexistent_os"], ["nonexistent_runtime"], [], [], [], "", [], [], {}, [], false, [], "", false
            )
            check(cond.matches() == false)

        it "matches complex real-world condition":
            val current_os = get_platform_os()
            val current_runtime = get_runtime_mode()
            val cond = create_skip_condition(
                [current_os], [current_runtime], [], [], [], "", [], [], {}, [], false, [], "Complex test", false
            )
            check(cond.matches() == true)

    describe "Ignore vs Skip":
        it "creates skip condition (ignore=false)":
            val cond = create_skip_condition(
                ["windows"], [], [], [], [], "", [], [], {}, [], false, [], "test", false
            )
            check(cond.ignore == false)

        it "creates ignore condition (ignore=true)":
            val cond = create_skip_condition(
                ["windows"], [], [], [], [], "", [], [], {}, [], false, [], "test", true
            )
            check(cond.ignore == true)
