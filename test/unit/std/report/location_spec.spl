"""
# SourceLocation Specification

**Feature IDs:** #RPT-002
**Category:** Infrastructure
**Difficulty:** 2/5
**Status:** Implemented

## Overview

Tests for Span, SourceLocation, and Label types from the unified reporting system.
Verifies byte range handling, location formatting, and label creation.

## Key Concepts

| Concept | Description |
|---------|-------------|
| Span | Byte range (start, end) in source code |
| SourceLocation | Full location with file, line, column, and span |
| Label | Annotated span with message for diagnostics |
"""

use std.report.*

# ============================================================================
# Test Group 1: Span
# ============================================================================

describe "Span":
    """
    ## Span Byte Range

    Tests for the Span struct which represents a byte range in source code.
    """

    context "creation":
        """
        ### Span Creation

        Spans can be created from range, at position, or empty.
        """

        it "creates span from range":
            val span = Span.from_range(10, 20)
            expect(span.start).to_equal(10)
            expect(span.end).to_equal(20)

        it "creates span at single position":
            val span = Span.at(15)
            expect(span.start).to_equal(15)
            expect(span.end).to_equal(15)

        it "creates empty span":
            val span = Span.empty()
            expect(span.start).to_equal(0)
            expect(span.end).to_equal(0)

    context "length calculation":
        """
        ### Span Length

        Span length is the difference between end and start.
        """

        it "calculates length correctly":
            val span = Span.from_range(10, 25)
            expect(span.len()).to_equal(15)

        it "empty span has zero length":
            val span = Span.empty()
            expect(span.len()).to_equal(0)

        it "single position span has zero length":
            val span = Span.at(10)
            expect(span.len()).to_equal(0)

    context "is_empty":
        """
        ### Empty Span Detection

        A span is empty when start >= end.
        """

        it "empty span is_empty returns true":
            val span = Span.empty()
            expect(span.is_empty()).to_be_true()

        it "non-empty span is_empty returns false":
            val span = Span.from_range(0, 10)
            expect(span.is_empty()).to_be_false()

    context "extend_to":
        """
        ### Span Extension

        Spans can be extended to include another span.
        """

        it "extends to include both spans":
            val span1 = Span.from_range(10, 20)
            val span2 = Span.from_range(15, 30)
            val extended = span1.extend_to(span2)
            expect(extended.start).to_equal(10)
            expect(extended.end).to_equal(30)

        it "extends to non-overlapping span":
            val span1 = Span.from_range(0, 10)
            val span2 = Span.from_range(20, 30)
            val extended = span1.extend_to(span2)
            expect(extended.start).to_equal(0)
            expect(extended.end).to_equal(30)

    context "contains_pos":
        """
        ### Position Containment

        Check if a byte position is within the span.
        """

        it "contains position within span":
            val span = Span.from_range(10, 20)
            expect(span.contains_pos(15)).to_be_true()

        it "contains start position":
            val span = Span.from_range(10, 20)
            expect(span.contains_pos(10)).to_be_true()

        it "does not contain end position":
            val span = Span.from_range(10, 20)
            expect(span.contains_pos(20)).to_be_false()

        it "does not contain position before span":
            val span = Span.from_range(10, 20)
            expect(span.contains_pos(5)).to_be_false()

    context "overlaps":
        """
        ### Span Overlap Detection

        Check if two spans overlap.
        """

        it "detects overlapping spans":
            val span1 = Span.from_range(10, 20)
            val span2 = Span.from_range(15, 25)
            expect(span1.overlaps(span2)).to_be_true()

        it "detects non-overlapping spans":
            val span1 = Span.from_range(10, 20)
            val span2 = Span.from_range(25, 35)
            expect(span1.overlaps(span2)).to_be_false()

        it "adjacent spans do not overlap":
            val span1 = Span.from_range(10, 20)
            val span2 = Span.from_range(20, 30)
            expect(span1.overlaps(span2)).to_be_false()

    context "extract":
        """
        ### Text Extraction

        Extract the text covered by the span from source.
        """

        it "extracts text from source":
            val span = Span.from_range(0, 5)
            val source = "hello world"
            expect(span.extract(source)).to_equal("hello")

        it "extracts middle of source":
            val span = Span.from_range(6, 11)
            val source = "hello world"
            expect(span.extract(source)).to_equal("world")

        it "returns empty for out of bounds":
            val span = Span.from_range(100, 110)
            val source = "hello"
            expect(span.extract(source)).to_equal("")

# ============================================================================
# Test Group 2: SourceLocation
# ============================================================================

describe "SourceLocation":
    """
    ## SourceLocation

    Tests for the SourceLocation struct with file, line, column, and span.
    """

    context "creation":
        """
        ### SourceLocation Creation

        Locations can be created at a position or with full span info.
        """

        it "creates location at position":
            val loc = SourceLocation.at("test.spl", 10, 5)
            expect(loc.file).to_equal("test.spl")
            expect(loc.line).to_equal(10)
            expect(loc.column).to_equal(5)

        it "creates location with span":
            val span = Span.from_range(100, 110)
            val loc = SourceLocation.from_span("test.spl", span, 10, 5, 10, 15)
            expect(loc.span.start).to_equal(100)
            expect(loc.span.end).to_equal(110)

        it "creates unknown location":
            val loc = SourceLocation.unknown()
            expect(loc.file).to_equal("<unknown>")
            expect(loc.line).to_equal(0)

    context "validity":
        """
        ### Location Validity

        A location is valid if line and column are positive.
        """

        it "valid location is_valid returns true":
            val loc = SourceLocation.at("test.spl", 10, 5)
            expect(loc.is_valid()).to_be_true()

        it "unknown location is_valid returns false":
            val loc = SourceLocation.unknown()
            expect(loc.is_valid()).to_be_false()

        it "zero line is invalid":
            val loc = SourceLocation.at("test.spl", 0, 5)
            expect(loc.is_valid()).to_be_false()

    context "multiline detection":
        """
        ### Multiline Locations

        Locations can span multiple lines.
        """

        it "single line is not multiline":
            val loc = SourceLocation.at("test.spl", 10, 5)
            expect(loc.is_multiline()).to_be_false()

        it "span across lines is multiline":
            val span = Span.from_range(100, 200)
            val loc = SourceLocation.from_span("test.spl", span, 10, 5, 12, 10)
            expect(loc.is_multiline()).to_be_true()

    context "formatting":
        """
        ### Location Formatting

        Locations can be formatted as strings.
        """

        it "formats short as file:line:column":
            val loc = SourceLocation.at("test.spl", 10, 5)
            expect(loc.format_short()).to_equal("test.spl:10:5")

        it "formats full for multiline":
            val span = Span.from_range(100, 200)
            val loc = SourceLocation.from_span("test.spl", span, 10, 5, 12, 10)
            expect(loc.format_full()).to_contain("10:5")
            expect(loc.format_full()).to_contain("12:10")

    context "extend_to":
        """
        ### Location Extension

        Locations in the same file can be extended to include another.
        """

        it "extends to include both locations":
            val loc1 = SourceLocation.at("test.spl", 10, 5)
            val loc2 = SourceLocation.at("test.spl", 15, 10)
            val extended = loc1.extend_to(loc2)
            expect(extended.line).to_equal(10)
            expect(extended.get_end_line()).to_equal(15)

        it "does not extend across files":
            val loc1 = SourceLocation.at("test1.spl", 10, 5)
            val loc2 = SourceLocation.at("test2.spl", 15, 10)
            val extended = loc1.extend_to(loc2)
            expect(extended.file).to_equal("test1.spl")

# ============================================================================
# Test Group 3: Label
# ============================================================================

describe "Label":
    """
    ## Label

    Tests for the Label struct which annotates a span with a message.
    """

    context "creation":
        """
        ### Label Creation

        Labels can be primary (main error) or secondary (related).
        """

        it "creates primary label":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val label = Label.primary(loc, "error here")
            expect(label.primary).to_be_true()
            expect(label.message).to_equal("error here")

        it "creates secondary label":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val label = Label.secondary(loc, "related location")
            expect(label.primary).to_be_false()

        it "creates label at position":
            val label = Label.at("test.spl", 10, 5, "message")
            expect(label.location.file).to_equal("test.spl")
            expect(label.location.line).to_equal(10)
            expect(label.primary).to_be_true()

    context "underline character":
        """
        ### Underline Characters

        Primary labels use ^, secondary use -.
        """

        it "primary label uses caret":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val label = Label.primary(loc, "error")
            expect(label.underline_char()).to_equal("^")

        it "secondary label uses dash":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val label = Label.secondary(loc, "note")
            expect(label.underline_char()).to_equal("-")
