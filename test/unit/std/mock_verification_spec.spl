# @pending
# Mock Verification Specification - Phase 2
# Feature IDs: Testing Infrastructure - Mock Verification
# Category: Testing

"""
Mock Verification Test Suite - Phase 2

Tests the verification capabilities of the mocking library, including:
- Call count expectations and verification
- Argument matching with various matchers (eq, any, gt, lt, contains, etc.)
- Call retrieval and inspection (get_call, get_last_call)
- VerificationResult success/failure handling
- Error message quality for mismatched expectations
"""

use testing.mocking as mocking

describe "Mock Library - Phase 2 (Verification)":
    """
    Verifies the mock verification system that allows tests to assert
    how mock functions were called. Covers expectation setting for call
    counts and arguments, a comprehensive set of argument matchers for
    flexible matching (equality, numeric comparisons, string operations),
    call history inspection, and detailed error messages when verification fails.
    """
    context "Expectations":
        it "sets expectation for call count":
            val mock_fn = mocking.MockFunction.new("handler")
            mock_fn.expect_call(2)
            mock_fn.record_call([])
            mock_fn.record_call([])
            val result = mock_fn.verify()
            expect result.is_ok()

        it "fails verification when call count mismatches":
            val mock_fn = mocking.MockFunction.new("process")
            mock_fn.expect_call(3)
            mock_fn.record_call([])
            mock_fn.record_call([])
            val result = mock_fn.verify()
            expect result.is_err()

        it "sets expectation for call arguments":
            val mock_fn = mocking.MockFunction.new("save")
            mock_fn.expect_call_with(["id_123", "data"])
            mock_fn.record_call(["id_123", "data"])
            val result = mock_fn.verify()
            expect result.is_ok()

        it "fails when arguments don't match":
            val mock_fn = mocking.MockFunction.new("update")
            mock_fn.expect_call_with(["old_value"])
            mock_fn.record_call(["new_value"])
            val result = mock_fn.verify()
            expect result.is_err()

    context "VerificationResult":
        it "returns success result":
            val result = mocking.VerificationResult.success()
            expect result.is_ok()
            expect not result.is_err()

        it "returns failure result with message":
            val result = mocking.VerificationResult.failure("Test failed")
            expect result.is_err()
            expect not result.is_ok()
            expect result.unwrap_err() == "Test failed"

    context "Argument Matchers - Equality":
        it "uses eq matcher for exact match":
            val matcher = mocking.Matcher.eq("hello")
            expect matcher.matches("hello")
            expect not matcher.matches("world")

        it "uses any matcher for wildcard":
            val matcher = mocking.Matcher.any()
            expect matcher.matches("anything")
            expect matcher.matches("123")
            expect matcher.matches("")

    context "Argument Matchers - Numeric":
        it "uses gt matcher for greater than":
            val matcher = mocking.Matcher.gt(10)
            expect matcher.matches("15")
            expect matcher.matches("100")
            expect not matcher.matches("5")
            expect not matcher.matches("10")

        it "uses lt matcher for less than":
            val matcher = mocking.Matcher.lt(10)
            expect matcher.matches("5")
            expect matcher.matches("0")
            expect not matcher.matches("10")
            expect not matcher.matches("15")

        it "uses gte matcher for greater or equal":
            val matcher = mocking.Matcher.gte(10)
            expect matcher.matches("10")
            expect matcher.matches("15")
            expect not matcher.matches("9")

        it "uses lte matcher for less or equal":
            val matcher = mocking.Matcher.lte(10)
            expect matcher.matches("10")
            expect matcher.matches("5")
            expect not matcher.matches("11")

    context "Argument Matchers - String Operations":
        it "uses contains matcher":
            val matcher = mocking.Matcher.contains("error")
            expect matcher.matches("fatal error occurred")
            expect matcher.matches("error")
            expect not matcher.matches("warning")

        it "uses starts_with matcher":
            val matcher = mocking.Matcher.starts_with("HTTP")
            expect matcher.matches("HTTP/1.1")
            expect matcher.matches("HTTPS")
            expect not matcher.matches("GET HTTP")

        it "uses ends_with matcher":
            val matcher = mocking.Matcher.ends_with(".json")
            expect matcher.matches("config.json")
            expect matcher.matches("data.json")
            expect not matcher.matches("config.yaml")

    context "Call Verification":
        it "verifies no calls were made":
            val mock_fn = mocking.MockFunction.new("unused")
            expect not mock_fn.was_called()

        it "verifies single call":
            val mock_fn = mocking.MockFunction.new("called_once")
            mock_fn.record_call([])
            expect mock_fn.was_called()
            expect mock_fn.was_called_n_times(1)

        it "verifies specific call count":
            val mock_fn = mocking.MockFunction.new("counter")
            mock_fn.record_call([])
            mock_fn.record_call([])
            mock_fn.record_call([])
            expect mock_fn.was_called_n_times(3)

        it "gets call by index":
            val mock_fn = mocking.MockFunction.new("api")
            mock_fn.record_call(["GET", "/users"])
            mock_fn.record_call(["POST", "/users"])
            val first = mock_fn.get_call(0)
            expect first.is_some()
            match first:
                Some(call): expect call.args[0] == "GET"
                nil: fail "Should have call"

        it "gets last call":
            val mock_fn = mocking.MockFunction.new("sequence")
            mock_fn.record_call(["first"])
            mock_fn.record_call(["second"])
            mock_fn.record_call(["third"])
            val last = mock_fn.get_last_call()
            expect last.is_some()
            match last:
                Some(call): expect call.args[0] == "third"
                nil: fail "Should have last call"

    context "Verification Error Messages":
        it "provides error message for call count mismatch":
            val mock_fn = mocking.MockFunction.new("test_fn")
            mock_fn.expect_call(2)
            mock_fn.record_call([])
            val result = mock_fn.verify()
            expect result.is_err()
            val msg = result.unwrap_err()
            expect msg.contains("test_fn")
            expect msg.contains("2")
            expect msg.contains("1")

        it "provides error message for argument mismatch":
            val mock_fn = mocking.MockFunction.new("service")
            mock_fn.expect_call_with(["expected_arg"])
            mock_fn.record_call(["actual_arg"])
            val result = mock_fn.verify()
            expect result.is_err()
            val msg = result.unwrap_err()
            expect msg.contains("service")
            expect msg.contains("expected_arg")

    context "Multiple Expectations":
        it "verifies multiple expectations":
            val mock_fn = mocking.MockFunction.new("multi")
            mock_fn.expect_call(2)
            mock_fn.record_call([])
            mock_fn.record_call([])
            val result = mock_fn.verify()
            expect result.is_ok()

        it "resets expectations on reset":
            val mock_fn = mocking.MockFunction.new("resettable")
            mock_fn.expect_call(1)
            mock_fn.reset()
            mock_fn.record_call([])
            mock_fn.record_call([])
            val result = mock_fn.verify()
            expect result.is_ok()

    context "Integer Literal Type Inference":
        """
        Reproducing test for i64 to usize cast bug.
        Integer literals default to i64, but get_call expects i32.
        The fix is to accept i64 in get_call method.
        """
        it "handles i64 literal in get_call":
            val mock_fn = mocking.MockFunction.new("literal_test")
            mock_fn.record_call(["first"])
            mock_fn.record_call(["second"])
            # This should work with i64 literal 0
            val call = mock_fn.get_call(0)
            expect call.is_some()

        it "handles i64 literal in array indexing":
            val mock_fn = mocking.MockFunction.new("index_test")
            mock_fn.record_call(["value"])
            val call = mock_fn.get_call(0)
            match call:
                Some(c):
                    # Array indexing with i64 literal
                    expect c.args[0] == "value"
                nil: fail "Should have call"
