# # Performance Optimization Specification
#
# **Feature IDs:** #perf-001 through #perf-003
# **Category:** Runtime | Infrastructure
# **Difficulty:** 4/5
# **Status:** In Progress
#
# ## Overview
#
# Intensive tests for performance optimization changes:
# 1. rt_thread_spawn_isolated closure execution (was stub)
# 2. rt_set_concurrent_backend / rt_get_concurrent_backend FFI
# 3. Integration: concurrent backend + thread spawn + channels
#
# ## Key Concepts
#
# | Concept | Description |
# |---------|-------------|
# | Backend switching | PureStd (single-thread) vs Native (concurrent crates) |
# | Closure execution | rt_thread_spawn_isolated now evaluates closure body |
# | Channel communication | Threads can send/receive values via channels |

# ============================================================================
# Extern declarations
# ============================================================================

extern fn rt_thread_available_parallelism() -> i64
extern fn rt_thread_sleep(millis: i64)
extern fn rt_thread_yield()
extern fn rt_thread_spawn_isolated(closure: Any) -> i64
extern fn rt_thread_spawn_isolated2(closure: Any, data1: Any, data2: Any) -> i64
extern fn rt_thread_join(handle: i64) -> Any
extern fn rt_thread_is_done(handle: i64) -> i64
extern fn rt_thread_id(handle: i64) -> i64
extern fn rt_thread_free(handle: i64)
extern fn rt_channel_new() -> i64
extern fn rt_channel_send(channel_id: i64, value: Any)
extern fn rt_channel_try_recv(channel_id: i64) -> Any
extern fn rt_channel_recv(channel_id: i64) -> Any
extern fn rt_channel_close(channel_id: i64)
extern fn rt_channel_is_closed(channel_id: i64) -> i64
extern fn rt_set_concurrent_backend(name: text)
extern fn rt_get_concurrent_backend() -> text

# ============================================================================
# Helpers
# ============================================================================

struct Channel:
    _id: i64

    fn send(self, value: Any):
        rt_channel_send(self._id, value)

    fn try_recv(self) -> Any:
        return rt_channel_try_recv(self._id)

    fn recv(self) -> Any:
        return rt_channel_recv(self._id)

    fn close(self):
        rt_channel_close(self._id)

    fn is_closed(self) -> bool:
        return rt_channel_is_closed(self._id) == 1

fn new_channel() -> Channel:
    val id = rt_channel_new()
    return Channel(_id: id)

struct ThreadHandle:
    _handle: i64

    fn join(self) -> Any:
        return rt_thread_join(self._handle)

    fn is_done(self) -> bool:
        return rt_thread_is_done(self._handle) == 1

    fn id(self) -> i64:
        return rt_thread_id(self._handle)

fn spawn_thread(closure: Any) -> ThreadHandle:
    val handle = rt_thread_spawn_isolated(closure)
    return ThreadHandle(_handle: handle)

fn spawn2(data1: Any, data2: Any, closure: fn(Any, Any) -> Any) -> ThreadHandle:
    val handle = rt_thread_spawn_isolated2(closure=closure, data1=data1, data2=data2)
    return ThreadHandle(_handle: handle)

# ============================================================================
# Test Group 1: rt_thread_spawn_isolated - Closure Execution
# ============================================================================

describe "rt_thread_spawn_isolated - Closure Execution":
    # ## Closure Execution (was stub)
    #
    # Previously rt_thread_spawn_isolated returned a dummy handle without
    # executing the closure. Now it extracts Lambda params/body/env,
    # evaluates the body, and stores the result for rt_thread_join.

    context "basic closure execution":
        it "executes closure and returns result via join":
            val handle = spawn_thread(\: 42)
            val result = handle.join()
            expect result == 42

        it "executes closure with arithmetic":
            val handle = spawn_thread(\: 10 + 20 + 12)
            val result = handle.join()
            expect result == 42

        it "executes closure with string result":
            val handle = spawn_thread(\: "hello world")
            val result = handle.join()
            expect result == "hello world"

        it "executes closure returning nil":
            val handle = spawn_thread(\: nil)
            val result = handle.join()
            expect result == nil

    context "closure with captures":
        it "captures outer variable":
            val x = 100
            val handle = spawn_thread(\: x + 1)
            val result = handle.join()
            expect result == 101

        it "captures multiple variables":
            val a = 10
            val b = 20
            val c = 30
            val handle = spawn_thread(\: a + b + c)
            val result = handle.join()
            expect result == 60

        it "captures list and operates on it":
            val items = [1, 2, 3, 4, 5]
            val handle = spawn_thread(\: items.len())
            val result = handle.join()
            expect result == 5

    context "unique handle IDs":
        it "assigns incrementing handle IDs":
            val h1 = spawn_thread(\: 1)
            val h2 = spawn_thread(\: 2)
            val h3 = spawn_thread(\: 3)
            expect h1.id() < h2.id()
            expect h2.id() < h3.id()
            h1.join()
            h2.join()
            h3.join()

        it "handles are always positive":
            val h = spawn_thread(\: nil)
            expect h._handle >= 1
            h.join()

    context "thread is done after synchronous execution":
        it "reports done immediately for PureStd":
            val handle = spawn_thread(\: 42)
            expect handle.is_done()
            handle.join()

    context "multiple spawns and joins":
        it "spawns 10 threads and joins all":
            var results = []
            for i in 0..10:
                val handle = spawn_thread(\: i * i)
                results = results.push(handle.join())
            expect results.len() == 10

        it "spawns and joins in different order":
            val h1 = spawn_thread(\: "first")
            val h2 = spawn_thread(\: "second")
            val h3 = spawn_thread(\: "third")
            val r3 = h3.join()
            val r1 = h1.join()
            val r2 = h2.join()
            expect r1 == "first"
            expect r2 == "second"
            expect r3 == "third"

# ============================================================================
# Test Group 2: rt_thread_spawn_isolated2 - Two-arg Closure Execution
# ============================================================================

describe "rt_thread_spawn_isolated2 - Two-arg Closure":
    # ## Two-argument closure with context
    #
    # rt_thread_spawn_isolated2 receives (closure, data1, data2),
    # binds params, evaluates body in cloned environment.

    context "basic two-arg execution":
        it "adds two numbers":
            val handle = spawn2(5, 3) \x, y: x + y
            val result = handle.join()
            expect result == 8

        it "concatenates strings":
            val handle = spawn2("hello", " world") \a, b: a + b
            val result = handle.join()
            expect result == "hello world"

        it "returns first argument":
            val handle = spawn2(42, 99) \x, y: x
            val result = handle.join()
            expect result == 42

        it "returns second argument":
            val handle = spawn2(42, 99) \x, y: y
            val result = handle.join()
            expect result == 99

    context "closure with channel communication":
        it "sends result via channel":
            val ch = new_channel()
            val handle = spawn2(6, ch._id) \data, channel_id:
                rt_channel_send(channel_id, data * 7)
                return nil

            handle.join()
            val result = ch.try_recv()
            expect result == 42
            ch.close()

        it "sends multiple values via channel":
            val ch = new_channel()
            val handle = spawn2(3, ch._id) \count, channel_id:
                for i in 0..count:
                    rt_channel_send(channel_id, i * 10)
                return nil

            handle.join()
            expect ch.try_recv() == 0
            expect ch.try_recv() == 10
            expect ch.try_recv() == 20
            ch.close()

    context "multiple two-arg spawns":
        it "runs 5 threads with accumulation":
            var total = 0
            for i in 0..5:
                val handle = spawn2(i, i + 1) \a, b: a * b
                total = total + handle.join()
            # 0*1 + 1*2 + 2*3 + 3*4 + 4*5 = 0+2+6+12+20 = 40
            expect total == 40

# ============================================================================
# Test Group 3: Backend Configuration FFI
# ============================================================================

describe "Concurrent Backend Configuration":
    # ## rt_set_concurrent_backend / rt_get_concurrent_backend
    #
    # Allows switching between "pure_std" and "native" backends at runtime.

    context "default backend":
        it "starts with pure_std":
            val backend = rt_get_concurrent_backend()
            expect backend == "pure_std"

    context "switching backends":
        it "switches to native and back":
            rt_set_concurrent_backend("native")
            expect rt_get_concurrent_backend() == "native"
            rt_set_concurrent_backend("pure_std")
            expect rt_get_concurrent_backend() == "pure_std"

        it "accepts std as alias for pure_std":
            rt_set_concurrent_backend("std")
            expect rt_get_concurrent_backend() == "pure_std"

        it "accepts pure_std explicitly":
            rt_set_concurrent_backend("pure_std")
            expect rt_get_concurrent_backend() == "pure_std"

    context "thread operations work after backend switch":
        it "spawns thread after switching to native":
            rt_set_concurrent_backend("native")
            val handle = spawn_thread(\: 42)
            val result = handle.join()
            expect result == 42
            rt_set_concurrent_backend("pure_std")

        it "channel works after switching to native":
            rt_set_concurrent_backend("native")
            val ch = new_channel()
            ch.send(100)
            val result = ch.try_recv()
            expect result == 100
            ch.close()
            rt_set_concurrent_backend("pure_std")

        it "spawn_isolated2 works in native mode":
            rt_set_concurrent_backend("native")
            val handle = spawn2(10, 5) \a, b: a - b
            val result = handle.join()
            expect result == 5
            rt_set_concurrent_backend("pure_std")

    context "round-trip backend switch":
        it "works after pure_std to native to pure_std":
            rt_set_concurrent_backend("native")
            rt_set_concurrent_backend("pure_std")
            val handle = spawn_thread(\: "survived")
            expect handle.join() == "survived"

    context "parallelism query per backend":
        it "reports parallelism in pure_std":
            rt_set_concurrent_backend("pure_std")
            val cores = rt_thread_available_parallelism()
            expect cores >= 1

        it "reports parallelism in native":
            rt_set_concurrent_backend("native")
            val cores = rt_thread_available_parallelism()
            expect cores >= 1
            rt_set_concurrent_backend("pure_std")

# ============================================================================
# Test Group 4: Integration - Thread Spawn + Channel + Backend
# ============================================================================

describe "Integration - Threads + Channels + Backend":
    # ## End-to-End Integration
    #
    # Tests combining closure execution, channel communication,
    # and backend switching.

    context "producer-consumer pattern":
        it "thread produces main consumes":
            val ch = new_channel()
            val handle = spawn2(ch._id, 5) \channel_id, count:
                for i in 0..count:
                    rt_channel_send(channel_id, i * 10)
                return "done"

            handle.join()

            var sum = 0
            for _ in 0..5:
                val v = ch.try_recv()
                if v != nil:
                    sum = sum + v

            expect sum == 100
            ch.close()

    context "fan-out pattern":
        it "spawns multiple threads writing to same channel":
            val ch = new_channel()
            var handles = []

            for i in 0..5:
                val h = spawn2(i, ch._id) \data, channel_id:
                    rt_channel_send(channel_id, data)
                    return nil
                handles = handles.push(h)

            for h in handles:
                h.join()

            var received = []
            for _ in 0..5:
                val v = ch.try_recv()
                if v != nil:
                    received = received.push(v)

            expect received.len() == 5
            ch.close()

    context "thread with complex captured data":
        it "captures dict and processes it":
            val data = {"a": 1, "b": 2, "c": 3}
            val handle = spawn2(data, nil) \d, _:
                var total = 0
                for k in d.keys():
                    total = total + d[k]
                return total

            val result = handle.join()
            expect result == 6

        it "captures list and computes sum":
            val numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
            val handle = spawn2(numbers, nil) \nums, _:
                var sum = 0
                for n in nums:
                    sum = sum + n
                return sum

            expect handle.join() == 55

    context "backend switch during active work":
        it "completes work switches continues":
            val h1 = spawn_thread(\: "pure_std_result")
            expect h1.join() == "pure_std_result"

            rt_set_concurrent_backend("native")
            val h2 = spawn_thread(\: "native_result")
            expect h2.join() == "native_result"

            rt_set_concurrent_backend("pure_std")
            val h3 = spawn_thread(\: "back_to_std")
            expect h3.join() == "back_to_std"

# ============================================================================
# Test Group 5: Stress Tests
# ============================================================================

describe "Stress Tests":
    # ## Stress and volume tests
    #
    # Verify correctness under higher load for threads and channels.

    context "many thread spawns":
        it "spawns and joins 50 threads":
            var results = []
            for i in 0..50:
                val h = spawn_thread(\: i)
                results = results.push(h.join())
            expect results.len() == 50

        it "spawns 50 two-arg threads":
            var total = 0
            for i in 0..50:
                val h = spawn2(i, 1) \a, b: a + b
                total = total + h.join()
            # Sum of (i+1) for i in 0..50 = 0+1+1+2+1+3+...+1+50 = sum(1..51) = 1275
            expect total == 1275

    context "many channel operations":
        it "sends and receives 100 messages":
            val ch = new_channel()
            for i in 0..100:
                ch.send(i)

            var sum = 0
            for _ in 0..100:
                sum = sum + ch.try_recv()

            expect sum == 4950
            ch.close()

        it "creates and closes 20 channels":
            var channels = []
            for _ in 0..20:
                channels = channels.push(new_channel())

            for ch in channels:
                ch.send(42)

            for ch in channels:
                expect ch.try_recv() == 42
                ch.close()

            for ch in channels:
                expect ch.is_closed()

    context "thread spawn with channel stress":
        it "10 threads each send 5 messages":
            val ch = new_channel()
            var handles = []

            for i in 0..10:
                val h = spawn2(i, ch._id) \thread_num, channel_id:
                    for j in 0..5:
                        rt_channel_send(channel_id, thread_num * 100 + j)
                    return nil
                handles = handles.push(h)

            for h in handles:
                h.join()

            var count = 0
            var msg = ch.try_recv()
            while msg != nil:
                count = count + 1
                msg = ch.try_recv()

            expect count == 50
            ch.close()

    context "rapid backend switching under load":
        it "alternates backends 10 times with spawns":
            for round in 0..10:
                if round % 2 == 0:
                    rt_set_concurrent_backend("pure_std")
                else:
                    rt_set_concurrent_backend("native")

                val h = spawn_thread(\: round)
                expect h.join() == round

            rt_set_concurrent_backend("pure_std")

    context "thread free cleanup":
        it "frees 20 handles without error":
            for i in 0..20:
                val h = spawn_thread(\: i)
                h.join()
                rt_thread_free(h._handle)

# ============================================================================
# Test Group 6: Edge Cases
# ============================================================================

describe "Edge Cases":
    # ## Edge cases and boundary conditions

    context "closure returning complex types":
        it "returns a list":
            val handle = spawn_thread(\: [1, 2, 3])
            val result = handle.join()
            expect result == [1, 2, 3]

        it "returns a dict":
            val handle = spawn_thread(\: {"key": "value"})
            val result = handle.join()
            expect result["key"] == "value"

        it "returns nested structure":
            val handle = spawn_thread(\: {"nums": [1, 2, 3], "name": "test"})
            val result = handle.join()
            expect result["nums"].len() == 3
            expect result["name"] == "test"

    context "closure with empty body":
        it "returns nil for empty closure":
            val handle = spawn_thread(\: nil)
            expect handle.join() == nil

    context "channel edge cases":
        it "try_recv on empty channel returns nil":
            val ch = new_channel()
            val result = ch.try_recv()
            expect result == nil
            ch.close()

        it "is_closed after close":
            val ch = new_channel()
            expect not ch.is_closed()
            ch.close()
            expect ch.is_closed()

    context "thread yield and sleep":
        it "yield does not crash":
            rt_thread_yield()
            expect true

        it "sleep for 1ms does not crash":
            rt_thread_sleep(1)
            expect true

    context "spawn_isolated with no extra args":
        it "closure with no parameters works":
            val h = spawn_thread(\: 99)
            expect h.join() == 99

    context "spawn2 with nil arguments":
        it "handles nil data arguments":
            val handle = spawn2(nil, nil) \a, b: "ok"
            expect handle.join() == "ok"
