# Multi-Threaded Async Runtime Tests
#
# Tests for thread-safe async components.

use std.async_host.thread_safe_queue.{ThreadSafeQueue}
use std.async_host.worker_thread.{WorkerThread}
use std.async_host.runtime.{HostRuntime, RuntimeMode}
use std.async_host.scheduler.{HostScheduler, SchedulerMode}
use std.thread_sffi.{thread_sleep}

describe "ThreadSafeQueue":
    it "creates empty queue":
        val queue = ThreadSafeQueue.new()
        expect(queue.is_empty()).to_equal(true)
        expect(queue.len()).to_equal(0)
        queue.destroy()

    it "pushes single item":
        val queue = ThreadSafeQueue.new()
        queue.push(42)
        expect(queue.is_empty()).to_equal(false)
        expect(queue.len()).to_equal(1)
        queue.destroy()

    it "pops single item":
        val queue = ThreadSafeQueue.new()
        queue.push(42)
        val item = queue.try_pop()
        match item:
            case Some(val):
                expect(val).to_equal(42)
            case nil:
                expect(false).to_equal(true)  # Should not be nil
        queue.destroy()

    it "try_pop on empty returns nil":
        val queue = ThreadSafeQueue.new()
        val item = queue.try_pop()
        match item:
            case Some(_):
                expect(false).to_equal(true)  # Should be nil
            case nil:
                expect(true).to_equal(true)
        queue.destroy()

    it "pushes multiple items":
        val queue = ThreadSafeQueue.new()
        queue.push(1)
        queue.push(2)
        queue.push(3)
        expect(queue.len()).to_equal(3)
        queue.destroy()

    it "pops in FIFO order":
        val queue = ThreadSafeQueue.new()
        queue.push(1)
        queue.push(2)
        queue.push(3)

        val i1 = queue.try_pop()
        val i2 = queue.try_pop()
        val i3 = queue.try_pop()

        match i1:
            case Some(v): expect(v).to_equal(1)
            case nil: expect(false).to_equal(true)

        match i2:
            case Some(v): expect(v).to_equal(2)
            case nil: expect(false).to_equal(true)

        match i3:
            case Some(v): expect(v).to_equal(3)
            case nil: expect(false).to_equal(true)

        queue.destroy()

    it "push/pop interleaved":
        val queue = ThreadSafeQueue.new()
        queue.push(1)
        val v1 = queue.try_pop()
        queue.push(2)
        val v2 = queue.try_pop()

        match v1:
            case Some(val): expect(val).to_equal(1)
            case nil: pass

        match v2:
            case Some(val): expect(val).to_equal(2)
            case nil: pass

        queue.destroy()

    it "clears queue":
        val queue = ThreadSafeQueue.new()
        queue.push(1)
        queue.push(2)
        queue.push(3)
        queue.clear()
        expect(queue.is_empty()).to_equal(true)
        expect(queue.len()).to_equal(0)
        queue.destroy()

    it "len updates correctly":
        val queue = ThreadSafeQueue.new()
        expect(queue.len()).to_equal(0)
        queue.push(1)
        expect(queue.len()).to_equal(1)
        queue.push(2)
        expect(queue.len()).to_equal(2)
        queue.try_pop()
        expect(queue.len()).to_equal(1)
        queue.try_pop()
        expect(queue.len()).to_equal(0)
        queue.destroy()

    it "handles many items":
        val queue = ThreadSafeQueue.new()
        for i in 0..100:
            queue.push(i)
        expect(queue.len()).to_equal(100)

        var count = 0
        for i in 0..100:
            val item = queue.try_pop()
            match item:
                case Some(_): count = count + 1
                case nil: pass

        expect(count).to_equal(100)
        expect(queue.is_empty()).to_equal(true)
        queue.destroy()

describe "ThreadSafeQueue blocking":
    it "pop_blocking with timeout returns nil":
        val queue = ThreadSafeQueue.new()
        val item = queue.pop_blocking(10)  # 10ms timeout
        match item:
            case Some(_):
                expect(false).to_equal(true)  # Should timeout
            case nil:
                expect(true).to_equal(true)
        queue.destroy()

    it "pop_blocking succeeds immediately if item available":
        val queue = ThreadSafeQueue.new()
        queue.push(42)
        val item = queue.pop_blocking(100)
        match item:
            case Some(v): expect(v).to_equal(42)
            case nil: expect(false).to_equal(true)
        queue.destroy()

describe "WorkerThread":
    it "creates worker thread":
        val local = ThreadSafeQueue.new()
        val global_q = ThreadSafeQueue.new()
        val worker = WorkerThread.new(0, local, global_q)
        expect(worker.worker_id).to_equal(0)
        expect(worker.is_running).to_equal(false)
        local.destroy()
        global_q.destroy()

    it "worker is idle when no tasks":
        val local = ThreadSafeQueue.new()
        val global_q = ThreadSafeQueue.new()
        val worker = WorkerThread.new(0, local, global_q)
        expect(worker.is_idle()).to_equal(true)
        local.destroy()
        global_q.destroy()

    it "run_one_task returns false when no tasks":
        val local = ThreadSafeQueue.new()
        val global_q = ThreadSafeQueue.new()
        var worker = WorkerThread.new(0, local, global_q)
        expect(worker.run_one_task()).to_equal(false)
        local.destroy()
        global_q.destroy()

    it "run_one_task returns true with local task":
        val local = ThreadSafeQueue.new()
        val global_q = ThreadSafeQueue.new()
        var worker = WorkerThread.new(0, local, global_q)

        local.push(1)
        expect(worker.run_one_task()).to_equal(true)

        local.destroy()
        global_q.destroy()

    it "run_one_task returns true with global task":
        val local = ThreadSafeQueue.new()
        val global_q = ThreadSafeQueue.new()
        var worker = WorkerThread.new(0, local, global_q)

        global_q.push(1)
        expect(worker.run_one_task()).to_equal(true)

        local.destroy()
        global_q.destroy()

    it "shutdown sets flag":
        val local = ThreadSafeQueue.new()
        val global_q = ThreadSafeQueue.new()
        var worker = WorkerThread.new(0, local, global_q)

        worker.shutdown()
        expect(worker.shutdown_requested).to_equal(true)

        local.destroy()
        global_q.destroy()

describe "HostRuntime modes":
    it "creates single-threaded runtime":
        val runtime = HostRuntime.new()
        expect(runtime.is_multi_threaded()).to_equal(false)
        expect(runtime.num_threads).to_equal(1)

    it "creates multi-threaded runtime":
        val runtime = HostRuntime.multi_threaded(4)
        expect(runtime.is_multi_threaded()).to_equal(true)
        expect(runtime.num_threads).to_equal(4)

    it "auto-detects CPU count when 0":
        val runtime = HostRuntime.multi_threaded(0)
        expect(runtime.is_multi_threaded()).to_equal(true)
        expect(runtime.num_threads > 0).to_equal(true)

    it "with_workers is single-threaded":
        val runtime = HostRuntime.with_workers(4)
        expect(runtime.is_multi_threaded()).to_equal(false)
        expect(runtime.num_threads).to_equal(1)

describe "HostScheduler modes":
    it "creates single-threaded scheduler":
        val scheduler = HostScheduler.new(4)
        expect(scheduler.is_multi_threaded()).to_equal(false)
        expect(scheduler.worker_count).to_equal(4)

    it "creates multi-threaded scheduler":
        val scheduler = HostScheduler.new_multi_threaded(4)
        expect(scheduler.is_multi_threaded()).to_equal(true)
        expect(scheduler.worker_count).to_equal(4)

    it "multi-threaded has thread-safe queues":
        val scheduler = HostScheduler.new_multi_threaded(4)
        expect(scheduler.thread_safe_queues.len()).to_equal(4)

    it "single-threaded has no thread-safe queues":
        val scheduler = HostScheduler.new(4)
        expect(scheduler.thread_safe_queues.len()).to_equal(0)

describe "ThreadSafeQueue stress test":
    it "handles 1000 push/pop cycles":
        val queue = ThreadSafeQueue.new()
        var count = 0

        for i in 0..1000:
            queue.push(i)
            val item = queue.try_pop()
            match item:
                case Some(_): count = count + 1
                case nil: pass

        expect(count).to_equal(1000)
        queue.destroy()

    it "handles 10000 items in batch":
        val queue = ThreadSafeQueue.new()

        for i in 0..10000:
            queue.push(i)

        expect(queue.len()).to_equal(10000)

        var popped = 0
        for i in 0..10000:
            val item = queue.try_pop()
            match item:
                case Some(_): popped = popped + 1
                case nil: pass

        expect(popped).to_equal(10000)
        expect(queue.is_empty()).to_equal(true)
        queue.destroy()

describe "Integration test":
    it "runtime with multi-threaded scheduler":
        val runtime = HostRuntime.multi_threaded(2)
        expect(runtime.is_multi_threaded()).to_equal(true)
        expect(runtime.scheduler.is_multi_threaded()).to_equal(true)
        expect(runtime.scheduler.worker_count).to_equal(2)

    it "runtime schedules tasks":
        val runtime = HostRuntime.new()
        expect(runtime.scheduler.has_runnable()).to_equal(false)
        expect(runtime.scheduler.is_idle()).to_equal(true)
