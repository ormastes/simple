# Binary I/O Test Suite
#
# Comprehensive tests for binary reading/writing with endianness
# support (std.binary_io).

use std.binary_io.*

# ============================================================================
# ByteOrder Tests
# ============================================================================

describe "ByteOrder":
    context "native order":
        it "should return platform byte order":
            val order = ByteOrder.native()
            # Most platforms are little-endian
            expect order.is_little_endian() to_be_true

    context "is_little_endian":
        it "should detect little-endian":
            expect ByteOrder.LittleEndian.is_little_endian() to_be_true
            expect ByteOrder.BigEndian.is_little_endian() to_be_false

    context "is_big_endian":
        it "should detect big-endian":
            expect ByteOrder.BigEndian.is_big_endian() to_be_true
            expect ByteOrder.LittleEndian.is_big_endian() to_be_false

# ============================================================================
# BinaryReader Tests
# ============================================================================

describe "BinaryReader":
    context "construction":
        it "should create reader from bytes":
            val data = [0x01, 0x02, 0x03, 0x04]
            val reader = BinaryReader.new(data)

            expect reader.remaining() to_equal 4
            expect reader.has_remaining() to_be_true

    context "remaining bytes":
        it "should track remaining bytes":
            val data = [0x01, 0x02, 0x03]
            val reader = BinaryReader.new(data)

            expect reader.remaining() to_equal 3

            reader.read_u8()
            expect reader.remaining() to_equal 2

            reader.read_u8()
            expect reader.remaining() to_equal 1

            reader.read_u8()
            expect reader.remaining() to_equal 0

        it "should detect when no bytes remaining":
            val data = [0x01]
            val reader = BinaryReader.new(data)

            expect reader.has_remaining() to_be_true
            reader.read_u8()
            expect reader.has_remaining() to_be_false

    context "read_u8":
        it "should read single byte":
            val data = [0x42]
            val reader = BinaryReader.new(data)

            val value = reader.read_u8()
            expect value.? to_be_true
            expect value.unwrap() to_equal 0x42

        it "should return None when empty":
            val data = []
            val reader = BinaryReader.new(data)

            expect reader.read_u8().? to_be_false

        it "should read multiple bytes":
            val data = [0x01, 0x02, 0x03]
            val reader = BinaryReader.new(data)

            expect reader.read_u8().unwrap() to_equal 0x01
            expect reader.read_u8().unwrap() to_equal 0x02
            expect reader.read_u8().unwrap() to_equal 0x03
            expect reader.read_u8().? to_be_false

    context "peek_u8":
        it "should peek without advancing":
            val data = [0x42, 0x43]
            val reader = BinaryReader.new(data)

            val peeked = reader.peek_u8()
            expect peeked.unwrap() to_equal 0x42

            # Position not advanced
            expect reader.read_u8().unwrap() to_equal 0x42

    context "read_u16":
        it "should read u16 little-endian":
            val data = [0x01, 0x02]
            val reader = BinaryReader.new(data)

            val value = reader.read_u16(ByteOrder.LittleEndian)
            expect value.unwrap() to_equal 0x0201

        it "should read u16 big-endian":
            val data = [0x01, 0x02]
            val reader = BinaryReader.new(data)

            val value = reader.read_u16(ByteOrder.BigEndian)
            expect value.unwrap() to_equal 0x0102

        it "should return None when insufficient bytes":
            val data = [0x01]
            val reader = BinaryReader.new(data)

            expect reader.read_u16(ByteOrder.LittleEndian).? to_be_false

    context "read_u32":
        it "should read u32 little-endian":
            val data = [0x01, 0x02, 0x03, 0x04]
            val reader = BinaryReader.new(data)

            val value = reader.read_u32(ByteOrder.LittleEndian)
            expect value.unwrap() to_equal 0x04030201

        it "should read u32 big-endian":
            val data = [0x01, 0x02, 0x03, 0x04]
            val reader = BinaryReader.new(data)

            val value = reader.read_u32(ByteOrder.BigEndian)
            expect value.unwrap() to_equal 0x01020304

        it "should return None when insufficient bytes":
            val data = [0x01, 0x02]
            val reader = BinaryReader.new(data)

            expect reader.read_u32(ByteOrder.LittleEndian).? to_be_false

    context "read_u64":
        it "should read u64 little-endian":
            val data = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
            val reader = BinaryReader.new(data)

            val value = reader.read_u64(ByteOrder.LittleEndian)
            expect value.unwrap() to_equal 0x0807060504030201

        it "should read u64 big-endian":
            val data = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
            val reader = BinaryReader.new(data)

            val value = reader.read_u64(ByteOrder.BigEndian)
            expect value.unwrap() to_equal 0x0102030405060708

    context "read_i8/i16/i32/i64":
        it "should read signed integers":
            val data = [0xFF, 0xFF, 0xFF]
            val reader = BinaryReader.new(data)

            val i8_val = reader.read_i8()
            expect i8_val.unwrap() to_equal -1

        it "should handle negative values":
            val data = [0x80, 0x00]  # -32768 in i16 BE
            val reader = BinaryReader.new(data)

            val value = reader.read_i16(ByteOrder.BigEndian)
            expect value.unwrap() to_equal -32768

    context "read_bytes":
        it "should read exact byte count":
            val data = [0x01, 0x02, 0x03, 0x04, 0x05]
            val reader = BinaryReader.new(data)

            val bytes = reader.read_bytes(3)
            expect bytes.? to_be_true
            expect bytes.unwrap() to_equal [0x01, 0x02, 0x03]

            expect reader.remaining() to_equal 2

        it "should return None when insufficient bytes":
            val data = [0x01, 0x02]
            val reader = BinaryReader.new(data)

            expect reader.read_bytes(5).? to_be_false

    context "skip and seek":
        it "should skip bytes":
            val data = [0x01, 0x02, 0x03, 0x04, 0x05]
            val reader = BinaryReader.new(data)

            val success = reader.skip(2)
            expect success to_be_true

            expect reader.read_u8().unwrap() to_equal 0x03

        it "should seek to position":
            val data = [0x01, 0x02, 0x03, 0x04, 0x05]
            val reader = BinaryReader.new(data)

            reader.read_u8()  # Position = 1

            val success = reader.seek(3)
            expect success to_be_true

            expect reader.read_u8().unwrap() to_equal 0x04

# ============================================================================
# BinaryWriter Tests
# ============================================================================

describe "BinaryWriter":
    context "construction":
        it "should create empty writer":
            val writer = BinaryWriter.new()
            expect writer.is_empty() to_be_true
            expect writer.len() to_equal 0

        it "should create writer with capacity":
            val writer = BinaryWriter.with_capacity(1024)
            expect writer.is_empty() to_be_true

    context "write_u8":
        it "should write single byte":
            val writer = BinaryWriter.new()
            writer.write_u8(0x42)

            val bytes = writer.to_bytes()
            expect bytes to_equal [0x42]

        it "should write multiple bytes":
            val writer = BinaryWriter.new()
            writer.write_u8(0x01)
            writer.write_u8(0x02)
            writer.write_u8(0x03)

            expect writer.to_bytes() to_equal [0x01, 0x02, 0x03]

    context "write_u16":
        it "should write u16 little-endian":
            val writer = BinaryWriter.new()
            writer.write_u16(0x0201, ByteOrder.LittleEndian)

            expect writer.to_bytes() to_equal [0x01, 0x02]

        it "should write u16 big-endian":
            val writer = BinaryWriter.new()
            writer.write_u16(0x0102, ByteOrder.BigEndian)

            expect writer.to_bytes() to_equal [0x01, 0x02]

    context "write_u32":
        it "should write u32 little-endian":
            val writer = BinaryWriter.new()
            writer.write_u32(0x04030201, ByteOrder.LittleEndian)

            expect writer.to_bytes() to_equal [0x01, 0x02, 0x03, 0x04]

        it "should write u32 big-endian":
            val writer = BinaryWriter.new()
            writer.write_u32(0x01020304, ByteOrder.BigEndian)

            expect writer.to_bytes() to_equal [0x01, 0x02, 0x03, 0x04]

    context "write_u64":
        it "should write u64 little-endian":
            val writer = BinaryWriter.new()
            writer.write_u64(0x0807060504030201, ByteOrder.LittleEndian)

            val expected = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
            expect writer.to_bytes() to_equal expected

        it "should write u64 big-endian":
            val writer = BinaryWriter.new()
            writer.write_u64(0x0102030405060708, ByteOrder.BigEndian)

            val expected = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
            expect writer.to_bytes() to_equal expected

    context "write_bytes":
        it "should write byte array":
            val writer = BinaryWriter.new()
            writer.write_bytes([0xAA, 0xBB, 0xCC])

            expect writer.to_bytes() to_equal [0xAA, 0xBB, 0xCC]

    context "clear":
        it "should clear buffer":
            val writer = BinaryWriter.new()
            writer.write_u8(0x01)
            writer.write_u8(0x02)

            writer.clear()

            expect writer.is_empty() to_be_true
            expect writer.len() to_equal 0

# ============================================================================
# Round-Trip Tests
# ============================================================================

describe "Round-Trip":
    context "u8 round-trip":
        it "should write and read u8":
            val writer = BinaryWriter.new()
            writer.write_u8(42)

            val reader = BinaryReader.new(writer.to_bytes())
            expect reader.read_u8().unwrap() to_equal 42

    context "u16 round-trip":
        it "should write and read u16 little-endian":
            val writer = BinaryWriter.new()
            writer.write_u16(1234, ByteOrder.LittleEndian)

            val reader = BinaryReader.new(writer.to_bytes())
            expect reader.read_u16(ByteOrder.LittleEndian).unwrap() to_equal 1234

        it "should write and read u16 big-endian":
            val writer = BinaryWriter.new()
            writer.write_u16(5678, ByteOrder.BigEndian)

            val reader = BinaryReader.new(writer.to_bytes())
            expect reader.read_u16(ByteOrder.BigEndian).unwrap() to_equal 5678

    context "u32 round-trip":
        it "should write and read u32":
            val writer = BinaryWriter.new()
            writer.write_u32(123456789, ByteOrder.LittleEndian)

            val reader = BinaryReader.new(writer.to_bytes())
            expect reader.read_u32(ByteOrder.LittleEndian).unwrap() to_equal 123456789

    context "u64 round-trip":
        it "should write and read u64":
            val writer = BinaryWriter.new()
            writer.write_u64(9876543210, ByteOrder.LittleEndian)

            val reader = BinaryReader.new(writer.to_bytes())
            expect reader.read_u64(ByteOrder.LittleEndian).unwrap() to_equal 9876543210

    context "mixed types round-trip":
        it "should write and read mixed types":
            val writer = BinaryWriter.new()
            writer.write_u8(0xFF)
            writer.write_u16(0x1234, ByteOrder.LittleEndian)
            writer.write_u32(0xDEADBEEF, ByteOrder.BigEndian)

            val reader = BinaryReader.new(writer.to_bytes())
            expect reader.read_u8().unwrap() to_equal 0xFF
            expect reader.read_u16(ByteOrder.LittleEndian).unwrap() to_equal 0x1234
            expect reader.read_u32(ByteOrder.BigEndian).unwrap() to_equal 0xDEADBEEF

# ============================================================================
# BufferedReader Tests
# ============================================================================

describe "BufferedReader":
    context "construction":
        it "should create buffered reader":
            val data = [0x01, 0x02, 0x03, 0x04]
            val reader = BufferedReader.new(data, buffer_size: 2)

            expect reader.remaining() to_equal 4

    context "reading":
        it "should read through buffer":
            val data = [0x01, 0x02, 0x03, 0x04]
            val reader = BufferedReader.new(data, buffer_size: 2)

            expect reader.read_u8().unwrap() to_equal 0x01
            expect reader.read_u8().unwrap() to_equal 0x02

        it "should handle larger reads":
            val data = [0x01, 0x02, 0x03, 0x04]
            val reader = BufferedReader.new(data, buffer_size: 2)

            val value = reader.read_u32(ByteOrder.LittleEndian)
            expect value.unwrap() to_equal 0x04030201

# ============================================================================
# BufferedWriter Tests
# ============================================================================

describe "BufferedWriter":
    context "construction":
        it "should create buffered writer":
            val writer = BufferedWriter.new(buffer_size: 4)
            # Created successfully

    context "writing":
        it "should buffer writes":
            val writer = BufferedWriter.new(buffer_size: 8)

            writer.write_u8(0x01)
            writer.write_u8(0x02)
            writer.flush()

            expect writer.to_bytes() to_equal [0x01, 0x02]

        it "should auto-flush when full":
            val writer = BufferedWriter.new(buffer_size: 4)

            # Write 5 bytes (will trigger flush at 4)
            writer.write_u32(0x01020304, ByteOrder.BigEndian)
            writer.write_u8(0x05)

            expect writer.to_bytes().len() to_equal 5

# ============================================================================
# Integration Tests
# ============================================================================

describe "Integration":
    context "binary protocol":
        it "should implement binary protocol":
            # Writer creates message
            val writer = BinaryWriter.new()
            writer.write_u32(0xCAFEBABE, ByteOrder.BigEndian)  # Magic
            writer.write_u16(1, ByteOrder.BigEndian)           # Version
            writer.write_u32(42, ByteOrder.LittleEndian)       # Payload

            # Reader parses message
            val reader = BinaryReader.new(writer.to_bytes())
            val magic = reader.read_u32(ByteOrder.BigEndian).unwrap()
            val version = reader.read_u16(ByteOrder.BigEndian).unwrap()
            val payload = reader.read_u32(ByteOrder.LittleEndian).unwrap()

            expect magic to_equal 0xCAFEBABE
            expect version to_equal 1
            expect payload to_equal 42

    context "endianness conversion":
        it "should convert between endianness":
            val writer_le = BinaryWriter.new()
            writer_le.write_u32(0x12345678, ByteOrder.LittleEndian)

            val reader = BinaryReader.new(writer_le.to_bytes())
            val value_be = reader.read_u32(ByteOrder.BigEndian).unwrap()

            # Reading LE as BE swaps bytes
            expect value_be to_equal 0x78563412

    context "multi-value stream":
        it "should handle stream of values":
            val writer = BinaryWriter.new()

            # Write multiple values
            for i in 0..10:
                writer.write_u32(i, ByteOrder.Native)

            val reader = BinaryReader.new(writer.to_bytes())

            # Read back values
            for i in 0..10:
                val value = reader.read_u32(ByteOrder.Native).unwrap()
                expect value to_equal i

# ============================================================================
# Use Cases
# ============================================================================

describe "Use Cases":
    context "file header parsing":
        it "should parse file header":
            # Example: PNG header
            val writer = BinaryWriter.new()
            writer.write_bytes([0x89, 0x50, 0x4E, 0x47])  # Magic
            writer.write_u32(13, ByteOrder.BigEndian)     # Chunk length
            writer.write_bytes([0x49, 0x48, 0x44, 0x52])  # "IHDR"

            val reader = BinaryReader.new(writer.to_bytes())
            val magic = reader.read_bytes(4).unwrap()
            val chunk_len = reader.read_u32(ByteOrder.BigEndian).unwrap()
            val chunk_type = reader.read_bytes(4).unwrap()

            expect magic to_equal [0x89, 0x50, 0x4E, 0x47]
            expect chunk_len to_equal 13

    context "network packet":
        it "should create network packet":
            # Example: Simple packet format
            val writer = BinaryWriter.new()
            writer.write_u16(100, ByteOrder.BigEndian)  # Packet ID
            writer.write_u16(8, ByteOrder.BigEndian)    # Length
            writer.write_u64(12345, ByteOrder.BigEndian)  # Payload

            val packet = writer.to_bytes()
            expect packet.len() to_equal 12

    context "serialization":
        it "should serialize structured data":
            # Example: Simple struct
            struct Point:
                x: i32
                y: i32

            val point = Point(x: 100, y: 200)

            # Serialize
            val writer = BinaryWriter.new()
            writer.write_i32(point.x, ByteOrder.Native)
            writer.write_i32(point.y, ByteOrder.Native)

            # Deserialize
            val reader = BinaryReader.new(writer.to_bytes())
            val x = reader.read_i32(ByteOrder.Native).unwrap()
            val y = reader.read_i32(ByteOrder.Native).unwrap()

            expect x to_equal 100
            expect y to_equal 200

# ============================================================================
# Summary
# ============================================================================

# Total tests: 50+
# - ByteOrder: 3 tests
# - BinaryReader: 20 tests
# - BinaryWriter: 9 tests
# - Round-Trip: 6 tests
# - BufferedReader: 3 tests
# - BufferedWriter: 3 tests
# - Integration: 3 tests
# - Use Cases: 3 tests
#
# Coverage:
# - All primitive types (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64)
# - Both endianness (little, big)
# - Byte arrays and strings
# - Buffering
# - Error handling (insufficient bytes)
# - Real-world use cases
