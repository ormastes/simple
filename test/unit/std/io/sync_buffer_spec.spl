"""
# Sync Buffered I/O Specification

**Feature IDs:** #IO-SYNC-BUFFER
**Category:** Stdlib
**Difficulty:** 3/5
**Status:** Implemented

## Overview

BufferedReader and BufferedWriter wrap any Read/Write implementor,
reducing syscall overhead by batching operations through an in-memory buffer.

## Syntax

```simple
val raw = FileHandle.read_file("big.bin")?
val reader = BufferedReader.new(raw)
val line = reader.read_line()?
reader.close()?

val out = FileHandle.create("output.bin")?
val writer = BufferedWriter.new(out)
writer.write_text("hello")?
writer.flush()?
writer.close()?
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| BufferedReader | Wraps Read — buffers reads (default 8KB) |
| BufferedWriter | Wraps Write — buffers writes (default 8KB) |
| with_capacity | Custom buffer size constructor |

## Behavior

- BufferedReader reads from buffer first, refills when empty
- BufferedWriter accumulates writes, flushes when full or on flush()
- close() on BufferedWriter flushes then closes inner
- Works with any Read/Write implementor (FileHandle, TcpStream, etc.)
"""

use std.spec

# ============================================================================
# BufferedReader
# ============================================================================

describe "BufferedReader":
    """
    ## Buffered Read Wrapper

    Reduces read syscalls by maintaining an in-memory buffer.
    Wraps any Read implementor.
    """

    context "construction":
        """
        ### Creating BufferedReader
        """

        it "creates with default capacity":
            val path = "/tmp/simple_io_spec_bufr.txt"
            File.write(path, "buffered read test")?
            val raw = FileHandle.read_file(path)?
            val reader = BufferedReader.new(raw)
            expect(reader.buf_size).to_equal(8192)
            reader.close()?

        it "creates with custom capacity":
            val path = "/tmp/simple_io_spec_bufr2.txt"
            File.write(path, "custom cap")?
            val raw = FileHandle.read_file(path)?
            val reader = BufferedReader.with_capacity(raw, 4096)
            expect(reader.buf_size).to_equal(4096)
            reader.close()?

    context "reading through buffer":
        """
        ### Buffered Reading

        Reads from internal buffer first, refills from inner when empty.
        """

        it "reads all content":
            val path = "/tmp/simple_io_spec_bufr3.txt"
            File.write(path, "hello, buffer")?
            val raw = FileHandle.read_file(path)?
            val reader = BufferedReader.new(raw)
            val content = reader.read_text()?
            expect(content).to_equal("hello, buffer")
            reader.close()?

        it "reads lines":
            val path = "/tmp/simple_io_spec_bufr_lines.txt"
            File.write(path, "line 1\nline 2\nline 3\n")?
            val raw = FileHandle.read_file(path)?
            val reader = BufferedReader.new(raw)
            val line1 = reader.read_line()?
            expect(line1).to_equal("line 1\n")
            reader.close()?

    context "wrapping different Read types":
        """
        ### Trait Composition

        BufferedReader works with any Read implementor.
        """

        it "documents wrapping FileHandle":
            # val fh = FileHandle.read_file("data.csv")?
            # val reader = BufferedReader.new(fh)
            # val line = reader.read_line()?
            pass

        it "documents wrapping TcpStream":
            # val stream = TcpStream.connect("127.0.0.1:8080")?
            # val reader = BufferedReader.new(stream)
            # val line = reader.read_line()?
            pass

# ============================================================================
# BufferedWriter
# ============================================================================

describe "BufferedWriter":
    """
    ## Buffered Write Wrapper

    Reduces write syscalls by batching writes in an in-memory buffer.
    Flushes when buffer is full or on explicit flush/close.
    """

    context "construction":
        """
        ### Creating BufferedWriter
        """

        it "creates with default capacity":
            val path = "/tmp/simple_io_spec_bufw.txt"
            val raw = FileHandle.create(path)?
            val writer = BufferedWriter.new(raw)
            expect(writer.buf_size).to_equal(8192)
            writer.close()?

    context "writing through buffer":
        """
        ### Buffered Writing

        Writes accumulate in buffer, flushed on flush() or when full.
        """

        it "writes text and flushes":
            val path = "/tmp/simple_io_spec_bufw2.txt"
            val raw = FileHandle.create(path)?
            val writer = BufferedWriter.new(raw)
            writer.write_text("buffered ")?
            writer.write_text("output")?
            writer.flush()?
            writer.close()?

            val content = File.read(path)?
            expect(content).to_equal("buffered output")

    context "flush on close":
        """
        ### Auto-Flush on Close

        close() automatically flushes pending buffer contents.
        """

        it "flushes buffer before closing inner":
            val path = "/tmp/simple_io_spec_bufw3.txt"
            val raw = FileHandle.create(path)?
            val writer = BufferedWriter.new(raw)
            writer.write_text("auto-flush")?
            # No explicit flush — close() should flush
            writer.close()?

            val content = File.read(path)?
            expect(content).to_equal("auto-flush")
