"""
# Event Loop Specification

**Feature IDs:** #IO-ASYNC-EVENTLOOP
**Category:** Stdlib
**Difficulty:** 4/5
**Status:** Implemented

## Overview

EventLoop abstracts epoll (Linux) / kqueue (BSD/macOS) for async I/O.
It manages fd registration, interest tracking, and event polling.
Waker callbacks wake pending futures when I/O is ready.

## Syntax

```simple
val loop = EventLoop.new()?
val waker = Waker.new(1, \\id: scheduler.wake(id))
loop.register(fd, Interest.Read, waker)?
val events = loop.poll(100)?
for event in events:
    dispatch(event.fd, event.ready)
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| EventLoop | epoll/kqueue wrapper â€” register, poll, deregister |
| Waker | Callback that wakes a pending future |
| Interest | Read, Write, or ReadWrite monitoring |
| IoEvent | (fd, ready) pair returned from poll |

## Behavior

- EventLoop.new() calls epoll_create / kqueue
- register(fd, interest, waker) adds fd to monitoring
- poll(timeout_ms) returns ready events
- deregister(fd) removes fd from monitoring
- run() loops until no fds registered
"""

use std.spec

# ============================================================================
# Waker
# ============================================================================

describe "Waker":
    """
    ## Future Wake Callback

    Waker stores an ID and a callback function.
    When wake() is called, it invokes the callback with the ID.
    """

    context "construction":
        it "creates waker with id and callback":
            var woken = false
            val waker = Waker.new(42, \id: woken = true)
            expect(waker.id).to_equal(42)

    context "wake":
        """
        ### Invoking the Wake Callback
        """

        it "invokes callback on wake":
            var woken_id = -1
            val waker = Waker.new(7, \id: woken_id = id)
            waker.wake()
            expect(woken_id).to_equal(7)

        it "can be woken multiple times":
            var count = 0
            val waker = Waker.new(1, \id: count = count + 1)
            waker.wake()
            waker.wake()
            waker.wake()
            expect(count).to_equal(3)

# ============================================================================
# EventLoop
# ============================================================================

describe "EventLoop":
    """
    ## epoll/kqueue Abstraction

    Manages file descriptor registration and polling for readiness events.
    """

    context "creation":
        """
        ### Creating an Event Loop
        """

        it "creates event loop successfully":
            val result = EventLoop.new()
            match result:
                case Ok(loop):
                    expect(loop.epoll_fd).to_be_greater_than(-1)
                case Err(e):
                    # May fail in sandboxed environment
                    pass

    context "register and deregister":
        """
        ### Managing fd Registration
        """

        it "documents register usage":
            # val loop = EventLoop.new()?
            # val waker = Waker.new(1, \\id: pass)
            # loop.register(socket_fd, Interest.Read, waker)?
            # loop.deregister(socket_fd)?
            pass

        it "documents modify usage":
            # val loop = EventLoop.new()?
            # val waker = Waker.new(1, \\id: pass)
            # loop.register(fd, Interest.Read, waker)?
            # loop.modify(fd, Interest.ReadWrite)?
            pass

    context "poll":
        """
        ### Polling for Events
        """

        it "documents poll usage":
            # val loop = EventLoop.new()?
            # val events = loop.poll(100)?  # 100ms timeout
            # for event in events:
            #     match event.ready:
            #         case Interest.Read: handle_read(event.fd)
            #         case Interest.Write: handle_write(event.fd)
            #         case Interest.ReadWrite: handle_both(event.fd)
            pass

        it "documents poll_one for single event":
            # val loop = EventLoop.new()?
            # val event = loop.poll_one(100)?
            # if event.?:
            #     handle(event.unwrap())
            pass

    context "run loop":
        """
        ### Running the Event Loop

        run() dispatches wakers until no fds remain registered.
        """

        it "documents run usage":
            # val loop = EventLoop.new()?
            # loop.register(fd1, Interest.Read, waker1)?
            # loop.register(fd2, Interest.Write, waker2)?
            # loop.run()?  # runs until all fds deregistered
            pass

# ============================================================================
# Interest and IoEvent
# ============================================================================

describe "Interest and IoEvent":
    """
    ## Event Types

    Interest specifies what to monitor; IoEvent reports what's ready.
    """

    context "Interest variants":
        it "has Read interest":
            val i = Interest.Read
            match i:
                case Interest.Read: expect(true).to_equal(true)
                case _: expect(false).to_equal(true)

        it "has Write interest":
            val i = Interest.Write
            match i:
                case Interest.Write: expect(true).to_equal(true)
                case _: expect(false).to_equal(true)

        it "has ReadWrite interest":
            val i = Interest.ReadWrite
            match i:
                case Interest.ReadWrite: expect(true).to_equal(true)
                case _: expect(false).to_equal(true)

    context "IoEvent construction":
        it "creates event with fd and interest":
            val event = IoEvent(fd: 5, ready: Interest.Read)
            expect(event.fd).to_equal(5)
