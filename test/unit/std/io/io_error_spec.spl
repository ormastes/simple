"""
# I/O Error Types Specification

**Feature IDs:** #IO-ERROR
**Category:** Stdlib
**Difficulty:** 2/5
**Status:** Implemented

## Overview

IoErrorKind, IoError, and SeekFrom provide the shared error vocabulary
for all sync and async I/O operations. IoError carries a kind, message,
and optional source chain for rich diagnostics.

## Syntax

```simple
val err = IoError.new(IoErrorKind.NotFound, "file not found")
if err.is_not_found():
    print "handle missing file"
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| IoErrorKind | 17-variant enum categorizing I/O failures |
| IoError | Class with kind, message, and optional source chain |
| SeekFrom | Enum for specifying seek position (Start, Current, End) |

## Behavior

- IoError.new() creates an error with nil source
- IoError.from() creates an error with a source cause for chaining
- Predicate methods (is_not_found, is_would_block, etc.) check kind
- to_string() formats as "{kind}: {message}"
"""

use std.spec

# ============================================================================
# IoErrorKind
# ============================================================================

describe "IoErrorKind":
    """
    ## Error Kind Variants and String Conversion

    IoErrorKind covers 17 categories of I/O failures.
    Each variant converts to a human-readable string.
    """

    context "string conversion":
        """
        ### All Variants

        Each IoErrorKind variant has a canonical string representation.
        """

        it "converts NotFound to string":
            val kind = IoErrorKind.NotFound
            expect(kind.to_string()).to_equal("not found")

        it "converts PermissionDenied to string":
            expect(IoErrorKind.PermissionDenied.to_string()).to_equal("permission denied")

        it "converts ConnectionRefused to string":
            expect(IoErrorKind.ConnectionRefused.to_string()).to_equal("connection refused")

        it "converts ConnectionReset to string":
            expect(IoErrorKind.ConnectionReset.to_string()).to_equal("connection reset")

        it "converts ConnectionAborted to string":
            expect(IoErrorKind.ConnectionAborted.to_string()).to_equal("connection aborted")

        it "converts AddrInUse to string":
            expect(IoErrorKind.AddrInUse.to_string()).to_equal("address in use")

        it "converts AddrNotAvailable to string":
            expect(IoErrorKind.AddrNotAvailable.to_string()).to_equal("address not available")

        it "converts BrokenPipe to string":
            expect(IoErrorKind.BrokenPipe.to_string()).to_equal("broken pipe")

        it "converts AlreadyExists to string":
            expect(IoErrorKind.AlreadyExists.to_string()).to_equal("already exists")

        it "converts WouldBlock to string":
            expect(IoErrorKind.WouldBlock.to_string()).to_equal("would block")

        it "converts TimedOut to string":
            expect(IoErrorKind.TimedOut.to_string()).to_equal("timed out")

        it "converts Interrupted to string":
            expect(IoErrorKind.Interrupted.to_string()).to_equal("interrupted")

        it "converts InvalidInput to string":
            expect(IoErrorKind.InvalidInput.to_string()).to_equal("invalid input")

        it "converts InvalidData to string":
            expect(IoErrorKind.InvalidData.to_string()).to_equal("invalid data")

        it "converts UnexpectedEof to string":
            expect(IoErrorKind.UnexpectedEof.to_string()).to_equal("unexpected end of file")

        it "converts Unsupported to string":
            expect(IoErrorKind.Unsupported.to_string()).to_equal("unsupported")

        it "converts Other to string":
            expect(IoErrorKind.Other.to_string()).to_equal("other error")

# ============================================================================
# IoError
# ============================================================================

describe "IoError":
    """
    ## Error Creation and Inspection

    IoError is the primary error type for all I/O operations.
    It carries a kind, message, and optional source chain.
    """

    context "creation with IoError.new":
        """
        ### Basic Error Creation

        IoError.new creates an error with nil source.
        """

        it "creates error with kind and message":
            val err = IoError.new(IoErrorKind.NotFound, "config.sdn not found")
            expect(err.kind).to_equal(IoErrorKind.NotFound)
            expect(err.message).to_equal("config.sdn not found")

        it "creates error with nil source":
            val err = IoError.new(IoErrorKind.Other, "unknown")
            expect(err.source).to_be_nil

    context "creation with IoError.from (source chain)":
        """
        ### Error Chaining

        IoError.from wraps an underlying cause for diagnostics.
        """

        it "creates error with source":
            val inner = IoError.new(IoErrorKind.ConnectionReset, "peer reset")
            val outer = IoError.from(IoErrorKind.Other, "request failed", inner)
            expect(outer.kind).to_equal(IoErrorKind.Other)
            expect(outer.message).to_equal("request failed")

        it "preserves source error":
            val inner = IoError.new(IoErrorKind.TimedOut, "connect timeout")
            val outer = IoError.from(IoErrorKind.Other, "operation failed", inner)
            val source = outer.source
            expect(source.?).to_equal(true)

    context "predicate methods":
        """
        ### Kind Predicate Checks

        Convenience methods for checking common error kinds.
        """

        it "is_not_found returns true for NotFound":
            val err = IoError.new(IoErrorKind.NotFound, "missing")
            expect(err.is_not_found()).to_equal(true)
            expect(err.is_timed_out()).to_equal(false)

        it "is_would_block returns true for WouldBlock":
            val err = IoError.new(IoErrorKind.WouldBlock, "try again")
            expect(err.is_would_block()).to_equal(true)

        it "is_timed_out returns true for TimedOut":
            val err = IoError.new(IoErrorKind.TimedOut, "deadline")
            expect(err.is_timed_out()).to_equal(true)

        it "is_interrupted returns true for Interrupted":
            val err = IoError.new(IoErrorKind.Interrupted, "signal")
            expect(err.is_interrupted()).to_equal(true)

    context "to_string formatting":
        """
        ### String Formatting

        to_string() formats as "{kind}: {message}".
        """

        it "formats NotFound error":
            val err = IoError.new(IoErrorKind.NotFound, "config.sdn")
            expect(err.to_string()).to_equal("not found: config.sdn")

        it "formats TimedOut error":
            val err = IoError.new(IoErrorKind.TimedOut, "connect timeout")
            expect(err.to_string()).to_equal("timed out: connect timeout")

        it "formats BrokenPipe error":
            val err = IoError.new(IoErrorKind.BrokenPipe, "write failed")
            expect(err.to_string()).to_equal("broken pipe: write failed")

# ============================================================================
# SeekFrom
# ============================================================================

describe "SeekFrom":
    """
    ## Seek Position Specification

    SeekFrom specifies where to seek in a stream:
    - Start(offset): Absolute position from beginning
    - Current(offset): Relative to current position
    - End(offset): Relative to end of stream
    """

    context "variant construction":
        it "creates Start variant":
            val pos = SeekFrom.Start(0)
            match pos:
                case SeekFrom.Start(o): expect(o).to_equal(0)
                case _: pass

        it "creates Current variant with negative offset":
            val pos = SeekFrom.Current(-10)
            match pos:
                case SeekFrom.Current(o): expect(o).to_equal(-10)
                case _: pass

        it "creates End variant":
            val pos = SeekFrom.End(0)
            match pos:
                case SeekFrom.End(o): expect(o).to_equal(0)
                case _: pass
