"""
# Sync TCP I/O Specification

**Feature IDs:** #IO-SYNC-TCP
**Category:** Stdlib
**Difficulty:** 3/5
**Status:** Implemented

## Overview

TcpListener and TcpStream implement the I/O traits for reliable,
connection-oriented network communication. TcpListener produces
TcpStream handles via accept().

## Syntax

```simple
val listener = TcpListener.bind("127.0.0.1:0")?
val stream = listener.accept()?
val data = stream.read_text()?
stream.write_text("response")?
stream.close()?
listener.close()?
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| TcpListener | Server socket — bind, accept, close |
| TcpStream | Bidirectional connection — Read+Write+Close |
| Shutdown | Direction enum: Read, Write, Both |

## Behavior

- TcpListener.bind("host:port") creates listening socket
- accept() blocks until client connects, returns TcpStream
- TcpStream.connect("host:port") initiates outbound connection
- read/write on TcpStream follow Read/Write trait contracts
- Shutdown allows half-close of connection
"""

use std.spec

# ============================================================================
# Shutdown
# ============================================================================

describe "Shutdown":
    """
    ## Shutdown Direction

    Controls which half of the TCP connection to close.
    """

    context "enum variants":
        it "has Read variant":
            val s = Shutdown.Read
            match s:
                case Shutdown.Read: expect(true).to_equal(true)
                case _: expect(false).to_equal(true)

        it "has Write variant":
            val s = Shutdown.Write
            match s:
                case Shutdown.Write: expect(true).to_equal(true)
                case _: expect(false).to_equal(true)

        it "has Both variant":
            val s = Shutdown.Both
            match s:
                case Shutdown.Both: expect(true).to_equal(true)
                case _: expect(false).to_equal(true)

# ============================================================================
# TcpListener
# ============================================================================

describe "TcpListener":
    """
    ## TCP Server Socket

    Binds to a local address and accepts incoming connections.
    """

    context "bind":
        """
        ### Binding to an Address

        TcpListener.bind() creates a listening socket.
        Using port 0 selects an available ephemeral port.
        """

        it "binds to ephemeral port":
            val result = TcpListener.bind("127.0.0.1:0")
            match result:
                case Ok(listener):
                    expect(listener.is_open()).to_equal(true)
                    listener.close()?
                case Err(e):
                    # May fail in sandboxed environment
                    pass

    context "local_addr":
        """
        ### Retrieving Bound Address
        """

        it "returns bound address":
            val listener = TcpListener.bind("127.0.0.1:0")?
            val addr = listener.local_addr()?
            expect(addr).to_contain("127.0.0.1")
            listener.close()?

    context "close":
        """
        ### Closing the Listener
        """

        it "transitions to closed":
            val listener = TcpListener.bind("127.0.0.1:0")?
            expect(listener.is_open()).to_equal(true)
            listener.close()?
            expect(listener.is_open()).to_equal(false)

        it "close is idempotent":
            val listener = TcpListener.bind("127.0.0.1:0")?
            listener.close()?
            val result = listener.close()
            match result:
                case Ok(_): expect(true).to_equal(true)
                case Err(_): pass

# ============================================================================
# TcpStream
# ============================================================================

describe "TcpStream":
    """
    ## TCP Connection Stream

    Bidirectional TCP connection implementing Read, Write, Close.
    """

    context "connect error handling":
        """
        ### Connection Failures

        Connecting to a non-listening port returns ConnectionRefused.
        """

        it "returns error connecting to closed port":
            val result = TcpStream.connect_timeout("127.0.0.1:1", 100)
            match result:
                case Ok(_): pass
                case Err(e):
                    # Expect either TimedOut or ConnectionRefused
                    expect(e.kind == IoErrorKind.TimedOut or e.kind == IoErrorKind.ConnectionRefused).to_equal(true)

    context "read/write on closed stream":
        """
        ### Closed Stream Errors
        """

        it "read returns error after close":
            # Create mock closed stream
            var stream = TcpStream(fd: -1, open: false)
            val result = stream.read(1024)
            match result:
                case Ok(_): pass
                case Err(e):
                    expect(e.message).to_contain("closed")

        it "write returns error after close":
            var stream = TcpStream(fd: -1, open: false)
            val result = stream.write_text("test")
            match result:
                case Ok(_): pass
                case Err(e):
                    expect(e.message).to_contain("closed")

    context "TCP options":
        """
        ### Socket Configuration

        TcpStream supports TCP_NODELAY, read/write timeouts, and shutdown.
        """

        it "documents nodelay usage":
            # stream.set_nodelay(true)?  # disable Nagle
            pass

        it "documents timeout usage":
            # stream.set_read_timeout(Some(5000))?   # 5s timeout
            # stream.set_write_timeout(Some(5000))?  # 5s timeout
            # stream.set_read_timeout(nil)?           # no timeout (blocking)
            pass

        it "documents shutdown usage":
            # stream.shutdown(Shutdown.Write)?  # done sending
            # stream.shutdown(Shutdown.Both)?   # full close
            pass
