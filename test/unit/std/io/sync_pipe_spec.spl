"""
# Sync Pipe I/O Specification

**Feature IDs:** #IO-SYNC-PIPE
**Category:** Stdlib
**Difficulty:** 2/5
**Status:** Implemented

## Overview

Stdin, Stdout, Stderr wrap standard I/O file descriptors as Read/Write
trait implementors, enabling use with BufferedReader/Writer and other
generic I/O code.

## Syntax

```simple
val out = Stdout.new()
out.write_text("Hello, world!\\n")?
out.flush()?

val err = Stderr.new()
err.write_text("error: something failed\\n")?
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| Stdin | Read trait — standard input |
| Stdout | Write trait — standard output |
| Stderr | Write trait — standard error |

## Behavior

- Stdin.read_line() blocks until newline or EOF
- Stdout/Stderr write_text() outputs immediately (no buffering by default)
- flush() ensures output is visible
- Can be wrapped in BufferedReader/BufferedWriter
"""

use std.spec

# ============================================================================
# Stdout
# ============================================================================

describe "Stdout":
    """
    ## Standard Output

    Write trait implementor for stdout.
    """

    context "construction":
        it "creates stdout writer":
            val out = Stdout.new()
            # Stdout is always constructed successfully
            expect(true).to_equal(true)

    context "writing":
        """
        ### Writing to Stdout
        """

        it "writes text":
            val out = Stdout.new()
            val result = out.write_text("")
            match result:
                case Ok(_): expect(true).to_equal(true)
                case Err(_): pass

        it "flushes":
            val out = Stdout.new()
            val result = out.flush()
            match result:
                case Ok(_): expect(true).to_equal(true)
                case Err(_): pass

# ============================================================================
# Stderr
# ============================================================================

describe "Stderr":
    """
    ## Standard Error

    Write trait implementor for stderr.
    """

    context "construction":
        it "creates stderr writer":
            val err = Stderr.new()
            expect(true).to_equal(true)

    context "writing":
        it "writes text":
            val err = Stderr.new()
            val result = err.write_text("")
            match result:
                case Ok(_): expect(true).to_equal(true)
                case Err(_): pass

# ============================================================================
# Stdin
# ============================================================================

describe "Stdin":
    """
    ## Standard Input

    Read trait implementor for stdin. read_line() blocks until input.
    """

    context "construction":
        it "creates stdin reader":
            val input = Stdin.new()
            expect(true).to_equal(true)

    context "documented usage":
        """
        ### Reading from Stdin

        read_line() blocks, so these are documented rather than executed.
        """

        it "documents interactive line reading":
            # val input = Stdin.new()
            # val line = input.read_line()?
            # print "You typed: {line}"
            pass

        it "documents reading all stdin":
            # val input = Stdin.new()
            # val all = input.read_text()?
            pass

# ============================================================================
# Composition with Buffered I/O
# ============================================================================

describe "Pipe + Buffered I/O Composition":
    """
    ## Composing Pipes with Buffers

    Stdin/Stdout/Stderr implement Read/Write, so they can be
    wrapped in BufferedReader/BufferedWriter.
    """

    context "buffered stdout":
        it "documents buffered stdout usage":
            # val writer = BufferedWriter.new(Stdout.new())
            # writer.write_text("buffered line 1\\n")?
            # writer.write_text("buffered line 2\\n")?
            # writer.flush()?
            pass

    context "buffered stdin":
        it "documents buffered stdin usage":
            # val reader = BufferedReader.new(Stdin.new())
            # val line = reader.read_line()?
            pass
