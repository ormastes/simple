"""
# Sync File I/O Specification

**Feature IDs:** #IO-SYNC-FILE
**Category:** Stdlib
**Difficulty:** 3/5
**Status:** Implemented

## Overview

FileHandle implements Read, Write, Seek, Close traits for fd-based file I/O.
File provides static one-shot convenience methods.

## Syntax

```simple
# Handle-based
val fh = FileHandle.open("data.txt", FileMode.ReadOnly)?
val content = fh.read_text()?
fh.close()?

# Static convenience
val text = File.read("data.txt")?
File.write("out.txt", text)?
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| FileHandle | fd-based handle with Read+Write+Seek+Close |
| File | Static convenience (delegates to FileHandle internally) |
| FileMode | ReadOnly, WriteOnly, ReadWrite, Append |
| FileMetadata | size, is_file, is_dir, readonly, timestamps |

## Behavior

- FileHandle.open() returns fd; errors produce IoError
- read_text() reads all remaining bytes and converts to text
- write_text() converts text to bytes and writes all
- seek()/rewind() for random access
- close() transitions to closed state; further ops return error
- File.read/write/append/copy/exists/delete wrap handle lifecycle
"""

use std.spec

# ============================================================================
# FileMode
# ============================================================================

describe "FileMode":
    """
    ## File Open Modes

    Four modes control how a file is opened.
    """

    context "enum variants":
        it "has ReadOnly mode":
            val mode = FileMode.ReadOnly
            match mode:
                case FileMode.ReadOnly: expect(true).to_equal(true)
                case _: expect(false).to_equal(true)

        it "has WriteOnly mode":
            val mode = FileMode.WriteOnly
            match mode:
                case FileMode.WriteOnly: expect(true).to_equal(true)
                case _: expect(false).to_equal(true)

        it "has ReadWrite mode":
            val mode = FileMode.ReadWrite
            match mode:
                case FileMode.ReadWrite: expect(true).to_equal(true)
                case _: expect(false).to_equal(true)

        it "has Append mode":
            val mode = FileMode.Append
            match mode:
                case FileMode.Append: expect(true).to_equal(true)
                case _: expect(false).to_equal(true)

# ============================================================================
# File (Static Convenience)
# ============================================================================

describe "File Static Convenience":
    """
    ## One-Shot File Operations

    File provides static methods that handle the full open-read/write-close
    lifecycle in a single call.
    """

    context "write and read":
        """
        ### Write Then Read

        File.write creates/truncates, File.read reads entire content.
        """

        it "writes and reads text":
            val path = "/tmp/simple_io_spec_rw.txt"
            val result = File.write(path, "hello, io spec")
            match result:
                case Ok(_):
                    val content = File.read(path)
                    match content:
                        case Ok(text):
                            expect(text).to_equal("hello, io spec")
                        case Err(_): pass
                case Err(_): pass

        it "writes and reads bytes":
            val path = "/tmp/simple_io_spec_bytes.txt"
            val data: [u8] = [72, 101, 108, 108, 111]
            File.write_bytes(path, data)?
            val result = File.read_bytes(path)?
            expect(result.len()).to_equal(5)
            expect(result[0]).to_equal(72)

    context "append":
        """
        ### Appending to Files

        File.append adds content without truncating.
        """

        it "appends to existing file":
            val path = "/tmp/simple_io_spec_append.txt"
            File.write(path, "line 1\n")?
            File.append(path, "line 2\n")?
            val content = File.read(path)?
            expect(content).to_contain("line 1")
            expect(content).to_contain("line 2")

    context "exists and delete":
        """
        ### File Existence and Deletion
        """

        it "checks file existence":
            val path = "/tmp/simple_io_spec_exists.txt"
            File.write(path, "exists")?
            expect(File.exists(path)).to_equal(true)
            File.delete(path)?
            expect(File.exists(path)).to_equal(false)

        it "returns error deleting nonexistent file":
            val result = File.delete("/tmp/nonexistent_io_spec_file_99999.txt")
            match result:
                case Ok(_): pass
                case Err(e):
                    expect(e.is_not_found()).to_equal(true)

    context "copy":
        """
        ### File Copy

        File.copy reads source bytes and writes to destination.
        """

        it "copies file content":
            val src = "/tmp/simple_io_spec_copy_src.txt"
            val dst = "/tmp/simple_io_spec_copy_dst.txt"
            File.write(src, "copy me")?
            File.copy(src, dst)?
            val content = File.read(dst)?
            expect(content).to_equal("copy me")

# ============================================================================
# FileHandle
# ============================================================================

describe "FileHandle":
    """
    ## Handle-Based File I/O

    FileHandle wraps a file descriptor and implements Read, Write, Seek, Close.
    Provides fine-grained control over file operations.
    """

    context "open and close":
        """
        ### Lifecycle Management
        """

        it "opens file for writing and closes":
            val path = "/tmp/simple_io_spec_fh_open.txt"
            val fh = FileHandle.open(path, FileMode.WriteOnly)?
            expect(fh.is_open()).to_equal(true)
            fh.close()?
            expect(fh.is_open()).to_equal(false)

        it "returns error opening nonexistent file for reading":
            val result = FileHandle.open("/tmp/nonexistent_99999.txt", FileMode.ReadOnly)
            match result:
                case Ok(_): pass
                case Err(e):
                    expect(e.is_not_found()).to_equal(true)

    context "read and write":
        """
        ### Reading and Writing Through Handle
        """

        it "writes text and reads it back":
            val path = "/tmp/simple_io_spec_fh_rw.txt"
            val wh = FileHandle.create(path)?
            wh.write_text("handle content")?
            wh.close()?

            val rh = FileHandle.read_file(path)?
            val content = rh.read_text()?
            expect(content).to_equal("handle content")
            rh.close()?

    context "seek and rewind":
        """
        ### Random Access

        Seek moves the read/write cursor within the file.
        Rewind returns to byte 0.
        """

        it "rewinds to beginning after write":
            val path = "/tmp/simple_io_spec_fh_seek.txt"
            val fh = FileHandle.open(path, FileMode.ReadWrite)?
            fh.write_text("abcdef")?
            fh.rewind()?
            val content = fh.read_text()?
            expect(content).to_equal("abcdef")
            fh.close()?

        it "seeks to specific position":
            val path = "/tmp/simple_io_spec_fh_seekpos.txt"
            val fh = FileHandle.open(path, FileMode.ReadWrite)?
            fh.write_text("hello world")?
            fh.seek(SeekFrom.Start(6))?
            val rest = fh.read_text()?
            expect(rest).to_equal("world")
            fh.close()?

    context "shortcut factories":
        """
        ### Convenience Constructors

        read_file, create, append are shortcuts for common modes.
        """

        it "read_file opens for reading":
            val path = "/tmp/simple_io_spec_fh_readfile.txt"
            File.write(path, "test data")?
            val fh = FileHandle.read_file(path)?
            expect(fh.is_open()).to_equal(true)
            val content = fh.read_text()?
            expect(content).to_equal("test data")
            fh.close()?

        it "create opens for writing (truncates)":
            val path = "/tmp/simple_io_spec_fh_create.txt"
            File.write(path, "old content")?
            val fh = FileHandle.create(path)?
            fh.write_text("new content")?
            fh.close()?
            val content = File.read(path)?
            expect(content).to_equal("new content")

    context "error on closed handle":
        """
        ### Closed Handle Errors

        Operations on a closed handle return IoError.
        """

        it "read returns error after close":
            val path = "/tmp/simple_io_spec_fh_closed.txt"
            File.write(path, "data")?
            val fh = FileHandle.read_file(path)?
            fh.close()?
            val result = fh.read(10)
            match result:
                case Ok(_): pass
                case Err(e):
                    expect(e.message).to_contain("closed")

        it "write returns error after close":
            val path = "/tmp/simple_io_spec_fh_closed2.txt"
            val fh = FileHandle.create(path)?
            fh.close()?
            val result = fh.write_text("should fail")
            match result:
                case Ok(_): pass
                case Err(e):
                    expect(e.message).to_contain("closed")
