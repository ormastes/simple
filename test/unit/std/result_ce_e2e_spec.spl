# ResultCE end-to-end spec
#
# Tests CE desugaring in eval.spl via `ce result_ce:` block syntax.
# Verifies that STMT_BIND short-circuits on nil and binds vars on success.

use std.result_ce.{result_ce_bind, result_ce_return, result_ce_zero}

describe "ce result_ce block desugaring":
    describe "successful binds":
        it "evaluates final expression when all binds succeed":
            val result = ce result_ce:
                bind x = "hello"
                bind y = "world"
                "{x} {y}"
            expect(result).to_equal("hello world")

        it "single bind returns bound value in final expr":
            val result = ce result_ce:
                bind n = 42
                n + 1
            expect(result).to_equal(43)

        it "binds integer and uses in arithmetic":
            val result = ce result_ce:
                bind a = 10
                bind b = 20
                a + b
            expect(result).to_equal(30)

        it "returns the final expression value":
            val result = ce result_ce:
                bind x = "data"
                x.len()
            expect(result).to_equal(4)

    describe "short-circuit on nil":
        it "returns nil when first bind is nil":
            val result = ce result_ce:
                bind x = nil
                bind y = "never reached"
                y
            expect(result).to_be_nil()

        it "returns nil when second bind is nil":
            val result = ce result_ce:
                bind x = "first"
                bind y = nil
                "{x}{y}"
            expect(result).to_be_nil()

        it "does not execute final expr when bind is nil":
            var executed = 0
            val result = ce result_ce:
                bind x = nil
                executed = 1
                x
            expect(result).to_be_nil()

    describe "mixed statements":
        it "evaluates non-bind statements normally":
            var side_effect = 0
            val result = ce result_ce:
                bind x = "value"
                side_effect = 1
                x
            expect(result).to_equal("value")
            expect(side_effect).to_equal(1)

        it "non-bind statement before bind runs normally":
            var counter = 0
            val result = ce result_ce:
                counter = counter + 1
                bind x = "ok"
                x
            expect(result).to_equal("ok")
            expect(counter).to_equal(1)
