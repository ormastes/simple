# Inline Helpers Module Extended Specification
#
# Tests for std.helpers inline utility functions.
# Since the helpers module has no exports (functions must be copied inline),
# we define and test each helper function directly.

use std.string.{NL}

# ============================================================================
# String Helpers (copied from std.helpers)
# ============================================================================

fn string_trim_inline(s: text) -> text:
    var result = s
    # Trim leading whitespace
    var trimming = true
    while trimming:
        if result.len() == 0:
            trimming = false
        else:
            val first = result[0:1]
            if first == " " or first == "\t" or first == NL or first == "\r":
                result = result[1:]
            else:
                trimming = false
    # Trim trailing whitespace
    var trimming2 = true
    while trimming2:
        if result.len() == 0:
            trimming2 = false
        else:
            val last = result[result.len()-1:result.len()]
            if last == " " or last == "\t" or last == NL or last == "\r":
                result = result[0:result.len()-1]
            else:
                trimming2 = false
    result

fn string_split_inline(s: text, delimiter: text) -> [text]:
    if delimiter.len() == 0:
        return [s]
    var parts = []
    var current = ""
    var i = 0
    var scanning = true
    while scanning:
        if i >= s.len():
            scanning = false
        else:
            var is_delim = true
            var j = 0
            var checking = true
            while checking:
                if j >= delimiter.len():
                    checking = false
                else:
                    val idx = i + j
                    if idx >= s.len():
                        is_delim = false
                        checking = false
                    else:
                        if s[idx:idx+1] != delimiter[j:j+1]:
                            is_delim = false
                            checking = false
                        else:
                            j = j + 1
            if is_delim and j == delimiter.len():
                parts.push(current)
                current = ""
                i = i + delimiter.len()
            else:
                current = current + s[i:i+1]
                i = i + 1
    parts.push(current)
    parts

fn to_int_or_inline(s: text, default_val: i64) -> i64:
    if s.len() == 0:
        return default_val
    val first = s[0:1]
    if first == "-" or first == "0" or first == "1" or first == "2" or first == "3" or first == "4" or first == "5" or first == "6" or first == "7" or first == "8" or first == "9":
        val result = int(s)
        result
    else:
        default_val

# ============================================================================
# Array Helpers (copied from std.helpers)
# ============================================================================

fn array_append_all_inline(arr1, arr2):
    var result = []
    for item in arr1:
        result.push(item)
    for item in arr2:
        result.push(item)
    result

fn array_flatten_inline(nested_arr):
    var result = []
    for sub_arr in nested_arr:
        for item in sub_arr:
            result.push(item)
    result

fn array_uniq_inline(arr):
    var seen = {}
    var result = []
    for item in arr:
        val key = "{item}"
        if not seen.contains_key(key):
            seen[key] = true
            result.push(item)
    result

fn array_compact_inline(arr):
    var result = []
    for item in arr:
        if item != nil:
            result.push(item)
    result

# ============================================================================
# String Helpers Tests
# ============================================================================

describe "string_trim_inline":

    it "trims leading spaces":
        val result = string_trim_inline("   hello")
        expect(result).to_equal("hello")

    it "trims trailing spaces":
        val result = string_trim_inline("hello   ")
        expect(result).to_equal("hello")

    it "trims both ends":
        val result = string_trim_inline("  hello  ")
        expect(result).to_equal("hello")

    it "trims tabs":
        val result = string_trim_inline("\thello\t")
        expect(result).to_equal("hello")

    it "returns empty for all whitespace":
        val result = string_trim_inline("   ")
        expect(result).to_equal("")

    it "returns empty for empty string":
        val result = string_trim_inline("")
        expect(result).to_equal("")

    it "returns same for no whitespace":
        val result = string_trim_inline("hello")
        expect(result).to_equal("hello")

    it "preserves internal whitespace":
        val result = string_trim_inline("  hello world  ")
        expect(result).to_equal("hello world")

describe "string_split_inline":

    it "splits by comma":
        val parts = string_split_inline("a,b,c", ",")
        expect(parts.len()).to_equal(3)
        expect(parts[0]).to_equal("a")
        expect(parts[1]).to_equal("b")
        expect(parts[2]).to_equal("c")

    it "splits by space":
        val parts = string_split_inline("hello world test", " ")
        expect(parts.len()).to_equal(3)
        expect(parts[0]).to_equal("hello")
        expect(parts[1]).to_equal("world")
        expect(parts[2]).to_equal("test")

    it "returns single element for no delimiter found":
        val parts = string_split_inline("hello", ",")
        expect(parts.len()).to_equal(1)
        expect(parts[0]).to_equal("hello")

    it "handles empty delimiter by returning whole string":
        val parts = string_split_inline("hello", "")
        expect(parts.len()).to_equal(1)
        expect(parts[0]).to_equal("hello")

    it "handles empty string":
        val parts = string_split_inline("", ",")
        expect(parts.len()).to_equal(1)
        expect(parts[0]).to_equal("")

    it "handles delimiter at start":
        val parts = string_split_inline(",hello", ",")
        expect(parts.len()).to_equal(2)
        expect(parts[0]).to_equal("")
        expect(parts[1]).to_equal("hello")

    it "handles delimiter at end":
        val parts = string_split_inline("hello,", ",")
        expect(parts.len()).to_equal(2)
        expect(parts[0]).to_equal("hello")
        expect(parts[1]).to_equal("")

    it "handles multi-char delimiter":
        val parts = string_split_inline("a::b::c", "::")
        expect(parts.len()).to_equal(3)
        expect(parts[0]).to_equal("a")
        expect(parts[1]).to_equal("b")
        expect(parts[2]).to_equal("c")

describe "to_int_or_inline":

    it "parses a valid integer":
        val result = to_int_or_inline("42", 0)
        expect(result).to_equal(42)

    it "parses negative integer":
        val result = to_int_or_inline("-10", 0)
        expect(result).to_equal(-10)

    it "parses zero":
        val result = to_int_or_inline("0", -1)
        expect(result).to_equal(0)

    it "returns default for non-numeric":
        val result = to_int_or_inline("abc", 99)
        expect(result).to_equal(99)

    it "returns default for empty string":
        val result = to_int_or_inline("", 42)
        expect(result).to_equal(42)

# ============================================================================
# Array Helpers Tests
# ============================================================================

describe "array_append_all_inline":

    it "concatenates two arrays":
        val result = array_append_all_inline([1, 2], [3, 4])
        expect(result.len()).to_equal(4)
        expect(result[0]).to_equal(1)
        expect(result[1]).to_equal(2)
        expect(result[2]).to_equal(3)
        expect(result[3]).to_equal(4)

    it "handles empty first array":
        val result = array_append_all_inline([], [1, 2])
        expect(result.len()).to_equal(2)
        expect(result[0]).to_equal(1)

    it "handles empty second array":
        val result = array_append_all_inline([1, 2], [])
        expect(result.len()).to_equal(2)

    it "handles both empty":
        val result = array_append_all_inline([], [])
        expect(result.len()).to_equal(0)

describe "array_flatten_inline":

    it "flattens nested arrays":
        val result = array_flatten_inline([[1, 2], [3, 4], [5]])
        expect(result.len()).to_equal(5)
        expect(result[0]).to_equal(1)
        expect(result[4]).to_equal(5)

    it "handles empty nested arrays":
        val result = array_flatten_inline([[], [1], []])
        expect(result.len()).to_equal(1)
        expect(result[0]).to_equal(1)

    it "handles empty outer array":
        val result = array_flatten_inline([])
        expect(result.len()).to_equal(0)

describe "array_uniq_inline":

    it "removes duplicates":
        val result = array_uniq_inline([1, 2, 2, 3, 3, 3])
        expect(result.len()).to_equal(3)
        expect(result[0]).to_equal(1)
        expect(result[1]).to_equal(2)
        expect(result[2]).to_equal(3)

    it "preserves order":
        val result = array_uniq_inline([3, 1, 2, 1, 3])
        expect(result.len()).to_equal(3)
        expect(result[0]).to_equal(3)
        expect(result[1]).to_equal(1)
        expect(result[2]).to_equal(2)

    it "handles empty array":
        val result = array_uniq_inline([])
        expect(result.len()).to_equal(0)

    it "handles all unique":
        val result = array_uniq_inline([1, 2, 3])
        expect(result.len()).to_equal(3)

    it "handles all same":
        val result = array_uniq_inline([5, 5, 5, 5])
        expect(result.len()).to_equal(1)
        expect(result[0]).to_equal(5)

describe "array_compact_inline":

    it "removes nil values":
        val result = array_compact_inline([1, nil, 2, nil, 3])
        expect(result.len()).to_equal(3)
        expect(result[0]).to_equal(1)
        expect(result[1]).to_equal(2)
        expect(result[2]).to_equal(3)

    it "handles no nil values":
        val result = array_compact_inline([1, 2, 3])
        expect(result.len()).to_equal(3)

    it "handles all nil":
        val result = array_compact_inline([nil, nil, nil])
        expect(result.len()).to_equal(0)

    it "handles empty array":
        val result = array_compact_inline([])
        expect(result.len()).to_equal(0)

    it "handles single nil":
        val result = array_compact_inline([nil])
        expect(result.len()).to_equal(0)

    it "handles single value":
        val result = array_compact_inline([42])
        expect(result.len()).to_equal(1)
        expect(result[0]).to_equal(42)
