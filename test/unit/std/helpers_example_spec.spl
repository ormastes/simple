# Inline Helpers Example - Phase 2 Workaround Demo
#
# This spec demonstrates how to use inline implementations
# to work around the runtime import limitation.

use std.text.{NL}

# ============================================================================
# Copy inline helpers from src/std/helpers.spl
# ============================================================================

fn string_trim_inline(s: text) -> text:
    """Trim whitespace from both ends."""
    var result = s
    # Trim leading
    while result.len() > 0:
        val first = result[0:1]
        if first == " " or first == "\t" or first == NL or first == "\r":
            result = result[1:]
        else:
            break
    # Trim trailing
    while result.len() > 0:
        val last = result[result.len()-1:result.len()]
        if last == " " or last == "\t" or last == NL or last == "\r":
            result = result[0:result.len()-1]
        else:
            break
    result

fn string_split_inline(s: text, delimiter: text) -> [text]:
    """Split string by delimiter."""
    if delimiter.len() == 0:
        return [s]
    var parts = []
    var current = ""
    var i = 0
    while i < s.len():
        var is_delim = true
        var j = 0
        while j < delimiter.len() and i + j < s.len():
            if s[i+j:i+j+1] != delimiter[j:j+1]:
                is_delim = false
                break
            j = j + 1
        if is_delim and j == delimiter.len():
            parts.push(current)
            current = ""
            i = i + delimiter.len()
        else:
            current = current + s[i:i+1]
            i = i + 1
    parts.push(current)
    parts

fn array_append_all_inline(arr1, arr2):
    """Concatenate two arrays."""
    var result = []
    for item in arr1:
        result.push(item)
    for item in arr2:
        result.push(item)
    result

fn array_partition_inline(arr, predicate):
    """Partition array by predicate."""
    var matching = []
    var non_matching = []
    for item in arr:
        if predicate(item):
            matching.push(item)
        else:
            non_matching.push(item)
    (matching, non_matching)

fn array_flatten_inline(nested_arr):
    """Flatten one level of nesting."""
    var result = []
    for sub_arr in nested_arr:
        for item in sub_arr:
            result.push(item)
    result

# ============================================================================
# Tests using inline helpers
# ============================================================================

describe "Inline Helpers - Phase 2 Workaround":
    context "String operations":
        it "trims whitespace from both ends":
            val input = "  hello world  "
            val trimmed = string_trim_inline(input)
            expect(trimmed).to_equal("hello world")

        it "trims tabs and newlines":
            val input = "\t{NL}hello{NL}\t"
            val trimmed = string_trim_inline(input)
            expect(trimmed).to_equal("hello")

        it "handles empty string":
            val empty = string_trim_inline("")
            expect(empty).to_equal("")

        it "splits string by delimiter":
            val csv = "apple,banana,cherry"
            val parts = string_split_inline(csv, ",")
            expect(parts.len()).to_equal(3)
            expect(parts[0]).to_equal("apple")
            expect(parts[1]).to_equal("banana")
            expect(parts[2]).to_equal("cherry")

        it "splits with multi-character delimiter":
            val text = "foo::bar::baz"
            val parts = string_split_inline(text, "::")
            expect(parts.len()).to_equal(3)
            expect(parts[0]).to_equal("foo")

        it "handles no delimiters found":
            val text = "no-delimiters-here"
            val parts = string_split_inline(text, ",")
            expect(parts.len()).to_equal(1)
            expect(parts[0]).to_equal("no-delimiters-here")

    context "Array operations":
        it "appends two arrays":
            val arr1 = [1, 2, 3]
            val arr2 = [4, 5, 6]
            val combined = array_append_all_inline(arr1, arr2)
            expect(combined.len()).to_equal(6)
            expect(combined[0]).to_equal(1)
            expect(combined[5]).to_equal(6)

        it "partitions by predicate":
            val numbers = [1, 2, 3, 4, 5, 6]
            val is_even = fn(x): x % 2 == 0
            val result = array_partition_inline(numbers, is_even)
            val evens = result.0
            val odds = result.1
            expect(evens.len()).to_equal(3)
            expect(odds.len()).to_equal(3)
            expect(evens[0]).to_equal(2)
            expect(odds[0]).to_equal(1)

        it "flattens nested arrays":
            val nested = [[1, 2], [3, 4], [5, 6]]
            val flat_result = array_flatten_inline(nested)
            expect(flat_result.len()).to_equal(6)
            expect(flat_result[0]).to_equal(1)
            expect(flat_result[5]).to_equal(6)

        it "flattens arrays with different lengths":
            val nested = [[1], [2, 3, 4], [5, 6]]
            val flat_result = array_flatten_inline(nested)
            expect(flat_result.len()).to_equal(6)

    context "Real-world usage":
        it "processes CSV data":
            # Simulate reading CSV lines
            val csv_line = "Alice,30,Engineer"
            val fields = string_split_inline(csv_line, ",")

            expect(fields.len()).to_equal(3)
            expect(fields[0]).to_equal("Alice")
            expect(fields[1]).to_equal("30")
            expect(fields[2]).to_equal("Engineer")

        it "combines data from multiple sources":
            val source1 = [1, 2, 3]
            val source2 = [4, 5]
            val source3 = [6, 7, 8, 9]

            # Combine all sources
            var all_data = array_append_all_inline(source1, source2)
            all_data = array_append_all_inline(all_data, source3)

            expect(all_data.len()).to_equal(9)

        it "filters and processes text lines":
            # Simulate file lines with whitespace
            val lines = ["  line 1  ", "  line 2  ", "  line 3  "]
            var trimmed_lines = []
            for line in lines:
                trimmed_lines.push(string_trim_inline(line))

            expect(trimmed_lines[0]).to_equal("line 1")
            expect(trimmed_lines[1]).to_equal("line 2")
            expect(trimmed_lines[2]).to_equal("line 3")

# ============================================================================
# Migration Note
# ============================================================================

# When the import system is fixed, replace inline functions with:
#
# use std.text.{string_trim, string_split}
# use std.array.{array_append_all, array_partition, array_flatten}
#
# Then remove the inline function definitions above and the tests will
# continue to work without any changes.
