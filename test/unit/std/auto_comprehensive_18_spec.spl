# # Comprehensive Coverage Test
#
# **Feature IDs:** #AUTO
# **Category:** Testing
# **Status:** Implemented

fn check(condition: bool):
    expect(condition).to_equal(true)

fn dict_keys(d) -> [text]:
    d.keys()

describe "Comprehensive Test Suite":
    it "arithmetic coverage 1":
        check(1 + 1 == 2)
        check(5 - 3 == 2)
        check(4 * 3 == 12)
        check(10 / 2 == 5)
        
    it "arithmetic coverage 2":
        check(7 % 3 == 1)
        check(2 ** 3 == 8)
        check(-5 * 2 == -10)
        
    it "comparison coverage 1":
        check(5 > 3)
        check(2 < 10)
        check(5 >= 5)
        check(3 <= 3)
        
    it "comparison coverage 2":
        check(10 != 5)
        check(5 == 5)
        check(not (3 > 5))
        
    it "boolean logic 1":
        check(true and true)
        check(not (true and false))
        check(true or false)
        check(not (false and false))
        
    it "boolean logic 2":
        check(not false)
        check(not not true)
        
    it "string coverage 1":
        val s = "hello"
        check(s.len() == 5)
        check(s.contains("ell"))
        check(s.starts_with("hel"))
        check(s.ends_with("llo"))
        
    it "string coverage 2":
        val s = "test"
        check(s[0..2] == "te")
        check(s + "ing" == "testing")
        
    it "array coverage 1":
        var arr = [1, 2, 3, 4, 5]
        check(arr.len() == 5)
        check(arr[0] == 1)
        check(arr[4] == 5)
        check(arr[-1] == 5)
        
    it "array coverage 2":
        var arr = [10, 20, 30]
        check(arr[0..2].len() == 2)
        val appended = arr.append(40)
        check(appended.len() == 4)
        
    it "dict coverage 1":
        val d = {"a": 1, "b": 2}
        check(d["a"] == 1)
        check(d["b"] == 2)
        check(dict_keys(d).len() == 2)
        
    it "dict coverage 2":
        val d = {"key": "value"}
        check(d.get("key").? == true)
        check(d.get("missing").? == false)
        
    it "option coverage 1":
        val opt = Some(42)
        check(opt.?)
        check(opt? == 42)
        
    it "option coverage 2":
        val opt = nil
        check(not opt.?)
        
    it "range coverage 1":
        var count = 0
        for i in 0..10:
            count = count + 1
        check(count == 10)
        
    it "range coverage 2":
        var sum = 0
        for i in 1..6:
            sum = sum + i
        check(sum == 15)
        
    it "conditional coverage 1":
        val x = 10
        val result = if x > 5: "big" else: "small"
        check(result == "big")
        
    it "conditional coverage 2":
        val x = 2
        val result = if x > 5: "big" else: "small"
        check(result == "small")
        
    it "match coverage 1":
        val x = Some(100)
        val result = match x:
            Some(v): v * 2
            nil: 0
        check(result == 200)
        
    it "match coverage 2":
        val x = nil
        val result = match x:
            Some(v): v * 2
            nil: -1
        check(result == -1)
        
    it "loop coverage 1":
        var total = 0
        for i in [10, 20, 30]:
            total = total + i
        check(total == 60)
        
    it "loop coverage 2":
        fn run_while() -> i64:
            var i = 0
            while i < 5:
                i = i + 1
            i
        check(run_while() == 5)
        
    it "nested coverage 1":
        val a = true
        val b = true
        if a:
            if b:
                check(true)
            else:
                check(false)
        else:
            check(false)
            
    it "nested coverage 2":
        val x = 10
        val y = 20
        if x < y:
            if y > 15:
                check(true)
            else:
                check(false)
        else:
            check(false)
            
    it "complex expression 1":
        val result = (1 + 2) * (3 + 4)
        check(result == 21)
        
    it "complex expression 2":
        val a = 10
        val b = 5
        val result = a * 2 + b / 5
        check(result == 21)
        
    it "chained comparison":
        val x = 5
        check(0 < x and x < 10)
        
    it "ternary-like":
        val x = 7
        val result = if x % 2 == 0: "even" else: "odd"
        check(result == "odd")
        
    it "list comprehension simulation":
        var evens = []
        for i in 0..10:
            if i % 2 == 0:
                evens = evens.append(i)
        check(evens.len() == 5)
        
    it "error path":
        var error = nil
        check(error == nil)
