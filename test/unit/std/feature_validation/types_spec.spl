# # Types Feature Validation
#
# **Feature ID:** #27 Option and Result
# **Category:** Types
# **Status:** Complete
#
# ## Overview
#
# Validates Option and Result types including Some/nil, the .? operator,
# ?? null coalescing, and the Result pattern for error handling.

use std.spec

# ============================================================================
# Feature #27: Option Type
# ============================================================================

describe "Feature #27 - Option Type":
    # ## Option Type
    #
    # Optional values with Some/nil. Used for nullable values.
    # The .? operator checks presence, ?? provides defaults.

    context "Some values":
        it "creates Some with integer":
            val opt = Some(42)
            expect(opt).to_equal(Some(42))

        it "creates Some with string":
            val opt = Some("hello")
            expect(opt).to_equal(Some("hello"))

        it "creates Some with boolean":
            val opt = Some(true)
            expect(opt).to_equal(Some(true))

        it "creates Some with array":
            val opt = Some([1, 2, 3])
            expect(opt).to_equal(Some([1, 2, 3]))

    context "nil values":
        it "represents absence with nil":
            val opt = nil
            expect(opt).to_be_nil()

        it "nil equals nil":
            expect(nil).to_equal(nil)

    context "null coalescing (??)":
        it "returns value when present":
            val opt = Some(42)
            val result = opt ?? 0
            expect(result).to_equal(42)

        it "returns default when nil":
            val opt = nil
            val result = opt ?? 99
            expect(result).to_equal(99)

        it "returns default string when nil":
            val name = nil
            val display = name ?? "Anonymous"
            expect(display).to_equal("Anonymous")

        it "returns value string when present":
            val name = Some("Alice")
            val display = name ?? "Anonymous"
            expect(display).to_equal("Alice")

    context "unwrap operations":
        it "unwrap extracts Some value":
            val opt = Some(42)
            expect(opt.unwrap()).to_equal(42)

        it "unwrap_or returns value for Some":
            val opt = Some(10)
            expect(opt.unwrap_or(0)).to_equal(10)

        it "unwrap_or returns default for nil":
            val opt = nil
            expect(opt.unwrap_or(99)).to_equal(99)

    context "conditional checks":
        it "Some is not nil":
            val opt = Some(1)
            val check = opt != nil
            expect(check).to_equal(true)

        it "nil is nil":
            val opt = nil
            val check = opt == nil
            expect(check).to_equal(true)

    context "Option in collections":
        it "uses Option with array elements":
            val items = [1, 2, 3]
            val first = if items.len() > 0: Some(items[0]) else: nil
            expect(first).to_equal(Some(1))

        it "uses nil for empty collection":
            val items = []
            val first = if items.len() > 0: Some(items[0]) else: nil
            expect(first).to_be_nil()

# ============================================================================
# Feature #27: Result Pattern
# ============================================================================

describe "Feature #27 - Result Pattern":
    # ## Result Pattern
    #
    # Error handling with Ok/Err pattern. Used for fallible operations
    # without exceptions (Simple has NO try/catch/throw).

    context "Ok values":
        it "creates Ok with integer":
            val result = Ok(42)
            expect(result.is_ok()).to_equal(true)

        it "creates Ok with string":
            val result = Ok("success")
            expect(result.is_ok()).to_equal(true)

        it "extracts Ok value":
            val result = Ok(100)
            expect(result.unwrap()).to_equal(100)

    context "Err values":
        it "creates Err with string":
            val result = Err("something went wrong")
            expect(result.is_err()).to_equal(true)

        it "extracts Err value":
            val result = Err("failure")
            expect(result.unwrap_err()).to_equal("failure")

    context "Result checks":
        it "is_ok returns true for Ok":
            val result = Ok(1)
            expect(result.is_ok()).to_equal(true)

        it "is_ok returns false for Err":
            val result = Err("error")
            expect(result.is_ok()).to_equal(false)

        it "is_err returns true for Err":
            val result = Err("error")
            expect(result.is_err()).to_equal(true)

        it "is_err returns false for Ok":
            val result = Ok(1)
            expect(result.is_err()).to_equal(false)

    context "Result unwrap_or":
        it "returns value for Ok":
            val result = Ok(42)
            expect(result.unwrap_or(0)).to_equal(42)

        it "returns default for Err":
            val result = Err("error")
            expect(result.unwrap_or(0)).to_equal(0)

    context "Result conversion to Option":
        it "ok() converts Ok to Some":
            val result = Ok(42)
            val opt = result.ok()
            expect(opt).to_equal(Some(42))

        it "ok() converts Err to nil":
            val result = Err("error")
            val opt = result.ok()
            expect(opt).to_be_nil()

    context "error handling patterns":
        it "uses Result for fallible computation":
            fn safe_divide(a, b):
                if b == 0:
                    return Err("division by zero")
                Ok(a / b)

            val result1 = safe_divide(10, 2)
            expect(result1.unwrap()).to_equal(5)

            val result2 = safe_divide(10, 0)
            expect(result2.is_err()).to_equal(true)

        it "chains Result with unwrap_or":
            fn parse_number(s):
                if s == "42":
                    return Ok(42)
                Err("not a number")

            val value = parse_number("42").unwrap_or(-1)
            expect(value).to_equal(42)

            val fallback = parse_number("abc").unwrap_or(-1)
            expect(fallback).to_equal(-1)
