"""
# Codegen Feature Validation

**Feature IDs:** #100 Cranelift Backend, #95 Buffer Pool, #96 Generator Codegen
**Category:** Codegen
**Status:** Complete

## Overview

Validates code generation concepts including JIT/AOT compilation verification,
buffer pool recycling, and generator state machine basics. Tests focus on
language-level patterns that exercise these features.
"""

use std.spec
use std.text.{NL}

# ============================================================================
# Feature #100: Cranelift Backend (Basic Sanity)
# ============================================================================

describe "Feature #100 - Cranelift Backend":
    """
    ## Cranelift Backend

    Cranelift-based code generation for AOT and JIT compilation.
    Provides fast compilation with good runtime performance.

    These tests verify that basic operations compile and execute correctly,
    exercising the code generation pipeline.
    """

    context "integer operations":
        it "compiles integer arithmetic":
            val a = 10
            val b = 20
            val sum = a + b
            expect(sum).to_equal(30)

        it "compiles multiplication":
            val x = 7
            val y = 6
            expect(x * y).to_equal(42)

        it "compiles division":
            val dividend = 100
            val divisor = 4
            expect(dividend / divisor).to_equal(25)

        it "compiles modulo":
            expect(17 % 5).to_equal(2)

        it "compiles negative numbers":
            val neg = -42
            expect(neg + 42).to_equal(0)

    context "comparison operations":
        it "compiles equality comparison":
            expect(1 == 1).to_equal(true)
            expect(1 == 2).to_equal(false)

        it "compiles ordering comparisons":
            expect(1 < 2).to_equal(true)
            expect(2 > 1).to_equal(true)
            expect(5 <= 5).to_equal(true)
            expect(5 >= 5).to_equal(true)

    context "function calls":
        it "compiles simple function":
            fn add(a, b):
                a + b
            expect(add(3, 4)).to_equal(7)

        it "compiles recursive function":
            fn factorial(n):
                if n <= 1:
                    return 1
                n * factorial(n - 1)
            expect(factorial(5)).to_equal(120)

        it "compiles nested function calls":
            fn double(x):
                x * 2
            fn add_one(x):
                x + 1
            expect(add_one(double(5))).to_equal(11)

    context "control flow":
        it "compiles if/else expressions":
            val x = 10
            val result = if x > 5: "big" else: "small"
            expect(result).to_equal("big")

        it "compiles while loop":
            var sum = 0
            var i = 1
            while i <= 10:
                sum = sum + i
                i = i + 1
            expect(sum).to_equal(55)

        it "compiles for loop":
            var total = 0
            for n in [1, 2, 3, 4, 5]:
                total = total + n
            expect(total).to_equal(15)

    context "string operations":
        it "compiles string creation":
            val s = "hello"
            expect(s).to_equal("hello")

        it "compiles string interpolation":
            val n = 42
            val s = "value is {n}"
            expect(s).to_equal("value is 42")

        it "compiles string concatenation":
            val a = "foo"
            val b = "bar"
            expect(a + b).to_equal("foobar")

    context "collection operations":
        it "compiles array creation and access":
            val arr = [10, 20, 30]
            expect(arr[0]).to_equal(10)
            expect(arr[2]).to_equal(30)

        it "compiles array length":
            val arr = [1, 2, 3, 4, 5]
            expect(arr.len()).to_equal(5)

# ============================================================================
# Feature #95: Buffer Pool
# ============================================================================

describe "Feature #95 - Buffer Pool Concepts":
    """
    ## Buffer Pool

    Reusable buffer pools for code generation. Reduces allocation overhead
    when compiling many modules by recycling buffers.

    These tests validate the language-level patterns that buffer pools optimize:
    repeated allocation and reuse of collections.
    """

    context "collection reuse pattern":
        it "demonstrates array recycling pattern":
            # Buffer pool concept: reuse allocations
            var buffer = []
            # Fill buffer
            for i in [1, 2, 3, 4, 5]:
                buffer = buffer + [i]
            expect(buffer.len()).to_equal(5)

            # Reset and reuse (simulates pool recycling)
            buffer = []
            for i in [10, 20, 30]:
                buffer = buffer + [i]
            expect(buffer.len()).to_equal(3)
            expect(buffer[0]).to_equal(10)

        it "handles multiple buffer instances":
            var buf1 = []
            var buf2 = []

            buf1 = buf1 + [1, 2, 3]
            buf2 = buf2 + [4, 5, 6]

            expect(buf1.len()).to_equal(3)
            expect(buf2.len()).to_equal(3)
            expect(buf1[0]).to_equal(1)
            expect(buf2[0]).to_equal(4)

        it "validates buffer capacity growth":
            var buffer = []
            for i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
                buffer = buffer + [i]
            expect(buffer.len()).to_equal(10)
            expect(buffer[9]).to_equal(10)

    context "string buffer patterns":
        it "builds strings incrementally":
            var result = ""
            for word in ["hello", " ", "world"]:
                result = result + word
            expect(result).to_equal("hello world")

        it "reuses string buffer":
            var buf = ""
            buf = buf + "line1{NL}"
            buf = buf + "line2{NL}"
            expect(buf).to_contain("line1")
            expect(buf).to_contain("line2")

# ============================================================================
# Feature #96: Generator Codegen
# ============================================================================

describe "Feature #96 - Generator State Machine Concepts":
    """
    ## Generator Codegen

    Generator state machine code generation. Transforms generator functions
    with yield statements into resumable state machines.

    These tests validate state machine patterns at the language level.
    """

    context "state machine pattern":
        it "simulates basic state machine":
            # Simulates a generator state machine with explicit state
            var state = 0
            var values = []

            # Step 1
            if state == 0:
                values = values + [1]
                state = 1

            # Step 2
            if state == 1:
                values = values + [2]
                state = 2

            # Step 3
            if state == 2:
                values = values + [3]
                state = 3

            expect(values).to_equal([1, 2, 3])
            expect(state).to_equal(3)

        it "simulates state machine with transitions":
            var state = "idle"
            var output = []

            # Transition: idle -> running
            if state == "idle":
                state = "running"
                output = output + ["started"]

            # Transition: running -> paused
            if state == "running":
                state = "paused"
                output = output + ["paused"]

            # Transition: paused -> running
            if state == "paused":
                state = "running"
                output = output + ["resumed"]

            expect(output.len()).to_equal(3)
            expect(output[0]).to_equal("started")
            expect(state).to_equal("running")

    context "iterator-like patterns":
        it "generates sequence of values":
            # Simulates a range generator
            var current = 0
            val max_val = 5
            var generated = []

            while current < max_val:
                generated = generated + [current]
                current = current + 1

            expect(generated).to_equal([0, 1, 2, 3, 4])
            expect(generated.len()).to_equal(5)

        it "generates fibonacci-like sequence":
            var a = 0
            var b = 1
            var sequence = [a, b]

            for i in [0, 1, 2, 3, 4]:
                val next = a + b
                sequence = sequence + [next]
                a = b
                b = next

            expect(sequence[0]).to_equal(0)
            expect(sequence[1]).to_equal(1)
            expect(sequence[2]).to_equal(1)
            expect(sequence[3]).to_equal(2)
            expect(sequence[4]).to_equal(3)
            expect(sequence[5]).to_equal(5)
            expect(sequence[6]).to_equal(8)

        it "generates values with accumulator":
            var sum = 0
            var partial_sums = []

            for n in [1, 2, 3, 4, 5]:
                sum = sum + n
                partial_sums = partial_sums + [sum]

            expect(partial_sums).to_equal([1, 3, 6, 10, 15])

    context "dispatcher entry pattern":
        it "dispatches based on state index":
            fn dispatch(state):
                if state == 0:
                    return "init"
                elif state == 1:
                    return "process"
                elif state == 2:
                    return "finalize"
                else:
                    return "done"

            expect(dispatch(0)).to_equal("init")
            expect(dispatch(1)).to_equal("process")
            expect(dispatch(2)).to_equal("finalize")
            expect(dispatch(3)).to_equal("done")
