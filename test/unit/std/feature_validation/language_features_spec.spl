# # Language Features Validation
#
# **Feature IDs:** #15 Variables, #24 Closures, #2 Parser
# **Category:** Language
# **Status:** Complete
#
# ## Overview
#
# Validates core language features including variable declarations (val/var/let),
# lambda syntax and closure capture, and parser functionality basics.

use std.spec

# ============================================================================
# Feature #15: Variables
# ============================================================================

describe "Feature #15 - Variables":
    # ## Variable Declarations
    #
    # Variable declarations with val for immutable bindings, var for mutable
    # bindings, and let as an alternative immutable binding. Supports type
    # annotations and type inference.

    context "val declarations (immutable)":
        it "declares immutable integer":
            val x = 42
            expect(x).to_equal(42)

        it "declares immutable string":
            val name = "Alice"
            expect(name).to_equal("Alice")

        it "declares immutable boolean":
            val flag = true
            expect(flag).to_equal(true)

        it "declares immutable array":
            val items = [1, 2, 3]
            expect(items.len()).to_equal(3)

        it "declares immutable with expression":
            val result = 2 + 3 * 4
            expect(result).to_equal(14)

    context "var declarations (mutable)":
        it "declares mutable integer":
            var count = 0
            count = count + 1
            expect(count).to_equal(1)

        it "allows reassignment":
            var value = 10
            value = 20
            expect(value).to_equal(20)

        it "supports mutation in loops":
            var total = 0
            for i in [1, 2, 3, 4, 5]:
                total = total + i
            expect(total).to_equal(15)

        it "supports mutable string":
            var msg = "hello"
            msg = "world"
            expect(msg).to_equal("world")

    context "let declarations":
        it "declares immutable binding with let":
            let x = 100
            expect(x).to_equal(100)

        it "declares let with string":
            let greeting = "hi"
            expect(greeting).to_equal("hi")

    context "type inference":
        it "infers integer type":
            val x = 42
            expect(x).to_equal(42)

        it "infers string type":
            val s = "hello"
            expect(s).to_start_with("h")

        it "infers boolean type":
            val b = true
            expect(b).to_equal(true)

        it "infers from expressions":
            val sum = 1 + 2
            expect(sum).to_equal(3)

# ============================================================================
# Feature #24: Closures
# ============================================================================

describe "Feature #24 - Closures":
    # ## Lambda Functions and Closures
    #
    # Lambda functions (anonymous functions) with lexical closure.
    # Captures variables from enclosing scope (read-only in interpreter).

    context "lambda syntax":
        it "creates simple lambda":
            val double = \x: x * 2
            expect(double(5)).to_equal(10)

        it "creates lambda with two parameters":
            val add = \a, b: a + b
            expect(add(3, 4)).to_equal(7)

        it "creates identity lambda":
            val id = \x: x
            expect(id(42)).to_equal(42)

    context "lambda with higher-order functions":
        it "uses lambda with map":
            val numbers = [1, 2, 3]
            val doubled = numbers.map(\x: x * 2)
            expect(doubled).to_equal([2, 4, 6])

        it "uses lambda with filter":
            val numbers = [1, 2, 3, 4, 5, 6]
            val evens = numbers.filter(\x: x % 2 == 0)
            expect(evens).to_equal([2, 4, 6])

    context "closure capture (read-only)":
        it "captures outer variable":
            val factor = 3
            val multiply = \x: x * factor
            expect(multiply(5)).to_equal(15)

        it "captures multiple outer variables":
            val base = 10
            val offset = 5
            val compute = \x: x + base + offset
            expect(compute(1)).to_equal(16)

        it "captures string variable":
            val prefix = "Hello"
            val greet = \name: "{prefix}, {name}!"
            expect(greet("World")).to_equal("Hello, World!")

    context "lambdas as values":
        it "stores lambda in val":
            val fn_val = \: 42
            expect(fn_val()).to_equal(42)

        it "passes lambda to function":
            fn apply(f, x):
                f(x)
            val result = apply(\x: x * 10, 5)
            expect(result).to_equal(50)

# ============================================================================
# Feature #2: Parser Basics
# ============================================================================

describe "Feature #2 - Parser":
    # ## Parser Functionality
    #
    # Transforms token stream into Abstract Syntax Tree (AST). Uses recursive
    # descent for statements and Pratt parsing for expressions with operator
    # precedence. This validates that the parser correctly handles basic
    # language constructs.

    context "arithmetic expressions":
        it "parses addition":
            expect(1 + 2).to_equal(3)

        it "parses subtraction":
            expect(10 - 3).to_equal(7)

        it "parses multiplication":
            expect(4 * 5).to_equal(20)

        it "parses division":
            expect(10 / 2).to_equal(5)

        it "parses modulo":
            expect(10 % 3).to_equal(1)

        it "parses operator precedence":
            # Multiplication before addition
            expect(2 + 3 * 4).to_equal(14)

        it "parses parenthesized expressions":
            expect((2 + 3) * 4).to_equal(20)

    context "comparison expressions":
        it "parses equality":
            expect(1 == 1).to_equal(true)

        it "parses inequality":
            expect(1 != 2).to_equal(true)

        it "parses less than":
            expect(1 < 2).to_equal(true)

        it "parses greater than":
            expect(2 > 1).to_equal(true)

        it "parses less than or equal":
            expect(1 <= 1).to_equal(true)

        it "parses greater than or equal":
            expect(2 >= 2).to_equal(true)

    context "logical expressions":
        it "parses and":
            expect(true and true).to_equal(true)
            expect(true and false).to_equal(false)

        it "parses or":
            expect(false or true).to_equal(true)
            expect(false or false).to_equal(false)

        it "parses not":
            expect(not false).to_equal(true)
            expect(not true).to_equal(false)

    context "string expressions":
        it "parses string literals":
            val s = "hello"
            expect(s).to_equal("hello")

        it "parses string interpolation":
            val name = "world"
            val msg = "hello {name}"
            expect(msg).to_equal("hello world")

        it "parses string concatenation":
            val a = "foo"
            val b = "bar"
            expect(a + b).to_equal("foobar")

    context "control flow parsing":
        it "parses if/else":
            val result = if true: "yes" else: "no"
            expect(result).to_equal("yes")

        it "parses for loop":
            var sum = 0
            for i in [1, 2, 3]:
                sum = sum + i
            expect(sum).to_equal(6)

        it "parses while loop":
            fn run_while_loop() -> i64:
                var count = 0
                while count < 3:
                    count = count + 1
                count
            expect(run_while_loop()).to_equal(3)

    context "function definitions":
        it "parses function with return value":
            fn square(x):
                x * x
            expect(square(5)).to_equal(25)

        it "parses function with multiple parameters":
            fn add_three(a, b, c):
                a + b + c
            expect(add_three(1, 2, 3)).to_equal(6)

    context "collection literals":
        it "parses array literals":
            val arr = [10, 20, 30]
            expect(arr.len()).to_equal(3)
            expect(arr[0]).to_equal(10)

        it "parses empty array":
            val empty = []
            expect(empty.len()).to_equal(0)

        it "parses dictionary literals":
            val dict = {"key": "value"}
            expect(dict["key"]).to_equal("value")
