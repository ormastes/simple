# Constructor Integration Tests
# Tests at module level where all features work
# Constructor integration tests validating struct instantiation patterns.
# Tests direct construction, implicit static constructors, factory methods,
# and the interaction between instance methods and static methods at
# module level.

# Module-level struct definitions for testing
fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")
struct Point:
    x: i64
    y: i64

struct Config:
    value: i64

struct Settings:
    enabled: bool

struct Builder:
    name: text

struct Rectangle:
    width: i64
    height: i64

struct Counter:
    count: i64

# Implementations with implicit static constructors
impl Point:
    fn new(x: i64, y: i64) -> Point:  # Implicitly static
        return Point(x: x, y: y)

    fn from_tuple(t: (i64, i64)) -> Point:  # Also implicitly static
        return Point(x: t.0, y: t.1)

impl Config:
    fn create(value: i64) -> Config:
        return Config(value: value)

impl Settings:
    fn default() -> Settings:
        return Settings(enabled: true)

impl Builder:
    static fn with_name(name: text) -> Builder:
        return Builder(name: name)

impl Rectangle:
    static fn new(width: i64, height: i64) -> Rectangle:  # Explicit static
        return Rectangle(width: width, height: height)

impl Counter:
    fn new() -> Counter:  # Implicitly static
        return Counter(count: 0)

    fn get_count() -> i64:  # Instance method
        return self.count

    me increment():
        self.count = self.count + 1

# Wrapper functions for locally-defined struct static methods
fn Point__new(x: i64, y: i64) -> Point:
    Point.new(x, y)

fn Point__from_tuple(t: (i64, i64)) -> Point:
    Point.from_tuple(t)

fn Config__create(value: i64) -> Config:
    Config.create(value)

fn Settings__default() -> Settings:
    Settings.default()

fn Builder__with_name(name: text) -> Builder:
    Builder.with_name(name)

fn Rectangle__new(width: i64, height: i64) -> Rectangle:
    Rectangle.new(width, height)

fn Counter__new() -> Counter:
    Counter.new()

describe "Module-Level Constructors":
    # Tests struct construction patterns at module level including direct
    # construction, implicit static methods, and factory method patterns.
    it "Direct construction works (PRIMARY METHOD)":
        val p = Point(5, 6)
        check(p.x == 5)
        check(p.y == 6)

    it "Direct construction with named parameters":
        val p = Point(x: 7, y: 8)
        check(p.x == 7)
        check(p.y == 8)

    it "fn new() is implicitly static at module level":
        val p = Point__new(3, 4)
        check(p.x == 3)
        check(p.y == 4)

    it "fn create() is implicitly static":
        val cfg = Config__create(42)
        check(cfg.value == 42)

    it "fn default() is implicitly static":
        val settings = Settings__default()
        check(settings.enabled == true)

    it "fn from_* is implicitly static":
        val p = Point__from_tuple((10, 20))
        check(p.x == 10)
        check(p.y == 20)

    it "static fn with_* works as factory":
        val b = Builder__with_name("test")
        check(b.name == "test")

    it "Explicit static keyword still works":
        val r = Rectangle__new(10, 20)
        check(r.width == 10)
        check(r.height == 20)

    it "Instance methods still get implicit self":
        val c = Counter__new()
        check(c.get_count() == 0)
        c.increment()
        check(c.get_count() == 1)
        c.increment()
        check(c.get_count() == 2)

    it "Direct construction and new() can coexist":
        val p1 = Point(1, 2)          # Direct
        val p2 = Point__new(3, 4)      # Via new()
        check(p1.x + p2.x == 4)
        check(p1.y + p2.y == 6)
