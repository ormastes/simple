# @pending
"""
Feature: SDN Parser
Category: SDN Parser
Status: Complete
"""

# Tests for LL(2) recursive descent parser.
#
# Covers:
# - Primitive parsing (all value types)
# - Inline collections (short form with =)
# - Block collections (long form with :)
# - Tables (named with |fields|, typed with table{types})
# - Dict vs array block disambiguation (LL(2) lookahead)
# - Error handling

use sdn.parser.{Parser, parse}
use sdn.value.SdnValue

describe "SDN Parser":
    """
    LL(2) recursive descent parser for SDN with full support for primitives, collections, and tables.
    """
    context "simple values":
        it "parses key-value pairs":
            val source = "name: Alice"
            match parse(source):
                case Ok(value):
                    match value.get("name"):
                        case Some(v):
                            expect v.as_str() == Some("Alice")
                        case nil:
                            fail("Expected 'name' key")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses multiple values":
            val source = "name: Alice\nage: 30\ncity: NYC"
            match parse(source):
                case Ok(value):
                    expect value.get("name").flatmap(|v| v.as_str()) == Some("Alice")
                    expect value.get("age").flatmap(|v| v.as_i64()) == Some(30)
                    expect value.get("city").flatmap(|v| v.as_str()) == Some("NYC")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

    context "inline collections":
        it "parses inline dicts":
            val source = "point = " + "{" + "xval: 10, yval: 20" + "}"
            match parse(source):
                case Ok(value):
                    match value.get("point"):
                        case Some(point):
                            expect point.get("xval").flatmap(|v| v.as_i64()) == Some(10)
                            expect point.get("yval").flatmap(|v| v.as_i64()) == Some(20)
                        case nil:
                            fail("Expected 'point' key")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses inline arrays":
            val source = "items = [1, 2, 3, 4, 5]"
            match parse(source):
                case Ok(value):
                    match value.get("items"):
                        case Some(arr):
                            match arr.as_array():
                                case Some(list):
                                    expect list.len() == 5
                                    expect list[0].as_i64() == Some(1)
                                    expect list[4].as_i64() == Some(5)
                                case nil:
                                    fail("Expected array")
                        case nil:
                            fail("Expected 'items' key")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses nested inline collections":
            val inner_config = "{" + "xval: 10" + "}"
            val source = "data = " + "{" + "items_list: [1, 2, 3], config: " + inner_config + "}"
            match parse(source):
                case Ok(value):
                    match value.get("data"):
                        case Some(nested_data):
                            # Check items array
                            match nested_data.get("items_list"):
                                case Some(arr):
                                    expect arr.is_array() == true
                                case nil:
                                    fail("Expected 'items_list' in data")
                            # Check config dict
                            match nested_data.get("config"):
                                case Some(cfg):
                                    expect cfg.get("xval").flatmap(|v| v.as_i64()) == Some(10)
                                case nil:
                                    fail("Expected 'config' in data")
                        case nil:
                            fail("Expected 'data' key")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

    context "block collections":
        it "parses block dicts":
            val source = "person:\n    name: Alice\n    age: 30"
            match parse(source):
                case Ok(value):
                    match value.get("person"):
                        case Some(person):
                            expect person.get("name").flatmap(|v| v.as_str()) == Some("Alice")
                            expect person.get("age").flatmap(|v| v.as_i64()) == Some(30)
                        case nil:
                            fail("Expected 'person' key")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses block arrays":
            val source = "numbers:\n    1\n    2\n    3"
            match parse(source):
                case Ok(value):
                    match value.get("numbers"):
                        case Some(arr):
                            match arr.as_array():
                                case Some(list):
                                    expect list.len() == 3
                                    expect list[0].as_i64() == Some(1)
                                    expect list[2].as_i64() == Some(3)
                                case nil:
                                    fail("Expected array")
                        case nil:
                            fail("Expected 'numbers' key")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "disambiguates dict vs array blocks":
            # This tests the LL(2) lookahead: identifier followed by colon = dict
            val dict_source = "config:\n    host: localhost\n    port: 8080"
            match parse(dict_source):
                case Ok(value):
                    match value.get("config"):
                        case Some(cfg):
                            expect cfg.is_dict() == true
                            expect cfg.get("host").is_some() == true
                        case nil:
                            fail("Expected 'config' key")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

            # Array block: no colon after identifiers
            val arr_source = "items:\n    apple\n    banana\n    cherry"
            match parse(arr_source):
                case Ok(value):
                    match value.get("items"):
                        case Some(arr):
                            expect arr.is_array() == true
                        case nil:
                            fail("Expected 'items' key")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

    context "tables":
        it "parses named tables":
            val source = "users |id, name, age|\n    1, Alice, 30\n    2, Bob, 25"
            match parse(source):
                case Ok(value):
                    match value.get("users"):
                        case Some(table):
                            expect table.is_table() == true
                            expect table.row_count() == Some(2)
                            expect table.column_count() == Some(3)
                        case nil:
                            fail("Expected 'users' table")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses typed tables":
            # Use escaped curly braces instead of raw string for multiline
            val type_decl = "table" + "{" + "int, string, boolean" + "}"
            val source = "data: " + type_decl + "\n    1, hello, true\n    2, world, false"
            match parse(source):
                case Ok(value):
                    match value.get("data"):
                        case Some(typed_table):
                            expect typed_table.is_table() == true
                            expect typed_table.is_typed_table() == true
                            expect typed_table.row_count() == Some(2)
                        case nil:
                            fail("Expected 'data' table")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

    context "error handling":
        it "reports syntax errors":
            # Missing value after colon
            val source = "key:"
            match parse(source):
                case Ok(_):
                    # Empty value is valid (null)
                    pass
                case Err(e):
                    # Or it could be an error - either is acceptable
                    expect e.to_string().len() > 0

        it "reports unexpected tokens":
            # Invalid syntax - two colons in a row
            val source = "key. value"
            match parse(source):
                case Ok(_):
                    # Parser may recover or fail
                    pass
                case Err(e):
                    # Error expected
                    expect e.to_string().len() > 0
