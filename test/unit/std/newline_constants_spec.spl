use std.string.{LF, CR, CRLF, NL, _NL, platform_newline, normalize_newlines}

describe "Newline Constants":
    it "defines LF constant":
        expect(LF).to_equal("\n")
        expect(LF.len()).to_equal(1)

    it "defines CR constant":
        expect(CR).to_equal("\r")
        expect(CR.len()).to_equal(1)

    it "defines CRLF constant":
        expect(CRLF).to_equal("\r\n")
        expect(CRLF.len()).to_equal(2)

    it "defines _NL as explicit LF":
        expect(_NL).to_equal("\n")
        expect(_NL).to_equal(LF)

    it "defines NL as LF default":
        expect(NL).to_equal("\n")
        expect(NL).to_equal(LF)

describe "platform_newline":
    it "returns a valid newline string":
        val nl = platform_newline()
        val is_lf = nl == LF
        val is_crlf = nl == CRLF
        val is_valid = is_lf or is_crlf
        expect(is_valid).to_equal(true)

    it "returns at least one character":
        val nl = platform_newline()
        val len_ok = nl.len() >= 1
        expect(len_ok).to_equal(true)

describe "normalize_newlines":
    it "converts CRLF to LF":
        val input = "line1\r\nline2\r\n"
        val output = normalize_newlines(input)
        expect(output).to_equal("line1\nline2\n")

    it "converts CR to LF":
        val input = "line1\rline2\r"
        val output = normalize_newlines(input)
        expect(output).to_equal("line1\nline2\n")

    it "handles mixed newlines":
        val input = "a\r\nb\rc\n"
        val output = normalize_newlines(input)
        expect(output).to_equal("a\nb\nc\n")

    it "preserves existing LF":
        val input = "line1\nline2\n"
        val output = normalize_newlines(input)
        expect(output).to_equal(input)

    it "handles empty string":
        val output = normalize_newlines("")
        expect(output).to_equal("")

    it "handles text without newlines":
        val input = "just plain text"
        val output = normalize_newlines(input)
        expect(output).to_equal(input)

describe "String interpolation with constants":
    it "works with NL in interpolation":
        val text = "line1{NL}line2"
        expect(text).to_contain("line1")
        expect(text).to_contain("line2")

    it "works with _NL in interpolation":
        val text = "line1{_NL}line2"
        expect(text).to_contain("\n")
        expect(text).to_equal("line1\nline2")

    it "works with LF in interpolation":
        val text = "a{LF}b"
        expect(text).to_equal("a\nb")

    it "works with CRLF in interpolation":
        val text = "a{CRLF}b"
        expect(text).to_equal("a\r\nb")

describe "replace operations with constants":
    it "can replace explicit newlines with CRLF":
        val text = "a\nb\nc"
        val result = text.replace("\n", CRLF)
        expect(result).to_equal("a\r\nb\r\nc")

    it "can replace CRLF with LF":
        val win = "line1\r\nline2\r\n"
        val unix = win.replace(CRLF, LF)
        expect(unix).to_equal("line1\nline2\n")

    it "can use _NL for explicit LF replacement":
        val text = "a|b|c"
        val result = text.replace("|", _NL)
        expect(result).to_equal("a\nb\nc")

    it "can normalize then split on LF":
        val mixed = "a\r\nb\rc"
        var normalized = normalize_newlines(mixed)
        val parts = normalized.split(LF)
        expect(parts.len()).to_equal(3)
