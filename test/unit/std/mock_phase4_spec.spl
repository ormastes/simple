"""
Mock Phase 4 Specification - Advanced Patterns

Advanced mocking patterns including conditional returns, call chain tracking,
state-based behavior sequences, mock snapshots, and mock composition.

Feature IDs: Testing Infrastructure - Mock Advanced Patterns
Category: Testing
Status: Phase 4 (Advanced Patterns)
"""

# ============================================================================
# Local Definitions (workaround for module import limitation)
# ============================================================================

use std.string.{NL}
struct CallRecord:
    args: [text]
    timestamp: i64
    call_number: i32

struct Expectation:
    method_name: text
    expected_times: i32
    expected_args: Option<[text]>

class VerificationResult:
    passed: bool
    error_message: text

    static fn success() -> VerificationResult:
        VerificationResult(passed: true, error_message: "")

    static fn failure(message: text) -> VerificationResult:
        VerificationResult(passed: false, error_message: message)

    fn is_ok() -> bool:
        self.passed

    fn is_err() -> bool:
        not self.passed

    fn unwrap_err() -> text:
        self.error_message

class MockFunction:
    name: text
    calls: [CallRecord]
    return_values: [text]
    return_index: i32
    should_panic: bool
    panic_message: text
    expectations: [Expectation]

    static fn new(name: text) -> MockFunction:
        MockFunction(
            name: name,
            calls: [],
            return_values: [],
            return_index: 0,
            should_panic: false,
            panic_message: "",
            expectations: []
        )

    me record_call(args: [text]):
        val record = CallRecord(
            args: args,
            timestamp: 0,
            call_number: self.calls.len() as i32
        )
        var calls = self.calls
        calls.append(record)
        self.calls = calls

    me set_return_values(values: [text]):
        self.return_values = values
        self.return_index = 0

    fn call_count() -> i32:
        self.calls.len() as i32

    fn was_called() -> bool:
        self.calls.len() > 0

    fn was_called_with(expected_args: [text]) -> bool:
        for call in self.calls:
            if call.args.len() == expected_args.len():
                var matches = true
                for i in 0..call.args.len():
                    if call.args[i] != expected_args[i]:
                        matches = false
                        break
                if matches:
                    return true
        false

    fn was_called_n_times(times: i32) -> bool:
        self.call_count() == times

    fn get_call(index: i32) -> Option<CallRecord>:
        if index >= 0 and index < self.calls.len() as i32:
            Some(self.calls[index])
        else:
            nil

    fn get_last_call() -> Option<CallRecord>:
        if self.calls.len() > 0:
            Some(self.calls[self.calls.len() - 1])
        else:
            nil

    me reset():
        self.calls = []
        self.return_values = []
        self.return_index = 0
        self.should_panic = false
        self.panic_message = ""
        self.expectations = []

    fn verify() -> VerificationResult:
        for expectation in self.expectations:
            if expectation.expected_times == 0:
                match expectation.expected_args:
                    Some(args):
                        if not self.was_called_with(args):
                            val msg = "Expected '{self.name}' to be called with {args}, but was not"
                            return VerificationResult.failure(msg)
                    nil: true
            else:
                if not self.was_called_n_times(expectation.expected_times):
                    val msg = "Expected '{self.name}' to be called {expectation.expected_times} times, but was called {self.call_count()} times"
                    return VerificationResult.failure(msg)
            match expectation.expected_args:
                Some(args):
                    if not self.was_called_with(args):
                        val msg = "Expected '{self.name}' to be called with {args}, but was not"
                        return VerificationResult.failure(msg)
                nil: true

        VerificationResult.success()

    me expect_call(times: i32):
        var expectations = self.expectations
        expectations.append(Expectation(
            method_name: self.name,
            expected_times: times,
            expected_args: nil
        ))
        self.expectations = expectations

    me expect_call_with(args: [text]):
        var expectations = self.expectations
        expectations.append(Expectation(
            method_name: self.name,
            expected_times: 0,
            expected_args: Some(args)
        ))
        self.expectations = expectations

    fn summary() -> text:
        if self.calls.len() == 0:
            return "Mock '{self.name}': not called"
        var result = "Mock '{self.name}': called {self.call_count()} time(s){NL}"
        for call in self.calls:
            result = result + "  {call.args}{NL}"
        result

# ============================================================================
# Phase 4: Advanced Patterns
# ============================================================================

struct ConditionalReturn:
    condition: fn([text]) -> bool
    value: text

class ConditionalReturns:
    conditions: [ConditionalReturn]
    default_value: text

    static fn new() -> ConditionalReturns:
        ConditionalReturns(conditions: [], default_value: "")

    me add_condition(condition: fn([text]) -> bool, value: text):
        var conditions = self.conditions
        conditions.append(ConditionalReturn(condition: condition, value: value))
        self.conditions = conditions

    me set_default(value: text):
        self.default_value = value

    fn evaluate(args: [text]) -> text:
        for cond_return in self.conditions:
            val cond_fn = cond_return.condition
            if cond_fn(args):
                return cond_return.value
        self.default_value

struct CallChain:
    parent_id: i32
    call_record: CallRecord
    child_ids: [i32]

class CallChainTracker:
    chains: [CallChain]
    next_id: i32

    static fn new() -> CallChainTracker:
        CallChainTracker(chains: [], next_id: 0)

    me start_chain(parent_id: i32, call: CallRecord) -> i32:
        val id = self.next_id
        self.next_id = self.next_id + 1
        var chains = self.chains
        chains.append(CallChain(
            parent_id: parent_id,
            call_record: call,
            child_ids: []
        ))
        self.chains = chains
        id

    me add_child(parent_id: i32, child_id: i32):
        for chain in self.chains:
            if chain.parent_id == parent_id:
                var child_ids = chain.child_ids
                child_ids.append(child_id)
                chain.child_ids = child_ids

    fn get_chain(id: i32) -> Option<CallChain>:
        for chain in self.chains:
            if chain.parent_id == id:
                return Some(chain)
        nil

    fn get_all_chains() -> [CallChain]:
        self.chains

struct BehaviorState:
    state_name: text
    return_value: text
    next_state: Option<text>

class BehaviorSequence:
    states: [BehaviorState]
    current_state: text

    static fn new(initial: text) -> BehaviorSequence:
        BehaviorSequence(states: [], current_state: initial)

    me add_state(name: text, return_value: text, next_state: Option<text>):
        var states = self.states
        states.append(BehaviorState(
            state_name: name,
            return_value: return_value,
            next_state: next_state
        ))
        self.states = states

    me transition() -> Option<text>:
        for state in self.states:
            if state.state_name == self.current_state:
                match state.next_state:
                    Some(next): self.current_state = next
                    nil: true
                return Some(state.return_value)
        nil

    fn get_current_state() -> text:
        self.current_state

    me reset_to(state: text):
        self.current_state = state

class MockSnapshot:
    timestamp: i64
    call_count: i32
    last_args: [text]
    expectations_met: bool

    static fn from_mock(mockfn: MockFunction) -> MockSnapshot:
        var last_args: [text] = []
        match mockfn.get_last_call():
            Some(call): last_args = call.args
            nil: true
        MockSnapshot(
            timestamp: 0,
            call_count: mockfn.call_count(),
            last_args: last_args,
            expectations_met: mockfn.verify().is_ok()
        )

    fn summary() -> text:
        "Snapshot: {self.call_count} calls, expectations_met={self.expectations_met}"

class MockComposition:
    mocks: [MockFunction]

    static fn new() -> MockComposition:
        MockComposition(mocks: [])

    me add_mock(mockfn: MockFunction):
        var mocks = self.mocks
        mocks.append(mockfn)
        self.mocks = mocks

    fn verify_all() -> bool:
        for mockfn in self.mocks:
            val result = mockfn.verify()
            if result.is_err():
                return false
        true

    fn get_total_calls() -> i32:
        var total = 0
        for mockfn in self.mocks:
            total = total + mockfn.call_count()
        total

    me reset_all():
        for mockfn in self.mocks:
            mockfn.reset()

    fn summary() -> text:
        var result = "MockComposition: {self.mocks.len()} mocks, {self.get_total_calls()} total calls{NL}"
        for mockfn in self.mocks:
            result = result + "  " + mockfn.summary() + NL
        result

# ============================================================================
# Test Suite
# ============================================================================

describe "Mock Library - Phase 4 (Advanced Patterns)":
    """
    Test suite for Phase 4 of the Mock Library focusing on advanced patterns.

    Tests cover:
    - Conditional Returns: Returning values based on argument conditions, multiple conditions, defaults
    - Call Chain Tracking: Tracking parent-child call relationships, retrieving chains by ID
    - State-Based Behavior Sequences: State machine transitions, terminal states, reset functionality
    - Mock Snapshots: Capturing mock state at a point in time, tracking expectation satisfaction
    - Mock Composition: Grouping multiple mocks, verifying all mocks, counting total calls, reset all
    - Complex Scenarios: Combining conditional returns with snapshots, state machines with composition,
      chaining calls with tracking, multi-mock workflows
    """
    context "Conditional Returns":
        it "returns value based on argument condition":
            val cond_returns = ConditionalReturns.new()
            cond_returns.add_condition(
                \args: args.len() > 0 and args[0] == "user",
                "user_data"
            )
            cond_returns.set_default("unknown")
            expect cond_returns.evaluate(["user"]) == "user_data"
            expect cond_returns.evaluate(["admin"]) == "unknown"

        it "checks multiple conditions in order":
            val cond = ConditionalReturns.new()
            cond.add_condition(
                \args: args.len() > 0 and args[0] == "GET",
                "retrieve"
            )
            cond.add_condition(
                \args: args.len() > 0 and args[0] == "POST",
                "create"
            )
            cond.set_default("other")
            expect cond.evaluate(["GET"]) == "retrieve"
            expect cond.evaluate(["POST"]) == "create"
            expect cond.evaluate(["DELETE"]) == "other"

        it "returns default when no conditions match":
            val cond = ConditionalReturns.new()
            cond.add_condition(
                \args: args.len() == 0,
                "empty"
            )
            cond.set_default("fallback")
            expect cond.evaluate(["something"]) == "fallback"

    context "Call Chain Tracking":
        it "tracks parent-child call relationships":
            val tracker = CallChainTracker.new()
            val call1 = CallRecord(args: ["parent"], timestamp: 0, call_number: 0)
            val id1 = tracker.start_chain(-1, call1)
            expect id1 == 0
            val call2 = CallRecord(args: ["child"], timestamp: 0, call_number: 1)
            val id2 = tracker.start_chain(id1, call2)
            expect id2 == 1
            tracker.add_child(parent_id=id1, child_id=id2)
            val all_chains = tracker.get_all_chains()
            expect all_chains.len() == 2

        it "retrieves chain by parent id":
            val tracker = CallChainTracker.new()
            val call = CallRecord(args: ["test"], timestamp: 0, call_number: 0)
            val id = tracker.start_chain(5, call)
            expect tracker.get_chain(5).is_some()

        it "starts multiple independent chains":
            val tracker = CallChainTracker.new()
            val call1 = CallRecord(args: ["a"], timestamp: 0, call_number: 0)
            val call2 = CallRecord(args: ["b"], timestamp: 0, call_number: 1)
            val id1 = tracker.start_chain(-1, call1)
            val id2 = tracker.start_chain(-1, call2)
            expect id1 != id2
            expect tracker.get_all_chains().len() == 2

    context "State-Based Behavior Sequences":
        it "transitions through behavior states":
            val behavior = BehaviorSequence.new("init")
            behavior.add_state(name="init", return_value="initializing", next_state=Some("ready"))
            behavior.add_state(name="ready", return_value="operational", next_state=Some("shutdown"))
            behavior.add_state(name="shutdown", return_value="stopped", next_state=nil)
            expect behavior.transition() == Some("initializing")
            expect behavior.get_current_state() == "ready"
            expect behavior.transition() == Some("operational")
            expect behavior.get_current_state() == "shutdown"

        it "handles terminal states":
            val behavior = BehaviorSequence.new("start")
            behavior.add_state(name="start", return_value="started", next_state=Some("end"))
            behavior.add_state(name="end", return_value="finished", next_state=nil)
            behavior.transition()
            expect behavior.get_current_state() == "end"
            behavior.transition()
            expect behavior.get_current_state() == "end"

        it "resets to initial state":
            val behavior = BehaviorSequence.new("a")
            behavior.add_state(name="a", return_value="value_a", next_state=Some("b"))
            behavior.add_state(name="b", return_value="value_b", next_state=nil)
            behavior.transition()
            expect behavior.get_current_state() == "b"
            behavior.reset_to("a")
            expect behavior.get_current_state() == "a"

        it "manages complex state machines":
            val behavior = BehaviorSequence.new("idle")
            behavior.add_state(name="idle", return_value="waiting", next_state=Some("running"))
            behavior.add_state(name="running", return_value="executing", next_state=Some("paused"))
            behavior.add_state(name="paused", return_value="suspended", next_state=Some("running"))
            expect behavior.transition() == Some("waiting")
            expect behavior.transition() == Some("executing")
            expect behavior.transition() == Some("suspended")

    context "Mock Snapshots":
        it "captures mock state at a point in time":
            val mockfn = MockFunction.new("service")
            mockfn.record_call(["arg1"])
            mockfn.record_call(["arg2"])
            val snapshot = MockSnapshot.from_mock(mockfn)
            expect snapshot.call_count == 2
            expect snapshot.last_args[0] == "arg2"

        it "tracks expectation satisfaction in snapshot":
            val mockfn = MockFunction.new("verified")
            mockfn.expect_call(1)
            mockfn.record_call([])
            val snapshot = MockSnapshot.from_mock(mockfn)
            expect snapshot.expectations_met == true

        it "shows when expectations are not met":
            val mockfn = MockFunction.new("unverified")
            mockfn.expect_call(2)
            mockfn.record_call([])
            val snapshot = MockSnapshot.from_mock(mockfn)
            expect snapshot.expectations_met == false

        it "generates snapshot summary":
            val mockfn = MockFunction.new("test")
            mockfn.record_call([])
            val snapshot = MockSnapshot.from_mock(mockfn)
            val summary = snapshot.summary()
            expect summary.contains("1")
            expect summary.contains("Snapshot")

    context "Mock Composition":
        it "groups multiple mocks":
            val composition = MockComposition.new()
            val m1 = MockFunction.new("fn1")
            val m2 = MockFunction.new("fn2")
            composition.add_mock(m1)
            composition.add_mock(m2)
            expect composition.mocks.len() == 2

        it "verifies all mocks in composition":
            val composition = MockComposition.new()
            val m1 = MockFunction.new("fn1")
            val m2 = MockFunction.new("fn2")
            m1.expect_call(1)
            m2.expect_call(1)
            m1.record_call([])
            m2.record_call([])
            composition.add_mock(m1)
            composition.add_mock(m2)
            expect composition.verify_all() == true

        it "fails verification if any mock fails":
            val composition = MockComposition.new()
            val m1 = MockFunction.new("fn1")
            val m2 = MockFunction.new("fn2")
            m1.expect_call(1)
            m2.expect_call(2)
            m1.record_call([])
            m2.record_call([])
            composition.add_mock(m1)
            composition.add_mock(m2)
            expect composition.verify_all() == false

        it "counts total calls across all mocks":
            val composition = MockComposition.new()
            val m1 = MockFunction.new("fn1")
            val m2 = MockFunction.new("fn2")
            m1.record_call([])
            m1.record_call([])
            m2.record_call([])
            composition.add_mock(m1)
            composition.add_mock(m2)
            expect composition.get_total_calls() == 3

        it "resets all mocks in composition":
            val composition = MockComposition.new()
            val m1 = MockFunction.new("fn1")
            val m2 = MockFunction.new("fn2")
            m1.record_call([])
            m2.record_call([])
            composition.add_mock(m1)
            composition.add_mock(m2)
            expect composition.get_total_calls() == 2
            composition.reset_all()
            expect composition.get_total_calls() == 0

        it "generates composition summary":
            val composition = MockComposition.new()
            val m1 = MockFunction.new("api")
            val m2 = MockFunction.new("db")
            m1.record_call(["GET"])
            m2.record_call(["SELECT"])
            composition.add_mock(m1)
            composition.add_mock(m2)
            val summary = composition.summary()
            expect summary.contains("2")
            expect summary.contains("mocks")
            expect summary.contains("2")

    context "Complex Phase 4 Scenarios":
        it "combines conditional returns with snapshots":
            val cond = ConditionalReturns.new()
            cond.add_condition(
                \args: args.len() > 0 and args[0] == "cache",
                "cached_value"
            )
            cond.set_default("fresh_value")
            expect cond.evaluate(["cache"]) == "cached_value"
            expect cond.evaluate(["fetch"]) == "fresh_value"

        it "uses state machine with mock composition":
            val composition = MockComposition.new()
            val behavior = BehaviorSequence.new("init")
            behavior.add_state(name="init", return_value="starting", next_state=Some("running"))
            behavior.add_state(name="running", return_value="operational", next_state=nil)
            val m1 = MockFunction.new("startup")
            val m2 = MockFunction.new("service")
            composition.add_mock(m1)
            composition.add_mock(m2)
            m1.record_call([])
            m2.record_call([])
            expect composition.get_total_calls() == 2
            expect behavior.transition() == Some("starting")

        it "chains calls and tracks with snapshots":
            val tracker = CallChainTracker.new()
            val mockfn = MockFunction.new("main")
            val call1 = CallRecord(args: ["init"], timestamp: 0, call_number: 0)
            val call2 = CallRecord(args: ["process"], timestamp: 0, call_number: 1)
            val id1 = tracker.start_chain(-1, call1)
            val id2 = tracker.start_chain(id1, call2)
            tracker.add_child(parent_id=id1, child_id=id2)
            mockfn.record_call(["init"])
            mockfn.record_call(["process"])
            val snapshot = MockSnapshot.from_mock(mockfn)
            expect snapshot.call_count == 2

        it "manages complex multi-mock workflow":
            val api_mock = MockFunction.new("api")
            val db_mock = MockFunction.new("db")
            val cache_mock = MockFunction.new("cache")
            val composition = MockComposition.new()
            composition.add_mock(api_mock)
            composition.add_mock(db_mock)
            composition.add_mock(cache_mock)
            api_mock.record_call(["GET", "/users"])
            db_mock.record_call(["SELECT", "users"])
            cache_mock.record_call(["get", "users"])
            expect composition.get_total_calls() == 3
            val summary = composition.summary()
            expect summary.contains("3")
