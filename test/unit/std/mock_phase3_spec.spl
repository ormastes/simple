"""
Mock Phase 3 Specification - Advanced Features

Tests advanced mocking capabilities including:
- Matcher composition with AND, OR, and NOT logical operators
- Custom predicate matchers for complex matching logic
- CallAnalyzer for analyzing recorded call history
- SequentialReturns for defining ordered return value sequences
- Spy for recording method calls on objects without replacing behavior

Feature IDs: Testing Infrastructure - Mock Advanced Features
Category: Testing
Status: Phase 3 (Advanced)
"""

# ============================================================================
# Local Class Definitions
# (Import system doesn't support module.Class.staticMethod() pattern)
# ============================================================================

struct CallRecord:
    args: [text]
    timestamp: i64
    call_number: i32

struct Expectation:
    method_name: text
    expected_times: i32
    expected_args: Option<[text]>

class MockFunction:
    name: text
    calls: [CallRecord]
    return_values: [text]
    return_index: i32
    should_panic: bool
    panic_message: text
    expectations: [Expectation]

    static fn new(name: text) -> MockFunction:
        MockFunction(
            name: name,
            calls: [],
            return_values: [],
            return_index: 0,
            should_panic: false,
            panic_message: "",
            expectations: []
        )

    me record_call(args: [text]):
        val record = CallRecord(
            args: args,
            timestamp: 0,
            call_number: self.calls.len() as i32
        )
        # Workaround: nested field mutation requires copy-modify-assign
        var calls = self.calls
        calls.append(record)
        self.calls = calls

    fn call_count() -> i32:
        self.calls.len() as i32

    fn was_called() -> bool:
        self.calls.len() > 0

    fn was_called_with(expected_args: [text]) -> bool:
        for call in self.calls:
            if call.args.len() == expected_args.len():
                var matches = true
                for i in 0..call.args.len():
                    if call.args[i] != expected_args[i]:
                        matches = false
                        break
                if matches:
                    return true
        false

    me reset():
        self.calls = []
        self.return_values = []
        self.return_index = 0

class Matcher:
    matches_fn: fn(text) -> bool

    static fn any() -> Matcher:
        Matcher(matches_fn: \arg: true)

    static fn eq(value: text) -> Matcher:
        Matcher(matches_fn: \arg: arg == value)

    static fn gt(n: i32) -> Matcher:
        Matcher(matches_fn: \arg:
            match arg.parse_i32():
                Some(v): v > n
                nil: false
        )

    static fn lt(n: i32) -> Matcher:
        Matcher(matches_fn: \arg:
            match arg.parse_i32():
                Some(v): v < n
                nil: false
        )

    static fn contains(substring: text) -> Matcher:
        Matcher(matches_fn: \arg: arg.contains(substring))

    static fn starts_with(prefix: text) -> Matcher:
        Matcher(matches_fn: \arg: arg.starts_with(prefix))

    static fn and_matcher(m1: Matcher, m2: Matcher) -> Matcher:
        Matcher(matches_fn: \arg: m1.matches(arg) and m2.matches(arg))

    static fn or_matcher(m1: Matcher, m2: Matcher) -> Matcher:
        Matcher(matches_fn: \arg: m1.matches(arg) or m2.matches(arg))

    static fn not_matcher(m: Matcher) -> Matcher:
        Matcher(matches_fn: \arg: not m.matches(arg))

    static fn predicate(fn_pred: fn(text) -> bool) -> Matcher:
        Matcher(matches_fn: fn_pred)

    fn matches(arg: text) -> bool:
        val fn_ref = self.matches_fn
        fn_ref(arg)

class CallAnalyzer:
    mockfn: MockFunction

    static fn new(mockfn: MockFunction) -> CallAnalyzer:
        CallAnalyzer(mockfn: mockfn)

    fn count_calls_with(args: [text]) -> i32:
        var count = 0
        for call in self.mockfn.calls:
            if call.args.len() == args.len():
                var matches = true
                for i in 0..call.args.len():
                    if call.args[i] != args[i]:
                        matches = false
                        break
                if matches:
                    count = count + 1
        count

    fn get_calls_matching(matcher_fn: fn(CallRecord) -> bool) -> [CallRecord]:
        var result = []
        for call in self.mockfn.calls:
            if matcher_fn(call):
                result.append(call)
        result

    fn get_first_call() -> Option<CallRecord>:
        if self.mockfn.calls.len() == 0:
            return None
        Some(self.mockfn.calls[0])

    fn get_calls_between(start_idx: i32, end_idx: i32) -> [CallRecord]:
        var result = []
        for i in start_idx..end_idx:
            if i >= 0 and i < self.mockfn.calls.len() as i32:
                result.append(self.mockfn.calls[i])
        result

struct ReturnValue:
    value: text
    times: i32

class SequentialReturns:
    returns: [ReturnValue]
    current_idx: i32
    times_used: i32

    static fn new() -> SequentialReturns:
        SequentialReturns(returns: [], current_idx: 0, times_used: 0)

    me add_return(value: text, times: i32):
        var returns = self.returns
        returns.append(ReturnValue(value: value, times: times))
        self.returns = returns

    me add_return_once(value: text):
        self.add_return(value, 1)

    me next_value() -> Option<text>:
        if self.current_idx >= self.returns.len() as i32:
            return None
        val current = self.returns[self.current_idx]
        self.times_used = self.times_used + 1
        if self.times_used >= current.times:
            self.current_idx = self.current_idx + 1
            self.times_used = 0
        Some(current.value)

    me reset():
        self.current_idx = 0
        self.times_used = 0

class Spy:
    name: text
    calls: [CallRecord]
    call_count_value: i32

    static fn new(name: text) -> Spy:
        Spy(
            name: name,
            calls: [],
            call_count_value: 0
        )

    me record_call(method: text, args: [text]):
        val full_args = [method] + args
        val record = CallRecord(
            args: full_args,
            timestamp: 0,
            call_number: self.calls.len() as i32
        )
        var calls = self.calls
        calls.append(record)
        self.calls = calls
        self.call_count_value = self.call_count_value + 1

    fn get_calls(method: text) -> [CallRecord]:
        var result = []
        for call in self.calls:
            if call.args.len() > 0 and call.args[0] == method:
                result.append(call)
        result

    fn method_called(method: text) -> bool:
        for call in self.calls:
            if call.args.len() > 0 and call.args[0] == method:
                return true
        false

    fn method_call_count(method: text) -> i32:
        var count = 0
        for call in self.calls:
            if call.args.len() > 0 and call.args[0] == method:
                count = count + 1
        count

    fn total_calls() -> i32:
        self.call_count_value

    fn summary() -> text:
        var result = "Spy '{self.name}': {self.total_calls()} call(s)\n"
        for call in self.calls:
            result = result + "  {call.args}\n"
        result

# ============================================================================
# Tests
# ============================================================================

describe "Mock Library - Phase 3 (Advanced Features)":
    """
    Verifies advanced mocking features that enable sophisticated test scenarios.
    """
    context "Matcher Composition - AND":
        it "combines two matchers with AND logic":
            val m1 = Matcher.gt(5)
            val m2 = Matcher.lt(100)
            val combined = Matcher.and_matcher(m1, m2)
            expect combined.matches("50")
            expect combined.matches("10")
            expect not combined.matches("2")
            expect not combined.matches("150")

        it "AND fails if either matcher fails":
            val m1 = Matcher.contains("error")
            val m2 = Matcher.starts_with("WARN")
            val combined = Matcher.and_matcher(m1, m2)
            expect not combined.matches("error")
            expect not combined.matches("WARNING error")
            expect combined.matches("WARN error")

    context "Matcher Composition - OR":
        it "combines two matchers with OR logic":
            val m1 = Matcher.eq("user")
            val m2 = Matcher.eq("admin")
            val combined = Matcher.or_matcher(m1, m2)
            expect combined.matches("user")
            expect combined.matches("admin")
            expect not combined.matches("guest")

        it "OR succeeds if either matcher matches":
            val m1 = Matcher.contains("GET")
            val m2 = Matcher.contains("POST")
            val combined = Matcher.or_matcher(m1, m2)
            expect combined.matches("GET /users")
            expect combined.matches("POST /users")
            expect not combined.matches("DELETE /users")

    context "Matcher Composition - NOT":
        it "negates a matcher":
            val m = Matcher.eq("admin")
            val negated = Matcher.not_matcher(m)
            expect not negated.matches("admin")
            expect negated.matches("user")
            expect negated.matches("")

        it "NOT inverts boolean logic":
            val m = Matcher.contains("error")
            val negated = Matcher.not_matcher(m)
            expect not negated.matches("fatal error")
            expect negated.matches("success")

    context "Custom Predicate Matchers":
        it "creates matcher from custom predicate":
            val starts_digit = \s: s.len() > 0 and s[0] >= "0" and s[0] <= "9"
            val predicate_m = Matcher.predicate(starts_digit)
            expect predicate_m.matches("4abc")
            expect predicate_m.matches("100")
            expect not predicate_m.matches("abc")
            expect not predicate_m.matches("xyz")

        it "uses custom predicate for complex logic":
            val has_numbers = \s: s.contains("1") or s.contains("2") or s.contains("3")
            val pred_m = Matcher.predicate(has_numbers)
            expect pred_m.matches("user123")
            expect pred_m.matches("abc123")
            expect not pred_m.matches("xyz")

    context "CallAnalyzer - Call Counting":
        it "counts calls with specific arguments":
            val mock_fn = MockFunction.new("service")
            mock_fn.record_call(["save", "doc1"])
            mock_fn.record_call(["save", "doc1"])
            mock_fn.record_call(["save", "doc2"])
            val analyzer = CallAnalyzer.new(mock_fn)
            expect analyzer.count_calls_with(["save", "doc1"]) == 2
            expect analyzer.count_calls_with(["save", "doc2"]) == 1
            expect analyzer.count_calls_with(["delete"]) == 0

        it "returns zero for non-matching calls":
            val mock_fn = MockFunction.new("handler")
            mock_fn.record_call(["init"])
            mock_fn.record_call(["start"])
            val analyzer = CallAnalyzer.new(mock_fn)
            expect analyzer.count_calls_with(["stop"]) == 0
            expect analyzer.count_calls_with(["cleanup"]) == 0

    context "CallAnalyzer - Pattern Matching":
        it "gets first call made":
            val mock_fn = MockFunction.new("sequence")
            mock_fn.record_call(["first"])
            mock_fn.record_call(["second"])
            mock_fn.record_call(["third"])
            val analyzer = CallAnalyzer.new(mock_fn)
            val first = analyzer.get_first_call()
            expect first.is_some()
            match first:
                Some(call): expect call.args[0] == "first"
                None: fail "Should have first call"

        it "returns None if no calls made":
            val mock_fn = MockFunction.new("unused")
            val analyzer = CallAnalyzer.new(mock_fn)
            expect analyzer.get_first_call().is_none()

    context "CallAnalyzer - Call Range Queries":
        it "gets calls between indices":
            val mock_fn = MockFunction.new("api")
            mock_fn.record_call(["call0"])
            mock_fn.record_call(["call1"])
            mock_fn.record_call(["call2"])
            mock_fn.record_call(["call3"])
            mock_fn.record_call(["call4"])
            val analyzer = CallAnalyzer.new(mock_fn)
            val range = analyzer.get_calls_between(start_idx=1, end_idx=4)
            expect range.len() == 3
            expect range[0].args[0] == "call1"
            expect range[1].args[0] == "call2"
            expect range[2].args[0] == "call3"

        it "handles boundary indices":
            val mock_fn = MockFunction.new("bounded")
            mock_fn.record_call(["a"])
            mock_fn.record_call(["b"])
            mock_fn.record_call(["c"])
            val analyzer = CallAnalyzer.new(mock_fn)
            val range = analyzer.get_calls_between(start_idx=0, end_idx=3)
            expect range.len() == 3

    context "CallAnalyzer - Predicate Matching":
        it "gets calls matching custom predicate":
            val mock_fn = MockFunction.new("log")
            mock_fn.record_call(["INFO", "Started"])
            mock_fn.record_call(["ERROR", "Failed"])
            mock_fn.record_call(["INFO", "Completed"])
            val analyzer = CallAnalyzer.new(mock_fn)
            val has_error = \call:
                call.args.len() > 0 and call.args[0] == "ERROR"
            val errors = analyzer.get_calls_matching(has_error)
            expect errors.len() == 1
            expect errors[0].args[1] == "Failed"

        it "returns empty list if no matches":
            val mock_fn = MockFunction.new("checker")
            mock_fn.record_call(["safe"])
            mock_fn.record_call(["ok"])
            val analyzer = CallAnalyzer.new(mock_fn)
            val has_panic = \call:
                call.args.len() > 0 and call.args[0].contains("panic")
            val panics = analyzer.get_calls_matching(has_panic)
            expect panics.len() == 0

    context "SequentialReturns - Basic Usage":
        it "returns values in sequence":
            val seq = SequentialReturns.new()
            seq.add_return("first", 1)
            seq.add_return("second", 1)
            seq.add_return("third", 1)
            expect seq.next_value() == Some("first")
            expect seq.next_value() == Some("second")
            expect seq.next_value() == Some("third")
            expect seq.next_value().is_none()

        it "repeats values based on count":
            val seq = SequentialReturns.new()
            seq.add_return("value_a", 3)
            seq.add_return("value_b", 2)
            expect seq.next_value() == Some("value_a")
            expect seq.next_value() == Some("value_a")
            expect seq.next_value() == Some("value_a")
            expect seq.next_value() == Some("value_b")
            expect seq.next_value() == Some("value_b")
            expect seq.next_value().is_none()

    context "SequentialReturns - add_return_once":
        it "adds single return value":
            val seq = SequentialReturns.new()
            seq.add_return_once("only_once")
            expect seq.next_value() == Some("only_once")
            expect seq.next_value().is_none()

        it "chains multiple once calls":
            val seq = SequentialReturns.new()
            seq.add_return_once("alpha")
            seq.add_return_once("beta")
            seq.add_return_once("gamma")
            expect seq.next_value() == Some("alpha")
            expect seq.next_value() == Some("beta")
            expect seq.next_value() == Some("gamma")
            expect seq.next_value().is_none()

    context "SequentialReturns - Reset":
        it "resets to beginning":
            val seq = SequentialReturns.new()
            seq.add_return_once("first")
            seq.add_return_once("second")
            expect seq.next_value() == Some("first")
            expect seq.next_value() == Some("second")
            seq.reset()
            expect seq.next_value() == Some("first")
            expect seq.next_value() == Some("second")

    context "Spy - Basic Call Recording":
        it "records method calls":
            val spy = Spy.new("user_service")
            spy.record_call("get_user", ["id_123"])
            spy.record_call("save_user", ["id_456", "John"])
            expect spy.total_calls() == 2
            expect spy.method_called("get_user")
            expect spy.method_called("save_user")

        it "tracks method call count":
            val spy = Spy.new("cache")
            spy.record_call("get", ["key1"])
            spy.record_call("get", ["key2"])
            spy.record_call("get", ["key3"])
            spy.record_call("set", ["key", "value"])
            expect spy.method_call_count("get") == 3
            expect spy.method_call_count("set") == 1
            expect spy.method_call_count("delete") == 0

    context "Spy - Call Retrieval":
        it "gets all calls to a method":
            val spy = Spy.new("database")
            spy.record_call("query", ["SELECT", "users"])
            spy.record_call("query", ["SELECT", "posts"])
            spy.record_call("execute", ["INSERT"])
            val queries = spy.get_calls("query")
            expect queries.len() == 2
            expect queries[0].args[1] == "SELECT"
            expect queries[1].args[1] == "SELECT"

        it "returns empty list for untracked methods":
            val spy = Spy.new("logger")
            spy.record_call("info", ["message"])
            val debug_calls = spy.get_calls("debug")
            expect debug_calls.len() == 0

    context "Spy - Method Verification":
        it "verifies method was called":
            val spy = Spy.new("handler")
            spy.record_call("process", ["data"])
            expect spy.method_called("process")
            expect not spy.method_called("cleanup")

        it "tracks total calls across all methods":
            val spy = Spy.new("api")
            spy.record_call("GET", [])
            spy.record_call("POST", [])
            spy.record_call("PUT", [])
            spy.record_call("DELETE", [])
            expect spy.total_calls() == 4

    context "Spy - Summary":
        it "generates summary of calls":
            val spy = Spy.new("test_spy")
            spy.record_call("init", [])
            spy.record_call("process", ["data"])
            val summary = spy.summary()
            expect summary.contains("test_spy")
            expect summary.contains("2")

    context "Complex Scenarios":
        it "combines matcher composition with call analysis":
            val mock_fn = MockFunction.new("validator")
            mock_fn.record_call(["email@test.com"])
            mock_fn.record_call(["user123"])
            mock_fn.record_call(["admin@test.com"])
            val analyzer = CallAnalyzer.new(mock_fn)
            val has_email = \call:
                call.args.len() > 0 and call.args[0].contains("@")
            val emails = analyzer.get_calls_matching(has_email)
            expect emails.len() == 2
            val contains_test = Matcher.contains("test")
            expect contains_test.matches(emails[0].args[0])

        it "uses sequential returns with spy":
            val seq = SequentialReturns.new()
            seq.add_return("initialized", 1)
            seq.add_return("processing", 2)
            seq.add_return("completed", 1)
            val spy = Spy.new("workflow")
            spy.record_call("status", [])
            spy.record_call("status", [])
            spy.record_call("status", [])
            spy.record_call("status", [])
            expect spy.method_call_count("status") == 4
            expect spy.total_calls() == 4

        it "uses all three matcher composition types":
            val m_contains_error = Matcher.contains("error")
            val m_not_success = Matcher.not_matcher(Matcher.eq("success"))
            val m_combined = Matcher.and_matcher(m_contains_error, m_not_success)
            expect m_combined.matches("fatal error")
            expect not m_combined.matches("success")
            expect not m_combined.matches("no problem")
