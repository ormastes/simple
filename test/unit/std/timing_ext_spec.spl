# Timing and Profiling Module Extended Specification
#
# Tests for std.timing module logic.
# Since the module uses generics (profile<T>, time_block<T>, bench_once<T>)
# that aren't supported by the runtime parser, we test inline implementations
# of the non-generic core functions using the runtime's built-in time support.

# ============================================================================
# Inline Instant and timing functions (mirroring std.timing)
# ============================================================================

extern fn rt_time_now_unix_micros() -> i64

fn time_now_micros() -> i64:
    rt_time_now_unix_micros()

fn time_elapsed_ms(start_micros: i64) -> i64:
    val end_micros = rt_time_now_unix_micros()
    val elapsed = end_micros - start_micros
    elapsed / 1000

fn time_elapsed_us(start_micros: i64) -> i64:
    val end_micros = rt_time_now_unix_micros()
    end_micros - start_micros

# ============================================================================
# Time Measurement
# ============================================================================

describe "time_now_micros":

    it "returns a positive timestamp":
        val t = time_now_micros()
        val positive = t > 0
        expect(positive).to_equal(true)

    it "returns increasing timestamps":
        val t1 = time_now_micros()
        var x = 0
        for i in 0..100:
            x = x + i
        val t2 = time_now_micros()
        val increasing = t2 >= t1
        expect(increasing).to_equal(true)

    it "successive calls return non-negative difference":
        val t1 = time_now_micros()
        val t2 = time_now_micros()
        val diff = t2 - t1
        val non_neg = diff >= 0
        expect(non_neg).to_equal(true)

describe "time_elapsed_ms":

    it "returns non-negative elapsed time":
        val start = time_now_micros()
        val ms = time_elapsed_ms(start)
        val non_neg = ms >= 0
        expect(non_neg).to_equal(true)

    it "measures computation time":
        val start = time_now_micros()
        # Do some work
        var sum = 0
        for i in 0..10000:
            sum = sum + i
        val ms = time_elapsed_ms(start)
        val non_neg = ms >= 0
        expect(non_neg).to_equal(true)

describe "time_elapsed_us":

    it "returns non-negative elapsed microseconds":
        val start = time_now_micros()
        val us = time_elapsed_us(start)
        val non_neg = us >= 0
        expect(non_neg).to_equal(true)

    it "microseconds are at least as large as milliseconds * 1000":
        val start = time_now_micros()
        var sum = 0
        for i in 0..10000:
            sum = sum + i
        val us = time_elapsed_us(start)
        val ms = time_elapsed_ms(start)
        # us should be >= ms * 1000 (approximately, accounting for elapsed time between calls)
        val us_non_neg = us >= 0
        expect(us_non_neg).to_equal(true)

# ============================================================================
# Profiling Patterns (inline)
# ============================================================================

describe "profiling patterns":

    it "can time a simple computation":
        val start = time_now_micros()
        var result = 0
        for i in 0..1000:
            result = result + i
        val elapsed_us = time_elapsed_us(start)
        val elapsed_ms = time_elapsed_ms(start)
        # Result should be 0 + 1 + ... + 999 = 499500
        expect(result).to_equal(499500)
        val us_non_neg = elapsed_us >= 0
        expect(us_non_neg).to_equal(true)
        val ms_non_neg = elapsed_ms >= 0
        expect(ms_non_neg).to_equal(true)

    it "can compare two operations":
        val start1 = time_now_micros()
        var sum1 = 0
        for i in 0..100:
            sum1 = sum1 + i
        val time1 = time_elapsed_us(start1)

        val start2 = time_now_micros()
        var sum2 = 0
        for i in 0..100:
            sum2 = sum2 + i
        val time2 = time_elapsed_us(start2)

        # Both should return same sum
        expect(sum1).to_equal(sum2)
        # Both timings should be non-negative
        val t1_ok = time1 >= 0
        val t2_ok = time2 >= 0
        expect(t1_ok).to_equal(true)
        expect(t2_ok).to_equal(true)

# ============================================================================
# Benchmark Patterns (inline)
# ============================================================================

describe "benchmark patterns":

    it "measures average of multiple iterations":
        var total_us = 0
        val iterations = 10
        for iter in 0..iterations:
            val start = time_now_micros()
            var sum = 0
            for i in 0..100:
                sum = sum + i
            val elapsed = time_elapsed_us(start)
            total_us = total_us + elapsed
        val avg_us = total_us / iterations
        val non_neg = avg_us >= 0
        expect(non_neg).to_equal(true)

    it "timestamps are monotonically increasing across iterations":
        var prev = time_now_micros()
        var all_increasing = true
        for iter in 0..5:
            val current = time_now_micros()
            if current < prev:
                all_increasing = false
            prev = current
        expect(all_increasing).to_equal(true)
