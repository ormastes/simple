# Tests for std.platform module
# Covers platform detection, path separators, path utilities
# NOTE: Tests assume running on Linux (this system is Linux)

use std.platform.{is_windows, is_unix, is_macos, is_linux}
use std.platform.{get_host_os, get_host_arch}
use std.platform.{dir_sep, path_sep, exe_ext, lib_ext}
use std.platform.{normalize_path, is_absolute_path, join_path}

describe "std.platform":
    describe "platform detection":
        it "detects Linux":
            expect(is_linux()).to_equal(true)

        it "detects Unix":
            expect(is_unix()).to_equal(true)

        it "not Windows":
            expect(is_windows()).to_equal(false)

        it "get_host_os returns linux":
            expect(get_host_os()).to_equal("linux")

        it "get_host_arch returns valid architecture":
            val arch = get_host_arch()
            # Should be one of common architectures
            val is_known = arch == "x86_64" or arch == "aarch64" or arch == "i686" or arch == "riscv64"
            expect(is_known).to_equal(true)

    describe "path separators":
        it "dir_sep is forward slash on Linux":
            expect(dir_sep()).to_equal("/")

        it "path_sep is colon on Linux":
            expect(path_sep()).to_equal(":")

        it "exe_ext is empty on Linux":
            expect(exe_ext()).to_equal("")

        it "lib_ext is .so on Linux":
            expect(lib_ext()).to_equal(".so")

    describe "is_absolute_path":
        it "recognizes absolute Unix path":
            expect(is_absolute_path("/usr/bin")).to_equal(true)

        it "recognizes root path":
            expect(is_absolute_path("/")).to_equal(true)

        it "rejects relative path":
            expect(is_absolute_path("relative/path")).to_equal(false)

        it "rejects empty path":
            expect(is_absolute_path("")).to_equal(false)

        it "rejects dot path":
            expect(is_absolute_path("./foo")).to_equal(false)

    describe "join_path":
        it "joins with separator":
            expect(join_path("/usr", "bin")).to_equal("/usr/bin")

        it "handles trailing separator":
            expect(join_path("/usr/", "bin")).to_equal("/usr/bin")

        it "joins relative paths":
            expect(join_path("foo", "bar")).to_equal("foo/bar")

    describe "normalize_path":
        it "returns path unchanged on Linux":
            expect(normalize_path("/usr/bin")).to_equal("/usr/bin")

        it "preserves relative paths":
            expect(normalize_path("foo/bar")).to_equal("foo/bar")

    describe "resolve_command":
        # resolve_command returns cmd unchanged on Unix
        # So it's a simple passthrough test
        it "returns command unchanged on Unix":
            use std.platform.{resolve_command}
            expect(resolve_command("gcc")).to_equal("gcc")
