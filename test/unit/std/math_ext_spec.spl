# Math Module Extended Specification
#
# Comprehensive tests for std.math module functions imported directly.
# Unlike math_spec.spl (which uses inline helpers), this file tests the
# actual exported functions from src/std/math.spl.

use std.math.{MATH_PI, MATH_E, MATH_TAU, MATH_INF}
use std.math.{math_abs, math_abs_i64, math_min, math_max, math_min_i64, math_max_i64}
use std.math.{math_clamp, math_clamp_i64, math_sign, math_sign_i64}
use std.math.{math_lerp, math_is_close}
use std.math.{math_gcd, math_lcm, math_pow_i64, math_factorial}
use std.math.{math_to_radians, math_to_degrees}
use std.math.{abs_i64, min_i64, max_i64, clamp_i64, sign_i64}
use std.math.{pow_i64, gcd, lcm, factorial, binomial}
use std.math.{is_even, is_odd, is_divisible_by, in_range_i64}
use std.math.{sum_i64, product_i64, average_i64, median_i64}

# ============================================================================
# Constants
# ============================================================================

describe "Math constants":

    it "MATH_PI is approximately 3.14159":
        val close = math_is_close(MATH_PI, 3.14159, 0.001)
        expect(close).to_equal(true)

    it "MATH_E is approximately 2.71828":
        val close = math_is_close(MATH_E, 2.71828, 0.001)
        expect(close).to_equal(true)

    it "MATH_TAU is approximately 2 * PI":
        val double_pi = MATH_PI * 2.0
        val close = math_is_close(MATH_TAU, double_pi, 0.0001)
        expect(close).to_equal(true)

    it "MATH_INF is a very large number":
        val big = 1000000.0
        val result = MATH_INF > big
        expect(result).to_equal(true)

# ============================================================================
# Absolute Value
# ============================================================================

describe "math_abs (f64)":

    it "returns positive for negative input":
        val result = math_abs(-3.5)
        val close = math_is_close(result, 3.5, 0.001)
        expect(close).to_equal(true)

    it "returns same for positive input":
        val result = math_abs(7.2)
        val close = math_is_close(result, 7.2, 0.001)
        expect(close).to_equal(true)

    it "returns 0.0 for zero":
        val result = math_abs(0.0)
        val close = math_is_close(result, 0.0, 0.001)
        expect(close).to_equal(true)

describe "math_abs_i64":

    it "returns positive for negative input":
        expect(math_abs_i64(-42)).to_equal(42)

    it "returns same for positive input":
        expect(math_abs_i64(17)).to_equal(17)

    it "returns 0 for zero":
        expect(math_abs_i64(0)).to_equal(0)

    it "handles large negative":
        expect(math_abs_i64(-999999)).to_equal(999999)

# ============================================================================
# Min / Max (f64)
# ============================================================================

describe "math_min (f64)":

    it "returns smaller of two positive values":
        val result = math_min(3.0, 5.0)
        val close = math_is_close(result, 3.0, 0.001)
        expect(close).to_equal(true)

    it "returns negative when one is negative":
        val result = math_min(-2.0, 4.0)
        val close = math_is_close(result, -2.0, 0.001)
        expect(close).to_equal(true)

    it "returns the value when both are equal":
        val result = math_min(7.0, 7.0)
        val close = math_is_close(result, 7.0, 0.001)
        expect(close).to_equal(true)

describe "math_max (f64)":

    it "returns larger of two positive values":
        val result = math_max(3.0, 5.0)
        val close = math_is_close(result, 5.0, 0.001)
        expect(close).to_equal(true)

    it "returns positive when one is negative":
        val result = math_max(-2.0, 4.0)
        val close = math_is_close(result, 4.0, 0.001)
        expect(close).to_equal(true)

    it "returns the value when both are equal":
        val result = math_max(7.0, 7.0)
        val close = math_is_close(result, 7.0, 0.001)
        expect(close).to_equal(true)

# ============================================================================
# Min / Max (i64)
# ============================================================================

describe "math_min_i64":

    it "returns smaller value":
        expect(math_min_i64(3, 8)).to_equal(3)

    it "handles negatives":
        expect(math_min_i64(-10, 5)).to_equal(-10)

    it "handles equal values":
        expect(math_min_i64(4, 4)).to_equal(4)

describe "math_max_i64":

    it "returns larger value":
        expect(math_max_i64(3, 8)).to_equal(8)

    it "handles negatives":
        expect(math_max_i64(-10, 5)).to_equal(5)

    it "handles equal values":
        expect(math_max_i64(4, 4)).to_equal(4)

# ============================================================================
# Clamp
# ============================================================================

describe "math_clamp (f64)":

    it "returns value when within range":
        val result = math_clamp(5.0, 0.0, 10.0)
        val close = math_is_close(result, 5.0, 0.001)
        expect(close).to_equal(true)

    it "returns min when below range":
        val result = math_clamp(-3.0, 0.0, 10.0)
        val close = math_is_close(result, 0.0, 0.001)
        expect(close).to_equal(true)

    it "returns max when above range":
        val result = math_clamp(15.0, 0.0, 10.0)
        val close = math_is_close(result, 10.0, 0.001)
        expect(close).to_equal(true)

describe "math_clamp_i64":

    it "returns value when within range":
        expect(math_clamp_i64(5, 0, 10)).to_equal(5)

    it "returns min when below range":
        expect(math_clamp_i64(-3, 0, 10)).to_equal(0)

    it "returns max when above range":
        expect(math_clamp_i64(15, 0, 10)).to_equal(10)

    it "handles boundary values":
        expect(math_clamp_i64(0, 0, 10)).to_equal(0)
        expect(math_clamp_i64(10, 0, 10)).to_equal(10)

# ============================================================================
# Sign
# ============================================================================

describe "math_sign (f64)":

    it "returns -1.0 for negative":
        val result = math_sign(-7.5)
        val close = math_is_close(result, -1.0, 0.001)
        expect(close).to_equal(true)

    it "returns 1.0 for positive":
        val result = math_sign(3.2)
        val close = math_is_close(result, 1.0, 0.001)
        expect(close).to_equal(true)

    it "returns 0.0 for zero":
        val result = math_sign(0.0)
        val close = math_is_close(result, 0.0, 0.001)
        expect(close).to_equal(true)

describe "math_sign_i64":

    it "returns -1 for negative":
        expect(math_sign_i64(-42)).to_equal(-1)

    it "returns 1 for positive":
        expect(math_sign_i64(99)).to_equal(1)

    it "returns 0 for zero":
        expect(math_sign_i64(0)).to_equal(0)

# ============================================================================
# Linear Interpolation
# ============================================================================

describe "math_lerp":

    it "returns a when t=0":
        val result = math_lerp(10.0, 20.0, 0.0)
        val close = math_is_close(result, 10.0, 0.001)
        expect(close).to_equal(true)

    it "returns b when t=1":
        val result = math_lerp(10.0, 20.0, 1.0)
        val close = math_is_close(result, 20.0, 0.001)
        expect(close).to_equal(true)

    it "returns midpoint when t=0.5":
        val result = math_lerp(10.0, 20.0, 0.5)
        val close = math_is_close(result, 15.0, 0.001)
        expect(close).to_equal(true)

    it "handles t=0.25":
        val result = math_lerp(0.0, 100.0, 0.25)
        val close = math_is_close(result, 25.0, 0.001)
        expect(close).to_equal(true)

# ============================================================================
# Approximate Equality
# ============================================================================

describe "math_is_close":

    it "returns true for identical values":
        val result = math_is_close(5.0, 5.0, 0.01)
        expect(result).to_equal(true)

    it "returns true for values within tolerance":
        val result = math_is_close(5.0, 5.005, 0.01)
        expect(result).to_equal(true)

    it "returns false for values outside tolerance":
        val result = math_is_close(5.0, 6.0, 0.01)
        expect(result).to_equal(false)

    it "handles negative differences":
        val result = math_is_close(3.0, 2.999, 0.01)
        expect(result).to_equal(true)

# ============================================================================
# GCD
# ============================================================================

describe "math_gcd":

    it "computes gcd of 12 and 8":
        expect(math_gcd(12, 8)).to_equal(4)

    it "computes gcd of coprime numbers":
        expect(math_gcd(7, 13)).to_equal(1)

    it "handles zero argument":
        expect(math_gcd(5, 0)).to_equal(5)
        expect(math_gcd(0, 5)).to_equal(5)

    it "handles negative arguments":
        expect(math_gcd(-12, 8)).to_equal(4)
        expect(math_gcd(12, -8)).to_equal(4)

    it "computes gcd of equal values":
        expect(math_gcd(6, 6)).to_equal(6)

# ============================================================================
# LCM
# ============================================================================

describe "math_lcm":

    it "computes lcm of 4 and 6":
        expect(math_lcm(4, 6)).to_equal(12)

    it "computes lcm of coprime numbers":
        expect(math_lcm(3, 5)).to_equal(15)

    it "returns 0 when either argument is zero":
        expect(math_lcm(0, 5)).to_equal(0)
        expect(math_lcm(5, 0)).to_equal(0)

    it "computes lcm of 7 and 3":
        expect(math_lcm(7, 3)).to_equal(21)

# ============================================================================
# Integer Power
# ============================================================================

describe "math_pow_i64":

    it "computes 2^10":
        expect(math_pow_i64(2, 10)).to_equal(1024)

    it "computes 3^5":
        expect(math_pow_i64(3, 5)).to_equal(243)

    it "returns 1 for exponent 0":
        expect(math_pow_i64(99, 0)).to_equal(1)

    it "returns 0 for negative exponent":
        expect(math_pow_i64(2, -1)).to_equal(0)

    it "computes 1^large":
        expect(math_pow_i64(1, 1000)).to_equal(1)

    it "computes 5^3":
        expect(math_pow_i64(5, 3)).to_equal(125)

# ============================================================================
# Factorial
# ============================================================================

describe "math_factorial":

    it "computes 0! = 1":
        expect(math_factorial(0)).to_equal(1)

    it "computes 1! = 1":
        expect(math_factorial(1)).to_equal(1)

    it "computes 5! = 120":
        expect(math_factorial(5)).to_equal(120)

    it "computes 10! = 3628800":
        expect(math_factorial(10)).to_equal(3628800)

    it "returns 1 for negative input":
        expect(math_factorial(-5)).to_equal(1)

# ============================================================================
# Degree/Radian Conversion
# ============================================================================

describe "math_to_radians":

    it "converts 0 degrees to 0 radians":
        val result = math_to_radians(0.0)
        val close = math_is_close(result, 0.0, 0.001)
        expect(close).to_equal(true)

    it "converts 180 degrees to PI radians":
        val result = math_to_radians(180.0)
        val close = math_is_close(result, MATH_PI, 0.001)
        expect(close).to_equal(true)

    it "converts 360 degrees to TAU radians":
        val result = math_to_radians(360.0)
        val close = math_is_close(result, MATH_TAU, 0.001)
        expect(close).to_equal(true)

    it "converts 90 degrees to PI/2 radians":
        val result = math_to_radians(90.0)
        val expected = MATH_PI / 2.0
        val close = math_is_close(result, expected, 0.001)
        expect(close).to_equal(true)

describe "math_to_degrees":

    it "converts 0 radians to 0 degrees":
        val result = math_to_degrees(0.0)
        val close = math_is_close(result, 0.0, 0.001)
        expect(close).to_equal(true)

    it "converts PI radians to 180 degrees":
        val result = math_to_degrees(MATH_PI)
        val close = math_is_close(result, 180.0, 0.001)
        expect(close).to_equal(true)

    it "converts TAU radians to 360 degrees":
        val result = math_to_degrees(MATH_TAU)
        val close = math_is_close(result, 360.0, 0.001)
        expect(close).to_equal(true)

    it "round-trips degrees through radians":
        val original = 45.0
        val rad = math_to_radians(original)
        val deg = math_to_degrees(rad)
        val close = math_is_close(deg, original, 0.001)
        expect(close).to_equal(true)

# ============================================================================
# Convenience Aliases
# ============================================================================

describe "abs_i64 (alias)":

    it "returns positive for negative input":
        expect(abs_i64(-15)).to_equal(15)

    it "returns same for positive input":
        expect(abs_i64(15)).to_equal(15)

    it "returns 0 for zero":
        expect(abs_i64(0)).to_equal(0)

describe "min_i64 (alias)":

    it "returns smaller value":
        expect(min_i64(2, 9)).to_equal(2)

    it "handles negatives":
        expect(min_i64(-5, -1)).to_equal(-5)

describe "max_i64 (alias)":

    it "returns larger value":
        expect(max_i64(2, 9)).to_equal(9)

    it "handles negatives":
        expect(max_i64(-5, -1)).to_equal(-1)

describe "clamp_i64 (alias)":

    it "clamps within range":
        expect(clamp_i64(5, 0, 10)).to_equal(5)

    it "clamps below minimum":
        expect(clamp_i64(-5, 0, 10)).to_equal(0)

    it "clamps above maximum":
        expect(clamp_i64(20, 0, 10)).to_equal(10)

describe "sign_i64 (alias)":

    it "returns -1 for negative":
        expect(sign_i64(-3)).to_equal(-1)

    it "returns 1 for positive":
        expect(sign_i64(3)).to_equal(1)

    it "returns 0 for zero":
        expect(sign_i64(0)).to_equal(0)

describe "pow_i64 (alias)":

    it "computes 2^8 = 256":
        expect(pow_i64(2, 8)).to_equal(256)

    it "computes 10^3 = 1000":
        expect(pow_i64(10, 3)).to_equal(1000)

    it "handles exponent 0":
        expect(pow_i64(42, 0)).to_equal(1)

describe "gcd (alias)":

    it "computes gcd of 18 and 12":
        expect(gcd(18, 12)).to_equal(6)

    it "computes gcd of 100 and 75":
        expect(gcd(100, 75)).to_equal(25)

describe "lcm (alias)":

    it "computes lcm of 6 and 8":
        expect(lcm(6, 8)).to_equal(24)

    it "computes lcm of 12 and 15":
        expect(lcm(12, 15)).to_equal(60)

describe "factorial (alias)":

    it "computes 7! = 5040":
        expect(factorial(7)).to_equal(5040)

    it "computes 3! = 6":
        expect(factorial(3)).to_equal(6)

# ============================================================================
# Binomial Coefficient
# ============================================================================

describe "binomial":

    it "computes C(5, 2) = 10":
        expect(binomial(5, 2)).to_equal(10)

    it "computes C(10, 3) = 120":
        expect(binomial(10, 3)).to_equal(120)

    it "returns 1 when k=0":
        expect(binomial(10, 0)).to_equal(1)

    it "returns 1 when k=n":
        expect(binomial(5, 5)).to_equal(1)

    it "returns 0 when k > n":
        expect(binomial(3, 5)).to_equal(0)

    it "computes C(6, 1) = 6":
        expect(binomial(6, 1)).to_equal(6)

    it "computes C(4, 2) = 6":
        expect(binomial(4, 2)).to_equal(6)

# ============================================================================
# Integer Predicates
# ============================================================================

describe "is_even":

    it "returns true for even numbers":
        expect(is_even(0)).to_equal(true)
        expect(is_even(2)).to_equal(true)
        expect(is_even(100)).to_equal(true)

    it "returns false for odd numbers":
        expect(is_even(1)).to_equal(false)
        expect(is_even(3)).to_equal(false)
        expect(is_even(99)).to_equal(false)

    it "handles negative even numbers":
        expect(is_even(-4)).to_equal(true)

    it "handles negative odd numbers":
        expect(is_even(-3)).to_equal(false)

describe "is_odd":

    it "returns true for odd numbers":
        expect(is_odd(1)).to_equal(true)
        expect(is_odd(3)).to_equal(true)
        expect(is_odd(99)).to_equal(true)

    it "returns false for even numbers":
        expect(is_odd(0)).to_equal(false)
        expect(is_odd(2)).to_equal(false)
        expect(is_odd(100)).to_equal(false)

    it "handles negative odd numbers":
        expect(is_odd(-3)).to_equal(true)

    it "handles negative even numbers":
        expect(is_odd(-4)).to_equal(false)

describe "is_divisible_by":

    it "returns true for divisible values":
        expect(is_divisible_by(10, 5)).to_equal(true)
        expect(is_divisible_by(12, 3)).to_equal(true)
        expect(is_divisible_by(100, 10)).to_equal(true)

    it "returns false for non-divisible values":
        expect(is_divisible_by(10, 3)).to_equal(false)
        expect(is_divisible_by(7, 2)).to_equal(false)

    it "returns false when divisor is zero":
        expect(is_divisible_by(10, 0)).to_equal(false)

    it "every number is divisible by 1":
        expect(is_divisible_by(42, 1)).to_equal(true)
        expect(is_divisible_by(0, 1)).to_equal(true)

describe "in_range_i64":

    it "returns true when value is within range":
        expect(in_range_i64(5, 0, 10)).to_equal(true)

    it "returns true at boundaries":
        expect(in_range_i64(0, 0, 10)).to_equal(true)
        expect(in_range_i64(10, 0, 10)).to_equal(true)

    it "returns false below range":
        expect(in_range_i64(-1, 0, 10)).to_equal(false)

    it "returns false above range":
        expect(in_range_i64(11, 0, 10)).to_equal(false)

    it "works with negative ranges":
        expect(in_range_i64(-5, -10, -1)).to_equal(true)
        expect(in_range_i64(0, -10, -1)).to_equal(false)

# ============================================================================
# Statistical Functions
# ============================================================================

describe "sum_i64":

    it "sums a list of positive numbers":
        expect(sum_i64([1, 2, 3, 4, 5])).to_equal(15)

    it "sums an empty list to 0":
        expect(sum_i64([])).to_equal(0)

    it "sums a single-element list":
        expect(sum_i64([42])).to_equal(42)

    it "handles negative numbers":
        expect(sum_i64([-1, -2, -3])).to_equal(-6)

    it "handles mixed positive and negative":
        expect(sum_i64([10, -3, 5, -2])).to_equal(10)

describe "product_i64":

    it "multiplies a list of numbers":
        expect(product_i64([1, 2, 3, 4])).to_equal(24)

    it "returns 1 for empty list":
        expect(product_i64([])).to_equal(1)

    it "handles single-element list":
        expect(product_i64([7])).to_equal(7)

    it "handles a zero in the list":
        expect(product_i64([5, 0, 3])).to_equal(0)

    it "handles negative numbers":
        expect(product_i64([-2, 3])).to_equal(-6)

describe "average_i64":

    it "computes average of a list":
        val result = average_i64([2, 4, 6])
        expect(result).to_equal(4)

    it "returns nil for empty list":
        val result = average_i64([])
        expect(result).to_be_nil()

    it "computes average of single element":
        val result = average_i64([10])
        expect(result).to_equal(10)

    it "truncates toward zero for integer division":
        # [1, 2] -> sum=3, len=2, 3/2 = 1 (integer division)
        val result = average_i64([1, 2])
        expect(result).to_equal(1)

describe "median_i64":

    it "computes median of odd-length list":
        val result = median_i64([3, 1, 2])
        expect(result).to_equal(2)

    it "computes median of even-length list":
        # [1, 2, 3, 4] -> (2 + 3) / 2 = 2 (integer division)
        val result = median_i64([4, 1, 3, 2])
        expect(result).to_equal(2)

    it "returns nil for empty list":
        val result = median_i64([])
        expect(result).to_be_nil()

    it "computes median of single element":
        val result = median_i64([42])
        expect(result).to_equal(42)

    it "computes median of sorted list":
        val result = median_i64([10, 20, 30, 40, 50])
        expect(result).to_equal(30)

    it "handles duplicate values":
        val result = median_i64([5, 5, 5])
        expect(result).to_equal(5)
