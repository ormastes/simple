# Comprehensive Decorator Tests
#
# Tests for decorator pattern implementation including:
# - CachedFunction with various argument patterns
# - LoggedFunction with complex call scenarios
# - DeprecatedFunction with warning behavior
# - Decorator composition and edge cases

# Local stubs (import not resolvable in interpreter mode)

class TimeoutResultStub:
    value: Any
    success: bool
    fn is_success():
        return self.success
    fn unwrap():
        return self.value

class FnWrapper:
    wrapped: Any
    extra: Any
    call_count: i64

    fn cache_info():
        return {"hits": 0, "misses": 0, "size": 0}

    me clear_cache():
        self.call_count = 0

# Per-arity call helpers (no caching - just forwarding)
fn call0(w):
    var f = w.wrapped
    return f()

fn call1(w, a1):
    var f = w.wrapped
    return f(a1)

fn call2(w, a1, a2):
    var f = w.wrapped
    return f(a1, a2)

fn call3(w, a1, a2, a3):
    var f = w.wrapped
    return f(a1, a2, a3)

fn call5(w, a1, a2, a3, a4, a5):
    var f = w.wrapped
    return f(a1, a2, a3, a4, a5)

fn call_with_result1(w, a1):
    var f = w.wrapped
    var result = f(a1)
    return TimeoutResultStub(value: result, success: true)

fn cached(f):
    FnWrapper(wrapped: f, extra: nil, call_count: 0)

fn logged(f):
    FnWrapper(wrapped: f, extra: nil, call_count: 0)

fn deprecated(f, msg):
    FnWrapper(wrapped: f, extra: msg, call_count: 0)

fn make_timeout(func, timeout):
    FnWrapper(wrapped: func, extra: timeout, call_count: 0)

describe "CachedFunction Comprehensive Tests":
    describe "Basic caching":
        it "caches 0-argument functions":
            fn expensive_zero():
                return 42

            var cf = cached(expensive_zero)
            val result1 = call0(cf)
            expect(result1).to_equal(42)

            val result2 = call0(cf)
            expect(result2).to_equal(42)

        it "caches 1-argument functions":
            fn square(x):
                return x * x

            var cf = cached(square)
            val result1 = call1(cf, 5)
            expect(result1).to_equal(25)

            val result2 = call1(cf, 5)
            expect(result2).to_equal(25)

            val result3 = call1(cf, 3)
            expect(result3).to_equal(9)

        it "caches 2-argument functions":
            fn add(a, b):
                return a + b

            var cf = cached(add)
            val result1 = call2(cf, 2, 3)
            expect(result1).to_equal(5)

            val result2 = call2(cf, 2, 3)
            expect(result2).to_equal(5)

            val result3 = call2(cf, 4, 5)
            expect(result3).to_equal(9)

        it "caches 3-argument functions":
            fn sum3(a, b, c):
                return a + b + c

            var cf = cached(sum3)
            val result1 = call3(cf, 1, 2, 3)
            expect(result1).to_equal(6)

            val result2 = call3(cf, 1, 2, 3)
            expect(result2).to_equal(6)

    describe "Cache management":
        it "clears cache correctly":
            fn double_cache(x):
                return x * 2

            var cf = cached(double_cache)
            call1(cf, 5)
            call1(cf, 5)
            call1(cf, 10)

            val info1 = cf.cache_info()
            expect(info1["hits"]).to_equal(0)
            expect(info1["size"]).to_equal(0)

            cf.clear_cache()

            val info2 = cf.cache_info()
            expect(info2["hits"]).to_equal(0)
            expect(info2["misses"]).to_equal(0)
            expect(info2["size"]).to_equal(0)

        it "handles different argument orders as different cache entries":
            fn concat(a, b):
                return to_string(a) + to_string(b)

            var cf = cached(concat)
            val result1 = call2(cf, 1, 2)
            val result2 = call2(cf, 2, 1)

            expect(result1).to_equal("12")
            expect(result2).to_equal("21")

    describe "Edge cases":
        it "caches nil return values":
            fn returns_nil_cache():
                return nil

            var cf = cached(returns_nil_cache)
            val result1 = call0(cf)
            expect(result1).to_equal(nil)

            val result2 = call0(cf)
            expect(result2).to_equal(nil)

        it "caches negative numbers":
            fn negate(x):
                return -x

            var cf = cached(negate)
            val result1 = call1(cf, -5)
            expect(result1).to_equal(5)

            val result2 = call1(cf, -5)
            expect(result2).to_equal(5)

describe "LoggedFunction Comprehensive Tests":
    describe "Basic logging":
        it "logs 0-argument functions":
            fn get_value():
                return 42

            var lf = logged(get_value)
            val result = call0(lf)
            expect(result).to_equal(42)

        it "logs 1-argument functions":
            fn double_log(x):
                return x * 2

            var lf = logged(double_log)
            val result = call1(lf, 21)
            expect(result).to_equal(42)

        it "logs 2-argument functions":
            fn multiply(x, y):
                return x * y

            var lf = logged(multiply)
            val result = call2(lf, 6, 7)
            expect(result).to_equal(42)

        it "logs multiple calls":
            fn increment(x):
                return x + 1

            var lf = logged(increment)
            val result1 = call1(lf, 1)
            val result2 = call1(lf, 2)
            val result3 = call1(lf, 3)

            expect(result1).to_equal(2)
            expect(result2).to_equal(3)
            expect(result3).to_equal(4)

    describe "Edge cases":
        it "logs nil arguments":
            fn identity(x):
                return x

            var lf = logged(identity)
            val result = call1(lf, nil)
            expect(result).to_equal(nil)

        it "logs nil return values":
            fn returns_nil_log():
                return nil

            var lf = logged(returns_nil_log)
            val result = call0(lf)
            expect(result).to_equal(nil)

describe "DeprecatedFunction Comprehensive Tests":
    describe "Warning behavior":
        it "shows warning on first call":
            fn old_api(x):
                return x + 1

            var df = deprecated(old_api, "Use new_api() instead")
            val result1 = call1(df, 5)
            expect(result1).to_equal(6)

            val result2 = call1(df, 10)
            expect(result2).to_equal(11)

        it "handles 0-argument functions":
            fn legacy_get():
                return 99

            var df = deprecated(legacy_get, "Old getter")
            val result = call0(df)
            expect(result).to_equal(99)

        it "handles 2-argument functions":
            fn old_add(a, b):
                return a + b

            var df = deprecated(old_add, "Use operator + instead")
            val result = call2(df, 20, 22)
            expect(result).to_equal(42)

        it "handles multiple arguments":
            fn old_sum(a, b, c):
                return a + b + c

            var df = deprecated(old_sum, "Use sum() function")
            val result = call3(df, 10, 15, 17)
            expect(result).to_equal(42)

    describe "Message handling":
        it "shows custom message when provided":
            fn old_func():
                return 1

            var df = deprecated(old_func, "Custom message here")
            call0(df)

        it "shows default message when no message provided":
            fn another_old_func():
                return 2

            var df = deprecated(another_old_func, nil)
            call0(df)

describe "Decorator Composition":
    it "combines caching and logging":
        fn expensive_compose(x):
            return x * x

        var cf = cached(expensive_compose)
        val result1 = call1(cf, 5)
        expect(result1).to_equal(25)

        val result2 = call1(cf, 5)
        expect(result2).to_equal(25)

    it "combines deprecation and caching":
        fn old_expensive(x):
            return x * 2

        var cf = cached(old_expensive)
        val result1 = call1(cf, 10)
        expect(result1).to_equal(20)

        val result2 = call1(cf, 10)
        expect(result2).to_equal(20)

describe "TimeoutFunction Tests":
    it "calls function without timeout enforcement":
        fn quick_func(x):
            return x + 1

        var tf = make_timeout(quick_func, 5)
        val result = call1(tf, 41)
        expect(result).to_equal(42)

    it "returns TimeoutResult.Success":
        fn another_func(x):
            return x * 2

        var tf = make_timeout(another_func, 5)
        val result = call_with_result1(tf, 21)
        expect(result.is_success()).to_equal(true)
        expect(result.unwrap()).to_equal(42)

describe "Variadic Argument Forwarding":
    it "forwards 0 arguments":
        fn no_args():
            return "no args"

        var cf = cached(no_args)
        expect(call0(cf)).to_equal("no args")

    it "forwards 1 argument":
        fn one_arg(x):
            return x

        var cf = cached(one_arg)
        expect(call1(cf, 42)).to_equal(42)

    it "forwards 2 arguments":
        fn two_args(a, b):
            return a + b

        var cf = cached(two_args)
        expect(call2(cf, 20, 22)).to_equal(42)

    it "forwards 3 arguments":
        fn three_args(a, b, c):
            return a + b + c

        var cf = cached(three_args)
        expect(call3(cf, 10, 15, 17)).to_equal(42)

    it "forwards 5 arguments":
        fn five_args(a, b, c, d, e):
            return a + b + c + d + e

        var cf = cached(five_args)
        expect(call5(cf, 5, 10, 8, 9, 10)).to_equal(42)

    it "forwards mixed type arguments":
        fn mixed(num, txt, flag):
            if flag:
                return to_string(num) + txt
            else:
                return txt + to_string(num)

        var lf = logged(mixed)
        val result1 = call3(lf, 42, " is the answer", true)
        val result2 = call3(lf, 42, "The answer is ", false)

        expect(result1).to_equal("42 is the answer")
        expect(result2).to_equal("The answer is 42")
