# Mock Phase 7 Specification - Advanced Scheduling
# Feature IDs: Testing Infrastructure - Advanced Scheduling
# Category: Testing
# Status: Phase 7 (Advanced Scheduling)

# Advanced Scheduling Test Suite - Phase 7
#
# Tests the scheduling and concurrency control utilities in the mocking library:
# - TaskScheduler for priority-based task execution (Critical, High, Normal, Low, Background)
# - RetryPolicy for configuring retry behavior with linear/exponential backoff
# - RateLimiter for controlling request throughput (per-second, per-minute)
# - TimeoutController for tracking operation timeouts
# - ExecutionOrderTracker for verifying task execution sequences
# - ConcurrencyController for limiting parallel execution
# - Debouncer for coalescing rapid calls into single executions
# - Throttler for rate-limiting function invocations

# ============================================================================
# Local Type Definitions (workaround for module import limitation)
# ============================================================================

enum TaskPriority:
    Critical
    High
    Normal
    Low
    Background

struct ScheduledTask:
    id: i32
    name: text
    priority: TaskPriority
    delay_ms: i32
    executed: bool
    execution_time: i32
    result: Option<text>

class TaskScheduler:
    tasks: [ScheduledTask]
    next_id: i32
    current_time: i32
    executed_order: [i32]

    static fn new() -> TaskScheduler:
        TaskScheduler(
            tasks: [],
            next_id: 0,
            current_time: 0,
            executed_order: []
        )

    me schedule(name: text, priority: TaskPriority, delay_ms: i32) -> i32:
        val id = self.next_id
        self.next_id = self.next_id + 1
        val task = ScheduledTask(
            id: id,
            name: name,
            priority: priority,
            delay_ms: delay_ms,
            executed: false,
            execution_time: 0,
            result: nil
        )
        var tasks = self.tasks
        tasks.append(task)
        self.tasks = tasks
        id

    me schedule_immediate(name: text) -> i32:
        self.schedule(name, TaskPriority.High, 0)

    me schedule_delayed(name: text, delay_ms: i32) -> i32:
        self.schedule(name, TaskPriority.Normal, delay_ms)

    me schedule_background(name: text, delay_ms: i32) -> i32:
        self.schedule(name, TaskPriority.Background, delay_ms)

    fn get_priority_value(priority: TaskPriority) -> i32:
        match priority:
            case Critical: 0
            case High: 1
            case Normal: 2
            case Low: 3
            case Background: 4

    me execute_next() -> Option<ScheduledTask>:
        var best_name = ""
        var best_priority = 999
        var best_delay = 999999
        var best_id = -1
        var found = false
        for task in self.tasks:
            if not task.executed:
                val priority_val = self.get_priority_value(task.priority)
                if priority_val < best_priority:
                    best_priority = priority_val
                    best_name = task.name
                    best_delay = task.delay_ms
                    best_id = task.id
                    found = true
                else if priority_val == best_priority:
                    if task.delay_ms < best_delay:
                        best_name = task.name
                        best_delay = task.delay_ms
                        best_id = task.id
                        found = true
        if not found:
            return nil
        var new_tasks: [ScheduledTask] = []
        var executed_task: Option<ScheduledTask> = nil
        for task in self.tasks:
            if task.id == best_id and not task.executed and executed_task.is_none():
                val updated_task = ScheduledTask(
                    id: task.id,
                    name: task.name,
                    priority: task.priority,
                    delay_ms: task.delay_ms,
                    executed: true,
                    execution_time: self.current_time,
                    result: task.result
                )
                new_tasks.append(updated_task)
                executed_task = Some(updated_task)
            else:
                new_tasks.append(task)
        self.tasks = new_tasks
        match executed_task:
            Some(et):
                self.current_time = self.current_time + et.delay_ms
                var executed_order = self.executed_order
                executed_order.append(et.id)
                self.executed_order = executed_order
                Some(et)
            nil: nil

    me execute_all():
        var remaining = self.get_pending_count()
        while remaining > 0:
            self.execute_next()
            remaining = self.get_pending_count()

    fn get_executed_order() -> [i32]:
        self.executed_order

    fn get_pending_count() -> i32:
        var count = 0
        for task in self.tasks:
            if not task.executed:
                count = count + 1
        count

    fn get_task(id: i32) -> Option<ScheduledTask>:
        for task in self.tasks:
            if task.id == id:
                return Some(task)
        nil

    fn verify_execution_order(expected: [i32]) -> bool:
        if self.executed_order.len() != expected.len():
            return false
        for i in 0..expected.len():
            if self.executed_order[i] != expected[i]:
                return false
        true

    me reset():
        self.tasks = []
        self.next_id = 0
        self.current_time = 0
        self.executed_order = []

enum BackoffStrategy:
    NoBackoff
    Linear
    Exponential
    Fixed

struct RetryAttempt:
    attempt_number: i32
    delay_ms: i32
    success: bool
    error: Option<text>

class RetryPolicy:
    max_attempts: i32
    base_delay_ms: i32
    max_delay_ms: i32
    backoff: BackoffStrategy
    attempts: [RetryAttempt]

    static fn new(max_attempts: i32) -> RetryPolicy:
        RetryPolicy(
            max_attempts: max_attempts,
            base_delay_ms: 100,
            max_delay_ms: 5000,
            backoff: BackoffStrategy.Exponential,
            attempts: []
        )

    static fn no_retry() -> RetryPolicy:
        RetryPolicy(
            max_attempts: 1,
            base_delay_ms: 0,
            max_delay_ms: 0,
            backoff: BackoffStrategy.NoBackoff,
            attempts: []
        )

    static fn with_linear_backoff(max_attempts: i32, delay_ms: i32) -> RetryPolicy:
        RetryPolicy(
            max_attempts: max_attempts,
            base_delay_ms: delay_ms,
            max_delay_ms: delay_ms * max_attempts,
            backoff: BackoffStrategy.Linear,
            attempts: []
        )

    static fn with_exponential_backoff(max_attempts: i32, base_delay_ms: i32) -> RetryPolicy:
        RetryPolicy(
            max_attempts: max_attempts,
            base_delay_ms: base_delay_ms,
            max_delay_ms: base_delay_ms * 32,
            backoff: BackoffStrategy.Exponential,
            attempts: []
        )

    me set_max_delay(max_ms: i32):
        self.max_delay_ms = max_ms

    fn calculate_delay(attempt: i32) -> i32:
        var delay = 0
        match self.backoff:
            case NoBackoff: delay = 0
            case Fixed: delay = self.base_delay_ms
            case Linear: delay = self.base_delay_ms * attempt
            case Exponential:
                var result = self.base_delay_ms
                for i in 1..attempt:
                    result = result * 2
                delay = result
        if delay > self.max_delay_ms:
            return self.max_delay_ms
        delay

    me record_attempt(success: bool, error: Option<text>):
        val attempt_num = self.attempts.len() as i32 + 1
        val delay = self.calculate_delay(attempt_num)
        val attempt = RetryAttempt(
            attempt_number: attempt_num,
            delay_ms: delay,
            success: success,
            error: error
        )
        var attempts = self.attempts
        attempts.append(attempt)
        self.attempts = attempts

    fn should_retry() -> bool:
        if self.attempts.len() == 0:
            return true
        if self.attempts.len() as i32 >= self.max_attempts:
            return false
        val last = self.attempts[self.attempts.len() - 1]
        not last.success

    fn get_attempt_count() -> i32:
        self.attempts.len() as i32

    fn get_total_delay() -> i32:
        var total = 0
        for attempt in self.attempts:
            total = total + attempt.delay_ms
        total

    fn was_successful() -> bool:
        if self.attempts.len() == 0:
            return false
        self.attempts[self.attempts.len() - 1].success

    me reset():
        self.attempts = []

class RateLimiter:
    max_requests: i32
    window_ms: i32
    requests: [i32]
    current_time: i32

    static fn new(max_requests: i32, window_ms: i32) -> RateLimiter:
        RateLimiter(
            max_requests: max_requests,
            window_ms: window_ms,
            requests: [],
            current_time: 0
        )

    static fn per_second(max_requests: i32) -> RateLimiter:
        RateLimiter.new(max_requests, 1000)

    static fn per_minute(max_requests: i32) -> RateLimiter:
        RateLimiter.new(max_requests, 60000)

    me advance_time(ms: i32):
        self.current_time = self.current_time + ms
        val window_start = self.current_time - self.window_ms
        var new_requests: [i32] = []
        for req_time in self.requests:
            if req_time >= window_start:
                new_requests.append(req_time)
        self.requests = new_requests

    fn can_proceed() -> bool:
        (self.requests.len() as i32) < self.max_requests

    me try_acquire() -> bool:
        if not self.can_proceed():
            return false
        var requests = self.requests
        requests.append(self.current_time)
        self.requests = requests
        true

    fn get_wait_time() -> i32:
        if self.can_proceed():
            return 0
        if self.requests.len() == 0:
            return 0
        val oldest = self.requests[0]
        val wait = (oldest + self.window_ms) - self.current_time
        if wait > 0:
            wait
        else:
            0

    fn get_remaining_requests() -> i32:
        self.max_requests - (self.requests.len() as i32)

    me reset():
        self.requests = []
        self.current_time = 0

struct TimeoutResult:
    completed: bool
    timed_out: bool
    duration_ms: i32
    result: Option<text>

class TimeoutController:
    timeout_ms: i32
    elapsed_ms: i32
    is_running: bool
    is_timed_out: bool

    static fn new(timeout_ms: i32) -> TimeoutController:
        TimeoutController(
            timeout_ms: timeout_ms,
            elapsed_ms: 0,
            is_running: false,
            is_timed_out: false
        )

    me start():
        self.is_running = true
        self.elapsed_ms = 0
        self.is_timed_out = false

    me advance(ms: i32):
        if self.is_running:
            self.elapsed_ms = self.elapsed_ms + ms
            if self.elapsed_ms >= self.timeout_ms:
                self.is_timed_out = true
                self.is_running = false

    me complete() -> TimeoutResult:
        self.is_running = false
        var result_val: Option<text> = nil
        if not self.is_timed_out:
            result_val = Some("completed")
        TimeoutResult(
            completed: not self.is_timed_out,
            timed_out: self.is_timed_out,
            duration_ms: self.elapsed_ms,
            result: result_val
        )

    fn has_timed_out() -> bool:
        self.is_timed_out

    fn remaining_time() -> i32:
        val remaining = self.timeout_ms - self.elapsed_ms
        if remaining > 0:
            remaining
        else:
            0

    me reset():
        self.elapsed_ms = 0
        self.is_running = false
        self.is_timed_out = false

struct ExecutionEvent:
    task_name: text
    timestamp: i32
    event_type: text

class ExecutionOrderTracker:
    events: [ExecutionEvent]
    current_time: i32

    static fn new() -> ExecutionOrderTracker:
        ExecutionOrderTracker(events: [], current_time: 0)

    me record_start(name: text):
        val event = ExecutionEvent(
            task_name: name,
            timestamp: self.current_time,
            event_type: "start"
        )
        var events = self.events
        events.append(event)
        self.events = events

    me record_end(name: text):
        val event = ExecutionEvent(
            task_name: name,
            timestamp: self.current_time,
            event_type: "end"
        )
        var events = self.events
        events.append(event)
        self.events = events

    me advance_time(ms: i32):
        self.current_time = self.current_time + ms

    fn get_start_order() -> [text]:
        var result = []
        for event in self.events:
            if event.event_type == "start":
                result.append(event.task_name)
        result

    fn get_end_order() -> [text]:
        var result = []
        for event in self.events:
            if event.event_type == "end":
                result.append(event.task_name)
        result

    fn verify_started_before(first: text, second: text) -> bool:
        var first_time: Option<i32> = nil
        var second_time: Option<i32> = nil
        for event in self.events:
            if event.event_type == "start":
                if event.task_name == first and first_time.is_none():
                    first_time = Some(event.timestamp)
                if event.task_name == second and second_time.is_none():
                    second_time = Some(event.timestamp)
        match first_time:
            Some(ft):
                match second_time:
                    Some(st): ft < st
                    nil: true
            nil: false

    fn verify_completed_before(first: text, second: text) -> bool:
        var first_time: Option<i32> = nil
        var second_time: Option<i32> = nil
        for event in self.events:
            if event.event_type == "end":
                if event.task_name == first and first_time.is_none():
                    first_time = Some(event.timestamp)
                if event.task_name == second and second_time.is_none():
                    second_time = Some(event.timestamp)
        match first_time:
            Some(ft):
                match second_time:
                    Some(st): ft < st
                    nil: true
            nil: false

    fn get_concurrent_at(time: i32) -> [text]:
        var running: [text] = []
        for event in self.events:
            if event.timestamp <= time:
                if event.event_type == "start":
                    running.append(event.task_name)
                else if event.event_type == "end":
                    var new_running: [text] = []
                    for name in running:
                        if name != event.task_name:
                            new_running.append(name)
                    running = new_running
        running

    me reset():
        self.events = []
        self.current_time = 0

class ConcurrencyController:
    max_concurrent: i32
    active_count: i32
    waiting_queue: [text]
    active_tasks: [text]
    completed_tasks: [text]

    static fn new(max_concurrent: i32) -> ConcurrencyController:
        ConcurrencyController(
            max_concurrent: max_concurrent,
            active_count: 0,
            waiting_queue: [],
            active_tasks: [],
            completed_tasks: []
        )

    fn can_start() -> bool:
        self.active_count < self.max_concurrent

    me try_start(name: text) -> bool:
        if not self.can_start():
            var waiting_queue = self.waiting_queue
            waiting_queue.append(name)
            self.waiting_queue = waiting_queue
            return false
        self.active_count = self.active_count + 1
        var active_tasks = self.active_tasks
        active_tasks.append(name)
        self.active_tasks = active_tasks
        true

    me complete(name: text):
        var new_active: [text] = []
        for task in self.active_tasks:
            if task != name:
                new_active.append(task)
        self.active_tasks = new_active
        self.active_count = self.active_count - 1
        var completed_tasks = self.completed_tasks
        completed_tasks.append(name)
        self.completed_tasks = completed_tasks
        # Inline try_start_waiting
        if self.waiting_queue.len() > 0 and self.can_start():
            val next = self.waiting_queue[0]
            var new_queue: [text] = []
            for i in 1..self.waiting_queue.len():
                new_queue.append(self.waiting_queue[i])
            self.waiting_queue = new_queue
            self.active_count = self.active_count + 1
            var active_tasks2 = self.active_tasks
            active_tasks2.append(next)
            self.active_tasks = active_tasks2

    fn get_active_count() -> i32:
        self.active_count

    fn get_waiting_count() -> i32:
        self.waiting_queue.len() as i32

    fn get_completed_count() -> i32:
        self.completed_tasks.len() as i32

    fn get_active_tasks() -> [text]:
        self.active_tasks

    me reset():
        self.active_count = 0
        self.waiting_queue = []
        self.active_tasks = []
        self.completed_tasks = []

class Debouncer:
    delay_ms: i32
    last_call_time: i32
    pending_value: Option<text>
    executed_values: [text]
    current_time: i32

    static fn new(delay_ms: i32) -> Debouncer:
        Debouncer(
            delay_ms: delay_ms,
            last_call_time: -999999,
            pending_value: nil,
            executed_values: [],
            current_time: 0
        )

    me call(value: text):
        self.pending_value = Some(value)
        self.last_call_time = self.current_time

    me advance_time(ms: i32):
        self.current_time = self.current_time + ms
        match self.pending_value:
            Some(v):
                if self.current_time - self.last_call_time >= self.delay_ms:
                    var executed_values = self.executed_values
                    executed_values.append(v)
                    self.executed_values = executed_values
                    self.pending_value = nil
            nil: ()

    fn get_executed_values() -> [text]:
        self.executed_values

    fn get_execution_count() -> i32:
        self.executed_values.len() as i32

    fn has_pending() -> bool:
        self.pending_value.is_some()

    me reset():
        self.last_call_time = -999999
        self.pending_value = nil
        self.executed_values = []
        self.current_time = 0

class Throttler:
    interval_ms: i32
    last_execution_time: i32
    dropped_count: i32
    executed_values: [text]
    current_time: i32

    static fn new(interval_ms: i32) -> Throttler:
        Throttler(
            interval_ms: interval_ms,
            last_execution_time: -999999,
            dropped_count: 0,
            executed_values: [],
            current_time: 0
        )

    me call(value: text) -> bool:
        if self.current_time - self.last_execution_time >= self.interval_ms:
            var executed_values = self.executed_values
            executed_values.append(value)
            self.executed_values = executed_values
            self.last_execution_time = self.current_time
            true
        else:
            self.dropped_count = self.dropped_count + 1
            false

    me advance_time(ms: i32):
        self.current_time = self.current_time + ms

    fn get_executed_values() -> [text]:
        self.executed_values

    fn get_execution_count() -> i32:
        self.executed_values.len() as i32

    fn get_dropped_count() -> i32:
        self.dropped_count

    me reset():
        self.last_execution_time = -999999
        self.dropped_count = 0
        self.executed_values = []
        self.current_time = 0

# ============================================================================
# Tests
# ============================================================================

describe "Mock Library - Phase 7 (Advanced Scheduling)":
    # Verifies the scheduling and concurrency control utilities that help test
    # time-sensitive and concurrent code. Covers task scheduling with priority
    # levels, retry policies with configurable backoff strategies, rate limiting
    # for throughput control, timeout tracking for operation deadlines, execution
    # order verification for concurrent tasks, concurrency controllers for limiting
    # parallelism, debouncers for coalescing rapid invocations, and throttlers
    # for rate-limiting function calls. Includes complex scenarios combining
    # multiple utilities like API rate limiting with retry, concurrent operations
    # with timeout handling, and priority scheduling with debounce.
    context "TaskPriority":
        it "defines priority levels":
            val critical = TaskPriority.Critical
            val high = TaskPriority.High
            val normal = TaskPriority.Normal
            val low = TaskPriority.Low
            val background = TaskPriority.Background
            expect true

    context "TaskScheduler - Basic":
        it "creates task scheduler":
            val scheduler = TaskScheduler.new()
            expect scheduler.get_pending_count() == 0

        it "schedules task with priority":
            val scheduler = TaskScheduler.new()
            val id = scheduler.schedule("task1", TaskPriority.Normal, 100)
            expect id == 0
            expect scheduler.get_pending_count() == 1

        it "schedules immediate task":
            val scheduler = TaskScheduler.new()
            val id = scheduler.schedule_immediate("urgent")
            expect scheduler.get_pending_count() == 1

        it "schedules delayed task":
            val scheduler = TaskScheduler.new()
            val id = scheduler.schedule_delayed("later", 500)
            expect scheduler.get_pending_count() == 1

        it "schedules background task":
            val scheduler = TaskScheduler.new()
            val id = scheduler.schedule_background("bg_task", 1000)
            expect scheduler.get_pending_count() == 1

    context "TaskScheduler - Execution":
        it "executes next task by priority":
            val scheduler = TaskScheduler.new()
            scheduler.schedule("low", TaskPriority.Low, 100)
            scheduler.schedule("high", TaskPriority.High, 100)
            scheduler.schedule("critical", TaskPriority.Critical, 100)
            match scheduler.execute_next():
                Some(task): expect task.name == "critical"
                nil: fail "Expected task"

        it "executes all tasks":
            val scheduler = TaskScheduler.new()
            scheduler.schedule("task1", TaskPriority.Normal, 50)
            scheduler.schedule("task2", TaskPriority.Normal, 50)
            scheduler.schedule("task3", TaskPriority.Normal, 50)
            scheduler.execute_all()
            expect scheduler.get_pending_count() == 0

        it "tracks execution order":
            val scheduler = TaskScheduler.new()
            val id1 = scheduler.schedule("critical", TaskPriority.Critical, 10)
            val id2 = scheduler.schedule("normal", TaskPriority.Normal, 10)
            val id3 = scheduler.schedule("high", TaskPriority.High, 10)
            scheduler.execute_all()
            expect scheduler.verify_execution_order([id1, id3, id2])

        it "gets task by id":
            val scheduler = TaskScheduler.new()
            val id = scheduler.schedule("findme", TaskPriority.Normal, 200)
            match scheduler.get_task(id):
                Some(task): expect task.name == "findme"
                nil: fail "Expected task"

        it "resets scheduler":
            val scheduler = TaskScheduler.new()
            scheduler.schedule("task", TaskPriority.Normal, 100)
            scheduler.reset()
            expect scheduler.get_pending_count() == 0

    context "RetryPolicy - Basic":
        it "creates retry policy":
            val policy = RetryPolicy.new(3)
            expect policy.max_attempts == 3

        it "creates no-retry policy":
            val policy = RetryPolicy.no_retry()
            expect policy.max_attempts == 1

        it "creates linear backoff policy":
            val policy = RetryPolicy.with_linear_backoff(5, 100)
            expect policy.max_attempts == 5
            expect policy.base_delay_ms == 100

        it "creates exponential backoff policy":
            val policy = RetryPolicy.with_exponential_backoff(4, 50)
            expect policy.max_attempts == 4
            expect policy.base_delay_ms == 50

    context "RetryPolicy - Backoff Calculation":
        it "calculates linear backoff":
            val policy = RetryPolicy.with_linear_backoff(5, 100)
            expect policy.calculate_delay(1) == 100
            expect policy.calculate_delay(2) == 200
            expect policy.calculate_delay(3) == 300

        it "calculates exponential backoff":
            val policy = RetryPolicy.with_exponential_backoff(5, 100)
            expect policy.calculate_delay(1) == 100
            expect policy.calculate_delay(2) == 200
            expect policy.calculate_delay(3) == 400

        it "respects max delay":
            val policy = RetryPolicy.with_exponential_backoff(10, 100)
            policy.set_max_delay(500)
            expect policy.calculate_delay(5) <= 500

    context "RetryPolicy - Attempt Tracking":
        it "records successful attempt":
            val policy = RetryPolicy.new(3)
            policy.record_attempt(true, nil)
            expect policy.get_attempt_count() == 1
            expect policy.was_successful()

        it "records failed attempt":
            val policy = RetryPolicy.new(3)
            policy.record_attempt(false, Some("timeout"))
            expect policy.get_attempt_count() == 1
            expect not policy.was_successful()

        it "determines should retry":
            val policy = RetryPolicy.new(3)
            expect policy.should_retry()
            policy.record_attempt(false, Some("error"))
            expect policy.should_retry()
            policy.record_attempt(false, Some("error"))
            expect policy.should_retry()
            policy.record_attempt(false, Some("error"))
            expect not policy.should_retry()

        it "calculates total delay":
            val policy = RetryPolicy.with_linear_backoff(3, 100)
            policy.record_attempt(false, nil)
            policy.record_attempt(false, nil)
            policy.record_attempt(true, nil)
            expect policy.get_total_delay() == 600

        it "resets policy":
            val policy = RetryPolicy.new(3)
            policy.record_attempt(false, nil)
            policy.reset()
            expect policy.get_attempt_count() == 0

    context "RateLimiter - Basic":
        it "creates rate limiter":
            val limiter = RateLimiter.new(10, 1000)
            expect limiter.max_requests == 10
            expect limiter.window_ms == 1000

        it "creates per-second limiter":
            val limiter = RateLimiter.per_second(5)
            expect limiter.max_requests == 5
            expect limiter.window_ms == 1000

        it "creates per-minute limiter":
            val limiter = RateLimiter.per_minute(100)
            expect limiter.max_requests == 100
            expect limiter.window_ms == 60000

    context "RateLimiter - Request Handling":
        it "allows requests within limit":
            val limiter = RateLimiter.new(3, 1000)
            expect limiter.try_acquire()
            expect limiter.try_acquire()
            expect limiter.try_acquire()
            expect not limiter.try_acquire()

        it "checks can proceed":
            val limiter = RateLimiter.new(2, 1000)
            expect limiter.can_proceed()
            limiter.try_acquire()
            limiter.try_acquire()
            expect not limiter.can_proceed()

        it "gets remaining requests":
            val limiter = RateLimiter.new(5, 1000)
            expect limiter.get_remaining_requests() == 5
            limiter.try_acquire()
            limiter.try_acquire()
            expect limiter.get_remaining_requests() == 3

        it "cleans up old requests after window":
            val limiter = RateLimiter.new(2, 100)
            limiter.try_acquire()
            limiter.try_acquire()
            expect not limiter.can_proceed()
            limiter.advance_time(150)
            expect limiter.can_proceed()

        it "calculates wait time":
            val limiter = RateLimiter.new(1, 100)
            expect limiter.get_wait_time() == 0
            limiter.try_acquire()
            expect limiter.get_wait_time() == 100

        it "resets limiter":
            val limiter = RateLimiter.new(2, 1000)
            limiter.try_acquire()
            limiter.try_acquire()
            limiter.reset()
            expect limiter.get_remaining_requests() == 2

    context "TimeoutController - Basic":
        it "creates timeout controller":
            val timeout = TimeoutController.new(5000)
            expect timeout.timeout_ms == 5000

        it "starts and tracks elapsed time":
            val timeout = TimeoutController.new(100)
            timeout.start()
            timeout.advance(50)
            expect timeout.remaining_time() == 50

        it "detects timeout":
            val timeout = TimeoutController.new(100)
            timeout.start()
            timeout.advance(150)
            expect timeout.has_timed_out()

        it "completes without timeout":
            val timeout = TimeoutController.new(100)
            timeout.start()
            timeout.advance(50)
            val result = timeout.complete()
            expect result.completed
            expect not result.timed_out

        it "completes with timeout":
            val timeout = TimeoutController.new(100)
            timeout.start()
            timeout.advance(150)
            val result = timeout.complete()
            expect not result.completed
            expect result.timed_out

        it "resets timeout":
            val timeout = TimeoutController.new(100)
            timeout.start()
            timeout.advance(150)
            timeout.reset()
            expect not timeout.has_timed_out()
            expect timeout.remaining_time() == 100

    context "ExecutionOrderTracker - Basic":
        it "creates execution order tracker":
            val tracker = ExecutionOrderTracker.new()
            expect tracker.get_start_order().len() == 0

        it "records start and end events":
            val tracker = ExecutionOrderTracker.new()
            tracker.record_start("task1")
            tracker.advance_time(50)
            tracker.record_end("task1")
            expect tracker.get_start_order().len() == 1
            expect tracker.get_end_order().len() == 1

    context "ExecutionOrderTracker - Verification":
        it "verifies started before":
            val tracker = ExecutionOrderTracker.new()
            tracker.record_start("first")
            tracker.advance_time(10)
            tracker.record_start("second")
            expect tracker.verify_started_before("first", "second")
            expect not tracker.verify_started_before("second", "first")

        it "verifies completed before":
            val tracker = ExecutionOrderTracker.new()
            tracker.record_start("fast")
            tracker.record_start("slow")
            tracker.advance_time(50)
            tracker.record_end("fast")
            tracker.advance_time(100)
            tracker.record_end("slow")
            expect tracker.verify_completed_before("fast", "slow")

        it "gets concurrent tasks at time":
            val tracker = ExecutionOrderTracker.new()
            tracker.record_start("task1")
            tracker.advance_time(10)
            tracker.record_start("task2")
            tracker.advance_time(10)
            tracker.record_start("task3")
            val concurrent = tracker.get_concurrent_at(15)
            expect concurrent.len() == 2

        it "gets start and end order":
            val tracker = ExecutionOrderTracker.new()
            tracker.record_start("a")
            tracker.record_start("b")
            tracker.record_end("a")
            tracker.record_end("b")
            val starts = tracker.get_start_order()
            expect starts[0] == "a"
            expect starts[1] == "b"

        it "resets tracker":
            val tracker = ExecutionOrderTracker.new()
            tracker.record_start("task")
            tracker.reset()
            expect tracker.get_start_order().len() == 0

    context "ConcurrencyController - Basic":
        it "creates concurrency controller":
            val controller = ConcurrencyController.new(3)
            expect controller.max_concurrent == 3

        it "allows starting within limit":
            val controller = ConcurrencyController.new(2)
            expect controller.try_start("task1")
            expect controller.try_start("task2")
            expect not controller.try_start("task3")

        it "checks can start":
            val controller = ConcurrencyController.new(1)
            expect controller.can_start()
            controller.try_start("task")
            expect not controller.can_start()

    context "ConcurrencyController - Queue Management":
        it "queues tasks when at limit":
            val controller = ConcurrencyController.new(1)
            controller.try_start("active")
            controller.try_start("waiting")
            expect controller.get_active_count() == 1
            expect controller.get_waiting_count() == 1

        it "starts waiting task on completion":
            val controller = ConcurrencyController.new(1)
            controller.try_start("first")
            controller.try_start("second")
            controller.complete("first")
            expect controller.get_active_count() == 1
            expect controller.get_waiting_count() == 0
            val active = controller.get_active_tasks()
            expect active[0] == "second"

        it "tracks completed tasks":
            val controller = ConcurrencyController.new(2)
            controller.try_start("a")
            controller.try_start("b")
            controller.complete("a")
            expect controller.get_completed_count() == 1

        it "resets controller":
            val controller = ConcurrencyController.new(2)
            controller.try_start("task")
            controller.reset()
            expect controller.get_active_count() == 0

    context "Debouncer - Basic":
        it "creates debouncer":
            val debouncer = Debouncer.new(100)
            expect debouncer.delay_ms == 100

        it "debounces rapid calls":
            val debouncer = Debouncer.new(100)
            debouncer.call("first")
            debouncer.advance_time(50)
            debouncer.call("second")
            debouncer.advance_time(50)
            debouncer.call("third")
            debouncer.advance_time(150)
            val executed = debouncer.get_executed_values()
            expect executed.len() == 1
            expect executed[0] == "third"

        it "executes after delay":
            val debouncer = Debouncer.new(100)
            debouncer.call("value")
            expect debouncer.has_pending()
            debouncer.advance_time(150)
            expect not debouncer.has_pending()
            expect debouncer.get_execution_count() == 1

        it "tracks execution count":
            val debouncer = Debouncer.new(50)
            debouncer.call("a")
            debouncer.advance_time(100)
            debouncer.call("b")
            debouncer.advance_time(100)
            expect debouncer.get_execution_count() == 2

        it "resets debouncer":
            val debouncer = Debouncer.new(100)
            debouncer.call("value")
            debouncer.advance_time(150)
            debouncer.reset()
            expect debouncer.get_execution_count() == 0

    context "Throttler - Basic":
        it "creates throttler":
            val throttler = Throttler.new(100)
            expect throttler.interval_ms == 100

        it "allows first call":
            val throttler = Throttler.new(100)
            expect throttler.call("first")
            expect throttler.get_execution_count() == 1

        it "throttles rapid calls":
            val throttler = Throttler.new(100)
            expect throttler.call("first")
            expect not throttler.call("second")
            expect not throttler.call("third")
            expect throttler.get_execution_count() == 1

        it "allows call after interval":
            val throttler = Throttler.new(100)
            throttler.call("first")
            throttler.advance_time(150)
            expect throttler.call("second")
            expect throttler.get_execution_count() == 2

        it "tracks dropped calls":
            val throttler = Throttler.new(100)
            throttler.call("ok")
            throttler.call("dropped1")
            throttler.call("dropped2")
            expect throttler.get_dropped_count() == 2

        it "resets throttler":
            val throttler = Throttler.new(100)
            throttler.call("value")
            throttler.call("dropped")
            throttler.reset()
            expect throttler.get_execution_count() == 0
            expect throttler.get_dropped_count() == 0

    context "Complex Scheduling Scenarios":
        it "simulates API with rate limiting and retry":
            val limiter = RateLimiter.new(2, 1000)
            val retry = RetryPolicy.with_exponential_backoff(3, 100)
            var success = false
            while retry.should_retry() and not success:
                if limiter.try_acquire():
                    success = true
                    retry.record_attempt(true, nil)
                else:
                    retry.record_attempt(false, Some("rate limited"))
            expect success

        it "tracks concurrent async operations":
            val controller = ConcurrencyController.new(2)
            val tracker = ExecutionOrderTracker.new()
            controller.try_start("op1")
            tracker.record_start("op1")
            controller.try_start("op2")
            tracker.record_start("op2")
            controller.try_start("op3")
            tracker.advance_time(100)
            tracker.record_end("op1")
            controller.complete("op1")
            tracker.record_start("op3")
            expect controller.get_active_tasks().len() == 2

        it "handles timeout with retry":
            val timeout = TimeoutController.new(100)
            val retry = RetryPolicy.new(3)
            var completed = false
            while retry.should_retry() and not completed:
                timeout.reset()
                timeout.start()
                timeout.advance(150)
                if timeout.has_timed_out():
                    retry.record_attempt(false, Some("timeout"))
                else:
                    retry.record_attempt(true, nil)
                    completed = true
            expect retry.get_attempt_count() == 3
            expect not retry.was_successful()

        it "priority scheduling with debounce":
            val scheduler = TaskScheduler.new()
            val debouncer = Debouncer.new(50)
            debouncer.call("input1")
            debouncer.advance_time(30)
            debouncer.call("input2")
            debouncer.advance_time(100)
            val values = debouncer.get_executed_values()
            if values.len() > 0:
                scheduler.schedule(values[0], TaskPriority.High, 10)
            scheduler.execute_all()
            expect scheduler.get_pending_count() == 0
