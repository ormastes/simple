# Error Handling Module Extended Specification
#
# Tests for std.error module logic.
# Since the module uses traits, generics (Context<E>), and extern fns that
# aren't fully supported by the runtime parser, we test inline implementations
# of the core error handling patterns.

# ============================================================================
# Inline ErrorKind enum simulation (mirroring std.error)
# ============================================================================

# Simulate ErrorKind as string constants (enum not importable)
use std.string.{NL}

val ERROR_NOT_FOUND = "not found"
val ERROR_PERMISSION_DENIED = "permission denied"
val ERROR_CONNECTION_REFUSED = "connection refused"
val ERROR_CONNECTION_RESET = "connection reset"
val ERROR_INTERRUPTED = "interrupted"
val ERROR_TIMED_OUT = "timed out"
val ERROR_INVALID_INPUT = "invalid input"
val ERROR_INVALID_DATA = "invalid data"
val ERROR_UNEXPECTED_EOF = "unexpected end of file"
val ERROR_ALREADY_EXISTS = "already exists"
val ERROR_WOULD_BLOCK = "would block"
val ERROR_OTHER = "other error"
val ERROR_UNKNOWN = "unknown error"

# ============================================================================
# Inline SimpleError (mirroring std.error)
# ============================================================================

fn simple_error(kind: text, message: text) -> dict:
    {"kind": kind, "msg": message, "source_error": nil}

fn simple_error_with_source(kind: text, message: text, source: dict) -> dict:
    {"kind": kind, "msg": message, "source_error": source}

fn error_message(err: dict) -> text:
    err["msg"]

fn error_kind(err: dict) -> text:
    err["kind"]

fn error_source(err: dict):
    err["source_error"]

# ============================================================================
# Inline error creation functions (mirroring std.error)
# ============================================================================

fn make_error(message: text) -> dict:
    simple_error(ERROR_UNKNOWN, message)

fn make_io_error(kind: text, message: text) -> dict:
    simple_error(kind, message)

fn make_validation_error(message: text) -> dict:
    simple_error(ERROR_INVALID_INPUT, message)

# ============================================================================
# Inline format_error (mirroring std.error)
# ============================================================================

fn format_error(err: dict) -> text:
    var result = "Error: {err["msg"]}"
    var current = err["source_error"]
    while current != nil:
        result = result + "{NL}Caused by: {current["msg"]}"
        current = current["source_error"]
    result

fn format_error_compact(err: dict) -> text:
    var result = err["msg"]
    var current = err["source_error"]
    while current != nil:
        result = result + ": {current["msg"]}"
        current = current["source_error"]
    result

# ============================================================================
# ErrorKind Tests
# ============================================================================

describe "ErrorKind constants":

    it "has NotFound kind":
        expect(ERROR_NOT_FOUND).to_equal("not found")

    it "has PermissionDenied kind":
        expect(ERROR_PERMISSION_DENIED).to_equal("permission denied")

    it "has InvalidInput kind":
        expect(ERROR_INVALID_INPUT).to_equal("invalid input")

    it "has InvalidData kind":
        expect(ERROR_INVALID_DATA).to_equal("invalid data")

    it "has Unknown kind":
        expect(ERROR_UNKNOWN).to_equal("unknown error")

    it "has TimedOut kind":
        expect(ERROR_TIMED_OUT).to_equal("timed out")

    it "has AlreadyExists kind":
        expect(ERROR_ALREADY_EXISTS).to_equal("already exists")

    it "has all 13 error kinds":
        val kinds = [ERROR_NOT_FOUND, ERROR_PERMISSION_DENIED, ERROR_CONNECTION_REFUSED, ERROR_CONNECTION_RESET, ERROR_INTERRUPTED, ERROR_TIMED_OUT, ERROR_INVALID_INPUT, ERROR_INVALID_DATA, ERROR_UNEXPECTED_EOF, ERROR_ALREADY_EXISTS, ERROR_WOULD_BLOCK, ERROR_OTHER, ERROR_UNKNOWN]
        expect(kinds.len()).to_equal(13)

# ============================================================================
# SimpleError Creation
# ============================================================================

describe "simple_error":

    it "creates error with kind and message":
        val err = simple_error(ERROR_NOT_FOUND, "File not found: data.txt")
        expect(error_message(err)).to_equal("File not found: data.txt")
        expect(error_kind(err)).to_equal("not found")

    it "creates error with nil source":
        val err = simple_error(ERROR_UNKNOWN, "something failed")
        val src = error_source(err)
        expect(src).to_be_nil()

describe "simple_error_with_source":

    it "creates error with source chain":
        val inner = simple_error(ERROR_NOT_FOUND, "file missing")
        val outer = simple_error_with_source(ERROR_INVALID_DATA, "config load failed", inner)
        expect(error_message(outer)).to_equal("config load failed")
        expect(error_kind(outer)).to_equal("invalid data")
        val src = error_source(outer)
        expect(error_message(src)).to_equal("file missing")
        expect(error_kind(src)).to_equal("not found")

    it "creates deep error chain":
        val e1 = simple_error(ERROR_CONNECTION_REFUSED, "server down")
        val e2 = simple_error_with_source(ERROR_TIMED_OUT, "request failed", e1)
        val e3 = simple_error_with_source(ERROR_OTHER, "operation failed", e2)
        expect(error_message(e3)).to_equal("operation failed")
        val src2 = error_source(e3)
        expect(error_message(src2)).to_equal("request failed")
        val src1 = error_source(src2)
        expect(error_message(src1)).to_equal("server down")
        val src0 = error_source(src1)
        expect(src0).to_be_nil()

# ============================================================================
# Error Creation Helpers
# ============================================================================

describe "make_error":

    it "creates error with Unknown kind":
        val err = make_error("something went wrong")
        expect(error_message(err)).to_equal("something went wrong")
        expect(error_kind(err)).to_equal("unknown error")

describe "make_io_error":

    it "creates IO error with specified kind":
        val err = make_io_error(ERROR_NOT_FOUND, "file.txt not found")
        expect(error_message(err)).to_equal("file.txt not found")
        expect(error_kind(err)).to_equal("not found")

    it "creates different IO error kinds":
        val e1 = make_io_error(ERROR_PERMISSION_DENIED, "access denied")
        val e2 = make_io_error(ERROR_TIMED_OUT, "connection timed out")
        expect(error_kind(e1)).to_equal("permission denied")
        expect(error_kind(e2)).to_equal("timed out")

describe "make_validation_error":

    it "creates validation error with InvalidInput kind":
        val err = make_validation_error("email format invalid")
        expect(error_message(err)).to_equal("email format invalid")
        expect(error_kind(err)).to_equal("invalid input")

# ============================================================================
# Error Formatting
# ============================================================================

describe "format_error":

    it "formats single error":
        val err = simple_error(ERROR_NOT_FOUND, "file missing")
        val formatted = format_error(err)
        expect(formatted).to_equal("Error: file missing")

    it "formats error with source chain":
        val inner = simple_error(ERROR_NOT_FOUND, "file missing")
        val outer = simple_error_with_source(ERROR_INVALID_DATA, "config load failed", inner)
        val formatted = format_error(outer)
        expect(formatted).to_contain("Error: config load failed")
        expect(formatted).to_contain("Caused by: file missing")

    it "formats deep error chain":
        val e1 = simple_error(ERROR_CONNECTION_REFUSED, "server down")
        val e2 = simple_error_with_source(ERROR_TIMED_OUT, "request failed", e1)
        val e3 = simple_error_with_source(ERROR_OTHER, "operation failed", e2)
        val formatted = format_error(e3)
        expect(formatted).to_contain("Error: operation failed")
        expect(formatted).to_contain("Caused by: request failed")
        expect(formatted).to_contain("Caused by: server down")

describe "format_error_compact":

    it "formats single error compactly":
        val err = simple_error(ERROR_NOT_FOUND, "file missing")
        val formatted = format_error_compact(err)
        expect(formatted).to_equal("file missing")

    it "formats error chain with colons":
        val inner = simple_error(ERROR_NOT_FOUND, "file missing")
        val outer = simple_error_with_source(ERROR_INVALID_DATA, "config load failed", inner)
        val formatted = format_error_compact(outer)
        expect(formatted).to_equal("config load failed: file missing")

    it "formats deep chain compactly":
        val e1 = simple_error(ERROR_CONNECTION_REFUSED, "server down")
        val e2 = simple_error_with_source(ERROR_TIMED_OUT, "request failed", e1)
        val e3 = simple_error_with_source(ERROR_OTHER, "operation failed", e2)
        val formatted = format_error_compact(e3)
        expect(formatted).to_equal("operation failed: request failed: server down")

# ============================================================================
# Error Patterns
# ============================================================================

describe "error handling patterns":

    it "uses nil for no error (option pattern)":
        var current_error = nil
        # Simulate successful operation
        val result = 42
        expect(current_error).to_be_nil()
        expect(result).to_equal(42)

    it "uses error dict for failure (option pattern)":
        var current_error = nil
        # Simulate failed operation
        current_error = make_error("operation failed")
        val has_error = current_error != nil
        expect(has_error).to_equal(true)
        expect(error_message(current_error)).to_equal("operation failed")

    it "propagates errors through chain":
        fn inner_op() -> dict:
            make_io_error(ERROR_NOT_FOUND, "data.txt not found")
        fn outer_op() -> dict:
            val err = inner_op()
            simple_error_with_source(ERROR_INVALID_DATA, "cannot load config", err)
        val final_err = outer_op()
        expect(error_kind(final_err)).to_equal("invalid data")
        val src = error_source(final_err)
        expect(error_kind(src)).to_equal("not found")

    it "handles multiple error kinds differently":
        fn handle_error(err: dict) -> text:
            val kind = error_kind(err)
            if kind == ERROR_NOT_FOUND:
                return "retry with default"
            if kind == ERROR_PERMISSION_DENIED:
                return "request access"
            if kind == ERROR_TIMED_OUT:
                return "retry later"
            "unknown handling"
        val e1 = make_io_error(ERROR_NOT_FOUND, "missing")
        val e2 = make_io_error(ERROR_PERMISSION_DENIED, "denied")
        val e3 = make_io_error(ERROR_TIMED_OUT, "slow")
        expect(handle_error(e1)).to_equal("retry with default")
        expect(handle_error(e2)).to_equal("request access")
        expect(handle_error(e3)).to_equal("retry later")
