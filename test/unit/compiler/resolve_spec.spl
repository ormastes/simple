"""
# Method Resolution Specification

**Feature IDs:** #2001-2070
**Category:** Compiler
**Difficulty:** 5/5
**Status:** In Progress

## Overview

MethodResolver provides UFCS (Uniform Function Call Syntax) method resolution.
It resolves method calls using a 3-priority algorithm:
1. Instance methods on the receiver's type (highest priority)
2. Trait methods implemented by the receiver's type
3. Free functions where receiver becomes first argument (UFCS)

## Key Features

- UFCS resolution with priority rules
- Type compatibility checking for method arguments
- Static method call detection (Type.method())
- Trait method resolution via impl blocks
- Comprehensive error messages with suggestions
- Full HIR expression traversal

## Implementation

File: `/home/ormastes/dev/pub/simple/src/compiler/resolve.spl`
"""

use compiler.hir_types.SymbolId
use compiler.resolve.*
use compiler.hir.*
use core.lexer.Span


# ============================================================================
# Test Group 1: Type Compatibility Checking
# ============================================================================

describe "TypeChecker Compatibility":
    """
    ## Type Compatibility

    Validates TypeChecker.is_compatible() for UFCS resolution.
    """

    context "when checking primitive types":
        """
        ### Scenario: Primitive Type Matching

        Tests exact matching for primitive types.
        """

        it "matches identical int types":
            val checker = TypeChecker()
            val t1 = create_int_type(64, true)
            val t2 = create_int_type(64, true)

            expect(checker.is_compatible(t1, t2)).to_be_true()

        it "rejects different int sizes":
            val checker = TypeChecker()
            val t1 = create_int_type(32, true)
            val t2 = create_int_type(64, true)

            expect(checker.is_compatible(t1, t2)).to_be_false()

        it "rejects different int signedness":
            val checker = TypeChecker()
            val t1 = create_int_type(64, true)   # i64
            val t2 = create_int_type(64, false)  # u64

            expect(checker.is_compatible(t1, t2)).to_be_false()

        it "matches identical float types":
            val checker = TypeChecker()
            val t1 = create_float_type(64)
            val t2 = create_float_type(64)

            expect(checker.is_compatible(t1, t2)).to_be_true()

        it "rejects different float sizes":
            val checker = TypeChecker()
            val t1 = create_float_type(32)
            val t2 = create_float_type(64)

            expect(checker.is_compatible(t1, t2)).to_be_false()

        it "matches bool types":
            val checker = TypeChecker()
            val t1 = create_bool_type()
            val t2 = create_bool_type()

            expect(checker.is_compatible(t1, t2)).to_be_true()

        it "matches char types":
            val checker = TypeChecker()
            val t1 = create_char_type()
            val t2 = create_char_type()

            expect(checker.is_compatible(t1, t2)).to_be_true()

        it "matches string types":
            val checker = TypeChecker()
            val t1 = create_string_type()
            val t2 = create_string_type()

            expect(checker.is_compatible(t1, t2)).to_be_true()

        it "matches unit types":
            val checker = TypeChecker()
            val t1 = create_unit_type()
            val t2 = create_unit_type()

            expect(checker.is_compatible(t1, t2)).to_be_true()

    context "when checking named types":
        """
        ### Scenario: Named Type Compatibility

        Tests matching for classes, structs, enums (named types).
        """

        it "matches identical named types":
            val checker = TypeChecker()
            val sym1 = create_symbol_id(1)
            val t1 = create_named_type(sym1, [])
            val t2 = create_named_type(sym1, [])

            expect(checker.is_compatible(t1, t2)).to_be_true()

        it "rejects different named types":
            val checker = TypeChecker()
            val sym1 = create_symbol_id(1)
            val sym2 = create_symbol_id(2)
            val t1 = create_named_type(sym1, [])
            val t2 = create_named_type(sym2, [])

            expect(checker.is_compatible(t1, t2)).to_be_false()

        it "matches generic types with compatible args":
            val checker = TypeChecker()
            val sym = create_symbol_id(1)
            val arg1 = create_int_type(64, true)
            val arg2 = create_int_type(64, true)
            val t1 = create_named_type(sym, [arg1])
            val t2 = create_named_type(sym, [arg2])

            expect(checker.is_compatible(t1, t2)).to_be_true()

        it "rejects generic types with incompatible args":
            val checker = TypeChecker()
            val sym = create_symbol_id(1)
            val arg1 = create_int_type(32, true)
            val arg2 = create_int_type(64, true)
            val t1 = create_named_type(sym, [arg1])
            val t2 = create_named_type(sym, [arg2])

            expect(checker.is_compatible(t1, t2)).to_be_false()

    context "when checking reference types":
        """
        ### Scenario: Reference Compatibility

        Tests that T is compatible with &T and &mut T.
        """

        it "matches T with &T":
            val checker = TypeChecker()
            val inner = create_int_type(64, true)
            val t_ref = create_ref_type(inner, false)

            expect(checker.is_compatible(inner, t_ref)).to_be_true()

        it "matches T with &mut T":
            val checker = TypeChecker()
            val inner = create_int_type(64, true)
            val t_mut_ref = create_ref_type(inner, true)

            expect(checker.is_compatible(inner, t_mut_ref)).to_be_true()

    context "when checking collection types":
        """
        ### Scenario: Collection Type Compatibility

        Tests arrays, slices, optionals.
        """

        it "matches array types with same element":
            val checker = TypeChecker()
            val elem = create_int_type(64, true)
            val t1 = create_array_type(elem, 10)
            val t2 = create_array_type(elem, 10)

            expect(checker.is_compatible(t1, t2)).to_be_true()

        it "matches slice types with same element":
            val checker = TypeChecker()
            val elem = create_int_type(64, true)
            val t1 = create_slice_type(elem)
            val t2 = create_slice_type(elem)

            expect(checker.is_compatible(t1, t2)).to_be_true()

        it "matches optional types with same inner":
            val checker = TypeChecker()
            val inner = create_int_type(64, true)
            val t1 = create_optional_type(inner)
            val t2 = create_optional_type(inner)

            expect(checker.is_compatible(t1, t2)).to_be_true()

    context "when checking type parameters":
        """
        ### Scenario: Generic Type Parameter Compatibility

        Tests type parameter matching.
        """

        it "matches identical type parameters":
            val checker = TypeChecker()
            val t1 = create_type_param("T", 0)
            val t2 = create_type_param("T", 0)

            expect(checker.is_compatible(t1, t2)).to_be_true()

        it "rejects different type parameters":
            val checker = TypeChecker()
            val t1 = create_type_param("T", 0)
            val t2 = create_type_param("U", 1)

            expect(checker.is_compatible(t1, t2)).to_be_false()

    context "when checking inference variables":
        """
        ### Scenario: Inference Variable Compatibility

        Inference variables are always compatible (will be unified).
        """

        it "matches infer with any type":
            val checker = TypeChecker()
            val infer = create_infer_type(0, InferKind.General)
            val concrete = create_int_type(64, true)

            expect(checker.is_compatible(infer, concrete)).to_be_true()

        it "matches any type with infer":
            val checker = TypeChecker()
            val concrete = create_int_type(64, true)
            val infer = create_infer_type(0, InferKind.General)

            expect(checker.is_compatible(concrete, infer)).to_be_true()

    context "when checking incompatible types":
        """
        ### Scenario: Type Mismatches

        Tests that incompatible types are rejected.
        """

        it "rejects int vs float":
            val checker = TypeChecker()
            val int_type = create_int_type(64, true)
            val float_type = create_float_type(64)

            expect(checker.is_compatible(int_type, float_type)).to_be_false()

        it "rejects bool vs int":
            val checker = TypeChecker()
            val bool_type = create_bool_type()
            val int_type = create_int_type(32, true)

            expect(checker.is_compatible(bool_type, int_type)).to_be_false()


# ============================================================================
# Test Group 2: Type Symbol Extraction
# ============================================================================

describe "TypeChecker Symbol Extraction":
    """
    ## Symbol Extraction

    Validates get_type_symbol() for extracting SymbolId from named types.
    """

    it "extracts symbol from named type":
        val sym_id = create_symbol_id(42)
        val ty = create_named_type(sym_id, [])

        val result = TypeChecker.get_type_symbol(ty)

        expect(result.?).to_be_true()
        expect(result.unwrap().id).to_equal(42)

    it "returns nil for non-named types":
        val ty = create_int_type(64, true)

        val result = TypeChecker.get_type_symbol(ty)

        expect(result.?).to_be_false()


# ============================================================================
# Test Group 3: Type Formatting
# ============================================================================

describe "MethodResolver Type Formatting":
    """
    ## Type Formatting

    Validates format_type() for error messages.
    """

    it "formats signed int types":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)
        val ty = create_int_type(64, true)

        val formatted = resolver.format_type(ty)

        expect(formatted).to_equal("i64")

    it "formats unsigned int types":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)
        val ty = create_int_type(32, false)

        val formatted = resolver.format_type(ty)

        expect(formatted).to_equal("u32")

    it "formats float types":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)
        val ty = create_float_type(64)

        val formatted = resolver.format_type(ty)

        expect(formatted).to_equal("f64")

    it "formats bool type":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)
        val ty = create_bool_type()

        val formatted = resolver.format_type(ty)

        expect(formatted).to_equal("bool")

    it "formats char type":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)
        val ty = create_char_type()

        val formatted = resolver.format_type(ty)

        expect(formatted).to_equal("char")

    it "formats string type":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)
        val ty = create_string_type()

        val formatted = resolver.format_type(ty)

        expect(formatted).to_equal("text")

    it "formats unit type":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)
        val ty = create_unit_type()

        val formatted = resolver.format_type(ty)

        expect(formatted).to_equal("()")

    it "formats array types":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)
        val elem = create_int_type(64, true)
        val ty = create_array_type(elem, 10)

        val formatted = resolver.format_type(ty)

        expect(formatted).to_equal("[i64]")

    it "formats optional types":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)
        val inner = create_int_type(64, true)
        val ty = create_optional_type(inner)

        val formatted = resolver.format_type(ty)

        expect(formatted).to_equal("i64?")


# ============================================================================
# Test Group 4: Name Similarity Checking
# ============================================================================

describe "MethodResolver Name Similarity":
    """
    ## Name Similarity

    Validates is_similar() for method suggestions.
    """

    it "matches identical names":
        expect(MethodResolver.is_similar("map", "map")).to_be_true()

    it "matches same prefix":
        expect(MethodResolver.is_similar("map", "max")).to_be_true()

    it "matches same suffix":
        expect(MethodResolver.is_similar("find_map", "filter_map")).to_be_true()

    it "rejects completely different names":
        expect(MethodResolver.is_similar("map", "xyz")).to_be_false()

    it "rejects short names":
        expect(MethodResolver.is_similar("a", "b")).to_be_false()

    it "rejects empty names":
        expect(MethodResolver.is_similar("", "map")).to_be_false()


# ============================================================================
# Test Group 5: Static Method Call Detection
# ============================================================================

describe "MethodResolver Static Call Detection":
    """
    ## Static Method Detection

    Validates is_static_method_call() for Type.method() vs expr.method().
    """

    it "detects class name as static call":
        val symbols = create_symbol_table_with_class("MyClass")
        val resolver = MethodResolver.new(symbols)
        val class_sym = create_symbol_id(1)
        val receiver = create_var_expr(class_sym)

        val is_static = resolver.is_static_method_call(receiver)

        expect(is_static).to_be_true()

    it "detects struct name as static call":
        val symbols = create_symbol_table_with_struct("MyStruct")
        val resolver = MethodResolver.new(symbols)
        val struct_sym = create_symbol_id(1)
        val receiver = create_var_expr(struct_sym)

        val is_static = resolver.is_static_method_call(receiver)

        expect(is_static).to_be_true()

    it "detects enum name as static call":
        val symbols = create_symbol_table_with_enum("MyEnum")
        val resolver = MethodResolver.new(symbols)
        val enum_sym = create_symbol_id(1)
        val receiver = create_var_expr(enum_sym)

        val is_static = resolver.is_static_method_call(receiver)

        expect(is_static).to_be_true()

    it "rejects value expression as static call":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)
        val receiver = create_int_lit_expr(42)

        val is_static = resolver.is_static_method_call(receiver)

        expect(is_static).to_be_false()


# ============================================================================
# Test Group 6: Error Handling
# ============================================================================

describe "MethodResolver Error Handling":
    """
    ## Error Tracking

    Validates error collection and reporting.
    """

    it "starts with no errors":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)

        expect(resolver.has_errors()).to_be_false()
        expect(resolver.get_errors().len()).to_equal(0)  
    it "tracks added errors":
        val symbols = create_empty_symbol_table()
        var resolver = MethodResolver.new(symbols)
        val span = create_span(0, 10)

        resolver.add_error("test error", span)

        expect(resolver.has_errors()).to_be_true()
        expect(resolver.get_errors().len()).to_equal(1)          expect(resolver.get_errors()[0].message).to_equal("test error")

    it "accumulates multiple errors":
        val symbols = create_empty_symbol_table()
        var resolver = MethodResolver.new(symbols)
        val span = create_span(0, 10)

        resolver.add_error("error 1", span)
        resolver.add_error("error 2", span)

        expect(resolver.get_errors().len()).to_equal(2)  

# ============================================================================
# Test Group 7: ResolveError Formatting
# ============================================================================

describe "ResolveError":
    """
    ## Error Formatting

    Validates ResolveError.to_string().
    """

    it "formats error with span":
        val span = create_span(10, 20)
        val error = ResolveError(message: "test error", span: span)

        val formatted = error.to_string()

        expect(formatted).to_contain("test error")
        expect(formatted).to_contain("resolve error")


# ============================================================================
# Test Group 8: Edge Cases - Nested Types
# ============================================================================

describe "TypeChecker Edge Cases - Nested Types":
    """
    ## Nested Type Compatibility

    Validates type checking for deeply nested and complex types.
    """

    it "handles nested generic types":
        val checker = TypeChecker()
        val sym = create_symbol_id(1)
        val inner = create_int_type(64, true)
        val middle = create_named_type(sym, [inner])
        val outer = create_named_type(sym, [middle])

        val t1 = create_named_type(sym, [middle])
        val t2 = create_named_type(sym, [middle])

        expect(checker.is_compatible(t1, t2)).to_be_true()

    it "handles deeply nested optionals":
        val checker = TypeChecker()
        val base = create_int_type(32, true)
        val opt1 = create_optional_type(base)
        val opt2 = create_optional_type(opt1)
        val opt3 = create_optional_type(opt2)

        val t1 = opt3
        val t2 = opt3

        expect(checker.is_compatible(t1, t2)).to_be_true()

    it "rejects mismatched nested optionals":
        val checker = TypeChecker()
        val base = create_int_type(32, true)
        val opt1 = create_optional_type(base)
        val opt2 = create_optional_type(opt1)

        expect(checker.is_compatible(opt1, opt2)).to_be_false()

    it "handles nested array types":
        val checker = TypeChecker()
        val inner = create_int_type(64, true)
        val arr1 = create_array_type(inner, 10)
        val arr2 = create_array_type(arr1, 5)

        val t1 = arr2
        val t2 = arr2

        expect(checker.is_compatible(t1, t2)).to_be_true()

    it "handles complex tuple types":
        val checker = TypeChecker()
        # Create tuple with mixed types: (i32, f64, Option<i64>)
        val elem1 = create_int_type(32, true)
        val elem2 = create_float_type(64)
        val elem3 = create_optional_type(create_int_type(64, true))

        # Note: Would need HirTypeKind.Tuple to fully test this
        # This validates the concept
        expect(checker.is_compatible(elem1, elem1)).to_equal(true)


# ============================================================================
# Test Group 9: Edge Cases - Boundary Conditions
# ============================================================================

describe "TypeChecker Edge Cases - Boundary Conditions":
    """
    ## Boundary Condition Testing

    Validates edge cases and boundary conditions.
    """

    it "handles zero-sized arrays":
        val checker = TypeChecker()
        val elem = create_int_type(32, true)
        val arr = create_array_type(elem, 0)

        expect(checker.is_compatible(arr, arr)).to_be_true()

    it "handles large type parameter indices":
        val checker = TypeChecker()
        val t1 = create_type_param("T", 999)
        val t2 = create_type_param("T", 999)

        expect(checker.is_compatible(t1, t2)).to_be_true()

    it "handles large inference variable IDs":
        val checker = TypeChecker()
        val t1 = create_infer_type(999999, InferKind.General)
        val concrete = create_int_type(64, true)

        expect(checker.is_compatible(t1, concrete)).to_be_true()


# ============================================================================
# Test Group 10: Error Paths
# ============================================================================

describe "MethodResolver Error Paths":
    """
    ## Error Path Coverage

    Validates error handling and edge cases in resolution.
    """

    it "handles empty method name in suggestions":
        expect(MethodResolver.is_similar("", "test")).to_be_false()
        expect(MethodResolver.is_similar("test", "")).to_be_false()

    it "handles single-character names":
        expect(MethodResolver.is_similar("a", "b")).to_be_false()
        expect(MethodResolver.is_similar("x", "x")).to_be_true()

    it "formats unknown types gracefully":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)
        val sym_id = create_symbol_id(999)  # Non-existent symbol
        val ty = create_named_type(sym_id, [])

        val formatted = resolver.format_type(ty)

        expect(formatted).to_equal("<named type>")

    it "accumulates errors without overflow":
        val symbols = create_empty_symbol_table()
        var resolver = MethodResolver.new(symbols)
        val span = create_span(0, 10)

        # Add many errors
        for i in 0..100:
            resolver.add_error("error {i}", span)

        expect(resolver.get_errors().len()).to_equal(100)  
    it "handles very long type names in formatting":
        val symbols = create_empty_symbol_table()
        val resolver = MethodResolver.new(symbols)

        # Create deeply nested array type
        var ty = create_int_type(64, true)
        for i in 0..10:
            ty = create_array_type(ty, 10)

        val formatted = resolver.format_type(ty)

        # Should format without crashing
        expect(formatted).to_contain("[")


# ============================================================================
# Helper Functions
# ============================================================================

fn create_int_type(bits: i32, signed: bool) -> HirType:
    """Create an integer HirType."""
    HirType(
        kind: HirTypeKind.Int(bits: bits, signed: signed),
        span: create_span(0, 0)
    )

fn create_float_type(bits: i32) -> HirType:
    """Create a float HirType."""
    HirType(
        kind: HirTypeKind.Float(bits: bits),
        span: create_span(0, 0)
    )

fn create_bool_type() -> HirType:
    """Create a bool HirType."""
    HirType(
        kind: HirTypeKind.Bool,
        span: create_span(0, 0)
    )

fn create_char_type() -> HirType:
    """Create a char HirType."""
    HirType(
        kind: HirTypeKind.Char,
        span: create_span(0, 0)
    )

fn create_string_type() -> HirType:
    """Create a string HirType."""
    HirType(
        kind: HirTypeKind.Str,
        span: create_span(0, 0)
    )

fn create_unit_type() -> HirType:
    """Create a unit HirType."""
    HirType(
        kind: HirTypeKind.Unit,
        span: create_span(0, 0)
    )

fn create_named_type(symbol: SymbolId, type_args: [HirType]) -> HirType:
    """Create a named HirType (class/struct/enum)."""
    HirType(
        kind: HirTypeKind.Named(sym: symbol, type_args: type_args),
        span: create_span(0, 0)
    )

fn create_ref_type(inner: HirType, is_mut: bool) -> HirType:
    """Create a reference HirType."""
    HirType(
        kind: HirTypeKind.Ref(inner: inner, is_mut: is_mut),
        span: create_span(0, 0)
    )

fn create_array_type(element_type: HirType, size: i32) -> HirType:
    """Create an array HirType."""
    HirType(
        kind: HirTypeKind.Array(element_type: element_type, size: Some(size)),
        span: create_span(0, 0)
    )

fn create_slice_type(element_type: HirType) -> HirType:
    """Create a slice HirType."""
    HirType(
        kind: HirTypeKind.Slice(element_type: element_type),
        span: create_span(0, 0)
    )

fn create_optional_type(inner: HirType) -> HirType:
    """Create an optional HirType."""
    HirType(
        kind: HirTypeKind.Optional(inner: inner),
        span: create_span(0, 0)
    )

fn create_type_param(name: text, index: i32) -> HirType:
    """Create a type parameter HirType."""
    HirType(
        kind: HirTypeKind.TypeParam(name: name, index: index),
        span: create_span(0, 0)
    )

fn create_infer_type(id: i32, kind: InferKind) -> HirType:
    """Create an inference variable HirType."""
    HirType(
        kind: HirTypeKind.Infer(id: id, kind: kind),
        span: create_span(0, 0)
    )

fn create_symbol_id(id: i64) -> SymbolId:
    """Create a SymbolId for testing."""
    SymbolId(id: id)

fn create_span(start: i32, end: i32) -> Span:
    """Create a Span for testing."""
    Span(start: start, end: end, line: 0, col: 0)

fn create_empty_symbol_table() -> SymbolTable:
    """Create an empty SymbolTable for testing."""
    SymbolTable(
        symbols: {},
        scopes: []
    )

fn create_symbol_table_with_class(name: text) -> SymbolTable:
    """Create a SymbolTable with a class definition."""
    var symbols: Dict<SymbolId, Symbol> = {}
    val class_sym_id = create_symbol_id(1)
    symbols[class_sym_id] = Symbol(
        id: class_sym_id,
        name: name,
        kind: SymbolKind.Class,
        type_: nil,
        is_public: true,
        is_mutable: false,
        span: create_span(0, 0)
    )
    SymbolTable(
        symbols: symbols,
        scopes: []
    )

fn create_symbol_table_with_struct(name: text) -> SymbolTable:
    """Create a SymbolTable with a struct definition."""
    var symbols: Dict<SymbolId, Symbol> = {}
    val struct_sym_id = create_symbol_id(1)
    symbols[struct_sym_id] = Symbol(
        id: struct_sym_id,
        name: name,
        kind: SymbolKind.Struct,
        type_: nil,
        is_public: true,
        is_mutable: false,
        span: create_span(0, 0)
    )
    SymbolTable(
        symbols: symbols,
        scopes: []
    )

fn create_symbol_table_with_enum(name: text) -> SymbolTable:
    """Create a SymbolTable with an enum definition."""
    var symbols: Dict<SymbolId, Symbol> = {}
    val enum_sym_id = create_symbol_id(1)
    symbols[enum_sym_id] = Symbol(
        id: enum_sym_id,
        name: name,
        kind: SymbolKind.Enum,
        type_: nil,
        is_public: true,
        is_mutable: false,
        span: create_span(0, 0)
    )
    SymbolTable(
        symbols: symbols,
        scopes: []
    )

fn create_var_expr(symbol: SymbolId) -> HirExpr:
    """Create a variable reference expression."""
    HirExpr(
        kind: HirExprKind.Var(symbol: symbol),
        type_: nil,
        span: create_span(0, 0)
    )

fn create_int_lit_expr(value: i64) -> HirExpr:
    """Create an integer literal expression."""
    HirExpr(
        kind: HirExprKind.IntLit(value: value, suffix: nil),
        type_: Some(create_int_type(64, true)),
        span: create_span(0, 0)
    )
