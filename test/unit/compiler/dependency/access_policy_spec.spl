# Feature: Access Policy and __init__.spl Boundary Enforcement
# Category: Dependency Tracker
# Status: In Progress

# Tests for access policy rules (Rules 1-4 from design)
#
# Rule 1: __init__.spl is the boundary wall
# Rule 2: No __init__.spl = freely accessible
# Rule 3: Export only in __init__.spl (enforced by ExportOutsideInit lint)
# Rule 4: #[bypass] attribute for container directories

use compiler.dependency.visibility.{
    Visibility, SymbolId, Symbol, ModDecl,
    DirManifest, ModuleContents,
    effective_visibility, visibility_meet, ancestor_visibility,
    AccessPolicy, effective_access_policy, check_access
}

describe "AccessPolicy":
    # Access control policy for directories.
    context "enum values":
        it "Open is open":
            val policy = AccessPolicy.Open
            expect policy.is_open()
            expect not policy.is_boundary()
            expect not policy.is_bypass()

        it "Boundary is boundary":
            val policy = AccessPolicy.Boundary
            expect not policy.is_open()
            expect policy.is_boundary()
            expect not policy.is_bypass()

        it "Bypass is bypass":
            val policy = AccessPolicy.Bypass
            expect not policy.is_open()
            expect not policy.is_boundary()
            expect policy.is_bypass()

    context "to_string":
        it "Open converts to string":
            expect AccessPolicy.Open.to_string() == "Open"

        it "Boundary converts to string":
            expect AccessPolicy.Boundary.to_string() == "Boundary"

        it "Bypass converts to string":
            expect AccessPolicy.Bypass.to_string() == "Bypass"

describe "effective_access_policy":
    # Determines access policy based on directory structure.
    context "Rule 2: No __init__.spl = freely accessible":
        it "returns Open when no __init__.spl":
            val policy = effective_access_policy(false, false)
            expect policy.is_open()

        it "returns Open regardless of bypass flag when no __init__.spl":
            val policy = effective_access_policy(false, true)
            expect policy.is_open()

    context "Rule 1: __init__.spl is the boundary wall":
        it "returns Boundary when __init__.spl exists without bypass":
            val policy = effective_access_policy(true, false)
            expect policy.is_boundary()

    context "Rule 4: #[bypass] attribute":
        it "returns Bypass when __init__.spl has bypass":
            val policy = effective_access_policy(true, true)
            expect policy.is_bypass()

describe "check_access":
    # Checks if access through a boundary is allowed.
    context "Open policy":
        it "allows any symbol access":
            val manifest = DirManifest.new("test")
            val sym = SymbolId.new("anything")
            expect check_access(manifest, AccessPolicy.Open, sym)

    context "Bypass policy":
        it "allows any symbol access (transparent)":
            val manifest = DirManifest.new("test")
            val sym = SymbolId.new("anything")
            expect check_access(manifest, AccessPolicy.Bypass, sym)

    context "Boundary policy":
        it "allows access to exported symbols":
            var manifest = DirManifest.new("test")
            val sym = SymbolId.new("PublicApi")
            manifest.add_export(sym)

            expect check_access(manifest, AccessPolicy.Boundary, sym)

        it "denies access to non-exported symbols":
            val manifest = DirManifest.new("test")
            val sym = SymbolId.new("InternalHelper")

            expect not check_access(manifest, AccessPolicy.Boundary, sym)

describe "Rule 1: __init__.spl boundary enforcement":
    # When a directory has __init__.spl, only exported symbols are accessible.
    it "exported symbol through boundary is accessible":
        var manifest = DirManifest.new("pkg")
        manifest.add_child(ModDecl.pub_decl("router"))
        val sym = SymbolId.new("Router")
        manifest.add_export(sym)

        var mc = ModuleContents.new()
        mc.add_symbol(Symbol.pub_symbol("Router"))

        # Symbol is public, module is public, and it's exported
        val vis = effective_visibility(manifest, "router", mc, sym)
        expect vis.is_public()

        # Access through boundary is allowed
        val policy = effective_access_policy(true, false)
        expect check_access(manifest, policy, sym)

    it "non-exported symbol through boundary is blocked":
        var manifest = DirManifest.new("pkg")
        manifest.add_child(ModDecl.pub_decl("internal"))
        # NOT exporting InternalHelper

        val sym = SymbolId.new("InternalHelper")
        val policy = effective_access_policy(true, false)
        expect not check_access(manifest, policy, sym)

describe "Rule 4: bypass directory validation":
    # Bypass directories are transparent and must only contain subdirectories.
    it "bypass directory allows pass-through access":
        val manifest = DirManifest.new("lib")
        val sym = SymbolId.new("anything")
        val policy = effective_access_policy(true, true)
        expect check_access(manifest, policy, sym)

    it "bypass directory ignores export list":
        var manifest = DirManifest.new("lib")
        # Even without exports, bypass allows access
        val sym = SymbolId.new("SomeType")
        val policy = effective_access_policy(true, true)
        expect check_access(manifest, policy, sym)

describe "Rule 6: bloodline restriction (model level)":
    # Symbols must flow upward through exports only.
    # A module's symbol is only externally visible if all three conditions are met.
    it "public symbol in public module without export is private":
        var manifest = DirManifest.new("pkg")
        manifest.add_child(ModDecl.pub_decl("mymod"))
        # NOT adding export

        var mc = ModuleContents.new()
        mc.add_symbol(Symbol.pub_symbol("Helper"))
        val sym = SymbolId.new("Helper")

        val vis = effective_visibility(manifest, "mymod", mc, sym)
        expect vis.is_private()

    it "public symbol in private module with export is private":
        var manifest = DirManifest.new("pkg")
        manifest.add_child(ModDecl.priv_decl("mymod"))
        val sym = SymbolId.new("Helper")
        manifest.add_export(sym)

        var mc = ModuleContents.new()
        mc.add_symbol(Symbol.pub_symbol("Helper"))

        val vis = effective_visibility(manifest, "mymod", mc, sym)
        expect vis.is_private()

    it "private symbol in public module with export is private":
        var manifest = DirManifest.new("pkg")
        manifest.add_child(ModDecl.pub_decl("mymod"))
        val sym = SymbolId.new("Secret")
        manifest.add_export(sym)

        var mc = ModuleContents.new()
        mc.add_symbol(Symbol.priv_symbol("Secret"))

        val vis = effective_visibility(manifest, "mymod", mc, sym)
        expect vis.is_private()

    it "private symbol in private module with export is private":
        var manifest = DirManifest.new("pkg")
        manifest.add_child(ModDecl.priv_decl("mymod"))
        val sym = SymbolId.new("Secret")
        manifest.add_export(sym)

        var mc = ModuleContents.new()
        mc.add_symbol(Symbol.priv_symbol("Secret"))

        val vis = effective_visibility(manifest, "mymod", mc, sym)
        expect vis.is_private()

# =========================================================================
# Intensive Coverage: Edge Cases and Combinations
# =========================================================================

describe "Boundary with multiple exports":
    # Tests boundary directories with multiple exported and non-exported symbols.
    it "allows access to first of multiple exports":
        var manifest = DirManifest.new("api")
        manifest.add_child(ModDecl.pub_decl("handlers"))
        val sym_a = SymbolId.new("GetHandler")
        val sym_b = SymbolId.new("PostHandler")
        manifest.add_export(sym_a)
        manifest.add_export(sym_b)

        val policy = effective_access_policy(true, false)
        expect check_access(manifest, policy, sym_a)

    it "allows access to second of multiple exports":
        var manifest = DirManifest.new("api")
        manifest.add_child(ModDecl.pub_decl("handlers"))
        val sym_a = SymbolId.new("GetHandler")
        val sym_b = SymbolId.new("PostHandler")
        manifest.add_export(sym_a)
        manifest.add_export(sym_b)

        val policy = effective_access_policy(true, false)
        expect check_access(manifest, policy, sym_b)

    it "denies access to symbol not in multi-export list":
        var manifest = DirManifest.new("api")
        manifest.add_child(ModDecl.pub_decl("handlers"))
        val sym_a = SymbolId.new("GetHandler")
        val sym_b = SymbolId.new("PostHandler")
        manifest.add_export(sym_a)
        manifest.add_export(sym_b)

        val sym_internal = SymbolId.new("InternalMiddleware")
        val policy = effective_access_policy(true, false)
        expect not check_access(manifest, policy, sym_internal)

describe "Boundary with multiple child modules":
    # Tests boundary directories with both public and private child modules.
    it "public symbol in first public module is visible":
        var manifest = DirManifest.new("pkg")
        manifest.add_child(ModDecl.pub_decl("public_mod"))
        manifest.add_child(ModDecl.priv_decl("private_mod"))
        val sym = SymbolId.new("PubType")
        manifest.add_export(sym)

        var mc = ModuleContents.new()
        mc.add_symbol(Symbol.pub_symbol("PubType"))

        val vis = effective_visibility(manifest, "public_mod", mc, sym)
        expect vis.is_public()

    it "public symbol in private child module is hidden":
        var manifest = DirManifest.new("pkg")
        manifest.add_child(ModDecl.pub_decl("public_mod"))
        manifest.add_child(ModDecl.priv_decl("private_mod"))
        val sym = SymbolId.new("PrivType")
        manifest.add_export(sym)

        var mc = ModuleContents.new()
        mc.add_symbol(Symbol.pub_symbol("PrivType"))

        val vis = effective_visibility(manifest, "private_mod", mc, sym)
        expect vis.is_private()

    it "symbol in non-existent module is private":
        var manifest = DirManifest.new("pkg")
        manifest.add_child(ModDecl.pub_decl("existing"))
        val sym = SymbolId.new("Ghost")
        manifest.add_export(sym)

        var mc = ModuleContents.new()
        mc.add_symbol(Symbol.pub_symbol("Ghost"))

        val vis = effective_visibility(manifest, "nonexistent", mc, sym)
        expect vis.is_private()

describe "Open policy edge cases":
    # Tests Open directories (no __init__.spl).
    it "Open allows access even with empty manifest":
        val manifest = DirManifest.new("utils")
        val sym = SymbolId.new("Helper")
        expect check_access(manifest, AccessPolicy.Open, sym)

    it "Open allows access to any symbol name":
        val manifest = DirManifest.new("utils")
        val sym1 = SymbolId.new("")
        val sym2 = SymbolId.new("a")
        val sym3 = SymbolId.new("very_long_symbol_name_here")
        expect check_access(manifest, AccessPolicy.Open, sym1)
        expect check_access(manifest, AccessPolicy.Open, sym2)
        expect check_access(manifest, AccessPolicy.Open, sym3)

    it "Open ignores export list even if populated":
        var manifest = DirManifest.new("utils")
        manifest.add_export(SymbolId.new("Exported"))

        # Non-exported symbol still accessible under Open policy
        val sym = SymbolId.new("NotExported")
        expect check_access(manifest, AccessPolicy.Open, sym)

describe "Bypass policy edge cases":
    # Tests Bypass directories (#[bypass]).
    it "Bypass allows access with empty manifest":
        val manifest = DirManifest.new("lib")
        val sym = SymbolId.new("Anything")
        expect check_access(manifest, AccessPolicy.Bypass, sym)

    it "Bypass allows access even if exports are defined":
        var manifest = DirManifest.new("lib")
        manifest.add_export(SymbolId.new("Something"))

        val sym = SymbolId.new("SomethingElse")
        expect check_access(manifest, AccessPolicy.Bypass, sym)

    it "Bypass allows access to exports too":
        var manifest = DirManifest.new("lib")
        val sym = SymbolId.new("ExportedToo")
        manifest.add_export(sym)

        expect check_access(manifest, AccessPolicy.Bypass, sym)

describe "Boundary policy edge cases":
    # Edge cases for Boundary policy (strict __init__.spl enforcement).
    it "Boundary with empty exports denies all":
        val manifest = DirManifest.new("sealed")
        val sym = SymbolId.new("Anything")
        expect not check_access(manifest, AccessPolicy.Boundary, sym)

    it "Boundary with matching export name allows":
        var manifest = DirManifest.new("pkg")
        val sym = SymbolId.new("Api")
        manifest.add_export(sym)

        expect check_access(manifest, AccessPolicy.Boundary, sym)

    it "Boundary distinguishes different symbol names":
        var manifest = DirManifest.new("pkg")
        manifest.add_export(SymbolId.new("Router"))

        val sym_ok = SymbolId.new("Router")
        val sym_bad = SymbolId.new("router")
        expect check_access(manifest, AccessPolicy.Boundary, sym_ok)
        expect not check_access(manifest, AccessPolicy.Boundary, sym_bad)

describe "Nested boundary simulation":
    # Simulates hierarchical access control with nested boundaries.
    # Tests that inner boundaries are independent of outer ones.
    it "inner boundary blocks even if outer allows":
        # Outer: boundary that exports InnerPkg
        var outer = DirManifest.new("outer")
        val inner_sym = SymbolId.new("InnerPkg")
        outer.add_export(inner_sym)

        # Inner: boundary that does NOT export DeepSecret
        var inner = DirManifest.new("inner")
        inner.add_child(ModDecl.pub_decl("deep"))
        # NOT exporting DeepSecret

        val deep_sym = SymbolId.new("DeepSecret")
        val outer_policy = effective_access_policy(true, false)
        val inner_policy = effective_access_policy(true, false)

        # Outer allows InnerPkg
        expect check_access(outer, outer_policy, inner_sym)
        # Inner blocks DeepSecret
        expect not check_access(inner, inner_policy, deep_sym)

    it "inner open allows even if outer is boundary":
        var outer = DirManifest.new("outer")
        val utils_sym = SymbolId.new("Utils")
        outer.add_export(utils_sym)

        # Inner has no __init__.spl (Open policy)
        val inner_policy = effective_access_policy(false, false)
        val any_sym = SymbolId.new("AnyHelper")

        # Inner is open, so access is allowed
        expect check_access(DirManifest.new("inner"), inner_policy, any_sym)

    it "bypass within boundary passes through":
        var outer = DirManifest.new("outer")
        val lib_sym = SymbolId.new("Lib")
        outer.add_export(lib_sym)

        # Inner has bypass
        val inner_policy = effective_access_policy(true, true)
        val deep_sym = SymbolId.new("DeepModule")

        # Bypass is transparent
        expect check_access(DirManifest.new("lib"), inner_policy, deep_sym)

describe "effective_visibility with ancestor_visibility combination":
    # Tests the interaction of effective_visibility with ancestor path traversal.
    it "fully public path with all conditions met":
        var manifest = DirManifest.new("pkg")
        manifest.add_child(ModDecl.pub_decl("mymod"))
        val sym = SymbolId.new("Widget")
        manifest.add_export(sym)

        var mc = ModuleContents.new()
        mc.add_symbol(Symbol.pub_symbol("Widget"))

        val eff_vis = effective_visibility(manifest, "mymod", mc, sym)
        val ancestor_path = [Visibility.Public, Visibility.Public, eff_vis]
        val final_vis = ancestor_visibility(ancestor_path)
        expect final_vis.is_public()

    it "private ancestor overrides public effective visibility":
        var manifest = DirManifest.new("pkg")
        manifest.add_child(ModDecl.pub_decl("mymod"))
        val sym = SymbolId.new("Widget")
        manifest.add_export(sym)

        var mc = ModuleContents.new()
        mc.add_symbol(Symbol.pub_symbol("Widget"))

        val eff_vis = effective_visibility(manifest, "mymod", mc, sym)
        # Even though effective visibility is public, a private ancestor overrides
        val ancestor_path = [Visibility.Private, eff_vis]
        val final_vis = ancestor_visibility(ancestor_path)
        expect final_vis.is_private()

describe "AccessPolicy all input combinations":
    # Exhaustive test of effective_access_policy truth table.
    it "false, false -> Open":
        expect effective_access_policy(false, false).is_open()

    it "false, true -> Open":
        expect effective_access_policy(false, true).is_open()

    it "true, false -> Boundary":
        expect effective_access_policy(true, false).is_boundary()

    it "true, true -> Bypass":
        expect effective_access_policy(true, true).is_bypass()

describe "check_access all policy-export combinations":
    # Cross-product of all policies with exported/non-exported symbols.
    it "Open + exported -> allowed":
        var manifest = DirManifest.new("d")
        val sym = SymbolId.new("X")
        manifest.add_export(sym)
        expect check_access(manifest, AccessPolicy.Open, sym)

    it "Open + non-exported -> allowed":
        val manifest = DirManifest.new("d")
        val sym = SymbolId.new("X")
        expect check_access(manifest, AccessPolicy.Open, sym)

    it "Bypass + exported -> allowed":
        var manifest = DirManifest.new("d")
        val sym = SymbolId.new("X")
        manifest.add_export(sym)
        expect check_access(manifest, AccessPolicy.Bypass, sym)

    it "Bypass + non-exported -> allowed":
        val manifest = DirManifest.new("d")
        val sym = SymbolId.new("X")
        expect check_access(manifest, AccessPolicy.Bypass, sym)

    it "Boundary + exported -> allowed":
        var manifest = DirManifest.new("d")
        val sym = SymbolId.new("X")
        manifest.add_export(sym)
        expect check_access(manifest, AccessPolicy.Boundary, sym)

    it "Boundary + non-exported -> denied":
        val manifest = DirManifest.new("d")
        val sym = SymbolId.new("X")
        expect not check_access(manifest, AccessPolicy.Boundary, sym)
