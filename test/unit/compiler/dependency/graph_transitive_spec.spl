# Tests for ImportGraph transitive imports (BFS algorithm)
# Task #18: BFS transitive closure

use compiler.dependency.graph.{ImportGraph}

describe "ImportGraph transitive_imports":
    context "empty and simple cases":
        it "module with no imports returns empty":
            var graph = ImportGraph.new()
            graph.add_module("a")

            val result = graph.transitive_imports("a")
            expect result.len() == 0

        it "non-existent module returns empty":
            val graph = ImportGraph.new()
            val result = graph.transitive_imports("nonexistent")
            expect result.len() == 0

        it "single direct import":
            var graph = ImportGraph.new()
            graph.add_use("a", "b")

            val result = graph.transitive_imports("a")
            expect result.len() == 1

        it "two direct imports":
            var graph = ImportGraph.new()
            graph.add_use("a", "b")
            graph.add_use("a", "c")

            val result = graph.transitive_imports("a")
            expect result.len() == 2

    context "transitive dependencies":
        it "linear chain includes all transitive deps":
            var graph = ImportGraph.new()
            graph.add_use("a", "b")
            graph.add_use("b", "c")
            graph.add_use("c", "d")

            val result = graph.transitive_imports("a")
            # a depends on b, c, d transitively
            expect result.len() == 3

            var has_b = false
            var has_c = false
            var has_d = false
            for module in result:
                if module == "b":
                    has_b = true
                if module == "c":
                    has_c = true
                if module == "d":
                    has_d = true

            expect has_b
            expect has_c
            expect has_d

        it "tree structure includes all descendants":
            var graph = ImportGraph.new()
            graph.add_use("a", "b")
            graph.add_use("a", "c")
            graph.add_use("b", "d")
            graph.add_use("c", "e")

            val result = graph.transitive_imports("a")
            # a depends on b, c, d, e
            expect result.len() == 4

        it "diamond structure - no duplicates":
            var graph = ImportGraph.new()
            graph.add_use("a", "b")
            graph.add_use("a", "c")
            graph.add_use("b", "d")
            graph.add_use("c", "d")

            val result = graph.transitive_imports("a")
            # a depends on b, c, d (d counted once)
            expect result.len() == 3

    context "partial dependencies":
        it "only includes reachable modules":
            var graph = ImportGraph.new()
            graph.add_use("a", "b")
            graph.add_use("b", "c")
            graph.add_use("x", "y")  # Separate component

            val result = graph.transitive_imports("a")
            # a only reaches b, c (not x, y)
            expect result.len() == 2

        it "middle of chain":
            var graph = ImportGraph.new()
            graph.add_use("a", "b")
            graph.add_use("b", "c")
            graph.add_use("c", "d")

            val result = graph.transitive_imports("b")
            # b depends on c, d (not a)
            expect result.len() == 2

        it "leaf module has no transitive imports":
            var graph = ImportGraph.new()
            graph.add_use("a", "b")
            graph.add_use("b", "c")

            val result = graph.transitive_imports("c")
            expect result.len() == 0

    context "cycles":
        it "handles self-loop":
            var graph = ImportGraph.new()
            graph.add_use("a", "a")

            val result = graph.transitive_imports("a")
            # Should include a (even though it's cyclic)
            expect result.len() == 1

        it "handles two-node cycle":
            var graph = ImportGraph.new()
            graph.add_use("a", "b")
            graph.add_use("b", "a")

            val result = graph.transitive_imports("a")
            # a -> b -> a (should terminate)
            expect result.len() >= 1

        it "handles larger cycle":
            var graph = ImportGraph.new()
            graph.add_use("a", "b")
            graph.add_use("b", "c")
            graph.add_use("c", "a")

            val result = graph.transitive_imports("a")
            # Should visit b, c without infinite loop
            expect result.len() >= 2

    context "complex graphs":
        it "complex dependency graph":
            var graph = ImportGraph.new()
            graph.add_use("a", "b")
            graph.add_use("a", "c")
            graph.add_use("b", "d")
            graph.add_use("c", "d")
            graph.add_use("c", "e")
            graph.add_use("d", "f")
            graph.add_use("e", "f")

            val result = graph.transitive_imports("a")
            # a depends on b, c, d, e, f
            expect result.len() == 5

        it "multiple paths to same module":
            var graph = ImportGraph.new()
            graph.add_use("a", "b")
            graph.add_use("a", "c")
            graph.add_use("a", "d")
            graph.add_use("b", "e")
            graph.add_use("c", "e")
            graph.add_use("d", "e")

            val result = graph.transitive_imports("a")
            # a depends on b, c, d, e (e counted once)
            expect result.len() == 4
