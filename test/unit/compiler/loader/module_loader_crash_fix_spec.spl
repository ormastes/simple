describe "Module Loader Crash Fix":
    it "skipped":
        skip("imports compiler modules - causes OOM via numbered directory resolution")

# # Module Loader Crash Fix Specification
# #
# # Tests for the 13 crash fixes in module_loader.spl:
# # - Corrected function call patterns (standalone fns, not method syntax)
# # - Corrected Dict method access (.contains_key, .remove)
# # - Corrected field access for nested struct methods
# # - Corrected self-referential function calls
# #
# # These tests verify that the wrong calling conventions have been fixed
# # and the correct patterns are used throughout the module loader.
# 
# use compiler.loader.module_loader.*
# use compiler.loader.jit_instantiator.*
# 
# # ============================================================================
# # Test Group 1: Standalone Function Call Convention
# # ============================================================================
# 
# describe "Standalone function call convention (crash fix)":
#     # Fix 1: moduleloaderconfig_default() — not ModuleLoaderConfig__default()
#     it "moduleloaderconfig_default returns valid config":
#         val config = moduleloaderconfig_default()
# 
#         expect(config.enable_jit).to_equal(true)
#         expect(config.enable_cache).to_equal(true)
#         expect(config.max_cache_size).to_equal(100)
#         expect(config.verbose).to_equal(false)
#         expect(config.hot_reload).to_equal(false)
# 
#     # Fix 2: moduleloader_new() — not ModuleLoader__new()
#     it "moduleloader_new accepts config and returns loader":
#         val config = moduleloaderconfig_default()
#         val loader = moduleloader_new(config)
# 
#         expect(loader.config.enable_jit).to_equal(true)
#         expect(loader.config.enable_cache).to_equal(true)
# 
#     # Fix 3: moduleloader_with_defaults() — calls moduleloader_new(moduleloaderconfig_default())
#     it "moduleloader_with_defaults creates loader without crash":
#         val loader = moduleloader_with_defaults()
# 
#         expect(loader.config.enable_jit).to_equal(true)
#         expect(loader.config.max_cache_size).to_equal(100)
# 
#     it "moduleloader_new with custom config":
#         val config = ModuleLoaderConfig(
#             enable_jit: false,
#             enable_cache: false,
#             max_cache_size: 25,
#             verbose: true,
#             hot_reload: true
#         )
#         val loader = moduleloader_new(config)
# 
#         expect(loader.config.enable_jit).to_equal(false)
#         expect(loader.config.enable_cache).to_equal(false)
#         expect(loader.config.max_cache_size).to_equal(25)
#         expect(loader.config.verbose).to_equal(true)
#         expect(loader.config.hot_reload).to_equal(true)
# 
# 
# # ============================================================================
# # Test Group 2: Dict .contains_key() Method Access
# # ============================================================================
# 
# describe "Dict .contains_key() method access (crash fix)":
#     # Fixes 4,5,8: self.modules.contains_key(path) — not self.modules_contains_key(modules, path)
#     # Fixes 6,7: self.global_symbols.contains_key(name) — not self.global_symbols_contains_key(...)
# 
#     it "Dict contains_key returns false for empty dict":
#         var d: Dict<text, i64> = {}
#         expect(d.contains_key("missing")).to_equal(false)
# 
#     it "Dict contains_key returns true for present key":
#         var d: Dict<text, i64> = {}
#         d["present"] = 42
#         expect(d.contains_key("present")).to_equal(true)
# 
#     it "Dict contains_key returns false for absent key in non-empty dict":
#         var d: Dict<text, i64> = {}
#         d["alpha"] = 1
#         d["beta"] = 2
#         expect(d.contains_key("gamma")).to_equal(false)
# 
#     it "modules dict contains_key pattern works":
#         # Simulates the fixed pattern: self.modules.contains_key(path)
#         var modules: Dict<text, text> = {}
#         val path = "/test/module.smf"
# 
#         expect(modules.contains_key(path)).to_equal(false)
# 
#         modules[path] = "loaded"
#         expect(modules.contains_key(path)).to_equal(true)
# 
#     it "global_symbols dict contains_key pattern works":
#         # Simulates: self.global_symbols.contains_key(name)
#         var global_symbols: Dict<text, text> = {}
#         val name = "my_function"
# 
#         expect(global_symbols.contains_key(name)).to_equal(false)
# 
#         global_symbols[name] = "symbol_data"
#         expect(global_symbols.contains_key(name)).to_equal(true)
# 
#     it "contains_key works with multiple entries":
#         var d: Dict<text, i64> = {}
#         d["a"] = 1
#         d["b"] = 2
#         d["c"] = 3
#         d["d"] = 4
#         d["e"] = 5
# 
#         expect(d.contains_key("a")).to_equal(true)
#         expect(d.contains_key("c")).to_equal(true)
#         expect(d.contains_key("e")).to_equal(true)
#         expect(d.contains_key("f")).to_equal(false)
#         expect(d.contains_key("z")).to_equal(false)
# 
# 
# # ============================================================================
# # Test Group 3: Dict .remove() Method Access
# # ============================================================================
# 
# describe "Dict .remove() method with reassignment (crash fix)":
#     # Fixes 9-13: self.global_symbols = self.global_symbols.remove(key)
#     #             self.modules = self.modules.remove(path)
#     # NOT: self.global_symbols_remove(global_symbols, key) — nonexistent function
# 
#     it "remove returns dict without the key":
#         var d: Dict<text, i64> = {}
#         d["a"] = 1
#         d["b"] = 2
#         d["c"] = 3
# 
#         d = d.remove("b")
# 
#         expect(d.contains_key("a")).to_equal(true)
#         expect(d.contains_key("b")).to_equal(false)
#         expect(d.contains_key("c")).to_equal(true)
# 
#     it "remove on missing key is safe":
#         var d: Dict<text, i64> = {}
#         d["a"] = 1
# 
#         d = d.remove("nonexistent")
# 
#         expect(d.contains_key("a")).to_equal(true)
# 
#     it "remove all entries leaves empty dict":
#         var d: Dict<text, i64> = {}
#         d["x"] = 10
#         d["y"] = 20
# 
#         d = d.remove("x")
#         d = d.remove("y")
# 
#         expect(d.contains_key("x")).to_equal(false)
#         expect(d.contains_key("y")).to_equal(false)
# 
#     it "remove and reassign pattern for global_symbols":
#         # Simulates the fixed pattern in moduleloader_unload
#         var global_symbols: Dict<text, text> = {}
#         global_symbols["sym_a"] = "owner_a"
#         global_symbols["sym_b"] = "owner_b"
#         global_symbols["sym_c"] = "owner_c"
# 
#         # Remove owned symbols (fixed pattern)
#         var owned = ["sym_a", "sym_c"]
#         for sym_name in owned:
#             global_symbols = global_symbols.remove(sym_name)
# 
#         expect(global_symbols.contains_key("sym_a")).to_equal(false)
#         expect(global_symbols.contains_key("sym_b")).to_equal(true)
#         expect(global_symbols.contains_key("sym_c")).to_equal(false)
# 
#     it "remove and reassign pattern for modules":
#         # Simulates: self.modules = self.modules.remove(path)
#         var modules: Dict<text, text> = {}
#         modules["/path/a.smf"] = "module_a"
#         modules["/path/b.smf"] = "module_b"
# 
#         modules = modules.remove("/path/a.smf")
# 
#         expect(modules.contains_key("/path/a.smf")).to_equal(false)
#         expect(modules.contains_key("/path/b.smf")).to_equal(true)
# 
#     it "sequential remove of multiple keys":
#         var d: Dict<text, i64> = {}
#         d["k1"] = 1
#         d["k2"] = 2
#         d["k3"] = 3
#         d["k4"] = 4
#         d["k5"] = 5
# 
#         d = d.remove("k2")
#         d = d.remove("k4")
# 
#         expect(d.contains_key("k1")).to_equal(true)
#         expect(d.contains_key("k2")).to_equal(false)
#         expect(d.contains_key("k3")).to_equal(true)
#         expect(d.contains_key("k4")).to_equal(false)
#         expect(d.contains_key("k5")).to_equal(true)
# 
# 
# # ============================================================================
# # Test Group 4: Field Access for Nested Struct Methods
# # ============================================================================
# 
# describe "Field access for nested struct methods (crash fix)":
#     # Fix: self.jit.try_jit_instantiate(name) — not self.jit_try_jit_instantiate(jit, name)
#     # Fix: self.jit.drop_cached_symbol(name) — not self.jit_drop_cached_symbol(jit, name)
# 
#     it "nested field access works on struct":
#         # Simulates the pattern: accessing a method on a field of a struct
#         val config = ModuleLoaderConfig(
#             enable_jit: true,
#             enable_cache: true,
#             max_cache_size: 100,
#             verbose: false,
#             hot_reload: false
#         )
#         val loader = moduleloader_new(config)
# 
#         # Verify nested field access pattern works
#         expect(loader.config.enable_jit).to_equal(true)
#         expect(loader.config.max_cache_size).to_equal(100)
# 
#     it "nested field access on jit config":
#         val config = moduleloaderconfig_default()
#         val loader = moduleloader_new(config)
# 
#         # Access jit field properties (validates self.jit.X pattern)
#         # The jit field is a JitInstantiator struct
#         expect(loader.config.enable_jit).to_equal(true)
# 
# 
# # ============================================================================
# # Test Group 5: Self-referential Standalone Function Calls
# # ============================================================================
# 
# describe "Self-referential standalone function calls (crash fix)":
#     # Fix: moduleloader_resolve_symbol(self, mangled) — not self.resolve_symbol(mangled)
#     # Fix: moduleloader_load(self, path) — not self.load(path)
# 
#     it "standalone fn pattern with explicit self":
#         # Demonstrates the correct pattern: fn_name(self, arg)
#         # vs the wrong pattern: self.fn_name(arg)
#         val config = moduleloaderconfig_default()
#         val loader = moduleloader_new(config)
# 
#         # moduleloader_resolve_symbol is a standalone fn(self, name)
#         val result = moduleloader_resolve_symbol(loader, "nonexistent_symbol")
#         # Should return NotFound since no modules are loaded
#         expect(result.?).to_equal(true)
# 
# 
# # ============================================================================
# # Test Group 6: ModuleLoader Initialization Correctness
# # ============================================================================
# 
# describe "ModuleLoader initialization correctness":
#     it "loader starts with empty modules dict":
#         val loader = moduleloader_with_defaults()
#         expect(loader.modules.contains_key("anything")).to_equal(false)
# 
#     it "loader starts with empty global_symbols dict":
#         val loader = moduleloader_with_defaults()
#         expect(loader.global_symbols.contains_key("anything")).to_equal(false)
# 
#     it "loader config propagates enable_jit false":
#         val config = ModuleLoaderConfig(
#             enable_jit: false,
#             enable_cache: true,
#             max_cache_size: 200,
#             verbose: false,
#             hot_reload: false
#         )
#         val loader = moduleloader_new(config)
#         expect(loader.config.enable_jit).to_equal(false)
#         expect(loader.config.max_cache_size).to_equal(200)
# 
#     it "loader config propagates hot_reload true":
#         val config = ModuleLoaderConfig(
#             enable_jit: true,
#             enable_cache: true,
#             max_cache_size: 100,
#             verbose: false,
#             hot_reload: true
#         )
#         val loader = moduleloader_new(config)
#         expect(loader.config.hot_reload).to_equal(true)
# 
# 
# # ============================================================================
# # Test Group 7: LoadResult and SymbolResult Enum Construction
# # ============================================================================
# 
# describe "LoadResult enum construction":
#     it "creates Error variant":
#         val result = LoadResult.Error(message: "file not found")
#         expect(result.?).to_equal(true)
# 
#     it "creates Success variant with module":
#         val module = LoadedModule(
#             path: "test.smf",
#             symbols: {},
#             load_time: 0,
#             version: 1
#         )
#         val result = LoadResult.Success(module: module)
#         expect(result.?).to_equal(true)
# 
#     it "creates AlreadyLoaded variant":
#         val module = LoadedModule(
#             path: "test.smf",
#             symbols: {},
#             load_time: 0,
#             version: 1
#         )
#         val result = LoadResult.AlreadyLoaded(module: module)
#         expect(result.?).to_equal(true)
# 
# describe "SymbolResult enum construction":
#     it "creates NotFound variant":
#         val result = SymbolResult.NotFound(name: "missing_fn")
#         expect(result.?).to_equal(true)
# 
#     it "creates Error variant":
#         val result = SymbolResult.Error(message: "compilation failed")
#         expect(result.?).to_equal(true)
# 
# 
# # ============================================================================
# # Test Group 8: LoadedSymbol and LoadedModule Struct Construction
# # ============================================================================
# 
# describe "LoadedSymbol struct construction":
#     it "creates with all fields including file_offset":
#         val sym = LoadedSymbol(
#             name: "my_fn",
#             address: 0x4000,
#             size: 256,
#             ty: SymbolType.Function,
#             is_jit: false,
#             file_offset: 1024
#         )
# 
#         expect(sym.name).to_equal("my_fn")
#         expect(sym.address).to_equal(0x4000)
#         expect(sym.size).to_equal(256)
#         expect(sym.is_jit).to_equal(false)
#         expect(sym.file_offset).to_equal(1024)
# 
#     it "creates JIT symbol":
#         val sym = LoadedSymbol(
#             name: "jit_fn",
#             address: 0x8000,
#             size: 128,
#             ty: SymbolType.Function,
#             is_jit: true,
#             file_offset: 0
#         )
# 
#         expect(sym.is_jit).to_equal(true)
#         expect(sym.file_offset).to_equal(0)
# 
# describe "LoadedModule struct construction":
#     it "creates with empty symbols":
#         val module = LoadedModule(
#             path: "/test/empty.smf",
#             symbols: {},
#             load_time: 1000,
#             version: 1
#         )
# 
#         expect(module.path).to_equal("/test/empty.smf")
#         expect(module.load_time).to_equal(1000)
#         expect(module.version).to_equal(1)
# 
#     it "creates with multiple symbols":
#         var symbols: Dict<text, LoadedSymbol> = {}
#         symbols["fn_a"] = LoadedSymbol(
#             name: "fn_a",
#             address: 0x1000,
#             size: 50,
#             ty: SymbolType.Function,
#             is_jit: false,
#             file_offset: 0
#         )
#         symbols["fn_b"] = LoadedSymbol(
#             name: "fn_b",
#             address: 0x2000,
#             size: 75,
#             ty: SymbolType.Function,
#             is_jit: true,
#             file_offset: 100
#         )
# 
#         val module = LoadedModule(
#             path: "/test/multi.smf",
#             symbols: symbols,
#             load_time: 2000,
#             version: 2
#         )
# 
#         expect(module.symbols.contains_key("fn_a")).to_equal(true)
#         expect(module.symbols.contains_key("fn_b")).to_equal(true)
#         expect(module.symbols.contains_key("fn_c")).to_equal(false)
# 
# 
# # ============================================================================
# # Test Group 9: mangle_name Helper
# # ============================================================================
# 
# describe "mangle_name helper":
#     it "returns base name for empty type_args":
#         val result = mangle_name("my_func", [])
#         expect(result).to_equal("my_func")
# 
# 
# # ============================================================================
# # Test Group 10: Unload Pattern Correctness
# # ============================================================================
# 
# describe "Unload dict cleanup pattern":
#     # Tests the fixed pattern used in moduleloader_unload:
#     # 1. Collect owned symbols into a list
#     # 2. Remove them from global_symbols via .remove() with reassignment
#     # 3. Remove module from modules via .remove() with reassignment
# 
#     it "collect and remove owned symbols pattern":
#         fn run_collect_remove() -> bool:
#             var global_symbols: Dict<text, text> = {}
#             global_symbols["sym1"] = "module_a"
#             global_symbols["sym2"] = "module_b"
#             global_symbols["sym3"] = "module_a"
#             global_symbols["sym4"] = "module_c"
#             global_symbols["sym5"] = "module_a"
# 
#             # Collect symbols owned by "module_a"
#             var owned: [text] = []
#             for _item in global_symbols:
#                 val sym_name = _item[0]
#                 val owner = _item[1]
#                 if owner == "module_a":
#                     owned = owned.push(sym_name)
# 
#             # Remove owned symbols (fixed pattern)
#             for sym_name in owned:
#                 global_symbols = global_symbols.remove(sym_name)
# 
#             # Verify only non-owned remain
#             val a_gone = not global_symbols.contains_key("sym1")
#             val b_stays = global_symbols.contains_key("sym2")
#             val c_gone = not global_symbols.contains_key("sym3")
#             val d_stays = global_symbols.contains_key("sym4")
#             val e_gone = not global_symbols.contains_key("sym5")
# 
#             a_gone and b_stays and c_gone and d_stays and e_gone
# 
#         expect(run_collect_remove()).to_equal(true)
# 
#     it "module removal after symbol cleanup":
#         fn run_module_removal() -> bool:
#             var modules: Dict<text, text> = {}
#             modules["/path/a.smf"] = "data_a"
#             modules["/path/b.smf"] = "data_b"
#             modules["/path/c.smf"] = "data_c"
# 
#             # Unload module b
#             val path = "/path/b.smf"
#             if modules.contains_key(path):
#                 modules = modules.remove(path)
# 
#             val removed = not modules.contains_key("/path/b.smf")
#             val a_kept = modules.contains_key("/path/a.smf")
#             val c_kept = modules.contains_key("/path/c.smf")
# 
#             removed and a_kept and c_kept
# 
#         expect(run_module_removal()).to_equal(true)
# 
#     it "JIT symbols collection and removal pattern":
#         fn run_jit_removal() -> bool:
#             var global_symbols: Dict<text, text> = {}
#             global_symbols["fn$Vec$i64"] = "__jit__"
#             global_symbols["fn$List$text"] = "__jit__"
#             global_symbols["regular_fn"] = "module_x"
# 
#             # Simulate jit_symbols_to_free list
#             var jit_symbols_to_free = ["fn$Vec$i64", "fn$List$text"]
# 
#             for jit_sym in jit_symbols_to_free:
#                 global_symbols = global_symbols.remove(jit_sym)
# 
#             val jit1_gone = not global_symbols.contains_key("fn$Vec$i64")
#             val jit2_gone = not global_symbols.contains_key("fn$List$text")
#             val regular_kept = global_symbols.contains_key("regular_fn")
# 
#             jit1_gone and jit2_gone and regular_kept
# 
#         expect(run_jit_removal()).to_equal(true)
# 
#     it "full unload sequence: collect, remove symbols, remove module":
#         fn run_full_unload() -> bool:
#             var modules: Dict<text, text> = {}
#             var global_symbols: Dict<text, text> = {}
# 
#             # Setup: two modules with symbols
#             modules["/a.smf"] = "mod_a"
#             modules["/b.smf"] = "mod_b"
#             global_symbols["fn1"] = "/a.smf"
#             global_symbols["fn2"] = "/a.smf"
#             global_symbols["fn3"] = "/b.smf"
# 
#             val unload_path = "/a.smf"
# 
#             # Step 1: Check module exists
#             if not modules.contains_key(unload_path):
#                 return false
# 
#             # Step 2: Collect owned symbols
#             var owned: [text] = []
#             for _item in global_symbols:
#                 val sym_name = _item[0]
#                 val owner = _item[1]
#                 if owner == unload_path:
#                     owned = owned.push(sym_name)
# 
#             # Step 3: Remove symbols
#             for sym_name in owned:
#                 global_symbols = global_symbols.remove(sym_name)
# 
#             # Step 4: Remove module
#             modules = modules.remove(unload_path)
# 
#             # Verify
#             val mod_removed = not modules.contains_key("/a.smf")
#             val mod_b_kept = modules.contains_key("/b.smf")
#             val fn1_removed = not global_symbols.contains_key("fn1")
#             val fn2_removed = not global_symbols.contains_key("fn2")
#             val fn3_kept = global_symbols.contains_key("fn3")
# 
#             mod_removed and mod_b_kept and fn1_removed and fn2_removed and fn3_kept
# 
#         expect(run_full_unload()).to_equal(true)
