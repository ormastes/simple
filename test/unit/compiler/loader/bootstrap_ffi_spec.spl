# # Bootstrap FFI Specification
#
# **Feature IDs:** #TBD
# **Category:** Compiler
# **Status:** In Progress
#
# ## Overview
#
# Tests Cranelift FFI infrastructure by creating a module via JIT
# and testing runtime FFI functions.

use std.spec
use compiler.ffi.{rt_exec, rt_file_hash}


extern fn cranelift_module_new(name: text, target: i64) -> i64
extern fn rt_cranelift_finalize_module(module: i64) -> i64
extern fn cranelift_free_module(module: i64)
extern fn cranelift_new_signature(call_conv: i64) -> i64
extern fn cranelift_sig_set_return(sig: i64, type_: i64)

fn cranelift_finalize_module(module: i64) -> i64:
    rt_cranelift_finalize_module(module)

fn test_create_module() -> bool:
    val CL_TYPE_I64 = 4
    val CL_TARGET_X86_64 = 0
    val module = cranelift_module_new("test_module", CL_TARGET_X86_64)
    if module == 0:
        return false
    val sig = cranelift_new_signature(0)
    if sig == 0:
        cranelift_free_module(module)
        return false
    cranelift_sig_set_return(sig, CL_TYPE_I64)
    cranelift_free_module(module)
    true

fn test_exec_ffi() -> bool:
    val result = rt_exec("echo 'Hello from rt_exec'")
    result == 0

fn test_file_hash_ffi() -> bool:
    val hash = rt_file_hash("/bin/sh")
    hash.len() > 0


fn skip_on_interpreter(name: text, block: fn()):
    print "    it {name} ... skipped (interpreter mode)"

describe "Bootstrap FFI":
    it "creates a Cranelift module":
        skip_on_interpreter "requires native Cranelift backend":
            expect(test_create_module()).to_equal(true)

    it "rt_exec FFI works":
        skip_on_interpreter "requires native runtime":
            expect(test_exec_ffi()).to_equal(true)

    it "rt_file_hash FFI works":
        skip_on_interpreter "requires native runtime":
            expect(test_file_hash_ffi()).to_equal(true)
