# Resource Lifecycle Manager Specification
#
# Tests the resource lifecycle manager's logic using mock implementations.
# The actual compiler modules depend on FFI/loader internals not available
# in interpreter mode, so we mock the core abstractions here.
#
# **Feature IDs:** #2001-2010
# **Category:** Infrastructure
# **Design:** doc/design/resource_lifecycle_manager_design.md

# ============================================================================
# Mock LifecycleManager — parallel arrays for module tracking
# ============================================================================

var lm_module_paths: [text] = []
var lm_module_symbols: [text] = []       # "module_path:symbol_name" pairs
var lm_jit_symbols: [text] = []
var lm_jit_origins: [text] = []
var lm_smf_refs: [text] = []             # "module_path:smf_path" pairs
var lm_metadata_paths: [text] = []       # "module_path:metadata_path" pairs

fn lm_reset():
    lm_module_paths = []
    lm_module_symbols = []
    lm_jit_symbols = []
    lm_jit_origins = []
    lm_smf_refs = []
    lm_metadata_paths = []

fn lm_on_module_load(path: text):
    lm_module_paths = lm_module_paths + [path]

fn lm_is_tracked(path: text) -> bool:
    lm_module_paths.index_of(path) >= 0

fn lm_tracked_module_count() -> i64:
    lm_module_paths.len()

fn lm_on_symbol_mapped(module_path: text, symbol: text):
    lm_module_symbols = lm_module_symbols + [module_path + ":" + symbol]

fn lm_on_jit_triggered(module_path: text, jit_sym: text):
    lm_jit_symbols = lm_jit_symbols + [jit_sym]
    lm_jit_origins = lm_jit_origins + [module_path]

fn lm_tracked_jit_count() -> i64:
    lm_jit_symbols.len()

fn lm_get_jit_origin(jit_sym: text) -> text:
    val idx = lm_jit_symbols.index_of(jit_sym)
    if idx >= 0:
        return lm_jit_origins[idx]
    ""

fn lm_on_metadata_loaded(module_path: text, meta_path: text):
    lm_metadata_paths = lm_metadata_paths + [module_path + ":" + meta_path]

fn lm_on_smf_accessed(module_path: text, smf_path: text):
    lm_smf_refs = lm_smf_refs + [module_path + ":" + smf_path]

fn lm_get_symbols_for(module_path: text) -> i64:
    var count = 0
    var i = 0
    while i < lm_module_symbols.len():
        if lm_module_symbols[i].starts_with(module_path + ":"):
            count = count + 1
        i = i + 1
    count

fn lm_unload_module(path: text):
    # Remove module from registry
    val idx = lm_module_paths.index_of(path)
    if idx < 0:
        return
    var new_paths: [text] = []
    var i = 0
    while i < lm_module_paths.len():
        if i != idx:
            new_paths = new_paths + [lm_module_paths[i]]
        i = i + 1
    lm_module_paths = new_paths
    # Remove symbols for this module
    var new_symbols: [text] = []
    i = 0
    while i < lm_module_symbols.len():
        if not lm_module_symbols[i].starts_with(path + ":"):
            new_symbols = new_symbols + [lm_module_symbols[i]]
        i = i + 1
    lm_module_symbols = new_symbols
    # Remove JIT symbols for this module
    var new_jit: [text] = []
    var new_origins: [text] = []
    i = 0
    while i < lm_jit_symbols.len():
        if lm_jit_origins[i] != path:
            new_jit = new_jit + [lm_jit_symbols[i]]
            new_origins = new_origins + [lm_jit_origins[i]]
        i = i + 1
    lm_jit_symbols = new_jit
    lm_jit_origins = new_origins
    # Remove SMF refs for this module
    var new_smf: [text] = []
    i = 0
    while i < lm_smf_refs.len():
        if not lm_smf_refs[i].starts_with(path + ":"):
            new_smf = new_smf + [lm_smf_refs[i]]
        i = i + 1
    lm_smf_refs = new_smf
    # Remove metadata for this module
    var new_meta: [text] = []
    i = 0
    while i < lm_metadata_paths.len():
        if not lm_metadata_paths[i].starts_with(path + ":"):
            new_meta = new_meta + [lm_metadata_paths[i]]
        i = i + 1
    lm_metadata_paths = new_meta

fn lm_destroy():
    lm_reset()

# ============================================================================
# Mock SmfCacheManager — ref-counted cache
# ============================================================================

var smf_paths: [text] = []
var smf_counts: [i64] = []

fn smf_reset():
    smf_paths = []
    smf_counts = []

fn smf_inc(path: text):
    val idx = smf_paths.index_of(path)
    if idx >= 0:
        fn set_i64(arr: [i64], at: i64, val_: i64) -> [i64]:
            var result: [i64] = []
            var i = 0
            while i < arr.len():
                if i == at:
                    result = result + [val_]
                else:
                    result = result + [arr[i]]
                i = i + 1
            result
        smf_counts = set_i64(smf_counts, idx, smf_counts[idx] + 1)
    else:
        smf_paths = smf_paths + [path]
        smf_counts = smf_counts + [1]

fn smf_dec(path: text):
    val idx = smf_paths.index_of(path)
    if idx < 0:
        return
    val new_count = smf_counts[idx] - 1
    if new_count <= 0:
        # Evict
        var new_paths: [text] = []
        var new_counts: [i64] = []
        var i = 0
        while i < smf_paths.len():
            if i != idx:
                new_paths = new_paths + [smf_paths[i]]
                new_counts = new_counts + [smf_counts[i]]
            i = i + 1
        smf_paths = new_paths
        smf_counts = new_counts
    else:
        fn set_i64_2(arr: [i64], at: i64, val_: i64) -> [i64]:
            var result: [i64] = []
            var i = 0
            while i < arr.len():
                if i == at:
                    result = result + [val_]
                else:
                    result = result + [arr[i]]
                i = i + 1
            result
        smf_counts = set_i64_2(smf_counts, idx, new_count)

fn smf_get_ref_count(path: text) -> i64:
    val idx = smf_paths.index_of(path)
    if idx >= 0:
        return smf_counts[idx]
    0

fn smf_tracked_count() -> i64:
    smf_paths.len()

fn smf_force_clear():
    smf_paths = []
    smf_counts = []

# ============================================================================
# Test Group 1: ResourceLifecycleManager Registration
# ============================================================================

describe "ResourceLifecycleManager":

    describe "module tracking":
        it "tracks a new module after on_module_load":
            lm_reset()
            lm_on_module_load("/test/mod_a.smf")
            expect(lm_is_tracked("/test/mod_a.smf")).to_equal(true)

        it "reports false for untracked module":
            lm_reset()
            expect(lm_is_tracked("/nonexistent")).to_equal(false)

        it "counts multiple tracked modules":
            lm_reset()
            lm_on_module_load("/a.smf")
            lm_on_module_load("/b.smf")
            expect(lm_tracked_module_count()).to_equal(2)

    describe "symbol and JIT tracking":
        it "records symbols mapped for a module":
            lm_reset()
            lm_on_module_load("/mod.smf")
            lm_on_symbol_mapped("/mod.smf", "func_a")
            lm_on_symbol_mapped("/mod.smf", "func_b")
            expect(lm_get_symbols_for("/mod.smf")).to_equal(2)

        it "records JIT symbol origin for unload":
            lm_reset()
            lm_on_module_load("/mod.smf")
            lm_on_jit_triggered("/mod.smf", "Vec$i64_push")
            expect(lm_tracked_jit_count()).to_equal(1)
            val origin = lm_get_jit_origin("Vec$i64_push")
            expect(origin).to_equal("/mod.smf")

        it "returns empty for unknown JIT symbol":
            lm_reset()
            val origin = lm_get_jit_origin("nonexistent")
            expect(origin).to_equal("")

    describe "metadata and SMF tracking":
        it "records metadata path for module":
            lm_reset()
            lm_on_module_load("/mod.smf")
            lm_on_metadata_loaded("/mod.smf", "/mod.smf")
            expect(lm_is_tracked("/mod.smf")).to_equal(true)

        it "tracks SMF cache access":
            lm_reset()
            smf_reset()
            lm_on_module_load("/mod.smf")
            lm_on_smf_accessed("/mod.smf", "/shared.smf")
            smf_inc("/shared.smf")
            expect(smf_get_ref_count("/shared.smf")).to_equal(1)

# ============================================================================
# Test Group 2: SmfCacheManager Ref Counting
# ============================================================================

describe "SmfCacheManager":

    describe "ref counting":
        it "starts at zero ref count":
            smf_reset()
            expect(smf_get_ref_count("/test.smf")).to_equal(0)

        it "increments ref count":
            smf_reset()
            smf_inc("/test.smf")
            expect(smf_get_ref_count("/test.smf")).to_equal(1)

        it "increments multiple times":
            smf_reset()
            smf_inc("/test.smf")
            smf_inc("/test.smf")
            smf_inc("/test.smf")
            expect(smf_get_ref_count("/test.smf")).to_equal(3)

        it "decrements ref count":
            smf_reset()
            smf_inc("/test.smf")
            smf_inc("/test.smf")
            smf_dec("/test.smf")
            expect(smf_get_ref_count("/test.smf")).to_equal(1)

        it "evicts when ref count reaches zero":
            smf_reset()
            smf_inc("/test.smf")
            smf_dec("/test.smf")
            expect(smf_tracked_count()).to_equal(0)

    describe "multi-path tracking":
        it "tracks independent paths":
            smf_reset()
            smf_inc("/a.smf")
            smf_inc("/b.smf")
            expect(smf_tracked_count()).to_equal(2)

        it "force clear resets all":
            smf_reset()
            smf_inc("/a.smf")
            smf_inc("/b.smf")
            smf_force_clear()
            expect(smf_tracked_count()).to_equal(0)

        it "ignores dec on untracked path":
            smf_reset()
            smf_dec("/nonexistent.smf")
            expect(smf_tracked_count()).to_equal(0)
