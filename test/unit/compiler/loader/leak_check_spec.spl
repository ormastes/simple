# Resource Lifecycle — Load/Unload Cycle Tests
#
# Integration-level tests for load/unload cycles using mock implementations.
# Verifies that resources are correctly tracked and freed per the
# ResourceLifecycleManager design (doc/design/resource_lifecycle_manager_design.md).
#
# Tests cover:
#   - Load/unload cycle: resources tracked then freed
#   - Hot-reload cycle: old resources freed before new ones registered
#   - Multiple modules sharing SMF: ref-count prevents premature eviction
#   - JIT symbol attribution: JIT symbols freed with originating module
#   - Full teardown: zero live resources after destroy()

# ============================================================================
# Array helper functions (needed because .push/.remove_at don't persist
# when called from module functions invoked inside it-block closures)
# ============================================================================

fn arr_remove_text(arr: [text], idx: i64) -> [text]:
    var result: [text] = []
    var i = 0
    while i < arr.len():
        if i != idx:
            result = result + [arr[i]]
        i = i + 1
    result

fn arr_remove_i64(arr: [i64], idx: i64) -> [i64]:
    var result: [i64] = []
    var i = 0
    while i < arr.len():
        if i != idx:
            result = result + [arr[i]]
        i = i + 1
    result

fn arr_set_i64(arr: [i64], idx: i64, val_: i64) -> [i64]:
    var result: [i64] = []
    var i = 0
    while i < arr.len():
        if i == idx:
            result = result + [val_]
        else:
            result = result + [arr[i]]
        i = i + 1
    result

# ============================================================================
# Mock exec mapper (replaces SharedExecMapper)
# Tracks which symbols are currently mapped
# ============================================================================

var mock_mapped_symbols: [text] = []
var mock_freed_symbols: [text] = []

fn mock_exec_map_symbol(owner: text, symbol: text):
    mock_mapped_symbols = mock_mapped_symbols + [symbol]

fn mock_exec_unmap_symbol(symbol: text):
    val idx = mock_mapped_symbols.index_of(symbol)
    if idx >= 0:
        mock_mapped_symbols = arr_remove_text(mock_mapped_symbols, idx)
    mock_freed_symbols = mock_freed_symbols + [symbol]

fn mock_exec_unmap_owner(owner: text):
    pass_dn  # Owner-level unmap; symbols tracked separately

fn mock_exec_mapped_count() -> i64:
    mock_mapped_symbols.len()

fn mock_exec_was_freed(symbol: text) -> bool:
    mock_freed_symbols.index_of(symbol) >= 0

fn mock_exec_reset():
    mock_mapped_symbols = []
    mock_freed_symbols = []

# ============================================================================
# Mock SMF ref counter (replaces SmfCacheManager)
# Tracks per-path ref counts
# ============================================================================

var mock_smf_paths: [text] = []
var mock_smf_counts: [i64] = []
var mock_smf_evicted: [text] = []

fn mock_smf_inc(path: text):
    val idx = mock_smf_paths.index_of(path)
    if idx >= 0:
        mock_smf_counts = arr_set_i64(mock_smf_counts, idx, mock_smf_counts[idx] + 1)
    else:
        mock_smf_paths = mock_smf_paths + [path]
        mock_smf_counts = mock_smf_counts + [1]

fn mock_smf_dec(path: text):
    val idx = mock_smf_paths.index_of(path)
    if idx >= 0:
        val new_count = mock_smf_counts[idx] - 1
        if new_count <= 0:
            mock_smf_evicted = mock_smf_evicted + [path]
            mock_smf_paths = arr_remove_text(mock_smf_paths, idx)
            mock_smf_counts = arr_remove_i64(mock_smf_counts, idx)
        else:
            mock_smf_counts = arr_set_i64(mock_smf_counts, idx, new_count)

fn mock_smf_get_count(path: text) -> i64:
    val idx = mock_smf_paths.index_of(path)
    if idx >= 0:
        mock_smf_counts[idx]
    else:
        0

fn mock_smf_was_evicted(path: text) -> bool:
    mock_smf_evicted.index_of(path) >= 0

fn mock_smf_active_count() -> i64:
    mock_smf_paths.len()

fn mock_smf_reset():
    mock_smf_paths = []
    mock_smf_counts = []
    mock_smf_evicted = []

# ============================================================================
# Mock Ownership Registry
# Tracks per-module resource ownership
# ============================================================================

struct MockOwnedResources:
    module_path: text
    exec_symbols: [text]
    jit_symbols: [text]
    smf_paths: [text]

var mock_registry_paths: [text] = []
var mock_registry_owned: [MockOwnedResources] = []
var mock_jit_origin_syms: [text] = []
var mock_jit_origin_mods: [text] = []

fn registry_set_owned_at(idx: i64, owned: MockOwnedResources):
    var new_owned: [MockOwnedResources] = []
    var i = 0
    while i < mock_registry_owned.len():
        if i == idx:
            new_owned = new_owned + [owned]
        else:
            new_owned = new_owned + [mock_registry_owned[i]]
        i = i + 1
    mock_registry_owned = new_owned

fn mock_registry_register(path: text):
    mock_registry_paths = mock_registry_paths + [path]
    mock_registry_owned = mock_registry_owned + [MockOwnedResources(
        module_path: path,
        exec_symbols: [],
        jit_symbols: [],
        smf_paths: []
    )]

fn mock_registry_is_tracked(path: text) -> bool:
    mock_registry_paths.index_of(path) >= 0

fn mock_registry_module_count() -> i64:
    mock_registry_paths.len()

fn mock_registry_add_exec_symbol(path: text, symbol: text):
    val idx = mock_registry_paths.index_of(path)
    if idx >= 0:
        val old = mock_registry_owned[idx]
        val updated = MockOwnedResources(
            module_path: old.module_path,
            exec_symbols: old.exec_symbols + [symbol],
            jit_symbols: old.jit_symbols,
            smf_paths: old.smf_paths
        )
        registry_set_owned_at(idx, updated)
        mock_exec_map_symbol(path, symbol)

fn mock_registry_add_jit_symbol(path: text, jit_sym: text):
    val idx = mock_registry_paths.index_of(path)
    if idx >= 0:
        val old = mock_registry_owned[idx]
        val updated = MockOwnedResources(
            module_path: old.module_path,
            exec_symbols: old.exec_symbols,
            jit_symbols: old.jit_symbols + [jit_sym],
            smf_paths: old.smf_paths
        )
        registry_set_owned_at(idx, updated)
        mock_jit_origin_syms = mock_jit_origin_syms + [jit_sym]
        mock_jit_origin_mods = mock_jit_origin_mods + [path]

fn mock_registry_add_smf(path: text, smf_path: text):
    val idx = mock_registry_paths.index_of(path)
    if idx >= 0:
        val old = mock_registry_owned[idx]
        val updated = MockOwnedResources(
            module_path: old.module_path,
            exec_symbols: old.exec_symbols,
            jit_symbols: old.jit_symbols,
            smf_paths: old.smf_paths + [smf_path]
        )
        registry_set_owned_at(idx, updated)
        mock_smf_inc(smf_path)

fn mock_registry_unload(path: text):
    val idx = mock_registry_paths.index_of(path)
    if idx < 0:
        return
    val owned = mock_registry_owned[idx]
    # Free JIT symbols
    var ji_idx = 0
    while ji_idx < owned.jit_symbols.len():
        val jit_sym = owned.jit_symbols[ji_idx]
        mock_exec_unmap_symbol(jit_sym)
        val ji = mock_jit_origin_syms.index_of(jit_sym)
        if ji >= 0:
            mock_jit_origin_syms = arr_remove_text(mock_jit_origin_syms, ji)
            mock_jit_origin_mods = arr_remove_text(mock_jit_origin_mods, ji)
        ji_idx = ji_idx + 1
    # Unmap exec symbols
    var ei_idx = 0
    while ei_idx < owned.exec_symbols.len():
        mock_exec_unmap_symbol(owned.exec_symbols[ei_idx])
        ei_idx = ei_idx + 1
    # Decrement SMF ref counts
    var si_idx = 0
    while si_idx < owned.smf_paths.len():
        mock_smf_dec(owned.smf_paths[si_idx])
        si_idx = si_idx + 1
    # Remove from registry
    mock_registry_paths = arr_remove_text(mock_registry_paths, idx)
    mock_registry_owned = arr_remove_owned(mock_registry_owned, idx)

fn arr_remove_owned(arr: [MockOwnedResources], idx: i64) -> [MockOwnedResources]:
    var result: [MockOwnedResources] = []
    var i = 0
    while i < arr.len():
        if i != idx:
            result = result + [arr[i]]
        i = i + 1
    result

fn mock_registry_get_jit_origin(jit_sym: text) -> text:
    val idx = mock_jit_origin_syms.index_of(jit_sym)
    if idx >= 0:
        mock_jit_origin_mods[idx]
    else:
        ""

fn mock_registry_reset():
    mock_registry_paths = []
    mock_registry_owned = []
    mock_jit_origin_syms = []
    mock_jit_origin_mods = []
    mock_exec_reset()
    mock_smf_reset()

# ============================================================================
# Tests: Basic load/unload cycle
# ============================================================================

describe "Load/Unload cycle":

    it "module is tracked after load":
        mock_registry_reset()
        mock_registry_register("/lib/module_a.smf")
        expect(mock_registry_is_tracked("/lib/module_a.smf")).to_equal(true)
        expect(mock_registry_module_count()).to_equal(1)

    it "module is not tracked before load":
        mock_registry_reset()
        expect(mock_registry_is_tracked("/lib/not_loaded.smf")).to_equal(false)

    it "exec symbols tracked per module":
        mock_registry_reset()
        mock_registry_register("/lib/module_a.smf")
        mock_registry_add_exec_symbol("/lib/module_a.smf", "fn_foo")
        mock_registry_add_exec_symbol("/lib/module_a.smf", "fn_bar")
        expect(mock_exec_mapped_count()).to_equal(2)

    it "unload frees all exec symbols":
        mock_registry_reset()
        mock_registry_register("/lib/module_a.smf")
        mock_registry_add_exec_symbol("/lib/module_a.smf", "fn_foo")
        mock_registry_add_exec_symbol("/lib/module_a.smf", "fn_bar")
        mock_registry_unload("/lib/module_a.smf")
        expect(mock_exec_mapped_count()).to_equal(0)
        expect(mock_exec_was_freed("fn_foo")).to_equal(true)
        expect(mock_exec_was_freed("fn_bar")).to_equal(true)

    it "unload removes module from registry":
        mock_registry_reset()
        mock_registry_register("/lib/module_a.smf")
        mock_registry_unload("/lib/module_a.smf")
        expect(mock_registry_is_tracked("/lib/module_a.smf")).to_equal(false)
        expect(mock_registry_module_count()).to_equal(0)

    it "unload of unknown module is safe (no crash)":
        mock_registry_reset()
        mock_registry_unload("/lib/nonexistent.smf")
        expect(mock_registry_module_count()).to_equal(0)


# ============================================================================
# Tests: Hot-reload cycle
# ============================================================================

describe "Hot-reload cycle":

    it "old symbols freed before new ones registered":
        mock_registry_reset()
        # First load
        mock_registry_register("/lib/module_hot.smf")
        mock_registry_add_exec_symbol("/lib/module_hot.smf", "hot_fn")
        expect(mock_exec_was_freed("hot_fn")).to_equal(false)
        # Unload (simulates hot-reload)
        mock_registry_unload("/lib/module_hot.smf")
        expect(mock_exec_was_freed("hot_fn")).to_equal(true)
        # Re-register (new load)
        mock_exec_reset()
        mock_registry_register("/lib/module_hot.smf")
        mock_registry_add_exec_symbol("/lib/module_hot.smf", "hot_fn")
        expect(mock_exec_mapped_count()).to_equal(1)

    it "multiple load/unload cycles clean up correctly":
        mock_registry_reset()
        var cycle = 0
        while cycle < 3:
            mock_registry_register("/lib/cycle_mod.smf")
            mock_registry_add_exec_symbol("/lib/cycle_mod.smf", "cycle_fn")
            mock_registry_unload("/lib/cycle_mod.smf")
            cycle = cycle + 1
        expect(mock_registry_module_count()).to_equal(0)
        expect(mock_exec_mapped_count()).to_equal(0)


# ============================================================================
# Tests: JIT symbol attribution
# ============================================================================

describe "JIT symbol attribution":

    it "JIT symbol attributed to triggering module":
        mock_registry_reset()
        mock_registry_register("/lib/caller.smf")
        mock_registry_add_jit_symbol("/lib/caller.smf", "Vec$i64_push")
        val origin = mock_registry_get_jit_origin("Vec$i64_push")
        expect(origin).to_equal("/lib/caller.smf")

    it "JIT symbol freed when originating module unloads":
        mock_registry_reset()
        mock_registry_register("/lib/caller.smf")
        mock_registry_add_exec_symbol("/lib/caller.smf", "Vec$i64_push")
        mock_registry_add_jit_symbol("/lib/caller.smf", "Vec$i64_push")
        mock_registry_unload("/lib/caller.smf")
        expect(mock_exec_was_freed("Vec$i64_push")).to_equal(true)

    it "JIT origin removed after unload":
        mock_registry_reset()
        mock_registry_register("/lib/caller.smf")
        mock_registry_add_jit_symbol("/lib/caller.smf", "Map$text_i64_insert")
        mock_registry_unload("/lib/caller.smf")
        val origin = mock_registry_get_jit_origin("Map$text_i64_insert")
        expect(origin).to_equal("")

    it "JIT symbols from different modules tracked independently":
        mock_registry_reset()
        mock_registry_register("/lib/mod_a.smf")
        mock_registry_register("/lib/mod_b.smf")
        mock_registry_add_jit_symbol("/lib/mod_a.smf", "jit_sym_a")
        mock_registry_add_jit_symbol("/lib/mod_b.smf", "jit_sym_b")
        mock_registry_unload("/lib/mod_a.smf")
        # mod_a's JIT freed; mod_b's JIT still tracked
        expect(mock_registry_get_jit_origin("jit_sym_a")).to_equal("")
        expect(mock_registry_get_jit_origin("jit_sym_b")).to_equal("/lib/mod_b.smf")


# ============================================================================
# Tests: SMF cache ref counting
# ============================================================================

describe "SMF cache ref counting":

    it "SMF ref count increases when module accesses it":
        mock_smf_reset()
        mock_smf_inc("/cache/std.smf")
        expect(mock_smf_get_count("/cache/std.smf")).to_equal(1)

    it "SMF not evicted while ref count > 0":
        mock_smf_reset()
        mock_smf_inc("/cache/shared.smf")
        mock_smf_inc("/cache/shared.smf")
        mock_smf_dec("/cache/shared.smf")
        expect(mock_smf_was_evicted("/cache/shared.smf")).to_equal(false)
        expect(mock_smf_get_count("/cache/shared.smf")).to_equal(1)

    it "SMF evicted when last module unloads":
        mock_smf_reset()
        mock_smf_inc("/cache/shared.smf")
        mock_smf_dec("/cache/shared.smf")
        expect(mock_smf_was_evicted("/cache/shared.smf")).to_equal(true)
        expect(mock_smf_get_count("/cache/shared.smf")).to_equal(0)

    it "multiple modules share SMF — eviction only on last unload":
        mock_registry_reset()
        mock_registry_register("/lib/mod_a.smf")
        mock_registry_register("/lib/mod_b.smf")
        mock_registry_add_smf("/lib/mod_a.smf", "/cache/shared.smf")
        mock_registry_add_smf("/lib/mod_b.smf", "/cache/shared.smf")
        # Unload first module — SMF still ref'd by mod_b
        mock_registry_unload("/lib/mod_a.smf")
        expect(mock_smf_was_evicted("/cache/shared.smf")).to_equal(false)
        expect(mock_smf_get_count("/cache/shared.smf")).to_equal(1)
        # Unload second module — SMF now evicted
        mock_registry_unload("/lib/mod_b.smf")
        expect(mock_smf_was_evicted("/cache/shared.smf")).to_equal(true)


# ============================================================================
# Tests: Full teardown (process exit)
# ============================================================================

describe "Full teardown":

    it "teardown frees all modules":
        mock_registry_reset()
        mock_registry_register("/lib/mod_a.smf")
        mock_registry_register("/lib/mod_b.smf")
        mock_registry_register("/lib/mod_c.smf")
        mock_registry_add_exec_symbol("/lib/mod_a.smf", "fn_a")
        mock_registry_add_exec_symbol("/lib/mod_b.smf", "fn_b")
        # Simulate destroy() — unload all
        val paths_to_unload = ["/lib/mod_a.smf", "/lib/mod_b.smf", "/lib/mod_c.smf"]
        for path in paths_to_unload:
            mock_registry_unload(path)
        expect(mock_registry_module_count()).to_equal(0)
        expect(mock_exec_mapped_count()).to_equal(0)

    it "teardown with zero modules is safe":
        mock_registry_reset()
        # No modules loaded — teardown should be a no-op
        expect(mock_registry_module_count()).to_equal(0)
        expect(mock_exec_mapped_count()).to_equal(0)

    it "after teardown, re-registration works (REPL restart)":
        mock_registry_reset()
        mock_registry_register("/lib/mod.smf")
        mock_registry_add_exec_symbol("/lib/mod.smf", "fn_x")
        mock_registry_unload("/lib/mod.smf")
        mock_exec_reset()
        # Re-register after teardown (simulates REPL restart)
        mock_registry_register("/lib/mod.smf")
        mock_registry_add_exec_symbol("/lib/mod.smf", "fn_x")
        expect(mock_registry_is_tracked("/lib/mod.smf")).to_equal(true)
        expect(mock_exec_mapped_count()).to_equal(1)
