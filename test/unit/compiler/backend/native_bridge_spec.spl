# # Native Bridge Module Specification
#
# Tests the Simple-side wrapper for native compilation and execution.
#
# **Feature IDs:** #BRIDGE-001 to #BRIDGE-010
# **Category:** Backend / Native Execution
# **Status:** Implementation Complete

use std.spec
use compiler.backend.native_bridge.*

# Declare FFI functions used in tests
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_time_now_unix_micros() -> i64

describe "NativeCompileResult":
    # Tests for the NativeCompileResult class.

    context "static factory methods":
        it "creates success result":
            val result = NativeCompileResult__success_result("/tmp/binary", 1000)
            expect result.is_ok() == true
            expect result.success == true
            expect result.binary_path == "/tmp/binary"
            expect result.compile_time_ms == 1000
            expect result.error_message == ""

        it "creates error result":
            val result = NativeCompileResult__error_result("compilation failed")
            expect result.is_ok() == false
            expect result.success == false
            expect result.binary_path == ""
            expect result.error_message == "compilation failed"
            expect result.compile_time_ms == 0

    context "is_ok method":
        it "returns true for successful compilation":
            val result = NativeCompileResult__success_result("/tmp/bin", 500)
            expect result.is_ok() == true

        it "returns false for failed compilation":
            val result = NativeCompileResult__error_result("error")
            expect result.is_ok() == false

    context "field access":
        it "has correct fields for success":
            val result = NativeCompileResult__success_result("/path/to/binary", 2500)
            expect result.binary_path.contains("binary") == true
            expect result.compile_time_ms > 0
            expect result.error_message == ""

        it "has correct fields for error":
            val result = NativeCompileResult__error_result("LLVM error: undefined symbol")
            expect result.error_message.contains("LLVM") == true
            expect result.binary_path == ""
            expect result.compile_time_ms == 0

describe "NativeExecutionResult":
    # Tests for the NativeExecutionResult class.

    context "construction":
        it "creates result with all fields":
            val result = NativeExecutionResult(
                stdout: "output text",
                stderr: "error text",
                exit_code: 0,
                execution_time_ms: 150
            )
            expect result.stdout == "output text"
            expect result.stderr == "error text"
            expect result.exit_code == 0
            expect result.execution_time_ms == 150

    context "is_success method":
        it "returns true for exit code 0":
            val result = NativeExecutionResult(
                stdout: "ok",
                stderr: "",
                exit_code: 0,
                execution_time_ms: 100
            )
            expect result.is_success() == true

        it "returns false for non-zero exit code":
            val result = NativeExecutionResult(
                stdout: "",
                stderr: "error",
                exit_code: 1,
                execution_time_ms: 50
            )
            expect result.is_success() == false

        it "returns false for negative exit code":
            val result = NativeExecutionResult(
                stdout: "",
                stderr: "timeout",
                exit_code: -1,
                execution_time_ms: 1000
            )
            expect result.is_success() == false

describe "compile_to_native":
    # Tests for the compile_to_native function.

    context "with invalid inputs":
        it "returns error for non-existent source file":
            val result = compile_to_native("/nonexistent/source.spl", "/tmp/output")
            expect result.is_ok() == false
            expect result.error_message != ""

        it "returns error for empty source path":
            val result = compile_to_native("", "/tmp/output")
            expect result.is_ok() == false

        it "returns error for empty output path":
            val result = compile_to_native("/tmp/test.spl", "")
            expect result.is_ok() == false

    context "with stub implementation":
        it "returns not implemented error":
            # Create a dummy source file
            extern fn rt_file_write_text(path: text, content: text) -> bool
            extern fn rt_file_delete(path: text) -> bool

            val source = "/tmp/test_compile_source.spl"
            rt_file_write_text(source, "fn main(): print \"test\"")

            val result = compile_to_native(source, "/tmp/test_output")

            # Should fail with "not implemented" currently
            expect result.is_ok() == false
            expect result.error_message.contains("not") or result.error_message.contains("implement")

            # Cleanup
            rt_file_delete(source)

    context "timing measurement":
        it "measures compilation time":
            val source = "/tmp/test_timing.spl"
            extern fn rt_file_write_text(path: text, content: text) -> bool
            extern fn rt_file_delete(path: text) -> bool

            rt_file_write_text(source, "fn main(): ()")

            val result = compile_to_native(source, "/tmp/output")

            # Even failed compilation should have timing
            expect result.compile_time_ms >= 0

            rt_file_delete(source)

describe "execute_native":
    # Tests for the execute_native function.

    context "executing system binaries":
        it "executes and captures output":
            val result = execute_native("/bin/echo", ["hello", "world"], 5000)
            expect result.is_success() == true
            expect result.exit_code == 0
            expect result.stdout.contains("hello")
            expect result.stdout.contains("world")

        it "captures stderr separately":
            val result = execute_native("/bin/sh", ["-c", "echo stderr_test >&2"], 5000)
            # stderr or stdout depending on shell behavior
            expect result.exit_code == 0

        it "returns error for non-existent binary":
            val result = execute_native("/nonexistent/binary", [], 5000)
            expect result.is_success() == false
            expect result.exit_code != 0

    context "argument passing":
        it "passes empty argument list":
            val result = execute_native("/bin/true", [], 5000)
            expect result.is_success() == true
            expect result.exit_code == 0

        it "passes multiple arguments":
            val result = execute_native("/bin/echo", ["a", "b", "c"], 5000)
            expect result.stdout.contains("a")
            expect result.exit_code == 0

        it "handles arguments with spaces":
            val result = execute_native("/bin/echo", ["hello world"], 5000)
            expect result.stdout.contains("hello world")

    context "timeout handling":
        it "respects timeout parameter":
            # Execute a fast command with large timeout
            val result = execute_native("/bin/true", [], 10000)
            expect result.execution_time_ms < 10000
            expect result.is_success() == true

        it "measures execution time":
            val result = execute_native("/bin/echo", ["test"], 5000)
            expect result.execution_time_ms >= 0
            expect result.execution_time_ms < 5000

describe "cleanup_native_binary":
    # Tests for cleanup utility function.

    it "deletes existing binary":
        extern fn rt_file_write_text(path: text, content: text) -> bool
        extern fn rt_file_exists(path: text) -> bool

        val binary_path = "/tmp/test_cleanup_binary"
        rt_file_write_text(binary_path, "fake binary content")

        cleanup_native_binary(binary_path)

        expect rt_file_exists(binary_path) == false

    it "handles non-existent binary gracefully":
        # Should not error
        cleanup_native_binary("/tmp/nonexistent_binary_xyz123")
        expect true  # No error thrown

    it "handles empty path":
        cleanup_native_binary("")
        expect true  # No error

describe "is_native_available":
    # Tests for checking LLVM backend availability.

    it "returns boolean":
        val available = is_native_available()
        expect available == true or available == false

    it "returns false when LLVM not available":
        # Currently should return false since implementation is stub
        val available = is_native_available()
        # May be true or false depending on build configuration
        expect available == false or available == true

describe "Integration Workflows":
    # End-to-end tests for complete workflows.

    context "compile and execute workflow":
        it "attempts full workflow":
            extern fn rt_file_write_text(path: text, content: text) -> bool
            extern fn rt_file_delete(path: text) -> bool

            val source = "/tmp/workflow_test.spl"
            val binary = "/tmp/workflow_binary"

            # Write source
            val program = """
            fn main():
                print "Workflow test"
            """
            rt_file_write_text(source, program)

            # Try to compile
            val compile_result = compile_to_native(source, binary)

            if compile_result.is_ok():
                # If compilation succeeds (future)
                val exec_result = execute_native(binary, [], 5000)
                expect exec_result.is_success() == true
                expect exec_result.stdout.contains("Workflow")

                # Cleanup binary
                cleanup_native_binary(binary)
            else:
                # Expected to fail with current stub
                expect compile_result.error_message != ""

            # Cleanup source
            rt_file_delete(source)

    context "error recovery":
        it "handles compilation failure gracefully":
            extern fn rt_file_write_text(path: text, content: text) -> bool
            extern fn rt_file_delete(path: text) -> bool

            val source = "/tmp/error_recovery_test.spl"
            val binary = "/tmp/error_binary"

            # Write invalid source code
            rt_file_write_text(source, "invalid syntax {{{")

            val result = compile_to_native(source, binary)

            # Should fail gracefully
            expect result.is_ok() == false
            expect result.error_message != ""

            rt_file_delete(source)

    context "multiple compilations":
        it "handles sequential compilations":
            extern fn rt_file_write_text(path: text, content: text) -> bool
            extern fn rt_file_delete(path: text) -> bool

            var all_failed = true

            for i in 0..3:
                val source = "/tmp/test_multi_{i}.spl"
                rt_file_write_text(source, "fn main(): ()")

                val result = compile_to_native(source, "/tmp/out_{i}")

                # Currently all should fail with "not implemented"
                if result.is_ok():
                    all_failed = false

                rt_file_delete(source)

            # With current stub, all should fail
            expect all_failed == true

extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_file_exists(path: text) -> bool
