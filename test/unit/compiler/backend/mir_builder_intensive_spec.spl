# # MIR Builder - Intensive Test Suite
#
# **Feature IDs:** #930-960
# **Category:** Backend Testing
# **Status:** Complete
#
# Comprehensive intensive tests for MIR instruction builder.
# Tests all existing builder methods with multiple scenarios.

use compiler.backend.mir_test_builder_full.{
    MirTestBuilder, MirTestInst, VReg, BlockId, BackendTarget,
    new_builder, simple_arithmetic, simd_reduction, gpu_kernel
}

# ============================================================
# CONSTANTS - Intensive Coverage
# ============================================================

describe "MIR Constants - Intensive":
    it "generates ConstInt with zero":
        val b = new_builder("test")
        b.add_const_int(0, 0)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "generates ConstInt with positive value":
        val b = new_builder("test")
        b.add_const_int(0, 42)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "generates ConstInt with negative value":
        val b = new_builder("test")
        b.add_const_int(0, -100)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "generates ConstInt with large value":
        val b = new_builder("test")
        b.add_const_int(0, 1000000)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "generates multiple ConstInt instructions":
        val b = new_builder("test")
        b.add_const_int(0, 10)
        b.add_const_int(1, 20)
        b.add_const_int(2, 30)
        b.add_const_int(3, 40)
        val tc = b.build()
        expect tc.instructions.len() == 4

    it "generates ConstFloat with zero":
        val b = new_builder("test")
        b.add_const_float(0, 0.0)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "generates ConstFloat with pi":
        val b = new_builder("test")
        b.add_const_float(0, 3.14159)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "generates ConstFloat with negative value":
        val b = new_builder("test")
        b.add_const_float(0, -2.5)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "generates ConstBool true":
        val b = new_builder("test")
        b.add_const_bool(0, true)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "generates ConstBool false":
        val b = new_builder("test")
        b.add_const_bool(0, false)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "generates mixed constant types":
        val b = new_builder("test")
        b.add_const_int(0, 42)
        b.add_const_float(1, 3.14)
        b.add_const_bool(2, true)
        val tc = b.build()
        expect tc.instructions.len() == 3

# ============================================================
# ARITHMETIC - Intensive Coverage
# ============================================================

describe "MIR Arithmetic - Intensive":
    context "Add instruction":
        it "adds two constants":
            val b = new_builder("test")
            b.add_const_int(0, 10)
            b.add_const_int(1, 20)
            b.add_add(2, 0, 1)
            val tc = b.build()
            expect tc.instructions.len() == 3

        it "chains multiple adds":
            val b = new_builder("test")
            b.add_const_int(0, 1)
            b.add_const_int(1, 2)
            b.add_add(2, 0, 1)
            b.add_const_int(3, 3)
            b.add_add(4, 2, 3)
            val tc = b.build()
            expect tc.instructions.len() == 5

        it "adds with same register as operands":
            val b = new_builder("test")
            b.add_const_int(0, 5)
            b.add_add(1, 0, 0)  # 5 + 5
            val tc = b.build()
            expect tc.instructions.len() == 2

    context "Mul instruction":
        it "multiplies two constants":
            val b = new_builder("test")
            b.add_const_int(0, 5)
            b.add_const_int(1, 6)
            b.add_mul(2, 0, 1)
            val tc = b.build()
            expect tc.instructions.len() == 3

        it "multiplies by zero":
            val b = new_builder("test")
            b.add_const_int(0, 42)
            b.add_const_int(1, 0)
            b.add_mul(2, 0, 1)
            val tc = b.build()
            expect tc.instructions.len() == 3

        it "chains add and mul":
            val b = new_builder("test")
            b.add_const_int(0, 2)
            b.add_const_int(1, 3)
            b.add_mul(2, 0, 1)
            b.add_const_int(3, 4)
            b.add_add(4, 2, 3)  # (2*3) + 4
            val tc = b.build()
            expect tc.instructions.len() == 5

# ============================================================
# CONTROL FLOW - Intensive Coverage
# ============================================================

describe "MIR Control Flow - Intensive":
    context "Ret instruction":
        it "returns integer constant":
            val b = new_builder("test")
            b.add_const_int(0, 42)
            b.add_ret(0)
            val tc = b.build()
            expect tc.instructions.len() == 2

        it "returns float constant":
            val b = new_builder("test")
            b.add_const_float(0, 3.14)
            b.add_ret(0)
            val tc = b.build()
            expect tc.instructions.len() == 2

        it "returns computed value":
            val b = new_builder("test")
            b.add_const_int(0, 10)
            b.add_const_int(1, 20)
            b.add_add(2, 0, 1)
            b.add_ret(2)
            val tc = b.build()
            expect tc.instructions.len() == 4

    context "RetVoid instruction":
        it "returns void alone":
            val b = new_builder("test")
            b.add_ret_void()
            val tc = b.build()
            expect tc.instructions.len() == 1

        it "returns void after operations":
            val b = new_builder("test")
            b.add_const_int(0, 42)
            b.add_ret_void()
            val tc = b.build()
            expect tc.instructions.len() == 2

    context "Branch instruction":
        it "branches on true condition":
            val b = new_builder("test")
            b.add_const_bool(0, true)
            b.add_branch(0, 1, 2)
            val tc = b.build()
            expect tc.instructions.len() == 2

        it "branches on false condition":
            val b = new_builder("test")
            b.add_const_bool(0, false)
            b.add_branch(0, 10, 20)
            val tc = b.build()
            expect tc.instructions.len() == 2

        it "branches on computed condition":
            val b = new_builder("test")
            b.add_const_int(0, 5)
            b.add_const_int(1, 10)
            b.add_add(2, 0, 1)
            b.add_const_bool(3, true)
            b.add_branch(3, 100, 200)
            val tc = b.build()
            expect tc.instructions.len() == 5

# ============================================================
# SIMD - Intensive Coverage
# ============================================================

describe "MIR SIMD - Intensive":
    it "generates VecSum with placeholder":
        val b = new_builder("test")
        b.add_const_int(0, 0)
        b.add_vec_sum(1, 0)
        val tc = b.build()
        expect tc.instructions.len() == 2

    it "chains SIMD operations":
        val b = new_builder("test")
        b.add_const_int(0, 0)
        b.add_vec_sum(1, 0)
        b.add_vec_sum(2, 1)
        val tc = b.build()
        expect tc.instructions.len() == 3

    it "SIMD followed by return":
        val b = new_builder("test")
        b.add_const_int(0, 0)
        b.add_vec_sum(1, 0)
        b.add_ret(1)
        val tc = b.build()
        expect tc.instructions.len() == 3

# ============================================================
# GPU - Intensive Coverage
# ============================================================

describe "MIR GPU - Intensive":
    it "gets GPU global ID dimension 0":
        val b = new_builder("test")
        b.add_gpu_global_id(0, 0)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "gets GPU global ID dimension 1":
        val b = new_builder("test")
        b.add_gpu_global_id(0, 1)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "gets GPU global ID dimension 2":
        val b = new_builder("test")
        b.add_gpu_global_id(0, 2)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "gets multiple GPU dimensions":
        val b = new_builder("test")
        b.add_gpu_global_id(0, 0)
        b.add_gpu_global_id(1, 1)
        b.add_gpu_global_id(2, 2)
        val tc = b.build()
        expect tc.instructions.len() == 3

    it "GPU ID followed by return":
        val b = new_builder("test")
        b.add_gpu_global_id(0, 0)
        b.add_ret(0)
        val tc = b.build()
        expect tc.instructions.len() == 2

# ============================================================
# REGISTER TRACKING - Intensive Coverage
# ============================================================

describe "MIR Register Tracking - Intensive":
    it "tracks sequential register allocation":
        val b = new_builder("test")
        expect b.next_vreg == 0
        b.add_const_int(0, 1)
        expect b.next_vreg == 1
        b.add_const_int(1, 2)
        expect b.next_vreg == 2
        b.add_const_int(2, 3)
        expect b.next_vreg == 3

    it "tracks non-sequential registers":
        val b = new_builder("test")
        expect b.next_vreg == 0
        b.add_const_int(10, 1)
        expect b.next_vreg == 11
        b.add_const_int(5, 2)
        expect b.next_vreg == 11
        b.add_const_int(20, 3)
        expect b.next_vreg == 21

    it "tracks sparse register usage":
        val b = new_builder("test")
        b.add_const_int(100, 1)
        expect b.next_vreg == 101
        b.add_const_int(0, 2)
        expect b.next_vreg == 101
        b.add_const_int(200, 3)
        expect b.next_vreg == 201

    it "handles register reuse":
        val b = new_builder("test")
        b.add_const_int(0, 1)
        b.add_const_int(0, 2)  # Reuse register 0
        val tc = b.build()
        expect tc.instructions.len() == 2
        expect b.next_vreg == 1

# ============================================================
# BACKEND SELECTION - Intensive Coverage
# ============================================================

describe "MIR Backend Selection - Intensive":
    it "uses default multiple backends":
        val b = new_builder("test")
        val tc = b.build()
        expect tc.expected_backends.len() >= 3

    it "restricts to Cranelift only":
        val b = new_builder("test")
        b.only_backend(BackendTarget.Cranelift)
        val tc = b.build()
        expect tc.expected_backends.len() == 1

    it "restricts to LLVM only":
        val b = new_builder("test")
        b.only_backend(BackendTarget.LLVM)
        val tc = b.build()
        expect tc.expected_backends.len() == 1

    it "restricts to Vulkan only":
        val b = new_builder("test")
        b.only_backend(BackendTarget.Vulkan)
        val tc = b.build()
        expect tc.expected_backends.len() == 1

    it "restricts to Interpreter only":
        val b = new_builder("test")
        b.only_backend(BackendTarget.Interpreter)
        val tc = b.build()
        expect tc.expected_backends.len() == 1

    it "selects two specific backends":
        val b = new_builder("test")
        b.only_backends([BackendTarget.Cranelift, BackendTarget.LLVM])
        val tc = b.build()
        expect tc.expected_backends.len() == 2

    it "selects three specific backends":
        val b = new_builder("test")
        b.only_backends([BackendTarget.Cranelift, BackendTarget.LLVM, BackendTarget.Interpreter])
        val tc = b.build()
        expect tc.expected_backends.len() == 3

# ============================================================
# TEST PATTERNS - Intensive Coverage
# ============================================================

describe "MIR Test Patterns - Intensive":
    it "simple_arithmetic has correct structure":
        val tc = simple_arithmetic()
        expect tc.name == "simple_arithmetic"
        expect tc.instructions.len() == 4
        expect tc.expected_backends.len() >= 3

    it "simd_reduction has correct structure":
        val tc = simd_reduction()
        expect tc.name == "simd_reduction"
        expect tc.expected_backends.len() == 2
        expect tc.instructions.len() == 3

    it "gpu_kernel has correct structure":
        val tc = gpu_kernel()
        expect tc.name == "gpu_kernel"
        expect tc.expected_backends.len() == 1
        expect tc.instructions.len() == 2

# ============================================================
# COMPLEX INTEGRATION SCENARIOS
# ============================================================

describe "MIR Integration - Complex Scenarios":
    it "builds fibonacci sequence setup":
        val b = new_builder("fib_setup")
        b.add_const_int(0, 0)
        b.add_const_int(1, 1)
        b.add_add(2, 0, 1)
        b.add_add(3, 1, 2)
        b.add_add(4, 2, 3)
        b.add_ret(4)
        val tc = b.build()
        expect tc.instructions.len() == 6

    it "builds conditional return pattern":
        val b = new_builder("cond_ret")
        b.add_const_bool(0, true)
        b.add_branch(0, 10, 20)
        val tc = b.build()
        expect tc.instructions.len() == 2

    it "builds accumulator pattern":
        val b = new_builder("accumulator")
        b.add_const_int(0, 0)   # acc = 0
        b.add_const_int(1, 1)   # add 1
        b.add_add(2, 0, 1)
        b.add_const_int(3, 2)   # add 2
        b.add_add(4, 2, 3)
        b.add_const_int(5, 3)   # add 3
        b.add_add(6, 4, 5)
        b.add_ret(6)
        val tc = b.build()
        expect tc.instructions.len() == 8

    it "builds multiply-add pattern":
        val b = new_builder("multiply_add")
        b.add_const_int(0, 3)
        b.add_const_int(1, 4)
        b.add_mul(2, 0, 1)
        b.add_const_int(3, 2)
        b.add_add(4, 2, 3)
        b.add_ret(4)
        val tc = b.build()
        expect tc.instructions.len() == 6

    it "builds large instruction sequence":
        val b = new_builder("large_sequence")
        for i in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]:
            b.add_const_int(i, i * 10)
        b.add_ret(9)
        val tc = b.build()
        expect tc.instructions.len() == 11

    it "builds mixed type operations":
        val b = new_builder("mixed_types")
        b.add_const_int(0, 42)
        b.add_const_float(1, 3.14)
        b.add_const_bool(2, true)
        b.add_branch(2, 10, 20)
        val tc = b.build()
        expect tc.instructions.len() == 4

    it "builds SIMD pipeline with return":
        val b = new_builder("simd_pipeline")
        b.add_const_int(0, 0)
        b.add_vec_sum(1, 0)
        b.add_vec_sum(2, 1)
        b.add_ret(2)
        b.only_backends([BackendTarget.Cranelift, BackendTarget.Interpreter])
        val tc = b.build()
        expect tc.instructions.len() == 4
        expect tc.expected_backends.len() == 2

    it "builds GPU kernel with multiple IDs":
        val b = new_builder("multi_gpu")
        b.add_gpu_global_id(0, 0)
        b.add_gpu_global_id(1, 1)
        b.add_gpu_global_id(2, 2)
        b.add_add(3, 0, 1)
        b.add_add(4, 3, 2)
        b.add_ret(4)
        b.only_backend(BackendTarget.Vulkan)
        val tc = b.build()
        expect tc.instructions.len() == 6

# ============================================================
# EDGE CASES AND STRESS TESTS
# ============================================================

describe "MIR Builder - Edge Cases":
    it "handles empty builder":
        val b = new_builder("empty")
        val tc = b.build()
        expect tc.instructions.len() == 0
        expect tc.name == "empty"

    it "handles single instruction":
        val b = new_builder("single")
        b.add_const_int(0, 1)
        val tc = b.build()
        expect tc.instructions.len() == 1

    it "handles high register numbers":
        val b = new_builder("high_regs")
        b.add_const_int(1000, 42)
        b.add_const_int(2000, 43)
        b.add_add(3000, 1000, 2000)
        val tc = b.build()
        expect tc.instructions.len() == 3
        expect b.next_vreg == 3001

    it "handles register 0 usage":
        val b = new_builder("reg_zero")
        b.add_const_int(0, 100)
        b.add_add(1, 0, 0)  # Use register 0 twice
        val tc = b.build()
        expect tc.instructions.len() == 2
