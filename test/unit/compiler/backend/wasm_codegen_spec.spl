# WASM Codegen Specification
#
# Tests for the WAT-based WASM backend:
# - MIR to WAT instruction translation
# - Control flow structuring
# - Memory layout and string table
# - WASI import declarations
# - WatBuilder output

use compiler.backend.wasm_backend.{WatBuilder, WasmType, WasmTarget}
use compiler.backend.wasm_type_mapper.{WasmTypeMapper}
use compiler.mir_data.*
use std.string.{NL}

describe "WatBuilder":

    context "basic output":
        it "creates empty module":
            var builder = WatBuilder.create()
            builder.begin_module("test")
            builder.end_module()
            val result = builder.build()
            expect(result).to_contain("(module $test")
            expect(result).to_contain(")")

        it "emits i32 const":
            var builder = WatBuilder.create()
            builder.emit_i32_const(42)
            val result = builder.build()
            expect(result).to_contain("i32.const 42")

        it "emits i64 const":
            var builder = WatBuilder.create()
            builder.emit_i64_const(100)
            val result = builder.build()
            expect(result).to_contain("i64.const 100")

        it "emits f64 const":
            var builder = WatBuilder.create()
            builder.emit_f64_const(3.14)
            val result = builder.build()
            expect(result).to_contain("f64.const")

    context "control flow":
        it "emits block":
            var builder = WatBuilder.create()
            builder.emit_block("exit")
            builder.emit_end()
            val result = builder.build()
            expect(result).to_contain("(block $exit")

        it "emits loop":
            var builder = WatBuilder.create()
            builder.emit_loop("loop0")
            builder.emit_end()
            val result = builder.build()
            expect(result).to_contain("(loop $loop0")

        it "emits branch":
            var builder = WatBuilder.create()
            builder.emit_br("exit")
            val result = builder.build()
            expect(result).to_contain("br $exit")

        it "emits conditional branch":
            var builder = WatBuilder.create()
            builder.emit_br_if("exit")
            val result = builder.build()
            expect(result).to_contain("br_if $exit")

        it "emits br_table":
            var builder = WatBuilder.create()
            builder.emit_br_table(["b0", "b1", "b2"], "b0")
            val result = builder.build()
            expect(result).to_contain("br_table")
            expect(result).to_contain("$b0")
            expect(result).to_contain("$b1")
            expect(result).to_contain("$b2")

    context "variables":
        it "emits local get by name":
            var builder = WatBuilder.create()
            builder.emit_local_named_get("x")
            val result = builder.build()
            expect(result).to_contain("local.get $x")

        it "emits local set by name":
            var builder = WatBuilder.create()
            builder.emit_local_named_set("x")
            val result = builder.build()
            expect(result).to_contain("local.set $x")

        it "emits global get":
            var builder = WatBuilder.create()
            builder.emit_global_get("heap_ptr")
            val result = builder.build()
            expect(result).to_contain("global.get $heap_ptr")

        it "emits global set":
            var builder = WatBuilder.create()
            builder.emit_global_set("heap_ptr")
            val result = builder.build()
            expect(result).to_contain("global.set $heap_ptr")

    context "memory operations":
        it "emits i32 load":
            var builder = WatBuilder.create()
            builder.emit_i32_load(0, 4)
            val result = builder.build()
            expect(result).to_contain("i32.load offset=0 align=4")

        it "emits i32 store":
            var builder = WatBuilder.create()
            builder.emit_i32_store(0, 4)
            val result = builder.build()
            expect(result).to_contain("i32.store offset=0 align=4")

        it "emits i64 load":
            var builder = WatBuilder.create()
            builder.emit_i64_load(8, 8)
            val result = builder.build()
            expect(result).to_contain("i64.load offset=8 align=8")

    context "arithmetic":
        it "emits i64 add":
            var builder = WatBuilder.create()
            builder.emit_i64_add()
            val result = builder.build()
            expect(result).to_contain("i64.add")

        it "emits i64 sub":
            var builder = WatBuilder.create()
            builder.emit_i64_sub()
            val result = builder.build()
            expect(result).to_contain("i64.sub")

        it "emits i64 mul":
            var builder = WatBuilder.create()
            builder.emit_i64_mul()
            val result = builder.build()
            expect(result).to_contain("i64.mul")

        it "emits f64 add":
            var builder = WatBuilder.create()
            builder.emit_f64_add()
            val result = builder.build()
            expect(result).to_contain("f64.add")

    context "comparison":
        it "emits i64 eq":
            var builder = WatBuilder.create()
            builder.emit_i64_eq()
            val result = builder.build()
            expect(result).to_contain("i64.eq")

        it "emits i64 lt_s":
            var builder = WatBuilder.create()
            builder.emit_i64_lt_s()
            val result = builder.build()
            expect(result).to_contain("i64.lt_s")

        it "emits f64 lt":
            var builder = WatBuilder.create()
            builder.emit_f64_lt()
            val result = builder.build()
            expect(result).to_contain("f64.lt")

    context "function":
        it "emits function with params and results":
            var builder = WatBuilder.create()
            builder.begin_func("add", [WasmType.I64, WasmType.I64], [WasmType.I64])
            builder.emit_local_get(0)
            builder.emit_local_get(1)
            builder.emit_i64_add()
            builder.emit_return()
            builder.end_func()
            val result = builder.build()
            expect(result).to_contain("(func $add")
            expect(result).to_contain("(param i64)")
            expect(result).to_contain("(result i64)")
            expect(result).to_contain("i64.add")

        it "emits call by name":
            var builder = WatBuilder.create()
            builder.emit_call_named("my_func")
            val result = builder.build()
            expect(result).to_contain("call $my_func")

    context "special instructions":
        it "emits nop":
            var builder = WatBuilder.create()
            builder.emit_nop()
            val result = builder.build()
            expect(result).to_contain("nop")

        it "emits unreachable":
            var builder = WatBuilder.create()
            builder.emit_unreachable()
            val result = builder.build()
            expect(result).to_contain("unreachable")

        it "emits drop":
            var builder = WatBuilder.create()
            builder.emit_drop()
            val result = builder.build()
            expect(result).to_contain("drop")

        it "emits return":
            var builder = WatBuilder.create()
            builder.emit_return()
            val result = builder.build()
            expect(result).to_contain("return")

describe "WasmTypeMapper":

    context "wasm32 type mapping":
        it "maps i64 to i64":
            val mapper = WasmTypeMapper.create_wasm32()
            val ty = MirType(kind: MirTypeKind.I64)
            expect(mapper.map_type(ty)).to_equal("i64")

        it "maps i32 to i32":
            val mapper = WasmTypeMapper.create_wasm32()
            val ty = MirType(kind: MirTypeKind.I32)
            expect(mapper.map_type(ty)).to_equal("i32")

        it "maps f64 to f64":
            val mapper = WasmTypeMapper.create_wasm32()
            val ty = MirType(kind: MirTypeKind.F64)
            expect(mapper.map_type(ty)).to_equal("f64")

        it "maps bool to i32":
            val mapper = WasmTypeMapper.create_wasm32()
            val ty = MirType(kind: MirTypeKind.Bool)
            expect(mapper.map_type(ty)).to_equal("i32")

    context "size and alignment":
        it "i64 is 8 bytes":
            val mapper = WasmTypeMapper.create_wasm32()
            val ty = MirType(kind: MirTypeKind.I64)
            expect(mapper.size_of(ty)).to_equal(8)

        it "i32 is 4 bytes":
            val mapper = WasmTypeMapper.create_wasm32()
            val ty = MirType(kind: MirTypeKind.I32)
            expect(mapper.size_of(ty)).to_equal(4)

        it "bool is 1 byte":
            val mapper = WasmTypeMapper.create_wasm32()
            val ty = MirType(kind: MirTypeKind.Bool)
            expect(mapper.size_of(ty)).to_equal(1)

        it "unit is 0 bytes":
            val mapper = WasmTypeMapper.create_wasm32()
            val ty = MirType(kind: MirTypeKind.Unit)
            expect(mapper.size_of(ty)).to_equal(0)

    context "function signatures":
        it "generates correct signature for unit return":
            val mapper = WasmTypeMapper.create_wasm32()
            val params = [MirType(kind: MirTypeKind.I64)]
            val ret = MirType(kind: MirTypeKind.Unit)
            val sig = mapper.map_function_signature(params, ret)
            expect(sig).to_contain("(param")
            # Unit return should have no (result ...)

        it "generates correct signature with result":
            val mapper = WasmTypeMapper.create_wasm32()
            val params = [MirType(kind: MirTypeKind.I64), MirType(kind: MirTypeKind.I64)]
            val ret = MirType(kind: MirTypeKind.I64)
            val sig = mapper.map_function_signature(params, ret)
            expect(sig).to_contain("(param")
            expect(sig).to_contain("(result")

describe "WasmTarget":

    it "browser needs JS glue":
        expect(WasmTarget.Browser.needs_js_glue()).to_equal(true)

    it "wasi does not need JS glue":
        expect(WasmTarget.Wasi.needs_js_glue()).to_equal(false)

    it "wasi needs WASI imports":
        expect(WasmTarget.Wasi.needs_wasi_imports()).to_equal(true)

    it "browser does not need WASI imports":
        expect(WasmTarget.Browser.needs_wasi_imports()).to_equal(false)

    it "converts to text correctly":
        expect(WasmTarget.Browser.to_text()).to_equal("browser")
        expect(WasmTarget.Wasi.to_text()).to_equal("wasi")
        expect(WasmTarget.Minimal.to_text()).to_equal("minimal")
