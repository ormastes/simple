# LLVM IR Builder Unit Tests
#
# Tests for LLVM IR generation and instruction emission.


# ============================================================================
# IR Builder Creation Tests
# ============================================================================

# Note: Compiler module imports removed - not resolvable from test runner.
# Tests verify LLVM IR string patterns conceptually.

describe "LLVM IR Builder - Creation":
    context "builder initialization":
        it "creates builder with module name":
            val triple = LlvmTargetTriple.x86_64_linux()
            val builder = LlvmIRBuilder.create("test_module", triple)
            expect(builder.module_name).to_equal("test_module")

        it "initializes with empty instructions":
            val triple = LlvmTargetTriple.x86_64_linux()
            val builder = LlvmIRBuilder.create("test", triple)
            expect(builder.instructions.len()).to_equal(0)

        it "initializes local counter to 0":
            val triple = LlvmTargetTriple.x86_64_linux()
            val builder = LlvmIRBuilder.create("test", triple)
            expect(builder.local_counter).to_equal(0)

# ============================================================================
# Module Header Tests
# ============================================================================

describe "LLVM IR Builder - Module Header":
    context "header emission":
        it "emits module ID comment":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("my_module", triple)
            builder.emit_module_header()
            val ir = builder.build()
            expect(ir).to_contain("; ModuleID = 'my_module'")

        it "emits source filename":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("my_module", triple)
            builder.emit_module_header()
            val ir = builder.build()
            expect(ir).to_contain("source_filename = \"my_module.spl\"")

        it "emits target triple":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("my_module", triple)
            builder.emit_module_header()
            val ir = builder.build()
            expect(ir).to_contain("target triple = \"x86_64-unknown-linux-gnu\"")

# ============================================================================
# Function Definition Tests
# ============================================================================

describe "LLVM IR Builder - Functions":
    context "function structure":
        it "emits function definition with nounwind":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.start_function("main", [], "i64")
            builder.emit_ret("i64", "0")
            builder.end_function()
            val ir = builder.build()
            expect(ir).to_contain("define i64 @main() nounwind {")
            expect(ir).to_contain("}")

        it "emits function with parameters":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            val params = ["i64 %a", "i64 %b"]
            builder.start_function("add", params, "i64")
            builder.end_function()
            val ir = builder.build()
            expect(ir).to_contain("define i64 @add(i64 %a, i64 %b) nounwind {")

# ============================================================================
# Arithmetic Instruction Tests
# ============================================================================

describe "LLVM IR Builder - Arithmetic":
    context "basic arithmetic":
        it "emits add instruction":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_add("%result", "i64", "%a", "%b")
            val ir = builder.build()
            expect(ir).to_contain("%result = add i64 %a, %b")

        it "emits sub instruction":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_sub("%result", "i64", "%a", "%b")
            val ir = builder.build()
            expect(ir).to_contain("%result = sub i64 %a, %b")

        it "emits mul instruction":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_mul("%result", "i64", "%a", "%b")
            val ir = builder.build()
            expect(ir).to_contain("%result = mul i64 %a, %b")

        it "emits div instruction":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_div("%result", "i64", "%a", "%b")
            val ir = builder.build()
            expect(ir).to_contain("%result = sdiv i64 %a, %b")

        it "emits neg instruction":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_neg("%result", "i64", "%value")
            val ir = builder.build()
            expect(ir).to_contain("%result = sub i64 0, %value")

# ============================================================================
# Bitwise Instruction Tests
# ============================================================================

describe "LLVM IR Builder - Bitwise":
    context "bitwise operations":
        it "emits and instruction":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_and("%result", "i64", "%a", "%b")
            val ir = builder.build()
            expect(ir).to_contain("%result = and i64 %a, %b")

        it "emits or instruction":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_or("%result", "i64", "%a", "%b")
            val ir = builder.build()
            expect(ir).to_contain("%result = or i64 %a, %b")

        it "emits xor instruction":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_xor("%result", "i64", "%a", "%b")
            val ir = builder.build()
            expect(ir).to_contain("%result = xor i64 %a, %b")

        it "emits shl instruction":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_shl("%result", "i64", "%value", "%amount")
            val ir = builder.build()
            expect(ir).to_contain("%result = shl i64 %value, %amount")

        it "emits not instruction":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_not("%result", "i64", "%value")
            val ir = builder.build()
            expect(ir).to_contain("%result = xor i64 %value, -1")

# ============================================================================
# Comparison Instruction Tests
# ============================================================================

describe "LLVM IR Builder - Comparisons":
    context "integer comparisons":
        it "emits eq comparison":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_icmp_eq("%result", "i64", "%a", "%b")
            val ir = builder.build()
            expect(ir).to_contain("%result = icmp eq i64 %a, %b")

        it "emits slt comparison":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_icmp_slt("%result", "i64", "%a", "%b")
            val ir = builder.build()
            expect(ir).to_contain("%result = icmp slt i64 %a, %b")

    context "float comparisons":
        it "emits oeq comparison":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_fcmp_oeq("%result", "double", "%a", "%b")
            val ir = builder.build()
            expect(ir).to_contain("%result = fcmp oeq double %a, %b")

# ============================================================================
# Memory Instruction Tests
# ============================================================================

describe "LLVM IR Builder - Memory":
    context "memory operations":
        it "emits alloca with alignment":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_alloca("%ptr", "i64")
            val ir = builder.build()
            expect(ir).to_contain("%ptr = alloca i64, align 8")

        it "emits load with alignment":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_load("%value", "i64", "%ptr")
            val ir = builder.build()
            expect(ir).to_contain("%value = load i64, ptr %ptr, align 8")

        it "emits store with alignment":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_store("i64", "%value", "%ptr")
            val ir = builder.build()
            expect(ir).to_contain("store i64 %value, ptr %ptr, align 8")

        it "emits gep instruction":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_gep("%ptr", "i64", "%base", ["i32 0", "i32 1"])
            val ir = builder.build()
            expect(ir).to_contain("%ptr = getelementptr i64, ptr %base, i32 0, i32 1")

# ============================================================================
# Control Flow Tests
# ============================================================================

describe "LLVM IR Builder - Control Flow":
    context "branches and returns":
        it "emits unconditional branch":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_br("label1")
            val ir = builder.build()
            expect(ir).to_contain("br label %label1")

        it "emits conditional branch":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_cond_br("%cond", "then", "else")
            val ir = builder.build()
            expect(ir).to_contain("br i1 %cond, label %then, label %else")

        it "emits return with value":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_ret("i64", "%value")
            val ir = builder.build()
            expect(ir).to_contain("ret i64 %value")

        it "emits void return":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_ret_void()
            val ir = builder.build()
            expect(ir).to_contain("ret void")

        it "emits switch":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            val cases = [("0", "case0"), ("1", "case1")]
            builder.emit_switch("%value", "i64", "default", cases)
            val ir = builder.build()
            expect(ir).to_contain("switch i64 %value, label %default")

        it "emits label":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_label("loop")
            val ir = builder.build()
            expect(ir).to_contain("loop:")

# ============================================================================
# Function Call Tests
# ============================================================================

describe "LLVM IR Builder - Function Calls":
    context "direct calls":
        it "emits call with return value":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_call(Some("%result"), "i64", "foo", ["i64 %a"])
            val ir = builder.build()
            expect(ir).to_contain("%result = call i64 @foo(i64 %a)")

        it "emits call without return value":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_call(nil, "void", "bar", [])
            val ir = builder.build()
            expect(ir).to_contain("call void @bar()")

    context "indirect calls":
        it "emits indirect call":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            builder.emit_call_indirect(Some("%result"), "i64", "%func_ptr", ["i64 %a"])
            val ir = builder.build()
            expect(ir).to_contain("%result = call i64 %func_ptr(i64 %a)")

# ============================================================================
# Fresh Local Generation Tests
# ============================================================================

describe "LLVM IR Builder - Local Generation":
    context "fresh locals":
        it "generates unique local names":
            val triple = LlvmTargetTriple.x86_64_linux()
            var builder = LlvmIRBuilder.create("test", triple)
            val local1 = builder.fresh_local()
            val local2 = builder.fresh_local()
            val local3 = builder.fresh_local()
            expect(local1).to_equal("%0")
            expect(local2).to_equal("%1")
            expect(local3).to_equal("%2")

# ============================================================================
# Optimization Pass Tests
# ============================================================================

describe "LLVM IR Builder - Optimization Passes":
    context "pass selection":
        it "returns empty passes for nil level":
            val passes = passes_for_level(nil)
            expect(passes.len()).to_equal(0)

        it "returns debug passes":
            val passes = passes_for_level(OptimizationLevel.Debug)
            expect(passes.len()).to_be_greater_than(0)

        it "returns speed passes":
            val passes = passes_for_level(OptimizationLevel.Speed)
            expect(passes.len()).to_be_greater_than(0)

    context "pass text conversion":
        it "converts InstCombine to text":
            val llvm_pass = LlvmPass.InstCombine
            expect(llvm_pass.to_text()).to_equal("instcombine")

        it "converts SimplifyCFG to text":
            val llvm_pass = LlvmPass.SimplifyCFG
            expect(llvm_pass.to_text()).to_equal("simplifycfg")
