describe "Wffi Bindgen":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Tests for WFFI bindgen wrapper generation.
# # No imports - all logic is replicated at module level.
# 
# # ============================================================================
# # Module-level helpers (replicate bindgen logic without imports)
# # ============================================================================
# 
# struct WffiParamSpec:
#     name: text
#     type_name: text
# 
# struct WffiFunctionSpec:
#     name: text
#     params: [WffiParamSpec]
#     has_return: bool
#     return_type: text
# 
# struct WffiBindingSpec:
#     lib_name: text
#     functions: [WffiFunctionSpec]
#     handle_var: text
# 
# fn spec_lib_name_to_safe(lib_name: text) -> text:
#     # Convert "libm.so" or "libm.so.6" to "libm" (safe identifier).
#     var result = lib_name
#     # Strip "lib" prefix
#     if result.len() >= 3:
#         if result[0:3] == "lib":
#             result = result[3:result.len()]
#     # Strip ".so" suffix and everything after
#     var i: i64 = 0
#     while i < result.len():
#         if result[i:i+1] == ".":
#             result = result[0:i]
#             i = result.len()  # stop
#         i = i + 1
#     result
# 
# fn spec_wffi_rt_call_fn(return_type: text) -> text:
#     # Map a return type to the rt_wffi_call_* function name.
#     if return_type == "f64":
#         return "rt_wffi_call_f64"
#     elif return_type == "i64":
#         return "rt_wffi_call_i64"
#     elif return_type == "bool":
#         return "rt_wffi_call_bool"
#     elif return_type == "text":
#         return "rt_wffi_call_text"
#     elif return_type == "i32":
#         return "rt_wffi_call_i32"
#     else:
#         return "rt_wffi_call_i64"
# 
# fn spec_wffi_params_to_text(params: [WffiParamSpec]) -> text:
#     var result = ""
#     var i: i64 = 0
#     while i < params.len():
#         val p = params[i]
#         if i > 0:
#             result = result + ", "
#         result = result + p.name + ": " + p.type_name
#         i = i + 1
#     result
# 
# fn spec_wffi_binding_new(lib_name: text) -> WffiBindingSpec:
#     val safe_name = spec_lib_name_to_safe(lib_name)
#     WffiBindingSpec(
#         lib_name: lib_name,
#         functions: [],
#         handle_var: "wffi_" + safe_name + "_handle"
#     )
# 
# fn spec_wffi_binding_add_fn(binding: WffiBindingSpec, func: WffiFunctionSpec) -> WffiBindingSpec:
#     val new_fns = binding.functions + [func]
#     WffiBindingSpec(lib_name: binding.lib_name, functions: new_fns, handle_var: binding.handle_var)
# 
# fn spec_wffi_generate_loader(binding: WffiBindingSpec) -> text:
#     val safe = spec_lib_name_to_safe(binding.lib_name)
#     val load_fn = "wffi_load_" + safe
#     var code = "fn " + load_fn + "() -> i64:\n"
#     code = code + "    rt_wffi_load(\"" + binding.lib_name + "\")\n"
#     code = code + "\n"
#     code = code + "var " + binding.handle_var + ": i64 = 0\n"
#     code = code + "\n"
#     code = code + "fn " + safe + "_init():\n"
#     code = code + "    " + binding.handle_var + " = " + load_fn + "()\n"
#     code
# 
# fn spec_wffi_generate_function(binding: WffiBindingSpec, func: WffiFunctionSpec) -> text:
#     val param_names = spec_wffi_params_to_text(func.params)
#     var code = ""
#     if func.has_return:
#         val call_fn = spec_wffi_rt_call_fn(func.return_type)
#         code = "fn " + func.name + "(" + param_names + ") -> " + func.return_type + ":\n"
#         code = code + "    " + call_fn + "(" + binding.handle_var + ", \"" + func.name + "\")\n"
#     else:
#         code = "fn " + func.name + "(" + param_names + "):\n"
#         code = code + "    rt_wffi_call_void(" + binding.handle_var + ", \"" + func.name + "\")\n"
#     code
# 
# # ============================================================================
# # Tests
# # ============================================================================
# 
# describe "lib_name_to_safe":
#     it "strips lib prefix and .so suffix from libm.so":
#         expect(spec_lib_name_to_safe("libm.so")).to_equal("libm")
# 
#     it "strips lib prefix and .so.6 suffix from libc.so.6":
#         expect(spec_lib_name_to_safe("libc.so.6")).to_equal("libc")
# 
#     it "strips lib prefix from libpthread.so":
#         expect(spec_lib_name_to_safe("libpthread.so")).to_equal("pthread")
# 
#     it "strips only .so suffix when no lib prefix (sqlite3.so)":
#         expect(spec_lib_name_to_safe("sqlite3.so")).to_equal("sqlite3")
# 
# describe "wffi_rt_call_fn":
#     it "returns rt_wffi_call_f64 for f64":
#         expect(spec_wffi_rt_call_fn("f64")).to_equal("rt_wffi_call_f64")
# 
#     it "returns rt_wffi_call_i64 for i64":
#         expect(spec_wffi_rt_call_fn("i64")).to_equal("rt_wffi_call_i64")
# 
#     it "returns rt_wffi_call_text for text":
#         expect(spec_wffi_rt_call_fn("text")).to_equal("rt_wffi_call_text")
# 
#     it "returns rt_wffi_call_bool for bool":
#         expect(spec_wffi_rt_call_fn("bool")).to_equal("rt_wffi_call_bool")
# 
# describe "wffi_params_to_text":
#     it "returns empty string for empty params":
#         val empty: [WffiParamSpec] = []
#         expect(spec_wffi_params_to_text(empty)).to_equal("")
# 
#     it "formats a single param as name: type":
#         val params = [WffiParamSpec(name: "x", type_name: "f64")]
#         expect(spec_wffi_params_to_text(params)).to_equal("x: f64")
# 
#     it "formats two params separated by comma-space":
#         val params = [
#             WffiParamSpec(name: "x", type_name: "f64"),
#             WffiParamSpec(name: "y", type_name: "f64")
#         ]
#         expect(spec_wffi_params_to_text(params)).to_equal("x: f64, y: f64")
# 
# describe "wffi_binding_new":
#     it "sets handle_var to wffi_libm_handle for libm.so":
#         val b = spec_wffi_binding_new("libm.so")
#         expect(b.handle_var).to_equal("wffi_libm_handle")
# 
# describe "wffi_binding_add_fn":
#     it "increases function count after adding a function":
#         val b = spec_wffi_binding_new("libm.so")
#         val empty: [WffiParamSpec] = []
#         val func = WffiFunctionSpec(name: "sqrt", params: empty, has_return: true, return_type: "f64")
#         val b2 = spec_wffi_binding_add_fn(b, func)
#         expect(b2.functions.len()).to_equal(1)
# 
# describe "wffi_generate_loader":
#     it "contains the library name in the generated loader code":
#         val b = spec_wffi_binding_new("libm.so")
#         val code = spec_wffi_generate_loader(b)
#         expect(code).to_contain("libm.so")
# 
# describe "wffi_generate_function":
#     it "contains the function name in the generated wrapper code":
#         val b = spec_wffi_binding_new("libm.so")
#         val empty: [WffiParamSpec] = []
#         val func = WffiFunctionSpec(name: "sqrt", params: empty, has_return: true, return_type: "f64")
#         val code = spec_wffi_generate_function(b, func)
#         expect(code).to_contain("sqrt")
