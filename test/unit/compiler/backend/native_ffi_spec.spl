"""
# Native FFI Bridge Specification

Tests the FFI bridge for native compilation and execution.

**Feature IDs:** #FFI-001 to #FFI-010
**Category:** Backend / Native Execution
**Status:** Partially Testable

## Overview

Tests are split into safe groups (file operations, compilation stubs) that
run normally, and unsafe groups (rt_execute_native) that are @skip'd because
rt_execute_native hangs in the current runtime.
"""

use std.spec
use std.text.{NL}
use app.io.file_ops.{file_delete, file_write, file_read, file_exists}
use app.io.time_ops.{time_now_unix_micros}

# Import the FFI functions that don't have wrappers yet
extern fn rt_compile_to_native(source_path: text, output_path: text) -> (bool, text)
extern fn rt_execute_native(binary_path: text, args: List<text>, timeout_ms: i64) -> (text, text, i32)


# ============================================================================
# Safe Group 1: File Operations (no rt_execute_native)
# ============================================================================

describe "Native FFI File Operations":
    """
    ## File I/O FFI Functions

    Tests for file_write, file_read, file_exists,
    and file_delete. These all work correctly in the current runtime.
    """

    context "file_delete":
        it "returns boolean":
            val result = file_delete("/tmp/nonexistent_file_xyz")
            expect(result == true or result == false).to_equal(true)

        it "returns false for non-existent file":
            val result = file_delete("/tmp/nonexistent_file_12345_xyz")
            expect(result).to_equal(false)

        it "successfully deletes existing file":
            val temp_path = "/tmp/test_delete_12345.tmp"
            file_write(temp_path, "test content")
            expect(file_exists(temp_path)).to_equal(true)

            val result = file_delete(temp_path)
            expect(result).to_equal(true)
            expect(file_exists(temp_path)).to_equal(false)

        it "handles deletion of already deleted file":
            val temp_path = "/tmp/test_delete_twice_12345.tmp"
            file_write(temp_path, "test")
            file_delete(temp_path)

            val result = file_delete(temp_path)
            expect(result).to_equal(false)

        it "handles empty path":
            val result = file_delete("")
            expect(result).to_equal(false)

        it "handles path with special characters":
            val temp_path = "/tmp/test file with spaces.tmp"
            file_write(temp_path, "test")

            val result = file_delete(temp_path)
            expect(result).to_equal(true)

    context "write and read round-trip":
        it "writes then reads back same content":
            val temp_path = "/tmp/test_roundtrip_ffi.tmp"
            val content = "Hello, FFI round-trip test!"
            file_write(temp_path, content)

            val read_back = file_read(temp_path)
            expect(read_back).to_equal(content)

            file_delete(temp_path)

        it "handles large content":
            val temp_path = "/tmp/test_large_ffi.tmp"
            # Build a string with repeated content
            var content = ""
            for i in 0..100:
                content = content + "Line {i}: This is test content for large file write.{NL}"

            file_write(temp_path, content)
            expect(file_exists(temp_path)).to_equal(true)

            val result = file_delete(temp_path)
            expect(result).to_equal(true)
            expect(file_exists(temp_path)).to_equal(false)

    context "sequential file operations":
        it "handles multiple sequential creates and deletes":
            val temp1 = "/tmp/test_seq_1.tmp"
            val temp2 = "/tmp/test_seq_2.tmp"

            file_write(temp1, "content1")
            file_write(temp2, "content2")

            expect(file_exists(temp1)).to_equal(true)
            expect(file_exists(temp2)).to_equal(true)

            expect(file_delete(temp1)).to_equal(true)
            expect(file_delete(temp2)).to_equal(true)

            expect(file_exists(temp1)).to_equal(false)
            expect(file_exists(temp2)).to_equal(false)

        it "handles create-delete-recreate cycle":
            val temp_path = "/tmp/test_cycle_ffi.tmp"

            file_write(temp_path, "first")
            expect(file_exists(temp_path)).to_equal(true)

            file_delete(temp_path)
            expect(file_exists(temp_path)).to_equal(false)

            file_write(temp_path, "second")
            expect(file_exists(temp_path)).to_equal(true)

            file_delete(temp_path)


# ============================================================================
# Safe Group 2: Compilation Stubs (no rt_execute_native)
# ============================================================================

describe "Native FFI Compilation":
    """
    ## Native Compilation FFI Functions

    Tests for rt_compile_to_native which currently returns a
    "not implemented" stub. These tests verify the stub behavior
    and do not involve rt_execute_native.
    """

    it "returns tuple with success flag and error message":
        val (success, error) = rt_compile_to_native("test.spl", "test.out")
        expect(success == false or success == true).to_equal(true)

    it "returns false for non-existent source file":
        val (success, error) = rt_compile_to_native("/nonexistent/file.spl", "out")
        expect(success).to_equal(false)

    it "returns not-implemented message currently":
        val (success, error) = rt_compile_to_native("", "")
        expect(success).to_equal(false)
        expect(error.len()).to_be_greater_than(0)

    it "handles empty paths gracefully":
        val (success, error) = rt_compile_to_native("", "")
        expect(success).to_equal(false)

    it "returns error for invalid source path":
        val (success, error) = rt_compile_to_native("/invalid/path/file.spl", "output")
        expect(success).to_equal(false)

    it "handles unusual characters in paths":
        val (success, error) = rt_compile_to_native("test?.spl", "out")
        expect(success).to_equal(false)

    it "handles very long paths":
        val long_path = "/tmp/" + ("a" * 1000) + ".spl"
        val (success, error) = rt_compile_to_native(long_path, "out")
        expect(success).to_equal(false)

    context "compile and cleanup integration":
        it "can attempt compile and cleanup files":
            val source = "/tmp/test_native_compile.spl"
            val binary = "/tmp/test_native_binary"

            val program = "fn main():{NL}    print \"Hello\"{NL}"
            file_write(source, program)

            val (success, error) = rt_compile_to_native(source, binary)

            # Expected to fail currently (not implemented)
            if not success:
                expect(error.len()).to_be_greater_than(0)

            # Cleanup
            file_delete(source)
            file_delete(binary)


# ============================================================================
# Unsafe Group 3: Execution (@skip - rt_execute_native hangs)
# ============================================================================

describe "Native FFI Execution":
    """
    ## Native Execution FFI Functions

    slow_it: rt_execute_native hangs in the current runtime.

    Tests for executing native binaries with timeout support.
    """

    # All tests use rt_execute_native which hangs - marked slow_it
    slow_it "returns tuple with stdout, stderr, and exit code":
        val (stdout, stderr, code) = rt_execute_native("/bin/echo", ["hello"], 5000)
        expect(stdout).to_contain("hello")
        expect(code).to_equal(0)

    slow_it "returns error for non-existent binary":
        val (stdout, stderr, code) = rt_execute_native("/nonexistent/binary", [], 5000)
        expect(code).to_be_greater_than(0)

    slow_it "respects timeout":
        val (stdout, stderr, code) = rt_execute_native("/bin/sleep", ["0.001"], 10)
        expect(code == 0 or code == 124).to_equal(true)

    slow_it "passes arguments correctly":
        val (stdout, stderr, code) = rt_execute_native("/bin/echo", ["arg1", "arg2"], 5000)
        expect(stdout).to_contain("arg1")
        expect(stdout).to_contain("arg2")
        expect(code).to_equal(0)

    slow_it "captures stderr separately":
        val (stdout, stderr, code) = rt_execute_native("/bin/sh", ["-c", "echo error >&2"], 5000)
        expect(code).to_equal(0)

    slow_it "handles empty argument list":
        val (stdout, stderr, code) = rt_execute_native("/bin/true", [], 5000)
        expect(code).to_equal(0)

    slow_it "handles large timeout values":
        val (stdout, stderr, code) = rt_execute_native("/bin/echo", ["test"], 3600000)
        expect(code).to_equal(0)
        expect(stdout).to_contain("test")


# ============================================================================
# Unsafe Group 4: Error Handling (@skip - uses rt_execute_native)
# ============================================================================

describe "Native Execution Error Handling":
    """
    ## Execution Error Conditions

    slow_it: Tests use rt_execute_native which hangs.

    Tests error conditions and edge cases for native execution.
    """

    # All tests use rt_execute_native which hangs - marked slow_it
    slow_it "handles invalid UTF-8 in binary output":
        val (stdout, stderr, code) = rt_execute_native("/bin/echo", ["test"], 5000)
        expect(stdout).to_contain("test")

    slow_it "handles zero timeout":
        val (stdout, stderr, code) = rt_execute_native("/bin/sleep", ["10"], 0)
        expect(code == 124 or code == -1).to_equal(true)

    slow_it "handles negative timeout":
        val (stdout, stderr, code) = rt_execute_native("/bin/true", [], -1)
        expect(code == 0 or code == -1).to_equal(true)


# ============================================================================
# Unsafe Group 5: Performance (@skip - uses rt_execute_native)
# ============================================================================

describe "Performance Characteristics":
    """
    ## Performance Tests

    slow_it: Uses rt_execute_native which hangs.
    """

    # Uses rt_execute_native which hangs - marked slow_it
    slow_it "executes simple binary quickly":
        val start = time_now_unix_micros()
        val (stdout, stderr, code) = rt_execute_native("/bin/true", [], 5000)
        val end = time_now_unix_micros()
        val duration_ms = (end - start) / 1000

        expect(code).to_equal(0)
        expect(duration_ms).to_be_less_than(100)

    slow_it "handles concurrent executions":
        var all_succeeded = true

        for i in 0..10:
            val (stdout, stderr, code) = rt_execute_native("/bin/echo", ["test"], 5000)
            if code != 0:
                all_succeeded = false

        expect(all_succeeded).to_equal(true)
