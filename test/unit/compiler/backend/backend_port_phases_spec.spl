# BackendPort Phases Spec
#
# Comprehensive phase tests for Feature 1: BackendPort Typed Composition Root.
# BackendPort is a struct-with-fn-fields replacing string-keyed DI for backends.
#
# Feature: BackendPort Typed Composition Root (Feature 1)
# Design: doc/research/di_composition_root_design.md Option A

use compiler.compiler_services.{create_default_services}

# ============================================================================
# Phase 1 - Basic API: BackendPort struct construction and field access
# ============================================================================

describe "BackendPort: Phase 1 - Basic API":

    context "struct construction via factory":
        it "creates backend port with name field":
            val services = create_default_services()
            val backend = services.backend
            expect(backend.name).to_equal("noop-backend")

        it "backend port has run_fn field":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.run_fn
            expect(f).to_equal(f)

        it "backend port has supports_jit_fn field":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.supports_jit_fn
            expect(f).to_equal(f)

        it "backend port has target_triple_fn field":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.target_triple_fn
            expect(f).to_equal(f)

    context "fn-field invocation":
        it "supports_jit_fn returns false for noop backend":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.supports_jit_fn
            val result = f()
            expect(result).to_equal(false)

        it "target_triple_fn returns noop for noop backend":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.target_triple_fn
            val result = f()
            expect(result).to_equal("noop")

        it "name distinguishes backend implementations":
            val services = create_default_services()
            val backend = services.backend
            expect(backend.name).to_start_with("noop")

# ============================================================================
# Phase 2 - Integration: BackendPort embedded in CompilerServices
# ============================================================================

describe "BackendPort: Phase 2 - Integration":

    context "backend port inside CompilerServices":
        it "CompilerServices has backend field with name":
            val services = create_default_services()
            val name = services.backend.name
            expect(name).to_equal("noop-backend")

        it "backend port is separate from other ports":
            val services = create_default_services()
            val lexer_name = services.lexer.name
            val backend_name = services.backend.name
            expect(lexer_name).to_equal("noop-lexer")
            expect(backend_name).to_equal("noop-backend")

        it "backend port and parser port are independent":
            val services = create_default_services()
            val parser_name = services.parser.name
            val backend_name = services.backend.name
            expect(parser_name).to_equal("noop-parser")
            expect(backend_name).to_equal("noop-backend")

    context "custom backend port construction":
        it "can construct custom backend port with typed fn-fields":
            var call_count = 0
            fn my_supports_jit() -> bool: true
            fn my_target_triple() -> text: "x86_64-linux"
            fn my_run(m) -> text: "ran"
            val custom_backend_name = "custom-test-backend"
            val f_jit = my_supports_jit
            val result = f_jit()
            expect(result).to_equal(true)

        it "target_triple identifies backend type":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.target_triple_fn
            val triple = f()
            expect(triple).to_equal("noop")

        it "supports_jit reflects backend capability":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.supports_jit_fn
            val jit_support = f()
            expect(jit_support).to_equal(false)

# ============================================================================
# Phase 3 - System behavior: BackendPort replaces string-keyed DI
# ============================================================================

describe "BackendPort: Phase 3 - System behavior":

    context "typed contract enforced":
        it "backend name is always a text value":
            val services = create_default_services()
            val backend = services.backend
            val n = backend.name
            expect(n.len()).to_be_greater_than(0)

        it "noop backend has consistent identity":
            val s1 = create_default_services()
            val s2 = create_default_services()
            expect(s1.backend.name).to_equal(s2.backend.name)

        it "backend fn-fields are non-nil":
            val services = create_default_services()
            val backend = services.backend
            val f1 = backend.supports_jit_fn
            val f2 = backend.target_triple_fn
            val r1 = f1()
            val r2 = f2()
            expect(r1).to_equal(false)
            expect(r2).to_equal("noop")

    context "edge cases":
        it "calling supports_jit multiple times gives same result":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.supports_jit_fn
            val r1 = f()
            val r2 = f()
            expect(r1).to_equal(r2)

        it "calling target_triple multiple times gives same result":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.target_triple_fn
            val r1 = f()
            val r2 = f()
            expect(r1).to_equal(r2)

        it "two separate service instances have independent backends":
            val s1 = create_default_services()
            val s2 = create_default_services()
            val b1 = s1.backend
            val b2 = s2.backend
            val f1 = b1.supports_jit_fn
            val f2 = b2.supports_jit_fn
            val r1 = f1()
            val r2 = f2()
            expect(r1).to_equal(r2)
