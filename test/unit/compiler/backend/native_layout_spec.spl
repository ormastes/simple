# Native Backend Layout Optimization Tests
#
# Unit tests for layout solver and function ordering.

use std.spec
use compiler.mir_data.{MirModule, MirFunction, MirSignature, MirType, MirBlock, BlockId, LayoutPhase}
use compiler.backend.native.layout_solver.{solve_layout, HotnessProfile, LayoutPlan, LayoutGroup}
use hir.SymbolId

# ============================================================================
# Test Helpers
# ============================================================================

fn make_test_function(name: text, phase: LayoutPhase?) -> MirFunction:
    """Create a minimal test function."""
    MirFunction(
        symbol: SymbolId(id: 0),
        name: name,
        signature: MirSignature(
            params: [],
            return_type: MirType.unit(),
            is_variadic: false
        ),
        locals: [],
        blocks: [MirBlock(
            id: BlockId(id: 0),
            instructions: [],
            terminator: nil,
            predecessors: [],
            span: nil
        )],
        entry_block: BlockId(id: 0),
        span: nil,
        generic_params: [],
        is_generic_template: false,
        specialization_of: nil,
        type_bindings: {},
        layout_phase: phase
    )

fn make_test_module(functions: [MirFunction]) -> MirModule:
    """Create a minimal test module."""
    var func_map: Dict<SymbolId, MirFunction> = {}
    var id = 0
    for func in functions:
        func_map[SymbolId(id: id)] = func
        id = id + 1

    MirModule(
        name: "test_module",
        functions: func_map,
        statics: {},
        constants: {},
        types: {}
    )

# ============================================================================
# Layout Phase Inference Tests
# ============================================================================

describe "Layout Phase Inference":
    context "startup functions":
        it "infers Startup phase for init functions":
            val func = make_test_function("init_runtime", nil)
            val module = make_test_module([func])
            val plan = solve_layout(module, nil)

            expect(plan.groups.len()).to_be_greater_than(0)
            # Should have startup group
            var has_startup = false
            for group in plan.groups:
                if group.phase == LayoutPhase.Startup:
                    has_startup = true
            expect(has_startup).to_equal(true)

        it "infers Startup phase for _start":
            val func = make_test_function("_start", nil)
            val module = make_test_module([func])
            val plan = solve_layout(module, nil)

            # Should infer startup phase
            var found_in_startup = false
            for group in plan.groups:
                if group.phase == LayoutPhase.Startup:
                    for f in group.functions:
                        if f.name == "_start":
                            found_in_startup = true
            expect(found_in_startup).to_equal(true)

    context "cold functions":
        it "infers Cold phase for error handlers":
            val func = make_test_function("error_handler", nil)
            val module = make_test_module([func])
            val plan = solve_layout(module, nil)

            var found_in_cold = false
            for group in plan.groups:
                if group.phase == LayoutPhase.Cold:
                    for f in group.functions:
                        if f.name == "error_handler":
                            found_in_cold = true
            expect(found_in_cold).to_equal(true)

        it "infers Cold phase for panic functions":
            val func = make_test_function("panic_abort", nil)
            val module = make_test_module([func])
            val plan = solve_layout(module, nil)

            var found_in_cold = false
            for group in plan.groups:
                if group.phase == LayoutPhase.Cold:
                    found_in_cold = true
            expect(found_in_cold).to_equal(true)

    context "steady state functions":
        it "defaults to Steady phase for regular functions":
            val func = make_test_function("compute", nil)
            val module = make_test_module([func])
            val plan = solve_layout(module, nil)

            var found_in_steady = false
            for group in plan.groups:
                if group.phase == LayoutPhase.Steady:
                    for f in group.functions:
                        if f.name == "compute":
                            found_in_steady = true
            expect(found_in_steady).to_equal(true)

# ============================================================================
# Explicit Phase Assignment Tests
# ============================================================================

describe "Explicit Phase Assignment":
    context "phase attribute":
        it "respects explicit Startup phase":
            val func = make_test_function("my_func", LayoutPhase.Startup)
            val module = make_test_module([func])
            val plan = solve_layout(module, nil)

            var found = false
            for group in plan.groups:
                if group.phase == LayoutPhase.Startup:
                    for f in group.functions:
                        if f.name == "my_func":
                            found = true
            expect(found).to_equal(true)

        it "respects explicit Cold phase":
            val func = make_test_function("rarely_called", LayoutPhase.Cold)
            val module = make_test_module([func])
            val plan = solve_layout(module, nil)

            var found = false
            for group in plan.groups:
                if group.phase == LayoutPhase.Cold:
                    for f in group.functions:
                        if f.name == "rarely_called":
                            found = true
            expect(found).to_equal(true)

# ============================================================================
# Hotness Scoring Tests
# ============================================================================

describe "Hotness Scoring":
    context "default hotness":
        it "assigns high hotness to main":
            val func = make_test_function("main", nil)
            val module = make_test_module([func])
            val plan = solve_layout(module, nil)

            var main_hotness = 0.0
            for group in plan.groups:
                for f in group.functions:
                    if f.name == "main":
                        main_hotness = f.hotness_score
            expect(main_hotness).to_be_greater_than(50.0)

        it "assigns low hotness to test functions":
            val func = make_test_function("test_something", nil)
            val module = make_test_module([func])
            val plan = solve_layout(module, nil)

            var hotness = 0.0
            for group in plan.groups:
                for f in group.functions:
                    if f.name == "test_something":
                        hotness = f.hotness_score
            expect(hotness).to_be_less_than(10.0)

    context "profile-guided hotness":
        it "uses execution counts from profile":
            val func = make_test_function("hot_loop", nil)
            val module = make_test_module([func])

            var profile = HotnessProfile.empty()
            profile.execution_counts["hot_loop"] = 10000

            val plan = solve_layout(module, profile)

            var hotness = 0.0
            for group in plan.groups:
                for f in group.functions:
                    if f.name == "hot_loop":
                        hotness = f.hotness_score
            expect(hotness).to_be_greater_than(5000.0)

# ============================================================================
# Function Ordering Tests
# ============================================================================

describe "Function Ordering":
    context "phase ordering":
        it "orders phases correctly: Startup -> FirstFrame -> Steady -> Cold":
            val funcs = [
                make_test_function("cold_func", LayoutPhase.Cold),
                make_test_function("startup_func", LayoutPhase.Startup),
                make_test_function("steady_func", LayoutPhase.Steady),
                make_test_function("first_frame_func", LayoutPhase.FirstFrame)
            ]
            val module = make_test_module(funcs)
            val plan = solve_layout(module, nil)

            # Check phase order
            expect(plan.groups.len()).to_equal(4)
            expect(plan.groups[0].phase).to_equal(LayoutPhase.Startup)
            expect(plan.groups[1].phase).to_equal(LayoutPhase.FirstFrame)
            expect(plan.groups[2].phase).to_equal(LayoutPhase.Steady)
            expect(plan.groups[3].phase).to_equal(LayoutPhase.Cold)

    context "hotness ordering within phase":
        it "orders hottest functions first within phase":
            var profile = HotnessProfile.empty()
            profile.execution_counts["func_a"] = 1000
            profile.execution_counts["func_b"] = 5000
            profile.execution_counts["func_c"] = 3000

            val funcs = [
                make_test_function("func_a", LayoutPhase.Steady),
                make_test_function("func_b", LayoutPhase.Steady),
                make_test_function("func_c", LayoutPhase.Steady)
            ]
            val module = make_test_module(funcs)
            val plan = solve_layout(module, profile)

            # Find steady group
            var steady_funcs: [text] = []
            for group in plan.groups:
                if group.phase == LayoutPhase.Steady:
                    for f in group.functions:
                        steady_funcs.push(f.name)

            # func_b (5000) should come before func_c (3000) before func_a (1000)
            expect(steady_funcs[0]).to_equal("func_b")
            expect(steady_funcs[1]).to_equal("func_c")
            expect(steady_funcs[2]).to_equal("func_a")

# ============================================================================
# Page Alignment Tests
# ============================================================================

describe "Page Alignment":
    context "4KB alignment":
        it "aligns each phase group to 4KB boundary":
            val funcs = [
                make_test_function("startup", LayoutPhase.Startup),
                make_test_function("steady", LayoutPhase.Steady)
            ]
            val module = make_test_module(funcs)
            val plan = solve_layout(module, nil)

            # Check that offsets are page-aligned
            for group in plan.groups:
                val offset = group.start_offset
                val page_size = 4096
                val remainder = offset % page_size
                expect(remainder).to_equal(0)

    context "total size calculation":
        it "includes padding in total size":
            val funcs = [
                make_test_function("f1", LayoutPhase.Startup),
                make_test_function("f2", LayoutPhase.Steady)
            ]
            val module = make_test_module(funcs)
            val plan = solve_layout(module, nil)

            # Total size should be > sum of function sizes due to padding
            expect(plan.total_size).to_be_greater_than(0)
            expect(plan.page_count).to_be_greater_than(0)

# ============================================================================
# Empty Module Tests
# ============================================================================

describe "Edge Cases":
    context "empty module":
        it "handles module with no functions":
            val module = make_test_module([])
            val plan = solve_layout(module, nil)

            expect(plan.groups.len()).to_equal(0)
            expect(plan.total_size).to_equal(0)

    context "single function":
        it "handles module with one function":
            val func = make_test_function("only_func", nil)
            val module = make_test_module([func])
            val plan = solve_layout(module, nil)

            expect(plan.groups.len()).to_be_greater_than(0)
            var total_funcs = 0
            for group in plan.groups:
                total_funcs = total_funcs + group.functions.len()
            expect(total_funcs).to_equal(1)

# ============================================================================
# Plan Validity Tests
# ============================================================================

describe "Plan Validity":
    context "completeness":
        it "includes all functions from module":
            val funcs = [
                make_test_function("f1", nil),
                make_test_function("f2", nil),
                make_test_function("f3", nil)
            ]
            val module = make_test_module(funcs)
            val plan = solve_layout(module, nil)

            var func_count = 0
            for group in plan.groups:
                func_count = func_count + group.functions.len()
            expect(func_count).to_equal(3)

    context "no duplicates":
        it "does not duplicate functions across phases":
            val funcs = [
                make_test_function("unique1", LayoutPhase.Startup),
                make_test_function("unique2", LayoutPhase.Steady)
            ]
            val module = make_test_module(funcs)
            val plan = solve_layout(module, nil)

            var seen_names: Dict<text, bool> = {}
            for group in plan.groups:
                for f in group.functions:
                    expect(seen_names.contains_key(f.name)).to_equal(false)
                    seen_names[f.name] = true
