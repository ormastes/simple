# Backend Factory Specification
#
# Tests for the BackendFactory pattern that centralizes backend selection logic.

# # Backend Factory Specification
#
# **Feature ID**: #backend-factory
# **Category**: Backend
# **Status**: In Progress
#
# The BackendFactory provides centralized backend selection and creation logic,
# eliminating scattered match statements and making it easy to add new backends.
#
# ## Related Files
# - `src/compiler/backend/backend_factory.spl` - Factory implementation
# - `src/compiler/backend_api.spl` - Backend kinds and targets

use compiler.backend.backend_factory.*
use compiler.backend_api.*

fn slow_it(name: text, block: fn()):
    it(name, block)

describe "BackendFactory":
    # Centralized backend creation and selection.

    context "automatic backend selection":
        it "selects LLVM for 32-bit targets":
            val target = CodegenTarget.X86  # i686 32-bit
            val options = CompileOptions.default()

            val backend_kind = BackendFactory.auto_select(target, options.build_mode)

            expect backend_kind == BackendKind.Llvm

        it "selects LLVM for ARMv7 (32-bit)":
            val target = CodegenTarget.Arm
            val options = CompileOptions.default()

            val backend_kind = BackendFactory.auto_select(target, options.build_mode)

            expect backend_kind == BackendKind.Llvm

        it "selects LLVM for RISC-V 32":
            val target = CodegenTarget.Riscv32
            val options = CompileOptions.default()

            val backend_kind = BackendFactory.auto_select(target, options.build_mode)

            expect backend_kind == BackendKind.Llvm

        it "selects Cranelift for x86_64 in debug mode":
            val target = CodegenTarget.X86_64
            val options = CompileOptions(build_mode: BuildMode.Debug)

            val backend_kind = BackendFactory.auto_select(target, options.build_mode)

            expect backend_kind == BackendKind.Cranelift

        it "selects LLVM for x86_64 in release mode":
            val target = CodegenTarget.X86_64
            val options = CompileOptions(build_mode: BuildMode.Release)

            val backend_kind = BackendFactory.auto_select(target, options.build_mode)

            expect backend_kind == BackendKind.Llvm

        it "selects Interpreter for test mode":
            val target = CodegenTarget.X86_64
            val options = CompileOptions(build_mode: BuildMode.Test)

            val backend_kind = BackendFactory.auto_select(target, options.build_mode)

            expect backend_kind == BackendKind.Interpreter

        it "selects Cranelift for bootstrap mode":
            val target = CodegenTarget.X86_64
            val options = CompileOptions(build_mode: BuildMode.Bootstrap)

            val backend_kind = BackendFactory.auto_select(target, options.build_mode)

            expect backend_kind == BackendKind.Cranelift

        it "selects Wasm backend for WebAssembly targets":
            val target = CodegenTarget.Wasm32
            val options = CompileOptions.default()

            val backend_kind = BackendFactory.auto_select(target, options.build_mode)

            expect backend_kind == BackendKind.Wasm

    context "user backend override":
        it "respects explicit Cranelift selection":
            val target = CodegenTarget.X86_64
            val options = CompileOptions(
                build_mode: BuildMode.Release,
                backend_kind: Some(BackendKind.Cranelift)
            )

            val backend = BackendFactory.create(target, options)

            expect backend.kind() == BackendKind.Cranelift

        it "respects explicit LLVM selection":
            val target = CodegenTarget.X86_64
            val options = CompileOptions(
                build_mode: BuildMode.Debug,
                backend_kind: Some(BackendKind.Llvm)
            )

            val backend = BackendFactory.create(target, options)

            expect backend.kind() == BackendKind.Llvm

        it "allows forcing Cranelift for release on 64-bit":
            val target = CodegenTarget.X86_64
            val options = CompileOptions(
                build_mode: BuildMode.Release,
                backend_kind: Some(BackendKind.Cranelift)
            )

            val backend_kind = if options.backend_kind.?:
                options.backend_kind.unwrap()
            else:
                BackendFactory.auto_select(target, options.build_mode)

            expect backend_kind == BackendKind.Cranelift

    context "backend creation":
        it "creates Cranelift backend successfully":
            val target = CodegenTarget.X86_64
            val options = CompileOptions(build_mode: BuildMode.Debug)

            val backend = BackendFactory.create(target, options)

            expect backend.kind() == BackendKind.Cranelift
            expect backend.target() == target

        it "creates LLVM backend successfully":
            val target = CodegenTarget.X86_64
            val options = CompileOptions(build_mode: BuildMode.Release)

            val backend = BackendFactory.create(target, options)

            expect backend.kind() == BackendKind.Llvm
            expect backend.target() == target

        it "creates Interpreter backend successfully":
            val target = CodegenTarget.X86_64
            val options = CompileOptions(build_mode: BuildMode.Test)

            val backend = BackendFactory.create(target, options)

            expect backend.kind() == BackendKind.Interpreter

        it "passes compile options to backend":
            val target = CodegenTarget.X86_64
            val options = CompileOptions(
                build_mode: BuildMode.Release,
                opt_level: OptimizationLevel.Aggressive,
                debug_info: true
            )

            val backend = BackendFactory.create(target, options)

            expect backend.opt_level() == OptimizationLevel.Aggressive
            expect backend.debug_info() == true

    context "target support validation":
        it "validates Cranelift only supports 64-bit":
            expect BackendFactory.supports_target(BackendKind.Cranelift, CodegenTarget.X86_64) == true
            expect BackendFactory.supports_target(BackendKind.Cranelift, CodegenTarget.AArch64) == true
            expect BackendFactory.supports_target(BackendKind.Cranelift, CodegenTarget.X86) == false
            expect BackendFactory.supports_target(BackendKind.Cranelift, CodegenTarget.Arm) == false

        it "validates LLVM supports all targets":
            val targets = [
                CodegenTarget.X86_64, CodegenTarget.X86,
                CodegenTarget.AArch64, CodegenTarget.Arm,
                CodegenTarget.Riscv64, CodegenTarget.Riscv32
            ]

            for target in targets:
                expect BackendFactory.supports_target(BackendKind.Llvm, target) == true

        it "validates Wasm backend only supports Wasm targets":
            expect BackendFactory.supports_target(BackendKind.Wasm, CodegenTarget.Wasm32) == true
            expect BackendFactory.supports_target(BackendKind.Wasm, CodegenTarget.Wasm64) == true
            expect BackendFactory.supports_target(BackendKind.Wasm, CodegenTarget.X86_64) == false

        it "validates Interpreter supports all targets":
            val targets = [
                CodegenTarget.X86_64, CodegenTarget.X86,
                CodegenTarget.AArch64, CodegenTarget.Arm
            ]

            for target in targets:
                expect BackendFactory.supports_target(BackendKind.Interpreter, target) == true

    context "error handling":
        it "errors when selecting unsupported backend-target combination":
            val target = CodegenTarget.X86  # 32-bit
            val options = CompileOptions(
                backend_kind: Some(BackendKind.Cranelift)  # Doesn't support 32-bit
            )

            val result = BackendFactory.try_create(target, options)

            expect result.is_err()
            expect result.err().message.contains("not supported")

        it "provides helpful error message":
            val target = CodegenTarget.Arm  # ARMv7 32-bit
            val options = CompileOptions(
                backend_kind: Some(BackendKind.Cranelift)
            )

            val result = BackendFactory.try_create(target, options)

            expect result.is_err()
            val error = result.err()
            expect error.message.contains("Cranelift")
            expect error.message.contains("32-bit")
            expect error.message.contains("LLVM")  # Suggestion

    context "available backends":
        it "lists all available backends":
            val backends = BackendFactory.available_backends()

            expect backends.contains(BackendKind.Cranelift)
            expect backends.contains(BackendKind.Llvm)
            expect backends.contains(BackendKind.Wasm)
            expect backends.contains(BackendKind.Interpreter)
            expect backends.contains(BackendKind.Lean)

        it "provides backend capabilities":
            val cranelift_caps = BackendFactory.get_capabilities(BackendKind.Cranelift)

            expect cranelift_caps.supports_jit == true
            expect cranelift_caps.supports_aot == true
            expect cranelift_caps.supports_32bit == false

        it "provides backend description":
            val llvm_desc = BackendFactory.get_description(BackendKind.Llvm)

            expect llvm_desc.contains("LLVM")
            expect llvm_desc.contains("32-bit")
            expect llvm_desc.contains("64-bit")

describe "Backend Selection Strategy":
    # Test the selection strategy across different scenarios.

    context "build mode priority":
        it "debug mode prioritizes compilation speed":
            val target = CodegenTarget.X86_64
            val debug_options = CompileOptions(build_mode: BuildMode.Debug)

            val backend_kind = BackendFactory.auto_select(target, debug_options.build_mode)

            # Cranelift is faster to compile
            expect backend_kind == BackendKind.Cranelift

        it "release mode prioritizes code quality":
            val target = CodegenTarget.X86_64
            val release_options = CompileOptions(build_mode: BuildMode.Release)

            val backend_kind = BackendFactory.auto_select(target, release_options.build_mode)

            # LLVM generates better code
            expect backend_kind == BackendKind.Llvm

        it "test mode prioritizes no compilation overhead":
            val target = CodegenTarget.X86_64
            val test_options = CompileOptions(build_mode: BuildMode.Test)

            val backend_kind = BackendFactory.auto_select(target, test_options.build_mode)

            # Interpreter has zero compile time
            expect backend_kind == BackendKind.Interpreter

    context "target constraints":
        it "32-bit always uses LLVM regardless of mode":
            val target = CodegenTarget.X86
            val debug = CompileOptions(build_mode: BuildMode.Debug)
            val release = CompileOptions(build_mode: BuildMode.Release)

            expect BackendFactory.auto_select(target, debug.build_mode) == BackendKind.Llvm
            expect BackendFactory.auto_select(target, release.build_mode) == BackendKind.Llvm

        it "wasm always uses Wasm backend":
            val target = CodegenTarget.Wasm32
            val debug = CompileOptions(build_mode: BuildMode.Debug)
            val release = CompileOptions(build_mode: BuildMode.Release)

            expect BackendFactory.auto_select(target, debug.build_mode) == BackendKind.Wasm
            expect BackendFactory.auto_select(target, release.build_mode) == BackendKind.Wasm

    context "fallback strategy":
        it "falls back to Cranelift if LLVM unavailable":
            val target = CodegenTarget.X86_64
            val options = CompileOptions(build_mode: BuildMode.Release)

            # Simulate LLVM not available
            val backend = BackendFactory.create_with_fallback(target, options, llvm_available: false)

            expect backend.kind() == BackendKind.Cranelift

        it "errors on 32-bit if LLVM unavailable (no fallback)":
            val target = CodegenTarget.X86
            val options = CompileOptions(build_mode: BuildMode.Release)

            # 32-bit requires LLVM, no fallback available
            val result = BackendFactory.try_create_with_fallback(target, options, llvm_available: false)

            expect result.is_err()
            expect result.err().message.contains("32-bit compilation requires LLVM")

describe "Backend Factory Extension":
    # Tests for extending the factory with new backends.

    context "adding new backend":
        it "can register custom backend":
            # Hypothetical custom backend
            BackendFactory.register(BackendKind.Custom("MyBackend"), \target, options:
                MyCustomBackend.create(target, options)
            )

            val available = BackendFactory.available_backends()

            expect available.contains(BackendKind.Custom("MyBackend"))

        it "custom backend can specify supported targets":
            BackendFactory.register_with_support(
                kind: BackendKind.Custom("GPUBackend"),
                factory: \target, options: GPUBackend.create(target, options),
                supports: \target: target.is_64bit()  # Only 64-bit
            )

            expect BackendFactory.supports_target(
                BackendKind.Custom("GPUBackend"),
                CodegenTarget.X86_64
            ) == true
            expect BackendFactory.supports_target(
                BackendKind.Custom("GPUBackend"),
                CodegenTarget.X86
            ) == false

describe "Backend Factory Performance":
    # Performance characteristics of backend factory.

    slow_it "backend creation is fast":
        val target = CodegenTarget.X86_64
        val options = CompileOptions.default()

        val start = time_now()
        for _ in 0..1000:
            val _ = BackendFactory.create(target, options)
        val elapsed = time_elapsed(start)

        # Should be very fast (< 10ms for 1000 creations)
        expect elapsed < 10

    slow_it "auto-selection is fast":
        val target = CodegenTarget.X86_64

        val start = time_now()
        for _ in 0..10000:
            val _ = BackendFactory.auto_select(target, BuildMode.Release)
        val elapsed = time_elapsed(start)

        # Should be extremely fast (< 5ms for 10k selections)
        expect elapsed < 5
