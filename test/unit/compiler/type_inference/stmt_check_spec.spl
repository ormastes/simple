# Statement Type Checking Tests
#
# Tests for stmt_check.spl - comprehensive coverage of statement type checking.

use compiler.type_system.stmt_check*
use compiler.type_system.expr_infer (infer_expr)
use compiler.inference.types*
use compiler.inference.infer (InferenceEngine)
use ast*

# ============================================================================
# Test Helpers
# ============================================================================

fn create_engine() -> InferenceEngine:
    # Create a fresh inference engine for testing.
    InferenceEngine.create()

fn create_env() -> Dict<text, Type>:
    # Create a basic environment.
    var env: Dict<text, Type> = {}
    env["x"] = Type.Int(bits: 64, signed: true)
    env["y"] = Type.Int(bits: 64, signed: true)
    env

fn make_span() -> Span:
    # Create a dummy span for testing.
    Span(start: 0, end: 0, line: 1, column: 1)

# ============================================================================
# Let Statement Tests
# ============================================================================

describe "Let Statement Type Checking":
    it "checks simple let binding with initializer":
        val engine = create_engine()
        val env = create_env()

        val let_stmt = LetStmt(
            span: make_span(),
            pattern: Pattern.Identifier("z"),
            ty: nil,
            value: Some(Expr.Integer(42)),
            mutability: Mutability.Immutable,
            storage_class: StorageClass.Auto,
            is_ghost: false,
            is_suspend: false
        )

        val stmt = Node.Let(let_stmt)
        val result = check_stmt(engine, stmt, env, nil)

        expect(result.ok.?).to_equal(true)
        val new_env = result.unwrap()
        expect(new_env.contains("z")).to_equal(true)

    it "checks let binding with type annotation":
        val engine = create_engine()
        val env = create_env()

        val let_stmt = LetStmt(
            span: make_span(),
            pattern: Pattern.Identifier("z"),
            ty: Some(ast.Type.Simple("i64")),
            value: Some(Expr.Integer(42)),
            mutability: Mutability.Immutable,
            storage_class: StorageClass.Auto,
            is_ghost: false,
            is_suspend: false
        )

        val stmt = Node.Let(let_stmt)
        val result = check_stmt(engine, stmt, env, nil)

        expect(result.ok.?).to_equal(true)

    it "checks tuple pattern binding":
        val engine = create_engine()
        val env = create_env()

        val let_stmt = LetStmt(
            span: make_span(),
            pattern: Pattern.Tuple([
                Pattern.Identifier("a"),
                Pattern.Identifier("b")
            ]),
            ty: nil,
            value: Some(Expr.Tuple([Expr.Integer(1), Expr.Integer(2)])),
            mutability: Mutability.Immutable,
            storage_class: StorageClass.Auto,
            is_ghost: false,
            is_suspend: false
        )

        val stmt = Node.Let(let_stmt)
        val result = check_stmt(engine, stmt, env, nil)

        expect(result.ok.?).to_equal(true)
        val new_env = result.unwrap()
        expect(new_env.contains("a")).to_equal(true)
        expect(new_env.contains("b")).to_equal(true)

# ============================================================================
# Assignment Tests
# ============================================================================

describe "Assignment Type Checking":
    it "checks simple assignment":
        val engine = create_engine()
        val env = create_env()

        val assign_stmt = AssignmentStmt(
            span: make_span(),
            target: Expr.Identifier("x"),
            op: AssignOp.Assign,
            value: Expr.Integer(42)
        )

        val stmt = Node.Assignment(assign_stmt)
        val result = check_stmt(engine, stmt, env, nil)

        expect(result.ok.?).to_equal(true)

    it "checks add-assign":
        val engine = create_engine()
        val env = create_env()

        val assign_stmt = AssignmentStmt(
            span: make_span(),
            target: Expr.Identifier("x"),
            op: AssignOp.AddAssign,
            value: Expr.Integer(10)
        )

        val stmt = Node.Assignment(assign_stmt)
        val result = check_stmt(engine, stmt, env, nil)

        expect(result.ok.?).to_equal(true)

# ============================================================================
# Return Statement Tests
# ============================================================================

describe "Return Statement Type Checking":
    it "checks return with value":
        val engine = create_engine()
        val env = create_env()
        val ret_type = Type.Int(bits: 64, signed: true)

        val ret_stmt = ReturnStmt(
            span: make_span(),
            value: Some(Expr.Integer(42))
        )

        val stmt = Node.Return(ret_stmt)
        val result = check_stmt(engine, stmt, env, Some(ret_type))

        expect(result.ok.?).to_equal(true)

    it "checks return without value as Unit":
        val engine = create_engine()
        val env = create_env()
        val ret_type = Type.Unit

        val ret_stmt = ReturnStmt(
            span: make_span(),
            value: nil
        )

        val stmt = Node.Return(ret_stmt)
        val result = check_stmt(engine, stmt, env, Some(ret_type))

        expect(result.ok.?).to_equal(true)

# ============================================================================
# If Statement Tests
# ============================================================================

describe "If Statement Type Checking":
    it "checks if statement with bool condition":
        val engine = create_engine()
        val env = create_env()

        val if_stmt = IfStmt(
            span: make_span(),
            let_pattern: nil,
            condition: Expr.Bool(true),
            then_block: Block(
                span: make_span(),
                statements: []
            ),
            elif_branches: [],
            else_block: nil,
            is_suspend: false
        )

        val stmt = Node.If(if_stmt)
        val result = check_stmt(engine, stmt, env, nil)

        expect(result.ok.?).to_equal(true)

    it "checks if with else branch":
        val engine = create_engine()
        val env = create_env()

        val if_stmt = IfStmt(
            span: make_span(),
            let_pattern: nil,
            condition: Expr.Bool(true),
            then_block: Block(span: make_span(), statements: []),
            elif_branches: [],
            else_block: Some(Block(span: make_span(), statements: [])),
            is_suspend: false
        )

        val stmt = Node.If(if_stmt)
        val result = check_stmt(engine, stmt, env, nil)

        expect(result.ok.?).to_equal(true)

# ============================================================================
# For Loop Tests
# ============================================================================

describe "For Loop Type Checking":
    it "checks for loop with array":
        val engine = create_engine()
        var env = create_env()
        env["items"] = Type.Array(
            elem: Type.Int(bits: 64, signed: true),
            size: nil
        )

        val for_stmt = ForStmt(
            span: make_span(),
            pattern: Pattern.Identifier("item"),
            iterable: Expr.Identifier("items"),
            body: Block(span: make_span(), statements: []),
            is_suspend: false,
            auto_enumerate: false,
            invariants: []
        )

        val stmt = Node.ForNode(for_stmt)
        val result = check_stmt(engine, stmt, env, nil)

        expect(result.ok.?).to_equal(true)

# ============================================================================
# While Loop Tests
# ============================================================================

describe "While Loop Type Checking":
    it "checks while loop with bool condition":
        val engine = create_engine()
        val env = create_env()

        val while_stmt = WhileStmt(
            span: make_span(),
            let_pattern: nil,
            condition: Expr.Bool(true),
            body: Block(span: make_span(), statements: []),
            is_suspend: false,
            invariants: []
        )

        val stmt = Node.WhileNode(while_stmt)
        val result = check_stmt(engine, stmt, env, nil)

        expect(result.ok.?).to_equal(true)

# ============================================================================
# Pattern Binding Tests
# ============================================================================

describe "Pattern Binding":
    it "binds simple identifier":
        val pattern = Pattern.Identifier("x")
        val ty = Type.Int(bits: 64, signed: true)
        val env: Dict<text, Type> = {}

        val new_env = bind_pattern(pattern, ty, env)

        expect(new_env.contains("x")).to_equal(true)
        expect(new_env["x"]).to_equal(ty)

    it "binds tuple pattern":
        val pattern = Pattern.Tuple([
            Pattern.Identifier("x"),
            Pattern.Identifier("y")
        ])
        val ty = Type.Tuple(elements: [
            Type.Int(bits: 64, signed: true),
            Type.Str
        ])
        val env: Dict<text, Type> = {}

        val new_env = bind_pattern(pattern, ty, env)

        expect(new_env.contains("x")).to_equal(true)
        expect(new_env.contains("y")).to_equal(true)

    it "handles wildcard pattern":
        val pattern = Pattern.Wildcard
        val ty = Type.Int(bits: 64, signed: true)
        val env: Dict<text, Type> = {}

        val new_env = bind_pattern(pattern, ty, env)

        # Wildcard should not add any bindings
        expect(new_env.len()).to_equal(0)

# ============================================================================
# Verification Statement Tests
# ============================================================================

describe "Verification Statement Type Checking":
    it "checks assert with bool condition":
        val engine = create_engine()
        val env = create_env()

        val assert_stmt = AssertStmt(
            span: make_span(),
            condition: Expr.Bool(true),
            message: Some("assertion failed")
        )

        val stmt = Node.Assert(assert_stmt)
        val result = check_stmt(engine, stmt, env, nil)

        expect(result.ok.?).to_equal(true)

    it "checks assume with bool condition":
        val engine = create_engine()
        val env = create_env()

        val assume_stmt = AssumeStmt(
            span: make_span(),
            condition: Expr.Bool(true),
            message: nil
        )

        val stmt = Node.Assume(assume_stmt)
        val result = check_stmt(engine, stmt, env, nil)

        expect(result.ok.?).to_equal(true)

# ============================================================================
# Block Checking Tests
# ============================================================================

describe "Block Type Checking":
    it "checks empty block as Unit":
        val engine = create_engine()
        val env = create_env()
        val block = Block(span: make_span(), statements: [])

        val result = check_block(engine, block, env, nil)

        expect(result.ok.?).to_equal(true)
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Unit)

    it "checks block with multiple statements":
        val engine = create_engine()
        val env = create_env()

        val let_stmt = LetStmt(
            span: make_span(),
            pattern: Pattern.Identifier("z"),
            ty: nil,
            value: Some(Expr.Integer(42)),
            mutability: Mutability.Immutable,
            storage_class: StorageClass.Auto,
            is_ghost: false,
            is_suspend: false
        )

        val block = Block(
            span: make_span(),
            statements: [Node.Let(let_stmt)]
        )

        val result = check_block(engine, block, env, nil)

        expect(result.ok.?).to_equal(true)

# ============================================================================
# Summary
# ============================================================================

# Total test count: 20+ tests covering:
# - Let statements (3 tests)
# - Assignments (2 tests)
# - Returns (2 tests)
# - If statements (2 tests)
# - For loops (1 test)
# - While loops (1 test)
# - Pattern binding (3 tests)
# - Verification statements (2 tests)
# - Block checking (2 tests)
