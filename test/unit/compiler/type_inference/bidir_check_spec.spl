# Bidirectional Type Checking Helpers Tests
#
# Tests for check_expr and synthesize_expr helpers.

fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")

# ============================================================================
# Synthesize Mode Tests
# ============================================================================

describe "synthesize_expr":
    it "synthesizes integer literal type":
        # synthesize(42) => i64
        pass

    it "synthesizes boolean literal type":
        # synthesize(true) => bool
        pass

    it "synthesizes string literal type":
        # synthesize("hello") => text
        pass

    it "synthesizes array literal type":
        # synthesize([1, 2, 3]) => [i64]
        pass

    it "synthesizes lambda with inferred params":
        # synthesize(\x: x + 1) => fn(Infer) -> Infer
        # Without expected type, params are fresh type vars
        pass

# ============================================================================
# Check Mode Tests
# ============================================================================

describe "check_expr":
    it "checks literal against matching type":
        # check(42, i64) => Ok
        pass

    it "rejects literal against mismatched type":
        # check(42, text) => Err(Mismatch)
        pass

    it "propagates function type into lambda params":
        # check(\x: x + 1, fn(i64) -> i64) => Ok
        # x is inferred as i64 from expected type
        pass

    it "checks lambda body against expected return type":
        # check(\x: x, fn(i64) -> i64) => Ok
        # check(\x: "hello", fn(i64) -> i64) => Err
        pass

    it "rejects lambda with wrong arity":
        # check(\x, y: x + y, fn(i64) -> i64) => Err
        # Expected 1 param, got 2
        pass

    it "handles nested lambdas with expected type":
        # check(\f: \x: f(x), fn(fn(i64) -> i64) -> fn(i64) -> i64) => Ok
        pass

# ============================================================================
# Bidirectional Dispatch Tests
# ============================================================================

describe "infer_expr_bidir":
    it "dispatches to synthesize in Synthesize mode":
        # infer_expr_bidir(42, Synthesize) => Ok(i64)
        pass

    it "dispatches to check in Check mode":
        # infer_expr_bidir(42, Check(i64)) => Ok(i64)
        pass

    it "returns expected type after successful check":
        # infer_expr_bidir(\x: x, Check(fn(i64) -> i64)) => Ok(fn(i64) -> i64)
        pass

    it "propagates error from failed check":
        # infer_expr_bidir(42, Check(text)) => Err
        pass

# ============================================================================
# Subsumption Tests
# ============================================================================

describe "check_subsumes":
    it "accepts identical types":
        # check_subsumes(i64, i64) => Ok
        pass

    it "accepts type variables that unify":
        # check_subsumes(T, i64) => Ok (T unified to i64)
        pass

    it "rejects incompatible types":
        # check_subsumes(i64, text) => Err
        pass

# ============================================================================
# Lambda Inference Integration Tests
# ============================================================================

describe "lambda inference with bidirectional":
    it "infers lambda param from function argument position":
        # fn apply(f: fn(i64) -> i64, x: i64): f(x)
        # apply(\y: y * 2, 5) => y inferred as i64
        pass

    it "infers lambda param from assignment context":
        # val double: fn(i64) -> i64 = \x: x * 2
        # x inferred as i64
        pass

    it "infers lambda param from return position":
        # fn make_adder() -> fn(i64) -> i64:
        #     \x: x + 1
        # x inferred as i64
        pass

    it "chains bidirectional inference through multiple lambdas":
        # val compose: fn(fn(i64) -> i64, fn(i64) -> i64) -> fn(i64) -> i64
        # compose(\x: x + 1, \y: y * 2)
        # Both x and y inferred as i64
        pass

# ============================================================================
# Error Message Tests
# ============================================================================

describe "bidirectional error messages":
    it "reports expected vs found in check mode":
        # check(42, text) => "expected text, found i64"
        pass

    it "reports arity mismatch for lambdas":
        # check(\x, y: x, fn(i64) -> i64) => "arity mismatch"
        pass

# ============================================================================
# Exports
# ============================================================================

export describe
