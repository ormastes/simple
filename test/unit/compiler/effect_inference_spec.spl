# Effect Inference System Tests
#
# Tests the effect inference and checking system that tracks side effects
# through expressions and ensures effect safety.

use std.spec.{check, check_msg}
use compiler.type_infer.*
use compiler.hir.*
use compiler.hir_types.SymbolId
use core.lexer.*

describe "Effect Inference":
    it "infers pure expressions have no effects":
        """Pure expressions like literals and arithmetic should have no effects."""
        val ctx = HmInferContext.with_builtins()

        # Integer literal - pure
        val int_expr = HirExpr(
            kind: HirExprKind.IntLit(42, nil),
            type_: nil,
            span: Span.dummy()
        )
        val effects = ctx.infer_expr_effects(int_expr)
        check(effects.is_empty())

        # Binary operation - pure
        val left = HirExpr(kind: HirExprKind.IntLit(1, nil), type_: nil, span: Span.dummy())
        val right = HirExpr(kind: HirExprKind.IntLit(2, nil), type_: nil, span: Span.dummy())
        val binary = HirExpr(
            kind: HirExprKind.Binary(HirBinOp.Add, left, right),
            type_: nil,
            span: Span.dummy()
        )
        val bin_effects = ctx.infer_expr_effects(binary)
        check(bin_effects.is_empty())

    it "infers method calls have IO effects":
        """Method calls conservatively assume IO effects."""
        val ctx = HmInferContext.with_builtins()

        val receiver = HirExpr(kind: HirExprKind.IntLit(42, nil), type_: nil, span: Span.dummy())
        val method_call = HirExpr(
            kind: HirExprKind.MethodCall(
                receiver,
                "to_string",
                [],
                MethodResolution.Unresolved
            ),
            type_: nil,
            span: Span.dummy()
        )

        val effects = ctx.infer_expr_effects(method_call)
        check(effects.len() > 0)
        check(effects[0].kind == EffectKind.IO)

    it "infers assignment has Mutates effect":
        """Assignments should be tracked as mutation effects."""
        val ctx = HmInferContext.with_builtins()

        val target = HirExpr(kind: HirExprKind.Var(SymbolId(id: 1)), type_: nil, span: Span.dummy())
        val value = HirExpr(kind: HirExprKind.IntLit(42, nil), type_: nil, span: Span.dummy())
        val assign = HirStmt(
            kind: HirStmtKind.Assign(target, AssignOp.Assign, value),
            span: Span.dummy()
        )

        val effects = ctx.infer_stmt_effects(assign)
        check(effects.len() > 0)

        var found_mutates = false
        for effect in effects:
            if effect.kind == EffectKind.Mutates:
                found_mutates = true
        check(found_mutates)

    it "merges effects from multiple expressions":
        """Effect merging combines effects from subexpressions."""
        val ctx = HmInferContext.with_builtins()

        val effect1 = Effect(kind: EffectKind.IO, span: Span.dummy())
        val effect2 = Effect(kind: EffectKind.Mutates, span: Span.dummy())
        val effect3 = Effect(kind: EffectKind.IO, span: Span.dummy())  # Duplicate

        val effects1 = [effect1]
        val effects2 = [effect2, effect3]

        val merged = ctx.merge_effects(effects1, effects2)

        # Should have 2 unique effects (IO and Mutates), not 3
        check(merged.len() == 2)

    it "checks effect compatibility":
        """Effect compatibility checking validates effect requirements."""
        val ctx = HmInferContext.with_builtins()

        val io_effect = Effect(kind: EffectKind.IO, span: Span.dummy())
        val mutates_effect = Effect(kind: EffectKind.Mutates, span: Span.dummy())

        # Required: IO
        # Provided: IO, Mutates
        # Result: OK (IO is provided)
        val required = [io_effect]
        val provided = [io_effect, mutates_effect]

        val result = ctx.check_effect_compatibility(required, provided, Span.dummy())
        check(result.ok.?)

    it "detects missing required effects":
        """Effect checking should fail when required effects are not provided."""
        val ctx = HmInferContext.with_builtins()

        val io_effect = Effect(kind: EffectKind.IO, span: Span.dummy())
        val mutates_effect = Effect(kind: EffectKind.Mutates, span: Span.dummy())

        # Required: IO
        # Provided: Mutates (missing IO)
        # Result: Error
        val required = [io_effect]
        val provided = [mutates_effect]

        val result = ctx.check_effect_compatibility(required, provided, Span.dummy())
        check(result.err.?)

    it "extracts effects from function types":
        """Function types carry their effects which can be extracted."""
        val ctx = HmInferContext.with_builtins()

        val io_effect = Effect(kind: EffectKind.IO, span: Span.dummy())
        val async_effect = Effect(kind: EffectKind.Async, span: Span.dummy())

        val fn_ty = HirType(
            kind: HirTypeKind.Function(
                [],
                HirType(kind: HirTypeKind.Unit, span: Span.dummy()),
                [io_effect, async_effect]
            ),
            span: Span.dummy()
        )

        val effects = ctx.get_function_effects(fn_ty)
        check(effects.len() == 2)

describe "Effect Kinds":
    it "matches same effect kinds":
        """Effect matching should recognize identical effects."""
        val ctx = HmInferContext.with_builtins()

        check(ctx.effects_match(
            Effect(kind: EffectKind.IO, span: Span.dummy()),
            Effect(kind: EffectKind.IO, span: Span.dummy())
        ))

        check(ctx.effects_match(
            Effect(kind: EffectKind.Pure, span: Span.dummy()),
            Effect(kind: EffectKind.Pure, span: Span.dummy())
        ))

    it "does not match different effect kinds":
        """Effect matching should distinguish different effects."""
        val ctx = HmInferContext.with_builtins()

        val io = Effect(kind: EffectKind.IO, span: Span.dummy())
        val mutates = Effect(kind: EffectKind.Mutates, span: Span.dummy())

        check(not ctx.effects_match(io, mutates))

    it "matches custom effects by name":
        """Custom effects should match by name."""
        val ctx = HmInferContext.with_builtins()

        val custom1 = Effect(kind: EffectKind.Custom("database"), span: Span.dummy())
        val custom2 = Effect(kind: EffectKind.Custom("database"), span: Span.dummy())
        val custom3 = Effect(kind: EffectKind.Custom("network"), span: Span.dummy())

        check(ctx.effects_match(custom1, custom2))
        check(not ctx.effects_match(custom1, custom3))
