#!/usr/bin/env simple
# MIR Serialization Tests
#
# Tests JSON serialization of MIR structures for JIT compilation.

use lib.testing.sspec.{describe, it, expect}
use std.string.{NL}
use compiler.mir.*
use compiler.mir_data.LocalId
use compiler.hir.SymbolId
use core.lexer.Span

describe "MIR Serialization":
    describe "Type Serialization":
        it "serializes primitive types":
            val i64_json = serialize_mir_type(MirType.i64())
            expect i64_json == "\"I64\""

            val f64_json = serialize_mir_type(MirType.f64())
            expect f64_json == "\"F64\""

            val bool_json = serialize_mir_type(MirType.bool())
            expect bool_json == "\"Bool\""

        it "serializes pointer types":
            val ptr = MirType.ptr(MirType.i64(), true)
            val json = serialize_mir_type(ptr)
            expect json.contains("\"Ptr\"")
            expect json.contains("\"mutable\":true")

        it "serializes array types":
            val arr_type = MirType(kind: MirTypeKind.Array(MirType.i64(), 10))
            val json = serialize_mir_type(arr_type)
            expect json.contains("\"Array\"")
            expect json.contains("\"size\":10")

    describe "Constant Value Serialization":
        it "serializes integer constants":
            val const_val = MirConstValue.Int(42)
            val json = serialize_const_value(const_val)
            expect json == "42"

        it "serializes float constants":
            val const_val = MirConstValue.Float(3.14)
            val json = serialize_const_value(const_val)
            expect json == "3.14"

        it "serializes bool constants":
            val const_true = MirConstValue.Bool(true)
            expect serialize_const_value(const_true) == "true"

            val const_false = MirConstValue.Bool(false)
            expect serialize_const_value(const_false) == "false"

        it "serializes string constants":
            val const_str = MirConstValue.Str("hello")
            val json = serialize_const_value(const_str)
            expect json == "\"hello\""

        it "escapes special characters in strings":
            val const_str = MirConstValue.Str("line1{NL}line2")
            val json = serialize_const_value(const_str)
            expect json == "\"line1\{NL}line2\""

    describe "Operand Serialization":
        it "serializes copy operands":
            val local_id = LocalId(id: 5)
            val operand = mir_operand_copy(local_id)
            val json = serialize_operand(operand)
            expect json == "{\"Copy\":5}"

        it "serializes move operands":
            val local_id = LocalId(id: 7)
            val operand = mir_operand_move(local_id)
            val json = serialize_operand(operand)
            expect json == "{\"Move\":7}"

        it "serializes const operands":
            val operand = mir_operand_const_int(42)
            val json = serialize_operand(operand)
            expect json.contains("\"Const\"")
            expect json.contains("\"value\":42")

    describe "Binary Operation Serialization":
        it "serializes arithmetic operations":
            expect serialize_binop(MirBinOp.Add) == "Add"
            expect serialize_binop(MirBinOp.Sub) == "Sub"
            expect serialize_binop(MirBinOp.Mul) == "Mul"
            expect serialize_binop(MirBinOp.Div) == "Div"

        it "serializes comparison operations":
            expect serialize_binop(MirBinOp.Eq) == "Eq"
            expect serialize_binop(MirBinOp.Ne) == "Ne"
            expect serialize_binop(MirBinOp.Lt) == "Lt"
            expect serialize_binop(MirBinOp.Le) == "Le"

        it "serializes broadcast operations":
            expect serialize_binop(MirBinOp.BroadcastAdd) == "BroadcastAdd"
            expect serialize_binop(MirBinOp.BroadcastMul) == "BroadcastMul"

    describe "Instruction Serialization":
        it "serializes Const instruction":
            val dest = LocalId(id: 1)
            val value = MirConstValue.Int(100)
            val inst_kind = MirInstKind.Const(dest, value, MirType.i64())
            val json = serialize_mir_inst_kind(inst_kind)

            expect json.contains("\"Const\"")
            expect json.contains("\"dest\":1")
            expect json.contains("\"value\":100")

        it "serializes Copy instruction":
            val dest = LocalId(id: 2)
            val src = LocalId(id: 3)
            val inst_kind = MirInstKind.Copy(dest, src)
            val json = serialize_mir_inst_kind(inst_kind)

            expect json == "{\"Copy\":{\"dest\":2,\"src\":3}}"

        it "serializes BinOp instruction":
            val dest = LocalId(id: 4)
            val left = mir_operand_copy(LocalId(id: 1))
            val right = mir_operand_copy(LocalId(id: 2))
            val inst_kind = MirInstKind.BinOp(dest, MirBinOp.Add, left, right)
            val json = serialize_mir_inst_kind(inst_kind)

            expect json.contains("\"BinOp\"")
            expect json.contains("\"dest\":4")
            expect json.contains("\"op\":\"Add\"")

    describe "Terminator Serialization":
        it "serializes Goto terminator":
            val target = BlockId(id: 3)
            val term = MirTerminator.Goto(target)
            val json = serialize_mir_terminator(term)
            expect json == "{\"Goto\":3}"

        it "serializes Return terminator with value":
            val value = mir_operand_const_int(42)
            val term = MirTerminator.Return(Some(value))
            val json = serialize_mir_terminator(term)
            expect json.contains("\"Return\"")

        it "serializes Return terminator without value":
            val term = MirTerminator.Return(nil)
            val json = serialize_mir_terminator(term)
            expect json == "{\"Return\":null}"

        it "serializes If terminator":
            val cond = mir_operand_copy(LocalId(id: 1))
            val then_block = BlockId(id: 2)
            val else_block = BlockId(id: 3)
            val term = MirTerminator.If(cond, then_block, else_block)
            val json = serialize_mir_terminator(term)

            expect json.contains("\"If\"")
            expect json.contains("\"then\":2")
            expect json.contains("\"else\":3")

    describe "Function Serialization":
        it "serializes simple function":
            val signature = MirSignature(
                params: [MirType.i64()],
                return_type: MirType.i64(),
                is_variadic: false
            )

            val local = MirLocal(
                id: LocalId(id: 0),
                name: Some("x"),
                type_: MirType.i64(),
                kind: LocalKind.Arg(0)
            )

            val entry_block = MirBlock(
                id: BlockId.entry(),
                label: Some("entry"),
                instructions: [],
                terminator: MirTerminator.Return(Some(mir_operand_copy(LocalId(id: 0))))
            )

            val func = MirFunction(
                symbol: SymbolId(id: 1),
                name: "identity",
                signature: signature,
                locals: [local],
                blocks: [entry_block],
                entry_block: BlockId.entry(),
                span: Span(start: 0, end: 0, line: 1, col: 1),
                generic_params: [],
                is_generic_template: false,
                specialization_of: nil,
                type_bindings: {}
            )

            val json = serialize_mir_function(func)

            # Verify key components are present
            expect json.contains("\"name\":\"identity\"")
            expect json.contains("\"symbol\":1")
            expect json.contains("\"locals\"")
            expect json.contains("\"blocks\"")
            expect json.contains("\"entry_block\":0")

    describe "JSON String Escaping":
        it "escapes double quotes":
            val result = escape_json_string("say \"hello\"")
            expect result == "say \\\"hello\\\""

        it "escapes backslashes":
            val result = escape_json_string("path\\to\\file")
            expect result == "path\\\\to\\\\file"

        it "escapes newlines":
            val result = escape_json_string("line1{NL}line2")
            expect result == "line1\{NL}line2"

        it "escapes tabs":
            val result = escape_json_string("col1\tcol2")
            expect result == "col1\\tcol2"

    describe "Roundtrip Properties":
        it "produces valid JSON structure":
            # Create a simple MIR function
            val signature = MirSignature(
                params: [],
                return_type: MirType.unit(),
                is_variadic: false
            )

            val block = MirBlock(
                id: BlockId.entry(),
                label: nil,
                instructions: [],
                terminator: MirTerminator.Return(nil)
            )

            val func = MirFunction(
                symbol: SymbolId(id: 0),
                name: "main",
                signature: signature,
                locals: [],
                blocks: [block],
                entry_block: BlockId.entry(),
                span: Span(start: 0, end: 0, line: 1, col: 1),
                generic_params: [],
                is_generic_template: false,
                specialization_of: nil,
                type_bindings: {}
            )

            val json = serialize_mir_function(func)

            # JSON should be well-formed (basic validation)
            expect json.starts_with("{")
            expect json.ends_with("}")
            expect json.contains("\"name\":\"main\"")
