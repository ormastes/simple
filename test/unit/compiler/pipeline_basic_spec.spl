"""
# Pipeline Basic Specification

**Feature IDs:** #TBD
**Category:** Compiler
**Status:** In Progress

## Overview

Tests the full Parse → HIR → MIR → Native pipeline produces a valid
ELF byte sequence. Requires native backend.
"""

use std.spec
use compiler.core.parser.*
use compiler.parser_types.*
use compiler.core.lexer.*
use compiler.blocks.*
use compiler.treesitter.*
use compiler.hir_lowering.*
use compiler.mir_lowering.*
use compiler.mir_data.*
use compiler.backend.native.mod.{compile_native}
use compiler.core.backend_types.{CodegenTarget}


describe "Pipeline Basic":
    it "compiles simple function to non-empty ELF bytes":
        skip_on_interpreter "requires native backend":
            val source = "fn main() -> i64:\n    0\n"
            var parser = Parser.new(source)
            val ast_module = parser.parse()
            var hir_lowering = HirLowering.new()
            val hir_module = hir_lowering.lower_module(ast_module)
            var mir_ctx = MirLowering.new(hir_lowering.symbols)
            val mir_module = mir_ctx.lower_module(hir_module)
            val elf_bytes = compile_native(mir_module, CodegenTarget.X86_64)
            expect(elf_bytes.len() > 0).to_equal(true)

    it "lowers function without return type to MIR":
        val source = "fn main():\n    0\n"
        var parser = Parser.new(source)
        val ast_module = parser.parse()
        var hir_lowering = HirLowering.new()
        val hir_module = hir_lowering.lower_module(ast_module)
        var mir_ctx = MirLowering.new(hir_lowering.symbols)
        val mir_module = mir_ctx.lower_module(hir_module)
        expect(mir_module.functions.keys().len() > 0).to_equal(true)
