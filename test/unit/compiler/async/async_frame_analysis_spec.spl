#!/usr/bin/env simple
# Async Frame Analysis Tests
#
# Tests the compile-time frame sizing analysis for async state machines.
# Covers: frame size computation, variant layouts, conflict analysis,
# overlap optimization, large capture detection, and limit verification.
#
# NOTE: SuspensionPoint requires Expr/ExprKind enum data constructors which
# fail in interpreter mode. Since all type tags resolve to 8B anyway,
# we use empty SuspensionAnalysis and test frame sizing directly.

use compiler.desugar.suspension_analysis.{
    SuspensionAnalysis,
    TYPETAG_BOOL,
    TYPETAG_I64,
    TYPETAG_F64,
    TYPETAG_TEXT,
    TYPETAG_UNKNOWN
}
use compiler.desugar.state_enum.{
    StateEnum,
    StateVariant
}
use compiler.desugar.frame_analysis.{
    FrameAnalysis,
    VariantLayout,
    VariableSizeInfo,
    ConflictEntry,
    analyze_frame,
    analyze_frame_with_large_capture_check,
    format_frame_analysis,
    type_tag_to_size,
    align_up,
    FRAME_HEADER_SIZE,
    DISCRIMINANT_SIZE,
    DEFAULT_TYPE_SIZE,
    FUTURE_SIZE,
    ALIGNMENT
}
use compiler.desugar.frame_verify.{
    FrameLimits,
    FrameDiagnostic,
    FrameVerifyResult,
    default_baremetal_limits,
    default_relaxed_limits,
    unlimited_limits,
    verify_frame,
    verify_task_frame,
    verify_frames_batch,
    format_verify_result
}
use compiler.parser_types.*
use lexer.Span

# ================================================================
# Test Helpers
# ================================================================

fn dummy_span() -> Span:
    Span.new(0, 0, 1, 1)

fn make_field(name: text) -> Field:
    Field(
        name: name,
        type_: nil,
        default: nil,
        is_public: false,
        is_volatile: false,
        fixed_address: nil,
        span: dummy_span()
    )

fn make_state_enum_no_awaits() -> StateEnum:
    StateEnum(
        name: "SimpleState",
        variants: [
            StateVariant(
                name: "State0",
                fields: [],
                suspension_point_id: nil,
                doc_comment: "Initial"
            )
        ],
        doc_comment: "No awaits"
    )

fn make_state_enum_one_await() -> StateEnum:
    StateEnum(
        name: "FetchState",
        variants: [
            StateVariant(
                name: "State0",
                fields: [],
                suspension_point_id: nil,
                doc_comment: "Initial"
            ),
            StateVariant(
                name: "State1",
                fields: [make_field("a"), make_field("future")],
                suspension_point_id: 0,
                doc_comment: "After await #0"
            )
        ],
        doc_comment: "One await"
    )

fn make_state_enum_two_awaits() -> StateEnum:
    StateEnum(
        name: "ProcessState",
        variants: [
            StateVariant(
                name: "State0",
                fields: [],
                suspension_point_id: nil,
                doc_comment: "Initial"
            ),
            StateVariant(
                name: "State1",
                fields: [make_field("a"), make_field("future")],
                suspension_point_id: 0,
                doc_comment: "After await #0"
            ),
            StateVariant(
                name: "State2",
                fields: [make_field("a"), make_field("b"), make_field("future")],
                suspension_point_id: 1,
                doc_comment: "After await #1"
            )
        ],
        doc_comment: "Two awaits"
    )

fn make_state_enum_disjoint_vars() -> StateEnum:
    # State1 has {x, future}, State2 has {y, future}
    # x and y are NOT simultaneously live => can share memory
    StateEnum(
        name: "DisjointState",
        variants: [
            StateVariant(
                name: "State0",
                fields: [],
                suspension_point_id: nil,
                doc_comment: "Initial"
            ),
            StateVariant(
                name: "State1",
                fields: [make_field("x"), make_field("future")],
                suspension_point_id: 0,
                doc_comment: "After await #0"
            ),
            StateVariant(
                name: "State2",
                fields: [make_field("y"), make_field("future")],
                suspension_point_id: 1,
                doc_comment: "After await #1"
            )
        ],
        doc_comment: "Disjoint variables"
    )

# Empty analysis (all types default to 8B which is correct for 64-bit target)
fn make_empty_analysis() -> SuspensionAnalysis:
    SuspensionAnalysis(
        suspension_points: [],
        total_states: 0
    )

# ================================================================
# Tests: Constants
# ================================================================

describe "Frame Analysis Constants":
    it "has correct header size":
        expect(FRAME_HEADER_SIZE).to_equal(24)

    it "has correct discriminant size":
        expect(DISCRIMINANT_SIZE).to_equal(8)

    it "has correct default type size":
        expect(DEFAULT_TYPE_SIZE).to_equal(8)

    it "has correct future size":
        expect(FUTURE_SIZE).to_equal(8)

    it "has correct alignment":
        expect(ALIGNMENT).to_equal(8)

# ================================================================
# Tests: Type Size Resolution
# ================================================================

describe "Type Tag to Size":
    it "resolves i64 to 8 bytes":
        expect(type_tag_to_size(TYPETAG_I64)).to_equal(8)

    it "resolves f64 to 8 bytes":
        expect(type_tag_to_size(TYPETAG_F64)).to_equal(8)

    it "resolves text to 8 bytes":
        expect(type_tag_to_size(TYPETAG_TEXT)).to_equal(8)

    it "resolves bool to 8 bytes (aligned)":
        expect(type_tag_to_size(TYPETAG_BOOL)).to_equal(8)

    it "resolves unknown to 8 bytes":
        expect(type_tag_to_size(TYPETAG_UNKNOWN)).to_equal(8)

# ================================================================
# Tests: Alignment
# ================================================================

describe "Alignment Helper":
    it "aligns 0 to 0":
        expect(align_up(0, 8)).to_equal(0)

    it "aligns 1 to 8":
        expect(align_up(1, 8)).to_equal(8)

    it "aligns 8 to 8":
        expect(align_up(8, 8)).to_equal(8)

    it "aligns 9 to 16":
        expect(align_up(9, 8)).to_equal(16)

    it "aligns 16 to 16":
        expect(align_up(16, 8)).to_equal(16)

    it "aligns 17 to 24":
        expect(align_up(17, 8)).to_equal(24)

# ================================================================
# Tests: Frame Analysis - No Awaits
# ================================================================

describe "Frame Analysis - No Awaits":
    it "computes zero payload for no-await function":
        val state_enum = make_state_enum_no_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("simple", state_enum, analysis)

        expect(fa.max_variant_payload).to_equal(0)

    it "includes header and discriminant even with no payload":
        val state_enum = make_state_enum_no_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("simple", state_enum, analysis)

        expect(fa.frame_header_size).to_equal(FRAME_HEADER_SIZE)
        expect(fa.discriminant_size).to_equal(DISCRIMINANT_SIZE)
        expect(fa.total_frame_size).to_equal(FRAME_HEADER_SIZE + DISCRIMINANT_SIZE)

    it "has no saved variables":
        val state_enum = make_state_enum_no_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("simple", state_enum, analysis)

        expect(fa.all_saved_variables.len()).to_equal(0)

    it "has one variant layout":
        val state_enum = make_state_enum_no_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("simple", state_enum, analysis)

        expect(fa.variant_layouts.len()).to_equal(1)
        expect(fa.variant_layouts[0].variant_name).to_equal("State0")

# ================================================================
# Tests: Frame Analysis - Single Await
# ================================================================

describe "Frame Analysis - Single Await":
    it "computes payload for one variable + future":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("fetch", state_enum, analysis)

        # State1 has: a(8B) + future(8B) = 16B
        expect(fa.max_variant_payload).to_equal(16)

    it "includes header in total frame size":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("fetch", state_enum, analysis)

        # 24 (header) + 8 (discriminant) + 16 (payload) = 48
        expect(fa.total_frame_size).to_equal(48)

    it "has two variant layouts":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("fetch", state_enum, analysis)

        expect(fa.variant_layouts.len()).to_equal(2)
        expect(fa.variant_layouts[0].payload_size).to_equal(0)
        expect(fa.variant_layouts[1].payload_size).to_equal(16)

    it "tracks saved variables (excluding future)":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("fetch", state_enum, analysis)

        expect(fa.all_saved_variables.len()).to_equal(1)
        expect(fa.all_saved_variables[0].name).to_equal("a")

    it "reports function name":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("fetch", state_enum, analysis)

        expect(fa.function_name).to_equal("fetch")

# ================================================================
# Tests: Frame Analysis - Two Awaits
# ================================================================

describe "Frame Analysis - Two Awaits":
    it "uses max variant payload":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("process", state_enum, analysis)

        # State1: a(8) + future(8) = 16
        # State2: a(8) + b(8) + future(8) = 24
        # Max = 24
        expect(fa.max_variant_payload).to_equal(24)

    it "total frame includes max payload":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("process", state_enum, analysis)

        # 24 (header) + 8 (discriminant) + 24 (max payload) = 56
        expect(fa.total_frame_size).to_equal(56)

    it "collects all unique saved variables":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("process", state_enum, analysis)

        # Variables: a (in both), b (in State2)
        expect(fa.all_saved_variables.len()).to_equal(2)

    it "has three variant layouts":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("process", state_enum, analysis)

        expect(fa.variant_layouts.len()).to_equal(3)

# ================================================================
# Tests: Storage Conflict Analysis
# ================================================================

describe "Frame Analysis - Conflict Detection":
    it "detects conflict for variables in same variant":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("process", state_enum, analysis)

        # a and b are both in State2 => conflict
        var found_conflict = false
        for c in fa.conflict_pairs:
            val match_ab = c.var_a == "a" and c.var_b == "b"
            val match_ba = c.var_a == "b" and c.var_b == "a"
            if match_ab or match_ba:
                found_conflict = true
        expect(found_conflict).to_equal(true)

    it "detects non-conflict for disjoint variables":
        val state_enum = make_state_enum_disjoint_vars()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("disjoint", state_enum, analysis)

        # x is only in State1, y is only in State2 => non-conflict
        var found_non_conflict = false
        for nc in fa.non_conflict_pairs:
            val match_xy = nc.var_a == "x" and nc.var_b == "y"
            val match_yx = nc.var_a == "y" and nc.var_b == "x"
            if match_xy or match_yx:
                found_non_conflict = true
        expect(found_non_conflict).to_equal(true)

    it "computes overlap savings for disjoint variables":
        val state_enum = make_state_enum_disjoint_vars()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("disjoint", state_enum, analysis)

        # x(8B) and y(8B) don't conflict => save 8B
        expect(fa.overlap_savings).to_equal(8)

    it "optimized frame is smaller with overlap":
        val state_enum = make_state_enum_disjoint_vars()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("disjoint", state_enum, analysis)

        expect(fa.optimized_frame_size).to_be_less_than(fa.total_frame_size)
        expect(fa.optimized_frame_size).to_equal(fa.total_frame_size - fa.overlap_savings)

    it "has zero overlap for conflicting variables":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("process", state_enum, analysis)

        # a and b conflict => no savings between them
        # a appears in both State1 and State2, so it conflicts with b
        expect(fa.overlap_savings).to_equal(0)

# ================================================================
# Tests: Large Capture Detection
# ================================================================

describe "Frame Analysis - Large Capture Detection":
    it "detects no large captures with high threshold":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        val fa = analyze_frame_with_large_capture_check("fetch", state_enum, analysis, 64)

        expect(fa.large_captures.len()).to_equal(0)

    it "detects large captures with low threshold":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        # Threshold of 4 bytes, but all vars are 8 bytes
        val fa = analyze_frame_with_large_capture_check("fetch", state_enum, analysis, 4)

        expect(fa.large_captures.len()).to_be_greater_than(0)

    it "reports variable name in large capture":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        val fa = analyze_frame_with_large_capture_check("fetch", state_enum, analysis, 4)

        if fa.large_captures.len() > 0:
            expect(fa.large_captures[0].name).to_equal("a")
            expect(fa.large_captures[0].size_bytes).to_equal(8)

# ================================================================
# Tests: Frame Verification - Strict Mode
# ================================================================

describe "Frame Verification - Strict Mode":
    it "passes when frame fits within limit":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("fetch", state_enum, analysis)

        val limits = FrameLimits(frame_max: 256, large_capture_max: 64, strict: true)
        val result = verify_frame(fa, limits)

        expect(result.has_errors).to_equal(false)
        expect(result.passed_functions).to_equal(1)

    it "errors when frame exceeds limit":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("process", state_enum, analysis)

        # Set very small limit that the frame will exceed
        val limits = FrameLimits(frame_max: 16, large_capture_max: 0, strict: true)
        val result = verify_frame(fa, limits)

        expect(result.has_errors).to_equal(true)
        expect(result.diagnostics.len()).to_be_greater_than(0)
        expect(result.diagnostics[0].level).to_equal("error")

    it "produces warning for large captures":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("fetch", state_enum, analysis)

        val limits = FrameLimits(frame_max: 256, large_capture_max: 4, strict: true)
        val result = verify_frame(fa, limits)

        # Large capture is always a warning, not error
        expect(result.has_warnings).to_equal(true)

# ================================================================
# Tests: Frame Verification - Relaxed Mode
# ================================================================

describe "Frame Verification - Relaxed Mode":
    it "warns instead of errors when frame exceeds limit":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("process", state_enum, analysis)

        val limits = FrameLimits(frame_max: 16, large_capture_max: 0, strict: false)
        val result = verify_frame(fa, limits)

        expect(result.has_errors).to_equal(false)
        expect(result.has_warnings).to_equal(true)
        expect(result.diagnostics[0].level).to_equal("warning")

# ================================================================
# Tests: Frame Verification - Unlimited
# ================================================================

describe "Frame Verification - Unlimited":
    it "always passes with unlimited limits":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("process", state_enum, analysis)

        val limits = unlimited_limits()
        val result = verify_frame(fa, limits)

        expect(result.has_errors).to_equal(false)
        expect(result.has_warnings).to_equal(false)
        expect(result.diagnostics.len()).to_equal(0)

# ================================================================
# Tests: @task Frame Attribute Verification
# ================================================================

describe "Frame Verification - Task Attribute":
    it "passes when frame fits declared @task frame":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("uart_rx", state_enum, analysis)

        val limits = default_baremetal_limits()
        val result = verify_task_frame(fa, 224, limits)

        expect(result.has_errors).to_equal(false)

    it "errors when frame exceeds declared @task frame":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("big_task", state_enum, analysis)

        # Declare small frame that won't fit
        val limits = default_baremetal_limits()
        val result = verify_task_frame(fa, 32, limits)

        expect(result.has_errors).to_equal(true)

    it "errors when declared frame exceeds profile max":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("oversized", state_enum, analysis)

        val limits = FrameLimits(frame_max: 128, large_capture_max: 64, strict: true)
        val result = verify_task_frame(fa, 256, limits)

        expect(result.has_errors).to_equal(true)

# ================================================================
# Tests: Batch Verification
# ================================================================

describe "Frame Verification - Batch":
    it "verifies multiple functions":
        val enum1 = make_state_enum_one_await()
        val enum2 = make_state_enum_two_awaits()
        val analysis1 = make_empty_analysis()
        val analysis2 = make_empty_analysis()
        val fa1 = analyze_frame("func1", enum1, analysis1)
        val fa2 = analyze_frame("func2", enum2, analysis2)

        val limits = default_baremetal_limits()
        val result = verify_frames_batch([fa1, fa2], limits)

        expect(result.total_functions).to_equal(2)
        expect(result.has_errors).to_equal(false)

    it "catches errors across batch":
        val enum1 = make_state_enum_one_await()
        val enum2 = make_state_enum_two_awaits()
        val analysis1 = make_empty_analysis()
        val analysis2 = make_empty_analysis()
        val fa1 = analyze_frame("ok_func", enum1, analysis1)
        val fa2 = analyze_frame("bad_func", enum2, analysis2)

        # Very tight limit
        val limits = FrameLimits(frame_max: 48, large_capture_max: 0, strict: true)
        val result = verify_frames_batch([fa1, fa2], limits)

        # fa1 is 48B (passes), fa2 is 56B (fails)
        expect(result.has_errors).to_equal(true)
        expect(result.total_functions).to_equal(2)

# ================================================================
# Tests: Formatting
# ================================================================

describe "Frame Analysis - Formatting":
    it "produces non-empty report":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("process", state_enum, analysis)

        val report = format_frame_analysis(fa)
        expect(report.len()).to_be_greater_than(0)
        expect(report).to_contain("Frame Analysis: process")
        expect(report).to_contain("Header:")
        expect(report).to_contain("Variants:")

    it "includes variant details":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("process", state_enum, analysis)

        val report = format_frame_analysis(fa)
        expect(report).to_contain("State0")
        expect(report).to_contain("State1")
        expect(report).to_contain("State2")

describe "Frame Verification - Formatting":
    it "formats passing result":
        val state_enum = make_state_enum_one_await()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("ok", state_enum, analysis)

        val limits = default_baremetal_limits()
        val result = verify_frame(fa, limits)
        val output = format_verify_result(result)

        expect(output).to_contain("1/1 passed")

    it "formats failing result":
        val state_enum = make_state_enum_two_awaits()
        val analysis = make_empty_analysis()
        val fa = analyze_frame("bad", state_enum, analysis)

        val limits = FrameLimits(frame_max: 16, large_capture_max: 0, strict: true)
        val result = verify_frame(fa, limits)
        val output = format_verify_result(result)

        expect(output).to_contain("0/1 passed")
        expect(output).to_contain("[error]")
