#!/usr/bin/env simple
# Resource Reservation Sum Analysis Tests — Pass C
#
# Tests the compile-time reservation verification for baremetal async.
# Covers: reserve lookup, single/multi resource checks, per-task breakdown,
# group-aware instances, zero reserves, edge cases, data structure
# construction, formatting, and end-to-end spec scenario.
#
# NOTE: Tests operate at the data structure level (same pattern as Pass A/B
# tests). Reserve data is provided externally — no attribute parsing tested.

use compiler.desugar.reservation_analysis.{
    ResourceLeaf,
    TaskReservation,
    ReservationDemand,
    ReservationDiagnostic,
    ReservationVerifyResult,
    get_task_reserve,
    compute_demand,
    verify_reservations,
    format_demand,
    format_reservation_result
}
use compiler.desugar.spawn_analysis.{
    SpawnAnalysis,
    TaskInfo,
    TaskGroupInfo
}

# ================================================================
# Test Helpers
# ================================================================

fn make_leaf(path: text, unit_type: text, cap: i64) -> ResourceLeaf:
    ResourceLeaf(path: path, unit_name: unit_type, cap: cap)

fn make_reservation(name: text, paths: [text], counts: [i64], inst: i64) -> TaskReservation:
    TaskReservation(
        task_name: name,
        reserve_paths: paths,
        reserve_counts: counts,
        instances: inst
    )

fn make_empty_reservation(name: text, inst: i64) -> TaskReservation:
    TaskReservation(
        task_name: name,
        reserve_paths: [],
        reserve_counts: [],
        instances: inst
    )

# ================================================================
# Tests: get_task_reserve lookup
# ================================================================

describe "get_task_reserve lookup":
    it "returns count for existing path":
        val task = make_reservation("uart_rx", ["NetRes.pkt_pool", "NetRes.rxq.entries"], [2, 1], 1)
        expect(get_task_reserve(task, "NetRes.pkt_pool")).to_equal(2)
        expect(get_task_reserve(task, "NetRes.rxq.entries")).to_equal(1)

    it "returns zero for missing path":
        val task = make_reservation("uart_rx", ["NetRes.pkt_pool"], [2], 1)
        expect(get_task_reserve(task, "NetRes.stats")).to_equal(0)

    it "returns zero for empty reserves":
        val task = make_empty_reservation("idle_task", 1)
        expect(get_task_reserve(task, "NetRes.pkt_pool")).to_equal(0)

# ================================================================
# Tests: Single resource checks
# ================================================================

describe "Single resource demand":
    it "passes when demand within capacity":
        val leaf = make_leaf("NetRes.pkt_pool", "PktBuf", 8)
        val tasks = [
            make_reservation("uart_rx", ["NetRes.pkt_pool"], [1], 2),
            make_reservation("parser", ["NetRes.pkt_pool"], [1], 3)
        ]
        val result = verify_reservations([leaf], tasks)
        expect(result.has_errors).to_equal(false)
        expect(result.passed_checks).to_equal(1)
        expect(result.total_checks).to_equal(1)
        # demand = 1*2 + 1*3 = 5 <= 8
        expect(result.demands[0].total_demand).to_equal(5)

    it "passes when demand equals capacity":
        val leaf = make_leaf("NetRes.pkt_pool", "PktBuf", 8)
        val tasks = [
            make_reservation("uart_rx", ["NetRes.pkt_pool"], [2], 2),
            make_reservation("parser", ["NetRes.pkt_pool"], [2], 2)
        ]
        val result = verify_reservations([leaf], tasks)
        expect(result.has_errors).to_equal(false)
        # demand = 2*2 + 2*2 = 8 == 8
        expect(result.demands[0].total_demand).to_equal(8)
        expect(result.demands[0].overflow).to_equal(false)

    it "errors when demand exceeds capacity":
        val leaf = make_leaf("NetRes.pkt_pool", "PktBuf", 4)
        val tasks = [
            make_reservation("uart_rx", ["NetRes.pkt_pool"], [3], 2),
            make_reservation("parser", ["NetRes.pkt_pool"], [1], 1)
        ]
        val result = verify_reservations([leaf], tasks)
        expect(result.has_errors).to_equal(true)
        expect(result.passed_checks).to_equal(0)
        # demand = 3*2 + 1*1 = 7 > 4
        expect(result.demands[0].total_demand).to_equal(7)
        expect(result.demands[0].overflow).to_equal(true)

# ================================================================
# Tests: Multi-resource checks
# ================================================================

describe "Multi-resource checks":
    it "passes when all resources within capacity":
        val leaves = [
            make_leaf("NetRes.pkt_pool", "PktBuf", 8),
            make_leaf("NetRes.rxq.entries", "RxEntry", 8)
        ]
        val tasks = [
            make_reservation("uart_rx", ["NetRes.pkt_pool", "NetRes.rxq.entries"], [1, 1], 2)
        ]
        val result = verify_reservations(leaves, tasks)
        expect(result.has_errors).to_equal(false)
        expect(result.passed_checks).to_equal(2)
        expect(result.total_checks).to_equal(2)

    it "errors when one resource overflows":
        val leaves = [
            make_leaf("NetRes.pkt_pool", "PktBuf", 8),
            make_leaf("NetRes.rxq.waiters", "Waiter", 2)
        ]
        val tasks = [
            make_reservation("uart_rx", ["NetRes.pkt_pool", "NetRes.rxq.waiters"], [1, 1], 3)
        ]
        val result = verify_reservations(leaves, tasks)
        expect(result.has_errors).to_equal(true)
        # pkt_pool: 1*3=3 <= 8 OK, waiters: 1*3=3 > 2 OVERFLOW
        expect(result.passed_checks).to_equal(1)
        expect(result.demands[0].overflow).to_equal(false)
        expect(result.demands[1].overflow).to_equal(true)

    it "errors when all resources overflow":
        val leaves = [
            make_leaf("pool_a", "A", 2),
            make_leaf("pool_b", "B", 3)
        ]
        val tasks = [
            make_reservation("task1", ["pool_a", "pool_b"], [2, 2], 2)
        ]
        val result = verify_reservations(leaves, tasks)
        expect(result.has_errors).to_equal(true)
        expect(result.passed_checks).to_equal(0)
        # pool_a: 2*2=4 > 2, pool_b: 2*2=4 > 3
        expect(result.demands[0].overflow).to_equal(true)
        expect(result.demands[1].overflow).to_equal(true)

# ================================================================
# Tests: Per-task breakdown
# ================================================================

describe "Per-task breakdown":
    it "tracks contributor names":
        val leaf = make_leaf("NetRes.pkt_pool", "PktBuf", 100)
        val tasks = [
            make_reservation("uart_rx", ["NetRes.pkt_pool"], [2], 3),
            make_reservation("parser", ["NetRes.pkt_pool"], [4], 2)
        ]
        val result = verify_reservations([leaf], tasks)
        val demand = result.demands[0]
        expect(demand.contributor_names.len()).to_equal(2)
        expect(demand.contributor_names[0]).to_equal("uart_rx")
        expect(demand.contributor_names[1]).to_equal("parser")

    it "tracks contributor amounts":
        val leaf = make_leaf("NetRes.pkt_pool", "PktBuf", 100)
        val tasks = [
            make_reservation("uart_rx", ["NetRes.pkt_pool"], [2], 3),
            make_reservation("parser", ["NetRes.pkt_pool"], [4], 2)
        ]
        val result = verify_reservations([leaf], tasks)
        val demand = result.demands[0]
        # uart_rx: 2*3=6, parser: 4*2=8
        expect(demand.contributor_amounts[0]).to_equal(6)
        expect(demand.contributor_amounts[1]).to_equal(8)
        expect(demand.total_demand).to_equal(14)

# ================================================================
# Tests: Group-aware instances (using exact spawn counts from Pass B)
# ================================================================

describe "Group-aware instances":
    it "uses exact spawn counts not declared instances":
        # Task declared with instances=4, but only spawned 2 times
        val leaf = make_leaf("pool", "Unit", 5)
        val tasks = [
            make_reservation("task_a", ["pool"], [2], 2)
        ]
        val result = verify_reservations([leaf], tasks)
        # demand = 2*2 = 4 <= 5 (uses instances=2, not declared max)
        expect(result.has_errors).to_equal(false)
        expect(result.demands[0].total_demand).to_equal(4)

    it "would overflow with declared instances but not with actual":
        # If instances were 4 (declared), demand would be 2*4=8 > 5
        # But actual spawn count is 2, so demand = 2*2=4 <= 5
        val leaf = make_leaf("pool", "Unit", 5)
        val tasks = [
            make_reservation("task_a", ["pool"], [2], 2)
        ]
        val result = verify_reservations([leaf], tasks)
        expect(result.has_errors).to_equal(false)

# ================================================================
# Tests: Zero reserves
# ================================================================

describe "Zero reserves":
    it "task with no reserves contributes nothing":
        val leaf = make_leaf("pool", "Unit", 4)
        val tasks = [
            make_empty_reservation("idle_task", 3),
            make_reservation("worker", ["pool"], [1], 2)
        ]
        val result = verify_reservations([leaf], tasks)
        # Only worker contributes: 1*2=2
        expect(result.demands[0].total_demand).to_equal(2)
        expect(result.demands[0].contributor_names.len()).to_equal(1)
        expect(result.demands[0].contributor_names[0]).to_equal("worker")

    it "resource with no reservers has zero demand":
        val leaf = make_leaf("unused_pool", "Unit", 4)
        val tasks = [
            make_reservation("worker", ["other_pool"], [1], 2)
        ]
        val result = verify_reservations([leaf], tasks)
        expect(result.demands[0].total_demand).to_equal(0)
        expect(result.demands[0].overflow).to_equal(false)
        expect(result.demands[0].contributor_names.len()).to_equal(0)

# ================================================================
# Tests: Edge cases
# ================================================================

describe "Edge cases":
    it "handles empty leaves list":
        val tasks = [
            make_reservation("worker", ["pool"], [1], 2)
        ]
        val result = verify_reservations([], tasks)
        expect(result.has_errors).to_equal(false)
        expect(result.total_checks).to_equal(0)
        expect(result.passed_checks).to_equal(0)
        expect(result.demands.len()).to_equal(0)

    it "handles empty tasks list":
        val leaves = [make_leaf("pool", "Unit", 4)]
        val result = verify_reservations(leaves, [])
        expect(result.has_errors).to_equal(false)
        expect(result.total_checks).to_equal(1)
        expect(result.passed_checks).to_equal(1)
        expect(result.demands[0].total_demand).to_equal(0)

# ================================================================
# Tests: Data structure construction
# ================================================================

describe "Data structure construction":
    it "creates ResourceLeaf correctly":
        val leaf = make_leaf("NetRes.pkt_pool", "PktBuf", 8)
        expect(leaf.path).to_equal("NetRes.pkt_pool")
        expect(leaf.unit_name).to_equal("PktBuf")
        expect(leaf.cap).to_equal(8)

    it "creates TaskReservation correctly":
        val task = make_reservation("uart_rx", ["pool_a", "pool_b"], [2, 3], 4)
        expect(task.task_name).to_equal("uart_rx")
        expect(task.reserve_paths.len()).to_equal(2)
        expect(task.reserve_counts.len()).to_equal(2)
        expect(task.instances).to_equal(4)
        expect(task.reserve_paths[0]).to_equal("pool_a")
        expect(task.reserve_counts[1]).to_equal(3)

    it "creates ReservationDemand via compute_demand":
        val leaf = make_leaf("pool", "Unit", 10)
        val tasks = [make_reservation("t1", ["pool"], [3], 2)]
        val demand = compute_demand(leaf, tasks)
        expect(demand.resource_path).to_equal("pool")
        expect(demand.total_demand).to_equal(6)
        expect(demand.cap).to_equal(10)
        expect(demand.overflow).to_equal(false)

# ================================================================
# Tests: Formatting
# ================================================================

describe "Reservation formatting":
    it "formats passing result":
        val leaves = [make_leaf("pool", "Unit", 10)]
        val tasks = [make_reservation("t1", ["pool"], [1], 2)]
        val result = verify_reservations(leaves, tasks)
        val output = format_reservation_result(result)
        expect(output).to_contain("Reservation Verification: pass")
        expect(output).to_contain("1/1 resources OK")
        expect(output).to_contain("pool")

    it "formats failing result with overflow details":
        val leaves = [make_leaf("pool", "Unit", 2)]
        val tasks = [make_reservation("t1", ["pool"], [3], 2)]
        val result = verify_reservations(leaves, tasks)
        val output = format_reservation_result(result)
        expect(output).to_contain("Reservation Verification: FAIL")
        expect(output).to_contain("0/1 resources OK")
        expect(output).to_contain("OVERFLOW")
        expect(output).to_contain("reservation overflow")

# ================================================================
# Tests: End-to-end scenario (spec Section 11)
# ================================================================

describe "End-to-end: spec Section 11 NetRes scenario":
    it "validates full NetRes resource set":
        # Resources from spec
        val leaves = [
            make_leaf("NetRes.pkt_pool", "PktBuf", 8),
            make_leaf("NetRes.rxq.entries", "RxEntry", 8),
            make_leaf("NetRes.rxq.waiters", "Waiter", 2),
            make_leaf("NetRes.stats", "StatSlot", 64)
        ]

        # Tasks: uart_rx (1 instance), parser (1 instance)
        val tasks = [
            make_reservation(
                "uart_rx",
                ["NetRes.pkt_pool", "NetRes.rxq.entries", "NetRes.rxq.waiters"],
                [1, 1, 1],
                1
            ),
            make_reservation(
                "parser",
                ["NetRes.stats"],
                [4],
                1
            )
        ]

        val result = verify_reservations(leaves, tasks)

        # All should pass:
        # pkt_pool: 1*1=1 <= 8
        # rxq.entries: 1*1=1 <= 8
        # rxq.waiters: 1*1=1 <= 2
        # stats: 4*1=4 <= 64
        expect(result.has_errors).to_equal(false)
        expect(result.total_checks).to_equal(4)
        expect(result.passed_checks).to_equal(4)

        # Verify individual demands
        expect(result.demands[0].total_demand).to_equal(1)
        expect(result.demands[1].total_demand).to_equal(1)
        expect(result.demands[2].total_demand).to_equal(1)
        expect(result.demands[3].total_demand).to_equal(4)

        # Formatting should show pass
        val output = format_reservation_result(result)
        expect(output).to_contain("pass")
        expect(output).to_contain("4/4 resources OK")
