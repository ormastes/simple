# Lexer Tests
#
# Tests for the lexer module, focusing on branch coverage for:
# - Helper functions (is_digit, is_alpha, keyword_kind, etc.)
# - Token and Span types
# - Basic tokenization

use core.lexer.*
use core.lexer_types.*

# ============================================================================
# Test Group 1: Character Classification Functions
# ============================================================================

describe "is_digit":
    """
    Tests digit classification.
    """

    it "returns true for digit 0":
        expect is_digit('0')

    it "returns true for digit 5":
        expect is_digit('5')

    it "returns true for digit 9":
        expect is_digit('9')

    it "returns false for letter a":
        expect not is_digit('a')

    it "returns false for letter Z":
        expect not is_digit('Z')

    it "returns false for space":
        expect not is_digit(' ')

    it "returns false for underscore":
        expect not is_digit('_')


describe "is_hex_digit":
    """
    Tests hexadecimal digit classification.
    """

    it "returns true for digit 0":
        expect is_hex_digit('0')

    it "returns true for digit 9":
        expect is_hex_digit('9')

    it "returns true for lowercase a":
        expect is_hex_digit('a')

    it "returns true for lowercase f":
        expect is_hex_digit('f')

    it "returns true for uppercase A":
        expect is_hex_digit('A')

    it "returns true for uppercase F":
        expect is_hex_digit('F')

    it "returns false for letter g":
        expect not is_hex_digit('g')

    it "returns false for letter Z":
        expect not is_hex_digit('Z')


describe "is_alpha":
    """
    Tests alphabetic character classification.
    """

    it "returns true for lowercase a":
        expect is_alpha('a')

    it "returns true for lowercase z":
        expect is_alpha('z')

    it "returns true for uppercase A":
        expect is_alpha('A')

    it "returns true for uppercase Z":
        expect is_alpha('Z')

    it "returns false for digit 0":
        expect not is_alpha('0')

    it "returns false for digit 9":
        expect not is_alpha('9')

    it "returns false for underscore":
        expect not is_alpha('_')


describe "is_ident_start":
    """
    Tests identifier start character classification.
    """

    it "returns true for lowercase letter":
        expect is_ident_start('a')

    it "returns true for uppercase letter":
        expect is_ident_start('Z')

    it "returns true for underscore":
        expect is_ident_start('_')

    it "returns false for digit":
        expect not is_ident_start('0')

    it "returns false for space":
        expect not is_ident_start(' ')

    it "returns false for special char":
        expect not is_ident_start('$')


describe "is_ident_char":
    """
    Tests identifier continuation character classification.
    """

    it "returns true for lowercase letter":
        expect is_ident_char('a')

    it "returns true for uppercase letter":
        expect is_ident_char('Z')

    it "returns true for digit":
        expect is_ident_char('5')

    it "returns true for underscore":
        expect is_ident_char('_')

    it "returns false for space":
        expect not is_ident_char(' ')

    it "returns false for special char":
        expect not is_ident_char('$')


# ============================================================================
# Test Group 2: Keyword Recognition
# ============================================================================

describe "keyword_kind":
    """
    Tests keyword recognition for control flow keywords.
    """

    it "recognizes 'fn' keyword":
        val kind = keyword_kind("fn")
        expect kind == TokenKind.KwFn

    it "recognizes 'val' keyword":
        val kind = keyword_kind("val")
        expect kind == TokenKind.KwVal

    it "recognizes 'var' keyword":
        val kind = keyword_kind("var")
        expect kind == TokenKind.KwVar

    it "recognizes 'if' keyword":
        val kind = keyword_kind("if")
        expect kind == TokenKind.KwIf

    it "recognizes 'else' keyword":
        val kind = keyword_kind("else")
        expect kind == TokenKind.KwElse

    it "recognizes 'elif' keyword":
        val kind = keyword_kind("elif")
        expect kind == TokenKind.KwElif

    it "recognizes 'match' keyword":
        val kind = keyword_kind("match")
        expect kind == TokenKind.KwMatch

    it "recognizes 'for' keyword":
        val kind = keyword_kind("for")
        expect kind == TokenKind.KwFor

    it "recognizes 'while' keyword":
        val kind = keyword_kind("while")
        expect kind == TokenKind.KwWhile

    it "recognizes 'return' keyword":
        val kind = keyword_kind("return")
        expect kind == TokenKind.KwReturn

    it "recognizes 'break' keyword":
        val kind = keyword_kind("break")
        expect kind == TokenKind.KwBreak

    it "recognizes 'continue' keyword":
        val kind = keyword_kind("continue")
        expect kind == TokenKind.KwContinue


describe "keyword_kind declarations":
    """
    Tests keyword recognition for declaration keywords.
    """

    it "recognizes 'struct' keyword":
        val kind = keyword_kind("struct")
        expect kind == TokenKind.KwStruct

    it "recognizes 'class' keyword":
        val kind = keyword_kind("class")
        expect kind == TokenKind.KwClass

    it "recognizes 'enum' keyword":
        val kind = keyword_kind("enum")
        expect kind == TokenKind.KwEnum

    it "recognizes 'trait' keyword":
        val kind = keyword_kind("trait")
        expect kind == TokenKind.KwTrait

    it "recognizes 'impl' keyword":
        val kind = keyword_kind("impl")
        expect kind == TokenKind.KwImpl

    it "recognizes 'mod' keyword":
        val kind = keyword_kind("mod")
        expect kind == TokenKind.KwMod


describe "keyword_kind booleans":
    """
    Tests keyword recognition for boolean and nil literals.
    """

    it "recognizes 'true' keyword":
        val kind = keyword_kind("true")
        expect kind == TokenKind.BoolLit

    it "recognizes 'false' keyword":
        val kind = keyword_kind("false")
        expect kind == TokenKind.BoolLit

    it "recognizes 'nil' keyword":
        val kind = keyword_kind("nil")
        expect kind == TokenKind.NilLit


describe "keyword_kind operators":
    """
    Tests keyword recognition for operator keywords.
    """

    it "recognizes 'not' keyword":
        val kind = keyword_kind("not")
        expect kind == TokenKind.KwNot

    it "recognizes 'and' keyword":
        val kind = keyword_kind("and")
        expect kind == TokenKind.KwAnd

    it "recognizes 'or' keyword":
        val kind = keyword_kind("or")
        expect kind == TokenKind.KwOr

    it "recognizes 'xor' keyword":
        val kind = keyword_kind("xor")
        expect kind == TokenKind.KwXor

    it "recognizes 'in' keyword":
        val kind = keyword_kind("in")
        expect kind == TokenKind.KwIn

    it "recognizes 'is' keyword":
        val kind = keyword_kind("is")
        expect kind == TokenKind.KwIs

    it "recognizes 'as' keyword":
        val kind = keyword_kind("as")
        expect kind == TokenKind.KwAs


describe "keyword_kind identifiers":
    """
    Tests that non-keywords return Ident.
    """

    it "returns Ident for regular identifier":
        val kind = keyword_kind("foo")
        expect kind == TokenKind.Ident

    it "returns Ident for camelCase identifier":
        val kind = keyword_kind("myVariable")
        expect kind == TokenKind.Ident

    it "returns Ident for identifier with underscore":
        val kind = keyword_kind("_private")
        expect kind == TokenKind.Ident

    it "returns Ident for identifier with numbers":
        val kind = keyword_kind("var123")
        expect kind == TokenKind.Ident


# ============================================================================
# Test Group 3: Helper Functions
# ============================================================================

describe "min function":
    """
    Tests min helper function.
    """

    it "returns smaller of two positive numbers":
        expect min(5, 10) == 5

    it "returns smaller of two negative numbers":
        expect min(-5, -10) == -10

    it "returns smaller when first is smaller":
        expect min(3, 7) == 3

    it "returns smaller when second is smaller":
        expect min(9, 2) == 2

    it "returns same value for equal numbers":
        expect min(5, 5) == 5

    it "handles zero":
        expect min(0, 10) == 0
        expect min(-5, 0) == -5


describe "max function":
    """
    Tests max helper function.
    """

    it "returns larger of two positive numbers":
        expect max(5, 10) == 10

    it "returns larger of two negative numbers":
        expect max(-5, -10) == -5

    it "returns larger when first is larger":
        expect max(7, 3) == 7

    it "returns larger when second is larger":
        expect max(2, 9) == 9

    it "returns same value for equal numbers":
        expect max(5, 5) == 5

    it "handles zero":
        expect max(0, 10) == 10
        expect max(-5, 0) == 0


# ============================================================================
# Test Group 4: Span Operations
# ============================================================================

describe "merge_spans":
    """
    Tests span merging functionality.
    """

    it "merges two spans on same line":
        val s1 = Span.new(0, 5, 1, 1)
        val s2 = Span.new(10, 15, 1, 11)
        val merged = merge_spans(s1, s2)
        expect merged.start == 0
        expect merged.end == 15
        expect merged.line == 1

    it "merges spans from different lines":
        val s1 = Span.new(0, 5, 1, 1)
        val s2 = Span.new(10, 15, 2, 1)
        val merged = merge_spans(s1, s2)
        expect merged.start == 0
        expect merged.end == 15
        expect merged.line == 1

    it "handles identical spans":
        val s1 = Span.new(5, 10, 1, 5)
        val s2 = Span.new(5, 10, 1, 5)
        val merged = merge_spans(s1, s2)
        expect merged.start == 5
        expect merged.end == 10

    it "handles overlapping spans":
        val s1 = Span.new(0, 10, 1, 1)
        val s2 = Span.new(5, 15, 1, 6)
        val merged = merge_spans(s1, s2)
        expect merged.start == 0
        expect merged.end == 15


# ============================================================================
# Test Group 5: Span Creation
# ============================================================================

describe "Span new":
    """
    Tests Span creation.
    """

    it "creates span with correct fields":
        val span = Span.new(0, 10, 1, 1)
        expect span.start == 0
        expect span.end == 10
        expect span.line == 1
        expect span.col == 1

    it "creates span with different values":
        val span = Span.new(100, 200, 5, 20)
        expect span.start == 100
        expect span.end == 200
        expect span.line == 5
        expect span.col == 20


# ============================================================================
# Test Group 6: Token Creation
# ============================================================================

describe "Token new":
    """
    Tests Token creation.
    """

    it "creates token with kind and span":
        val span = Span.new(0, 3, 1, 1)
        val token = Token.new(TokenKind.KwFn, span, "fn")
        expect token.kind == TokenKind.KwFn
        expect token.text == "fn"

    it "creates token with different kind":
        val span = Span.new(0, 5, 1, 1)
        val token = Token.new(TokenKind.Ident, span, "hello")
        expect token.kind == TokenKind.Ident
        expect token.text == "hello"


describe "Token eof":
    """
    Tests EOF token creation.
    """

    it "creates EOF token":
        val token = Token.eof(100, 5)
        expect token.kind == TokenKind.Eof

    it "creates EOF token with correct position":
        val token = Token.eof(200, 10)
        expect token.span.start == 200
        expect token.span.line == 10


# ============================================================================
# Test Group 7: Edge Cases
# ============================================================================

describe "Edge cases":
    """
    Edge cases for lexer helper functions.
    """

    it "handles empty keyword string":
        val kind = keyword_kind("")
        expect kind == TokenKind.Ident

    it "handles min with same values":
        expect min(0, 0) == 0
        expect min(-1, -1) == -1

    it "handles max with large values":
        expect max(1000000, 999999) == 1000000

    it "handles span with zero length":
        val span = Span.new(5, 5, 1, 5)
        expect span.start == span.end
