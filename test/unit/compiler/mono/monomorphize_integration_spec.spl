# Monomorphization Integration Test Specification
#
# Tests for monomorphization pipeline integration.
# Verifies that the driver correctly runs monomorphization pass.

use std.test.*

# ============================================================================
# Documentation Tests (interpreter-compatible)
# ============================================================================

describe "Monomorphization Pipeline Integration":
    describe "Driver Integration":
        it "Phase 4 runs after Phase 3 (HIR lowering)":
            # Driver.compile() flow:
            # Phase 1: Load sources
            # Phase 2: Parse
            # Phase 3: Lower to HIR + resolve methods + type check
            # Phase 4: Monomorphization (NEW)
            # Phase 5: Mode-specific processing
            pass

        it "monomorphize_impl scans HIR modules for generics":
            # MonomorphizationPass.process_modules():
            # 1. collect_generics() - Find generic functions/structs/classes
            # 2. scan_call_sites() - Find calls with type arguments
            # 3. process_specializations() - Create specialized versions
            # 4. rewrite_module() - Update call sites
            pass

        it "statistics track monomorphization progress":
            # MonoStats:
            # - generic_functions_found
            # - generic_structs_found
            # - generic_classes_found
            # - call_sites_found
            # - specializations_created
            pass

    describe "Generic Detection":
        it "identifies generic functions by type_params":
            # fn identity<T>(x: T) -> T
            # HirFunction.type_params.len() > 0 -> is generic
            pass

        it "identifies generic structs by type_params":
            # struct Box<T>: value: T
            # HirStruct.type_params.len() > 0 -> is generic
            pass

        it "identifies generic classes by type_params":
            # class List<T>: items: [T]
            # HirClass.type_params.len() > 0 -> is generic
            pass

    describe "Call Site Scanning":
        it "scans function bodies recursively":
            # scan_function_body() -> scan_block() -> scan_stmt() -> scan_expr()
            # Handles all expression kinds that might contain calls
            pass

        it "detects calls with explicit type arguments":
            # identity<Int>(42) -> Call with type_args = [Int]
            pass

        it "detects method calls that may be generic":
            # list.map<String>(f) -> MethodCall with generics
            pass

    describe "Specialization":
        it "creates mangled names for specializations":
            # identity<Int> -> identity$Int
            # map<Int, String> -> map$Int_String
            pass

        it "substitutes type parameters in function body":
            # fn identity<T>(x: T) -> T: x
            # With T=Int becomes:
            # fn identity$Int(x: Int) -> Int: x
            pass

    describe "Pipeline Order":
        it "runs before MIR lowering":
            # Ensures specialized functions are available for MIR lowering
            # driver.lower_to_mir() uses specialized HirFunctions
            pass

        it "runs after type checking":
            # Ensures type information is available for specialization
            # Type arguments are resolved before monomorphization
            pass

describe "MIR Lowering Integration":
    it "HIR lowering exists and is complete (1206 lines)":
        # src/compiler/hir_lowering.spl
        # AST -> HIR transformation
        pass

    it "MIR lowering exists and is mostly complete (761 lines)":
        # src/compiler/mir_lowering.spl
        # HIR -> MIR transformation
        pass

    it "MIR optimization is ready (7 passes)":
        # src/compiler/mir_opt/
        # DCE, Const Fold, Copy Prop, CSE, Inline, Loop Opt, Pipeline
        pass

    it "Full pipeline flows: HIR -> Mono -> MIR -> Opt -> Codegen":
        # Phase 3: AST -> HIR
        # Phase 4: HIR -> Specialized HIR
        # lower_to_mir(): Specialized HIR -> MIR
        # optimize_mir_module(): MIR -> Optimized MIR
        # codegen: MIR -> Native
        pass
