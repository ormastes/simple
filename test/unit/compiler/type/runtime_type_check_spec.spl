# Runtime Type Checking Tests
#
# Tests for type_checker.spl runtime type validation
# Covers union, intersection, refinement, and basic type checking

use std.spec.{describe, it, expect}

# Mock value constructors for testing
# In production these come from interpreter/value.spl

var test_val_kinds: [i64] = []
var test_val_ints: [i64] = []
var test_val_floats: [f64] = []
var test_val_texts: [text] = []
var test_val_arrays: [[i64]] = []
var test_val_struct_names: [text] = []
var test_val_struct_fields: [[text]] = []
var test_val_struct_values: [[i64]] = []

val TEST_VAL_NIL: i64 = 0
val TEST_VAL_BOOL: i64 = 1
val TEST_VAL_INT: i64 = 2
val TEST_VAL_FLOAT: i64 = 3
val TEST_VAL_TEXT: i64 = 4
val TEST_VAL_ARRAY: i64 = 5
val TEST_VAL_STRUCT: i64 = 6
val TEST_VAL_FUNCTION: i64 = 7

fn test_val_reset():
    test_val_kinds = []
    test_val_ints = []
    test_val_floats = []
    test_val_texts = []
    test_val_arrays = []
    test_val_struct_names = []
    test_val_struct_fields = []
    test_val_struct_values = []

fn test_val_alloc(kind: i64) -> i64:
    val idx = test_val_kinds.len()
    test_val_kinds.push(kind)
    test_val_ints.push(0)
    test_val_floats.push(0.0)
    test_val_texts.push("")
    test_val_arrays.push([])
    test_val_struct_names.push("")
    test_val_struct_fields.push([])
    test_val_struct_values.push([])
    idx

fn test_make_nil() -> i64:
    test_val_alloc(TEST_VAL_NIL)

fn test_make_bool(b: bool) -> i64:
    val idx = test_val_alloc(TEST_VAL_BOOL)
    if b:
        test_val_ints[idx] = 1
    else:
        test_val_ints[idx] = 0
    idx

fn test_make_int(n: i64) -> i64:
    val idx = test_val_alloc(TEST_VAL_INT)
    test_val_ints[idx] = n
    idx

fn test_make_float(f: f64) -> i64:
    val idx = test_val_alloc(TEST_VAL_FLOAT)
    test_val_floats[idx] = f
    idx

fn test_make_text(s: text) -> i64:
    val idx = test_val_alloc(TEST_VAL_TEXT)
    test_val_texts[idx] = s
    idx

fn test_make_array(elements: [i64]) -> i64:
    val idx = test_val_alloc(TEST_VAL_ARRAY)
    test_val_arrays[idx] = elements
    idx

fn test_make_struct(name: text, fields: [text], values: [i64]) -> i64:
    val idx = test_val_alloc(TEST_VAL_STRUCT)
    test_val_struct_names[idx] = name
    test_val_struct_fields[idx] = fields
    test_val_struct_values[idx] = values
    idx

# Mock extern functions needed by type_checker.spl
fn val_kind(value_id: i64) -> i64:
    if value_id < 0 or value_id >= test_val_kinds.len():
        return TEST_VAL_NIL
    test_val_kinds[value_id]

fn val_get_int(value_id: i64) -> i64:
    if value_id < 0 or value_id >= test_val_ints.len():
        return 0
    test_val_ints[value_id]

fn val_get_float(value_id: i64) -> f64:
    if value_id < 0 or value_id >= test_val_floats.len():
        return 0.0
    test_val_floats[value_id]

fn val_get_text(value_id: i64) -> text:
    if value_id < 0 or value_id >= test_val_texts.len():
        return ""
    test_val_texts[value_id]

fn val_get_array(value_id: i64) -> [i64]:
    if value_id < 0 or value_id >= test_val_arrays.len():
        return []
    test_val_arrays[value_id]

fn val_get_struct_name(value_id: i64) -> text:
    if value_id < 0 or value_id >= test_val_struct_names.len():
        return ""
    test_val_struct_names[value_id]

fn val_get_struct_fields(value_id: i64) -> [text]:
    if value_id < 0 or value_id >= test_val_struct_fields.len():
        return []
    test_val_struct_fields[value_id]

fn val_get_struct_values(value_id: i64) -> [i64]:
    if value_id < 0 or value_id >= test_val_struct_values.len():
        return []
    test_val_struct_values[value_id]

# Mock type registry functions
var test_named_types: [text] = []
var test_named_fields: [[text]] = []
var test_named_field_types: [[i64]] = []

fn named_type_find(name: text) -> i64:
    for i in range(0, test_named_types.len()):
        if test_named_types[i] == name:
            return i
    -1

fn named_type_name(type_id: i64) -> text:
    if type_id < 0 or type_id >= test_named_types.len():
        return ""
    test_named_types[type_id]

fn named_type_fields(type_id: i64) -> [text]:
    if type_id < 0 or type_id >= test_named_fields.len():
        return []
    test_named_fields[type_id]

fn named_type_field_type_tags(type_id: i64) -> [i64]:
    if type_id < 0 or type_id >= test_named_field_types.len():
        return []
    test_named_field_types[type_id]

fn test_register_named_type(name: text, fields: [text], field_types: [i64]):
    test_named_types.push(name)
    test_named_fields.push(fields)
    test_named_field_types.push(field_types)

# Mock union/intersection/refinement registries
var test_union_members: [[i64]] = []
var test_intersection_members: [[i64]] = []
var test_refinement_bases: [i64] = []
var test_refinement_predicates: [text] = []

fn union_type_get_members(union_id: i64) -> [i64]:
    if union_id < 0 or union_id >= test_union_members.len():
        return []
    test_union_members[union_id]

fn test_register_union(members: [i64]) -> i64:
    val idx = test_union_members.len()
    test_union_members.push(members)
    idx

fn intersection_type_get_members(inter_id: i64) -> [i64]:
    if inter_id < 0 or inter_id >= test_intersection_members.len():
        return []
    test_intersection_members[inter_id]

fn test_register_intersection(members: [i64]) -> i64:
    val idx = test_intersection_members.len()
    test_intersection_members.push(members)
    idx

fn refinement_type_base(ref_id: i64) -> i64:
    if ref_id < 0 or ref_id >= test_refinement_bases.len():
        return 12  # TYPE_ANY
    test_refinement_bases[ref_id]

fn refinement_type_predicate(ref_id: i64) -> text:
    if ref_id < 0 or ref_id >= test_refinement_predicates.len():
        return ""
    test_refinement_predicates[ref_id]

fn test_register_refinement(base_type: i64, predicate: text) -> i64:
    val idx = test_refinement_bases.len()
    test_refinement_bases.push(base_type)
    test_refinement_predicates.push(predicate)
    idx

# Import type checker functions
# NOTE: In production this would be: use compiler.core.type_checker.{...}
# For testing we'll inline minimal type checking logic

val TYPE_VOID: i64 = 0
val TYPE_BOOL: i64 = 1
val TYPE_I64: i64 = 2
val TYPE_F64: i64 = 3
val TYPE_TEXT: i64 = 4
val TYPE_ARRAY_ANY: i64 = 8
val TYPE_STRUCT: i64 = 10
val TYPE_FN: i64 = 11
val TYPE_ANY: i64 = 12
val TYPE_NIL: i64 = 13

fn simple_type_check(value_id: i64, type_tag: i64) -> bool:
    val kind = val_kind(value_id)
    if type_tag == TYPE_ANY:
        return true
    if type_tag == TYPE_NIL:
        return kind == TEST_VAL_NIL
    if type_tag == TYPE_BOOL:
        return kind == TEST_VAL_BOOL
    if type_tag == TYPE_I64:
        return kind == TEST_VAL_INT
    if type_tag == TYPE_F64:
        return kind == TEST_VAL_FLOAT
    if type_tag == TYPE_TEXT:
        return kind == TEST_VAL_TEXT
    if type_tag == TYPE_ARRAY_ANY:
        return kind == TEST_VAL_ARRAY
    if type_tag == TYPE_FN:
        return kind == TEST_VAL_FUNCTION
    false

fn simple_union_check(value_id: i64, union_id: i64) -> bool:
    val members = union_type_get_members(union_id)
    if members.len() == 0:
        return false
    for member_type in members:
        if simple_type_check(value_id, member_type):
            return true
    false

fn simple_intersection_check(value_id: i64, inter_id: i64) -> bool:
    val members = intersection_type_get_members(inter_id)
    if members.len() == 0:
        return true
    for member_type in members:
        if not simple_type_check(value_id, member_type):
            return false
    true

fn simple_refinement_check(value_id: i64, ref_id: i64) -> bool:
    val base_type = refinement_type_base(ref_id)
    if not simple_type_check(value_id, base_type):
        return false
    val predicate = refinement_type_predicate(ref_id)
    if predicate == "":
        return true
    # Simple predicate evaluation for "x > N" patterns
    val kind = val_kind(value_id)
    if kind == TEST_VAL_INT:
        val value = val_get_int(value_id)
        if predicate == "x > 0":
            return value > 0
        if predicate == "x >= 0":
            return value >= 0
        if predicate == "x < 100":
            return value < 100
        if predicate == "x > 10":
            return value > 10
    if kind == TEST_VAL_TEXT or kind == TEST_VAL_ARRAY:
        var length: i64 = 0
        if kind == TEST_VAL_TEXT:
            val txt = val_get_text(value_id)
            length = txt.len()
        else:
            val arr = val_get_array(value_id)
            length = arr.len()
        if predicate == "len(x) > 0":
            return length > 0
        if predicate == "len(x) >= 5":
            return length >= 5
    true

# ===== TEST SUITE =====

describe("Runtime Type Checking"):
    it("checks nil values correctly"):
        test_val_reset()
        val nil_val = test_make_nil()
        expect(simple_type_check(nil_val, TYPE_NIL)).to_equal(true)
        expect(simple_type_check(nil_val, TYPE_I64)).to_equal(false)
        expect(simple_type_check(nil_val, TYPE_ANY)).to_equal(true)

    it("checks boolean values correctly"):
        test_val_reset()
        val bool_val = test_make_bool(true)
        expect(simple_type_check(bool_val, TYPE_BOOL)).to_equal(true)
        expect(simple_type_check(bool_val, TYPE_I64)).to_equal(false)
        expect(simple_type_check(bool_val, TYPE_ANY)).to_equal(true)

    it("checks integer values correctly"):
        test_val_reset()
        val int_val = test_make_int(42)
        expect(simple_type_check(int_val, TYPE_I64)).to_equal(true)
        expect(simple_type_check(int_val, TYPE_F64)).to_equal(false)
        expect(simple_type_check(int_val, TYPE_ANY)).to_equal(true)

    it("checks float values correctly"):
        test_val_reset()
        val float_val = test_make_float(3.14)
        expect(simple_type_check(float_val, TYPE_F64)).to_equal(true)
        expect(simple_type_check(float_val, TYPE_I64)).to_equal(false)
        expect(simple_type_check(float_val, TYPE_ANY)).to_equal(true)

    it("checks text values correctly"):
        test_val_reset()
        val text_val = test_make_text("hello")
        expect(simple_type_check(text_val, TYPE_TEXT)).to_equal(true)
        expect(simple_type_check(text_val, TYPE_I64)).to_equal(false)
        expect(simple_type_check(text_val, TYPE_ANY)).to_equal(true)

    it("checks array values correctly"):
        test_val_reset()
        val arr_val = test_make_array([1, 2, 3])
        expect(simple_type_check(arr_val, TYPE_ARRAY_ANY)).to_equal(true)
        expect(simple_type_check(arr_val, TYPE_I64)).to_equal(false)
        expect(simple_type_check(arr_val, TYPE_ANY)).to_equal(true)

describe("Union Type Checking"):
    it("accepts value matching first union member"):
        test_val_reset()
        test_union_members = []
        val union_id = test_register_union([TYPE_I64, TYPE_TEXT])
        val int_val = test_make_int(42)
        expect(simple_union_check(int_val, union_id)).to_equal(true)

    it("accepts value matching second union member"):
        test_val_reset()
        test_union_members = []
        val union_id = test_register_union([TYPE_I64, TYPE_TEXT])
        val text_val = test_make_text("hello")
        expect(simple_union_check(text_val, union_id)).to_equal(true)

    it("rejects value not matching any union member"):
        test_val_reset()
        test_union_members = []
        val union_id = test_register_union([TYPE_I64, TYPE_TEXT])
        val float_val = test_make_float(3.14)
        expect(simple_union_check(float_val, union_id)).to_equal(false)

    it("handles three-member unions"):
        test_val_reset()
        test_union_members = []
        val union_id = test_register_union([TYPE_I64, TYPE_TEXT, TYPE_F64])
        val float_val = test_make_float(2.71)
        expect(simple_union_check(float_val, union_id)).to_equal(true)

    it("rejects empty union"):
        test_val_reset()
        test_union_members = []
        val union_id = test_register_union([])
        val int_val = test_make_int(42)
        expect(simple_union_check(int_val, union_id)).to_equal(false)

    it("handles union with nil"):
        test_val_reset()
        test_union_members = []
        val union_id = test_register_union([TYPE_I64, TYPE_NIL])
        val nil_val = test_make_nil()
        expect(simple_union_check(nil_val, union_id)).to_equal(true)

describe("Intersection Type Checking"):
    it("accepts value matching all intersection members"):
        test_val_reset()
        test_intersection_members = []
        val inter_id = test_register_intersection([TYPE_ANY, TYPE_I64])
        val int_val = test_make_int(42)
        expect(simple_intersection_check(int_val, inter_id)).to_equal(true)

    it("rejects value not matching all intersection members"):
        test_val_reset()
        test_intersection_members = []
        val inter_id = test_register_intersection([TYPE_I64, TYPE_TEXT])
        val int_val = test_make_int(42)
        expect(simple_intersection_check(int_val, inter_id)).to_equal(false)

    it("accepts empty intersection as universal type"):
        test_val_reset()
        test_intersection_members = []
        val inter_id = test_register_intersection([])
        val int_val = test_make_int(42)
        expect(simple_intersection_check(int_val, inter_id)).to_equal(true)

    it("handles three-member intersections"):
        test_val_reset()
        test_intersection_members = []
        val inter_id = test_register_intersection([TYPE_ANY, TYPE_I64, TYPE_ANY])
        val int_val = test_make_int(99)
        expect(simple_intersection_check(int_val, inter_id)).to_equal(true)

describe("Refinement Type Checking"):
    it("checks positive integer refinement"):
        test_val_reset()
        test_refinement_bases = []
        test_refinement_predicates = []
        val ref_id = test_register_refinement(TYPE_I64, "x > 0")
        val pos_val = test_make_int(5)
        expect(simple_refinement_check(pos_val, ref_id)).to_equal(true)

    it("rejects negative integer for positive refinement"):
        test_val_reset()
        test_refinement_bases = []
        test_refinement_predicates = []
        val ref_id = test_register_refinement(TYPE_I64, "x > 0")
        val neg_val = test_make_int(-5)
        expect(simple_refinement_check(neg_val, ref_id)).to_equal(false)

    it("checks non-negative integer refinement"):
        test_val_reset()
        test_refinement_bases = []
        test_refinement_predicates = []
        val ref_id = test_register_refinement(TYPE_I64, "x >= 0")
        val zero_val = test_make_int(0)
        expect(simple_refinement_check(zero_val, ref_id)).to_equal(true)

    it("checks bounded integer refinement"):
        test_val_reset()
        test_refinement_bases = []
        test_refinement_predicates = []
        val ref_id = test_register_refinement(TYPE_I64, "x < 100")
        val small_val = test_make_int(50)
        expect(simple_refinement_check(small_val, ref_id)).to_equal(true)

    it("rejects out-of-bounds for bounded refinement"):
        test_val_reset()
        test_refinement_bases = []
        test_refinement_predicates = []
        val ref_id = test_register_refinement(TYPE_I64, "x < 100")
        val big_val = test_make_int(150)
        expect(simple_refinement_check(big_val, ref_id)).to_equal(false)

    it("checks non-empty text refinement"):
        test_val_reset()
        test_refinement_bases = []
        test_refinement_predicates = []
        val ref_id = test_register_refinement(TYPE_TEXT, "len(x) > 0")
        val text_val = test_make_text("hello")
        expect(simple_refinement_check(text_val, ref_id)).to_equal(true)

    it("rejects empty text for non-empty refinement"):
        test_val_reset()
        test_refinement_bases = []
        test_refinement_predicates = []
        val ref_id = test_register_refinement(TYPE_TEXT, "len(x) > 0")
        val empty_val = test_make_text("")
        expect(simple_refinement_check(empty_val, ref_id)).to_equal(false)

    it("checks minimum-length array refinement"):
        test_val_reset()
        test_refinement_bases = []
        test_refinement_predicates = []
        val ref_id = test_register_refinement(TYPE_ARRAY_ANY, "len(x) >= 5")
        val arr_val = test_make_array([1, 2, 3, 4, 5])
        expect(simple_refinement_check(arr_val, ref_id)).to_equal(true)

    it("rejects short array for minimum-length refinement"):
        test_val_reset()
        test_refinement_bases = []
        test_refinement_predicates = []
        val ref_id = test_register_refinement(TYPE_ARRAY_ANY, "len(x) >= 5")
        val short_arr = test_make_array([1, 2])
        expect(simple_refinement_check(short_arr, ref_id)).to_equal(false)

    it("accepts value with empty predicate"):
        test_val_reset()
        test_refinement_bases = []
        test_refinement_predicates = []
        val ref_id = test_register_refinement(TYPE_I64, "")
        val int_val = test_make_int(42)
        expect(simple_refinement_check(int_val, ref_id)).to_equal(true)

    it("rejects wrong base type for refinement"):
        test_val_reset()
        test_refinement_bases = []
        test_refinement_predicates = []
        val ref_id = test_register_refinement(TYPE_I64, "x > 0")
        val text_val = test_make_text("not a number")
        expect(simple_refinement_check(text_val, ref_id)).to_equal(false)

describe("Complex Type Scenarios"):
    it("checks union of refinements"):
        test_val_reset()
        test_union_members = []
        test_refinement_bases = []
        test_refinement_predicates = []
        val pos_ref = test_register_refinement(TYPE_I64, "x > 10")
        val pos_val = test_make_int(15)
        expect(simple_refinement_check(pos_val, pos_ref)).to_equal(true)

    it("checks intersection with any type"):
        test_val_reset()
        test_intersection_members = []
        val inter_id = test_register_intersection([TYPE_ANY])
        val val1 = test_make_int(42)
        val val2 = test_make_text("test")
        expect(simple_intersection_check(val1, inter_id)).to_equal(true)
        expect(simple_intersection_check(val2, inter_id)).to_equal(true)

    it("handles multiple type checks on same value"):
        test_val_reset()
        val int_val = test_make_int(42)
        expect(simple_type_check(int_val, TYPE_I64)).to_equal(true)
        expect(simple_type_check(int_val, TYPE_ANY)).to_equal(true)
        expect(simple_type_check(int_val, TYPE_TEXT)).to_equal(false)
        expect(simple_type_check(int_val, TYPE_NIL)).to_equal(false)

    it("validates type checking with multiple values"):
        test_val_reset()
        val v1 = test_make_int(1)
        val v2 = test_make_text("two")
        val v3 = test_make_float(3.0)
        expect(simple_type_check(v1, TYPE_I64)).to_equal(true)
        expect(simple_type_check(v2, TYPE_TEXT)).to_equal(true)
        expect(simple_type_check(v3, TYPE_F64)).to_equal(true)

    it("handles union with all basic types"):
        test_val_reset()
        test_union_members = []
        val union_id = test_register_union([TYPE_NIL, TYPE_BOOL, TYPE_I64, TYPE_F64, TYPE_TEXT])
        val nil_v = test_make_nil()
        val bool_v = test_make_bool(true)
        val int_v = test_make_int(42)
        expect(simple_union_check(nil_v, union_id)).to_equal(true)
        expect(simple_union_check(bool_v, union_id)).to_equal(true)
        expect(simple_union_check(int_v, union_id)).to_equal(true)

    it("validates refinement bounds correctly"):
        test_val_reset()
        test_refinement_bases = []
        test_refinement_predicates = []
        val ref1 = test_register_refinement(TYPE_I64, "x > 0")
        val ref2 = test_register_refinement(TYPE_I64, "x >= 0")
        val zero_val = test_make_int(0)
        expect(simple_refinement_check(zero_val, ref1)).to_equal(false)
        expect(simple_refinement_check(zero_val, ref2)).to_equal(true)
