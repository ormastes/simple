# Basic Type Checking Tests
# Minimal tests for type_checker.spl

use std.spec.{describe, it, expect}

val TYPE_NIL: i64 = 13
val TYPE_BOOL: i64 = 1
val TYPE_I64: i64 = 2
val TYPE_F64: i64 = 3
val TYPE_TEXT: i64 = 4
val TYPE_ANY: i64 = 12

describe "Type Tag Constants":
    it "defines nil type":
        expect(TYPE_NIL).to_equal(13)

    it "defines bool type":
        expect(TYPE_BOOL).to_equal(1)

    it "defines i64 type":
        expect(TYPE_I64).to_equal(2)

    it "defines f64 type":
        expect(TYPE_F64).to_equal(3)

    it "defines text type":
        expect(TYPE_TEXT).to_equal(4)

    it "defines any type":
        expect(TYPE_ANY).to_equal(12)

describe "Union Type Registry":
    it "can register union members":
        var test_union_members: [[i64]] = []
        test_union_members.push([TYPE_I64, TYPE_TEXT])
        expect(test_union_members.len()).to_equal(1)
        expect(test_union_members[0].len()).to_equal(2)

    it "can retrieve union members":
        var test_union_members: [[i64]] = []
        test_union_members.push([TYPE_I64, TYPE_TEXT, TYPE_F64])
        val members = test_union_members[0]
        expect(members[0]).to_equal(TYPE_I64)
        expect(members[1]).to_equal(TYPE_TEXT)
        expect(members[2]).to_equal(TYPE_F64)

describe "Intersection Type Registry":
    it "can register intersection members":
        var test_inter_members: [[i64]] = []
        test_inter_members.push([TYPE_ANY, TYPE_I64])
        expect(test_inter_members.len()).to_equal(1)

    it "can retrieve intersection members":
        var test_inter_members: [[i64]] = []
        test_inter_members.push([TYPE_I64])
        val members = test_inter_members[0]
        expect(members.len()).to_equal(1)
        expect(members[0]).to_equal(TYPE_I64)

describe "Refinement Type Registry":
    it "can register refinement base types":
        var test_ref_bases: [i64] = []
        var test_ref_predicates: [text] = []
        test_ref_bases.push(TYPE_I64)
        test_ref_predicates.push("x > 0")
        expect(test_ref_bases.len()).to_equal(1)
        expect(test_ref_predicates.len()).to_equal(1)

    it "can retrieve refinement predicate":
        var test_ref_bases: [i64] = []
        var test_ref_predicates: [text] = []
        test_ref_bases.push(TYPE_I64)
        test_ref_predicates.push("x > 0")
        val predicate = test_ref_predicates[0]
        expect(predicate).to_equal("x > 0")

    it "can check empty predicate":
        var test_ref_bases: [i64] = []
        var test_ref_predicates: [text] = []
        test_ref_bases.push(TYPE_TEXT)
        test_ref_predicates.push("")
        val predicate = test_ref_predicates[0]
        expect(predicate).to_equal("")

describe "Type Checking Logic":
    it "validates positive integer predicate":
        val value: i64 = 5
        val is_positive = value > 0
        expect(is_positive).to_equal(true)

    it "validates negative integer predicate":
        val value: i64 = -3
        val is_positive = value > 0
        expect(is_positive).to_equal(false)

    it "validates zero for >= 0 predicate":
        val value: i64 = 0
        val is_non_negative = value >= 0
        expect(is_non_negative).to_equal(true)

    it "validates bounded integer":
        val value: i64 = 50
        val is_bounded = value < 100
        expect(is_bounded).to_equal(true)

    it "rejects out of bounds":
        val value: i64 = 150
        val is_bounded = value < 100
        expect(is_bounded).to_equal(false)
