describe "Extensions":
    it "skipped":
        skip("imports compiler modules - causes OOM via numbered directory resolution")

# # Extensions Container Spec
# #
# # Tests for Feature 5: DI Extension Container for Plugins.
# # Verifies that CompileContext.extensions (renamed from di) works as a
# # dynamic extension point for plugin registration.
# 
# # use compiler.di.{DiContainer}
# 
# # Local stub: DiContainer with list-based storage
# class DiContainer:
#     bindings: list
#     singletons: list
#     profile: text
#     all_bindings: list
#     locked: bool
# 
#     fn is_locked() -> bool:
#         self.locked
# 
#     me lock():
#         self.locked = true
# 
#     me unlock():
#         self.locked = false
# 
#     me bind_instance(key: text, value):
#         if self.locked:
#             return nil
#         var new_bindings = []
#         for entry in self.all_bindings:
#             if entry[0] != key:
#                 new_bindings = new_bindings + [entry]
#         new_bindings = new_bindings + [[key, value]]
#         self.all_bindings = new_bindings
# 
#     me bind(key: text, factory):
#         if self.locked:
#             return nil
#         val value = factory()
#         var new_bindings = []
#         for entry in self.all_bindings:
#             if entry[0] != key:
#                 new_bindings = new_bindings + [entry]
#         new_bindings = new_bindings + [[key, value]]
#         self.all_bindings = new_bindings
# 
#     fn has(key: text) -> bool:
#         for entry in self.all_bindings:
#             if entry[0] == key:
#                 return true
#         false
# 
#     fn resolve(key: text):
#         for entry in self.all_bindings:
#             if entry[0] == key:
#                 return entry[1]
#         nil
# 
#     fn resolve_or(key: text, default_val):
#         for entry in self.all_bindings:
#             if entry[0] == key:
#                 return entry[1]
#         default_val
# 
# fn make_extensions() -> DiContainer:
#     DiContainer(bindings: [], singletons: [], profile: "dev", all_bindings: [], locked: false)
# 
# # ---------------------------------------------------------------------------
# # Test Group 1: Basic plugin registration via extensions
# # ---------------------------------------------------------------------------
# 
# describe "Extensions container: plugin registration":
# 
#     it "registers a plugin by name":
#         val ext = make_extensions()
#         ext.bind_instance("Profiler", "profiler-v1")
#         expect(ext.has("Profiler")).to_equal(true)
# 
#     it "resolves a registered plugin":
#         val ext = make_extensions()
#         ext.bind_instance("Formatter", "fmt-plugin")
#         val result = ext.resolve("Formatter")
#         expect(result).to_equal("fmt-plugin")
# 
#     it "returns nil for unregistered plugin via resolve_or":
#         val ext = make_extensions()
#         val result = ext.resolve_or("MissingPlugin", nil)
#         expect(result).to_be_nil()
# 
#     it "returns default for unregistered plugin via resolve_or":
#         val ext = make_extensions()
#         val result = ext.resolve_or("MissingPlugin", "default-value")
#         expect(result).to_equal("default-value")
# 
#     it "registers multiple plugins independently":
#         val ext = make_extensions()
#         ext.bind_instance("PluginA", "a")
#         ext.bind_instance("PluginB", "b")
#         expect(ext.has("PluginA")).to_equal(true)
#         expect(ext.has("PluginB")).to_equal(true)
#         expect(ext.resolve("PluginA")).to_equal("a")
#         expect(ext.resolve("PluginB")).to_equal("b")
# 
#     it "registers numeric plugin values":
#         val ext = make_extensions()
#         ext.bind_instance("MaxWorkers", 4)
#         val result = ext.resolve("MaxWorkers")
#         expect(result).to_equal(4)
# 
# 
# # ---------------------------------------------------------------------------
# # Test Group 2: Extension lock protects against accidental mutation
# # ---------------------------------------------------------------------------
# 
# describe "Extensions container: lock behavior":
# 
#     it "blocks registration when locked":
#         val ext = make_extensions()
#         ext.lock()
#         ext.bind_instance("LockedPlugin", "should-not-register")
#         expect(ext.has("LockedPlugin")).to_equal(false)
# 
#     it "allows registration after unlock":
#         val ext = make_extensions()
#         ext.lock()
#         ext.bind_instance("Temp", "v1")
#         expect(ext.has("Temp")).to_equal(false)
# 
#         ext.unlock()
#         ext.bind_instance("Temp", "v1")
#         expect(ext.has("Temp")).to_equal(true)
# 
#     it "resolve still works when locked":
#         val ext = make_extensions()
#         ext.bind_instance("Logger", "log-plugin")
#         ext.lock()
#         val result = ext.resolve("Logger")
#         expect(result).to_equal("log-plugin")
# 
#     it "is_locked reflects lock state":
#         val ext = make_extensions()
#         expect(ext.is_locked()).to_equal(false)
#         ext.lock()
#         expect(ext.is_locked()).to_equal(true)
#         ext.unlock()
#         expect(ext.is_locked()).to_equal(false)
# 
# 
# # ---------------------------------------------------------------------------
# # Test Group 3: Separation - typed fields vs extensions
# # ---------------------------------------------------------------------------
# 
# describe "Extensions container: separation of concerns":
# 
#     it "extensions container starts empty":
#         val ext = make_extensions()
#         expect(ext.has("Backend")).to_equal(false)
#         expect(ext.has("Logger")).to_equal(false)
#         expect(ext.has("AnyPlugin")).to_equal(false)
# 
#     it "typed backend field is separate from extensions":
#         # Verify extensions does NOT hold the backend (typed field does)
#         val ext = make_extensions()
#         val backend_in_ext = ext.resolve_or("Backend", nil)
#         expect(backend_in_ext).to_be_nil()
# 
#     it "plugin registration does not affect other plugins":
#         val ext = make_extensions()
#         ext.bind_instance("PluginX", "x-value")
#         val other = ext.resolve_or("PluginY", nil)
#         expect(other).to_be_nil()
#         val x_val = ext.resolve("PluginX")
#         expect(x_val).to_equal("x-value")
# 
#     it "factory-bound extension resolves lazily":
#         val ext = make_extensions()
#         ext.bind("LazyPlugin", fn(): "lazy-created")
#         expect(ext.has("LazyPlugin")).to_equal(true)
#         val result = ext.resolve("LazyPlugin")
#         expect(result).to_equal("lazy-created")
