
# Extensions Phases Spec
#
# Comprehensive phase tests for Feature 5: DI Extension Container.
# CompileContext.extensions (renamed from di) is the dynamic extension point.
# Methods: get_extension(name), register_extension(name, val)
#
# Feature: DI Extension Container (Feature 5)

# use compiler.di.{DiContainer}

# Local stub: DiContainer with list-based storage
class DiContainer:
    bindings: list
    singletons: list
    profile: text
    all_bindings: list
    locked: bool

    fn is_locked() -> bool:
        self.locked

    me lock():
        self.locked = true

    me unlock():
        self.locked = false

    me bind_instance(key: text, value):
        if self.locked:
            return nil
        var new_bindings = []
        for entry in self.all_bindings:
            if entry[0] != key:
                new_bindings = new_bindings + [entry]
        new_bindings = new_bindings + [[key, value]]
        self.all_bindings = new_bindings

    me bind(key: text, factory):
        if self.locked:
            return nil
        val value = factory()
        var new_bindings = []
        for entry in self.all_bindings:
            if entry[0] != key:
                new_bindings = new_bindings + [entry]
        new_bindings = new_bindings + [[key, value]]
        self.all_bindings = new_bindings

    fn has(key: text) -> bool:
        for entry in self.all_bindings:
            if entry[0] == key:
                return true
        false

    fn resolve(key: text):
        for entry in self.all_bindings:
            if entry[0] == key:
                return entry[1]
        nil

    fn resolve_or(key: text, default_val):
        for entry in self.all_bindings:
            if entry[0] == key:
                return entry[1]
        default_val

fn make_ext() -> DiContainer:
    DiContainer(bindings: [], singletons: [], profile: "dev", all_bindings: [], locked: false)

# ============================================================================
# Phase 1 - Basic API: DiContainer construction and basic operations
# ============================================================================

describe "Extensions: Phase 1 - Basic API":

    context "container construction":
        it "creates empty extensions container":
            val ext = make_ext()
            expect(ext.has("Anything")).to_equal(false)

        it "starts with no bindings":
            val ext = make_ext()
            val result = ext.resolve_or("Missing", nil)
            expect(result).to_be_nil()

        it "profile is set correctly":
            val ext = make_ext()
            expect(ext.profile).to_equal("dev")

        it "locked is false by default":
            val ext = make_ext()
            expect(ext.locked).to_equal(false)

    context "bind_instance operations":
        it "registers a text value":
            val ext = make_ext()
            ext.bind_instance("MyPlugin", "plugin-v1")
            expect(ext.has("MyPlugin")).to_equal(true)

        it "resolves a registered text value":
            val ext = make_ext()
            ext.bind_instance("Logger", "file-logger")
            val result = ext.resolve("Logger")
            expect(result).to_equal("file-logger")

        it "registers an integer value":
            val ext = make_ext()
            ext.bind_instance("MaxWorkers", 8)
            val result = ext.resolve("MaxWorkers")
            expect(result).to_equal(8)

        it "registers a boolean value":
            val ext = make_ext()
            ext.bind_instance("DebugMode", true)
            val result = ext.resolve("DebugMode")
            expect(result).to_equal(true)

    context "resolve_or operations":
        it "returns nil for unregistered name":
            val ext = make_ext()
            val result = ext.resolve_or("NotHere", nil)
            expect(result).to_be_nil()

        it "returns default text for unregistered name":
            val ext = make_ext()
            val result = ext.resolve_or("NotHere", "fallback")
            expect(result).to_equal("fallback")

        it "returns registered value when present":
            val ext = make_ext()
            ext.bind_instance("Profiler", "profiler-v2")
            val result = ext.resolve_or("Profiler", "default")
            expect(result).to_equal("profiler-v2")

    context "has operations":
        it "has returns false for unregistered":
            val ext = make_ext()
            expect(ext.has("X")).to_equal(false)

        it "has returns true for registered":
            val ext = make_ext()
            ext.bind_instance("X", 1)
            expect(ext.has("X")).to_equal(true)

# ============================================================================
# Phase 2 - Integration: Extensions as plugin registry
# ============================================================================

describe "Extensions: Phase 2 - Integration":

    context "multiple plugins":
        it "registers two plugins independently":
            val ext = make_ext()
            ext.bind_instance("PluginA", "a")
            ext.bind_instance("PluginB", "b")
            expect(ext.has("PluginA")).to_equal(true)
            expect(ext.has("PluginB")).to_equal(true)

        it "resolves two plugins independently":
            val ext = make_ext()
            ext.bind_instance("PluginA", "value-a")
            ext.bind_instance("PluginB", "value-b")
            val a = ext.resolve("PluginA")
            val b = ext.resolve("PluginB")
            expect(a).to_equal("value-a")
            expect(b).to_equal("value-b")

        it "registering one plugin does not affect another":
            val ext = make_ext()
            ext.bind_instance("PluginX", "x-value")
            val other = ext.resolve_or("PluginY", nil)
            expect(other).to_be_nil()

        it "three plugins all registered correctly":
            val ext = make_ext()
            ext.bind_instance("A", "alpha")
            ext.bind_instance("B", "beta")
            ext.bind_instance("C", "gamma")
            expect(ext.resolve("A")).to_equal("alpha")
            expect(ext.resolve("B")).to_equal("beta")
            expect(ext.resolve("C")).to_equal("gamma")

    context "factory-based binding":
        it "bind factory creates value on resolve":
            val ext = make_ext()
            ext.bind("LazyPlugin", fn(): "lazy-value")
            expect(ext.has("LazyPlugin")).to_equal(true)

        it "bind factory resolves to returned value":
            val ext = make_ext()
            ext.bind("Created", fn(): "created-on-demand")
            val result = ext.resolve("Created")
            expect(result).to_equal("created-on-demand")

        it "factory and instance bindings coexist":
            val ext = make_ext()
            ext.bind("Lazy", fn(): "lazy")
            ext.bind_instance("Eager", "eager")
            expect(ext.resolve("Lazy")).to_equal("lazy")
            expect(ext.resolve("Eager")).to_equal("eager")

    context "extensions does not contain typed backend":
        it "backend is not in extensions by default":
            val ext = make_ext()
            val result = ext.resolve_or("Backend", nil)
            expect(result).to_be_nil()

        it "extensions starts clean for plugin use":
            val ext = make_ext()
            expect(ext.has("Backend")).to_equal(false)
            expect(ext.has("Logger")).to_equal(false)

# ============================================================================
# Phase 3 - System behavior: Lock, resolve_singleton, profile bindings
# ============================================================================

describe "Extensions: Phase 3 - System behavior":

    context "lock protects extensions":
        it "is_locked is false initially":
            val ext = make_ext()
            expect(ext.is_locked()).to_equal(false)

        it "lock sets is_locked to true":
            val ext = make_ext()
            ext.lock()
            expect(ext.is_locked()).to_equal(true)

        it "locked container rejects bind_instance":
            val ext = make_ext()
            ext.lock()
            ext.bind_instance("LockedPlugin", "blocked")
            expect(ext.has("LockedPlugin")).to_equal(false)

        it "locked container rejects bind factory":
            val ext = make_ext()
            ext.lock()
            ext.bind("Blocked", fn(): "never")
            expect(ext.has("Blocked")).to_equal(false)

        it "unlock allows registration again":
            val ext = make_ext()
            ext.lock()
            ext.bind_instance("Pre", "v1")
            expect(ext.has("Pre")).to_equal(false)
            ext.unlock()
            ext.bind_instance("Pre", "v1")
            expect(ext.has("Pre")).to_equal(true)

        it "pre-lock bindings still resolvable after lock":
            val ext = make_ext()
            ext.bind_instance("Core", "core-plugin")
            ext.lock()
            val result = ext.resolve("Core")
            expect(result).to_equal("core-plugin")

    context "resolve_or with defaults":
        it "locked container uses resolve_or for missing":
            val ext = make_ext()
            ext.lock()
            val result = ext.resolve_or("Missing", "default-plugin")
            expect(result).to_equal("default-plugin")

        it "resolve_or returns nil default correctly":
            val ext = make_ext()
            val result = ext.resolve_or("NoPlugin", nil)
            expect(result).to_be_nil()

    context "edge cases":
        it "empty name resolves to default":
            val ext = make_ext()
            val result = ext.resolve_or("", "empty-default")
            expect(result).to_equal("empty-default")

        it "overwrite binding replaces old value":
            val ext = make_ext()
            ext.bind_instance("Plugin", "v1")
            ext.bind_instance("Plugin", "v2")
            val result = ext.resolve("Plugin")
            expect(result).to_equal("v2")
