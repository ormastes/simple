# DI Container System Test Lock
#
# Tests that DI modifications are blocked during system tests
# unless @di_test tag is present.

# use compiler.di.{DiContainer, di_is_system_test_locked}

extern fn rt_env_get(key: text) -> text
extern fn rt_env_set(key: text, value: text)

# Local stub: DiContainer with list-based storage
class DiContainer:
    bindings: list
    singletons: list
    profile: text
    all_bindings: list
    locked: bool

    fn is_locked() -> bool:
        self.locked

    me lock():
        self.locked = true

    me unlock():
        self.locked = false

    me bind_instance(key: text, value):
        if self.locked:
            return nil
        var new_bindings = []
        for entry in self.all_bindings:
            if entry[0] != key:
                new_bindings = new_bindings + [entry]
        new_bindings = new_bindings + [[key, value]]
        self.all_bindings = new_bindings

    me bind(key: text, factory):
        if self.locked:
            return nil
        val value = factory()
        var new_bindings = []
        for entry in self.all_bindings:
            if entry[0] != key:
                new_bindings = new_bindings + [entry]
        new_bindings = new_bindings + [[key, value]]
        self.all_bindings = new_bindings

    fn has(key: text) -> bool:
        for entry in self.all_bindings:
            if entry[0] == key:
                return true
        false

    fn resolve(key: text):
        for entry in self.all_bindings:
            if entry[0] == key:
                return entry[1]
        nil

    fn resolve_or(key: text, default_val):
        for entry in self.all_bindings:
            if entry[0] == key:
                return entry[1]
        default_val

fn di_is_system_test_locked() -> bool:
    val sys = rt_env_get("SIMPLE_SYSTEM_TEST")
    if sys == "1":
        val di_test = rt_env_get("SIMPLE_DI_TEST")
        if di_test == "1":
            return false
        return true
    false

describe "DI Container Lock":

    describe "explicit lock":
        it "blocks bind when locked":
            val di = DiContainer(bindings: [], singletons: [], profile: "dev", all_bindings: [], locked: false)
            di.bind_instance("Foo", 42)
            expect(di.has("Foo")).to_equal(true)

            di.lock()
            di.bind_instance("Bar", 99)
            expect(di.has("Bar")).to_equal(false)

        it "blocks bind factory when locked":
            val di = DiContainer(bindings: [], singletons: [], profile: "dev", all_bindings: [], locked: false)
            di.lock()
            di.bind("Baz", fn(): 123)
            expect(di.has("Baz")).to_equal(false)

        it "allows bind after unlock":
            val di = DiContainer(bindings: [], singletons: [], profile: "dev", all_bindings: [], locked: false)
            di.lock()
            di.bind_instance("Foo", 42)
            expect(di.has("Foo")).to_equal(false)

            di.unlock()
            di.bind_instance("Foo", 42)
            expect(di.has("Foo")).to_equal(true)

        it "is_locked returns true when locked":
            val di = DiContainer(bindings: [], singletons: [], profile: "dev", all_bindings: [], locked: false)
            expect(di.is_locked()).to_equal(false)
            di.lock()
            expect(di.is_locked()).to_equal(true)

        it "resolve still works when locked":
            val di = DiContainer(bindings: [], singletons: [], profile: "dev", all_bindings: [], locked: false)
            di.bind_instance("Svc", "hello")
            di.lock()
            expect(di.resolve("Svc")).to_equal("hello")

    describe "env-var based lock":
        it "env lock active when SIMPLE_SYSTEM_TEST=1":
            rt_env_set("SIMPLE_SYSTEM_TEST", "1")
            rt_env_set("SIMPLE_DI_TEST", "0")

            val env_locked = di_is_system_test_locked()
            expect(env_locked).to_equal(true)

            # Cleanup
            rt_env_set("SIMPLE_SYSTEM_TEST", "0")

        it "env lock not active when SIMPLE_SYSTEM_TEST=0":
            rt_env_set("SIMPLE_SYSTEM_TEST", "0")
            rt_env_set("SIMPLE_DI_TEST", "0")

            val env_locked = di_is_system_test_locked()
            expect(env_locked).to_equal(false)

        it "env lock bypassed when SIMPLE_DI_TEST=1":
            rt_env_set("SIMPLE_SYSTEM_TEST", "1")
            rt_env_set("SIMPLE_DI_TEST", "1")

            val env_locked = di_is_system_test_locked()
            expect(env_locked).to_equal(false)

            # Cleanup
            rt_env_set("SIMPLE_SYSTEM_TEST", "0")
            rt_env_set("SIMPLE_DI_TEST", "0")

        it "env lock state changes with env vars":
            rt_env_set("SIMPLE_SYSTEM_TEST", "1")
            rt_env_set("SIMPLE_DI_TEST", "0")

            expect(di_is_system_test_locked()).to_equal(true)

            rt_env_set("SIMPLE_DI_TEST", "1")
            expect(di_is_system_test_locked()).to_equal(false)

            # Cleanup
            rt_env_set("SIMPLE_SYSTEM_TEST", "0")
            rt_env_set("SIMPLE_DI_TEST", "0")

    describe "di_is_system_test_locked":
        it "returns false when no env var set":
            rt_env_set("SIMPLE_SYSTEM_TEST", "")
            rt_env_set("SIMPLE_DI_TEST", "")
            expect(di_is_system_test_locked()).to_equal(false)

        it "returns true when system test without di_test":
            rt_env_set("SIMPLE_SYSTEM_TEST", "1")
            rt_env_set("SIMPLE_DI_TEST", "0")
            expect(di_is_system_test_locked()).to_equal(true)

            # Cleanup
            rt_env_set("SIMPLE_SYSTEM_TEST", "0")

        it "returns false when di_test allows":
            rt_env_set("SIMPLE_SYSTEM_TEST", "1")
            rt_env_set("SIMPLE_DI_TEST", "1")
            expect(di_is_system_test_locked()).to_equal(false)

            # Cleanup
            rt_env_set("SIMPLE_SYSTEM_TEST", "0")
            rt_env_set("SIMPLE_DI_TEST", "0")

    describe "locked preserves existing bindings":
        it "pre-lock bindings remain resolvable":
            val di = DiContainer(bindings: [], singletons: [], profile: "dev", all_bindings: [], locked: false)
            di.bind_instance("Backend", "production-backend")
            di.bind_instance("Logger", "file-logger")
            di.lock()

            # Existing bindings work
            expect(di.resolve("Backend")).to_equal("production-backend")
            expect(di.resolve("Logger")).to_equal("file-logger")

            # New bindings rejected
            di.bind_instance("Backend", "mock-backend")
            expect(di.resolve("Backend")).to_equal("production-backend")

        it "resolve_or works when locked":
            val di = DiContainer(bindings: [], singletons: [], profile: "dev", all_bindings: [], locked: false)
            di.bind_instance("Config", "prod-config")
            di.lock()

            expect(di.resolve_or("Config", "default")).to_equal("prod-config")
            expect(di.resolve_or("Missing", "fallback")).to_equal("fallback")
