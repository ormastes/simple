# Transform Adapter Tests
#
# Tests that transform adapter structs construct correctly and that
# their instance methods return the expected values.
#
# Adapters tested:
#   - TypedAstContext  (typing_to_hir/entity_view/TypedAstView.spl)
#   - CfgContext       (hir_to_mir/entity_view/HirView.spl)
#   - MirProgram       (mir_to_backend/entity_view/MirView.spl)
#   - MirDebugInfo     (mir_to_backend/entity_view/MirView.spl)

use compiler.transform.feature.typing_to_hir.entity_view.TypedAstView.{TypedAstContext}
use compiler.transform.feature.hir_to_mir.entity_view.HirView.{CfgContext}
use compiler.transform.feature.mir_to_backend.entity_view.MirView.{MirProgram, MirDebugInfo}

# ============================================================================
# TypedAstContext
# ============================================================================

describe "TypedAstContext":
    it "constructs empty context via static factory":
        val ctx = TypedAstContext.empty()
        expect(ctx.ast_decl_count).to_equal(0)
        expect(ctx.symbol_count).to_equal(0)
        expect(ctx.inferred_type_count).to_equal(0)

    it "empty context has no types":
        val ctx = TypedAstContext.empty()
        expect(ctx.has_types()).to_equal(false)

    it "empty context has no symbols":
        val ctx = TypedAstContext.empty()
        expect(ctx.has_symbols()).to_equal(false)

    it "empty module name is empty string":
        val ctx = TypedAstContext.empty()
        expect(ctx.module_name).to_equal("")

    it "constructs with data and detects types":
        val ctx = TypedAstContext(
            ast_decl_count: 5,
            symbol_count: 3,
            inferred_type_count: 8,
            module_name: "test"
        )
        expect(ctx.has_types()).to_equal(true)

    it "constructs with data and detects symbols":
        val ctx = TypedAstContext(
            ast_decl_count: 5,
            symbol_count: 3,
            inferred_type_count: 8,
            module_name: "test"
        )
        expect(ctx.has_symbols()).to_equal(true)

    it "stores module name":
        val ctx = TypedAstContext(
            ast_decl_count: 5,
            symbol_count: 3,
            inferred_type_count: 8,
            module_name: "test"
        )
        expect(ctx.module_name).to_equal("test")

    it "stores decl count":
        val ctx = TypedAstContext(
            ast_decl_count: 5,
            symbol_count: 3,
            inferred_type_count: 8,
            module_name: "test"
        )
        expect(ctx.ast_decl_count).to_equal(5)

    it "zero inferred types means no types":
        val ctx = TypedAstContext(
            ast_decl_count: 2,
            symbol_count: 0,
            inferred_type_count: 0,
            module_name: "empty_types"
        )
        expect(ctx.has_types()).to_equal(false)

    it "zero symbols means no symbols":
        val ctx = TypedAstContext(
            ast_decl_count: 2,
            symbol_count: 0,
            inferred_type_count: 5,
            module_name: "no_syms"
        )
        expect(ctx.has_symbols()).to_equal(false)

# ============================================================================
# CfgContext
# ============================================================================

describe "CfgContext":
    it "creates context for function via static factory":
        val ctx = CfgContext.for_function("main")
        expect(ctx.current_fn_name).to_equal("main")

    it "for_function starts with zero loop depth":
        val ctx = CfgContext.for_function("main")
        expect(ctx.loop_depth).to_equal(0)

    it "for_function is not in loop":
        val ctx = CfgContext.for_function("main")
        expect(ctx.in_loop()).to_equal(false)

    it "for_function sets entry block label":
        val ctx = CfgContext.for_function("main")
        expect(ctx.current_block_label).to_equal("entry")

    it "for_function has empty break stack":
        val ctx = CfgContext.for_function("main")
        expect(ctx.current_break_label()).to_equal("")

    it "for_function has empty continue stack":
        val ctx = CfgContext.for_function("main")
        expect(ctx.current_continue_label()).to_equal("")

    it "constructs with loop depth":
        val ctx = CfgContext(
            current_fn_name: "foo",
            loop_depth: 2,
            current_block_label: "loop_body",
            break_label_stack: ["loop_end_0", "loop_end_1"],
            continue_label_stack: ["loop_start_0", "loop_start_1"]
        )
        expect(ctx.in_loop()).to_equal(true)
        expect(ctx.loop_depth).to_equal(2)

    it "reports current break label from stack top":
        val ctx = CfgContext(
            current_fn_name: "foo",
            loop_depth: 2,
            current_block_label: "loop_body",
            break_label_stack: ["loop_end_0", "loop_end_1"],
            continue_label_stack: ["loop_start_0", "loop_start_1"]
        )
        expect(ctx.current_break_label()).to_equal("loop_end_1")

    it "reports current continue label from stack top":
        val ctx = CfgContext(
            current_fn_name: "foo",
            loop_depth: 2,
            current_block_label: "loop_body",
            break_label_stack: ["loop_end_0", "loop_end_1"],
            continue_label_stack: ["loop_start_0", "loop_start_1"]
        )
        expect(ctx.current_continue_label()).to_equal("loop_start_1")

    it "loop_depth 1 is in loop":
        val ctx = CfgContext(
            current_fn_name: "bar",
            loop_depth: 1,
            current_block_label: "loop_body",
            break_label_stack: ["end"],
            continue_label_stack: ["start"]
        )
        expect(ctx.in_loop()).to_equal(true)

    it "stores function name":
        val ctx = CfgContext.for_function("process_items")
        expect(ctx.current_fn_name).to_equal("process_items")

# ============================================================================
# MirProgram - first struct in mir_to_backend/entity_view/MirView.spl
# ============================================================================

describe "MirProgram":
    it "creates empty program via static factory":
        val prog = MirProgram.empty()
        expect(prog.function_count).to_equal(0)

    it "empty program has no functions":
        val prog = MirProgram.empty()
        expect(prog.has_functions()).to_equal(false)

    it "empty program has no extern fns":
        val prog = MirProgram.empty()
        expect(prog.has_extern_fns()).to_equal(false)

    it "empty program uses interpreter target triple":
        val prog = MirProgram.empty()
        expect(prog.target_triple).to_equal("interpreter-simple-runtime")

    it "empty program has zero string literals":
        val prog = MirProgram.empty()
        expect(prog.string_literal_count).to_equal(0)

    it "constructs with functions":
        val prog = MirProgram(
            function_count: 2,
            extern_fn_names: [],
            string_literal_count: 0,
            target_triple: "x86_64-linux-gnu"
        )
        expect(prog.has_functions()).to_equal(true)
        expect(prog.function_count).to_equal(2)

    it "constructs with extern functions":
        val prog = MirProgram(
            function_count: 2,
            extern_fn_names: ["printf", "malloc"],
            string_literal_count: 3,
            target_triple: "x86_64-linux-gnu"
        )
        expect(prog.has_extern_fns()).to_equal(true)

    it "stores target triple":
        val prog = MirProgram(
            function_count: 1,
            extern_fn_names: [],
            string_literal_count: 0,
            target_triple: "aarch64-linux-gnu"
        )
        expect(prog.target_triple).to_equal("aarch64-linux-gnu")

    it "stores string literal count":
        val prog = MirProgram(
            function_count: 1,
            extern_fn_names: [],
            string_literal_count: 7,
            target_triple: "x86_64-linux-gnu"
        )
        expect(prog.string_literal_count).to_equal(7)

    it "no functions returns false for has_functions":
        val prog = MirProgram(
            function_count: 0,
            extern_fn_names: [],
            string_literal_count: 0,
            target_triple: "x86_64-linux-gnu"
        )
        expect(prog.has_functions()).to_equal(false)

    it "empty extern names returns false for has_extern_fns":
        val prog = MirProgram(
            function_count: 1,
            extern_fn_names: [],
            string_literal_count: 0,
            target_triple: "x86_64-linux-gnu"
        )
        expect(prog.has_extern_fns()).to_equal(false)

# ============================================================================
# MirDebugInfo - second struct in mir_to_backend/entity_view/MirView.spl
# ============================================================================

describe "MirDebugInfo":
    it "constructs with source file info":
        val dbg = MirDebugInfo(
            fn_source_files: ["main.spl", "lib.spl"],
            fn_start_lines: [1, 10]
        )
        expect(dbg.fn_start_lines[0]).to_equal(1)
        expect(dbg.fn_start_lines[1]).to_equal(10)

    it "constructs with empty debug info":
        val dbg = MirDebugInfo(
            fn_source_files: [],
            fn_start_lines: []
        )
        expect(dbg.fn_source_files.len()).to_equal(0)
