# Feature: BlockDefinition Three-Level Interface
# Feature ID: #1091
# Category: Compiler
# Status: In Progress
# Priority: P0
#
# ## Overview
#
# The BlockDefinition trait now exposes 3 levels of parsing:
# 1. **lex()**: Sub-lexer producing block-specific tokens
# 2. **treesitter_outline()**: Fast structural extraction for IDE
# 3. **parse_full()**: Full parse using pre-lex info
#
# All methods have backward-compatible defaults so existing blocks work unchanged.
#
# ## Syntax
#
# ```simple
# trait BlockDefinition:
# fn lex(payload, pre_lex, ctx) -> Result<[BlockToken], BlockError>       # Default: Ok([])
# fn treesitter_outline(payload, pre_lex) -> BlockOutlineInfo              # Default: opaque
# fn parse_full(payload, pre_lex, ctx) -> Result<BlockValue, BlockError>   # Default: delegates to parse_payload
# fn skip_policy() -> BlockSkipPolicy                                      # Default: Skippable
# ```
use compiler.blocks.modes.{PreLexInfo, BlockSkipPolicy, BlockOutlineInfo, BlockToken, BlockTokenKind, TextSpan}
use compiler.blocks.context.{BlockContext, BlockError}
use compiler.blocks.builtin_blocks_defs.{MathBlockDef, ShellBlockDef, SqlBlockDef, RegexBlockDef, JsonBlockDef, MarkdownBlockDef, LossBlockDef, NogradBlockDef}

# ============================================================================
# Default Method Behavior (Backward Compatibility)
# ============================================================================

describe "BlockDefinition defaults - lex()":
    it "ShellBlockDef returns empty tokens":
        val block = ShellBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("ls -la")
        val result = block.lex("ls -la", pre_lex, ctx)
        expect(result.ok.?).to_be_true()
        expect(result.unwrap().len()).to_equal(0)

    it "SqlBlockDef returns empty tokens":
        val block = SqlBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("SELECT 1")
        val result = block.lex("SELECT 1", pre_lex, ctx)
        expect(result.ok.?).to_be_true()
        expect(result.unwrap().len()).to_equal(0)

    it "RegexBlockDef returns empty tokens":
        val block = RegexBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("[a-z]+")
        val result = block.lex("[a-z]+", pre_lex, ctx)
        expect(result.ok.?).to_be_true()
        expect(result.unwrap().len()).to_equal(0)

    it "JsonBlockDef returns empty tokens":
        val block = JsonBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("{}")
        val result = block.lex("{}", pre_lex, ctx)
        expect(result.ok.?).to_be_true()
        expect(result.unwrap().len()).to_equal(0)

    it "MarkdownBlockDef returns empty tokens":
        val block = MarkdownBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("# hello")
        val result = block.lex("# hello", pre_lex, ctx)
        expect(result.ok.?).to_be_true()
        expect(result.unwrap().len()).to_equal(0)

    it "LossBlockDef returns empty tokens":
        val block = LossBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("mse(x, y)")
        val result = block.lex("mse(x, y)", pre_lex, ctx)
        expect(result.ok.?).to_be_true()
        expect(result.unwrap().len()).to_equal(0)

    it "NogradBlockDef returns empty tokens":
        val block = NogradBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("model(x)")
        val result = block.lex("model(x)", pre_lex, ctx)
        expect(result.ok.?).to_be_true()
        expect(result.unwrap().len()).to_equal(0)

describe "BlockDefinition defaults - treesitter_outline()":
    it "ShellBlockDef returns opaque":
        val block = ShellBlockDef()
        val info = block.treesitter_outline("ls -la", PreLexInfo.empty())
        expect(info.is_opaque).to_be_true()
        expect(info.kind).to_equal("sh")
        expect(info.identifiers.len()).to_equal(0)
        expect(info.external_refs.len()).to_equal(0)
        expect(info.structure_kind).to_equal(nil)

    it "SqlBlockDef returns opaque":
        val block = SqlBlockDef()
        val info = block.treesitter_outline("SELECT 1", PreLexInfo.empty())
        expect(info.is_opaque).to_be_true()
        expect(info.kind).to_equal("sql")

    it "RegexBlockDef returns opaque":
        val block = RegexBlockDef()
        val info = block.treesitter_outline("[a-z]+", PreLexInfo.empty())
        expect(info.is_opaque).to_be_true()
        expect(info.kind).to_equal("re")

    it "JsonBlockDef returns opaque":
        val block = JsonBlockDef()
        val info = block.treesitter_outline("{}", PreLexInfo.empty())
        expect(info.is_opaque).to_be_true()
        expect(info.kind).to_equal("json")

    it "MarkdownBlockDef returns opaque":
        val block = MarkdownBlockDef()
        val info = block.treesitter_outline("# Heading", PreLexInfo.empty())
        expect(info.is_opaque).to_be_true()
        expect(info.kind).to_equal("md")

    it "LossBlockDef returns opaque":
        val block = LossBlockDef()
        val info = block.treesitter_outline("mse(x, y)", PreLexInfo.empty())
        expect(info.is_opaque).to_be_true()
        expect(info.kind).to_equal("loss")

    it "NogradBlockDef returns opaque":
        val block = NogradBlockDef()
        val info = block.treesitter_outline("model(x)", PreLexInfo.empty())
        expect(info.is_opaque).to_be_true()
        expect(info.kind).to_equal("nograd")

describe "BlockDefinition defaults - parse_full()":
    it "ShellBlockDef delegates to parse_payload":
        val block = ShellBlockDef()
        val ctx = BlockContext.test("ls -la")
        val pre_lex = PreLexInfo.empty()
        val result = block.parse_full("ls -la", pre_lex, ctx)
        expect(result.ok.?).to_be_true()

    it "SqlBlockDef delegates to parse_payload":
        val block = SqlBlockDef()
        val ctx = BlockContext.test("SELECT 1")
        val pre_lex = PreLexInfo.empty()
        val result = block.parse_full("SELECT 1", pre_lex, ctx)
        expect(result.ok.?).to_be_true()

    it "JsonBlockDef delegates to parse_payload":
        val block = JsonBlockDef()
        val ctx = BlockContext.test("{\"key\": 1}")
        val pre_lex = PreLexInfo.empty()
        val result = block.parse_full("{\"key\": 1}", pre_lex, ctx)
        expect(result.ok.?).to_be_true()

    it "MarkdownBlockDef delegates to parse_payload":
        val block = MarkdownBlockDef()
        val ctx = BlockContext.test("# Hello")
        val pre_lex = PreLexInfo.empty()
        val result = block.parse_full("# Hello", pre_lex, ctx)
        expect(result.ok.?).to_be_true()

    it "empty payload returns error for ShellBlockDef":
        val block = ShellBlockDef()
        val ctx = BlockContext.test("")
        val pre_lex = PreLexInfo.empty()
        val result = block.parse_full("", pre_lex, ctx)
        expect(result.err.?).to_be_true()

    it "empty payload returns error for SqlBlockDef":
        val block = SqlBlockDef()
        val ctx = BlockContext.test("")
        val pre_lex = PreLexInfo.empty()
        val result = block.parse_full("", pre_lex, ctx)
        expect(result.err.?).to_be_true()

    it "whitespace-only payload returns error for ShellBlockDef":
        val block = ShellBlockDef()
        val ctx = BlockContext.test("   ")
        val pre_lex = PreLexInfo.empty()
        val result = block.parse_full("   ", pre_lex, ctx)
        expect(result.err.?).to_be_true()

describe "BlockDefinition defaults - skip_policy()":
    it "ShellBlockDef defaults to Skippable":
        expect(ShellBlockDef().skip_policy()).to_equal(BlockSkipPolicy.Skippable)

    it "SqlBlockDef defaults to Skippable":
        expect(SqlBlockDef().skip_policy()).to_equal(BlockSkipPolicy.Skippable)

    it "RegexBlockDef defaults to Skippable":
        expect(RegexBlockDef().skip_policy()).to_equal(BlockSkipPolicy.Skippable)

    it "JsonBlockDef defaults to Skippable":
        expect(JsonBlockDef().skip_policy()).to_equal(BlockSkipPolicy.Skippable)

    it "MarkdownBlockDef defaults to Skippable":
        expect(MarkdownBlockDef().skip_policy()).to_equal(BlockSkipPolicy.Skippable)

    it "LossBlockDef defaults to Skippable":
        expect(LossBlockDef().skip_policy()).to_equal(BlockSkipPolicy.Skippable)

    it "NogradBlockDef defaults to Skippable":
        expect(NogradBlockDef().skip_policy()).to_equal(BlockSkipPolicy.Skippable)

# ============================================================================
# Math Block Reference Implementation
# ============================================================================

describe "MathBlockDef - lex()":
    it "tokenizes simple expression":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("x + y")
        val result = block.lex("x + y", pre_lex, ctx)
        expect(result.ok.?).to_be_true()
        val tokens = result.unwrap()
        expect(tokens.len()).to_be_greater_than(0)

    it "produces Identifier tokens for variables":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("x")
        val tokens = block.lex("x", pre_lex, ctx).unwrap()
        val ident_tokens = tokens.filter(\t: t.kind == BlockTokenKind.Identifier)
        expect(ident_tokens.len()).to_be_greater_than_or_equal_to(1)
        expect(ident_tokens[0].value).to_equal("x")

    it "produces Number tokens for numeric literals":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("42")
        val tokens = block.lex("42", pre_lex, ctx).unwrap()
        val num_tokens = tokens.filter(\t: t.kind == BlockTokenKind.Number)
        expect(num_tokens.len()).to_equal(1)
        expect(num_tokens[0].value).to_equal("42")

    it "produces Operator tokens for ^":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("x^2")
        val tokens = block.lex("x^2", pre_lex, ctx).unwrap()
        val op_tokens = tokens.filter(\t: t.kind == BlockTokenKind.Operator)
        expect(op_tokens.len()).to_be_greater_than_or_equal_to(1)
        expect(op_tokens[0].value).to_equal("^")

    it "produces Operator tokens for all math operators":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("a + b - c * d / e ^ f @ g")
        val tokens = block.lex("a + b - c * d / e ^ f @ g", pre_lex, ctx).unwrap()
        val op_tokens = tokens.filter(\t: t.kind == BlockTokenKind.Operator)
        # Should find +, -, *, /, ^, @
        expect(op_tokens.len()).to_equal(6)

    it "produces Punctuation tokens for parens and commas":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("f(a, b)")
        val tokens = block.lex("f(a, b)", pre_lex, ctx).unwrap()
        val punct_tokens = tokens.filter(\t: t.kind == BlockTokenKind.Punctuation)
        # Should find (, comma, )
        expect(punct_tokens.len()).to_equal(3)

    it "produces Whitespace tokens":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("x + y")
        val tokens = block.lex("x + y", pre_lex, ctx).unwrap()
        val ws_tokens = tokens.filter(\t: t.kind == BlockTokenKind.Whitespace)
        expect(ws_tokens.len()).to_be_greater_than(0)

    it "handles empty payload":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("")
        val tokens = block.lex("", pre_lex, ctx).unwrap()
        expect(tokens.len()).to_equal(0)

    it "handles numeric literals with decimal point":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("3.14")
        val tokens = block.lex("3.14", pre_lex, ctx).unwrap()
        val num_tokens = tokens.filter(\t: t.kind == BlockTokenKind.Number)
        expect(num_tokens.len()).to_equal(1)
        expect(num_tokens[0].value).to_equal("3.14")

    it "handles underscore in identifiers":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("x_1 + y_2")
        val tokens = block.lex("x_1 + y_2", pre_lex, ctx).unwrap()
        val ident_tokens = tokens.filter(\t: t.kind == BlockTokenKind.Identifier)
        expect(ident_tokens.len()).to_equal(2)
        expect(ident_tokens[0].value).to_equal("x_1")
        expect(ident_tokens[1].value).to_equal("y_2")

    it "skips positions inside pre-scanned comments":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [],
            comment_spans: [TextSpan.new(4, 13)],
            escape_positions: [], brace_pairs: []
        )
        val ctx = BlockContext.test("x + # comment\ny")
        val tokens = block.lex("x + # comment\ny", pre_lex, ctx).unwrap()
        val comment_tokens = tokens.filter(\t: t.kind == BlockTokenKind.Comment)
        expect(comment_tokens.len()).to_be_greater_than_or_equal_to(1)

    it "token spans are correct":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("abc")
        val tokens = block.lex("abc", pre_lex, ctx).unwrap()
        val ident = tokens.filter(\t: t.kind == BlockTokenKind.Identifier)[0]
        expect(ident.span.start).to_equal(0)
        expect(ident.span.end).to_equal(3)
        expect(ident.span.len()).to_equal(3)

    it "complex expression produces correct token sequence":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("sin(x^2)")
        val tokens = block.lex("sin(x^2)", pre_lex, ctx).unwrap()
        # sin ( x ^ 2 )
        val non_ws = tokens.filter(\t: t.kind != BlockTokenKind.Whitespace)
        expect(non_ws.len()).to_equal(6)
        expect(non_ws[0].kind).to_equal(BlockTokenKind.Identifier)   # sin
        expect(non_ws[0].value).to_equal("sin")
        expect(non_ws[1].kind).to_equal(BlockTokenKind.Punctuation)  # (
        expect(non_ws[2].kind).to_equal(BlockTokenKind.Identifier)   # x
        expect(non_ws[3].kind).to_equal(BlockTokenKind.Operator)     # ^
        expect(non_ws[4].kind).to_equal(BlockTokenKind.Number)       # 2
        expect(non_ws[5].kind).to_equal(BlockTokenKind.Punctuation)  # )

# ============================================================================
# Math Block - treesitter_outline()
# ============================================================================

describe "MathBlockDef - treesitter_outline()":
    it "extracts single variable":
        val block = MathBlockDef()
        val info = block.treesitter_outline("x", PreLexInfo.empty())
        expect(info.identifiers).to_contain("x")
        expect(info.is_opaque).to_be_false()

    it "extracts multiple variables":
        val block = MathBlockDef()
        val info = block.treesitter_outline("x^2 + 2*x*y + y^2", PreLexInfo.empty())
        expect(info.identifiers).to_contain("x")
        expect(info.identifiers).to_contain("y")

    it "deduplicates identifiers":
        val block = MathBlockDef()
        val info = block.treesitter_outline("x + x + x + x", PreLexInfo.empty())
        expect(info.identifiers.len()).to_equal(1)

    it "extracts function names":
        val block = MathBlockDef()
        val info = block.treesitter_outline("sin(x) + cos(y) + tan(z)", PreLexInfo.empty())
        expect(info.identifiers).to_contain("sin")
        expect(info.identifiers).to_contain("cos")
        expect(info.identifiers).to_contain("tan")
        expect(info.identifiers).to_contain("x")
        expect(info.identifiers).to_contain("y")
        expect(info.identifiers).to_contain("z")

    it "does not extract numbers as identifiers":
        val block = MathBlockDef()
        val info = block.treesitter_outline("2*x + 3.14", PreLexInfo.empty())
        expect(info.identifiers).to_contain("x")
        expect(info.identifiers).not_to_contain("2")
        expect(info.identifiers).not_to_contain("3")

    it "extracts identifiers with underscores":
        val block = MathBlockDef()
        val info = block.treesitter_outline("x_1 + y_max", PreLexInfo.empty())
        expect(info.identifiers).to_contain("x_1")
        expect(info.identifiers).to_contain("y_max")

    it "reports structure_kind as expression":
        val block = MathBlockDef()
        val info = block.treesitter_outline("x + y", PreLexInfo.empty())
        expect(info.structure_kind).to_equal(Some("expression"))

    it "reports kind as m":
        val block = MathBlockDef()
        val info = block.treesitter_outline("x", PreLexInfo.empty())
        expect(info.kind).to_equal("m")

    it "returns empty identifiers for numbers-only expression":
        val block = MathBlockDef()
        val info = block.treesitter_outline("1 + 2 + 3", PreLexInfo.empty())
        expect(info.identifiers.len()).to_equal(0)

    it "returns empty identifiers for empty payload":
        val block = MathBlockDef()
        val info = block.treesitter_outline("", PreLexInfo.empty())
        expect(info.identifiers.len()).to_equal(0)

    it "skips identifiers inside protected regions":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [TextSpan.new(0, 10)],
            comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        # "hidden_var" is inside a string span, should be skipped
        val info = block.treesitter_outline("hidden_var + visible", pre_lex)
        expect(info.identifiers).not_to_contain("hidden_var")
        expect(info.identifiers).to_contain("visible")

    it "skips identifiers inside comment regions":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [],
            comment_spans: [TextSpan.new(5, 20)],
            escape_positions: [], brace_pairs: []
        )
        # "x + # commented_var\ny" -> commented_var is in comment
        val info = block.treesitter_outline("x + # commented_var\ny", pre_lex)
        expect(info.identifiers).to_contain("x")
        expect(info.identifiers).to_contain("y")

    it "external_refs is empty for math":
        val block = MathBlockDef()
        val info = block.treesitter_outline("x + y", PreLexInfo.empty())
        expect(info.external_refs.len()).to_equal(0)

# ============================================================================
# Math Block - parse_full() and skip_policy()
# ============================================================================

describe "MathBlockDef - parse_full()":
    it "succeeds with simple expression":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("x^2")
        val result = block.parse_full("x^2", pre_lex, ctx)
        expect(result.ok.?).to_be_true()

    it "succeeds with complex expression":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("sin(x)^2 + cos(x)^2")
        val result = block.parse_full("sin(x)^2 + cos(x)^2", pre_lex, ctx)
        expect(result.ok.?).to_be_true()

    it "succeeds with pre_lex info provided":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [],
            comment_spans: [],
            escape_positions: [],
            brace_pairs: [(4, 10)]
        )
        val ctx = BlockContext.test("f = {a + b}")
        val result = block.parse_full("f = {a + b}", pre_lex, ctx)
        expect(result.ok.?).to_be_true()

    it "accepts multiline math expression":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val ctx = BlockContext.test("x^2\n+ y^2")
        val result = block.parse_full("x^2\n+ y^2", pre_lex, ctx)
        expect(result.ok.?).to_be_true()

describe "MathBlockDef - skip_policy()":
    it "returns OutlineRequired":
        val block = MathBlockDef()
        expect(block.skip_policy()).to_equal(BlockSkipPolicy.OutlineRequired)

    it "is different from default Skippable":
        val math = MathBlockDef()
        val shell = ShellBlockDef()
        expect(math.skip_policy()).not_to_equal(shell.skip_policy())

# ============================================================================
# BlockSkipPolicy enum
# ============================================================================

describe "BlockSkipPolicy":
    it "Skippable to_string":
        expect(BlockSkipPolicy.Skippable.to_string()).to_equal("skippable")

    it "OutlineRequired to_string":
        expect(BlockSkipPolicy.OutlineRequired.to_string()).to_equal("outline_required")

    it "AlwaysFull to_string":
        expect(BlockSkipPolicy.AlwaysFull.to_string()).to_equal("always_full")

    it "enum variants are distinct":
        expect(BlockSkipPolicy.Skippable).not_to_equal(BlockSkipPolicy.OutlineRequired)
        expect(BlockSkipPolicy.Skippable).not_to_equal(BlockSkipPolicy.AlwaysFull)
        expect(BlockSkipPolicy.OutlineRequired).not_to_equal(BlockSkipPolicy.AlwaysFull)

# ============================================================================
# BlockOutlineInfo
# ============================================================================

describe "BlockOutlineInfo":
    context "opaque factory":
        it "creates opaque info with given kind":
            val info = BlockOutlineInfo.opaque("test")
            expect(info.is_opaque).to_be_true()
            expect(info.kind).to_equal("test")
            expect(info.identifiers.len()).to_equal(0)
            expect(info.external_refs.len()).to_equal(0)
            expect(info.structure_kind).to_equal(nil)

        it "works with any kind string":
            val info = BlockOutlineInfo.opaque("custom_block_v2")
            expect(info.kind).to_equal("custom_block_v2")
            expect(info.is_opaque).to_be_true()

    context "direct construction":
        it "creates non-opaque info":
            val info = BlockOutlineInfo(
                kind: "sql",
                identifiers: ["name", "age"],
                external_refs: ["users"],
                structure_kind: Some("query"),
                is_opaque: false
            )
            expect(info.is_opaque).to_be_false()
            expect(info.identifiers.len()).to_equal(2)
            expect(info.external_refs.len()).to_equal(1)
            expect(info.structure_kind).to_equal(Some("query"))

# ============================================================================
# BlockToken
# ============================================================================

describe "BlockToken":
    it "creates token with factory method":
        val tok = BlockToken.new(BlockTokenKind.Identifier, 0, 3, "foo")
        expect(tok.kind).to_equal(BlockTokenKind.Identifier)
        expect(tok.span.start).to_equal(0)
        expect(tok.span.end).to_equal(3)
        expect(tok.value).to_equal("foo")

    it "creates token with direct construction":
        val tok = BlockToken(
            kind: BlockTokenKind.Number,
            span: TextSpan.new(5, 8),
            value: "123"
        )
        expect(tok.kind).to_equal(BlockTokenKind.Number)
        expect(tok.value).to_equal("123")

    it "all BlockTokenKind variants are distinct":
        expect(BlockTokenKind.Keyword).not_to_equal(BlockTokenKind.Identifier)
        expect(BlockTokenKind.Number).not_to_equal(BlockTokenKind.StringLit)
        expect(BlockTokenKind.Operator).not_to_equal(BlockTokenKind.Punctuation)
        expect(BlockTokenKind.Comment).not_to_equal(BlockTokenKind.Whitespace)
        expect(BlockTokenKind.Error).not_to_equal(BlockTokenKind.Keyword)
