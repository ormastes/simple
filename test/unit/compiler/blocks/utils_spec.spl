describe "Utils":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Utils API Tests - Pre-built Utilities
# #
# # Tests for compiler.blocks.utils module
# # Pre-built parsers, validators, and helpers
# 
# use std.test
# fn check(condition: bool):
#     expect(condition).to_equal(true)
# fn check_msg(condition: bool, message: text):
#     if not condition:
#         expect(message).to_equal("")
# use compiler.blocks.utils.{
#     parse_json, parse_yaml, parse_toml, parse_xml, parse_csv,
#     validate_json, validate_regex, validate_sql,
#     highlight_keywords, highlight_strings, highlight_comments, highlight_numbers,
#     error_at, error_span, errors_from_strings,
#     interpolate_variables, strip_indent, normalize_newlines
# }
# use compiler.blocks.value.{BlockValue}
# use compiler.blocks.context.{BlockContext}
# use compiler.blocks.modes.{Span}
# 
# describe "Utils - Pre-built Parsers":
# 
#     it "parses JSON":
#         val result = parse_json('{"name": "Alice", "age": 30}')
# 
#         check(result.ok.?)
#         val value = result.unwrap()
#         check(value.is_json())
# 
#     it "handles invalid JSON":
#         val result = parse_json("{invalid json}")
# 
#         check(result.err.?)
#         val error = result.unwrap_err()
#         check(error.contains("parse error"))
# 
#     it "parses YAML":
#         val result = parse_yaml("name: Alice\nage: 30")
# 
#         check(result.ok.?)
#         match result.unwrap():
#             case Custom("YAML", _):
#                 pass  # Expected
#             case _:
#                 check(false)
# 
#     it "parses TOML":
#         val result = parse_toml("[section]\nkey = 'value'")
# 
#         check(result.ok.?)
# 
#     it "parses XML":
#         val result = parse_xml("<root><item>value</item></root>")
# 
#         check(result.ok.?)
# 
#     it "parses CSV":
#         val csv_text = """
# name,age,city
# Alice,30,NYC
# Bob,25,SF
#         """.trim()
# 
#         val result = parse_csv(csv_text)
# 
#         check(result.ok.?)
#         match result.unwrap():
#             case Custom("CSV", _):
#                 pass  # Expected
#             case _:
#                 check(false)
# 
# describe "Utils - Pre-built Validators":
# 
#     it "validates JSON structure":
#         val valid = BlockValue.Json(JsonValue(kind: JsonKind.Null))
#         val errors = validate_json(valid)
# 
#         check(errors.len() == 0)
# 
#     it "rejects non-JSON values":
#         val invalid = BlockValue.Raw("not json")
#         val errors = validate_json(invalid)
# 
#         check(errors.len() > 0)
#         check(errors[0].contains("Expected JSON"))
# 
#     it "validates regex patterns":
#         val valid = BlockValue.Regex(RegexPattern(raw: "^[a-z]+$", _handle: 0))
#         val errors = validate_regex(valid)
# 
#         check(errors.len() == 0)
# 
#     it "validates SQL with dialect":
#         val query = BlockValue.Sql(SqlQuery(
#             raw: "SELECT * FROM users",
#             kind: SqlKind.Select,
#             tables: ["users"],
#             columns: [],
#             params: []
#         ))
# 
#         val ansi_errors = validate_sql(query, dialect: "ansi")
#         check(ansi_errors.len() == 0)
# 
#         val pg_errors = validate_sql(query, dialect: "postgres")
#         check(pg_errors.len() == 0)
# 
# describe "Utils - Syntax Highlighting":
# 
#     it "highlights keywords":
#         val text = "SELECT name FROM users WHERE age > 21"
#         val keywords = ["SELECT", "FROM", "WHERE"]
# 
#         val tokens = highlight_keywords(text, keywords)
# 
#         check(tokens.len() >= 3)
#         check(tokens[0].kind == HighlightKind.Keyword)
# 
#     it "handles case sensitivity in keywords":
#         val text = "select FROM where"
#         val keywords = ["SELECT", "FROM", "WHERE"]
# 
#         val tokens = highlight_keywords(text, keywords)
# 
#         # Should find FROM (exact match) but not select/where
#         val found_keywords = tokens.filter(\t: t.kind == HighlightKind.Keyword)
#         check(found_keywords.len() >= 1)
# 
#     it "highlights strings":
#         val text = 'name = "Alice" and city = "NYC"'
# 
#         val tokens = highlight_strings(text)
# 
#         val strings = tokens.filter(\t: t.kind == HighlightKind.String)
#         check(strings.len() == 2)
# 
#     it "handles escaped quotes in strings":
#         val text = 'text = "She said \\"Hello\\""'
# 
#         val tokens = highlight_strings(text)
# 
#         val strings = tokens.filter(\t: t.kind == HighlightKind.String)
#         check(strings.len() == 1)
# 
#     it "highlights line comments":
#         val text = "code(); // This is a comment\nmore_code();"
# 
#         val tokens = highlight_comments(text, line_comment: "//")
# 
#         val comments = tokens.filter(\t: t.kind == HighlightKind.Comment)
#         check(comments.len() >= 1)
# 
#     it "highlights block comments":
#         val text = "code(); /* This is\na block comment */ more();"
# 
#         val tokens = highlight_comments(text,
#             line_comment: "//",
#             block_comment: ("/*", "*/")
#         )
# 
#         val comments = tokens.filter(\t: t.kind == HighlightKind.Comment)
#         check(comments.len() >= 1)
# 
#     it "highlights both line and block comments":
#         val text = """
# // Line comment
# code();
# /* Block
#    comment */
# more(); // Another line
#         """
# 
#         val tokens = highlight_comments(text,
#             line_comment: "//",
#             block_comment: ("/*", "*/")
#         )
# 
#         val comments = tokens.filter(\t: t.kind == HighlightKind.Comment)
#         check(comments.len() >= 3)
# 
#     it "highlights numbers":
#         val text = "x = 42 + 3.14 - 0x1F"
# 
#         val tokens = highlight_numbers(text)
# 
#         val numbers = tokens.filter(\t: t.kind == HighlightKind.Number)
#         check(numbers.len() == 3)
# 
#     it "highlights hex numbers":
#         val text = "value = 0xFF00AB"
# 
#         val tokens = highlight_numbers(text)
# 
#         val numbers = tokens.filter(\t: t.kind == HighlightKind.Number)
#         check(numbers.len() == 1)
# 
#     it "highlights floats with exponents":
#         val text = "sci = 1.23e-4"
# 
#         val tokens = highlight_numbers(text)
# 
#         val numbers = tokens.filter(\t: t.kind == HighlightKind.Number)
#         check(numbers.len() == 1)
# 
# describe "Utils - Error Helpers":
# 
#     it "creates error at offset":
#         val ctx = BlockContext(
#             payload: "SELECT * FROM users",
#             payload_span: Span(start: 100, end: 119, line: 5, col: 10),
#             block_span: Span(start: 95, end: 124, line: 5, col: 5),
#             file_path: nil,
#             module_name: nil,
#             pre_lex_info: nil,
#             is_top_level: false,
#             parent_block: nil
#         )
# 
#         val error = error_at(ctx, "Missing semicolon", offset: 19)
# 
#         check(error.message == "Missing semicolon")
#         check(error.span.?)
#         check(error.span.unwrap().start == 119)  # 100 + 19
# 
#     it "creates error for span":
#         val ctx = BlockContext.test("SELECT * FROM users")
# 
#         val error = error_span(ctx, "Invalid table name", span: (14, 19))
# 
#         check(error.message == "Invalid table name")
#         check(error.span.?)
# 
#     it "converts string errors to BlockErrors":
#         val ctx = BlockContext.test("test")
#         val messages = ["Error 1", "Error 2", "Error 3"]
# 
#         val errors = errors_from_strings(ctx, messages)
# 
#         check(errors.len() == 3)
#         check(errors[0].message == "Error 1")
#         check(errors[1].message == "Error 2")
#         check(errors[2].message == "Error 3")
# 
#     it "handles empty error list":
#         val ctx = BlockContext.test("test")
#         val errors = errors_from_strings(ctx, [])
# 
#         check(errors.len() == 0)
# 
# describe "Utils - Text Transformations":
# 
#     it "interpolates variables":
#         val template = "Hello {name}, you are {age} years old"
#         val vars = {
#             "name": "Alice",
#             "age": "30"
#         }
# 
#         val result = interpolate_variables(template, vars)
# 
#         check(result == "Hello Alice, you are 30 years old")
# 
#     it "handles missing variables":
#         val template = "Hello {name}, your {title}"
#         val vars = {"name": "Alice"}
# 
#         val result = interpolate_variables(template, vars)
# 
#         # Missing {title} remains unchanged
#         check(result.contains("Alice"))
#         check(result.contains("{title}"))
# 
#     it "handles empty variable dict":
#         val template = "No variables"
#         val vars = {}
# 
#         val result = interpolate_variables(template, vars)
# 
#         check(result == "No variables")
# 
#     it "strips common indent":
#         val text = """
#             Line 1
#             Line 2
#                 Indented
#         """
# 
#         val result = strip_indent(text)
# 
#         # Common indent should be removed
#         check(not result.starts_with(" "))
#         check(result.contains("Line 1"))
# 
#     it "preserves relative indentation":
#         val text = """
#             Normal
#                 Indented
#             Normal
#         """
# 
#         val result = strip_indent(text)
# 
#         val lines = result.split("\n")
#         # Second line should still be indented relative to first
#         # (This test assumes strip_indent preserves relative indentation)
# 
#     it "handles text with no indent":
#         val text = "Line 1\nLine 2"
# 
#         val result = strip_indent(text)
# 
#         check(result == text)
# 
#     it "normalizes newlines from Windows":
#         val windows = "Line 1\r\nLine 2\r\nLine 3"
# 
#         val result = normalize_newlines(windows)
# 
#         check(result == "Line 1\nLine 2\nLine 3")
#         check(not result.contains("\r"))
# 
#     it "normalizes newlines from old Mac":
#         val old_mac = "Line 1\rLine 2\rLine 3"
# 
#         val result = normalize_newlines(old_mac)
# 
#         check(result == "Line 1\nLine 2\nLine 3")
# 
#     it "handles mixed line endings":
#         val mixed = "Line 1\r\nLine 2\rLine 3\nLine 4"
# 
#         val result = normalize_newlines(mixed)
# 
#         check(result == "Line 1\nLine 2\nLine 3\nLine 4")
# 
# describe "Utils - Integration":
# 
#     it "combines highlighting functions":
#         val code = """
# SELECT * FROM users -- Get all users
# WHERE age > 30
# /* Filter by age */
#         """
# 
#         val all_tokens = []
#             .concat(highlight_keywords(code, ["SELECT", "FROM", "WHERE"]))
#             .concat(highlight_comments(code, line_comment: "--", block_comment: ("/*", "*/")))
#             .concat(highlight_numbers(code))
# 
#         check(all_tokens.len() > 0)
# 
#     it "combines text transformations":
#         val template = """
#             Query: {query}
#                 Result: {result}
#         """
# 
#         val normalized = normalize_newlines(template)
#         val stripped = strip_indent(normalized)
#         val interpolated = interpolate_variables(stripped, {
#             "query": "SELECT *",
#             "result": "42 rows"
#         })
# 
#         check(interpolated.contains("SELECT *"))
#         check(interpolated.contains("42 rows"))
# 
#     it "creates detailed errors with context":
#         val payload = "SELECT * FROM users WHERE age > 21"
#         val ctx = BlockContext.test(payload)
# 
#         # Find "users" position
#         val users_pos = payload.index_of("users").unwrap()
# 
#         val error = error_span(ctx, "Table 'users' not found", span: (users_pos, users_pos + 5))
# 
#         check(error.message.contains("not found"))
# 
# describe "Utils - Edge Cases":
# 
#     it "handles empty strings":
#         check(interpolate_variables("", {}) == "")
#         check(strip_indent("") == "")
#         check(normalize_newlines("") == "")
# 
#     it "handles unicode in text":
#         val unicode = "Hello ‰∏ñÁïå üåç"
# 
#         val normalized = normalize_newlines(unicode)
#         check(normalized.contains("‰∏ñÁïå"))
#         check(normalized.contains("üåç"))
# 
#     it "handles very long strings":
#         val long_text = "x" * 10000
# 
#         val normalized = normalize_newlines(long_text)
#         check(normalized.len() == 10000)
# 
#     it "handles special characters in interpolation":
#         val template = "Use {var} here"
#         val vars = {"var": "Special: {}, [], ()"}
# 
#         val result = interpolate_variables(template, vars)
# 
#         check(result.contains("Special:"))
# 
# # ============================================================================
# # Feature Tags
# # ============================================================================
# 
# # tags: [compiler, blocks, utils, helpers]
# # priority: high
# # status: complete
