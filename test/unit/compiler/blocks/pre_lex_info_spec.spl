"""
Feature: PreLexInfo Data Types and Helper Methods
Feature ID: #1090
Category: Compiler
Status: In Progress
Priority: P0

## Overview

PreLexInfo holds pre-scanning information (strings, comments, escapes, brace pairs)
collected by the main lexer during Tier 1/2 brace tracking. This data is shared with
block handlers so they can correctly parse DSL payloads without re-scanning for
strings and comments.

## Concepts

- **TextSpan**: Byte range (start, end) within a payload
- **PreLexInfo**: Aggregation of string spans, comment spans, escape positions, brace pairs
- **is_protected()**: Unified check for string/comment/escape regions
"""

use compiler.blocks.modes.{TextSpan, PreLexInfo}
use std.string.{NL}

# ============================================================================
# TextSpan Tests
# ============================================================================

describe "TextSpan":
    context "construction":
        it "creates span with direct construction":
            val span = TextSpan.new(5, 12)
            expect(span.start).to_equal(5)
            expect(span.end).to_equal(12)

        it "creates span with factory method":
            val span = TextSpan.new(0, 100)
            expect(span.start).to_equal(0)
            expect(span.end).to_equal(100)

        it "creates zero-length span":
            val span = TextSpan.new(5, 5)
            expect(span.len()).to_equal(0)

    context "len()":
        it "returns correct length for non-empty span":
            val span = TextSpan.new(3, 10)
            expect(span.len()).to_equal(7)

        it "returns zero for empty span":
            val span = TextSpan.new(0, 0)
            expect(span.len()).to_equal(0)

        it "returns 1 for single-char span":
            val span = TextSpan.new(5, 6)
            expect(span.len()).to_equal(1)

        it "handles large spans":
            val span = TextSpan.new(0, 100000)
            expect(span.len()).to_equal(100000)

    context "contains()":
        it "returns true for position at start":
            val span = TextSpan.new(5, 10)
            expect(span.contains(5)).to_be_true()

        it "returns false for position at end (exclusive)":
            val span = TextSpan.new(5, 10)
            expect(span.contains(10)).to_be_false()

        it "returns true for position in middle":
            val span = TextSpan.new(5, 10)
            expect(span.contains(7)).to_be_true()

        it "returns false for position before start":
            val span = TextSpan.new(5, 10)
            expect(span.contains(4)).to_be_false()

        it "returns false for position well after end":
            val span = TextSpan.new(5, 10)
            expect(span.contains(100)).to_be_false()

        it "returns false for zero-length span":
            val span = TextSpan.new(5, 5)
            expect(span.contains(5)).to_be_false()

        it "returns true for single-char span at start":
            val span = TextSpan.new(5, 6)
            expect(span.contains(5)).to_be_true()

        it "returns false for negative position":
            val span = TextSpan.new(0, 10)
            expect(span.contains(-1)).to_be_false()

# ============================================================================
# PreLexInfo Construction Tests
# ============================================================================

describe "PreLexInfo":
    context "empty()":
        it "creates info with no spans":
            val info = PreLexInfo.empty()
            expect(info.string_spans.len()).to_equal(0)
            expect(info.comment_spans.len()).to_equal(0)
            expect(info.escape_positions.len()).to_equal(0)
            expect(info.brace_pairs.len()).to_equal(0)

    context "direct construction":
        it "creates info with string spans":
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 12)],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.string_spans.len()).to_equal(1)
            expect(info.string_spans[0].start).to_equal(5)

        it "creates info with multiple string spans":
            val info = PreLexInfo(
                string_spans: [
                    TextSpan.new(0, 5),
                    TextSpan.new(10, 15),
                    TextSpan.new(20, 30)
                ],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.string_spans.len()).to_equal(3)

        it "creates info with comment spans":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan.new(10, 25)],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.comment_spans.len()).to_equal(1)

        it "creates info with escape positions":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [3, 7, 15],
                brace_pairs: []
            )
            expect(info.escape_positions.len()).to_equal(3)

        it "creates info with brace pairs":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: [(0, 10), (2, 5)]
            )
            expect(info.brace_pairs.len()).to_equal(2)

        it "creates info with all fields populated":
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 12)],
                comment_spans: [TextSpan.new(20, 30)],
                escape_positions: [4],
                brace_pairs: [(0, 35)]
            )
            expect(info.string_spans.len()).to_equal(1)
            expect(info.comment_spans.len()).to_equal(1)
            expect(info.escape_positions.len()).to_equal(1)
            expect(info.brace_pairs.len()).to_equal(1)

# ============================================================================
# PreLexInfo.is_in_string() Tests
# ============================================================================

describe "PreLexInfo.is_in_string()":
    context "with no string spans":
        it "returns false for any position":
            val info = PreLexInfo.empty()
            expect(info.is_in_string(0)).to_be_false()
            expect(info.is_in_string(5)).to_be_false()
            expect(info.is_in_string(100)).to_be_false()

    context "with one string span":
        it "returns true for position inside span":
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 12)],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(5)).to_be_true()
            expect(info.is_in_string(7)).to_be_true()
            expect(info.is_in_string(11)).to_be_true()

        it "returns false for position at end boundary":
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 12)],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(12)).to_be_false()

        it "returns false for position before span":
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 12)],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(4)).to_be_false()
            expect(info.is_in_string(0)).to_be_false()

        it "returns false for position after span":
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 12)],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(13)).to_be_false()
            expect(info.is_in_string(100)).to_be_false()

    context "with multiple non-overlapping string spans":
        it "returns true for positions in any span":
            val info = PreLexInfo(
                string_spans: [
                    TextSpan.new(0, 3),
                    TextSpan.new(10, 15),
                    TextSpan.new(20, 25)
                ],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(1)).to_be_true()
            expect(info.is_in_string(12)).to_be_true()
            expect(info.is_in_string(22)).to_be_true()

        it "returns false for gaps between spans":
            val info = PreLexInfo(
                string_spans: [
                    TextSpan.new(0, 3),
                    TextSpan.new(10, 15)
                ],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(5)).to_be_false()
            expect(info.is_in_string(8)).to_be_false()

    context "with adjacent string spans":
        it "handles spans that touch at boundaries":
            # "abc""def" -> spans [0,5) and [5,10)
            val info = PreLexInfo(
                string_spans: [
                    TextSpan.new(0, 5),
                    TextSpan.new(5, 10)
                ],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(4)).to_be_true()
            expect(info.is_in_string(5)).to_be_true()
            expect(info.is_in_string(9)).to_be_true()
            expect(info.is_in_string(10)).to_be_false()

# ============================================================================
# PreLexInfo.is_in_comment() Tests
# ============================================================================

describe "PreLexInfo.is_in_comment()":
    context "with no comment spans":
        it "returns false for any position":
            val info = PreLexInfo.empty()
            expect(info.is_in_comment(0)).to_be_false()
            expect(info.is_in_comment(50)).to_be_false()

    context "with line comment span":
        it "returns true for position inside comment":
            # "x = 1 # comment{NL}" -> comment at [6, 16)
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan.new(6, 16)],
                escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_comment(6)).to_be_true()
            expect(info.is_in_comment(10)).to_be_true()
            expect(info.is_in_comment(15)).to_be_true()

        it "returns false outside comment":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan.new(6, 16)],
                escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_comment(0)).to_be_false()
            expect(info.is_in_comment(5)).to_be_false()
            expect(info.is_in_comment(16)).to_be_false()

    context "with block comment span":
        it "returns true for positions inside block comment":
            # "x /* comment */ y" -> comment at [2, 15)
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan.new(2, 15)],
                escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_comment(2)).to_be_true()
            expect(info.is_in_comment(5)).to_be_true()
            expect(info.is_in_comment(14)).to_be_true()

    context "with multiple comments":
        it "returns true for any comment region":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [
                    TextSpan.new(6, 16),
                    TextSpan.new(20, 35)
                ],
                escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_comment(10)).to_be_true()
            expect(info.is_in_comment(25)).to_be_true()
            expect(info.is_in_comment(18)).to_be_false()

# ============================================================================
# PreLexInfo.is_escaped() Tests
# ============================================================================

describe "PreLexInfo.is_escaped()":
    context "with no escapes":
        it "returns false for any position":
            val info = PreLexInfo.empty()
            expect(info.is_escaped(0)).to_be_false()
            expect(info.is_escaped(5)).to_be_false()

    context "with escape positions":
        it "returns true when preceded by backslash":
            # Backslash at position 3, so position 4 is escaped
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [3],
                brace_pairs: []
            )
            expect(info.is_escaped(4)).to_be_true()

        it "returns false for the backslash position itself":
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [3],
                brace_pairs: []
            )
            # Position 3 is the backslash, not escaped
            expect(info.is_escaped(3)).to_be_false()

        it "returns false for position not preceded by backslash":
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [3],
                brace_pairs: []
            )
            expect(info.is_escaped(6)).to_be_false()

        it "returns false for position 0 (nothing before it)":
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [0],
                brace_pairs: []
            )
            expect(info.is_escaped(0)).to_be_false()

        it "handles multiple escape positions":
            # \{ \} {NL} -> backslashes at 0, 3, 6
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [0, 3, 6],
                brace_pairs: []
            )
            expect(info.is_escaped(1)).to_be_true()
            expect(info.is_escaped(4)).to_be_true()
            expect(info.is_escaped(7)).to_be_true()
            expect(info.is_escaped(2)).to_be_false()
            expect(info.is_escaped(5)).to_be_false()

        it "handles consecutive escapes":
            # \\{NL} -> backslashes at 0, 1  (\\  then {NL})
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [0, 2],
                brace_pairs: []
            )
            expect(info.is_escaped(1)).to_be_true()
            expect(info.is_escaped(3)).to_be_true()

# ============================================================================
# PreLexInfo.is_protected() Tests
# ============================================================================

describe "PreLexInfo.is_protected()":
    context "with empty info":
        it "returns false for any position":
            val info = PreLexInfo.empty()
            expect(info.is_protected(0)).to_be_false()
            expect(info.is_protected(50)).to_be_false()

    context "position in string":
        it "returns true":
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 12)],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_protected(7)).to_be_true()

    context "position in comment":
        it "returns true":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan.new(10, 20)],
                escape_positions: [], brace_pairs: []
            )
            expect(info.is_protected(15)).to_be_true()

    context "position after escape":
        it "returns true":
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [5],
                brace_pairs: []
            )
            expect(info.is_protected(6)).to_be_true()

    context "position outside all protected regions":
        it "returns false":
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 10)],
                comment_spans: [TextSpan.new(20, 30)],
                escape_positions: [15],
                brace_pairs: []
            )
            expect(info.is_protected(0)).to_be_false()
            expect(info.is_protected(12)).to_be_false()
            expect(info.is_protected(35)).to_be_false()

    context "mixed protected regions":
        it "correctly identifies all region types":
            val info = PreLexInfo(
                string_spans: [TextSpan.new(0, 5)],
                comment_spans: [TextSpan.new(10, 20)],
                escape_positions: [25],
                brace_pairs: [(30, 40)]
            )
            # In string
            expect(info.is_protected(2)).to_be_true()
            # Between string and comment
            expect(info.is_protected(7)).to_be_false()
            # In comment
            expect(info.is_protected(15)).to_be_true()
            # After escape
            expect(info.is_protected(26)).to_be_true()
            # After everything
            expect(info.is_protected(50)).to_be_false()

    context "overlapping string and comment (edge case)":
        it "returns true when in either region":
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 15)],
                comment_spans: [TextSpan.new(10, 20)],
                escape_positions: [], brace_pairs: []
            )
            # Only in string
            expect(info.is_protected(7)).to_be_true()
            # In both string and comment
            expect(info.is_protected(12)).to_be_true()
            # Only in comment
            expect(info.is_protected(17)).to_be_true()
            # Outside both
            expect(info.is_protected(3)).to_be_false()
            expect(info.is_protected(22)).to_be_false()
