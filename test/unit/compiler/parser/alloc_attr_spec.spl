# Allocation attribute spec
#
# Tests for #[alloc] and #[no_alloc] function-level attributes (Phase 2).
# These attributes annotate whether a function performs allocation.
# In Phase 2 they are recognized and stored but not enforced.

struct Widget:
    id: i64
    name: text

#[alloc]
fn create_widget(id: i64, name: text) -> Widget:
    Widget(id: id, name: name)

#[no_alloc]
fn add_pure(a: i64, b: i64) -> i64:
    a + b

fn plain_fn(x: i64) -> i64:
    x * 2

describe "#[alloc] attribute":
    it "parses without error on a function":
        val w = create_widget(1, "test")
        expect(w.id).to_equal(1)
        expect(w.name).to_equal("test")

    it "function with #[alloc] returns correct value":
        val w = create_widget(42, "hello")
        expect(w.id).to_equal(42)

    it "function with #[alloc] works with new keyword":
        val w = new create_widget(7, "alloc")
        expect(w.id).to_equal(7)
        expect(w.name).to_equal("alloc")

describe "#[no_alloc] attribute":
    it "parses without error on a function":
        val result = add_pure(3, 4)
        expect(result).to_equal(7)

    it "function with #[no_alloc] returns correct value":
        val result = add_pure(100, 200)
        expect(result).to_equal(300)

    it "function with #[no_alloc] works with new keyword":
        val result = new add_pure(10, 20)
        expect(result).to_equal(30)

    it "function with #[no_alloc] works without new keyword":
        val result = add_pure(5, 5)
        expect(result).to_equal(10)

describe "combination of alloc attributes and new":
    it "#[alloc] function called with new returns correct value":
        val w = new create_widget(99, "combo")
        expect(w.id).to_equal(99)
        expect(w.name).to_equal("combo")

    it "plain function without attributes still works":
        val result = plain_fn(5)
        expect(result).to_equal(10)

    it "plain function works with new":
        val result = new plain_fn(8)
        expect(result).to_equal(16)
