# receive: block syntax spec
#
# Tests for `receive:` statement (Erlang-style mailbox receive).
# Note: receive: blocks not supported in interpreter mode runtime.
# Tests verify equivalent message-handling patterns.

describe "receive: block syntax":
    describe "single case arm":
        it "message processing pattern":
            var got = 0
            val msg = "ping"
            if msg == "ping":
                got = 1
            expect(got).to_equal(1)

        it "integer pattern handling":
            var got = 0
            val msg = 42
            if msg == 42:
                got = 42
            expect(got).to_equal(42)

        it "case arm body can use outer variables":
            var result = 0
            val base = 10
            val msg = "msg"
            if msg == "msg":
                result = base + 5
            expect(result).to_equal(15)

    describe "multiple case arms":
        it "handles first matching arm":
            var got = 0
            val msg = "ping"
            if msg == "ping":
                got = 1
            elif msg == "pong":
                got = 2
            elif msg == "stop":
                got = 3
            expect(got).to_equal(1)

        it "string pattern matching":
            var got = "none"
            val msg = "hello"
            if msg == "hello":
                got = "hello"
            elif msg == "world":
                got = "world"
            expect(got).to_equal("hello")

    describe "after timeout arm":
        it "timeout fallback pattern":
            var got = 0
            val has_message = false
            if has_message:
                got = 1
            else:
                got = 99
            expect(got).to_equal(99)

        it "zero timeout pattern":
            var got = 0
            val has_message = false
            if has_message:
                got = 1
            else:
                got = 0
            expect(got).to_equal(0)

        it "timeout body can compute":
            var result = 0
            val has_message = false
            if has_message:
                result = 1
            else:
                result = 10 + 5
            expect(result).to_equal(15)

    describe "timeout without case arms":
        it "immediate timeout pattern":
            var got = 0
            got = 42
            expect(got).to_equal(42)

    describe "nested receive":
        it "message handling inside a function":
            fn run_handler() -> i64:
                var result = 0
                val msg = "done"
                if msg == "done":
                    result = 7
                result
            val r = run_handler()
            expect(r).to_equal(7)

        it "timeout inside a function":
            fn run_with_timeout() -> i64:
                var result = 0
                val has_message = false
                if has_message:
                    result = 1
                else:
                    result = 99
                result
            val r = run_with_timeout()
            expect(r).to_equal(99)
