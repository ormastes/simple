use std.spec

extern fn rt_file_read_text(path: text) -> text

fn read_text(path: text) -> text:
    rt_file_read_text(path) ?? ""

describe "Bitfield Pure Simple Implementation":
    it "registers bitfield keyword in token table":
        val tokens = read_text("src/compiler/10.frontend/core/tokens.spl")
        expect(tokens.contains("TOK_KW_BITFIELD")).to_equal(true)
        expect(tokens.contains("if name == \"bitfield\": return TOK_KW_BITFIELD")).to_equal(true)
        expect(tokens.contains("if kind == TOK_KW_BITFIELD: return \"bitfield\"")).to_equal(true)

    it "routes module declarations to parse_bitfield_decl":
        val decls = read_text("src/compiler/10.frontend/core/parser_decls.spl")
        expect(decls.contains("elif par_kind == TOK_KW_BITFIELD")).to_equal(true)
        expect(decls.contains("val d = parse_bitfield_decl()")).to_equal(true)

    it "supports backing type and reserved underscore fields":
        val decls = read_text("src/compiler/10.frontend/core/parser_decls.spl")
        expect(decls.contains("parser_expect(TOK_LPAREN)")).to_equal(true)
        expect(decls.contains("val backing_type = parser_parse_type()")).to_equal(true)
        expect(decls.contains("val is_underscore: bool = par_kind == TOK_UNDERSCORE")).to_equal(true)

    it "enforces backing and field width validation in parser":
        val decls = read_text("src/compiler/10.frontend/core/parser_decls.spl")
        expect(decls.contains("bitfield backing type must be u8, u16, u32, or u64")).to_equal(true)
        expect(decls.contains("bitfield field type must be bool, uN, or iN")).to_equal(true)
        expect(decls.contains("uses \" + int_to_str(used_bits) + \" bits")).to_equal(true)
