# Feature Port Struct Tests
#
# Tests that feature stage port structs can be constructed and
# that their fields are accessible.
#
# NOTE: Due to runtime limitation, only the FIRST struct in each imported
# module supports direct field construction. Subsequent structs are tested
# via the first struct's import scope.

use compiler.feature.lexing.app.ports.{LexerInputPort, LexerOutputPort}
use compiler.feature.parsing.app.ports.{ParseError, ParserInputPort, ParserOutputPort}
use compiler.feature.desugaring.app.ports.{DesugarInputPort, DesugarOutputPort}
use compiler.feature.codegen.app.ports.{CodegenInputPort, CodegenOutputPort}

# ============================================================================
# LexerInputPort - first struct in lexing/app/ports.spl
# ============================================================================

describe "LexerInputPort":
    it "constructs with source_text":
        val port = LexerInputPort(source_text: "val x = 1")
        expect(port.source_text).to_equal("val x = 1")

    it "constructs with empty source":
        val port = LexerInputPort(source_text: "")
        expect(port.source_text).to_equal("")

    it "constructs with multiline source":
        val port = LexerInputPort(source_text: "fn foo():\n    1")
        expect(port.source_text).to_start_with("fn foo")

# ============================================================================
# LexerOutputPort - second struct in lexing/app/ports.spl
# Direct construction: fields will be nil due to runtime limitation.
# Test only that it constructs without error.
# ============================================================================

describe "LexerOutputPort":
    it "constructs with token data":
        val port = LexerOutputPort(
            token_tags: [1, 2, 3],
            token_texts: ["val", "x", "="],
            token_lines: [1, 1, 1],
            token_cols: [1, 5, 7],
            token_count: 3
        )
        expect(port.token_count).to_equal(3)

    it "constructs with empty token arrays":
        val port = LexerOutputPort(
            token_tags: [],
            token_texts: [],
            token_lines: [],
            token_cols: [],
            token_count: 0
        )
        expect(port.token_count).to_equal(0)

# ============================================================================
# ParseError - first struct in parsing/app/ports.spl
# ============================================================================

describe "ParseError":
    it "constructs with message and location":
        val err = ParseError(message: "unexpected token", line: 5, col: 12)
        expect(err.message).to_equal("unexpected token")
        expect(err.line).to_equal(5)
        expect(err.col).to_equal(12)

    it "stores zero location for start of file":
        val err = ParseError(message: "syntax error", line: 1, col: 1)
        expect(err.line).to_equal(1)
        expect(err.col).to_equal(1)

    it "stores large line numbers":
        val err = ParseError(message: "eof", line: 9999, col: 80)
        expect(err.line).to_equal(9999)

# ============================================================================
# ParserInputPort - second struct in parsing/app/ports.spl
# ============================================================================

describe "ParserInputPort":
    it "constructs with token stream data":
        val port = ParserInputPort(
            token_tags: [1, 2],
            token_texts: ["val", "x"],
            token_lines: [1, 1],
            token_cols: [1, 5],
            token_count: 2,
            source_text: "val x"
        )
        expect(port.token_count).to_equal(2)

# ============================================================================
# ParserOutputPort - third struct in parsing/app/ports.spl
# ============================================================================

describe "ParserOutputPort":
    it "constructs empty output":
        val port = ParserOutputPort(
            expr_count: 0,
            stmt_count: 0,
            decl_count: 0,
            root_decls: [],
            errors: [],
            error_count: 0
        )
        expect(port.error_count).to_equal(0)

    it "constructs output with counts":
        val port = ParserOutputPort(
            expr_count: 10,
            stmt_count: 5,
            decl_count: 3,
            root_decls: [0, 1, 2],
            errors: [],
            error_count: 0
        )
        expect(port.expr_count).to_equal(10)
        expect(port.stmt_count).to_equal(5)
        expect(port.decl_count).to_equal(3)

# ============================================================================
# DesugarInputPort - first struct in desugaring/app/ports.spl
# ============================================================================

describe "DesugarInputPort":
    it "constructs with source and module name":
        val port = DesugarInputPort(source_text: "fn foo(): 1", module_name: "test")
        expect(port.module_name).to_equal("test")
        expect(port.source_text).to_equal("fn foo(): 1")

    it "holds the module name":
        val port = DesugarInputPort(source_text: "", module_name: "my_module")
        expect(port.module_name).to_equal("my_module")

# ============================================================================
# DesugarOutputPort - second struct in desugaring/app/ports.spl
# ============================================================================

describe "DesugarOutputPort":
    it "constructs with desugared source":
        val port = DesugarOutputPort(
            desugared_source: "fn foo(): 1",
            injected_fn_names: [],
            pass_count: 5
        )
        expect(port.pass_count).to_equal(5)

    it "constructs with injected function names":
        val port = DesugarOutputPort(
            desugared_source: "fn foo(): 1\nfn __foo_impl(): 1",
            injected_fn_names: ["__foo_impl"],
            pass_count: 5
        )
        expect(port.pass_count).to_equal(5)

# ============================================================================
# CodegenInputPort - first struct in codegen/app/ports.spl
# ============================================================================

describe "CodegenInputPort":
    it "constructs with function counts":
        val port = CodegenInputPort(
            function_count: 3,
            extern_fn_count: 1,
            string_literal_count: 2
        )
        expect(port.function_count).to_equal(3)
        expect(port.extern_fn_count).to_equal(1)
        expect(port.string_literal_count).to_equal(2)

    it "constructs with zero counts":
        val port = CodegenInputPort(
            function_count: 0,
            extern_fn_count: 0,
            string_literal_count: 0
        )
        expect(port.function_count).to_equal(0)

# ============================================================================
# CodegenOutputPort - second struct in codegen/app/ports.spl
# ============================================================================

describe "CodegenOutputPort":
    it "reports success":
        val port = CodegenOutputPort(
            object_byte_count: 1024,
            symbol_count: 5,
            target_triple: "x86_64-linux-gnu",
            success: true
        )
        expect(port.success).to_equal(true)
        expect(port.target_triple).to_equal("x86_64-linux-gnu")

    it "reports failure":
        val port = CodegenOutputPort(
            object_byte_count: 0,
            symbol_count: 0,
            target_triple: "x86_64-linux-gnu",
            success: false
        )
        expect(port.success).to_equal(false)

    it "stores object byte count":
        val port = CodegenOutputPort(
            object_byte_count: 4096,
            symbol_count: 10,
            target_triple: "aarch64-linux-gnu",
            success: true
        )
        expect(port.object_byte_count).to_equal(4096)
        expect(port.symbol_count).to_equal(10)
