#!/usr/bin/env simple
# HIR Async Integration Tests
#
# Tests Future<T> type handling and async function validation in HIR.

use compiler.hir_lowering.async.{AsyncFunctionCheck}
use compiler.hir_lowering.types.{HirLowering}
use compiler.hir_types.{HirType, HirTypeKind, SymbolId, SymbolTable, Symbol, SymbolKind}
use compiler.hir_definitions.{HirFunction, HirParam, HirEnum, HirEnumVariant}
use lexer.Span

# Helper to create dummy span
fn dummy_span() -> Span:
    Span.new(0, 0, 1, 1)

# Helper to create HIR lowering context with Future symbol
fn make_lowering_with_future() -> HirLowering:
    var lowering = HirLowering.new()

    # Register Future symbol
    val future_sym = lowering.symbols.define(
        "Future",
        SymbolKind.Class,
        nil,  # Type will be set later
        dummy_span(),
        true,  # public
        false,  # not mutable
        "std.async.future"
    )

    # Register Poll symbol
    val poll_sym = lowering.symbols.define(
        "Poll",
        SymbolKind.Enum,
        nil,
        dummy_span(),
        true,
        false,
        "std.async.poll"
    )

    lowering

# Helper to create text HirType
fn make_text_type() -> HirType:
    HirType(kind: HirTypeKind.Str, span: dummy_span())

# Helper to create i64 HirType
fn make_i64_type() -> HirType:
    HirType(kind: HirTypeKind.Int(64, true), span: dummy_span())

# Helper to create Future<T> HirType
fn make_future_type_manual(lowering: HirLowering, inner: HirType) -> HirType:
    val future_symbol = lowering.symbols.lookup("Future").unwrap()
    HirType(
        kind: HirTypeKind.Named(future_symbol, [inner]),
        span: dummy_span()
    )

describe "HIR Async - Future Type Recognition":
    it "recognizes Future<text> type":
        val lowering = make_lowering_with_future()
        val future_text = make_future_type_manual(lowering, make_text_type())

        expect(lowering.is_future_type(future_text)).to_equal(true)

    it "recognizes Future<i64> type":
        val lowering = make_lowering_with_future()
        val future_i64 = make_future_type_manual(lowering, make_i64_type())

        expect(lowering.is_future_type(future_i64)).to_equal(true)

    it "rejects non-Future types":
        val lowering = make_lowering_with_future()
        val text_type = make_text_type()

        expect(lowering.is_future_type(text_type)).to_equal(false)

describe "HIR Async - Future Inner Type Extraction":
    it "extracts text from Future<text>":
        val lowering = make_lowering_with_future()
        val inner_type = make_text_type()
        val future_type = make_future_type_manual(lowering, inner_type)

        val extracted = lowering.extract_future_inner(future_type)

        expect(extracted.?).to_equal(true)
        # Type comparison would go here

    it "extracts i64 from Future<i64>":
        val lowering = make_lowering_with_future()
        val inner_type = make_i64_type()
        val future_type = make_future_type_manual(lowering, inner_type)

        val extracted = lowering.extract_future_inner(future_type)

        expect(extracted.?).to_equal(true)

    it "returns nil for non-Future types":
        val lowering = make_lowering_with_future()
        val text_type = make_text_type()

        val extracted = lowering.extract_future_inner(text_type)

        expect(extracted.?).to_equal(false)

describe "HIR Async - Future Type Construction":
    it "constructs Future<text> type":
        val lowering = make_lowering_with_future()
        val inner = make_text_type()

        val future_type = lowering.make_future_type(inner, dummy_span())

        expect(lowering.is_future_type(future_type)).to_equal(true)

    it "constructs Future<i64> type":
        val lowering = make_lowering_with_future()
        val inner = make_i64_type()

        val future_type = lowering.make_future_type(inner, dummy_span())

        expect(lowering.is_future_type(future_type)).to_equal(true)

describe "HIR Async - Type Formatting":
    it "formats primitive types":
        val lowering = make_lowering_with_future()

        expect(lowering.format_type(make_text_type())).to_equal("text")
        expect(lowering.format_type(make_i64_type())).to_equal("i64")

    it "formats Future<T> types":
        val lowering = make_lowering_with_future()
        val future_text = make_future_type_manual(lowering, make_text_type())

        val formatted = lowering.format_type(future_text)

        expect(formatted).to_contain("Future")
        expect(formatted).to_contain("text")

    it "formats tuple types":
        val lowering = make_lowering_with_future()
        val tuple_type = HirType(
            kind: HirTypeKind.Tuple([make_i64_type(), make_text_type()]),
            span: dummy_span()
        )

        val formatted = lowering.format_type(tuple_type)

        expect(formatted).to_contain("i64")
        expect(formatted).to_contain("text")

describe "HIR Async - Function Validation":
    it "validates async function with correct return type":
        val lowering = make_lowering_with_future()

        # Create function: fn fetch() -> Future<text>
        val future_return = make_future_type_manual(lowering, make_text_type())
        val func = HirFunction(
            symbol: SymbolId.new(1),
            name: "fetch",
            type_params: [],
            params: [],
            return_type: future_return,
            body: HirBlock(stmts: [], span: dummy_span()),
            effects: [],
            is_async: false,  # Already desugared
            is_static: false,
            is_public: false,
            is_method: false,
            is_mutable: false,
            is_const: false,
            doc_comment: nil,
            span: dummy_span()
        )

        val check = lowering.check_async_function(func, nil, nil)

        expect(check.is_valid).to_equal(true)
        expect(check.errors.len()).to_equal(0)

    it "rejects function with non-Future return":
        val lowering = make_lowering_with_future()

        # Create function: fn fetch() -> text (should be Future<text>)
        val text_return = make_text_type()
        val func = HirFunction(
            symbol: SymbolId.new(1),
            name: "fetch",
            type_params: [],
            params: [],
            return_type: text_return,
            body: HirBlock(stmts: [], span: dummy_span()),
            effects: [],
            is_async: false,
            is_static: false,
            is_public: false,
            is_method: false,
            is_mutable: false,
            is_const: false,
            doc_comment: nil,
            span: dummy_span()
        )

        val check = lowering.check_async_function(func, nil, nil)

        expect(check.is_valid).to_equal(false)
        expect(check.errors.len()).to_be_greater_than(0)

describe "HIR Async - Poll Function Validation":
    it "validates poll function parameter count":
        val lowering = make_lowering_with_future()

        # Poll function should have 2 params (state, waker)
        val func_2_params = HirFunction(
            symbol: SymbolId.new(1),
            name: "poll_fetch",
            type_params: [],
            params: [
                HirParam(
                    symbol: SymbolId.new(2),
                    name: "state",
                    type_: make_i64_type(),  # placeholder
                    default: nil,
                    span: dummy_span()
                ),
                HirParam(
                    symbol: SymbolId.new(3),
                    name: "waker",
                    type_: make_i64_type(),  # placeholder
                    default: nil,
                    span: dummy_span()
                )
            ],
            return_type: HirType(kind: HirTypeKind.Unit, span: dummy_span()),
            body: HirBlock(stmts: [], span: dummy_span()),
            effects: [],
            is_async: false,
            is_static: false,
            is_public: false,
            is_method: false,
            is_mutable: false,
            is_const: false,
            doc_comment: nil,
            span: dummy_span()
        )

        # Just checking parameter count (return type checked separately)
        expect(func_2_params.params.len()).to_equal(2)

describe "HIR Async - State Enum Validation":
    it "validates state enum with State0":
        val lowering = make_lowering_with_future()

        # Create minimal state enum with State0
        val state_enum = HirEnum(
            symbol: SymbolId.new(1),
            name: "FetchState",
            type_params: [],
            variants: [
                HirEnumVariant(
                    symbol: SymbolId.new(2),
                    name: "State0",
                    fields: [],
                    discriminant: Some(0),
                    doc_comment: nil,
                    span: dummy_span()
                )
            ],
            is_public: false,
            doc_comment: nil,
            span: dummy_span()
        )

        val check = lowering.check_state_enum_structure(state_enum, dummy_span())

        expect(check.is_valid).to_equal(true)
        expect(check.errors.len()).to_equal(0)

    it "rejects empty state enum":
        val lowering = make_lowering_with_future()

        # Create empty enum (invalid)
        val empty_enum = HirEnum(
            symbol: SymbolId.new(1),
            name: "EmptyState",
            type_params: [],
            variants: [],
            is_public: false,
            doc_comment: nil,
            span: dummy_span()
        )

        val check = lowering.check_state_enum_structure(empty_enum, dummy_span())

        expect(check.is_valid).to_equal(false)
        expect(check.errors.len()).to_be_greater_than(0)
