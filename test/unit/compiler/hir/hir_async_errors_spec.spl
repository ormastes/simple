describe "Hir Async Errors":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# #!/usr/bin/env simple
# # HIR Async Error Diagnostics Tests
# #
# # Tests error message generation for async/await issues.
# 
# use compiler.hir_lowering.async_errors.{
#     AsyncErrorCode,
#     AsyncError,
#     AsyncErrorCollector,
#     async_fn_must_return_future,
#     type_mismatch_in_state,
#     poll_function_wrong_signature,
#     future_type_param_mismatch,
#     await_outside_async,
#     invalid_state_enum_structure,
#     future_type_not_found,
#     poll_type_not_found
# }
# use lexer.Span
# 
# # Helper to create dummy span
# fn dummy_span() -> Span:
#     Span.new(0, 0, 1, 1)
# 
# describe "Async Errors - Error Codes":
#     it "formats error code E0701":
#         val code = AsyncErrorCode.E0701
#         expect(code.code()).to_equal("E0701")
# 
#     it "formats error code E0702":
#         val code = AsyncErrorCode.E0702
#         expect(code.code()).to_equal("E0702")
# 
#     it "formats all error codes":
#         val codes = [
#             AsyncErrorCode.E0701,
#             AsyncErrorCode.E0702,
#             AsyncErrorCode.E0703,
#             AsyncErrorCode.E0704,
#             AsyncErrorCode.E0705
#         ]
# 
#         for code in codes:
#             val formatted = code.code()
#             expect(formatted).to_start_with("E07")
# 
# describe "Async Errors - async_fn_must_return_future":
#     it "creates error with correct code":
#         val error = async_fn_must_return_future(
#             "fetch",
#             "text",
#             "Future<text>",
#             dummy_span()
#         )
# 
#         expect(error.code.code()).to_equal("E0701")
# 
#     it "includes function name in message":
#         val error = async_fn_must_return_future(
#             "fetch",
#             "text",
#             "Future<text>",
#             dummy_span()
#         )
# 
#         expect(error.message).to_contain("fetch")
# 
#     it "provides helpful suggestion":
#         val error = async_fn_must_return_future(
#             "fetch",
#             "text",
#             "Future<text>",
#             dummy_span()
#         )
# 
#         expect(error.help.?).to_equal(true)
#         expect(error.help).to_contain("Future<text>")
# 
#     it "formats complete error message":
#         val error = async_fn_must_return_future(
#             "fetch",
#             "text",
#             "Future<text>",
#             dummy_span()
#         )
# 
#         val formatted = error.format()
# 
#         expect(formatted).to_contain("error[E0701]")
#         expect(formatted).to_contain("fetch")
#         expect(formatted).to_contain("help:")
# 
# describe "Async Errors - type_mismatch_in_state":
#     it "creates error with correct code":
#         val error = type_mismatch_in_state(
#             "State1",
#             "x",
#             "i64",
#             "text",
#             dummy_span()
#         )
# 
#         expect(error.code.code()).to_equal("E0702")
# 
#     it "includes state and field names":
#         val error = type_mismatch_in_state(
#             "State1",
#             "x",
#             "i64",
#             "text",
#             dummy_span()
#         )
# 
#         expect(error.message).to_contain("State1")
#         expect(error.message).to_contain("x")
# 
#     it "shows expected and found types":
#         val error = type_mismatch_in_state(
#             "State1",
#             "x",
#             "i64",
#             "text",
#             dummy_span()
#         )
# 
#         expect(error.help.?).to_equal(true)
#         expect(error.help).to_contain("i64")
# 
# describe "Async Errors - poll_function_wrong_signature":
#     it "creates error with correct code":
#         val error = poll_function_wrong_signature(
#             "poll_fetch",
#             "missing waker parameter",
#             dummy_span()
#         )
# 
#         expect(error.code.code()).to_equal("E0704")
# 
#     it "includes issue description":
#         val error = poll_function_wrong_signature(
#             "poll_fetch",
#             "missing waker parameter",
#             dummy_span()
#         )
# 
#         expect(error.message).to_contain("missing waker parameter")
# 
#     it "provides correct signature in help":
#         val error = poll_function_wrong_signature(
#             "poll_fetch",
#             "wrong params",
#             dummy_span()
#         )
# 
#         expect(error.help.?).to_equal(true)
#         expect(error.help).to_contain("Waker")
#         expect(error.help).to_contain("Poll<T>")
# 
# describe "Async Errors - future_type_param_mismatch":
#     it "creates error with correct code":
#         val error = future_type_param_mismatch(
#             "fetch",
#             "text",
#             "i64",
#             dummy_span()
#         )
# 
#         expect(error.code.code()).to_equal("E0705")
# 
#     it "shows both inner types":
#         val error = future_type_param_mismatch(
#             "fetch",
#             "text",
#             "i64",
#             dummy_span()
#         )
# 
#         expect(error.help.?).to_equal(true)
#         expect(error.help).to_contain("text")
#         expect(error.help).to_contain("i64")
# 
# describe "Async Errors - await_outside_async":
#     it "creates error with correct code":
#         val error = await_outside_async(dummy_span())
# 
#         expect(error.code.code()).to_equal("E0707")
# 
#     it "suggests marking function as async":
#         val error = await_outside_async(dummy_span())
# 
#         expect(error.help.?).to_equal(true)
#         expect(error.help).to_contain("async")
# 
#     it "includes suggestion":
#         val error = await_outside_async(dummy_span())
# 
#         expect(error.suggestion.?).to_equal(true)
#         expect(error.suggestion).to_contain("async fn")
# 
# describe "Async Errors - invalid_state_enum_structure":
#     it "creates error with correct code":
#         val error = invalid_state_enum_structure(
#             "FetchState",
#             "missing State0",
#             dummy_span()
#         )
# 
#         expect(error.code.code()).to_equal("E0708")
# 
#     it "includes enum name and issue":
#         val error = invalid_state_enum_structure(
#             "FetchState",
#             "no variants",
#             dummy_span()
#         )
# 
#         expect(error.message).to_contain("FetchState")
#         expect(error.message).to_contain("no variants")
# 
#     it "suggests State0 variant":
#         val error = invalid_state_enum_structure(
#             "FetchState",
#             "empty",
#             dummy_span()
#         )
# 
#         expect(error.help.?).to_equal(true)
#         expect(error.help).to_contain("State0")
# 
# describe "Async Errors - future_type_not_found":
#     it "creates error with correct code":
#         val error = future_type_not_found(dummy_span())
# 
#         expect(error.code.code()).to_equal("E0709")
# 
#     it "suggests importing Future":
#         val error = future_type_not_found(dummy_span())
# 
#         expect(error.help.?).to_equal(true)
#         expect(error.help).to_contain("std.async.future")
# 
#     it "provides import suggestion":
#         val error = future_type_not_found(dummy_span())
# 
#         expect(error.suggestion.?).to_equal(true)
#         expect(error.suggestion).to_contain("use")
#         expect(error.suggestion).to_contain("Future")
# 
# describe "Async Errors - poll_type_not_found":
#     it "creates error with correct code":
#         val error = poll_type_not_found(dummy_span())
# 
#         expect(error.code.code()).to_equal("E0710")
# 
#     it "suggests importing Poll":
#         val error = poll_type_not_found(dummy_span())
# 
#         expect(error.help.?).to_equal(true)
#         expect(error.help).to_contain("std.async.poll")
# 
# describe "Async Errors - Error Collector":
#     it "creates empty collector":
#         val collector = AsyncErrorCollector.new()
# 
#         expect(collector.has_errors()).to_equal(false)
#         expect(collector.count()).to_equal(0)
# 
#     it "adds errors to collector":
#         var collector = AsyncErrorCollector.new()
# 
#         val error1 = future_type_not_found(dummy_span())
#         collector.add(error1)
# 
#         expect(collector.has_errors()).to_equal(true)
#         expect(collector.count()).to_equal(1)
# 
#     it "collects multiple errors":
#         var collector = AsyncErrorCollector.new()
# 
#         collector.add(future_type_not_found(dummy_span()))
#         collector.add(poll_type_not_found(dummy_span()))
# 
#         expect(collector.count()).to_equal(2)
# 
#     it "formats all errors":
#         var collector = AsyncErrorCollector.new()
# 
#         collector.add(async_fn_must_return_future(
#             "fetch",
#             "text",
#             "Future<text>",
#             dummy_span()
#         ))
#         collector.add(await_outside_async(dummy_span()))
# 
#         val formatted = collector.format_all()
# 
#         expect(formatted).to_contain("E0701")
#         expect(formatted).to_contain("E0707")
# 
#     it "gets error codes":
#         var collector = AsyncErrorCollector.new()
# 
#         collector.add(async_fn_must_return_future(
#             "fetch",
#             "text",
#             "Future<text>",
#             dummy_span()
#         ))
#         collector.add(type_mismatch_in_state(
#             "State1",
#             "x",
#             "i64",
#             "text",
#             dummy_span()
#         ))
# 
#         val codes = collector.get_codes()
# 
#         expect(codes.len()).to_equal(2)
#         expect(codes).to_contain("E0701")
#         expect(codes).to_contain("E0702")
# 
# describe "Async Errors - Error Formatting":
#     it "formats error with all fields":
#         val error = async_fn_must_return_future(
#             "fetch",
#             "text",
#             "Future<text>",
#             dummy_span()
#         )
# 
#         val formatted = error.format()
# 
#         # Should contain all components
#         expect(formatted).to_contain("error[E0701]")
#         expect(formatted).to_contain("async function")
#         expect(formatted).to_contain("help:")
#         expect(formatted).to_contain("note:")
# 
#     it "formats error without optional fields":
#         val error = AsyncError(
#             code: AsyncErrorCode.E0703,
#             message: "test error",
#             span: dummy_span(),
#             help: nil,
#             note: nil,
#             suggestion: nil
#         )
# 
#         val formatted = error.format()
# 
#         expect(formatted).to_contain("error[E0703]")
#         expect(formatted).to_contain("test error")
