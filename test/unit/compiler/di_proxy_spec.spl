# DI Proxy Generation Specification
#
# Tests for the lazy proxy desugar pass: annotation parsing,
# proxy code generation, and deferred instantiation behavior.

use app.desugar.lazy_proxy_gen.{desugar_lazy_proxies}

describe "DI Lazy Proxy Generation":

    describe "no-op when no annotations":
        it "returns source unchanged when no @lazy_proxy annotations":
            val source = "fn hello():\n    print \"hi\"\n"
            val result = desugar_lazy_proxies(source)
            expect(result).to_equal(source)

        it "returns source unchanged for plain traits":
            val source = "trait Display:\n    fn to_string() -> text\n"
            val result = desugar_lazy_proxies(source)
            expect(result).to_equal(source)

    describe "proxy generation":
        it "generates delegation functions for annotated trait":
            val source = "# @lazy_proxy(\"test_svc\")\ntrait TestService:\n    fn greet(name: text) -> text\n    fn count() -> i64\n"
            val result = desugar_lazy_proxies(source)
            expect(result.contains("__lazy_test_svc_greet")).to_equal(true)
            expect(result.contains("__lazy_test_svc_count")).to_equal(true)

        it "generates factory function":
            val source = "# @lazy_proxy(\"test_svc\")\ntrait TestService:\n    fn greet(name: text) -> text\n"
            val result = desugar_lazy_proxies(source)
            expect(result.contains("make_lazy_TestService")).to_equal(true)

        it "delegation function calls di_resolve":
            val source = "# @lazy_proxy(\"my_svc\")\ntrait MySvc:\n    fn action() -> text\n"
            val result = desugar_lazy_proxies(source)
            expect(result.contains("di_resolve(\"my_svc\")")).to_equal(true)

        it "delegation function forwards to fn-field":
            val source = "# @lazy_proxy(\"my_svc\")\ntrait MySvc:\n    fn process(data: text) -> text\n"
            val result = desugar_lazy_proxies(source)
            expect(result.contains("real.process_fn(data)")).to_equal(true)

    describe "multiple methods":
        it "generates proxy for trait with multiple methods":
            val source = "# @lazy_proxy(\"json\")\ntrait JsonSvc:\n    fn escape(s: text) -> text\n    fn js(s: text) -> text\n    fn jp(key: text, value: text) -> text\n"
            val result = desugar_lazy_proxies(source)
            expect(result.contains("__lazy_json_escape")).to_equal(true)
            expect(result.contains("__lazy_json_js")).to_equal(true)
            expect(result.contains("__lazy_json_jp")).to_equal(true)
            expect(result.contains("make_lazy_JsonSvc")).to_equal(true)

    describe "preserves original source":
        it "keeps the original trait declaration":
            val source = "val x = 1\n# @lazy_proxy(\"svc\")\ntrait Svc:\n    fn action() -> text\nval y = 2\n"
            val result = desugar_lazy_proxies(source)
            expect(result.contains("val x = 1")).to_equal(true)
            expect(result.contains("val y = 2")).to_equal(true)
            expect(result.contains("trait Svc:")).to_equal(true)

    describe "annotation parsing":
        it "ignores malformed annotations":
            val source = "# @lazy_proxy\ntrait Bad:\n    fn action() -> text\n"
            val result = desugar_lazy_proxies(source)
            # Should not generate proxy code for malformed annotation
            expect(result.contains("make_lazy_Bad")).to_equal(false)

        it "ignores annotations without trailing trait":
            val source = "# @lazy_proxy(\"svc\")\nfn not_a_trait():\n    42\n"
            val result = desugar_lazy_proxies(source)
            expect(result.contains("make_lazy_")).to_equal(false)
