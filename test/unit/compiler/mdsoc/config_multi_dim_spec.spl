# Tests for multi-dimension config parsing.
# Run with: bin/simple test test/unit/compiler/mdsoc/config_multi_dim_spec.spl
#
# Tests for: src/compiler/85.mdsoc/mdsoc/config.spl (multi-dimension support)
# Verifies that dimension_construct: section is parsed as a second dimension
# and both dimensions accumulate into manifest.dimensions.
# Also verifies backward compatibility of single-dimension configs.

use compiler.mdsoc.types.*
use compiler.mdsoc.config.*

# ============================================================================
# Backward compatibility: single dimension
# ============================================================================

describe "parse_mdsoc_sdn backward compat single dimension":
    it "single dimension section still produces one dimension":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension:\n  name: feature\n  key_template: feature/{name}\n"
        sdn = sdn + "  layering:\n    order: [api, app, domain, infra]\n    direction: upper_to_lower"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        expect(manifest.dimensions.len()).to_equal(1)
        val dim = manifest.dimensions[0]
        expect(dim.name).to_equal("feature")

    it "single dimension keeps all fields":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension:\n  name: feature\n  key_template: feature/{name}\n"
        sdn = sdn + "  participation: auto_bind\n"
        sdn = sdn + "  layering:\n    order: [api, domain]\n    direction: upper_to_lower"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val dim = manifest.dimensions[0]
        expect(dim.participation).to_equal("auto_bind")
        expect(dim.layer.order.len()).to_equal(2)

    it "single dimension default kind is horizontal":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension:\n  name: feature\n  key_template: feature/{name}"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val dim = manifest.dimensions[0]
        expect(dim.dimension_kind).to_equal("horizontal")

    it "existing tests: capsule, roots, rules unaffected":
        var sdn = "capsule:\n  name: my-project\n  version: 1.2.0\n"
        sdn = sdn + "\nroots:\n  - name: core\n    path: src/core\n"
        sdn = sdn + "\ndimension:\n  name: feature\n  key_template: feature/{name}\n"
        sdn = sdn + "\nrules:\n  enforce_layering: true\n  reject_cycles: false"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        expect(manifest.name).to_equal("my-project")
        expect(manifest.carets.len()).to_equal(1)
        expect(manifest.rules.reject_cycles).to_equal(false)

# ============================================================================
# dimension_kind field
# ============================================================================

describe "parse_mdsoc_sdn dimension_kind":
    it "dimension_kind horizontal parsed correctly":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension:\n  name: feature\n  key_template: feature/{name}\n"
        sdn = sdn + "  dimension_kind: horizontal"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val dim = manifest.dimensions[0]
        expect(dim.dimension_kind).to_equal("horizontal")

    it "dimension_kind vertical parsed in dimension section":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension:\n  name: construct\n  key_template: construct/{name}\n"
        sdn = sdn + "  dimension_kind: vertical"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val dim = manifest.dimensions[0]
        expect(dim.dimension_kind).to_equal("vertical")

# ============================================================================
# dimension_construct section
# ============================================================================

describe "parse_mdsoc_sdn dimension_construct section":
    it "dimension_construct section parsed as second dimension":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension:\n  name: feature\n  key_template: feature/{name}\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        expect(manifest.dimensions.len()).to_equal(2)

    it "dimension_construct name field parsed":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        expect(manifest.dimensions.len()).to_equal(1)
        val dim = manifest.dimensions[0]
        expect(dim.name).to_equal("construct")

    it "dimension_construct key_template field parsed":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val dim = manifest.dimensions[0]
        expect(dim.key_template).to_equal("construct/{name}")

    it "dimension_construct participation shared_bind parsed":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}\n"
        sdn = sdn + "  participation: shared_bind"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val dim = manifest.dimensions[0]
        expect(dim.participation).to_equal("shared_bind")

    it "dimension_construct dimension_kind vertical parsed":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}\n"
        sdn = sdn + "  dimension_kind: vertical"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val dim = manifest.dimensions[0]
        expect(dim.dimension_kind).to_equal("vertical")

    it "dimension_construct dependency_cycles allow_tier parsed":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}\n"
        sdn = sdn + "  dependency_cycles: allow_tier"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val dim = manifest.dimensions[0]
        expect(dim.dep_cycles).to_equal("allow_tier")

# ============================================================================
# dimension_construct tiers subsection
# ============================================================================

describe "parse_mdsoc_sdn dimension_construct tiers subsection":
    it "tiers order parsed into layer.order":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}\n"
        sdn = sdn + "  tiers:\n    order: [core, flow, decl, advanced, meta]\n    direction: lower_to_upper"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val dim = manifest.dimensions[0]
        expect(dim.layer.order.len()).to_equal(5)

    it "tiers direction lower_to_upper parsed":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}\n"
        sdn = sdn + "  tiers:\n    order: [core, flow, decl, advanced, meta]\n    direction: lower_to_upper"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val dim = manifest.dimensions[0]
        expect(dim.layer.direction.to_text()).to_equal("lower_to_upper")

    it "tiers order contains correct names":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}\n"
        sdn = sdn + "  tiers:\n    order: [core, flow, decl, advanced, meta]"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val dim = manifest.dimensions[0]
        expect(dim.layer.order[0]).to_equal("core")
        expect(dim.layer.order[4]).to_equal("meta")

# ============================================================================
# Two-dimension config
# ============================================================================

describe "parse_mdsoc_sdn two-dimension config":
    it "both feature and construct dimensions present":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension:\n  name: feature\n  key_template: feature/{name}\n"
        sdn = sdn + "  layering:\n    order: [api, app, domain, infra]\n    direction: upper_to_lower\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}\n"
        sdn = sdn + "  participation: shared_bind\n"
        sdn = sdn + "  tiers:\n    order: [core, flow, decl, advanced, meta]\n    direction: lower_to_upper"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        expect(manifest.dimensions.len()).to_equal(2)

    it "feature dimension is parsed correctly in two-dim config":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension:\n  name: feature\n  key_template: feature/{name}\n"
        sdn = sdn + "  layering:\n    order: [api, domain]\n    direction: upper_to_lower\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val feature_dim_opt = manifest.get_dimension("feature")
        val feature_dim = feature_dim_opt ?? DimensionDef.new("", "")
        expect(feature_dim.name).to_equal("feature")
        expect(feature_dim.layer.order.len()).to_equal(2)
        expect(feature_dim.dimension_kind).to_equal("horizontal")

    it "construct dimension is parsed correctly in two-dim config":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension:\n  name: feature\n  key_template: feature/{name}\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}\n"
        sdn = sdn + "  participation: shared_bind\n  dimension_kind: vertical\n"
        sdn = sdn + "  tiers:\n    order: [core, flow, decl, advanced, meta]\n    direction: lower_to_upper"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val construct_dim_opt = manifest.get_dimension("construct")
        val construct_dim = construct_dim_opt ?? DimensionDef.new("", "")
        expect(construct_dim.name).to_equal("construct")
        expect(construct_dim.participation).to_equal("shared_bind")
        expect(construct_dim.dimension_kind).to_equal("vertical")
        expect(construct_dim.layer.order.len()).to_equal(5)
        expect(construct_dim.layer.direction.to_text()).to_equal("lower_to_upper")

    it "dimensions can be looked up by name":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension:\n  name: feature\n  key_template: feature/{name}\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        val f = manifest.get_dimension("feature")
        val c = manifest.get_dimension("construct")
        expect(f).to_be(f)
        expect(c).to_be(c)
        val feature_dim = f ?? DimensionDef.new("", "")
        val construct_dim = c ?? DimensionDef.new("", "")
        expect(feature_dim.name).to_equal("feature")
        expect(construct_dim.name).to_equal("construct")

    it "full two-dim config with all sections":
        var sdn = "capsule:\n  name: my-compiler\n  version: 2.0.0\n"
        sdn = sdn + "\nroots:\n  - name: main\n    path: src\n"
        sdn = sdn + "\ndimension:\n  name: feature\n  key_template: feature/{name}\n"
        sdn = sdn + "  layering:\n    order: [api, app, domain, infra]\n    direction: upper_to_lower\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}\n"
        sdn = sdn + "  participation: shared_bind\n  dimension_kind: vertical\n"
        sdn = sdn + "  dependency_cycles: allow_tier\n"
        sdn = sdn + "  tiers:\n    order: [core, flow, decl, advanced, meta]\n    direction: lower_to_upper\n"
        sdn = sdn + "\nrules:\n  enforce_layering: true\n  reject_cycles: false"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        expect(manifest.name).to_equal("my-compiler")
        expect(manifest.carets.len()).to_equal(1)
        expect(manifest.dimensions.len()).to_equal(2)
        expect(manifest.rules.reject_cycles).to_equal(false)

# ============================================================================
# Only dimension_construct (no dimension section)
# ============================================================================

describe "parse_mdsoc_sdn construct-only config":
    it "dimension_construct alone produces one dimension":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}\n"
        sdn = sdn + "  participation: shared_bind"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        expect(manifest.dimensions.len()).to_equal(1)
        expect(manifest.dimensions[0].name).to_equal("construct")

    it "construct dimension followed by rules section":
        var sdn = "capsule:\n  name: proj\n  version: 0.1.0\n"
        sdn = sdn + "\ndimension_construct:\n  name: construct\n  key_template: construct/{name}\n"
        sdn = sdn + "\nrules:\n  enforce_layering: false"
        val result = parse_mdsoc_sdn(sdn)
        val manifest = result ?? MdsocManifest.new("")
        expect(manifest.dimensions.len()).to_equal(1)
        expect(manifest.rules.enforce_layering).to_equal(false)
