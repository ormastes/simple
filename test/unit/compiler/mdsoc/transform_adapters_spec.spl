describe "Transform Adapters":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Transform Adapter Tests
# #
# # Tests that transform adapter structs construct correctly and that
# # their instance methods return the expected values.
# #
# # Adapters tested:
# #   - TypedAstContext  (typing_to_hir/entity_view/TypedAstView.spl)
# #   - CfgContext       (hir_to_mir/entity_view/HirView.spl)
# #   - MirProgram       (mir_to_backend/entity_view/MirView.spl)
# #   - MirDebugInfo     (mir_to_backend/entity_view/MirView.spl)
# #   - TokenStreamView  (lexing_to_parsing/entity_view/TokenStreamView.spl)
# #   - MirOptView       (mir_to_optimizer/entity_view/MirOptView.spl)
# #   - ObjectFileView   (backend_to_linker/entity_view/ObjectFileView.spl)
# #   - LoadedModuleView (loading_to_parsing/entity_view/LoadedModuleView.spl)
# 
# use compiler.transform.feature.typing_to_hir.entity_view.TypedAstView.{TypedAstContext}
# use compiler.transform.feature.hir_to_mir.entity_view.HirView.{CfgContext}
# use compiler.transform.feature.mir_to_backend.entity_view.MirView.{MirProgram, MirDebugInfo}
# use compiler.transform.feature.lexing_to_parsing.entity_view.TokenStreamView.{TokenStreamView}
# use compiler.transform.feature.mir_to_optimizer.entity_view.MirOptView.{MirOptView}
# use compiler.transform.feature.backend_to_linker.entity_view.ObjectFileView.{ObjectFileView}
# use compiler.transform.feature.loading_to_parsing.entity_view.LoadedModuleView.{LoadedModuleView}
# 
# # ============================================================================
# # TypedAstContext
# # ============================================================================
# 
# describe "TypedAstContext":
#     it "constructs empty context via static factory":
#         val ctx = TypedAstContext__empty()
#         expect(ctx.ast_decl_count).to_equal(0)
#         expect(ctx.symbol_count).to_equal(0)
#         expect(ctx.inferred_type_count).to_equal(0)
# 
#     it "empty context has no types":
#         val ctx = TypedAstContext__empty()
#         expect(ctx.has_types()).to_equal(false)
# 
#     it "empty context has no symbols":
#         val ctx = TypedAstContext__empty()
#         expect(ctx.has_symbols()).to_equal(false)
# 
#     it "empty module name is empty string":
#         val ctx = TypedAstContext__empty()
#         expect(ctx.module_name).to_equal("")
# 
#     it "constructs with data and detects types":
#         val ctx = TypedAstContext(
#             ast_decl_count: 5,
#             symbol_count: 3,
#             inferred_type_count: 8,
#             module_name: "test"
#         )
#         expect(ctx.has_types()).to_equal(true)
# 
#     it "constructs with data and detects symbols":
#         val ctx = TypedAstContext(
#             ast_decl_count: 5,
#             symbol_count: 3,
#             inferred_type_count: 8,
#             module_name: "test"
#         )
#         expect(ctx.has_symbols()).to_equal(true)
# 
#     it "stores module name":
#         val ctx = TypedAstContext(
#             ast_decl_count: 5,
#             symbol_count: 3,
#             inferred_type_count: 8,
#             module_name: "test"
#         )
#         expect(ctx.module_name).to_equal("test")
# 
#     it "stores decl count":
#         val ctx = TypedAstContext(
#             ast_decl_count: 5,
#             symbol_count: 3,
#             inferred_type_count: 8,
#             module_name: "test"
#         )
#         expect(ctx.ast_decl_count).to_equal(5)
# 
#     it "zero inferred types means no types":
#         val ctx = TypedAstContext(
#             ast_decl_count: 2,
#             symbol_count: 0,
#             inferred_type_count: 0,
#             module_name: "empty_types"
#         )
#         expect(ctx.has_types()).to_equal(false)
# 
#     it "zero symbols means no symbols":
#         val ctx = TypedAstContext(
#             ast_decl_count: 2,
#             symbol_count: 0,
#             inferred_type_count: 5,
#             module_name: "no_syms"
#         )
#         expect(ctx.has_symbols()).to_equal(false)
# 
# # ============================================================================
# # CfgContext
# # ============================================================================
# 
# describe "CfgContext":
#     it "creates context for function via static factory":
#         val ctx = CfgContext__for_function("main")
#         expect(ctx.current_fn_name).to_equal("main")
# 
#     it "for_function starts with zero loop depth":
#         val ctx = CfgContext__for_function("main")
#         expect(ctx.loop_depth).to_equal(0)
# 
#     it "for_function is not in loop":
#         val ctx = CfgContext__for_function("main")
#         expect(ctx.in_loop()).to_equal(false)
# 
#     it "for_function sets entry block label":
#         val ctx = CfgContext__for_function("main")
#         expect(ctx.current_block_label).to_equal("entry")
# 
#     it "for_function has empty break stack":
#         val ctx = CfgContext__for_function("main")
#         expect(ctx.current_break_label()).to_equal("")
# 
#     it "for_function has empty continue stack":
#         val ctx = CfgContext__for_function("main")
#         expect(ctx.current_continue_label()).to_equal("")
# 
#     it "constructs with loop depth":
#         val ctx = CfgContext(
#             current_fn_name: "foo",
#             loop_depth: 2,
#             current_block_label: "loop_body",
#             break_label_stack: ["loop_end_0", "loop_end_1"],
#             continue_label_stack: ["loop_start_0", "loop_start_1"]
#         )
#         expect(ctx.in_loop()).to_equal(true)
#         expect(ctx.loop_depth).to_equal(2)
# 
#     it "reports current break label from stack top":
#         val ctx = CfgContext(
#             current_fn_name: "foo",
#             loop_depth: 2,
#             current_block_label: "loop_body",
#             break_label_stack: ["loop_end_0", "loop_end_1"],
#             continue_label_stack: ["loop_start_0", "loop_start_1"]
#         )
#         expect(ctx.current_break_label()).to_equal("loop_end_1")
# 
#     it "reports current continue label from stack top":
#         val ctx = CfgContext(
#             current_fn_name: "foo",
#             loop_depth: 2,
#             current_block_label: "loop_body",
#             break_label_stack: ["loop_end_0", "loop_end_1"],
#             continue_label_stack: ["loop_start_0", "loop_start_1"]
#         )
#         expect(ctx.current_continue_label()).to_equal("loop_start_1")
# 
#     it "loop_depth 1 is in loop":
#         val ctx = CfgContext(
#             current_fn_name: "bar",
#             loop_depth: 1,
#             current_block_label: "loop_body",
#             break_label_stack: ["end"],
#             continue_label_stack: ["start"]
#         )
#         expect(ctx.in_loop()).to_equal(true)
# 
#     it "stores function name":
#         val ctx = CfgContext__for_function("process_items")
#         expect(ctx.current_fn_name).to_equal("process_items")
# 
# # ============================================================================
# # MirProgram - first struct in mir_to_backend/entity_view/MirView.spl
# # ============================================================================
# 
# describe "MirProgram":
#     it "creates empty program via static factory":
#         val prog = MirProgram__empty()
#         expect(prog.function_count).to_equal(0)
# 
#     it "empty program has no functions":
#         val prog = MirProgram__empty()
#         expect(prog.has_functions()).to_equal(false)
# 
#     it "empty program has no extern fns":
#         val prog = MirProgram__empty()
#         expect(prog.has_extern_fns()).to_equal(false)
# 
#     it "empty program uses interpreter target triple":
#         val prog = MirProgram__empty()
#         expect(prog.target_triple).to_equal("interpreter-simple-runtime")
# 
#     it "empty program has zero string literals":
#         val prog = MirProgram__empty()
#         expect(prog.string_literal_count).to_equal(0)
# 
#     it "constructs with functions":
#         val prog = MirProgram(
#             function_count: 2,
#             extern_fn_names: [],
#             string_literal_count: 0,
#             target_triple: "x86_64-linux-gnu"
#         )
#         expect(prog.has_functions()).to_equal(true)
#         expect(prog.function_count).to_equal(2)
# 
#     it "constructs with extern functions":
#         val prog = MirProgram(
#             function_count: 2,
#             extern_fn_names: ["printf", "malloc"],
#             string_literal_count: 3,
#             target_triple: "x86_64-linux-gnu"
#         )
#         expect(prog.has_extern_fns()).to_equal(true)
# 
#     it "stores target triple":
#         val prog = MirProgram(
#             function_count: 1,
#             extern_fn_names: [],
#             string_literal_count: 0,
#             target_triple: "aarch64-linux-gnu"
#         )
#         expect(prog.target_triple).to_equal("aarch64-linux-gnu")
# 
#     it "stores string literal count":
#         val prog = MirProgram(
#             function_count: 1,
#             extern_fn_names: [],
#             string_literal_count: 7,
#             target_triple: "x86_64-linux-gnu"
#         )
#         expect(prog.string_literal_count).to_equal(7)
# 
#     it "no functions returns false for has_functions":
#         val prog = MirProgram(
#             function_count: 0,
#             extern_fn_names: [],
#             string_literal_count: 0,
#             target_triple: "x86_64-linux-gnu"
#         )
#         expect(prog.has_functions()).to_equal(false)
# 
#     it "empty extern names returns false for has_extern_fns":
#         val prog = MirProgram(
#             function_count: 1,
#             extern_fn_names: [],
#             string_literal_count: 0,
#             target_triple: "x86_64-linux-gnu"
#         )
#         expect(prog.has_extern_fns()).to_equal(false)
# 
# # ============================================================================
# # MirDebugInfo - second struct in mir_to_backend/entity_view/MirView.spl
# # ============================================================================
# 
# describe "MirDebugInfo":
#     it "constructs with source file info":
#         val dbg = MirDebugInfo(
#             fn_source_files: ["main.spl", "lib.spl"],
#             fn_start_lines: [1, 10]
#         )
#         expect(dbg.fn_start_lines[0]).to_equal(1)
#         expect(dbg.fn_start_lines[1]).to_equal(10)
# 
#     it "constructs with empty debug info":
#         val dbg = MirDebugInfo(
#             fn_source_files: [],
#             fn_start_lines: []
#         )
#         expect(dbg.fn_source_files.len()).to_equal(0)
# 
# # ============================================================================
# # TokenStreamView - lexing_to_parsing/entity_view/TokenStreamView.spl
# # ============================================================================
# 
# describe "TokenStreamView":
#     it "constructs via static factory from_lexer_output":
#         val view = TokenStreamView__from_lexer_output(
#             [1, 2, 3],
#             ["fn", "main", "("],
#             [1, 1, 1],
#             [0, 3, 7],
#             3,
#             "fn main("
#         )
#         expect(view.token_count).to_equal(3)
#         expect(view.source_text).to_equal("fn main(")
# 
#     it "is_empty returns true when token_count is zero":
#         val view = TokenStreamView(
#             token_tags: [],
#             token_texts: [],
#             token_lines: [],
#             token_cols: [],
#             token_count: 0,
#             source_text: ""
#         )
#         expect(view.is_empty()).to_equal(true)
# 
#     it "is_empty returns false when token_count is nonzero":
#         val view = TokenStreamView__from_lexer_output(
#             [1],
#             ["fn"],
#             [1],
#             [0],
#             1,
#             "fn"
#         )
#         expect(view.is_empty()).to_equal(false)
# 
#     it "get_token_text returns correct text for valid index":
#         val view = TokenStreamView__from_lexer_output(
#             [1, 2, 3],
#             ["fn", "main", "("],
#             [1, 1, 1],
#             [0, 3, 7],
#             3,
#             "fn main("
#         )
#         expect(view.get_token_text(0)).to_equal("fn")
#         expect(view.get_token_text(1)).to_equal("main")
#         expect(view.get_token_text(2)).to_equal("(")
# 
#     it "get_token_text returns empty string for negative index":
#         val view = TokenStreamView__from_lexer_output(
#             [1, 2],
#             ["fn", "main"],
#             [1, 1],
#             [0, 3],
#             2,
#             "fn main"
#         )
#         expect(view.get_token_text(-1)).to_equal("")
# 
#     it "get_token_text returns empty string for index at token_count":
#         val view = TokenStreamView__from_lexer_output(
#             [1, 2],
#             ["fn", "main"],
#             [1, 1],
#             [0, 3],
#             2,
#             "fn main"
#         )
#         expect(view.get_token_text(2)).to_equal("")
# 
#     it "get_token_text returns empty string for index beyond token_count":
#         val view = TokenStreamView__from_lexer_output(
#             [1],
#             ["fn"],
#             [1],
#             [0],
#             1,
#             "fn"
#         )
#         expect(view.get_token_text(99)).to_equal("")
# 
#     it "stores source_text via factory":
#         val view = TokenStreamView__from_lexer_output(
#             [],
#             [],
#             [],
#             [],
#             0,
#             "val x = 1"
#         )
#         expect(view.source_text).to_equal("val x = 1")
# 
#     it "empty view has zero token_count":
#         val view = TokenStreamView__from_lexer_output([], [], [], [], 0, "")
#         expect(view.token_count).to_equal(0)
# 
# # ============================================================================
# # MirOptView - mir_to_optimizer/entity_view/MirOptView.spl
# # ============================================================================
# 
# describe "MirOptView":
#     it "creates empty view with optimization level":
#         val view = MirOptView__empty(2)
#         expect(view.mir_fn_count).to_equal(0)
#         expect(view.optimization_level).to_equal(2)
# 
#     it "empty view has no functions":
#         val view = MirOptView__empty(1)
#         expect(view.has_functions()).to_equal(false)
# 
#     it "empty view is not optimized at level 0":
#         val view = MirOptView__empty(0)
#         expect(view.is_optimized()).to_equal(false)
# 
#     it "empty view is optimized at level 1":
#         val view = MirOptView__empty(1)
#         expect(view.is_optimized()).to_equal(true)
# 
#     it "constructs with functions":
#         val view = MirOptView(
#             mir_fn_count: 5,
#             mir_inst_count: 80,
#             optimization_level: 2
#         )
#         expect(view.has_functions()).to_equal(true)
#         expect(view.mir_fn_count).to_equal(5)
# 
#     it "average_insts_per_fn computes correctly":
#         val view = MirOptView(
#             mir_fn_count: 4,
#             mir_inst_count: 100,
#             optimization_level: 1
#         )
#         expect(view.average_insts_per_fn()).to_equal(25)
# 
#     it "average_insts_per_fn returns 0 for empty view":
#         val view = MirOptView__empty(1)
#         expect(view.average_insts_per_fn()).to_equal(0)
# 
#     it "stores instruction count":
#         val view = MirOptView(
#             mir_fn_count: 2,
#             mir_inst_count: 30,
#             optimization_level: 3
#         )
#         expect(view.mir_inst_count).to_equal(30)
# 
# # ============================================================================
# # ObjectFileView - backend_to_linker/entity_view/ObjectFileView.spl
# # ============================================================================
# 
# describe "ObjectFileView":
#     it "creates failed view":
#         val view = ObjectFileView__failed("x86_64-linux-gnu")
#         expect(view.success).to_equal(false)
#         expect(view.object_byte_count).to_equal(0)
# 
#     it "failed view is empty":
#         val view = ObjectFileView__failed("x86_64-linux-gnu")
#         expect(view.is_empty()).to_equal(true)
# 
#     it "failed view has no symbols":
#         val view = ObjectFileView__failed("x86_64-linux-gnu")
#         expect(view.has_symbols()).to_equal(false)
# 
#     it "creates view from codegen output":
#         val view = ObjectFileView__from_codegen(4096, 8, "x86_64-linux-gnu")
#         expect(view.success).to_equal(true)
#         expect(view.object_byte_count).to_equal(4096)
#         expect(view.symbol_count).to_equal(8)
# 
#     it "codegen view is not empty":
#         val view = ObjectFileView__from_codegen(1024, 3, "aarch64-linux-gnu")
#         expect(view.is_empty()).to_equal(false)
# 
#     it "codegen view has symbols":
#         val view = ObjectFileView__from_codegen(2048, 5, "x86_64-linux-gnu")
#         expect(view.has_symbols()).to_equal(true)
# 
#     it "stores target triple":
#         val view = ObjectFileView__from_codegen(512, 2, "riscv64-linux-gnu")
#         expect(view.target_triple).to_equal("riscv64-linux-gnu")
# 
#     it "constructs directly with zero bytes":
#         val view = ObjectFileView(
#             object_byte_count: 0,
#             symbol_count: 0,
#             target_triple: "x86_64-linux-gnu",
#             success: false
#         )
#         expect(view.is_empty()).to_equal(true)
# 
# # ============================================================================
# # LoadedModuleView - loading_to_parsing/entity_view/LoadedModuleView.spl
# # ============================================================================
# 
# describe "LoadedModuleView":
#     it "creates empty view":
#         val view = LoadedModuleView__empty("my_module")
#         expect(view.module_name).to_equal("my_module")
#         expect(view.byte_count).to_equal(0)
# 
#     it "empty view has no source":
#         val view = LoadedModuleView__empty("test")
#         expect(view.has_source()).to_equal(false)
# 
#     it "empty view is empty":
#         val view = LoadedModuleView__empty("test")
#         expect(view.is_empty()).to_equal(true)
# 
#     it "creates view from source":
#         val view = LoadedModuleView__from_source("math", "src/math.spl", "fn add(a: i64, b: i64) -> i64: a + b")
#         expect(view.module_name).to_equal("math")
#         expect(view.file_path).to_equal("src/math.spl")
# 
#     it "from_source has source":
#         val view = LoadedModuleView__from_source("lib", "lib.spl", "val X = 1")
#         expect(view.has_source()).to_equal(true)
#         expect(view.is_empty()).to_equal(false)
# 
#     it "from_source stores byte count":
#         val src = "fn foo(): 1"
#         val view = LoadedModuleView__from_source("foo", "foo.spl", src)
#         expect(view.byte_count).to_equal(src.len())
# 
#     it "from_source stores source text":
#         val view = LoadedModuleView__from_source("x", "x.spl", "val x = 42")
#         expect(view.source_text).to_equal("val x = 42")
# 
#     it "constructs directly with all fields":
#         val view = LoadedModuleView(
#             module_name: "core",
#             source_text: "# core module",
#             file_path: "core.spl",
#             byte_count: 13
#         )
#         expect(view.module_name).to_equal("core")
#         expect(view.byte_count).to_equal(13)
