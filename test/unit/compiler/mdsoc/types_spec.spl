# NOTE: These tests construct MDSOC types directly.
# Run with: bin/simple test test/unit/compiler/mdsoc/types_spec.spl
#
# Tests for: src/compiler/mdsoc/types.spl
# Covers all structs, enums, and methods in the MDSOC type system.

use compiler.mdsoc.types.*

# ============================================================================
# CapsuleVisibility
# ============================================================================

describe "CapsuleVisibility":
    it "Public is_public returns true":
        val vis = CapsuleVisibility.Public
        expect(vis.is_public()).to_equal(true)

    it "Public is_internal returns false":
        val vis = CapsuleVisibility.Public
        expect(vis.is_internal()).to_equal(false)

    it "Public is_private returns false":
        val vis = CapsuleVisibility.Public
        expect(vis.is_private()).to_equal(false)

    it "Internal is_internal returns true":
        val vis = CapsuleVisibility.Internal
        expect(vis.is_internal()).to_equal(true)

    it "Internal is_public returns false":
        val vis = CapsuleVisibility.Internal
        expect(vis.is_public()).to_equal(false)

    it "Private is_private returns true":
        val vis = CapsuleVisibility.Private
        expect(vis.is_private()).to_equal(true)

    it "Private is_public returns false":
        val vis = CapsuleVisibility.Private
        expect(vis.is_public()).to_equal(false)

    it "Private is_internal returns false":
        val vis = CapsuleVisibility.Private
        expect(vis.is_internal()).to_equal(false)

    it "Public to_text returns public":
        expect(CapsuleVisibility.Public.to_text()).to_equal("public")

    it "Internal to_text returns internal":
        expect(CapsuleVisibility.Internal.to_text()).to_equal("internal")

    it "Private to_text returns private":
        expect(CapsuleVisibility.Private.to_text()).to_equal("private")

# ============================================================================
# CaretId
# ============================================================================

describe "CaretId":
    it "constructs with name and path":
        val caret = CaretId.new("core", "src/core")
        expect(caret.name).to_equal("core")
        expect(caret.path).to_equal("src/core")
        expect(caret.is_default).to_equal(false)

    it "default_caret uses name main":
        val caret = CaretId.default_caret("src/")
        expect(caret.name).to_equal("main")
        expect(caret.path).to_equal("src/")
        expect(caret.is_default).to_equal(true)

    it "caret_prefix prepends caret symbol":
        val caret = CaretId.new("ui", "src/ui")
        expect(caret.caret_prefix()).to_equal("^ui")

    it "default caret prefix is ^main":
        val caret = CaretId.default_caret("src/")
        expect(caret.caret_prefix()).to_equal("^main")

    it "equals compares by name":
        val a = CaretId.new("core", "src/core")
        val b = CaretId.new("core", "other/path")
        expect(a.equals(b)).to_equal(true)

    it "equals returns false for different names":
        val a = CaretId.new("core", "src/core")
        val b = CaretId.new("ui", "src/ui")
        expect(a.equals(b)).to_equal(false)

# ============================================================================
# CaretMapping
# ============================================================================

describe "CaretMapping":
    it "constructs with all fields":
        val mapping = CaretMapping.new("core", "feature/auth/**", "feature/auth")
        expect(mapping.caret_name).to_equal("core")
        expect(mapping.match_pattern).to_equal("feature/auth/**")
        expect(mapping.target_key).to_equal("feature/auth")

    it "matches_path with glob wildcard":
        val mapping = CaretMapping.new("core", "feature/auth/**", "feature/auth")
        expect(mapping.matches_path("feature/auth/login.spl")).to_equal(true)
        expect(mapping.matches_path("feature/auth/register/form.spl")).to_equal(true)

    it "matches_path rejects non-matching paths":
        val mapping = CaretMapping.new("core", "feature/auth/**", "feature/auth")
        expect(mapping.matches_path("feature/billing/pay.spl")).to_equal(false)

    it "matches_path with exact match (no glob)":
        val mapping = CaretMapping.new("core", "feature/auth", "feature/auth")
        expect(mapping.matches_path("feature/auth")).to_equal(true)
        expect(mapping.matches_path("feature/auth/sub")).to_equal(false)

    it "matches_path base prefix includes slash":
        val mapping = CaretMapping.new("ui", "ui_feature/auth/**", "feature/auth")
        expect(mapping.matches_path("ui_feature/auth/view.spl")).to_equal(true)
        expect(mapping.matches_path("ui_feature/billing/view.spl")).to_equal(false)

# ============================================================================
# LayerDirection
# ============================================================================

describe "LayerDirection":
    it "UpperToLower to_text":
        val dir = LayerDirection.UpperToLower
        expect(dir.to_text()).to_equal("upper_to_lower")

    it "LowerToUpper to_text":
        val dir = LayerDirection.LowerToUpper
        expect(dir.to_text()).to_equal("lower_to_upper")

# ============================================================================
# LayerDef
# ============================================================================

describe "LayerDef":
    it "empty creates no layers":
        val layer = LayerDef.empty()
        expect(layer.order.len()).to_equal(0)
        expect(layer.allow_same_layer).to_equal(true)
        expect(layer.allow_adjacent_only).to_equal(false)

    it "new creates with order and direction":
        val order = ["api", "app", "domain", "infra"]
        val layer = LayerDef.new(order, LayerDirection.UpperToLower)
        expect(layer.order.len()).to_equal(4)
        expect(layer.allow_same_layer).to_equal(true)

    it "get_level returns correct index":
        val layer = LayerDef.new(["api", "app", "domain", "infra"], LayerDirection.UpperToLower)
        expect(layer.get_level("api")).to_equal(0)
        expect(layer.get_level("app")).to_equal(1)
        expect(layer.get_level("domain")).to_equal(2)
        expect(layer.get_level("infra")).to_equal(3)

    it "get_level returns -1 for unknown":
        val layer = LayerDef.new(["api", "app"], LayerDirection.UpperToLower)
        expect(layer.get_level("unknown")).to_equal(-1)

    it "has_layer returns true for known layers":
        val layer = LayerDef.new(["api", "app", "domain"], LayerDirection.UpperToLower)
        expect(layer.has_layer("api")).to_equal(true)
        expect(layer.has_layer("domain")).to_equal(true)

    it "has_layer returns false for unknown":
        val layer = LayerDef.new(["api", "app"], LayerDirection.UpperToLower)
        expect(layer.has_layer("infra")).to_equal(false)

    it "layer_count returns length":
        val layer = LayerDef.new(["api", "app", "domain"], LayerDirection.UpperToLower)
        expect(layer.layer_count()).to_equal(3)

    it "empty layer_count is zero":
        val layer = LayerDef.empty()
        expect(layer.layer_count()).to_equal(0)

describe "LayerDef can_depend UpperToLower":
    it "allows upper to depend on lower":
        val layer = LayerDef.new(["api", "app", "domain", "infra"], LayerDirection.UpperToLower)
        # api (0) -> app (1): upper depends on lower = allowed
        expect(layer.can_depend("api", "app")).to_equal(true)
        # api (0) -> infra (3): upper depends on lower = allowed
        expect(layer.can_depend("api", "infra")).to_equal(true)

    it "denies lower depending on upper":
        val layer = LayerDef.new(["api", "app", "domain", "infra"], LayerDirection.UpperToLower)
        # infra (3) -> api (0): lower depends on upper = denied
        expect(layer.can_depend("infra", "api")).to_equal(false)
        # domain (2) -> app (1): lower depends on upper = denied
        expect(layer.can_depend("domain", "app")).to_equal(false)

    it "allows same layer by default":
        val layer = LayerDef.new(["api", "app"], LayerDirection.UpperToLower)
        expect(layer.can_depend("app", "app")).to_equal(true)

    it "denies same layer when disabled":
        var layer = LayerDef.new(["api", "app"], LayerDirection.UpperToLower)
        layer.allow_same_layer = false
        expect(layer.can_depend("app", "app")).to_equal(false)

    it "allows unknown layers (no restriction)":
        val layer = LayerDef.new(["api", "app"], LayerDirection.UpperToLower)
        # unknown -> api: unrestricted
        expect(layer.can_depend("unknown", "api")).to_equal(true)
        # api -> unknown: unrestricted
        expect(layer.can_depend("api", "unknown")).to_equal(true)

describe "LayerDef can_depend LowerToUpper":
    it "allows lower to depend on upper":
        val layer = LayerDef.new(["api", "app", "domain", "infra"], LayerDirection.LowerToUpper)
        # infra (3) -> api (0): lower depends on upper = allowed
        expect(layer.can_depend("infra", "api")).to_equal(true)
        # domain (2) -> app (1): lower depends on upper = allowed
        expect(layer.can_depend("domain", "app")).to_equal(true)

    it "denies upper depending on lower":
        val layer = LayerDef.new(["api", "app", "domain", "infra"], LayerDirection.LowerToUpper)
        # api (0) -> infra (3): upper depends on lower = denied
        expect(layer.can_depend("api", "infra")).to_equal(false)

describe "LayerDef adjacent_only mode":
    it "allows adjacent layers only (UpperToLower)":
        var layer = LayerDef.new(["api", "app", "domain", "infra"], LayerDirection.UpperToLower)
        layer.allow_adjacent_only = true
        # api (0) -> app (1): adjacent = allowed
        expect(layer.can_depend("api", "app")).to_equal(true)
        # api (0) -> domain (2): skip = denied
        expect(layer.can_depend("api", "domain")).to_equal(false)
        # api (0) -> infra (3): skip = denied
        expect(layer.can_depend("api", "infra")).to_equal(false)
        # app (1) -> domain (2): adjacent = allowed
        expect(layer.can_depend("app", "domain")).to_equal(true)

    it "allows adjacent layers only (LowerToUpper)":
        var layer = LayerDef.new(["api", "app", "domain", "infra"], LayerDirection.LowerToUpper)
        layer.allow_adjacent_only = true
        # infra (3) -> domain (2): adjacent = allowed
        expect(layer.can_depend("infra", "domain")).to_equal(true)
        # infra (3) -> api (0): skip = denied
        expect(layer.can_depend("infra", "api")).to_equal(false)
        # domain (2) -> app (1): adjacent = allowed
        expect(layer.can_depend("domain", "app")).to_equal(true)

describe "LayerDef describe_violation":
    it "describes same-layer violation":
        var layer = LayerDef.new(["api", "app"], LayerDirection.UpperToLower)
        layer.allow_same_layer = false
        val msg = layer.describe_violation("app", "app")
        expect(msg).to_contain("same-layer dependency")
        expect(msg).to_contain("app")

    it "describes cross-layer violation with levels":
        val layer = LayerDef.new(["api", "app", "domain", "infra"], LayerDirection.UpperToLower)
        val msg = layer.describe_violation("infra", "api")
        expect(msg).to_contain("infra")
        expect(msg).to_contain("api")
        expect(msg).to_contain("level")

# ============================================================================
# VirtualCapsule
# ============================================================================

describe "VirtualCapsule":
    it "constructs with name, dimension, layer":
        val cap = VirtualCapsule.new("auth", "feature", "domain")
        expect(cap.name).to_equal("auth")
        expect(cap.dimension).to_equal("feature")
        expect(cap.layer).to_equal("domain")
        expect(cap.bindings.len()).to_equal(0)
        expect(cap.exports.len()).to_equal(0)

    it "capsule_id returns dimension/name":
        val cap = VirtualCapsule.new("auth", "feature", "domain")
        expect(cap.capsule_id()).to_equal("feature/auth")

    it "capsule_id for platform dimension":
        val cap = VirtualCapsule.new("linux", "platform", "infra")
        expect(cap.capsule_id()).to_equal("platform/linux")

describe "VirtualCapsule bindings":
    it "find_binding returns nil for empty capsule":
        val cap = VirtualCapsule.new("auth", "feature", "domain")
        val result = cap.find_binding("core_auth")
        expect(result).to_be_nil()

    it "find_binding returns matching binding":
        var cap = VirtualCapsule.new("auth", "feature", "domain")
        cap.bindings = [SurfaceBinding.new("core", "feature/auth/login.spl", "core_auth")]
        val result = cap.find_binding("core_auth")
        expect(result).to_be(result)
        val binding = result ?? SurfaceBinding.new("", "", "")
        expect(binding.alias).to_equal("core_auth")
        expect(binding.source_caret).to_equal("core")

    it "find_binding returns nil for no match":
        var cap = VirtualCapsule.new("auth", "feature", "domain")
        cap.bindings = [SurfaceBinding.new("core", "feature/auth/login.spl", "core_auth")]
        val result = cap.find_binding("ui_auth")
        expect(result).to_be_nil()

    it "has_binding_from returns true when caret present":
        var cap = VirtualCapsule.new("auth", "feature", "domain")
        cap.bindings = [SurfaceBinding.new("core", "feature/auth/login.spl", "core_auth")]
        expect(cap.has_binding_from("core")).to_equal(true)

    it "has_binding_from returns false when caret absent":
        var cap = VirtualCapsule.new("auth", "feature", "domain")
        cap.bindings = [SurfaceBinding.new("core", "feature/auth/login.spl", "core_auth")]
        expect(cap.has_binding_from("ui")).to_equal(false)

describe "VirtualCapsule exports":
    it "find_export returns nil for empty capsule":
        val cap = VirtualCapsule.new("auth", "feature", "domain")
        val result = cap.find_export("login")
        expect(result).to_be_nil()

    it "find_export returns matching export":
        var cap = VirtualCapsule.new("auth", "feature", "domain")
        cap.exports = [CapsuleExport.public_export("core_auth", "login")]
        val result = cap.find_export("login")
        val exp = result ?? CapsuleExport.public_export("", "")
        expect(exp.symbol_name).to_equal("login")
        expect(exp.binding_alias).to_equal("core_auth")

    it "public_exports filters public only":
        var cap = VirtualCapsule.new("auth", "feature", "domain")
        cap.exports = [
            CapsuleExport.public_export("a", "login"),
            CapsuleExport.internal_export("b", "helper"),
            CapsuleExport.public_export("c", "logout")
        ]
        val pub_list = cap.public_exports()
        expect(pub_list.len()).to_equal(2)

    it "internal_exports filters internal only":
        var cap = VirtualCapsule.new("auth", "feature", "domain")
        cap.exports = [
            CapsuleExport.public_export("a", "login"),
            CapsuleExport.internal_export("b", "helper"),
            CapsuleExport.internal_export("c", "utils")
        ]
        val int_exports = cap.internal_exports()
        expect(int_exports.len()).to_equal(2)

# ============================================================================
# SurfaceBinding
# ============================================================================

describe "SurfaceBinding":
    it "constructs with caret, path, alias":
        val binding = SurfaceBinding.new("core", "feature/auth/login.spl", "core_auth")
        expect(binding.source_caret).to_equal("core")
        expect(binding.source_path).to_equal("feature/auth/login.spl")
        expect(binding.alias).to_equal("core_auth")

    it "different bindings have different aliases":
        val a = SurfaceBinding.new("core", "auth.spl", "core_auth")
        val b = SurfaceBinding.new("ui", "auth.spl", "ui_auth")
        expect(a.alias).to_equal("core_auth")
        expect(b.alias).to_equal("ui_auth")
        expect(a.source_caret).to_equal("core")
        expect(b.source_caret).to_equal("ui")

# ============================================================================
# CapsuleExport
# ============================================================================

describe "CapsuleExport":
    it "public_export creates Public visibility":
        val exp = CapsuleExport.public_export("core_auth", "login")
        expect(exp.visibility.is_public()).to_equal(true)
        expect(exp.binding_alias).to_equal("core_auth")
        expect(exp.symbol_name).to_equal("login")

    it "internal_export creates Internal visibility":
        val exp = CapsuleExport.internal_export("core_auth", "helper")
        expect(exp.visibility.is_internal()).to_equal(true)

    it "qualified_name joins alias and symbol":
        val exp = CapsuleExport.public_export("core_auth", "login")
        expect(exp.qualified_name()).to_equal("core_auth.login")

    it "is_accessible_from_capsule for Public":
        val exp = CapsuleExport.public_export("a", "sym")
        expect(exp.is_accessible_from_capsule()).to_equal(true)

    it "is_accessible_from_capsule for Internal":
        val exp = CapsuleExport.internal_export("a", "sym")
        expect(exp.is_accessible_from_capsule()).to_equal(true)

    it "is_accessible_from_capsule for Private":
        val exp = CapsuleExport.private_export("a", "sym")
        expect(exp.is_accessible_from_capsule()).to_equal(false)

# ============================================================================
# BypassGrant
# ============================================================================

describe "BypassGrant":
    it "constructs with all fields":
        val grant = BypassGrant.new(
            "infra/db",
            "raw_query",
            "domain->infra",
            "performance critical",
            "infra/db.spl:10"
        )
        expect(grant.granting_module).to_equal("infra/db")
        expect(grant.granted_symbol).to_equal("raw_query")
        expect(grant.layer_edge).to_equal("domain->infra")
        expect(grant.reason).to_equal("performance critical")
        expect(grant.location).to_equal("infra/db.spl:10")

    it "grant_key joins module and symbol":
        val grant = BypassGrant.new(
            "infra/db",
            "raw_query",
            "domain->infra",
            "perf",
            "db.spl:10"
        )
        expect(grant.grant_key()).to_equal("infra/db::raw_query")

    it "grant_key is deterministic":
        val a = BypassGrant.new("mod", "sym", "e", "r", "l")
        val b = BypassGrant.new("mod", "sym", "e2", "r2", "l2")
        expect(a.grant_key()).to_equal(b.grant_key())

# ============================================================================
# CapsuleRules
# ============================================================================

describe "CapsuleRules":
    it "strict enables all enforcement":
        val rules = CapsuleRules.strict()
        expect(rules.enforce_layering).to_equal(true)
        expect(rules.reject_cycles).to_equal(true)
        expect(rules.forbid_implicit_merge).to_equal(true)
        expect(rules.require_explicit_bind).to_equal(true)

    it "permissive disables all enforcement":
        val rules = CapsuleRules.permissive()
        expect(rules.enforce_layering).to_equal(false)
        expect(rules.reject_cycles).to_equal(false)
        expect(rules.forbid_implicit_merge).to_equal(false)
        expect(rules.require_explicit_bind).to_equal(false)

    it "default_rules returns strict":
        val rules = CapsuleRules.default_rules()
        expect(rules.enforce_layering).to_equal(true)
        expect(rules.reject_cycles).to_equal(true)
        expect(rules.forbid_implicit_merge).to_equal(true)
        expect(rules.require_explicit_bind).to_equal(true)

# ============================================================================
# MdsocManifest
# ============================================================================

describe "MdsocManifest":
    it "constructs with name and defaults":
        val manifest = MdsocManifest.new("my-project")
        expect(manifest.name).to_equal("my-project")
        expect(manifest.version).to_equal("0.1.0")
        expect(manifest.carets.len()).to_equal(0)
        expect(manifest.dimensions.len()).to_equal(0)
        expect(manifest.capsules.len()).to_equal(0)
        expect(manifest.bypass_grants.len()).to_equal(0)
        # default rules are strict
        expect(manifest.rules.enforce_layering).to_equal(true)

    it "get_caret returns nil when empty":
        val manifest = MdsocManifest.new("proj")
        val result = manifest.get_caret("core")
        expect(result).to_be_nil()

    it "get_caret returns matching caret":
        var manifest = MdsocManifest.new("proj")
        manifest.carets = [CaretId.new("core", "src/core"), CaretId.new("ui", "src/ui")]
        val result = manifest.get_caret("ui")
        val caret = result ?? CaretId.default_caret("")
        expect(caret.name).to_equal("ui")
        expect(caret.path).to_equal("src/ui")

    it "get_caret returns nil for non-existent":
        var manifest = MdsocManifest.new("proj")
        manifest.carets = [CaretId.new("core", "src/core")]
        val result = manifest.get_caret("infra")
        expect(result).to_be_nil()

    it "get_dimension returns matching dimension":
        var manifest = MdsocManifest.new("proj")
        manifest.dimensions = [DimensionDef.new("feature", "feature/" + r"{name}")]
        val result = manifest.get_dimension("feature")
        val dim = result ?? DimensionDef.new("", "")
        expect(dim.name).to_equal("feature")
        expect(dim.key_template).to_equal("feature/" + r"{name}")

    it "get_dimension returns nil for non-existent":
        val manifest = MdsocManifest.new("proj")
        val result = manifest.get_dimension("platform")
        expect(result).to_be_nil()

    it "get_capsule returns matching capsule":
        var manifest = MdsocManifest.new("proj")
        manifest.capsules = [VirtualCapsule.new("auth", "feature", "domain")]
        val result = manifest.get_capsule("auth")
        val cap = result ?? VirtualCapsule.new("", "", "")
        expect(cap.name).to_equal("auth")
        expect(cap.dimension).to_equal("feature")

    it "get_capsule returns nil for non-existent":
        val manifest = MdsocManifest.new("proj")
        val result = manifest.get_capsule("billing")
        expect(result).to_be_nil()

    it "find_bypass_grant returns matching grant":
        var manifest = MdsocManifest.new("proj")
        manifest.bypass_grants = [BypassGrant.new("mod", "raw_query", "e", "r", "l")]
        val result = manifest.find_bypass_grant("raw_query")
        val grant = result ?? BypassGrant.new("", "", "", "", "")
        expect(grant.granted_symbol).to_equal("raw_query")

    it "find_bypass_grant returns nil for no match":
        val manifest = MdsocManifest.new("proj")
        val result = manifest.find_bypass_grant("nonexistent")
        expect(result).to_be_nil()

    it "find_capsule_by_id matches dimension/name":
        var manifest = MdsocManifest.new("proj")
        manifest.capsules = [VirtualCapsule.new("auth", "feature", "domain")]
        val result = manifest.find_capsule_by_id("feature/auth")
        val cap = result ?? VirtualCapsule.new("", "", "")
        expect(cap.name).to_equal("auth")

    it "find_capsule_by_id returns nil for wrong id":
        var manifest = MdsocManifest.new("proj")
        manifest.capsules = [VirtualCapsule.new("auth", "feature", "domain")]
        val result = manifest.find_capsule_by_id("platform/auth")
        expect(result).to_be_nil()

# ============================================================================
# DimensionDef
# ============================================================================

describe "DimensionDef":
    it "new sets defaults":
        val dim = DimensionDef.new("feature", "feature/" + r"{name}")
        expect(dim.name).to_equal("feature")
        expect(dim.key_template).to_equal("feature/" + r"{name}")
        expect(dim.surface_file).to_equal("__init__.spl")
        expect(dim.participation).to_equal("explicit_bind_only")
        expect(dim.intra_access).to_equal("via_surface_only")
        expect(dim.symbol_merge).to_equal("forbid_implicit")
        expect(dim.dep_cycles).to_equal("reject")
        expect(dim.mappings.len()).to_equal(0)

    it "expand_key substitutes name":
        val dim = DimensionDef.new("feature", "feature/" + r"{name}")
        expect(dim.expand_key("auth")).to_equal("feature/auth")
        expect(dim.expand_key("billing")).to_equal("feature/billing")

    it "expand_key with nested template":
        val dim = DimensionDef.new("platform", "platform/" + r"{name}" + "/driver")
        expect(dim.expand_key("linux")).to_equal("platform/linux/driver")

    it "is_explicit_bind returns true for default":
        val dim = DimensionDef.new("feature", "feature/" + r"{name}")
        expect(dim.is_explicit_bind()).to_equal(true)

    it "is_explicit_bind returns false for other participation":
        var dim = DimensionDef.new("feature", "feature/" + r"{name}")
        dim.participation = "auto_bind"
        expect(dim.is_explicit_bind()).to_equal(false)

    it "rejects_cycles returns true for default":
        val dim = DimensionDef.new("feature", "feature/" + r"{name}")
        expect(dim.rejects_cycles()).to_equal(true)

    it "rejects_cycles returns false for allow":
        var dim = DimensionDef.new("feature", "feature/" + r"{name}")
        dim.dep_cycles = "allow"
        expect(dim.rejects_cycles()).to_equal(false)

    it "find_mapping returns matching mapping":
        var dim = DimensionDef.new("feature", "feature/" + r"{name}")
        dim.mappings = [
            CaretMapping.new("core", "feature/**", "feature"),
            CaretMapping.new("ui", "ui_feature/**", "feature")
        ]
        val result = dim.find_mapping("ui")
        val mapping = result ?? CaretMapping.new("", "", "")
        expect(mapping.caret_name).to_equal("ui")
        expect(mapping.match_pattern).to_equal("ui_feature/**")

    it "find_mapping returns nil for no match":
        val dim = DimensionDef.new("feature", "feature/" + r"{name}")
        val result = dim.find_mapping("unknown")
        expect(result).to_be_nil()
