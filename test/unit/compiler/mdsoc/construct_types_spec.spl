# Tests for construct dimension types.
# Run with: bin/simple test test/unit/compiler/mdsoc/construct_types_spec.spl
#
# Tests for: src/compiler/85.mdsoc/mdsoc/types.spl (construct section)
# Covers ConstructKind, ConstructTier, SharedBinding, ConstructCapsule,
# CrossDimensionQuery, CrossDimensionResult.

use compiler.mdsoc.types.*

# ============================================================================
# ConstructKind
# ============================================================================

describe "ConstructKind to_text":
    it "Func returns func":
        expect(ConstructKind.Func.to_text()).to_equal("func")

    it "ClassStruct returns class_struct":
        expect(ConstructKind.ClassStruct.to_text()).to_equal("class_struct")

    it "Enum returns enum":
        expect(ConstructKind.Enum.to_text()).to_equal("enum")

    it "Trait returns trait":
        expect(ConstructKind.Trait.to_text()).to_equal("trait")

    it "Variable returns variable":
        expect(ConstructKind.Variable.to_text()).to_equal("variable")

    it "Control returns control":
        expect(ConstructKind.Control.to_text()).to_equal("control")

    it "Match returns match":
        expect(ConstructKind.Match.to_text()).to_equal("match")

    it "Expr returns expr":
        expect(ConstructKind.Expr.to_text()).to_equal("expr")

    it "Async returns async":
        expect(ConstructKind.Async.to_text()).to_equal("async")

    it "Block returns block":
        expect(ConstructKind.Block.to_text()).to_equal("block")

    it "Module returns module":
        expect(ConstructKind.Module.to_text()).to_equal("module")

    it "Asm returns asm":
        expect(ConstructKind.Asm.to_text()).to_equal("asm")

describe "ConstructKind from_text":
    it "func parses to Func":
        val result = ConstructKind.from_text("func")
        val kind = result ?? ConstructKind.Expr
        expect(kind.to_text()).to_equal("func")

    it "trait parses to Trait":
        val result = ConstructKind.from_text("trait")
        val kind = result ?? ConstructKind.Expr
        expect(kind.to_text()).to_equal("trait")

    it "unknown returns nil":
        val result = ConstructKind.from_text("unknown_kind")
        expect(result).to_be_nil()

    it "all 12 kinds round-trip":
        val names = ["func", "class_struct", "enum", "trait", "variable",
                     "control", "match", "expr", "async", "block", "module", "asm"]
        for name in names:
            val parsed = ConstructKind.from_text(name)
            val kind = parsed ?? ConstructKind.Expr
            expect(kind.to_text()).to_equal(name)

# ============================================================================
# ConstructTier
# ============================================================================

describe "ConstructTier to_text":
    it "Core returns core":
        expect(ConstructTier.Core.to_text()).to_equal("core")

    it "Flow returns flow":
        expect(ConstructTier.Flow.to_text()).to_equal("flow")

    it "Decl returns decl":
        expect(ConstructTier.Decl.to_text()).to_equal("decl")

    it "Advanced returns advanced":
        expect(ConstructTier.Advanced.to_text()).to_equal("advanced")

    it "Meta returns meta":
        expect(ConstructTier.Meta.to_text()).to_equal("meta")

describe "ConstructTier tier_level ordering":
    it "Core level is 0":
        expect(ConstructTier.Core.tier_level()).to_equal(0)

    it "Flow level is 1":
        expect(ConstructTier.Flow.tier_level()).to_equal(1)

    it "Decl level is 2":
        expect(ConstructTier.Decl.tier_level()).to_equal(2)

    it "Advanced level is 3":
        expect(ConstructTier.Advanced.tier_level()).to_equal(3)

    it "Meta level is 4":
        expect(ConstructTier.Meta.tier_level()).to_equal(4)

    it "tiers are strictly ordered":
        val core = ConstructTier.Core.tier_level()
        val flow = ConstructTier.Flow.tier_level()
        val decl = ConstructTier.Decl.tier_level()
        val adv = ConstructTier.Advanced.tier_level()
        val meta = ConstructTier.Meta.tier_level()
        expect(core < flow).to_equal(true)
        expect(flow < decl).to_equal(true)
        expect(decl < adv).to_equal(true)
        expect(adv < meta).to_equal(true)

describe "ConstructTier from_text":
    it "core parses to Core":
        val result = ConstructTier.from_text("core")
        val tier = result ?? ConstructTier.Meta
        expect(tier.to_text()).to_equal("core")

    it "advanced parses to Advanced":
        val result = ConstructTier.from_text("advanced")
        val tier = result ?? ConstructTier.Core
        expect(tier.to_text()).to_equal("advanced")

    it "unknown returns nil":
        val result = ConstructTier.from_text("invalid_tier")
        expect(result).to_be_nil()

    it "all 5 tiers round-trip":
        val names = ["core", "flow", "decl", "advanced", "meta"]
        for name in names:
            val parsed = ConstructTier.from_text(name)
            val tier = parsed ?? ConstructTier.Core
            expect(tier.to_text()).to_equal(name)

# ============================================================================
# SharedBinding
# ============================================================================

describe "SharedBinding":
    it "constructs with path, primary, layer":
        val sb = SharedBinding.new("10.frontend/core/ast.spl", "func", 10)
        expect(sb.source_path).to_equal("10.frontend/core/ast.spl")
        expect(sb.primary_construct).to_equal("func")
        expect(sb.layer_number).to_equal(10)
        expect(sb.construct_tags.len()).to_equal(0)

    it "is_primary_for returns true when matching":
        val sb = SharedBinding.new("parser.spl", "func", 10)
        expect(sb.is_primary_for("func")).to_equal(true)

    it "is_primary_for returns false when not matching":
        val sb = SharedBinding.new("parser.spl", "func", 10)
        expect(sb.is_primary_for("class_struct")).to_equal(false)

    it "has_tag returns false for empty tags":
        val sb = SharedBinding.new("ast.spl", "func", 10)
        expect(sb.has_tag("func")).to_equal(false)

    it "has_tag returns true when tag present":
        var sb = SharedBinding.new("ast.spl", "func", 10)
        sb.construct_tags = ["func", "class_struct", "enum"]
        expect(sb.has_tag("class_struct")).to_equal(true)

    it "has_tag returns false when tag absent":
        var sb = SharedBinding.new("ast.spl", "func", 10)
        sb.construct_tags = ["func", "class_struct"]
        expect(sb.has_tag("trait")).to_equal(false)

# ============================================================================
# ConstructCapsule
# ============================================================================

describe "ConstructCapsule construction":
    it "new creates capsule with empty collections":
        val cap = ConstructCapsule.new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        expect(cap.name).to_equal("trait")
        expect(cap.kind.to_text()).to_equal("trait")
        expect(cap.tier.to_text()).to_equal("advanced")
        expect(cap.exclusive_files.len()).to_equal(0)
        expect(cap.shared_bindings.len()).to_equal(0)
        expect(cap.depends_on.len()).to_equal(0)

    it "block capsule has block tier":
        val cap = ConstructCapsule.new("block", ConstructKind.Block, ConstructTier.Advanced)
        expect(cap.name).to_equal("block")
        expect(cap.tier.to_text()).to_equal("advanced")

    it "variable capsule has core tier":
        val cap = ConstructCapsule.new("variable", ConstructKind.Variable, ConstructTier.Core)
        expect(cap.tier.to_text()).to_equal("core")

describe "ConstructCapsule file_count":
    it "empty capsule has zero files":
        val cap = ConstructCapsule.new("expr", ConstructKind.Expr, ConstructTier.Core)
        expect(cap.file_count()).to_equal(0)

    it "file_count sums exclusive and shared":
        var cap = ConstructCapsule.new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        cap.exclusive_files = ["25.traits/traits.spl", "25.traits/solver.spl"]
        cap.shared_bindings = [SharedBinding.new("10.frontend/ast.spl", "trait", 10)]
        expect(cap.file_count()).to_equal(3)

describe "ConstructCapsule has_exclusive_file":
    it "returns false for empty capsule":
        val cap = ConstructCapsule.new("func", ConstructKind.Func, ConstructTier.Decl)
        expect(cap.has_exclusive_file("some/file.spl")).to_equal(false)

    it "returns true when file present":
        var cap = ConstructCapsule.new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        cap.exclusive_files = ["25.traits/traits.spl", "25.traits/solver.spl"]
        expect(cap.has_exclusive_file("25.traits/traits.spl")).to_equal(true)

    it "returns false when file absent":
        var cap = ConstructCapsule.new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        cap.exclusive_files = ["25.traits/traits.spl"]
        expect(cap.has_exclusive_file("25.traits/coherence.spl")).to_equal(false)

describe "ConstructCapsule find_shared_binding":
    it "returns nil for empty capsule":
        val cap = ConstructCapsule.new("func", ConstructKind.Func, ConstructTier.Decl)
        val result = cap.find_shared_binding("ast.spl")
        expect(result).to_be_nil()

    it "returns matching binding":
        var cap = ConstructCapsule.new("func", ConstructKind.Func, ConstructTier.Decl)
        cap.shared_bindings = [SharedBinding.new("10.frontend/ast.spl", "func", 10)]
        val result = cap.find_shared_binding("10.frontend/ast.spl")
        val sb = result ?? SharedBinding.new("", "", 0)
        expect(sb.source_path).to_equal("10.frontend/ast.spl")

    it "returns nil for no match":
        var cap = ConstructCapsule.new("func", ConstructKind.Func, ConstructTier.Decl)
        cap.shared_bindings = [SharedBinding.new("10.frontend/ast.spl", "func", 10)]
        val result = cap.find_shared_binding("50.mir/mir_data.spl")
        expect(result).to_be_nil()

describe "ConstructCapsule depends_on_construct":
    it "returns false for empty depends_on":
        val cap = ConstructCapsule.new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        expect(cap.depends_on_construct("func")).to_equal(false)

    it "returns true when dependency listed":
        var cap = ConstructCapsule.new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        cap.depends_on = ["func", "class_struct", "expr"]
        expect(cap.depends_on_construct("func")).to_equal(true)
        expect(cap.depends_on_construct("class_struct")).to_equal(true)

    it "returns false when dependency not listed":
        var cap = ConstructCapsule.new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        cap.depends_on = ["func", "class_struct"]
        expect(cap.depends_on_construct("async")).to_equal(false)

# ============================================================================
# CrossDimensionQuery
# ============================================================================

describe "CrossDimensionQuery construction":
    it "new sets all fields":
        val q = CrossDimensionQuery.new("feature/parser", "trait", 10, 35)
        expect(q.feature_filter).to_equal("feature/parser")
        expect(q.construct_filter).to_equal("trait")
        expect(q.layer_min).to_equal(10)
        expect(q.layer_max).to_equal(35)

    it "for_construct sets only construct filter":
        val q = CrossDimensionQuery.for_construct("async")
        expect(q.construct_filter).to_equal("async")
        expect(q.feature_filter).to_equal("")
        expect(q.layer_min).to_equal(-1)

    it "for_feature sets only feature filter":
        val q = CrossDimensionQuery.for_feature("parser")
        expect(q.feature_filter).to_equal("parser")
        expect(q.construct_filter).to_equal("")

describe "CrossDimensionQuery filter detection":
    it "has_feature_filter returns true when set":
        val q = CrossDimensionQuery.new("parser", "", -1, 999)
        expect(q.has_feature_filter()).to_equal(true)

    it "has_feature_filter returns false when empty":
        val q = CrossDimensionQuery.for_construct("trait")
        expect(q.has_feature_filter()).to_equal(false)

    it "has_construct_filter returns true when set":
        val q = CrossDimensionQuery.new("", "trait", -1, 999)
        expect(q.has_construct_filter()).to_equal(true)

    it "has_construct_filter returns false when empty":
        val q = CrossDimensionQuery.for_feature("parser")
        expect(q.has_construct_filter()).to_equal(false)

    it "has_layer_filter returns false for default range":
        val q = CrossDimensionQuery.new("", "trait", -1, 999)
        expect(q.has_layer_filter()).to_equal(false)

    it "has_layer_filter returns true when min set":
        val q = CrossDimensionQuery.new("", "trait", 10, 999)
        expect(q.has_layer_filter()).to_equal(true)

    it "has_layer_filter returns true when max set":
        val q = CrossDimensionQuery.new("", "trait", -1, 50)
        expect(q.has_layer_filter()).to_equal(true)

# ============================================================================
# CrossDimensionResult
# ============================================================================

describe "CrossDimensionResult":
    it "empty creates zero result":
        val r = CrossDimensionResult.empty()
        expect(r.matching_files.len()).to_equal(0)
        expect(r.exclusive_count).to_equal(0)
        expect(r.shared_count).to_equal(0)

    it "total_count sums matching files":
        var r = CrossDimensionResult.empty()
        r.matching_files = ["a.spl", "b.spl", "c.spl"]
        expect(r.total_count()).to_equal(3)

    it "has_results returns false for empty":
        val r = CrossDimensionResult.empty()
        expect(r.has_results()).to_equal(false)

    it "has_results returns true when files present":
        var r = CrossDimensionResult.empty()
        r.matching_files = ["traits.spl"]
        expect(r.has_results()).to_equal(true)

# ============================================================================
# DimensionDef dimension_kind field
# ============================================================================

describe "DimensionDef dimension_kind":
    it "default dimension_kind is horizontal":
        val dim = DimensionDef.new("feature", "feature/{name}")
        expect(dim.dimension_kind).to_equal("horizontal")

    it "dimension_kind can be set to vertical":
        var dim = DimensionDef.new("construct", "construct/{name}")
        dim.dimension_kind = "vertical"
        expect(dim.dimension_kind).to_equal("vertical")

    it "horizontal dimension still has all other defaults":
        val dim = DimensionDef.new("feature", "feature/{name}")
        expect(dim.participation).to_equal("explicit_bind_only")
        expect(dim.dep_cycles).to_equal("reject")
