# Tests for construct tier checker.
# Run with: bin/simple test test/unit/compiler/mdsoc/construct_checker_spec.spl
#
# Tests for: src/compiler/85.mdsoc/mdsoc/construct_checker.spl
# Covers ConstructLayerChecker: tier registration, dep checking, shared
# consistency, warn_only mode.

use compiler.mdsoc.types.*
use compiler.mdsoc.layer_checker.{LayerViolation}
use compiler.mdsoc.construct_checker.*

# ============================================================================
# ConstructLayerChecker creation
# ============================================================================

describe "ConstructLayerChecker new":
    it "creates with empty collections":
        val tier_def = LayerDef__new(["core", "flow", "decl"], LayerDirection.LowerToUpper)
        val checker = ConstructLayerChecker__new(tier_def)
        expect(checker.construct_names.len()).to_equal(0)
        expect(checker.violations.len()).to_equal(0)
        expect(checker.warn_only).to_equal(true)

    it "with_default_tiers has 5 tiers":
        val checker = ConstructLayerChecker__with_default_tiers()
        expect(checker.tier_def.order.len()).to_equal(5)

    it "with_default_tiers direction is lower_to_upper":
        val checker = ConstructLayerChecker__with_default_tiers()
        expect(checker.tier_def.direction.to_text()).to_equal("lower_to_upper")

    it "with_default_tiers first tier is core":
        val checker = ConstructLayerChecker__with_default_tiers()
        expect(checker.tier_def.order[0]).to_equal("core")

    it "with_default_tiers last tier is meta":
        val checker = ConstructLayerChecker__with_default_tiers()
        expect(checker.tier_def.order[4]).to_equal("meta")

    it "warn_only is true by default":
        val checker = ConstructLayerChecker__with_default_tiers()
        expect(checker.is_warn_only()).to_equal(true)

# ============================================================================
# Tier assignment
# ============================================================================

describe "ConstructLayerChecker assign_construct_tier":
    it "assigns tier to construct":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("trait", "advanced")
        val tier_opt = checker.get_construct_tier("trait")
        val tier = tier_opt ?? ""
        expect(tier).to_equal("advanced")

    it "updates existing tier assignment":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("trait", "advanced")
        checker.assign_construct_tier("trait", "decl")
        val tier_opt = checker.get_construct_tier("trait")
        val tier = tier_opt ?? ""
        expect(tier).to_equal("decl")

    it "get_construct_tier returns nil for unregistered":
        val checker = ConstructLayerChecker__with_default_tiers()
        val result = checker.get_construct_tier("unknown_construct")
        expect(result).to_be_nil()

    it "multiple constructs registered independently":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("variable", "core")
        checker.assign_construct_tier("expr", "core")
        checker.assign_construct_tier("func", "decl")
        checker.assign_construct_tier("trait", "advanced")
        val v = checker.get_construct_tier("variable") ?? ""
        val e = checker.get_construct_tier("expr") ?? ""
        val f = checker.get_construct_tier("func") ?? ""
        val t = checker.get_construct_tier("trait") ?? ""
        expect(v).to_equal("core")
        expect(e).to_equal("core")
        expect(f).to_equal("decl")
        expect(t).to_equal("advanced")

# ============================================================================
# Dependency checking: allowed cases
# ============================================================================

describe "ConstructLayerChecker check_construct_dep allowed":
    it "unregistered construct returns nil (no constraint)":
        val checker = ConstructLayerChecker__with_default_tiers()
        val result = checker.check_construct_dep("unknown_a", "unknown_b")
        expect(result).to_be_nil()

    it "higher tier depending on lower tier is allowed (advanced -> decl)":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("trait", "advanced")
        checker.assign_construct_tier("func", "decl")
        val result = checker.check_construct_dep("trait", "func")
        expect(result).to_be_nil()

    it "higher tier depending on much lower tier is allowed (meta -> core)":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("module", "meta")
        checker.assign_construct_tier("expr", "core")
        val result = checker.check_construct_dep("module", "expr")
        expect(result).to_be_nil()

    it "same-tier dependency is allowed (allow_tier policy)":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("variable", "core")
        checker.assign_construct_tier("expr", "core")
        val result = checker.check_construct_dep("expr", "variable")
        expect(result).to_be_nil()

    it "flow tier can depend on core tier":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("control", "flow")
        checker.assign_construct_tier("expr", "core")
        val result = checker.check_construct_dep("control", "expr")
        expect(result).to_be_nil()

# ============================================================================
# Dependency checking: violations
# ============================================================================

describe "ConstructLayerChecker check_construct_dep violations":
    it "lower tier depending on higher tier is a violation (core -> advanced)":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("expr", "core")
        checker.assign_construct_tier("trait", "advanced")
        val result = checker.check_construct_dep("expr", "trait")
        expect(result).to_be(result)
        val violation = result ?? LayerViolation__new("", "", "", "", "", "")
        expect(violation.from_module).to_equal("expr")
        expect(violation.to_module).to_equal("trait")
        expect(violation.from_layer).to_equal("core")
        expect(violation.to_layer).to_equal("advanced")

    it "decl tier cannot depend on advanced tier":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("func", "decl")
        checker.assign_construct_tier("async", "advanced")
        val result = checker.check_construct_dep("func", "async")
        expect(result).to_be(result)
        val violation = result ?? LayerViolation__new("", "", "", "", "", "")
        expect(violation.from_layer).to_equal("decl")
        expect(violation.to_layer).to_equal("advanced")

    it "violation message contains layer names":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("expr", "core")
        checker.assign_construct_tier("module", "meta")
        val result = checker.check_construct_dep("expr", "module")
        val violation = result ?? LayerViolation__new("", "", "", "", "", "")
        expect(violation.message).to_contain("core")
        expect(violation.message).to_contain("meta")

# ============================================================================
# check_capsule_deps
# ============================================================================

describe "ConstructLayerChecker check_capsule_deps":
    it "no violations for valid dependency ordering":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("trait", "advanced")
        checker.assign_construct_tier("func", "decl")
        checker.assign_construct_tier("class_struct", "decl")
        checker.assign_construct_tier("expr", "core")

        var cap = ConstructCapsule__new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        cap.depends_on = ["func", "class_struct", "expr"]
        checker.check_capsule_deps(cap)
        expect(checker.has_violations()).to_equal(false)

    it "violation recorded for invalid dependency in warn_only mode":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("expr", "core")
        checker.assign_construct_tier("trait", "advanced")

        # expr (core) depending on trait (advanced) = violation
        var cap = ConstructCapsule__new("expr", ConstructKind.Expr, ConstructTier.Core)
        cap.depends_on = ["trait"]
        checker.check_capsule_deps(cap)
        expect(checker.has_violations()).to_equal(true)
        expect(checker.violation_count()).to_equal(1)

    it "warn_only still records violation":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("control", "flow")
        checker.assign_construct_tier("module", "meta")

        var cap = ConstructCapsule__new("control", ConstructKind.Control, ConstructTier.Flow)
        cap.depends_on = ["module"]
        checker.check_capsule_deps(cap)
        expect(checker.is_warn_only()).to_equal(true)
        expect(checker.has_violations()).to_equal(true)

    it "unregistered dependency is not a violation":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("trait", "advanced")
        # "unknown_construct" not registered

        var cap = ConstructCapsule__new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        cap.depends_on = ["unknown_construct"]
        checker.check_capsule_deps(cap)
        expect(checker.has_violations()).to_equal(false)

# ============================================================================
# check_shared_consistency
# ============================================================================

describe "ConstructLayerChecker check_shared_consistency":
    it "empty tags produce no violations":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("func", "decl")

        val sb = SharedBinding__new("ast.spl", "func", 10)
        val result = checker.check_shared_consistency(sb)
        expect(result.len()).to_equal(0)

    it "unregistered primary produces no violations":
        val checker = ConstructLayerChecker__with_default_tiers()
        var sb = SharedBinding__new("ast.spl", "func", 10)
        sb.construct_tags = ["func", "trait"]
        val result = checker.check_shared_consistency(sb)
        expect(result.len()).to_equal(0)

    it "tag at same tier as primary produces no violation":
        var checker = ConstructLayerChecker__with_default_tiers()
        checker.assign_construct_tier("func", "decl")
        checker.assign_construct_tier("class_struct", "decl")

        var sb = SharedBinding__new("ast.spl", "func", 10)
        sb.construct_tags = ["func", "class_struct"]
        val result = checker.check_shared_consistency(sb)
        expect(result.len()).to_equal(0)

# ============================================================================
# register_capsules and check_all_capsules
# ============================================================================

describe "ConstructLayerChecker register_capsules":
    it "registers tier for each capsule":
        var checker = ConstructLayerChecker__with_default_tiers()
        var cap1 = ConstructCapsule__new("variable", ConstructKind.Variable, ConstructTier.Core)
        var cap2 = ConstructCapsule__new("func", ConstructKind.Func, ConstructTier.Decl)
        var cap3 = ConstructCapsule__new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        checker.register_capsules([cap1, cap2, cap3])
        expect(checker.get_construct_tier("variable") ?? "").to_equal("core")
        expect(checker.get_construct_tier("func") ?? "").to_equal("decl")
        expect(checker.get_construct_tier("trait") ?? "").to_equal("advanced")

describe "ConstructLayerChecker check_all_capsules":
    it "no violations for well-ordered capsules":
        var checker = ConstructLayerChecker__with_default_tiers()
        var cap_expr = ConstructCapsule__new("expr", ConstructKind.Expr, ConstructTier.Core)
        cap_expr.depends_on = []
        var cap_func = ConstructCapsule__new("func", ConstructKind.Func, ConstructTier.Decl)
        cap_func.depends_on = ["expr"]
        var cap_trait = ConstructCapsule__new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        cap_trait.depends_on = ["func", "expr"]
        checker.check_all_capsules([cap_expr, cap_func, cap_trait])
        expect(checker.has_violations()).to_equal(false)

    it "violation recorded for inverted dependency":
        var checker = ConstructLayerChecker__with_default_tiers()
        var cap_expr = ConstructCapsule__new("expr", ConstructKind.Expr, ConstructTier.Core)
        cap_expr.depends_on = ["trait"]  # core depending on advanced = violation
        var cap_trait = ConstructCapsule__new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        cap_trait.depends_on = ["expr"]
        checker.check_all_capsules([cap_expr, cap_trait])
        expect(checker.has_violations()).to_equal(true)

    it "get_violations returns all recorded violations":
        var checker = ConstructLayerChecker__with_default_tiers()
        var cap_expr = ConstructCapsule__new("expr", ConstructKind.Expr, ConstructTier.Core)
        cap_expr.depends_on = ["trait", "module"]  # two violations
        var cap_trait = ConstructCapsule__new("trait", ConstructKind.Trait, ConstructTier.Advanced)
        cap_trait.depends_on = []
        var cap_module = ConstructCapsule__new("module", ConstructKind.Module, ConstructTier.Meta)
        cap_module.depends_on = []
        checker.check_all_capsules([cap_expr, cap_trait, cap_module])
        val violations = checker.get_violations()
        expect(violations.len()).to_equal(2)
