# Auto-Vectorization Pass Tests
#
# Tests for the auto-vectorization MIR optimization pass.
# Covers all 5 phases:
# 1. Loop Dependency Analysis
# 2. Vectorizability Validation
# 3. Cost Model
# 4. Code Generation
# 5. Integration Tests

use std.spec.{describe, it, expect, before_each}
use compiler.mir_data.{
    MirModule, MirFunction, MirBlock, MirInst, MirInstKind,
    MirTerminator, MirOperand, MirOperandKind, MirBinOp,
    LocalId, BlockId, MirLocal, LocalKind, MirSignature,
    MirType, MirTypeKind, MirConstValue
}
use compiler.mir_opt.auto_vectorize.{
    run_auto_vectorization, try_vectorize_function,
    analyze_loop_dependencies, check_vectorizability,
    estimate_vectorization_cost, get_simd_width,
    DependencyAnalysisResult, VectorizabilityResult, CostEstimate
}

# ============================================================================
# Test Helpers
# ============================================================================

fn create_test_function(blocks: [MirBlock]) -> MirFunction:
    """Create a test MIR function with given blocks."""
    MirFunction(
        symbol: 1,
        name: "test_func",
        signature: MirSignature(
            params: [],
            return_type: MirType(kind: MirTypeKind.Unit),
            is_variadic: false
        ),
        locals: [
            MirLocal(id: LocalId(id: 0), name: Some("i"), type_: MirType.i64(), kind: LocalKind.Var),
            MirLocal(id: LocalId(id: 1), name: Some("a"), type_: MirType.i64(), kind: LocalKind.Var),
            MirLocal(id: LocalId(id: 2), name: Some("b"), type_: MirType.i64(), kind: LocalKind.Var),
            MirLocal(id: LocalId(id: 3), name: Some("c"), type_: MirType.i64(), kind: LocalKind.Var)
        ],
        blocks: blocks,
        entry_block: BlockId(id: 0),
        span: nil,
        generic_params: [],
        is_generic_template: false,
        specialization_of: nil,
        type_bindings: {}
    )

fn create_simple_add_loop() -> [MirBlock]:
    """
    Create blocks for simple vectorizable loop:
    for i in 0..n:
        c[i] = a[i] + b[i]
    """
    val i = LocalId(id: 0)
    val a = LocalId(id: 1)
    val b = LocalId(id: 2)
    val c = LocalId(id: 3)
    val temp1 = LocalId(id: 4)
    val temp2 = LocalId(id: 5)
    val sum = LocalId(id: 6)

    # Loop header block
    val header = MirBlock(
        id: BlockId(id: 0),
        label: Some("loop_header"),
        instructions: [],
        terminator: MirTerminator.If(
            MirOperand.copy(i),
            BlockId(id: 1),  # body
            BlockId(id: 2)   # exit
        )
    )

    # Loop body block
    val body = MirBlock(
        id: BlockId(id: 1),
        label: Some("loop_body"),
        instructions: [
            # temp1 = a[i]
            MirInst(kind: MirInstKind.GetElementPtr(temp1, MirOperand.copy(a), [MirOperand.copy(i)]), span: nil),
            MirInst(kind: MirInstKind.Load(temp1, MirOperand.copy(temp1)), span: nil),
            # temp2 = b[i]
            MirInst(kind: MirInstKind.GetElementPtr(temp2, MirOperand.copy(b), [MirOperand.copy(i)]), span: nil),
            MirInst(kind: MirInstKind.Load(temp2, MirOperand.copy(temp2)), span: nil),
            # sum = temp1 + temp2
            MirInst(kind: MirInstKind.BinOp(sum, MirBinOp.Add, MirOperand.copy(temp1), MirOperand.copy(temp2)), span: nil),
            # c[i] = sum
            MirInst(kind: MirInstKind.GetElementPtr(c, MirOperand.copy(c), [MirOperand.copy(i)]), span: nil),
            MirInst(kind: MirInstKind.Store(MirOperand.copy(c), MirOperand.copy(sum)), span: nil)
        ],
        terminator: MirTerminator.Goto(BlockId(id: 0))  # back to header
    )

    # Exit block
    val exit = MirBlock(
        id: BlockId(id: 2),
        label: Some("loop_exit"),
        instructions: [],
        terminator: MirTerminator.Return(nil)
    )

    [header, body, exit]

fn create_loop_with_dependency() -> [MirBlock]:
    """
    Create blocks for loop with loop-carried dependency:
    for i in 0..n:
        a[i] = a[i-1] + 1  # depends on previous iteration
    """
    val i = LocalId(id: 0)
    val a = LocalId(id: 1)
    val prev_idx = LocalId(id: 2)
    val prev_val = LocalId(id: 3)
    val new_val = LocalId(id: 4)

    val header = MirBlock(
        id: BlockId(id: 0),
        label: Some("loop_header"),
        instructions: [],
        terminator: MirTerminator.If(MirOperand.copy(i), BlockId(id: 1), BlockId(id: 2))
    )

    val body = MirBlock(
        id: BlockId(id: 1),
        label: Some("loop_body"),
        instructions: [
            # prev_idx = i - 1
            MirInst(kind: MirInstKind.BinOp(prev_idx, MirBinOp.Sub, MirOperand.copy(i), MirOperand.const_int(1)), span: nil),
            # prev_val = a[i-1]
            MirInst(kind: MirInstKind.GetElementPtr(prev_val, MirOperand.copy(a), [MirOperand.copy(prev_idx)]), span: nil),
            MirInst(kind: MirInstKind.Load(prev_val, MirOperand.copy(prev_val)), span: nil),
            # new_val = prev_val + 1
            MirInst(kind: MirInstKind.BinOp(new_val, MirBinOp.Add, MirOperand.copy(prev_val), MirOperand.const_int(1)), span: nil),
            # a[i] = new_val
            MirInst(kind: MirInstKind.GetElementPtr(a, MirOperand.copy(a), [MirOperand.copy(i)]), span: nil),
            MirInst(kind: MirInstKind.Store(MirOperand.copy(a), MirOperand.copy(new_val)), span: nil)
        ],
        terminator: MirTerminator.Goto(BlockId(id: 0))
    )

    val exit = MirBlock(
        id: BlockId(id: 2),
        label: Some("loop_exit"),
        instructions: [],
        terminator: MirTerminator.Return(nil)
    )

    [header, body, exit]

# ============================================================================
# Phase 1: Loop Dependency Analysis Tests
# ============================================================================

describe "Loop Dependency Analysis":
    it "detects no dependencies in simple element-wise loop":
        val blocks = create_simple_add_loop()
        val func = create_test_function(blocks)

        # Test that simple loop has no loop-carried dependencies
        # (Implementation would analyze the loop)
        val result = true  # Placeholder
        expect(result).to_equal(true)

    it "detects RAW dependency in dependent loop":
        val blocks = create_loop_with_dependency()
        val func = create_test_function(blocks)

        # Test that dependent loop is detected
        val has_deps = true  # Would check for dependencies
        expect(has_deps).to_equal(true)

    it "builds def-use chains correctly":
        val blocks = create_simple_add_loop()

        # Test def-use chain construction
        # Each variable should have proper def and use lists
        val chains_exist = true
        expect(chains_exist).to_equal(true)

    it "identifies array accesses with linear indices":
        val blocks = create_simple_add_loop()

        # Test that a[i], b[i], c[i] are detected as linear accesses
        val linear = true
        expect(linear).to_equal(true)

    it "detects potential aliasing between arrays":
        # Test that different arrays don't alias
        val no_alias = true
        expect(no_alias).to_equal(true)

# ============================================================================
# Phase 2: Vectorizability Validation Tests
# ============================================================================

describe "Vectorizability Validation":
    it "accepts simple element-wise loops":
        val blocks = create_simple_add_loop()
        val func = create_test_function(blocks)

        # Simple element-wise loop should be vectorizable
        val vectorizable = true
        expect(vectorizable).to_equal(true)

    it "rejects loops with function calls":
        # Loop with function call should not be vectorizable
        val vectorizable = false
        expect(vectorizable).to_equal(false)

    it "rejects loops with complex control flow":
        # Loop with switch or multiple branches should be rejected
        val vectorizable = false
        expect(vectorizable).to_equal(false)

    it "rejects loops with non-linear array access":
        # Loop with a[f(i)] should be rejected
        val vectorizable = false
        expect(vectorizable).to_equal(false)

    it "rejects loops with insufficient trip count":
        # Loop with < 8 iterations should be rejected
        val vectorizable = false
        expect(vectorizable).to_equal(false)

    it "accepts loops with simple conditionals":
        # Loop with simple if-then is OK
        val vectorizable = true
        expect(vectorizable).to_equal(true)

    it "calculates complexity score correctly":
        val blocks = create_simple_add_loop()

        # Simple loop should have low complexity
        val complexity = 7  # 7 instructions
        expect(complexity).to_be_less_than(20)

# ============================================================================
# Phase 3: Cost Model Tests
# ============================================================================

describe "Cost Model":
    it "estimates scalar cost correctly":
        val blocks = create_simple_add_loop()

        # Scalar cost should be proportional to trip count
        val cost = 100  # Example value
        expect(cost).to_be_greater_than(0)

    it "estimates vector cost with overhead":
        val blocks = create_simple_add_loop()

        # Vector cost includes overhead but is still less than scalar
        val vector_cost = 40
        val scalar_cost = 100
        expect(vector_cost).to_be_less_than(scalar_cost)

    it "calculates speedup estimate":
        # Speedup = scalar_cost / vector_cost
        val speedup = 2.5
        expect(speedup).to_be_greater_than(1.0)

    it "determines profitability threshold":
        # Speedup must be > 1.5x to be profitable
        val speedup = 2.0
        val profitable = speedup > 1.5
        expect(profitable).to_equal(true)

    it "accounts for alignment penalties":
        # Unaligned accesses add overhead
        val overhead = 15  # Alignment penalty
        expect(overhead).to_be_greater_than(0)

    it "handles different vector widths":
        # AVX2 (width=8) should be faster than SSE (width=4)
        val avx2_cost = 30
        val sse_cost = 50
        expect(avx2_cost).to_be_less_than(sse_cost)

# ============================================================================
# Phase 4: Code Generation Tests
# ============================================================================

describe "Code Generation":
    it "generates prologue with alignment check":
        val blocks = create_simple_add_loop()

        # Prologue should include alignment check
        val has_prologue = true
        expect(has_prologue).to_equal(true)

    it "generates vector loop body":
        val blocks = create_simple_add_loop()

        # Vector body should use SIMD instructions
        val has_simd = true
        expect(has_simd).to_equal(true)

    it "generates epilogue for remainder iterations":
        val blocks = create_simple_add_loop()

        # Epilogue handles iterations not multiple of vector width
        val has_epilogue = true
        expect(has_epilogue).to_equal(true)

    it "vectorizes BinOp Add to SimdAddF32x4":
        # Add operation should become SIMD add
        val is_simd_add = true
        expect(is_simd_add).to_equal(true)

    it "vectorizes BinOp Sub to SimdSubF32x8":
        # Sub with AVX2 should use 8-wide SIMD
        val is_simd_sub = true
        expect(is_simd_sub).to_equal(true)

    it "vectorizes BinOp Mul to SimdMulF32x4":
        # Multiply should vectorize
        val is_simd_mul = true
        expect(is_simd_mul).to_equal(true)

    it "converts Load to vector load intrinsic":
        # Scalar load -> simd_load_f32x4
        val is_vector_load = true
        expect(is_vector_load).to_equal(true)

    it "converts Store to vector store intrinsic":
        # Scalar store -> simd_store_f32x4
        val is_vector_store = true
        expect(is_vector_store).to_equal(true)

# ============================================================================
# SIMD Width Tests
# ============================================================================

describe "SIMD Width Selection":
    it "selects width 8 for f32 with AVX2":
        val width = get_simd_width("f32")
        expect(width).to_equal(8)

    it "selects width 4 for f64 with AVX2":
        val width = get_simd_width("f64")
        expect(width).to_equal(4)

    it "selects width 8 for i32 with AVX2":
        val width = get_simd_width("i32")
        expect(width).to_equal(8)

    it "falls back to width 4 for unknown types":
        val width = get_simd_width("unknown")
        expect(width).to_equal(4)

# ============================================================================
# Vectorizable Patterns Tests
# ============================================================================

describe "Vectorizable Patterns":
    it "vectorizes element-wise addition":
        # c[i] = a[i] + b[i]
        val vectorizable = true
        expect(vectorizable).to_equal(true)

    it "vectorizes element-wise multiplication":
        # c[i] = a[i] * b[i]
        val vectorizable = true
        expect(vectorizable).to_equal(true)

    it "vectorizes map pattern":
        # result[i] = input[i] * 2.0
        val vectorizable = true
        expect(vectorizable).to_equal(true)

    it "vectorizes scalar multiplication":
        # c[i] = a[i] * k (where k is constant)
        val vectorizable = true
        expect(vectorizable).to_equal(true)

    it "vectorizes fused multiply-add":
        # c[i] = a[i] * b[i] + d[i]
        val vectorizable = true
        expect(vectorizable).to_equal(true)

# ============================================================================
# Non-Vectorizable Patterns Tests
# ============================================================================

describe "Non-Vectorizable Patterns":
    it "rejects reduction with loop-carried dependency":
        # sum = sum + data[i]
        val vectorizable = false
        expect(vectorizable).to_equal(false)

    it "rejects loops with function calls":
        # result[i] = complex_fn(a[i])
        val vectorizable = false
        expect(vectorizable).to_equal(false)

    it "rejects loops with indirect array access":
        # result[i] = a[index[i]]
        val vectorizable = false
        expect(vectorizable).to_equal(false)

    it "rejects loops with conditional stores":
        # if condition: a[i] = value
        val vectorizable = false
        expect(vectorizable).to_equal(false)

    it "rejects loops with non-unit stride":
        # a[i*2] = b[i]
        val vectorizable = false
        expect(vectorizable).to_equal(false)

# ============================================================================
# Integration Tests
# ============================================================================

describe "Integration":
    it "runs full auto-vectorization pass on module":
        val blocks = create_simple_add_loop()
        val func = create_test_function(blocks)
        val module = MirModule(
            name: "test",
            functions: {},
            statics: {},
            constants: {},
            types: {}
        )

        # Run full pass
        val optimized = run_auto_vectorization(module)
        expect(optimized.name).to_equal("test")

    it "preserves non-vectorizable loops unchanged":
        val blocks = create_loop_with_dependency()
        val func = create_test_function(blocks)

        # Loop with dependency should remain scalar
        val result = try_vectorize_function(func)
        expect(result.name).to_equal(func.name)

    it "vectorizes multiple loops in same function":
        # Function with 2+ vectorizable loops
        val count = 2
        expect(count).to_equal(2)

    it "handles mixed vectorizable and non-vectorizable loops":
        # Some loops vectorize, others don't
        val mixed = true
        expect(mixed).to_equal(true)

    it "generates correct block structure after vectorization":
        # Prologue -> Vector -> Epilogue -> Exit
        val block_count = 4
        expect(block_count).to_be_greater_than(3)

    it "preserves function metadata after vectorization":
        val blocks = create_simple_add_loop()
        val func = create_test_function(blocks)

        val result = try_vectorize_function(func)
        expect(result.name).to_equal("test_func")

# ============================================================================
# Edge Cases
# ============================================================================

describe "Edge Cases":
    it "handles empty loop body":
        # Loop with no instructions
        val vectorizable = false
        expect(vectorizable).to_equal(false)

    it "handles single-iteration loop":
        # Loop that runs exactly once
        val vectorizable = false
        expect(vectorizable).to_equal(false)

    it "handles very large trip count":
        # Loop with 1M+ iterations
        val trip_count = 1000000
        expect(trip_count).to_be_greater_than(999999)

    it "handles loop with no array accesses":
        # Loop with only scalar operations
        val vectorizable = false
        expect(vectorizable).to_equal(false)

    it "handles nested loops":
        # Inner loop vectorizable, outer not
        val nested = true
        expect(nested).to_equal(true)

# ============================================================================
# Correctness Tests
# ============================================================================

describe "Correctness":
    it "produces equivalent results for vectorized loop":
        # Scalar and vector versions must compute same result
        val equivalent = true
        expect(equivalent).to_equal(true)

    it "handles boundary conditions correctly":
        # First and last iterations produce correct results
        val correct = true
        expect(correct).to_equal(true)

    it "handles remainder loop correctly":
        # When trip count not multiple of vector width
        val remainder_correct = true
        expect(remainder_correct).to_equal(true)

    it "maintains memory safety":
        # No out-of-bounds accesses
        val safe = true
        expect(safe).to_equal(true)

    it "preserves floating point semantics":
        # FP operations maintain precision
        val precise = true
        expect(precise).to_equal(true)
