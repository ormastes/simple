# ARM NEON Encoding Tests
#
# Tests for ARM NEON SIMD instruction encoding.
# Verifies correct 32-bit instruction encoding for ARMv8-A Advanced SIMD.

use compiler.backend.native.arm_neon.{q_to_index}
use compiler.backend.native.arm_neon.{neon_encode_f32x4_3reg, neon_encode_f64x2_3reg, neon_encode_i32x4_3reg}
use compiler.backend.native.arm_neon.{encode_fadd_4s, encode_fsub_4s, encode_fmul_4s, encode_fdiv_4s, encode_fmla_4s}
use compiler.backend.native.arm_neon.{encode_fadd_2d, encode_fsub_2d, encode_fmul_2d, encode_fdiv_2d, encode_fmla_2d}
use compiler.backend.native.arm_neon.{encode_add_4s_int, encode_sub_4s_int, encode_mul_4s_int}
use compiler.backend.native.arm_neon.{encode_ldr_q, encode_str_q, encode_ld1_4s, encode_st1_4s}
use compiler.backend.native.arm_neon.{encode_faddp_4s, encode_fmaxnm_4s, encode_fminnm_4s}
use compiler.backend.native.mach_inst.{AARCH64_Q0, AARCH64_Q1, AARCH64_Q2, AARCH64_Q3, AARCH64_Q4, AARCH64_Q5, AARCH64_Q6, AARCH64_Q7}
use compiler.backend.native.arm_neon.{arm_neon_reg_name}

# Alias for test convenience
val ARM_Q0 = AARCH64_Q0
val ARM_Q1 = AARCH64_Q1
val ARM_Q2 = AARCH64_Q2
val ARM_Q3 = AARCH64_Q3
val ARM_Q4 = AARCH64_Q4
val ARM_Q5 = AARCH64_Q5
val ARM_Q6 = AARCH64_Q6
val ARM_Q7 = AARCH64_Q7

# ============================================================================
# Helper Functions
# ============================================================================

fn bytes_to_u32_le(bytes: [i64]) -> i64:
    # Convert 4 bytes (little-endian) to 32-bit unsigned integer.
    if bytes.len() < 4:
        0
    else:
        bytes[0] + (bytes[1] * 256) + (bytes[2] * 65536) + (bytes[3] * 16777216)

# ============================================================================
# Register Encoding Tests
# ============================================================================

describe "ARM NEON Register Encoding":
    it "converts Q register IDs to indices":
        expect(q_to_index(ARM_Q0)).to_equal(0)
        expect(q_to_index(ARM_Q1)).to_equal(1)
        expect(q_to_index(ARM_Q2)).to_equal(2)
        expect(q_to_index(ARM_Q3)).to_equal(3)
        expect(q_to_index(ARM_Q4)).to_equal(4)
        expect(q_to_index(ARM_Q5)).to_equal(5)

    it "converts higher Q registers correctly":
        expect(q_to_index(ARM_Q6)).to_equal(6)
        expect(q_to_index(ARM_Q7)).to_equal(7)
        expect(q_to_index(64)).to_equal(0)
        expect(q_to_index(79)).to_equal(15)

    it "generates register names correctly":
        expect(arm_neon_reg_name(ARM_Q0)).to_equal("q0")
        expect(arm_neon_reg_name(ARM_Q5)).to_equal("q5")
        expect(arm_neon_reg_name(79)).to_equal("q15")

# ============================================================================
# NEON f32x4 Float Arithmetic Tests
# ============================================================================

describe "NEON f32x4 Instructions":
    it "encodes FADD.4S V0, V1, V2":
        val bytes = encode_fadd_4s(ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)

        # FADD.4S base: 0x4E20D400
        # V0: Rd=0, V1: Rn=1, V2: Rm=2
        # Expected: 0x4E20D400 + 0 + (1*32) + (2*65536)
        # = 0x4E20D400 + 0x20 + 0x20000 = 0x4E22D420

        val inst = bytes_to_u32_le(bytes)
        # Check key bits: opcode base present
        # Byte 3 should be 0x4E (opcode high)
        expect(bytes[3]).to_equal(0x4E)

        # Byte 1 should have Rn field (bits 5-9 of instruction)
        # Rn=1 means bit 5 set, so byte containing bits 5-9 has value influenced
        # Verify at least register fields are in correct positions
        expect(bytes[0] % 32).to_equal(0)  # Rd=0 in bits 0-4

    it "encodes FSUB.4S V0, V1, V2":
        val bytes = encode_fsub_4s(ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)
        # FSUB.4S base: 0x4EA0D400 (bit 23 set vs FADD)
        expect(bytes[3]).to_equal(0x4E)

    it "encodes FMUL.4S V3, V4, V5":
        val bytes = encode_fmul_4s(ARM_Q3, ARM_Q4, ARM_Q5)
        expect(bytes.len()).to_equal(4)
        # FMUL.4S base: 0x6E20DC00
        expect(bytes[3]).to_equal(0x6E)
        # Rd=3 in bits 0-4
        expect(bytes[0] % 32).to_equal(3)

    it "encodes FDIV.4S V6, V7, ARM_Q0":
        val bytes = encode_fdiv_4s(ARM_Q6, ARM_Q7, ARM_Q0)
        expect(bytes.len()).to_equal(4)
        # FDIV.4S base: 0x6E20FC00
        expect(bytes[3]).to_equal(0x6E)
        expect(bytes[0] % 32).to_equal(6)

    it "encodes FMLA.4S V0, V1, V2":
        val bytes = encode_fmla_4s(ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)
        # FMLA.4S base: 0x4E20CC00
        expect(bytes[3]).to_equal(0x4E)

# ============================================================================
# NEON f64x2 Double Precision Tests
# ============================================================================

describe "NEON f64x2 Instructions":
    it "encodes FADD.2D V0, V1, V2":
        val bytes = encode_fadd_2d(ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)
        # FADD.2D base: 0x4E60D400 (Sz=1 for double)
        expect(bytes[3]).to_equal(0x4E)

    it "encodes FSUB.2D V0, V1, V2":
        val bytes = encode_fsub_2d(ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)
        # FSUB.2D base: 0x4EE0D400
        expect(bytes[3]).to_equal(0x4E)

    it "encodes FMUL.2D V3, V4, V5":
        val bytes = encode_fmul_2d(ARM_Q3, ARM_Q4, ARM_Q5)
        expect(bytes.len()).to_equal(4)
        # FMUL.2D base: 0x6E60DC00
        expect(bytes[3]).to_equal(0x6E)
        expect(bytes[0] % 32).to_equal(3)

    it "encodes FDIV.2D V0, V1, V2":
        val bytes = encode_fdiv_2d(ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)
        # FDIV.2D base: 0x6E60FC00
        expect(bytes[3]).to_equal(0x6E)

    it "encodes FMLA.2D V0, V1, V2":
        val bytes = encode_fmla_2d(ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)
        # FMLA.2D base: 0x4E60CC00
        expect(bytes[3]).to_equal(0x4E)

# ============================================================================
# NEON i32x4 Integer Arithmetic Tests
# ============================================================================

describe "NEON i32x4 Instructions":
    it "encodes ADD.4S V0, V1, V2 (integer)":
        val bytes = encode_add_4s_int(ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)
        # ADD.4S base: 0x4EA08400
        expect(bytes[3]).to_equal(0x4E)

    it "encodes SUB.4S V0, V1, V2 (integer)":
        val bytes = encode_sub_4s_int(ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)
        # SUB.4S base: 0x6EA08400
        expect(bytes[3]).to_equal(0x6E)

    it "encodes MUL.4S V3, V4, V5 (integer)":
        val bytes = encode_mul_4s_int(ARM_Q3, ARM_Q4, ARM_Q5)
        expect(bytes.len()).to_equal(4)
        # MUL.4S base: 0x4EA09C00
        expect(bytes[3]).to_equal(0x4E)
        expect(bytes[0] % 32).to_equal(3)

# ============================================================================
# Load/Store Instruction Tests
# ============================================================================

describe "NEON Load/Store Instructions":
    it "encodes LDR Q0, [X1, #0]":
        val bytes = encode_ldr_q(ARM_Q0, 1, 0)
        expect(bytes.len()).to_equal(4)
        # LDR Q base: 0x3DC00000
        # Rt=0, Rn=1, imm12=0
        expect(bytes[3]).to_equal(0x3D)
        expect(bytes[0] % 32).to_equal(0)  # Rt=0

    it "encodes LDR Q2, [X3, #16]":
        val bytes = encode_ldr_q(ARM_Q2, 3, 16)
        expect(bytes.len()).to_equal(4)
        # offset=16, imm12=16/16=1
        expect(bytes[3]).to_equal(0x3D)
        expect(bytes[0] % 32).to_equal(2)  # Rt=2

    it "encodes LDR Q5, [X10, #64]":
        val bytes = encode_ldr_q(ARM_Q5, 10, 64)
        expect(bytes.len()).to_equal(4)
        # offset=64, imm12=64/16=4
        expect(bytes[3]).to_equal(0x3D)
        expect(bytes[0] % 32).to_equal(5)  # Rt=5

    it "encodes STR Q0, [X1, #0]":
        val bytes = encode_str_q(ARM_Q0, 1, 0)
        expect(bytes.len()).to_equal(4)
        # STR Q base: 0x3D800000
        expect(bytes[3]).to_equal(0x3D)
        expect(bytes[0] % 32).to_equal(0)

    it "encodes STR Q3, [X5, #32]":
        val bytes = encode_str_q(ARM_Q3, 5, 32)
        expect(bytes.len()).to_equal(4)
        # offset=32, imm12=32/16=2
        expect(bytes[3]).to_equal(0x3D)
        expect(bytes[0] % 32).to_equal(3)

# ============================================================================
# Structure Load/Store Tests
# ============================================================================

describe "NEON Structure Load/Store":
    it "encodes LD1 {V0.4S}, [X1]":
        val bytes = encode_ld1_4s(ARM_Q0, 1)
        expect(bytes.len()).to_equal(4)
        # LD1 base: 0x4C407000
        expect(bytes[3]).to_equal(0x4C)
        expect(bytes[0] % 32).to_equal(0)

    it "encodes LD1 {V2.4S}, [X3]":
        val bytes = encode_ld1_4s(ARM_Q2, 3)
        expect(bytes.len()).to_equal(4)
        expect(bytes[3]).to_equal(0x4C)
        expect(bytes[0] % 32).to_equal(2)

    it "encodes ST1 {V0.4S}, [X1]":
        val bytes = encode_st1_4s(ARM_Q0, 1)
        expect(bytes.len()).to_equal(4)
        # ST1 base: 0x4C007000
        expect(bytes[3]).to_equal(0x4C)
        expect(bytes[0] % 32).to_equal(0)

    it "encodes ST1 {V4.4S}, [X7]":
        val bytes = encode_st1_4s(ARM_Q4, 7)
        expect(bytes.len()).to_equal(4)
        expect(bytes[3]).to_equal(0x4C)
        expect(bytes[0] % 32).to_equal(4)

# ============================================================================
# Horizontal Operation Tests
# ============================================================================

describe "NEON Horizontal Operations":
    it "encodes FADDP.4S V0, V1, V2":
        val bytes = encode_faddp_4s(ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)
        # FADDP base: 0x6E20D400
        expect(bytes[3]).to_equal(0x6E)

    it "encodes FMAXNM.4S V0, V1, V2":
        val bytes = encode_fmaxnm_4s(ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)
        # FMAXNM base: 0x4E20C400
        expect(bytes[3]).to_equal(0x4E)

    it "encodes FMINNM.4S V3, V4, V5":
        val bytes = encode_fminnm_4s(ARM_Q3, ARM_Q4, ARM_Q5)
        expect(bytes.len()).to_equal(4)
        # FMINNM base: 0x4EA0C400
        expect(bytes[3]).to_equal(0x4E)
        expect(bytes[0] % 32).to_equal(3)

# ============================================================================
# Encoding Helper Tests
# ============================================================================

describe "NEON Encoding Helpers":
    it "encodes 3-register instruction with correct register fields":
        # Test neon_encode_f32x4_3reg directly with known opcode
        val bytes = neon_encode_f32x4_3reg(0x4E20D400, ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)

        # Verify register fields are correctly positioned
        # Rd=0 in bits 0-4
        expect(bytes[0] % 32).to_equal(0)

    it "encodes 3-register instruction with different registers":
        val bytes = neon_encode_f32x4_3reg(0x4E20D400, ARM_Q7, ARM_Q6, ARM_Q5)
        expect(bytes.len()).to_equal(4)

        # Rd=7 in bits 0-4
        expect(bytes[0] % 32).to_equal(7)

    it "preserves opcode high bits correctly":
        val bytes = neon_encode_f32x4_3reg(0x6E20DC00, ARM_Q0, ARM_Q1, ARM_Q2)
        expect(bytes.len()).to_equal(4)

        # High byte should be 0x6E
        expect(bytes[3]).to_equal(0x6E)

# ============================================================================
# Edge Case Tests
# ============================================================================

describe "ARM NEON Edge Cases":
    it "handles Q0 registers correctly":
        val bytes = encode_fadd_4s(ARM_Q0, ARM_Q0, ARM_Q0)
        expect(bytes.len()).to_equal(4)
        # All registers = 0
        expect(bytes[0] % 32).to_equal(0)

    it "handles high Q registers (Q15)":
        val bytes = encode_fadd_4s(79, 79, 79)  # Q15 = id 79
        expect(bytes.len()).to_equal(4)
        # Rd=15 in bits 0-4
        expect(bytes[0] % 32).to_equal(15)

    it "handles mixed register operands":
        val bytes = encode_fmul_4s(ARM_Q0, ARM_Q7, ARM_Q3)
        expect(bytes.len()).to_equal(4)
        expect(bytes[0] % 32).to_equal(0)

    it "handles large offset in LDR":
        # Max offset: 4095*16 = 65520
        val bytes = encode_ldr_q(ARM_Q0, 1, 1024)
        expect(bytes.len()).to_equal(4)
        # imm12 = 1024/16 = 64
        expect(bytes[3]).to_equal(0x3D)

    it "handles zero offset in STR":
        val bytes = encode_str_q(ARM_Q5, 10, 0)
        expect(bytes.len()).to_equal(4)
        expect(bytes[3]).to_equal(0x3D)
        expect(bytes[0] % 32).to_equal(5)

# ============================================================================
# Instruction Length Tests
# ============================================================================

describe "ARM NEON Instruction Length":
    it "all arithmetic instructions are 4 bytes":
        expect(encode_fadd_4s(ARM_Q0, ARM_Q1, ARM_Q2).len()).to_equal(4)
        expect(encode_fsub_4s(ARM_Q0, ARM_Q1, ARM_Q2).len()).to_equal(4)
        expect(encode_fmul_4s(ARM_Q0, ARM_Q1, ARM_Q2).len()).to_equal(4)
        expect(encode_fdiv_4s(ARM_Q0, ARM_Q1, ARM_Q2).len()).to_equal(4)

    it "all load/store instructions are 4 bytes":
        expect(encode_ldr_q(ARM_Q0, 1, 0).len()).to_equal(4)
        expect(encode_str_q(ARM_Q0, 1, 0).len()).to_equal(4)
        expect(encode_ld1_4s(ARM_Q0, 1).len()).to_equal(4)
        expect(encode_st1_4s(ARM_Q0, 1).len()).to_equal(4)

    it "all horizontal operations are 4 bytes":
        expect(encode_faddp_4s(ARM_Q0, ARM_Q1, ARM_Q2).len()).to_equal(4)
        expect(encode_fmaxnm_4s(ARM_Q0, ARM_Q1, ARM_Q2).len()).to_equal(4)
        expect(encode_fminnm_4s(ARM_Q0, ARM_Q1, ARM_Q2).len()).to_equal(4)
