# callconv_bridge_spec.spl
#
# BDD spec for calling convention bridge logic.
# All logic is replicated inline (no module imports) to avoid import issues.

# ============================================================================
# Inline replicas of callconv_bridge functions
# ============================================================================

fn spec_callconv_from_string(name: text) -> text:
    if name == "C":
        return "C"
    elif name == "Fastcall":
        return "Fastcall"
    elif name == "Stdcall":
        return "Stdcall"
    elif name == "Vectorcall":
        return "Vectorcall"
    elif name == "Interrupt":
        return "Interrupt"
    elif name == "Naked":
        return "Naked"
    elif name == "Simple":
        return "Simple"
    else:
        return "Simple"

fn spec_callconv_is_valid_name(name: text) -> bool:
    val resolved = spec_callconv_from_string(name)
    not (resolved == "Simple" and not (name == "Simple" or name == ""))

fn spec_callconv_resolve_from_flags(is_naked: bool, is_interrupt: bool, has_callconv: bool, callconv: text) -> text:
    if has_callconv and callconv.len() > 0:
        return spec_callconv_from_string(callconv)
    elif is_naked:
        return "Naked"
    elif is_interrupt:
        return "Interrupt"
    else:
        return "Simple"

fn spec_callconv_needs_prologue(conv: text) -> bool:
    not (conv == "Naked")

fn spec_callconv_is_interrupt_compat(conv: text) -> bool:
    conv == "Interrupt" or conv == "Naked"

# ============================================================================
# Tests
# ============================================================================

describe "callconv_bridge":

    describe "callconv_from_string":

        it "maps C to C convention":
            val result = spec_callconv_from_string("C")
            expect(result).to_equal("C")

        it "maps Fastcall to Fastcall convention":
            val result = spec_callconv_from_string("Fastcall")
            expect(result).to_equal("Fastcall")

        it "maps Stdcall to Stdcall convention":
            val result = spec_callconv_from_string("Stdcall")
            expect(result).to_equal("Stdcall")

        it "maps Vectorcall to Vectorcall convention":
            val result = spec_callconv_from_string("Vectorcall")
            expect(result).to_equal("Vectorcall")

        it "maps Naked to Naked convention":
            val result = spec_callconv_from_string("Naked")
            expect(result).to_equal("Naked")

        it "maps Interrupt to Interrupt convention":
            val result = spec_callconv_from_string("Interrupt")
            expect(result).to_equal("Interrupt")

        it "maps unknown string to Simple fallback":
            val result = spec_callconv_from_string("UnknownABI")
            expect(result).to_equal("Simple")

    describe "callconv_resolve_from_flags":

        it "naked flag resolves to Naked when no explicit callconv":
            val result = spec_callconv_resolve_from_flags(true, false, false, "")
            expect(result).to_equal("Naked")

        it "interrupt flag resolves to Interrupt when no explicit callconv":
            val result = spec_callconv_resolve_from_flags(false, true, false, "")
            expect(result).to_equal("Interrupt")

        it "explicit callconv C overrides naked flag":
            val result = spec_callconv_resolve_from_flags(true, false, true, "C")
            expect(result).to_equal("C")

        it "explicit callconv Fastcall overrides interrupt flag":
            val result = spec_callconv_resolve_from_flags(false, true, true, "Fastcall")
            expect(result).to_equal("Fastcall")

        it "no flags resolves to Simple default":
            val result = spec_callconv_resolve_from_flags(false, false, false, "")
            expect(result).to_equal("Simple")

    describe "callconv_needs_prologue":

        it "Naked convention does not need prologue":
            val result = spec_callconv_needs_prologue("Naked")
            expect(result).to_equal(false)

        it "C convention needs prologue":
            val result = spec_callconv_needs_prologue("C")
            expect(result).to_equal(true)

        it "Simple convention needs prologue":
            val result = spec_callconv_needs_prologue("Simple")
            expect(result).to_equal(true)

        it "Interrupt convention needs prologue":
            val result = spec_callconv_needs_prologue("Interrupt")
            expect(result).to_equal(true)

    describe "callconv_is_interrupt_compat":

        it "Interrupt convention is interrupt compatible":
            val result = spec_callconv_is_interrupt_compat("Interrupt")
            expect(result).to_equal(true)

        it "Naked convention is interrupt compatible":
            val result = spec_callconv_is_interrupt_compat("Naked")
            expect(result).to_equal(true)

        it "C convention is not interrupt compatible":
            val result = spec_callconv_is_interrupt_compat("C")
            expect(result).to_equal(false)

        it "Simple convention is not interrupt compatible":
            val result = spec_callconv_is_interrupt_compat("Simple")
            expect(result).to_equal(false)

        it "Fastcall convention is not interrupt compatible":
            val result = spec_callconv_is_interrupt_compat("Fastcall")
            expect(result).to_equal(false)
