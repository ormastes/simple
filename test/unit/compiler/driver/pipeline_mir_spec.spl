describe "Pipeline Mir":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # # Pipeline MIR Specification
# #
# # **Feature IDs:** #TBD
# # **Category:** Compiler
# # **Status:** In Progress
# #
# # ## Overview
# #
# # Tests the full Parse → HIR → MIR pipeline produces valid MIR output.
# 
# use std.spec
# use compiler.core.parser.*
# use compiler.parser_types.*
# use compiler.core.lexer.*
# use compiler.blocks.*
# use compiler.treesitter.*
# use compiler.hir_lowering.*
# use compiler.mir_lowering.*
# use compiler.mir_data.*
# 
# 
# describe "Pipeline MIR":
#     it "lowers simple function to MIR with at least 1 function":
#         val source = "fn main() -> i64:\n    0\n"
#         var parser = Parser.new(source)
#         val ast_module = parser.parse()
#         var hir_lowering = HirLowering.new()
#         val hir_module = hir_lowering.lower_module(ast_module)
#         var mir_ctx = MirLowering.new(hir_lowering.symbols)
#         val mir_module = mir_ctx.lower_module(hir_module)
#         expect(mir_module.functions.keys().len() > 0).to_equal(true)
# 
#     it "MIR function has at least 1 block":
#         val source = "fn main() -> i64:\n    0\n"
#         var parser = Parser.new(source)
#         val ast_module = parser.parse()
#         var hir_lowering = HirLowering.new()
#         val hir_module = hir_lowering.lower_module(ast_module)
#         var mir_ctx = MirLowering.new(hir_lowering.symbols)
#         val mir_module = mir_ctx.lower_module(hir_module)
#         for key in mir_module.functions.keys():
#             val fn_ = mir_module.functions[key]
#             expect(fn_.blocks.len() > 0).to_equal(true)
