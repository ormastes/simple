# CompilerServices Phases Spec
#
# Comprehensive phase tests for Feature 2: Pipeline Stage Ports (CompilerServices).
# CompilerServices has 9 typed port structs and create_default_services() factory.
#
# Feature: Pipeline Stage Ports (Feature 2)
# Design: doc/report/compiler_mdsoc_impl_plan.md Phase 2

# use compiler.compiler_services.{
#     create_default_services,
#     LexerPort, ParserPort, DesugarPort, TypeCheckPort,
#     HirLowerPort, MirLowerPort, LoggerPort, ModuleLoaderPort,
#     CompilerServices
# }

# Local stubs for testing
class LexerPort:
    name: text
    tokenize_fn: fn(text) -> list

class ParserPort:
    name: text
    parse_fn: fn(list, text) -> list

class DesugarPort:
    name: text
    desugar_fn: fn(text) -> text

class TypeCheckPort:
    name: text
    check_fn: fn(text) -> list

class HirLowerPort:
    name: text
    lower_fn: fn(text) -> list

class MirLowerPort:
    name: text
    lower_fn: fn(text) -> list

class BackendPort:
    name: text
    run_fn: fn(text) -> text
    supports_jit_fn: fn() -> bool
    target_triple_fn: fn() -> text

class LoggerPort:
    name: text
    debug_fn: fn(text)
    info_fn: fn(text)
    warn_fn: fn(text)
    error_fn: fn(text)

class ModuleLoaderPort:
    name: text
    load_fn: fn(text) -> text
    resolve_fn: fn(text, text) -> text

class CompilerServices:
    lexer: LexerPort
    parser: ParserPort
    desugarer: DesugarPort
    type_checker: TypeCheckPort
    hir_lowerer: HirLowerPort
    mir_lowerer: MirLowerPort
    backend: BackendPort
    logger: LoggerPort
    module_loader: ModuleLoaderPort

fn create_default_services() -> CompilerServices:
    fn noop_tokenize(src: text) -> list: []
    fn noop_parse(tokens: list, src: text) -> list: []
    fn noop_desugar(src: text) -> text: src
    fn noop_check(module: text) -> list: []
    fn noop_hir_lower(module: text) -> list: []
    fn noop_mir_lower(module: text) -> list: []
    fn noop_run(m): nil
    fn noop_jit() -> bool: false
    fn noop_triple() -> text: "noop"
    fn noop_log(msg: text): nil
    fn noop_load(path: text) -> text: ""
    fn noop_resolve(current: text, import_name: text) -> text: import_name
    CompilerServices(
        lexer: LexerPort(name: "noop-lexer", tokenize_fn: noop_tokenize),
        parser: ParserPort(name: "noop-parser", parse_fn: noop_parse),
        desugarer: DesugarPort(name: "noop-desugarer", desugar_fn: noop_desugar),
        type_checker: TypeCheckPort(name: "noop-type-checker", check_fn: noop_check),
        hir_lowerer: HirLowerPort(name: "noop-hir-lowerer", lower_fn: noop_hir_lower),
        mir_lowerer: MirLowerPort(name: "noop-mir-lowerer", lower_fn: noop_mir_lower),
        backend: BackendPort(name: "noop-backend", run_fn: noop_run, supports_jit_fn: noop_jit, target_triple_fn: noop_triple),
        logger: LoggerPort(name: "noop-logger", debug_fn: noop_log, info_fn: noop_log, warn_fn: noop_log, error_fn: noop_log),
        module_loader: ModuleLoaderPort(name: "noop-module-loader", load_fn: noop_load, resolve_fn: noop_resolve)
    )

# ============================================================================
# Phase 1 - Basic API: All 9 port structs exist and are named correctly
# ============================================================================

describe "CompilerServices: Phase 1 - Basic API":

    context "factory creates services":
        it "create_default_services returns a container":
            val services = create_default_services()
            expect(services.lexer.name).to_equal("noop-lexer")

        it "all 9 ports are wired with correct names":
            val s = create_default_services()
            expect(s.lexer.name).to_equal("noop-lexer")
            expect(s.parser.name).to_equal("noop-parser")
            expect(s.desugarer.name).to_equal("noop-desugarer")

        it "type checker and hir lowerer have correct names":
            val s = create_default_services()
            expect(s.type_checker.name).to_equal("noop-type-checker")
            expect(s.hir_lowerer.name).to_equal("noop-hir-lowerer")

        it "mir lowerer has correct name":
            val s = create_default_services()
            expect(s.mir_lowerer.name).to_equal("noop-mir-lowerer")

        it "backend has correct name":
            val s = create_default_services()
            expect(s.backend.name).to_equal("noop-backend")

        it "logger has correct name":
            val s = create_default_services()
            expect(s.logger.name).to_equal("noop-logger")

        it "module loader has correct name":
            val s = create_default_services()
            expect(s.module_loader.name).to_equal("noop-module-loader")

    context "port fn-fields are callable":
        it "lexer tokenize_fn returns empty list for noop":
            val s = create_default_services()
            val f = s.lexer.tokenize_fn
            val result = f("val x = 1")
            expect(result.len()).to_equal(0)

        it "parser parse_fn returns empty errors for noop":
            val s = create_default_services()
            val f = s.parser.parse_fn
            val result = f([], "")
            expect(result.len()).to_equal(0)

        it "desugarer desugar_fn returns source unchanged":
            val s = create_default_services()
            val src = "val x = 1"
            val f = s.desugarer.desugar_fn
            val result = f(src)
            expect(result).to_equal(src)

        it "type checker check_fn returns empty errors":
            val s = create_default_services()
            val f = s.type_checker.check_fn
            val result = f("main")
            expect(result.len()).to_equal(0)

        it "hir lowerer lower_fn returns empty errors":
            val s = create_default_services()
            val f = s.hir_lowerer.lower_fn
            val result = f("main")
            expect(result.len()).to_equal(0)

        it "mir lowerer lower_fn returns empty errors":
            val s = create_default_services()
            val f = s.mir_lowerer.lower_fn
            val result = f("main")
            expect(result.len()).to_equal(0)

        it "backend supports_jit_fn returns false":
            val s = create_default_services()
            val f = s.backend.supports_jit_fn
            val result = f()
            expect(result).to_equal(false)

        it "backend target_triple_fn returns noop":
            val s = create_default_services()
            val f = s.backend.target_triple_fn
            val result = f()
            expect(result).to_equal("noop")

        it "module loader load_fn returns empty string":
            val s = create_default_services()
            val f = s.module_loader.load_fn
            val result = f("some/path.spl")
            expect(result).to_equal("")

        it "module loader resolve_fn returns import name unchanged":
            val s = create_default_services()
            val f = s.module_loader.resolve_fn
            val result = f("/src/main.spl", "std.string")
            expect(result).to_equal("std.string")

# ============================================================================
# Phase 2 - Integration: Ports work together as a pipeline
# ============================================================================

describe "CompilerServices: Phase 2 - Integration":

    context "pipeline stage separation":
        it "each port has a distinct name":
            val s = create_default_services()
            val names = [
                s.lexer.name,
                s.parser.name,
                s.desugarer.name,
                s.type_checker.name,
                s.hir_lowerer.name,
                s.mir_lowerer.name,
                s.backend.name,
                s.logger.name,
                s.module_loader.name
            ]
            expect(names.len()).to_equal(9)

        it "lexer and parser are independent ports":
            val s = create_default_services()
            expect(s.lexer.name).to_equal("noop-lexer")
            expect(s.parser.name).to_equal("noop-parser")

        it "hir and mir lowerers have distinct names":
            val s = create_default_services()
            val hir = s.hir_lowerer.name
            val mir = s.mir_lowerer.name
            expect(hir).to_equal("noop-hir-lowerer")
            expect(mir).to_equal("noop-mir-lowerer")

    context "logger port has 4 fn-fields":
        it "logger debug_fn is callable":
            val s = create_default_services()
            val f = s.logger.debug_fn
            f("debug message")
            expect(s.logger.name).to_equal("noop-logger")

        it "logger info_fn is callable":
            val s = create_default_services()
            val f = s.logger.info_fn
            f("info message")
            expect(s.logger.name).to_equal("noop-logger")

        it "logger warn_fn is callable":
            val s = create_default_services()
            val f = s.logger.warn_fn
            f("warn message")
            expect(s.logger.name).to_equal("noop-logger")

        it "logger error_fn is callable":
            val s = create_default_services()
            val f = s.logger.error_fn
            f("error message")
            expect(s.logger.name).to_equal("noop-logger")

    context "create_default_services called multiple times":
        it "each call produces independent containers":
            val s1 = create_default_services()
            val s2 = create_default_services()
            expect(s1.lexer.name).to_equal(s2.lexer.name)
            expect(s1.backend.name).to_equal(s2.backend.name)

        it "two service containers have same port names":
            val s1 = create_default_services()
            val s2 = create_default_services()
            expect(s1.parser.name).to_equal(s2.parser.name)

# ============================================================================
# Phase 3 - System behavior: Ports enable pipeline stage boundary typing
# ============================================================================

describe "CompilerServices: Phase 3 - System behavior":

    context "desugar pass-through behavior":
        it "noop desugarer returns source unchanged for empty string":
            val s = create_default_services()
            val f = s.desugarer.desugar_fn
            val result = f("")
            expect(result).to_equal("")

        it "noop desugarer preserves complex source":
            val s = create_default_services()
            val src = "fn foo(x: i64) -> i64:\n    x * 2"
            val f = s.desugarer.desugar_fn
            val result = f(src)
            expect(result).to_equal(src)

    context "module loader resolve behavior":
        it "noop resolve returns import name for any current path":
            val s = create_default_services()
            val f = s.module_loader.resolve_fn
            val r1 = f("/a/b.spl", "std.math")
            val r2 = f("/x/y.spl", "std.math")
            expect(r1).to_equal("std.math")
            expect(r2).to_equal("std.math")

        it "noop load returns empty for any path":
            val s = create_default_services()
            val f = s.module_loader.load_fn
            val r1 = f("src/foo.spl")
            val r2 = f("test/bar.spl")
            expect(r1).to_equal("")
            expect(r2).to_equal("")

    context "backend port in services":
        it "noop backend supports_jit is consistently false":
            val s1 = create_default_services()
            val s2 = create_default_services()
            val f1 = s1.backend.supports_jit_fn
            val f2 = s2.backend.supports_jit_fn
            expect(f1()).to_equal(false)
            expect(f2()).to_equal(false)

        it "noop backend triple is consistently noop":
            val s = create_default_services()
            val f = s.backend.target_triple_fn
            val r1 = f()
            val r2 = f()
            expect(r1).to_equal(r2)
