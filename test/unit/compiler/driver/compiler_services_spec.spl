# Compiler Services - Port Struct Tests
#
# Tests that CompilerServices port structs can be constructed and
# that the create_default_services factory wires them correctly.
#
# Feature: Pipeline Stage Ports (Feature 2)
# Design: doc/report/compiler_mdsoc_impl_plan.md Phase 2

# use compiler.compiler_services.{
#     create_default_services,
#     LexerPort, ParserPort, DesugarPort, TypeCheckPort,
#     HirLowerPort, MirLowerPort, LoggerPort, ModuleLoaderPort,
#     CompilerServices
# }

# Local stubs for testing
class LexerPort:
    name: text
    tokenize_fn: fn(text) -> list

class ParserPort:
    name: text
    parse_fn: fn(list, text) -> list

class DesugarPort:
    name: text
    desugar_fn: fn(text) -> text

class TypeCheckPort:
    name: text
    check_fn: fn(text) -> list

class HirLowerPort:
    name: text
    lower_fn: fn(text) -> list

class MirLowerPort:
    name: text
    lower_fn: fn(text) -> list

class BackendPort:
    name: text
    run_fn: fn(text) -> text
    supports_jit_fn: fn() -> bool
    target_triple_fn: fn() -> text

class LoggerPort:
    name: text
    debug_fn: fn(text)
    info_fn: fn(text)
    warn_fn: fn(text)
    error_fn: fn(text)

class ModuleLoaderPort:
    name: text
    load_fn: fn(text) -> text
    resolve_fn: fn(text, text) -> text

class CompilerServices:
    lexer: LexerPort
    parser: ParserPort
    desugarer: DesugarPort
    type_checker: TypeCheckPort
    hir_lowerer: HirLowerPort
    mir_lowerer: MirLowerPort
    backend: BackendPort
    logger: LoggerPort
    module_loader: ModuleLoaderPort

fn create_default_services() -> CompilerServices:
    fn noop_tokenize(src: text) -> list: []
    fn noop_parse(tokens: list, src: text) -> list: []
    fn noop_desugar(src: text) -> text: src
    fn noop_check(module: text) -> list: []
    fn noop_hir_lower(module: text) -> list: []
    fn noop_mir_lower(module: text) -> list: []
    fn noop_run(m): nil
    fn noop_jit() -> bool: false
    fn noop_triple() -> text: "noop"
    fn noop_log(msg: text): nil
    fn noop_load(path: text) -> text: ""
    fn noop_resolve(current: text, import_name: text) -> text: import_name
    CompilerServices(
        lexer: LexerPort(name: "noop-lexer", tokenize_fn: noop_tokenize),
        parser: ParserPort(name: "noop-parser", parse_fn: noop_parse),
        desugarer: DesugarPort(name: "noop-desugarer", desugar_fn: noop_desugar),
        type_checker: TypeCheckPort(name: "noop-type-checker", check_fn: noop_check),
        hir_lowerer: HirLowerPort(name: "noop-hir-lowerer", lower_fn: noop_hir_lower),
        mir_lowerer: MirLowerPort(name: "noop-mir-lowerer", lower_fn: noop_mir_lower),
        backend: BackendPort(name: "noop-backend", run_fn: noop_run, supports_jit_fn: noop_jit, target_triple_fn: noop_triple),
        logger: LoggerPort(name: "noop-logger", debug_fn: noop_log, info_fn: noop_log, warn_fn: noop_log, error_fn: noop_log),
        module_loader: ModuleLoaderPort(name: "noop-module-loader", load_fn: noop_load, resolve_fn: noop_resolve)
    )

# ============================================================================
# Test Group 1: Factory creates all port fields
# ============================================================================

describe "CompilerServices - create_default_services":

    context "factory construction":
        it "creates services without error":
            val services = create_default_services()
            expect(services.lexer.name).to_equal("noop-lexer")

        it "wires lexer port":
            val services = create_default_services()
            expect(services.lexer.name).to_equal("noop-lexer")

        it "wires parser port":
            val services = create_default_services()
            expect(services.parser.name).to_equal("noop-parser")

        it "wires desugarer port":
            val services = create_default_services()
            expect(services.desugarer.name).to_equal("noop-desugarer")

        it "wires type_checker port":
            val services = create_default_services()
            expect(services.type_checker.name).to_equal("noop-type-checker")

        it "wires hir_lowerer port":
            val services = create_default_services()
            expect(services.hir_lowerer.name).to_equal("noop-hir-lowerer")

        it "wires mir_lowerer port":
            val services = create_default_services()
            expect(services.mir_lowerer.name).to_equal("noop-mir-lowerer")

        it "wires backend port":
            val services = create_default_services()
            expect(services.backend.name).to_equal("noop-backend")

        it "wires logger port":
            val services = create_default_services()
            expect(services.logger.name).to_equal("noop-logger")

        it "wires module_loader port":
            val services = create_default_services()
            expect(services.module_loader.name).to_equal("noop-module-loader")

# ============================================================================
# Test Group 2: Port fn-fields are callable
# ============================================================================

describe "CompilerServices - port fn-fields are callable":

    context "lexer port":
        it "tokenize_fn returns a list":
            val services = create_default_services()
            val lexer = services.lexer
            val f = lexer.tokenize_fn
            val result = f("val x = 1")
            expect(result.len()).to_equal(0)

    context "parser port":
        it "parse_fn returns empty errors for noop":
            val services = create_default_services()
            val parser = services.parser
            val f = parser.parse_fn
            val result = f([], "")
            expect(result.len()).to_equal(0)

    context "desugarer port":
        it "desugar_fn returns source unchanged for noop":
            val services = create_default_services()
            val desugarer = services.desugarer
            val src = "val x = 1"
            val f = desugarer.desugar_fn
            val result = f(src)
            expect(result).to_equal(src)

    context "type checker port":
        it "check_fn returns empty errors for noop":
            val services = create_default_services()
            val checker = services.type_checker
            val f = checker.check_fn
            val result = f("main")
            expect(result.len()).to_equal(0)

    context "hir lowerer port":
        it "lower_fn returns empty errors for noop":
            val services = create_default_services()
            val lowerer = services.hir_lowerer
            val f = lowerer.lower_fn
            val result = f("main")
            expect(result.len()).to_equal(0)

    context "mir lowerer port":
        it "lower_fn returns empty errors for noop":
            val services = create_default_services()
            val lowerer = services.mir_lowerer
            val f = lowerer.lower_fn
            val result = f("main")
            expect(result.len()).to_equal(0)

    context "backend port":
        it "supports_jit_fn returns false for noop":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.supports_jit_fn
            val result = f()
            expect(result).to_equal(false)

        it "target_triple_fn returns noop for noop backend":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.target_triple_fn
            val result = f()
            expect(result).to_equal("noop")

    context "module loader port":
        it "load_fn returns empty string for noop":
            val services = create_default_services()
            val loader = services.module_loader
            val f = loader.load_fn
            val result = f("some/path.spl")
            expect(result).to_equal("")

        it "resolve_fn returns import name unchanged for noop":
            val services = create_default_services()
            val loader = services.module_loader
            val f = loader.resolve_fn
            val result = f("/src/main.spl", "std.string")
            expect(result).to_equal("std.string")

# ============================================================================
# Test Group 3: Services container has all 9 fields
# ============================================================================

describe "CompilerServices - struct shape":

    context "field presence":
        it "has lexer field":
            val services = create_default_services()
            val lexer_name = services.lexer.name
            expect(lexer_name).to_equal("noop-lexer")

        it "has parser field":
            val services = create_default_services()
            val parser_name = services.parser.name
            expect(parser_name).to_equal("noop-parser")

        it "has desugarer field":
            val services = create_default_services()
            val desugarer_name = services.desugarer.name
            expect(desugarer_name).to_equal("noop-desugarer")

        it "has type_checker field":
            val services = create_default_services()
            val checker_name = services.type_checker.name
            expect(checker_name).to_equal("noop-type-checker")

        it "has hir_lowerer field":
            val services = create_default_services()
            val hir_name = services.hir_lowerer.name
            expect(hir_name).to_equal("noop-hir-lowerer")

        it "has mir_lowerer field":
            val services = create_default_services()
            val mir_name = services.mir_lowerer.name
            expect(mir_name).to_equal("noop-mir-lowerer")

        it "has backend field":
            val services = create_default_services()
            val backend_name = services.backend.name
            expect(backend_name).to_equal("noop-backend")

        it "has logger field":
            val services = create_default_services()
            val logger_name = services.logger.name
            expect(logger_name).to_equal("noop-logger")

        it "has module_loader field":
            val services = create_default_services()
            val loader_name = services.module_loader.name
            expect(loader_name).to_equal("noop-module-loader")
