describe "Collection Opt":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Collection Optimization Pass Tests
# #
# # Tests for MIR-level collection optimizations:
# # - Array concat to push replacement in loops
# # - Loop-invariant pure method call hoisting
# 
# use compiler.mir.mir_data.*
# use compiler.mir.mir.*
# use compiler.mir_opt.mir_opt.collection_opt.{
#     CollectionOptimization, create_collection_opt_pass, collection_opt_run_on_function
# }
# 
# # ============================================================================
# # Test Helpers
# # ============================================================================
# 
# fn make_block(id: i64, instructions: [MirInst], term: MirTerminator) -> MirBlock:
#     MirBlock(
#         id: BlockId(id: id),
#         label: "bb{id}",
#         instructions: instructions,
#         terminator: term
#     )
# 
# fn make_local(id: i64) -> LocalId:
#     LocalId(id: id)
# 
# fn make_copy(local_id: i64) -> MirOperand:
#     MirOperand(kind: MirOperandKind.Copy(make_local(local_id)))
# 
# fn make_const_int(value: i64) -> MirOperand:
#     MirOperand(kind: MirOperandKind.Const(
#         MirConstValue.Int(value),
#         MirType.i64()
#     ))
# 
# fn make_const_str(s: text) -> MirOperand:
#     MirOperand(kind: MirOperandKind.Const(
#         MirConstValue.Str(s),
#         MirType.unit()
#     ))
# 
# fn make_inst(kind: MirInstKind) -> MirInst:
#     MirInst(kind: kind, span: nil)
# 
# fn make_function(name: text, blocks: [MirBlock]) -> MirFunction:
#     MirFunction(
#         symbol: SymbolId(id: 0),
#         name: name,
#         signature: MirSignature(params: [], return_type: MirType.unit(), is_variadic: false),
#         locals: [],
#         blocks: blocks,
#         entry_block: BlockId(id: 0),
#         span: nil,
#         generic_params: [],
#         is_generic_template: false,
#         specialization_of: nil,
#         type_bindings: {},
#         layout_phase: nil
#     )
# 
# # ============================================================================
# # Concat-to-Push Tests
# # ============================================================================
# 
# describe "Collection Optimization - Concat to Push":
#     it "creates optimization pass successfully":
#         var opt = create_collection_opt_pass()
#         expect(opt.concat_replaced).to_equal(0)
#         expect(opt.calls_hoisted).to_equal(0)
# 
#     it "passes through function with no loops":
#         # bb0: const + return
#         val bb0 = make_block(0, [
#             make_inst(MirInstKind.Const(make_local(0), MirConstValue.Int(42), MirType.i64()))
#         ], MirTerminator.Return(make_const_int(42)))
# 
#         val func = make_function("no_loop", [bb0])
#         var opt = create_collection_opt_pass()
#         val result = collection_opt_run_on_function(opt, func)
# 
#         expect(result.blocks.len()).to_equal(1)
#         expect(opt.concat_replaced).to_equal(0)
# 
#     it "reports stats summary":
#         var opt = create_collection_opt_pass()
#         val summary = opt.stats_summary()
#         expect(summary).to_contain("CollectionOpt")
#         expect(summary).to_contain("concat->push")
#         expect(summary).to_contain("hoisted")
# 
# # ============================================================================
# # Pure Call Hoisting Tests
# # ============================================================================
# 
# describe "Collection Optimization - Pure Call Hoisting":
#     it "identifies pure methods":
#         var opt = create_collection_opt_pass()
#         expect(opt.is_pure_method("len")).to_equal(true)
#         expect(opt.is_pure_method("is_empty")).to_equal(true)
#         expect(opt.is_pure_method("first")).to_equal(true)
#         expect(opt.is_pure_method("last")).to_equal(true)
#         expect(opt.is_pure_method("get")).to_equal(true)
#         expect(opt.is_pure_method("contains_key")).to_equal(true)
# 
#     it "does not consider impure methods as pure":
#         var opt = create_collection_opt_pass()
#         expect(opt.is_pure_method("push")).to_equal(false)
#         expect(opt.is_pure_method("pop")).to_equal(false)
#         expect(opt.is_pure_method("remove")).to_equal(false)
#         expect(opt.is_pure_method("sort")).to_equal(false)
