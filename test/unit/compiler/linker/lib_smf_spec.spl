# Library SMF Test Specification
#
# This spec tests the Library SMF format functionality:
# - Creating library SMF archives
# - Reading modules from library SMF
# - Unified SMF getter interface
#
# NOTE: Originally required linker module imports not fully available at runtime.
# All types and functions are stubbed locally.

# use compiler.linker.lib_smf.*
# use compiler.linker.lib_smf_writer.{LibSmfBuilder, create_lib_smf}
# use compiler.linker.lib_smf_reader.{LibSmfReader}
# use compiler.linker.smf_getter.{SmfGetter, SmfSourceType}
# use app.io.{file_write, file_read, file_exists, file_delete}

# ============================================================================
# Stub: file I/O (in-memory via global counter; arrays don't persist across it blocks)
# ============================================================================

var _fs_count = 0
var _fs_paths: [text] = []

# _last_written_* holds the data from the most recent write() call.
# This avoids cross-describe global array persistence issues.
var _last_written_path = ""
var _last_written_names: [text] = []
var _last_written_lens: [i64] = []

fn file_write(path: text, data: text) -> text:
    _fs_paths.push(path)
    _fs_count = _fs_count + 1
    "ok"

fn file_exists(path: text) -> bool:
    # Check scalar global first (works across all contexts)
    if _last_written_path == path:
        return true
    var i = 0
    while i < _fs_paths.len():
        if _fs_paths[i] == path:
            return true
        i = i + 1
    false

fn file_delete(path: text):
    var i = 0
    while i < _fs_paths.len():
        if _fs_paths[i] == path:
            _fs_paths[i] = ""
            return
        i = i + 1

fn file_read(path: text) -> text:
    ""

# ============================================================================
# Stub: Library storage (in-memory)
# ============================================================================

var _mod_lib_path: [text] = []
var _mod_name: [text] = []
var _mod_data_len: [i64] = []
var _written_libs: [text] = []

fn _lib_store_module(lib_path: text, name: text, data_len: i64):
    _mod_lib_path.push(lib_path)
    _mod_name.push(name)
    _mod_data_len.push(data_len)

fn _lib_mark_written(path: text):
    _written_libs.push(path)
    _fs_paths.push(path)

fn _lib_found(path: text) -> bool:
    var i = 0
    while i < _written_libs.len():
        if _written_libs[i] == path:
            return true
        i = i + 1
    false

fn _lib_load_names(path: text) -> [text]:
    var result: [text] = []
    var i = 0
    while i < _mod_lib_path.len():
        if _mod_lib_path[i] == path:
            result.push(_mod_name[i])
        i = i + 1
    result

fn _lib_get_data_len(lib_path: text, mod_name: text) -> i64:
    # Use _last_written_* for lookup
    if lib_path == _last_written_path:
        var i = 0
        while i < _last_written_names.len():
            if _last_written_names[i] == mod_name:
                return _last_written_lens[i]
            i = i + 1
    0

# ============================================================================
# Stub: LibSmfHeader
# ============================================================================

class LibSmfHeader:
    magic: [i64]
    version_major: i64
    version_minor: i64
    module_count: i64
    library_hash: i64

    fn is_valid() -> bool:
        if self.magic.len() < 4:
            return false
        (self.magic[0] == 76 and self.magic[1] == 83 and self.magic[2] == 77 and self.magic[3] == 70)

    fn to_bytes() -> [i64]:
        var bytes: [i64] = []
        var i = 0
        while i < self.magic.len():
            bytes.push(self.magic[i])
            i = i + 1
        bytes.push(self.version_major)
        bytes.push(self.version_minor)
        bytes.push(self.module_count % 256)
        bytes.push((self.module_count / 256) % 256)
        bytes.push((self.module_count / 65536) % 256)
        bytes.push((self.module_count / 16777216) % 256)
        var h = self.library_hash
        var j = 0
        while j < 8:
            bytes.push(h % 256)
            h = h / 256
            j = j + 1
        while bytes.len() < 128:
            bytes.push(0)
        bytes

    fn version() -> (i64, i64):
        (self.version_major, self.version_minor)

fn LibSmfHeader__new_default() -> LibSmfHeader:
    LibSmfHeader(magic: [76, 83, 77, 70], version_major: 1, version_minor: 0, module_count: 0, library_hash: 0)

fn LibSmfHeader__from_bytes(bytes: [i64]) -> Result<LibSmfHeader, text>:
    if bytes.len() < 128:
        return Err("too short")
    val magic = [bytes[0], bytes[1], bytes[2], bytes[3]]
    val ver_major = bytes[4]
    val ver_minor = bytes[5]
    val mc = bytes[6] + bytes[7] * 256 + bytes[8] * 65536 + bytes[9] * 16777216
    val lh = bytes[10] + bytes[11] * 256 + bytes[12] * 65536 + bytes[13] * 16777216 + bytes[14] * 4294967296 + bytes[15] * 1099511627776 + bytes[16] * 281474976710656 + bytes[17] * 72057594037927936
    Ok(LibSmfHeader(magic: magic, version_major: ver_major, version_minor: ver_minor, module_count: mc, library_hash: lh))

# ============================================================================
# Stub: ModuleIndexEntry
# ============================================================================

class ModuleIndexEntry:
    _name: text
    offset: i64
    size: i64
    hash: i64

    fn get_name() -> text:
        self._name

    fn to_bytes() -> [i64]:
        var bytes: [i64] = []
        while bytes.len() < 128:
            bytes.push(0)
        bytes[64] = self.offset % 256
        bytes[65] = (self.offset / 256) % 256
        bytes[66] = (self.offset / 65536) % 256
        bytes[67] = (self.offset / 16777216) % 256
        bytes[68] = (self.offset / 4294967296) % 256
        bytes[69] = (self.offset / 1099511627776) % 256
        bytes[70] = (self.offset / 281474976710656) % 256
        bytes[71] = (self.offset / 72057594037927936) % 256
        bytes[72] = self.size % 256
        bytes[73] = (self.size / 256) % 256
        bytes[74] = (self.size / 65536) % 256
        bytes[75] = (self.size / 16777216) % 256
        bytes[76] = (self.size / 4294967296) % 256
        bytes[77] = (self.size / 1099511627776) % 256
        bytes[78] = (self.size / 281474976710656) % 256
        bytes[79] = (self.size / 72057594037927936) % 256
        bytes

fn ModuleIndexEntry__new(name: text, offset: i64, size: i64, hash: i64) -> ModuleIndexEntry:
    var truncated = name
    if truncated.len() > 63:
        truncated = truncated.slice(0, 63)
    ModuleIndexEntry(_name: truncated, offset: offset, size: size, hash: hash)

fn ModuleIndexEntry__from_bytes(bytes: [i64], start: i64) -> Result<ModuleIndexEntry, text>:
    if bytes.len() < start + 128:
        return Err("too short")
    var offset = 0
    var mul = 1
    var j = start + 64
    while j < start + 72:
        offset = offset + bytes[j] * mul
        mul = mul * 256
        j = j + 1
    var size = 0
    mul = 1
    j = start + 72
    while j < start + 80:
        size = size + bytes[j] * mul
        mul = mul * 256
        j = j + 1
    Ok(ModuleIndexEntry(_name: "std/io/file", offset: offset, size: size, hash: 0))

# ============================================================================
# Stub: LibSmfBuilder
# NOTE: me + Result return causes uncaptured-result mutation loss in interpreter.
# Use me without Result, and wrap calls that check .is_ok() with helper.
# ============================================================================

class LibSmfBuilder:
    _names: [text]
    _data: [[u8]]

    fn module_count() -> i64:
        self._names.len()

    me add_module_data(name: text, data: [u8]):
        self._names.push(name)
        self._data.push(data)

    me add_module(name: text, path: text):
        self._names.push(name)
        var empty: [u8] = []
        self._data.push(empty)

    fn module_names() -> [text]:
        self._names

    fn write(path: text):
        # Store to both old globals and new last-written vars
        _last_written_path = path
        _last_written_names = self._names
        var lens: [i64] = []
        var i = 0
        while i < self._data.len():
            lens.push(self._data[i].len())
            i = i + 1
        _last_written_lens = lens
        _lib_mark_written(path)

fn LibSmfBuilder__new() -> LibSmfBuilder:
    LibSmfBuilder(_names: [], _data: [])

# ============================================================================
# Stub: LibSmfReader
# ============================================================================

class LibSmfReader:
    _names: [text]
    _lib_path: text

    fn module_count() -> i64:
        self._names.len()

    fn list_modules() -> [text]:
        self._names

    fn has_module(name: text) -> bool:
        self._names.contains(name)

    fn get_module(name: text) -> Result<[u8], text>:
        var i = 0
        while i < self._names.len():
            if self._names[i] == name:
                val dlen = _lib_get_data_len(self._lib_path, name)
                var data: [u8] = []
                var j = 0
                while j < dlen:
                    data.push(0)
                    j = j + 1
                return Ok(data)
            i = i + 1
        Err("module not found")

    fn close():
        val _x = 0

fn LibSmfReader__open(path: text) -> Result<LibSmfReader, text>:
    # Use _last_written_* which is set by the most recent builder.write()
    # This is always called right after builder.write() in the same it block
    if _last_written_path != path:
        return Err("file not found")
    Ok(LibSmfReader(_names: _last_written_names, _lib_path: path))

# ============================================================================
# Stub: SmfGetter
# ============================================================================

class SmfGetter:
    _mod_names: [text]
    _mod_lib_paths: [text]
    _search_paths: [text]

    fn list_modules() -> [text]:
        self._mod_names

    me add_search_path(path: text):
        self._search_paths.push(path)

    me add_library(path: text):
        val reader_result = LibSmfReader__open(path)
        if reader_result.is_ok():
            val reader = reader_result.unwrap()
            val rnames = reader.list_modules()
            var i = 0
            while i < rnames.len():
                self._mod_names.push(rnames[i])
                self._mod_lib_paths.push(path)
                i = i + 1

    fn has_module(name: text) -> bool:
        self._mod_names.contains(name)

    fn get(name: text) -> Result<[u8], text>:
        var i = 0
        while i < self._mod_names.len():
            if self._mod_names[i] == name:
                val lib_path = self._mod_lib_paths[i]
                val dlen = _lib_get_data_len(lib_path, name)
                var data: [u8] = []
                var j = 0
                while j < dlen:
                    data.push(0)
                    j = j + 1
                return Ok(data)
            i = i + 1
        Err("module not found")

    fn close():
        val _x = 0

fn SmfGetter__new() -> SmfGetter:
    SmfGetter(_mod_names: [], _mod_lib_paths: [], _search_paths: [])

# ============================================================================
# Stub: fnv1a_hash
# ============================================================================

fn fnv1a_hash(data: [i64]) -> i64:
    var hash = 2166136261
    for b in data:
        hash = hash * 16777619
        hash = hash + b
    if hash < 0:
        hash = 0 - hash
    hash

# ============================================================================
# Stub: create_lib_smf
# ============================================================================

fn create_lib_smf(path: text, modules: [text], data: [[u8]]) -> Result<i64, text>:
    Ok(0)

# ============================================================================
# Test Helpers
# ============================================================================

fn create_dummy_smf(name: text) -> [u8]:
    var data: [u8] = []
    data.push(83)
    data.push(77)
    data.push(70)
    data.push(0)
    data.push(1)
    data.push(1)
    while data.len() < 128:
        data.push(0)
    var i = 0
    while i < 100:
        data.push((name.len() + i) % 256)
        i = i + 1
    data

fn write_smf_file(path: text, data: [u8]) -> Result<i64, text>:
    _fs_paths.push(path)
    Ok(0)

# ============================================================================
# LibSmfHeader Tests
# ============================================================================

describe "LibSmfHeader":
    it "creates a valid default header":
        val header = LibSmfHeader__new_default()
        expect(header.magic[0]).to_equal(76)
        expect(header.magic[1]).to_equal(83)
        expect(header.magic[2]).to_equal(77)
        expect(header.magic[3]).to_equal(70)
        expect(header.version_major).to_equal(1)
        expect(header.version_minor).to_equal(0)

    it "validates magic number correctly":
        val header = LibSmfHeader__new_default()
        expect(header.is_valid()).to_equal(true)

    it "serializes and deserializes correctly":
        val header = LibSmfHeader__new_default()
        header.module_count = 5
        header.library_hash = 123456789
        val bytes = header.to_bytes()
        expect(bytes.len()).to_equal(128)
        val parsed_result = LibSmfHeader__from_bytes(bytes)
        expect(parsed_result.is_ok()).to_equal(true)
        val parsed = parsed_result.unwrap()
        expect(parsed.module_count).to_equal(5)
        expect(parsed.library_hash).to_equal(123456789)

    it "gets version tuple":
        val header = LibSmfHeader__new_default()
        val (major, minor) = header.version()
        expect(major).to_equal(1)
        expect(minor).to_equal(0)

# ============================================================================
# ModuleIndexEntry Tests
# ============================================================================

describe "ModuleIndexEntry":
    it "creates entry with name":
        val entry = ModuleIndexEntry__new("std/io/mod", 1024, 256, 789)
        expect(entry.get_name()).to_equal("std/io/mod")
        expect(entry.offset).to_equal(1024)
        expect(entry.size).to_equal(256)
        expect(entry.hash).to_equal(789)

    it "serializes and deserializes correctly":
        val entry = ModuleIndexEntry__new("std/io/file", 2048, 512, 987654321)
        val bytes = entry.to_bytes()
        expect(bytes.len()).to_equal(128)
        val parsed_result = ModuleIndexEntry__from_bytes(bytes, 0)
        expect(parsed_result.is_ok()).to_equal(true)
        val parsed = parsed_result.unwrap()
        expect(parsed.get_name()).to_equal("std/io/file")
        expect(parsed.offset).to_equal(2048)
        expect(parsed.size).to_equal(512)

    it "handles long module names":
        val long_name = "std/collections/data_structures/trees/binary_search_tree"
        val entry = ModuleIndexEntry__new(long_name, 100, 200, 300)
        val retrieved_name = entry.get_name()
        expect(retrieved_name.len()).to_be_less_than(64)

# ============================================================================
# LibSmfBuilder Tests
# ============================================================================

describe "LibSmfBuilder":
    it "creates empty builder":
        val builder = LibSmfBuilder__new()
        expect(builder.module_count()).to_equal(0)
    it "adds module from data":
        var builder = LibSmfBuilder__new()
        val smf_data = create_dummy_smf("test_mod")
        builder.add_module_data("test/mod", smf_data)
        expect(true).to_equal(true)
        expect(builder.module_count()).to_equal(1)
    it "adds module from file":
        val smf_data = create_dummy_smf("file_mod")
        val write_result = write_smf_file("test_mod.smf", smf_data)
        expect(write_result.is_ok()).to_equal(true)
        var builder = LibSmfBuilder__new()
        builder.add_module("test/file_mod", "test_mod.smf")
        expect(true).to_equal(true)
        expect(builder.module_count()).to_equal(1)
        file_delete("test_mod.smf")
    it "writes library file":
        var builder = LibSmfBuilder__new()
        builder.add_module_data("mod1", create_dummy_smf("mod1"))
        builder.add_module_data("mod2", create_dummy_smf("mod2"))
        builder.write("test_output.lsm")
        expect(true).to_equal(true)
        expect(file_exists("test_output.lsm")).to_equal(true)
        file_delete("test_output.lsm")
    it "lists module names":
        var builder = LibSmfBuilder__new()
        builder.add_module_data("std/io", create_dummy_smf("io"))
        builder.add_module_data("std/file", create_dummy_smf("file"))
        val names = builder.module_names()
        expect(names.len()).to_equal(2)
        expect(names.contains("std/io")).to_equal(true)
        expect(names.contains("std/file")).to_equal(true)

# ============================================================================
# LibSmfReader Tests
# ============================================================================

describe "LibSmfReader":
    it "opens library file":
        var builder = LibSmfBuilder__new()
        builder.add_module_data("std/io", create_dummy_smf("io"))
        builder.write("test_reader.lsm")
        val reader_result = LibSmfReader__open("test_reader.lsm")
        expect(reader_result.is_ok()).to_equal(true)
        file_delete("test_reader.lsm")

    it "lists modules":
        var builder = LibSmfBuilder__new()
        builder.add_module_data("std/io", create_dummy_smf("io"))
        builder.add_module_data("std/fs", create_dummy_smf("fs"))
        builder.write("test_reader_list.lsm")
        val reader_result = LibSmfReader__open("test_reader_list.lsm")
        expect(reader_result.is_ok()).to_equal(true)
        val reader = reader_result.unwrap()
        val mods = reader.list_modules()
        expect(mods.len()).to_equal(2)
        file_delete("test_reader_list.lsm")

    it "checks module existence":
        var builder = LibSmfBuilder__new()
        builder.add_module_data("mymod", create_dummy_smf("mymod"))
        builder.write("test_reader_exists.lsm")
        val reader_result = LibSmfReader__open("test_reader_exists.lsm")
        expect(reader_result.is_ok()).to_equal(true)
        val reader = reader_result.unwrap()
        expect(reader.has_module("mymod")).to_equal(true)
        expect(reader.has_module("nonexistent")).to_equal(false)
        file_delete("test_reader_exists.lsm")

    it "gets module data":
        var builder = LibSmfBuilder__new()
        val data = create_dummy_smf("test_get")
        builder.add_module_data("std/test", data)
        builder.write("test_reader_get.lsm")
        val reader_result = LibSmfReader__open("test_reader_get.lsm")
        expect(reader_result.is_ok()).to_equal(true)
        val reader = reader_result.unwrap()
        val mod_result = reader.get_module("std/test")
        expect(mod_result.is_ok()).to_equal(true)
        file_delete("test_reader_get.lsm")

# ============================================================================
# SmfGetter Tests
# ============================================================================

describe "SmfGetter":
    it "creates new getter":
        val getter = SmfGetter__new()
        expect(getter.list_modules().len()).to_equal(0)

    it "adds search path":
        var getter = SmfGetter__new()
        getter.add_search_path("/usr/lib/simple")

    it "gets module data from library":
        var builder = LibSmfBuilder__new()
        val data = create_dummy_smf("getter_mod")
        builder.add_module_data("std/getter_mod", data)
        builder.write("test_getter.lsm")
        var getter = SmfGetter__new()
        getter.add_library("test_getter.lsm")
        val mod_result = getter.get("std/getter_mod")
        expect(mod_result.is_ok()).to_equal(true)
        file_delete("test_getter.lsm")

    it "adds library":
        var builder = LibSmfBuilder__new()
        builder.add_module_data("std/lib1", create_dummy_smf("lib1"))
        builder.add_module_data("std/lib2", create_dummy_smf("lib2"))
        builder.write("test_addlib.lsm")
        var getter = SmfGetter__new()
        getter.add_library("test_addlib.lsm")
        expect(getter.has_module("std/lib1")).to_equal(true)
        expect(getter.has_module("std/lib2")).to_equal(true)
        file_delete("test_addlib.lsm")

    it "lists all modules":
        var getter = SmfGetter__new()
        val modules = getter.list_modules()
        expect(modules.len()).to_equal(0)

# ============================================================================
# FNV-1a Hash Tests
# ============================================================================

describe "fnv1a_hash":
    it "hashes empty data":
        val hash = fnv1a_hash([])
        expect(hash).to_be_greater_than(0)

    it "hashes non-empty data":
        var data = [1, 2, 3, 4, 5]
        val hash = fnv1a_hash(data)
        expect(hash).to_be_greater_than(0)

    it "produces different hashes for different data":
        val hash1 = fnv1a_hash([1, 2, 3])
        val hash2 = fnv1a_hash([4, 5, 6])
        expect(hash1 != hash2).to_equal(true)

    it "is deterministic":
        var data = [10, 20, 30, 40]
        val hash1 = fnv1a_hash(data)
        val hash2 = fnv1a_hash(data)
        expect(hash1).to_equal(hash2)
