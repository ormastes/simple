"""
# HIR Lowering Specification

**Feature IDs:** #2071-2180
**Category:** Compiler
**Difficulty:** 5/5
**Status:** In Progress

## Overview

HirLowering transforms AST (Abstract Syntax Tree) to HIR (High-level IR).
It handles:
- Name resolution (identifiers â†’ symbols)
- Type annotations and inference
- Desugaring (comprehensions, operators, control flow)
- Symbol table management
- Scope tracking

## Key Features

- Complete AST to HIR transformation
- Type lowering with builtin type recognition
- Module-level symbol declaration
- Function, class, struct, enum, trait lowering
- Expression and statement lowering
- Type inference configuration
- Comprehensive error tracking

## Implementation

File: `/home/ormastes/dev/pub/simple/src/compiler/hir_lowering.spl`
"""

use compiler.hir_lowering.*
use compiler.hir_types.*
use compiler.hir_definitions.*
use compiler.core.parser.*
use compiler.core.lexer.Span
use compiler.config.{TypeInferenceConfig, TypeDefault}


# ============================================================================
# Test Group 1: Initialization and Configuration
# ============================================================================

describe "HirLowering Initialization":
    """
    ## Initialization

    Validates HirLowering.new() and with_config().
    """

    it "creates with default config":
        val lowering = HirLowering.new()

        expect(lowering.errors.len()).to_equal(0)
        expect(lowering.loop_depth).to_equal(0)
        expect(lowering.current_function.?).to_be_false()
        expect(lowering.type_inference_config.?).to_be_false()

    it "creates with custom config":
        val config = TypeInferenceConfig(
            empty_array_default: TypeDefault.I64,
            strict_empty_collections: true
        )
        val lowering = HirLowering.with_config(config)

        expect(lowering.type_inference_config.?).to_be_true()

    it "allows setting config after creation":
        var lowering = HirLowering.new()
        val config = TypeInferenceConfig(
            empty_array_default: TypeDefault.F64,
            strict_empty_collections: false
        )

        lowering.set_type_inference_config(config)

        expect(lowering.type_inference_config.?).to_be_true()


# ============================================================================
# Test Group 2: Type Inference Configuration
# ============================================================================

describe "HirLowering Type Defaults":
    """
    ## Type Default Configuration

    Validates get_empty_array_default() with different TypeDefault values.
    """

    it "returns i32 for default config":
        val lowering = HirLowering.new()

        val default_type = lowering.get_empty_array_default()

        match default_type.kind:
            case Int(bits, signed):
                expect(bits).to_equal(32)
                expect(signed).to_be_true()
            case _:
                fail("Expected Int type")

    it "returns i64 when configured":
        val config = TypeInferenceConfig(
            empty_array_default: TypeDefault.I64,
            strict_empty_collections: false
        )
        val lowering = HirLowering.with_config(config)

        val default_type = lowering.get_empty_array_default()

        match default_type.kind:
            case Int(bits, signed):
                expect(bits).to_equal(64)
                expect(signed).to_be_true()
            case _:
                fail("Expected Int type")

    it "returns f64 when configured":
        val config = TypeInferenceConfig(
            empty_array_default: TypeDefault.F64,
            strict_empty_collections: false
        )
        val lowering = HirLowering.with_config(config)

        val default_type = lowering.get_empty_array_default()

        match default_type.kind:
            case Float(bits):
                expect(bits).to_equal(64)
            case _:
                fail("Expected Float type")

    it "returns string when configured":
        val config = TypeInferenceConfig(
            empty_array_default: TypeDefault.String,
            strict_empty_collections: false
        )
        val lowering = HirLowering.with_config(config)

        val default_type = lowering.get_empty_array_default()

        match default_type.kind:
            case Str:
                pass  # Expected
            case _:
                fail("Expected Str type")

    it "returns bool when configured":
        val config = TypeInferenceConfig(
            empty_array_default: TypeDefault.Bool,
            strict_empty_collections: false
        )
        val lowering = HirLowering.with_config(config)

        val default_type = lowering.get_empty_array_default()

        match default_type.kind:
            case Bool:
                pass  # Expected
            case _:
                fail("Expected Bool type")

    it "checks strict mode":
        val config1 = TypeInferenceConfig(
            empty_array_default: TypeDefault.I32,
            strict_empty_collections: true
        )
        val lowering1 = HirLowering.with_config(config1)

        expect(lowering1.is_strict_empty_collections()).to_be_true()

        val config2 = TypeInferenceConfig(
            empty_array_default: TypeDefault.I32,
            strict_empty_collections: false
        )
        val lowering2 = HirLowering.with_config(config2)

        expect(lowering2.is_strict_empty_collections()).to_be_false()


# ============================================================================
# Test Group 3: Type Lowering - Primitives
# ============================================================================

describe "HirLowering Type Lowering - Primitives":
    """
    ## Primitive Type Lowering

    Validates lower_type() for primitive types (int, float, bool, etc.).
    """

    it "lowers i8 type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("i8", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Int(bits, signed):
                expect(bits).to_equal(8)
                expect(signed).to_be_true()
            case _:
                fail("Expected Int(8, true)")

    it "lowers i16 type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("i16", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Int(bits, signed):
                expect(bits).to_equal(16)
                expect(signed).to_be_true()
            case _:
                fail("Expected Int(16, true)")

    it "lowers i32 type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("i32", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Int(bits, signed):
                expect(bits).to_equal(32)
                expect(signed).to_be_true()
            case _:
                fail("Expected Int(32, true)")

    it "lowers i64 type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("i64", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Int(bits, signed):
                expect(bits).to_equal(64)
                expect(signed).to_be_true()
            case _:
                fail("Expected Int(64, true)")

    it "lowers u8 type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("u8", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Int(bits, signed):
                expect(bits).to_equal(8)
                expect(signed).to_be_false()
            case _:
                fail("Expected Int(8, false)")

    it "lowers u16 type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("u16", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Int(bits, signed):
                expect(bits).to_equal(16)
                expect(signed).to_be_false()
            case _:
                fail("Expected Int(16, false)")

    it "lowers u32 type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("u32", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Int(bits, signed):
                expect(bits).to_equal(32)
                expect(signed).to_be_false()
            case _:
                fail("Expected Int(32, false)")

    it "lowers u64 type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("u64", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Int(bits, signed):
                expect(bits).to_equal(64)
                expect(signed).to_be_false()
            case _:
                fail("Expected Int(64, false)")

    it "lowers f32 type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("f32", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Float(bits):
                expect(bits).to_equal(32)
            case _:
                fail("Expected Float(32)")

    it "lowers f64 type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("f64", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Float(bits):
                expect(bits).to_equal(64)
            case _:
                fail("Expected Float(64)")

    it "lowers bool type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("bool", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Bool:
                pass  # Expected
            case _:
                fail("Expected Bool")

    it "lowers char type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("char", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Char:
                pass  # Expected
            case _:
                fail("Expected Char")

    it "lowers text type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("text", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Str:
                pass  # Expected
            case _:
                fail("Expected Str")

    it "lowers str type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("str", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Str:
                pass  # Expected
            case _:
                fail("Expected Str")

    it "lowers String type":
        var lowering = HirLowering.new()
        val ast_type = create_named_type("String", [])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Str:
                pass  # Expected
            case _:
                fail("Expected Str")


# ============================================================================
# Test Group 4: Type Lowering - Composite Types
# ============================================================================

describe "HirLowering Type Lowering - Composite":
    """
    ## Composite Type Lowering

    Validates lower_type() for tuples, arrays, functions, optionals.
    """

    it "lowers empty tuple to unit":
        var lowering = HirLowering.new()
        val ast_type = create_tuple_type([])

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Unit:
                pass  # Expected
            case _:
                fail("Expected Unit")

    it "lowers array type":
        var lowering = HirLowering.new()
        val elem_type = create_named_type("i64", [])
        val ast_type = create_array_type(elem_type, nil)

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Array(elem, size):
                match elem.kind:
                    case Int(bits, signed):
                        expect(bits).to_equal(64)
                        expect(signed).to_be_true()
                    case _:
                        fail("Expected Int element")
            case _:
                fail("Expected Array")

    it "lowers optional type":
        var lowering = HirLowering.new()
        val inner_type = create_named_type("i32", [])
        val ast_type = create_optional_type(inner_type)

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Optional(inner):
                match inner.kind:
                    case Int(bits, signed):
                        expect(bits).to_equal(32)
                    case _:
                        fail("Expected Int inner")
            case _:
                fail("Expected Optional")

    it "lowers reference type (immutable)":
        var lowering = HirLowering.new()
        val inner_type = create_named_type("i64", [])
        val ast_type = create_ref_type(inner_type, false)

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Ref(inner, is_mut):
                expect(is_mut).to_be_false()
                match inner.kind:
                    case Int(bits, _):
                        expect(bits).to_equal(64)
                    case _:
                        fail("Expected Int inner")
            case _:
                fail("Expected Ref")

    it "lowers reference type (mutable)":
        var lowering = HirLowering.new()
        val inner_type = create_named_type("i64", [])
        val ast_type = create_ref_type(inner_type, true)

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Ref(inner, is_mut):
                expect(is_mut).to_be_true()
            case _:
                fail("Expected Ref")

    it "lowers inference type":
        var lowering = HirLowering.new()
        val ast_type = create_infer_type()

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Infer(id, kind):
                pass  # Expected
            case _:
                fail("Expected Infer")

    it "lowers error type":
        var lowering = HirLowering.new()
        val ast_type = create_error_type()

        val hir_type = lowering.lower_type(ast_type)

        match hir_type.kind:
            case Error:
                pass  # Expected
            case _:
                fail("Expected Error")


# ============================================================================
# Test Group 5: LoweringError
# ============================================================================

describe "LoweringError":
    """
    ## Lowering Error Representation

    Validates LoweringError and LoweringErrorKind.
    """

    it "creates unresolved name error":
        val span = create_span(0, 10)
        val error = LoweringError(
            message: "unresolved name: foo",
            span: span,
            kind: LoweringErrorKind.UnresolvedName
        )

        expect(error.message).to_equal("unresolved name: foo")
        match error.kind:
            case UnresolvedName:
                pass  # Expected
            case _:
                fail("Expected UnresolvedName")

    it "creates duplicate definition error":
        val span = create_span(0, 10)
        val error = LoweringError(
            message: "duplicate definition",
            span: span,
            kind: LoweringErrorKind.DuplicateDefinition
        )

        match error.kind:
            case DuplicateDefinition:
                pass  # Expected
            case _:
                fail("Expected DuplicateDefinition")

    it "creates type mismatch error":
        val span = create_span(0, 10)
        val error = LoweringError(
            message: "type mismatch",
            span: span,
            kind: LoweringErrorKind.TypeMismatch
        )

        match error.kind:
            case TypeMismatch:
                pass  # Expected
            case _:
                fail("Expected TypeMismatch")

    it "creates invalid pattern error":
        val span = create_span(0, 10)
        val error = LoweringError(
            message: "invalid pattern",
            span: span,
            kind: LoweringErrorKind.InvalidPattern
        )

        match error.kind:
            case InvalidPattern:
                pass  # Expected
            case _:
                fail("Expected InvalidPattern")

    it "creates invalid expression error":
        val span = create_span(0, 10)
        val error = LoweringError(
            message: "invalid expression",
            span: span,
            kind: LoweringErrorKind.InvalidExpression
        )

        match error.kind:
            case InvalidExpression:
                pass  # Expected
            case _:
                fail("Expected InvalidExpression")

    it "creates other error":
        val span = create_span(0, 10)
        val error = LoweringError(
            message: "other error",
            span: span,
            kind: LoweringErrorKind.Other
        )

        match error.kind:
            case Other:
                pass  # Expected
            case _:
                fail("Expected Other")


# ============================================================================
# Helper Functions
# ============================================================================

fn create_span(start: i32, end: i32) -> Span:
    """Create a Span for testing."""
    Span(start: start, end: end, line: 0, col: 0)

fn create_named_type(name: text, type_args: [Type]) -> Type:
    """Create a named AST Type."""
    Type(
        kind: TypeKind.Named(name: name, type_args: type_args),
        span: create_span(0, 0)
    )

fn create_tuple_type(elements: [Type]) -> Type:
    """Create a tuple AST Type."""
    Type(
        kind: TypeKind.Tuple(elements: elements),
        span: create_span(0, 0)
    )

fn create_array_type(element_type: Type, size: Expr?) -> Type:
    """Create an array AST Type."""
    Type(
        kind: TypeKind.Array(element_type: element_type, size: size),
        span: create_span(0, 0)
    )

fn create_optional_type(inner: Type) -> Type:
    """Create an optional AST Type."""
    Type(
        kind: TypeKind.Optional(inner: inner),
        span: create_span(0, 0)
    )

fn create_ref_type(inner: Type, mutable: bool) -> Type:
    """Create a reference AST Type."""
    Type(
        kind: TypeKind.Reference(inner: inner, mutable: mutable),
        span: create_span(0, 0)
    )

fn create_infer_type() -> Type:
    """Create an inference AST Type."""
    Type(
        kind: TypeKind.Infer,
        span: create_span(0, 0)
    )

fn create_error_type() -> Type:
    """Create an error AST Type."""
    Type(
        kind: TypeKind.Error,
        span: create_span(0, 0)
    )
