# Borrow Checker Conflict Detection Tests (WI-4)
#
# Verifies that place_conflicts_with(), kind_conflicts_with(), kind_is_mutable()
# and related helper functions exist in borrow_graph.spl.

extern fn rt_file_read_text(path: text) -> text

describe "WI-4: Place conflict detection functions exist":
    it "place_conflicts_with function defined":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("fn place_conflicts_with(a: Place, b: Place) -> bool")).to_equal(true)

    it "place_base_equals function defined":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("fn place_base_equals(a: PlaceBase, b: PlaceBase) -> bool")).to_equal(true)

    it "place_elem_equals function defined":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("fn place_elem_equals(a: PlaceElem, b: PlaceElem) -> bool")).to_equal(true)

describe "WI-4: Place conflicts logic":
    it "checks base equality first":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("val same_base = place_base_equals(a.base, b.base)")).to_equal(true)

    it "returns false for different bases":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("if not same_base")).to_equal(true)

    it "checks projection prefix":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("place_elem_equals(a.projections[i], b.projections[i])")).to_equal(true)

describe "WI-4: Base equals handles all variants":
    it "handles Local variant":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("case Local(a_id)")).to_equal(true)

    it "handles Static variant":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("case Static(a_name)")).to_equal(true)

    it "handles Promoted variant":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("case Promoted(a_id)")).to_equal(true)

describe "WI-4: Elem equals handles all variants":
    it "handles Deref":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("case Deref:")).to_equal(true)

    it "handles Field":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("case Field(a_idx)")).to_equal(true)

    it "handles Index":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("case Index(a_local)")).to_equal(true)

    it "handles ConstantIndex":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("case ConstantIndex(a_idx)")).to_equal(true)

    it "handles Downcast":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("case Downcast(a_v)")).to_equal(true)

describe "WI-4: Borrow kind conflict detection":
    it "kind_conflicts_with function defined":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("fn kind_conflicts_with(a: BorrowKind, b: BorrowKind) -> bool")).to_equal(true)

    it "shared+shared returns false":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        # The function should have Shared case returning false for Shared
        expect(content.contains("case Shared: false")).to_equal(true)

    it "kind_is_mutable function defined":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("fn kind_is_mutable(kind: BorrowKind) -> bool")).to_equal(true)

describe "WI-4: Call site fixes":
    it "borrows_of uses free function place_conflicts_with":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("if place_conflicts_with(borrow.place, place)")).to_equal(true)

    it "has_conflicting_borrow uses free function kind_conflicts_with":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("if kind_conflicts_with(borrow.kind, kind)")).to_equal(true)

    it "record_assign uses free function kind_is_mutable":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("if kind_is_mutable(borrow.kind)")).to_equal(true)

describe "WI-4: Exports":
    it "exports conflict detection functions":
        val content = rt_file_read_text("src/compiler/55.borrow/borrow_check/borrow_graph.spl") ?? ""
        expect(content.contains("export place_base_equals, place_elem_equals, place_conflicts_with")).to_equal(true)
        expect(content.contains("export kind_conflicts_with, kind_is_mutable")).to_equal(true)
