describe "Safety Checker":
    it "skipped":
        skip("imports compiler modules - causes OOM via numbered directory resolution")

# # Safety Checker Specification
# #
# # Tests for safety checking of unsafe operations.
# # Verifies that inline assembly and other unsafe operations
# # are only allowed within unsafe blocks.
# 
# # Skipped: compiler.safety_checker module has parse errors and cannot be loaded
# # use compiler.safety_checker (SafetyChecker, SafetyError)
# use std.spec
# fn check(condition: bool):
#     expect(condition).to_equal(true)
# fn check_msg(condition: bool, message: text):
#     if not condition:
#         expect(message).to_equal("")
# 
# describe "Safety Checker - Inline Assembly":
#     it "rejects inline asm outside unsafe block":
#         val code = """
#         fn dangerous():
#             asm("cli")  # ERROR: not in unsafe block
#         """
#         # This should produce a safety error
#         check(code.contains("asm"))
# 
#     it "accepts inline asm inside unsafe block":
#         val code = """
#         fn safe_dangerous():
#             unsafe:
#                 asm("cli")  # OK: in unsafe block
#         """
#         # This should NOT produce a safety error
#         check(code.contains("unsafe"))
# 
#     it "rejects inline asm in nested function outside unsafe":
#         val code = """
#         fn outer():
#             unsafe:
#                 val x = 5
#             # Back to safe context
#             asm("nop")  # ERROR: not in unsafe
#         """
#         check(code.contains("asm"))
# 
#     it "accepts inline asm in nested unsafe blocks":
#         val code = """
#         fn deeply_nested():
#             unsafe:
#                 if true:
#                     asm("hlt")  # OK: still in unsafe context
#         """
#         check(code.contains("unsafe"))
# 
# describe "Safety Checker - Unsafe Context Tracking":
#     it "tracks unsafe context entry":
#         val code = """
#         fn test():
#             # Safe context
#             val x = 5
#             unsafe:
#                 # Unsafe context begins
#                 asm("nop")
#             # Safe context resumes
#         """
#         check(code.contains("unsafe"))
# 
#     it "handles nested unsafe blocks":
#         val code = """
#         fn test():
#             unsafe:
#                 # Unsafe level 1
#                 unsafe:
#                     # Unsafe level 2
#                     asm("cli")
#         """
#         # Both levels should allow inline asm
#         check(code.contains("asm"))
# 
#     it "exits unsafe context correctly":
#         val code = """
#         fn test():
#             unsafe:
#                 asm("cli")  # OK
#             asm("sti")  # ERROR: back to safe context
#         """
#         check(code.contains("ERROR"))
# 
# describe "Safety Checker - Multiple Unsafe Operations":
#     it "allows multiple asm calls in same unsafe block":
#         val code = """
#         fn multiple():
#             unsafe:
#                 asm("cli")
#                 asm("hlt")
#                 asm("sti")
#         """
#         # All should be allowed
#         check(code.contains("cli"))
# 
#     it "rejects mix of safe and unsafe without block":
#         val code = """
#         fn mixed():
#             val x = 5  # Safe
#             asm("nop")  # ERROR: unsafe without block
#             val y = 10  # Safe
#         """
#         check(code.contains("ERROR"))
# 
# describe "Safety Checker - Error Messages":
#     it "provides clear error for asm outside unsafe":
#         val error_msg = "inline assembly can only be used in unsafe blocks"
#         check(error_msg.contains("unsafe"))
# 
#     it "includes span information in errors":
#         # Safety errors should include location information
#         val code = """
#         fn test():
#             asm("nop")  # Line 3
#         """
#         # Error should reference line 3
#         check(code.contains("asm"))
# 
# describe "Safety Checker - Control Flow":
#     it "tracks unsafe through if statements":
#         val code = """
#         fn test(flag: bool):
#             unsafe:
#                 if flag:
#                     asm("cli")  # OK: in unsafe if body
#                 else:
#                     asm("sti")  # OK: in unsafe else body
#         """
#         check(code.contains("unsafe"))
# 
#     it "tracks unsafe through loops":
#         val code = """
#         fn test():
#             unsafe:
#                 for i in 0..10:
#                     asm("nop")  # OK: in unsafe loop
#         """
#         check(code.contains("for"))
# 
#     it "tracks unsafe through match":
#         val code = """
#         fn test(x: i32):
#             unsafe:
#                 match x:
#                     case 0:
#                         asm("cli")  # OK
#                     case _:
#                         asm("sti")  # OK
#         """
#         check(code.contains("match"))
# 
# describe "Safety Checker - Functions and Closures":
#     it "requires unsafe in function with asm":
#         val code = """
#         fn port_write(port: u16, value: u8):
#             unsafe:
#                 asm volatile("out dx, al", in("dx") port, in("al") value)
#         """
#         check(code.contains("unsafe"))
# 
#     it "rejects asm in closure outside unsafe":
#         val code = """
#         fn test():
#             val f = \: asm("nop")  # ERROR
#         """
#         check(code.contains("ERROR"))
# 
#     it "allows asm in closure inside unsafe":
#         val code = """
#         fn test():
#             unsafe:
#                 val f = \: asm("nop")  # OK
#         """
#         check(code.contains("unsafe"))
# 
# describe "Safety Checker - Complex Examples":
#     it "validates outb implementation":
#         val code = """
#         fn outb(port: u16, value: u8):
#             unsafe:
#                 asm volatile(
#                     "out dx, al",
#                     in("dx") port,
#                     in("al") value
#                 )
#         """
#         # Should have no errors
#         check(code.contains("asm volatile"))
# 
#     it "validates inb implementation":
#         val code = """
#         fn inb(port: u16) -> u8:
#             var result: u8
#             unsafe:
#                 asm volatile(
#                     "in al, dx",
#                     out("al") result,
#                     in("dx") port
#                 )
#             result
#         """
#         # Should have no errors
#         check(code.contains("result"))
# 
#     it "validates atomic CAS":
#         val code = """
#         fn atomic_cas(ptr: *mut u32, expected: u32, desired: u32) -> bool:
#             var old: u32
#             unsafe:
#                 asm volatile(
#                     "lock cmpxchg [{ptr}], {desired}",
#                     ptr = in(reg) ptr,
#                     desired = in(reg) desired,
#                     inout("eax") expected => old
#                 )
#             old == expected
#         """
#         check(code.contains("lock cmpxchg"))
# 
# describe "Safety Checker - Edge Cases":
#     it "handles empty unsafe blocks":
#         val code = """
#         fn test():
#             unsafe:
#                 pass
#         """
#         # Should be valid (though pointless)
#         check(code.contains("unsafe"))
# 
#     it "handles unsafe with only safe operations":
#         val code = """
#         fn test():
#             unsafe:
#                 val x = 5
#                 val y = x + 10
#         """
#         # Should be valid (safe ops allowed in unsafe)
#         check(code.contains("x + 10"))
# 
#     it "rejects asm in method outside unsafe":
#         val code = """
#         class Hardware:
#             fn control():
#                 asm("cli")  # ERROR
#         """
#         check(code.contains("ERROR"))
# 
#     it "accepts asm in method inside unsafe":
#         val code = """
#         class Hardware:
#             fn control():
#                 unsafe:
#                     asm("cli")  # OK
#         """
#         check(code.contains("unsafe"))
# 
# describe "Safety Checker - Integration":
#     it "checks entire module":
#         val code = """
#         fn safe_func():
#             val x = 5
# 
#         fn unsafe_func():
#             unsafe:
#                 asm("nop")
# 
#         fn bad_func():
#             asm("hlt")  # ERROR
#         """
#         # Should find error in bad_func only
#         check(code.contains("ERROR"))
# 
#     it "validates x86 I/O module":
#         val code = """
#         mod io:
#             fn outb(port: u16, value: u8):
#                 unsafe:
#                     asm volatile("out dx, al", in("dx") port, in("al") value)
# 
#             fn inb(port: u16) -> u8:
#                 var result: u8
#                 unsafe:
#                     asm volatile("in al, dx", out("al") result, in("dx") port)
#                 result
#         """
#         # Both functions should be valid
#         check(code.contains("mod io"))
