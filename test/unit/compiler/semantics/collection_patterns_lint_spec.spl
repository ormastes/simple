describe "Collection Patterns Lint":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Collection Patterns Lint Specification
# #
# # Tests for COLL001-COLL005 collection efficiency anti-pattern detection.
# 
# use compiler.core.ast.{ast_reset, module_get_decls}
# use compiler.core.parser.{parse_module}
# use compiler.semantics.lint.collection_patterns.{check_collection_patterns, CollectionLintWarning}
# 
# fn analyze(code: text) -> [CollectionLintWarning]:
#     ast_reset()
#     parse_module(code, "test.spl")
#     val decls = module_get_decls()
#     check_collection_patterns(decls)
# 
# fn has_code(warnings: [CollectionLintWarning], code: text) -> bool:
#     for w in warnings:
#         if w.code == code:
#             return true
#     false
# 
# describe "COLL001 - Array concat in loop":
#     it "warns on arr = arr + [x] in while loop":
#         val code = "fn process():\n    var items = []\n    var i = 0\n    while i < 10:\n        items = items + [i]\n        i = i + 1\n"
#         val warnings = analyze(code)
#         expect(has_code(warnings, "COLL001")).to_equal(true)
# 
#     it "warns on arr = arr + [x] in for loop":
#         val code = "fn build():\n    var result = []\n    for x in 0..10:\n        result = result + [x]\n"
#         val warnings = analyze(code)
#         expect(has_code(warnings, "COLL001")).to_equal(true)
# 
#     it "does not warn outside loop":
#         val code = "fn once():\n    var items = []\n    items = items + [1]\n"
#         val warnings = analyze(code)
#         expect(has_code(warnings, "COLL001")).to_equal(false)
# 
# describe "COLL002 - .contains() on array in loop":
#     it "warns on .contains() inside while loop":
#         val code = "fn search(data: [i64]):\n    var i = 0\n    while i < 100:\n        data.contains(i)\n        i = i + 1\n"
#         val warnings = analyze(code)
#         expect(has_code(warnings, "COLL002")).to_equal(true)
# 
#     it "does not warn on .contains() outside loop":
#         val code = "fn check(data: [i64]):\n    data.contains(5)\n"
#         val warnings = analyze(code)
#         expect(has_code(warnings, "COLL002")).to_equal(false)
# 
# describe "COLL003 - .remove(0) queue drain":
#     it "warns on .remove(0) in while loop":
#         val code = "fn drain(queue: [i64]):\n    while queue.len() > 0:\n        queue.remove(0)\n"
#         val warnings = analyze(code)
#         expect(has_code(warnings, "COLL003")).to_equal(true)
# 
#     it "does not warn on .remove(1)":
#         val code = "fn drain(queue: [i64]):\n    while queue.len() > 0:\n        queue.remove(1)\n"
#         val warnings = analyze(code)
#         expect(has_code(warnings, "COLL003")).to_equal(false)
# 
# describe "COLL004 - Loop-invariant method call":
#     it "warns on external .len() call in for loop":
#         val code = "fn process(data: [i64]):\n    for x in 0..100:\n        data.len()\n"
#         val warnings = analyze(code)
#         expect(has_code(warnings, "COLL004")).to_equal(true)
# 
#     it "does not warn when receiver is loop variable":
#         val code = "fn process(items: [[i64]]):\n    for item in items:\n        item.len()\n"
#         val warnings = analyze(code)
#         expect(has_code(warnings, "COLL004")).to_equal(false)
# 
# describe "COLL005 - Chained .filter().filter()":
#     it "warns on .filter().filter() chain":
#         val code = "fn process(data: [i64]):\n    val result = data.filter(\\x: x > 0).filter(\\x: x < 100)\n"
#         val warnings = analyze(code)
#         expect(has_code(warnings, "COLL005")).to_equal(true)
# 
#     it "does not warn on single .filter()":
#         val code = "fn process(data: [i64]):\n    val result = data.filter(\\x: x > 0)\n"
#         val warnings = analyze(code)
#         expect(has_code(warnings, "COLL005")).to_equal(false)
