# Allocation Inference Specification
#
# Tests for detecting direct allocations (new, array, dict, interpolated string)
# and transitive propagation through call graphs.

use compiler.core.lexer.{lex}
use compiler.core.parser.{parse}
use compiler.core.ast.{ast_reset}
use compiler.core.alloc_inference.{alloc_inference_analyze, alloc_inference_is_alloc, alloc_inference_get_alloc_fns, alloc_inference_get_non_alloc_fns, alloc_inference_reset}

# Helper function to analyze code and run inference
fn analyze_code(code: text):
    ast_reset()
    alloc_inference_reset()
    val tokens = lex(code)
    parse(tokens)
    alloc_inference_analyze()

describe "Direct: new keyword":
    it "detects new as allocating":
        val code = "fn create():\n    new Foo()\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("create")).to_equal(true)

    it "detects new with args as allocating":
        val code = "fn make(x: i64):\n    new Bar(x)\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("make")).to_equal(true)

describe "Direct: array literal":
    it "detects array literal as allocating":
        val code = "fn make_list():\n    [1, 2, 3]\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("make_list")).to_equal(true)

    it "detects empty array as allocating":
        val code = "fn empty():\n    []\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("empty")).to_equal(true)

describe "Direct: dict literal":
    it "detects dict literal as allocating":
        val code = "fn make_map():\n    {\"a\": 1}\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("make_map")).to_equal(true)

describe "Direct: interpolated string":
    it "detects interpolated string as allocating":
        val code = "fn greet(name: text):\n    \"hello {name}\"\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("greet")).to_equal(true)

describe "Non-allocating":
    it "pure arithmetic is not allocating":
        val code = "fn add(a: i64, b: i64) -> i64:\n    a + b\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("add")).to_equal(false)

    it "empty function is not allocating":
        val code = "fn noop():\n    pass\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("noop")).to_equal(false)

    it "function calling non-alloc fn is not allocating":
        val code = "fn add(a: i64, b: i64) -> i64:\n    a + b\nfn use_add():\n    add(1, 2)\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("use_add")).to_equal(false)

    it "return statement is not allocating":
        val code = "fn identity(x: i64) -> i64:\n    return x\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("identity")).to_equal(false)

describe "Transitive propagation":
    it "caller of alloc fn is allocating":
        val code = "fn make_list():\n    [1, 2, 3]\nfn wrapper():\n    make_list()\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("make_list")).to_equal(true)
        expect(alloc_inference_is_alloc("wrapper")).to_equal(true)

    it "two-level chain propagates":
        val code = "fn alloc_fn():\n    [1]\nfn mid():\n    alloc_fn()\nfn top():\n    mid()\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("alloc_fn")).to_equal(true)
        expect(alloc_inference_is_alloc("mid")).to_equal(true)
        expect(alloc_inference_is_alloc("top")).to_equal(true)

    it "unrelated fn not affected by alloc fn":
        val code = "fn alloc_fn():\n    [1]\nfn pure(x: i64) -> i64:\n    x + 1\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("alloc_fn")).to_equal(true)
        expect(alloc_inference_is_alloc("pure")).to_equal(false)

describe "Control flow":
    it "alloc inside if branch is allocating":
        val code = "fn maybe_alloc(x: i64):\n    if x > 0:\n        [1, 2]\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("maybe_alloc")).to_equal(true)

    it "alloc inside for loop is allocating":
        val code = "fn loop_alloc():\n    for i in range(0, 10):\n        [i]\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("loop_alloc")).to_equal(true)

    it "alloc inside while loop is allocating":
        val code = "fn while_alloc(n: i64):\n    while n > 0:\n        [n]\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("while_alloc")).to_equal(true)

describe "Nested expressions":
    it "alloc in val binding is allocating":
        val code = "fn bind_alloc():\n    val xs = [1, 2, 3]\n    xs\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("bind_alloc")).to_equal(true)

    it "alloc in var binding is allocating":
        val code = "fn var_alloc():\n    var xs = [1]\n    xs\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("var_alloc")).to_equal(true)

describe "Edge cases":
    it "external function call is not allocating":
        val code = "fn use_external():\n    print(42)\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("use_external")).to_equal(false)

    it "mutual recursion without alloc is not allocating":
        val code = "fn ping():\n    pong()\nfn pong():\n    ping()\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("ping")).to_equal(false)
        expect(alloc_inference_is_alloc("pong")).to_equal(false)

    it "mutual recursion with alloc marks both":
        val code = "fn ping():\n    [1]\n    pong()\nfn pong():\n    ping()\n"
        analyze_code(code)
        expect(alloc_inference_is_alloc("ping")).to_equal(true)
        expect(alloc_inference_is_alloc("pong")).to_equal(true)

    it "get_alloc_fns returns allocating functions":
        val code = "fn alloc_fn():\n    [1]\nfn pure_fn(x: i64) -> i64:\n    x\n"
        analyze_code(code)
        val alloc_fns = alloc_inference_get_alloc_fns()
        var has_alloc = false
        for name in alloc_fns:
            if name == "alloc_fn":
                has_alloc = true
        expect(has_alloc).to_equal(true)

    it "get_non_alloc_fns returns non-allocating functions":
        val code = "fn alloc_fn():\n    [1]\nfn pure_fn(x: i64) -> i64:\n    x\n"
        analyze_code(code)
        val non_alloc_fns = alloc_inference_get_non_alloc_fns()
        var has_pure = false
        for name in non_alloc_fns:
            if name == "pure_fn":
                has_pure = true
        expect(has_pure).to_equal(true)
