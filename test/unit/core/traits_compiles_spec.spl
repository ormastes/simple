# Tests for new @traits queries: "compiles", "get_annotations", "has_annotation"
#
# Tests the extended __traits built-in queries added to eval.spl:
#   "compiles"        — returns bool true if expr evaluates without error
#   "get_annotations" — returns [text] of known annotations on a symbol
#   "has_annotation"  — returns bool true if symbol has a given annotation

use core.ast.{ast_reset}
use core.interpreter.eval.{eval_init, eval_reset, eval_module, eval_has_error, eval_get_error}
use core.interpreter.env.{env_init}
use core.interpreter.value.{val_reset}
use core.parser.{parse_module, parser_has_errors}

# Helper: parse and evaluate a code snippet, return error message or ""
fn eval_code(code: text) -> text:
    ast_reset()
    val_reset()
    env_init()
    eval_reset()
    parse_module(code, "traits_compiles_test.spl")
    if parser_has_errors():
        return "PARSE_ERROR"
    eval_module()
    if eval_has_error():
        return eval_get_error()
    return ""

describe "@traits(\"compiles\") query":
    it "returns true for valid expression 1 + 1":
        val code = "val r = @traits(\"compiles\", 1 + 1)\n"
        val err = eval_code(code)
        expect(err).to_equal("")

    it "returns true for string literal expression":
        val code = "val r = @traits(\"compiles\", \"hello\")\n"
        val err = eval_code(code)
        expect(err).to_equal("")

    it "returns true for numeric literal":
        val code = "val r = @traits(\"compiles\", 42)\n"
        val err = eval_code(code)
        expect(err).to_equal("")

    it "does not propagate inner eval error":
        val code = "val r = @traits(\"compiles\", 1 + 1)\n"
        val err = eval_code(code)
        expect(err).to_equal("")

    it "returns false with too few arguments":
        val code = "val r = @traits(\"compiles\")\n"
        val err = eval_code(code)
        expect(err).to_equal("")

describe "@traits(\"get_annotations\") query":
    it "returns empty array for unknown symbol":
        val code = "val anns = @traits(\"get_annotations\", \"nonexistent_sym\")\n"
        val err = eval_code(code)
        expect(err).to_equal("")

    it "returns empty array for plain function with no must_use annotation":
        val code = "fn plain_fn() -> i64: 42\nval anns = @traits(\"get_annotations\", \"plain_fn\")\n"
        val err = eval_code(code)
        expect(err).to_equal("")

    it "returns empty array with no arguments":
        val code = "val anns = @traits(\"get_annotations\")\n"
        val err = eval_code(code)
        expect(err).to_equal("")

describe "@traits(\"has_annotation\") query":
    it "returns false for unknown symbol and annotation":
        val code = "val r = @traits(\"has_annotation\", \"unknown_fn\", \"must_use\")\n"
        val err = eval_code(code)
        expect(err).to_equal("")

    it "returns false for known function with no must_use annotation":
        val code = "fn regular_fn() -> i64: 99\nval r = @traits(\"has_annotation\", \"regular_fn\", \"must_use\")\n"
        val err = eval_code(code)
        expect(err).to_equal("")

    it "returns false for unrecognized annotation name":
        val code = "fn some_fn() -> i64: 1\nval r = @traits(\"has_annotation\", \"some_fn\", \"deprecated\")\n"
        val err = eval_code(code)
        expect(err).to_equal("")

    it "returns false with too few arguments":
        val code = "val r = @traits(\"has_annotation\", \"some_fn\")\n"
        val err = eval_code(code)
        expect(err).to_equal("")
