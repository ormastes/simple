"""
# Branch Coverage Test Suite - Comprehensive Core Coverage

**Feature IDs:** #BRANCH #COMPREHENSIVE
**Category:** Testing
**Status:** Implemented

## Overview

Comprehensive tests to achieve 100% branch coverage of core Simple modules.
Tests all execution paths in lexer, parser, interpreter, and type system.
"""

use std.spec.{check}
use std.text.{NL}

describe "Lexer All Branches":
    it "handles all numeric formats":
        val dec = 42
        val hex = 0xFF
        val bin = 0b1010
        val oct = 0o77
        check(dec == 42)
        check(hex == 255)
        check(bin == 10)
        check(oct == 63)

    it "handles all float formats":
        val normal = 3.14
        val exp_pos = 1.5e10
        val exp_neg = 2.5e-5
        check(normal > 3.0)
        check(exp_pos > 1.0)
        check(exp_neg < 1.0)

    it "handles all string escapes":
        val newline = "{NL}"
        val tab = "\t"
        val quote = "\""
        val backslash = "\\"
        check(newline.len() > 0)
        check(tab.len() > 0)
        check(quote == "\"")
        check(backslash == "\\")

    it "handles raw strings":
        val raw = r"{NL}\t\\"
        check(raw.contains("\\"))

    it "handles multiline strings":
        val multi = """
        line 1
        line 2
        """
        check(multi.contains("line"))

    it "handles string interpolation - all cases":
        val x = 10
        val s1 = "{x}"
        val s2 = "value: {x + 5}"
        val s3 = "{x} + {x} = {x + x}"
        check(s1.contains("10"))
        check(s2.contains("15"))
        check(s3.contains("20"))


describe "Parser All Branches":
    it "handles all operators - arithmetic":
        check(2 + 3 == 5)
        check(5 - 2 == 3)
        check(3 * 4 == 12)
        check(10 / 2 == 5)
        check(10 % 3 == 1)
        check(2 ** 3 == 8)

    it "handles all operators - comparison":
        check(5 == 5)
        check(5 != 4)
        check(5 > 4)
        check(5 >= 5)
        check(4 < 5)
        check(4 <= 4)

    it "handles all operators - logical":
        check(true and true)
        check(true or false)
        check(not false)

    it "handles all operators - bitwise":
        check((5 & 3) == 1)
        check((5 | 3) == 7)
        check((5 ^ 3) == 6)

    it "handles unary operators":
        check(-5 < 0)
        check(+5 > 0)
        check(not false == true)

    it "handles precedence - all levels":
        check(2 + 3 * 4 == 14)
        check((2 + 3) * 4 == 20)
        check(2 ** 3 * 4 == 32)
        check(10 - 5 - 2 == 3)

    it "handles associativity":
        check(10 - 5 - 2 == 3)
        check(2 ** 3 ** 2 == 512)


describe "Control Flow All Branches":
    it "if - then only":
        var x = 0
        if true:
            x = 1
        check(x == 1)

    it "if - else taken":
        var x = 0
        if false:
            x = 1
        else:
            x = 2
        check(x == 2)

    it "if - elif - first":
        var x = 0
        if true:
            x = 1
        elif true:
            x = 2
        else:
            x = 3
        check(x == 1)

    it "if - elif - second":
        var x = 0
        if false:
            x = 1
        elif true:
            x = 2
        else:
            x = 3
        check(x == 2)

    it "if - elif - else":
        var x = 0
        if false:
            x = 1
        elif false:
            x = 2
        else:
            x = 3
        check(x == 3)

    it "nested if - all paths":
        var result = 0
        if true:
            if true:
                result = 1
            else:
                result = 2
        else:
            result = 3
        check(result == 1)


describe "Loop All Branches":
    it "for - empty range":
        var count = 0
        for i in 0..0:
            count = count + 1
        check(count == 0)

    it "for - single iteration":
        var count = 0
        for i in 0..1:
            count = count + 1
        check(count == 1)

    it "for - multiple iterations":
        var count = 0
        for i in 0..5:
            count = count + 1
        check(count == 5)

    it "for - with break first":
        var count = 0
        for i in 0..10:
            count = count + 1
            break
        check(count == 1)

    it "for - with break middle":
        var count = 0
        for i in 0..10:
            count = count + 1
            if count == 5:
                break
        check(count == 5)

    it "for - with continue":
        var count = 0
        for i in 0..10:
            if i % 2 == 0:
                continue
            count = count + 1
        check(count == 5)

    it "for - all continue":
        var count = 0
        for i in 0..5:
            continue
            count = count + 1
        check(count == 0)

    it "while - never enters":
        var count = 0
        while false:
            count = count + 1
        check(count == 0)

    it "while - enters once":
        var count = 0
        while count < 1:
            count = count + 1
        check(count == 1)

    it "while - multiple times":
        var count = 0
        while count < 5:
            count = count + 1
        check(count == 5)

    it "while - with break":
        var count = 0
        while true:
            count = count + 1
            if count == 3:
                break
        check(count == 3)

    it "while - with continue":
        var count = 0
        var iter = 0
        while iter < 10:
            iter = iter + 1
            if iter % 2 == 0:
                continue
            count = count + 1
        check(count == 5)


describe "Match All Branches":
    it "match - first case":
        val x = 1
        val r = match x:
            1: "a"
            2: "b"
            3: "c"
            _: "d"
        check(r == "a")

    it "match - middle case":
        val x = 2
        val r = match x:
            1: "a"
            2: "b"
            3: "c"
            _: "d"
        check(r == "b")

    it "match - last case":
        val x = 3
        val r = match x:
            1: "a"
            2: "b"
            3: "c"
            _: "d"
        check(r == "c")

    it "match - default":
        val x = 99
        val r = match x:
            1: "a"
            2: "b"
            3: "c"
            _: "d"
        check(r == "d")

    it "match - Some":
        val opt = Some(42)
        var r = 0
        match opt:
            Some(x): r = x
            nil: r = -1
        check(r == 42)

    it "match - nil":
        val opt = nil
        var r = 0
        match opt:
            Some(x): r = 99
            nil: r = -1
        check(r == -1)

    it "match - boolean true":
        val b = true
        val r = match b:
            true: 1
            false: 0
        check(r == 1)

    it "match - boolean false":
        val b = false
        val r = match b:
            true: 1
            false: 0
        check(r == 0)


describe "Array All Branches":
    it "array - empty":
        val arr = []
        check(arr.len() == 0)

    it "array - single element":
        val arr = [1]
        check(arr.len() == 1)
        check(arr[0] == 1)

    it "array - multiple elements":
        val arr = [1, 2, 3, 4, 5]
        check(arr.len() == 5)

    it "array - index positive":
        val arr = [10, 20, 30]
        check(arr[0] == 10)
        check(arr[1] == 20)
        check(arr[2] == 30)

    it "array - index negative":
        val arr = [10, 20, 30]
        check(arr[-1] == 30)
        check(arr[-2] == 20)
        check(arr[-3] == 10)

    it "array - slice empty":
        val arr = [1, 2, 3]
        val slice = arr[1..1]
        check(slice.len() == 0)

    it "array - slice full":
        val arr = [1, 2, 3]
        val slice = arr[0..3]
        check(slice.len() == 3)

    it "array - slice partial":
        val arr = [1, 2, 3, 4, 5]
        val slice = arr[1..4]
        check(slice.len() == 3)
        check(slice[0] == 2)


describe "Optional All Branches":
    it "optional - Some exists":
        val opt: i64? = Some(42)
        check(opt.?)

    it "optional - nil":
        val opt: i64? = nil
        check(not opt.?)

    it "optional - unwrap Some":
        val opt = Some(42)
        check(opt? == 42)

    it "optional - coalesce Some":
        val opt = Some(42)
        val r = opt ?? 99
        check(r == 42)

    it "optional - coalesce nil":
        val opt: i64? = nil
        val r = opt ?? 99
        check(r == 99)

    it "optional - chain Some-Some":
        val opt: i64?? = Some(Some(10))
        check(opt.?)

    it "optional - chain Some-nil":
        val opt: i64?? = Some(nil)
        check(opt.?)

    it "optional - chain nil":
        val opt: i64?? = nil
        check(not opt.?)


describe "Boolean All Branches":
    it "and - TT":
        check(true and true == true)

    it "and - TF":
        check(true and false == false)

    it "and - FT":
        check(false and true == false)

    it "and - FF":
        check(false and false == false)

    it "or - TT":
        check(true or true == true)

    it "or - TF":
        check(true or false == true)

    it "or - FT":
        check(false or true == true)

    it "or - FF":
        check(false or false == false)

    it "not - T":
        check(not true == false)

    it "not - F":
        check(not false == true)

    it "xor - TT":
        check((true != true) == false)

    it "xor - TF":
        check((true != false) == true)

    it "xor - FT":
        check((false != true) == true)

    it "xor - FF":
        check((false != false) == false)


describe "Type System All Branches":
    it "type - int":
        val x: i64 = 42
        check(x == 42)

    it "type - float":
        val x: f64 = 3.14
        check(x > 3.0)

    it "type - bool":
        val x: bool = true
        check(x)

    it "type - text":
        val x: text = "hello"
        check(x == "hello")

    it "type - array":
        val x: [i64] = [1, 2, 3]
        check(x.len() == 3)

    it "type - optional":
        val x: i64? = Some(42)
        check(x.?)

    it "type - nil literal":
        val x = nil
        check(not x.?)


describe "Function All Branches":
    it "function - no params no return":
        fn test():
            pass
        test()
        check(true)

    it "function - with params":
        fn test(x: i64) -> i64:
            x * 2
        check(test(5) == 10)

    it "function - multiple params":
        fn test(x: i64, y: i64) -> i64:
            x + y
        check(test(3, 4) == 7)

    it "function - early return":
        fn test(x: i64) -> i64:
            if x < 0:
                return 0
            x * 2
        check(test(-5) == 0)
        check(test(5) == 10)

    it "function - multiple returns":
        fn test(x: i64) -> i64:
            if x < 0:
                return -1
            elif x == 0:
                return 0
            else:
                return 1
        check(test(-5) == -1)
        check(test(0) == 0)
        check(test(5) == 1)
