# Core Interpreter â€” Operations Tests
#
# Mirrors arithmetic/comparison/logical tests from:
#   test/system/interpreter/interpreter_basics_spec.spl
#   src/compiler/backend/interpreter.spl (eval_binop, eval_unaryop)

use core.interpreter.value.{val_reset, val_make_nil, val_make_bool, val_make_int, val_make_float, val_make_text}
use core.interpreter.value.{val_get_kind, val_get_int, val_get_bool, val_get_float, val_get_text}
use core.interpreter.value.{val_is_truthy, VAL_INT, VAL_BOOL, VAL_TEXT, VAL_NIL}
use core.interpreter.ops.{val_add, val_sub, val_mul, val_div, val_mod}
use core.interpreter.ops.{val_eq, val_neq, val_lt, val_gt, val_lteq, val_gteq}
use core.interpreter.ops.{val_and, val_or, val_not, val_negate}
use core.interpreter.ops.{val_binary_op, val_unary_op, val_compound_op}
use core.interpreter.ops.{ops_get_error, ops_clear_error}

describe "Core Interpreter Operations":
    before_each:
        val_reset()
        ops_clear_error()

    # Migrated from interpreter_basics_spec: "handles arithmetic operations"
    describe "arithmetic":
        it "adds integers":
            val r = val_add(val_make_int(1), val_make_int(1))
            expect(val_get_int(r)).to_equal(2)

        it "subtracts integers":
            val r = val_sub(val_make_int(10), val_make_int(3))
            expect(val_get_int(r)).to_equal(7)

        it "multiplies integers":
            val r = val_mul(val_make_int(4), val_make_int(5))
            expect(val_get_int(r)).to_equal(20)

        it "divides integers":
            val r = val_div(val_make_int(15), val_make_int(3))
            expect(val_get_int(r)).to_equal(5)

        it "modulo integers":
            val r = val_mod(val_make_int(10), val_make_int(3))
            expect(val_get_int(r)).to_equal(1)

        it "division by zero returns error":
            val r = val_div(val_make_int(10), val_make_int(0))
            expect(r).to_equal(-1)
            expect(ops_get_error()).to_contain("division by zero")

        it "modulo by zero returns error":
            val r = val_mod(val_make_int(10), val_make_int(0))
            expect(r).to_equal(-1)
            expect(ops_get_error()).to_contain("modulo by zero")

        it "adds floats":
            val r = val_add(val_make_float(1.5), val_make_float(2.5))
            expect(val_get_kind(r)).to_equal(3)

        it "concatenates text":
            val r = val_add(val_make_text("Hello"), val_make_text(" World"))
            expect(val_get_text(r)).to_equal("Hello World")

        it "type error on mixed add":
            val r = val_add(val_make_int(1), val_make_text("x"))
            expect(r).to_equal(-1)
            expect(ops_get_error()).to_contain("type error")

    # Migrated from interpreter_basics_spec: "handles comparison operations"
    describe "comparisons":
        it "greater than":
            val r = val_gt(val_make_int(5), val_make_int(3))
            expect(val_get_bool(r)).to_equal(true)

        it "less than":
            val r = val_lt(val_make_int(2), val_make_int(10))
            expect(val_get_bool(r)).to_equal(true)

        it "equal":
            val r = val_eq(val_make_int(5), val_make_int(5))
            expect(val_get_bool(r)).to_equal(true)

        it "not equal":
            val r = val_neq(val_make_int(3), val_make_int(4))
            expect(val_get_bool(r)).to_equal(true)

        it "less than or equal":
            val r1 = val_lteq(val_make_int(3), val_make_int(5))
            expect(val_get_bool(r1)).to_equal(true)
            val r2 = val_lteq(val_make_int(5), val_make_int(5))
            expect(val_get_bool(r2)).to_equal(true)
            val r3 = val_lteq(val_make_int(6), val_make_int(5))
            expect(val_get_bool(r3)).to_equal(false)

        it "greater than or equal":
            val r1 = val_gteq(val_make_int(5), val_make_int(3))
            expect(val_get_bool(r1)).to_equal(true)
            val r2 = val_gteq(val_make_int(5), val_make_int(5))
            expect(val_get_bool(r2)).to_equal(true)

        it "compares text":
            val r = val_lt(val_make_text("a"), val_make_text("b"))
            expect(val_get_bool(r)).to_equal(true)

        it "nil equality":
            val r = val_eq(val_make_nil(), val_make_nil())
            expect(val_get_bool(r)).to_equal(true)

    # Migrated from interpreter_basics_spec: "handles boolean operations"
    describe "logical operations":
        it "and with both true":
            val r = val_and(val_make_bool(true), val_make_bool(true))
            expect(val_get_bool(r)).to_equal(true)

        it "and with one false":
            val r = val_and(val_make_bool(true), val_make_bool(false))
            expect(val_get_bool(r)).to_equal(false)

        it "or with one true":
            val r = val_or(val_make_bool(true), val_make_bool(false))
            expect(val_get_bool(r)).to_equal(true)

        it "or with both false":
            val r = val_or(val_make_bool(false), val_make_bool(false))
            expect(val_get_bool(r)).to_equal(false)

        it "not true":
            val r = val_not(val_make_bool(true))
            expect(val_get_bool(r)).to_equal(false)

        it "not false":
            val r = val_not(val_make_bool(false))
            expect(val_get_bool(r)).to_equal(true)

    describe "unary operations":
        it "negates integer":
            val r = val_negate(val_make_int(42))
            expect(val_get_int(r)).to_equal(-42)

        it "negates negative integer":
            val r = val_negate(val_make_int(-5))
            expect(val_get_int(r)).to_equal(5)

        it "negate type error on text":
            val r = val_negate(val_make_text("x"))
            expect(r).to_equal(-1)

    # Migrated from compiler/backend/interpreter.spl eval_binop dispatch
    describe "binary op dispatch (by token kind)":
        it "dispatches TOK_PLUS (60)":
            val r = val_binary_op(60, val_make_int(3), val_make_int(4))
            expect(val_get_int(r)).to_equal(7)

        it "dispatches TOK_MINUS (61)":
            val r = val_binary_op(61, val_make_int(10), val_make_int(3))
            expect(val_get_int(r)).to_equal(7)

        it "dispatches TOK_STAR (62)":
            val r = val_binary_op(62, val_make_int(4), val_make_int(5))
            expect(val_get_int(r)).to_equal(20)

        it "dispatches TOK_SLASH (63)":
            val r = val_binary_op(63, val_make_int(15), val_make_int(3))
            expect(val_get_int(r)).to_equal(5)

        it "dispatches TOK_PERCENT (64)":
            val r = val_binary_op(64, val_make_int(10), val_make_int(3))
            expect(val_get_int(r)).to_equal(1)

        it "dispatches TOK_EQ (80)":
            val r = val_binary_op(80, val_make_int(5), val_make_int(5))
            expect(val_get_bool(r)).to_equal(true)

        it "dispatches TOK_NOT_EQ (81)":
            val r = val_binary_op(81, val_make_int(5), val_make_int(3))
            expect(val_get_bool(r)).to_equal(true)

        it "dispatches TOK_LT (82)":
            val r = val_binary_op(82, val_make_int(3), val_make_int(5))
            expect(val_get_bool(r)).to_equal(true)

        it "dispatches TOK_GT (83)":
            val r = val_binary_op(83, val_make_int(5), val_make_int(3))
            expect(val_get_bool(r)).to_equal(true)

        it "dispatches TOK_KW_AND (55)":
            val r = val_binary_op(55, val_make_bool(true), val_make_bool(true))
            expect(val_get_bool(r)).to_equal(true)

        it "dispatches TOK_KW_OR (56)":
            val r = val_binary_op(56, val_make_bool(false), val_make_bool(true))
            expect(val_get_bool(r)).to_equal(true)

    describe "unary op dispatch":
        it "dispatches TOK_MINUS (61) for negate":
            val r = val_unary_op(61, val_make_int(42))
            expect(val_get_int(r)).to_equal(-42)

        it "dispatches TOK_KW_NOT (57) for not":
            val r = val_unary_op(57, val_make_bool(true))
            expect(val_get_bool(r)).to_equal(false)

    # Migrated from compiler/backend/interpreter.spl apply_assign_op
    describe "compound assignment dispatch":
        it "dispatches TOK_PLUS_EQ (101)":
            val r = val_compound_op(101, val_make_int(10), val_make_int(5))
            expect(val_get_int(r)).to_equal(15)

        it "dispatches TOK_MINUS_EQ (102)":
            val r = val_compound_op(102, val_make_int(10), val_make_int(3))
            expect(val_get_int(r)).to_equal(7)

        it "dispatches TOK_STAR_EQ (103)":
            val r = val_compound_op(103, val_make_int(4), val_make_int(5))
            expect(val_get_int(r)).to_equal(20)

        it "dispatches TOK_SLASH_EQ (104)":
            val r = val_compound_op(104, val_make_int(15), val_make_int(3))
            expect(val_get_int(r)).to_equal(5)

        it "dispatches TOK_PERCENT_EQ (105)":
            val r = val_compound_op(105, val_make_int(10), val_make_int(3))
            expect(val_get_int(r)).to_equal(1)
