# Core Compiler Branch Coverage Tests
#
# Tests language features that exercise core compiler branches.
# Uses source code execution to cover lexer, parser, and type checker.

use std.spec.*

describe "Number Literal Branches":
    it "covers integer literals":
        val a = 42
        val b = 0
        val c = 1_000_000
        expect a == 42
        expect b == 0
        expect c == 1000000
    
    it "covers hex literals":
        val h1 = 0xFF
        val h2 = 0xABCDEF
        val h3 = 0xFF_FF
        expect h1 == 255
    
    it "covers binary literals":
        val b1 = 0b1010
        val b2 = 0b1111_0000
        expect b1 == 10
    
    it "covers octal literals":
        val o1 = 0o777
        val o2 = 0o77_77
        expect o1 == 511
    
    it "covers float literals":
        val f1 = 3.14
        val f2 = 1_000.000_1
        val f3 = 1e10
        val f4 = 1E10
        val f5 = 1e+10
        val f6 = 1e-10
        val f7 = 1.23e-45
        expect f1 > 3.0

describe "String Literal Branches":
    it "covers simple strings":
        val s1 = "hello"
        val s2 = "world"
        expect s1 == "hello"
        expect s2 == "world"
    
    it "covers escape sequences":
        val e1 = "a\nb"
        val e2 = "a\tb"
        val e3 = "a\\b"
        val e4 = "a\"b"
        expect e1.len() == 3
        expect e2.len() == 3

describe "Keyword Branches":
    it "covers val and var":
        val x = 1
        var y = 2
        y = 3
        expect x == 1
        expect y == 3
    
    it "covers fn keyword":
        fn add(a: i64, b: i64) -> i64:
            a + b
        expect add(1, 2) == 3
    
    it "covers if/elif/else":
        val x = 5
        val r = if x > 10:
            "big"
        elif x > 3:
            "medium"
        else:
            "small"
        expect r == "medium"
    
    it "covers match":
        val x = 2
        val r = match x:
            case 1:
                "one"
            case 2:
                "two"
            case _:
                "other"
        expect r == "two"
    
    it "covers for loop":
        var sum = 0
        for i in 0..5:
            sum = sum + i
        expect sum == 10
    
    it "covers while loop":
        var count = 0
        while count < 3:
            count = count + 1
        expect count == 3
    
    it "covers return":
        fn get_value() -> i64:
            return 42
        expect get_value() == 42
    
    it "covers break and continue":
        var sum = 0
        for i in 0..10:
            if i == 5:
                break
            if i == 2:
                continue
            sum = sum + i
        expect sum == 1 + 3 + 4

describe "Operator Branches":
    it "covers arithmetic operators":
        expect 1 + 2 == 3
        expect 5 - 3 == 2
        expect 4 * 3 == 12
        expect 10 / 2 == 5
        expect 10 % 3 == 1
    
    it "covers comparison operators":
        expect (1 == 1) == true
        expect (1 != 2) == true
        expect (1 < 2) == true
        expect (2 > 1) == true
        expect (1 <= 1) == true
        expect (1 >= 1) == true
    
    it "covers logical operators":
        expect (true and true) == true
        expect (true and false) == false
        expect (true or false) == true
        expect (false or false) == false
        expect (not false) == true
    
    it "covers assignment operators":
        var x = 10
        x += 5
        expect x == 15
        x -= 3
        expect x == 12
        x *= 2
        expect x == 24
        x /= 4
        expect x == 6

describe "Delimiter Branches":
    it "covers parentheses":
        val r = (1 + 2) * 3
        expect r == 9
    
    it "covers brackets":
        val arr = [1, 2, 3]
        expect arr[0] == 1
    
    it "covers braces":
        struct Obj:
            x: i64
            y: i64
        val obj = Obj { x: 1, y: 2 }
        expect obj.x == 1
    
    it "covers range operators":
        var count = 0
        for i in 0..5:
            count = count + 1
        expect count == 5
        
        var count2 = 0
        for i in 0..=5:
            count2 = count2 + 1
        expect count2 == 6
    
    it "covers optional operators":
        val x: i64? = nil
        val y = x ?? 42
        expect y == 42

describe "Complex Expression Branches":
    it "covers nested expressions":
        val a = (1 + 2) * (3 + 4) - 5
        expect a == 16
    
    it "covers method chaining":
        val s = "hello"
        val r = s.len()
        expect r == 5
    
    it "covers lambda expressions":
        val f = \x: x * 2
        expect f(5) == 10
    
    it "covers list operations":
        val arr = [1, 2, 3]
        val mapped = arr.map(\x: x * 2)
        expect mapped[0] == 2
        expect mapped[1] == 4
        expect mapped[2] == 6

describe "Control Flow Branches":
    it "covers nested if":
        val x = 5
        val y = 10
        val r = if x > 0:
            if y > 5:
                "both"
            else:
                "x only"
        else:
            "neither"
        expect r == "both"
    
    it "covers early return":
        fn find_first_even(arr: [i64]) -> i64?:
            for x in arr:
                if x % 2 == 0:
                    return x
            nil
        expect find_first_even([1, 3, 4, 5]) == 4
        expect find_first_even([1, 3, 5]) == nil
    
    it "covers match with guards":
        fn classify(x: i64) -> text:
            match x:
                case n if n < 0:
                    "negative"
                case 0:
                    "zero"
                case n if n > 100:
                    "large"
                case _:
                    "small"
        expect classify(-5) == "negative"
        expect classify(0) == "zero"
        expect classify(200) == "large"
        expect classify(50) == "small"

describe "Type System Branches":
    it "covers basic types":
        val i: i64 = 42
        val f: f64 = 3.14
        val b: bool = true
        val s: text = "hello"
        expect i == 42
        expect b == true
    
    it "covers optional types":
        val x: i64? = 42
        val y: i64? = nil
        expect x == 42
        expect y == nil
    
    it "covers array types":
        val arr: [i64] = [1, 2, 3]
        expect arr.len() == 3
    
    it "covers struct types":
        struct Point:
            x: i64
            y: i64
        val p = Point { x: 1, y: 2 }
        expect p.x == 1
        expect p.y == 2

describe "Edge Cases":
    it "covers empty collections":
        val empty: [i64] = []
        expect empty.len() == 0
    
    it "covers single element":
        val single = [42]
        expect single[0] == 42
    
    it "covers zero values":
        val zero = 0
        val empty_str = ""
        expect zero == 0
        expect empty_str.len() == 0
    
    it "covers negative numbers":
        val neg = -42
        expect neg == -42
        expect neg < 0

describe "Test Summary":
    it "reports coverage":
        print ""
        print "Core Compiler Branch Coverage Tests Complete"
        print "Covered:"
        print "  - All number literal types"
        print "  - All string escapes"
        print "  - All keywords"
        print "  - All operators"
        print "  - All delimiters"
        print "  - Complex expressions"
        print "  - Control flow"
        print "  - Type system"
        print "  - Edge cases"
