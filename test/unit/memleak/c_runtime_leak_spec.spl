# C Runtime Memory Leak Regression Tests
#
# Documents and reproduces all 9 memory leak categories found in the C runtime
# and generated C code. Each test verifies the fix is present.
#
# For actual ASan verification, run:
#   cmake -B build-asan -G Ninja -DCMAKE_C_COMPILER=clang -DCMAKE_C_FLAGS="-fsanitize=address,leak -g" -DCMAKE_EXE_LINKER_FLAGS="-fsanitize=address,leak" -S src/compiler_cpp
#   ninja -C build-asan && ASAN_OPTIONS=detect_leaks=1 build-asan/simple --version
#
# == Leak Record ==
#
# Leak 1: Nested array types [[text]]/[[i64]] had no free functions.
#   Fix: Added simple_string_array_array_free() and simple_int_array_array_free().
#   File: src/app/compile/c_runtime.c
#
# Leak 2: simple_string_array_copy_push() shallow-copied string pointers.
#   Fix: Deep-copy via strdup() each element.
#   File: src/app/compile/c_runtime.c
#
# Leak 3: Option/Result stored raw pointer (no strdup), no free function.
#   Fix: strdup() on input. Added simple_option_free() and simple_result_free().
#   File: src/app/compile/c_runtime.c
#
# Leak 4: Codegen mapped Opaque("str") to void* â€” could not track string locals.
#   Fix: Map to const char*, track str_locals, emit cleanup on reassign/return.
#   Files: c_type_mapper.spl, c_backend.spl
#
# Leak 5: Generated main.c had no simple_string_array_free(), never freed arrays.
#   Fix: Added free function, atexit cleanup.
#   File: src/compiler_cpp/main.c
#
# Leak 6: simple_string_array_slice() results in command dispatch never freed.
#   Fix: Store result, call handler, free array, then return.
#   File: src/compiler_cpp/main.c
#
# Leak 7: simple_substr_from() returned strdup'd strings for flag parsing, never freed.
#   Fix: Use pointer arithmetic (arg + N) instead of simple_substr_from().
#   File: src/compiler_cpp/main.c
#
# Leak 8: run_lex_command() called get_cli_args() but never freed the array.
#   Fix: Free args before return.
#   File: src/compiler_cpp/main.c
#
# Leak 9: program_args in default file-execution branch never freed.
#   Fix: Store return code, free array, then return.
#   File: src/compiler_cpp/main.c

extern fn rt_file_read_text(path: text) -> text

describe "C Runtime Leak 1 - Nested array free functions exist":
    it "c_runtime.c has simple_string_array_array_free":
        val content = rt_file_read_text("src/app/compile/c_runtime.c") ?? ""
        expect(content.contains("simple_string_array_array_free")).to_equal(true)

    it "c_runtime.c has simple_int_array_array_free":
        val content = rt_file_read_text("src/app/compile/c_runtime.c") ?? ""
        expect(content.contains("simple_int_array_array_free")).to_equal(true)

    it "string_array_array_free iterates and frees inner arrays":
        val content = rt_file_read_text("src/app/compile/c_runtime.c") ?? ""
        # The free function must call simple_string_array_free on each inner array
        expect(content.contains("simple_string_array_free(&arr->items[i])")).to_equal(true)

    it "int_array_array_free iterates and frees inner arrays":
        val content = rt_file_read_text("src/app/compile/c_runtime.c") ?? ""
        expect(content.contains("simple_int_array_free(&arr->items[i])")).to_equal(true)

describe "C Runtime Leak 2 - String copy_push deep-copies via strdup":
    it "simple_string_array_copy_push uses strdup for each element":
        val content = rt_file_read_text("src/app/compile/c_runtime.c") ?? ""
        # Must contain strdup in the copy_push function body
        # The fix changed from: dst.items[i] = src.items[i]
        # To: dst.items[i] = strdup(src.items[i] ? src.items[i] : "")
        expect(content.contains("strdup(src.items[i]")).to_equal(true)

describe "C Runtime Leak 3 - Option/Result own strings via strdup":
    it "simple_some_str uses strdup":
        val content = rt_file_read_text("src/app/compile/c_runtime.c") ?? ""
        # Must strdup the input string so Option owns its copy
        expect(content.contains("o.str_val = strdup(val")).to_equal(true)

    it "simple_result_ok_str uses strdup":
        val content = rt_file_read_text("src/app/compile/c_runtime.c") ?? ""
        expect(content.contains("r.ok_str = strdup(val")).to_equal(true)

    it "simple_result_err_str uses strdup":
        val content = rt_file_read_text("src/app/compile/c_runtime.c") ?? ""
        expect(content.contains("r.err_str = strdup(val")).to_equal(true)

    it "simple_option_free exists and frees string":
        val content = rt_file_read_text("src/app/compile/c_runtime.c") ?? ""
        expect(content.contains("simple_option_free")).to_equal(true)
        expect(content.contains("free((char*)o->str_val)")).to_equal(true)

    it "simple_result_free exists and frees strings":
        val content = rt_file_read_text("src/app/compile/c_runtime.c") ?? ""
        expect(content.contains("simple_result_free")).to_equal(true)
        expect(content.contains("free((char*)r->ok_str)")).to_equal(true)
        expect(content.contains("free((char*)r->err_str)")).to_equal(true)

describe "C Runtime Leak 4 - Codegen maps str to const char*":
    it "c_type_mapper maps Opaque str to const char*":
        val content = rt_file_read_text("src/compiler/70.backend/backend/c_type_mapper.spl") ?? ""
        # Must map Opaque("str") to "const char*" not "void*"
        expect(content.contains("const char*")).to_equal(true)

    it "c_backend tracks string locals via str_locals dict":
        val content = rt_file_read_text("src/compiler/70.backend/backend/c_backend.spl") ?? ""
        expect(content.contains("str_locals")).to_equal(true)

    it "c_backend has emit_str_cleanup for free-before-reassign":
        val content = rt_file_read_text("src/compiler/70.backend/backend/c_backend.spl") ?? ""
        expect(content.contains("emit_str_cleanup")).to_equal(true)

    it "c_backend has emit_str_cleanup_all for function exit":
        val content = rt_file_read_text("src/compiler/70.backend/backend/c_backend.spl") ?? ""
        expect(content.contains("emit_str_cleanup_all")).to_equal(true)

describe "C Runtime Leak 5 - Generated main.c has array cleanup":
    it "main.c contains simple_string_array_free definition":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        expect(content.contains("simple_string_array_free")).to_equal(true)

    it "main.c frees all_args in get_cli_args before return":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        expect(content.contains("simple_string_array_free(&all_args)")).to_equal(true)

    it "main.c has atexit cleanup for main arrays":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        expect(content.contains("atexit(_main_cleanup)")).to_equal(true)

    it "main.c cleanup function frees both args and filtered_args":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        expect(content.contains("simple_string_array_free(&_main_args)")).to_equal(true)
        expect(content.contains("simple_string_array_free(&_main_filtered)")).to_equal(true)

describe "C Runtime Leak Regression - Bootstrap runtime synced":
    it "bootstrap c_runtime.c has all free functions":
        val content = rt_file_read_text("src/compiler_cpp/c_runtime.c") ?? ""
        expect(content.contains("simple_string_array_free")).to_equal(true)
        expect(content.contains("simple_int_array_free")).to_equal(true)
        expect(content.contains("simple_string_array_array_free")).to_equal(true)
        expect(content.contains("simple_int_array_array_free")).to_equal(true)
        expect(content.contains("simple_option_free")).to_equal(true)
        expect(content.contains("simple_result_free")).to_equal(true)
        expect(content.contains("simple_dict_free")).to_equal(true)

    it "bootstrap c_runtime.c uses strdup in copy_push":
        val content = rt_file_read_text("src/compiler_cpp/c_runtime.c") ?? ""
        expect(content.contains("strdup(src.items[i]")).to_equal(true)

    it "bootstrap c_runtime.c uses strdup in Option/Result":
        val content = rt_file_read_text("src/compiler_cpp/c_runtime.c") ?? ""
        expect(content.contains("o.str_val = strdup")).to_equal(true)

describe "C Runtime Leak 6 - Sliced arrays freed in command dispatch":
    it "main.c frees test_args after cli_run_tests":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        expect(content.contains("simple_string_array_free(&test_args)")).to_equal(true)

    it "main.c frees build_args after handle_build":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        expect(content.contains("simple_string_array_free(&build_args)")).to_equal(true)

    it "main.c frees check_args after run_check":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        expect(content.contains("simple_string_array_free(&check_args)")).to_equal(true)

    it "main.c frees stats_args after run_stats":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        expect(content.contains("simple_string_array_free(&stats_args)")).to_equal(true)

describe "C Runtime Leak 7 - No substr_from in flag parsing":
    it "main.c uses pointer arithmetic for jit-threshold":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        expect(content.contains("atoll(arg + 16)")).to_equal(true)

    it "main.c uses pointer arithmetic for backend":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        expect(content.contains("backend = arg + 10")).to_equal(true)

    it "main.c uses pointer arithmetic for timeout":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        expect(content.contains("atoll(arg + 10)")).to_equal(true)

describe "C Runtime Leak 8 - run_lex_command frees args":
    it "main.c frees args in run_lex_command":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        # run_lex_command must free the args array before returning
        expect(content.contains("long long rc = cli_run_lex(args)")).to_equal(true)
        expect(content.contains("simple_string_array_free(&args)")).to_equal(true)

describe "C Runtime Leak 9 - program_args freed in default branch":
    it "main.c frees program_args before return":
        val content = rt_file_read_text("src/compiler_cpp/main.c") ?? ""
        expect(content.contains("simple_string_array_free(&program_args)")).to_equal(true)
