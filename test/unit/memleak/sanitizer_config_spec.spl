# Sanitizer Configuration Tests
#
# Verifies that all LLVM sanitizer options, suppression files,
# and CI workflow are properly configured.

extern fn rt_file_read_text(path: text) -> text

describe "CMakeLists.txt has all sanitizer options":
    it "has ENABLE_UBSAN option":
        val content = rt_file_read_text("src/compiler_cpp/CMakeLists.txt") ?? ""
        expect(content.contains("ENABLE_UBSAN")).to_equal(true)

    it "has ENABLE_TSAN option":
        val content = rt_file_read_text("src/compiler_cpp/CMakeLists.txt") ?? ""
        expect(content.contains("ENABLE_TSAN")).to_equal(true)

    it "has ENABLE_MSAN option":
        val content = rt_file_read_text("src/compiler_cpp/CMakeLists.txt") ?? ""
        expect(content.contains("ENABLE_MSAN")).to_equal(true)

describe "CMakeLists.txt has mutual exclusion guard":
    it "has _SANITIZER_COUNT variable":
        val content = rt_file_read_text("src/compiler_cpp/CMakeLists.txt") ?? ""
        expect(content.contains("_SANITIZER_COUNT")).to_equal(true)

    it "has FATAL_ERROR for multiple sanitizers":
        val content = rt_file_read_text("src/compiler_cpp/CMakeLists.txt") ?? ""
        expect(content.contains("FATAL_ERROR")).to_equal(true)

describe "CMakeLists.txt has correct sanitizer flags":
    it "UBSan has -fno-sanitize-recover=undefined":
        val content = rt_file_read_text("src/compiler_cpp/CMakeLists.txt") ?? ""
        expect(content.contains("-fno-sanitize-recover=undefined")).to_equal(true)

    it "TSan has -fPIE flag":
        val content = rt_file_read_text("src/compiler_cpp/CMakeLists.txt") ?? ""
        expect(content.contains("-fPIE")).to_equal(true)

    it "TSan has -pie link flag":
        val content = rt_file_read_text("src/compiler_cpp/CMakeLists.txt") ?? ""
        expect(content.contains("-pie")).to_equal(true)

    it "MSan has -fsanitize-memory-track-origins=2":
        val content = rt_file_read_text("src/compiler_cpp/CMakeLists.txt") ?? ""
        expect(content.contains("-fsanitize-memory-track-origins=2")).to_equal(true)

describe "Suppression files exist and are non-empty":
    it "asan.supp exists":
        val content = rt_file_read_text("src/compiler_cpp/sanitizers/asan.supp") ?? ""
        expect(content.len() > 0).to_equal(true)

    it "lsan.supp exists with memtrack suppressions":
        val content = rt_file_read_text("src/compiler_cpp/sanitizers/lsan.supp") ?? ""
        expect(content.contains("memtrack_ensure_init")).to_equal(true)

    it "ubsan_blacklist.txt exists with ptr_hash":
        val content = rt_file_read_text("src/compiler_cpp/sanitizers/ubsan_blacklist.txt") ?? ""
        expect(content.contains("ptr_hash")).to_equal(true)

    it "tsan.supp exists with handle lock suppressions":
        val content = rt_file_read_text("src/compiler_cpp/sanitizers/tsan.supp") ?? ""
        expect(content.contains("g_handle_lock_initialized")).to_equal(true)

describe "CI workflow exists with all jobs":
    it "sanitizer-ci.yml exists":
        val content = rt_file_read_text(".github/workflows/sanitizer-ci.yml") ?? ""
        expect(content.len() > 0).to_equal(true)

    it "has asan-ubsan job":
        val content = rt_file_read_text(".github/workflows/sanitizer-ci.yml") ?? ""
        expect(content.contains("asan-ubsan")).to_equal(true)

    it "has tsan job":
        val content = rt_file_read_text(".github/workflows/sanitizer-ci.yml") ?? ""
        expect(content.contains("tsan")).to_equal(true)

    it "has ubsan-standalone job":
        val content = rt_file_read_text(".github/workflows/sanitizer-ci.yml") ?? ""
        expect(content.contains("ubsan-standalone")).to_equal(true)
