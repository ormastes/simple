# Extended Feature IDs Specification
# Tests all new FeatureId enum variants including breakpoint management,
# frame navigation, ptrace, and DWARF feature identifiers.
# Verifies to_string() output and eq() comparison for each variant.

# --- Local FeatureId enum for testing ---
# Mirrors the full enum from remote.feature.features to avoid import issues.

enum FeatureId:
    # Execution control
    Halt
    Resume
    SingleStep
    StepOver
    Reset

    # Memory
    ReadMemory
    WriteMemory

    # Registers
    ReadRegister
    WriteRegister
    ReadAllRegisters

    # Breakpoints
    SetBreakpoint
    ClearBreakpoint
    SetWatchpoint
    ConditionalBreakpoint
    FunctionBreakpoint
    EnableBreakpoint
    DisableBreakpoint
    ListBreakpoints

    # Inspection
    ReadLocals
    ReadGlobals
    ReadArguments
    EvaluateExpression
    ReadStackTrace

    # Frame navigation
    SelectFrame
    FrameLocals
    FrameArguments
    SetVariable

    # Ptrace (native process tracing)
    PtraceAttach
    PtraceDetach
    PtraceContinue
    PtraceSingleStep
    PtraceReadMemory
    PtraceWriteMemory

    # DWARF (debug info)
    DwarfAddrToSource
    DwarfSourceToAddr
    DwarfFunctionName

    # System operations
    ProfileSample
    FlashProgram
    SystemReset

    fn to_string() -> text:
        match self:
            Halt: "Halt"
            Resume: "Resume"
            SingleStep: "SingleStep"
            StepOver: "StepOver"
            Reset: "Reset"
            ReadMemory: "ReadMemory"
            WriteMemory: "WriteMemory"
            ReadRegister: "ReadRegister"
            WriteRegister: "WriteRegister"
            ReadAllRegisters: "ReadAllRegisters"
            SetBreakpoint: "SetBreakpoint"
            ClearBreakpoint: "ClearBreakpoint"
            SetWatchpoint: "SetWatchpoint"
            ConditionalBreakpoint: "ConditionalBreakpoint"
            FunctionBreakpoint: "FunctionBreakpoint"
            EnableBreakpoint: "EnableBreakpoint"
            DisableBreakpoint: "DisableBreakpoint"
            ListBreakpoints: "ListBreakpoints"
            ReadLocals: "ReadLocals"
            ReadGlobals: "ReadGlobals"
            ReadArguments: "ReadArguments"
            EvaluateExpression: "EvaluateExpression"
            ReadStackTrace: "ReadStackTrace"
            SelectFrame: "SelectFrame"
            FrameLocals: "FrameLocals"
            FrameArguments: "FrameArguments"
            SetVariable: "SetVariable"
            PtraceAttach: "PtraceAttach"
            PtraceDetach: "PtraceDetach"
            PtraceContinue: "PtraceContinue"
            PtraceSingleStep: "PtraceSingleStep"
            PtraceReadMemory: "PtraceReadMemory"
            PtraceWriteMemory: "PtraceWriteMemory"
            DwarfAddrToSource: "DwarfAddrToSource"
            DwarfSourceToAddr: "DwarfSourceToAddr"
            DwarfFunctionName: "DwarfFunctionName"
            ProfileSample: "ProfileSample"
            FlashProgram: "FlashProgram"
            SystemReset: "SystemReset"

    fn eq(other: FeatureId) -> bool:
        self.to_string() == other.to_string()

# ============================================================================
# Breakpoint Feature IDs
# ============================================================================

describe "FeatureId breakpoint variants":
    it "ConditionalBreakpoint has correct to_string":
        val f = FeatureId.ConditionalBreakpoint
        expect(f.to_string()).to_equal("ConditionalBreakpoint")

    it "FunctionBreakpoint has correct to_string":
        val f = FeatureId.FunctionBreakpoint
        expect(f.to_string()).to_equal("FunctionBreakpoint")

    it "EnableBreakpoint has correct to_string":
        val f = FeatureId.EnableBreakpoint
        expect(f.to_string()).to_equal("EnableBreakpoint")

    it "DisableBreakpoint has correct to_string":
        val f = FeatureId.DisableBreakpoint
        expect(f.to_string()).to_equal("DisableBreakpoint")

    it "ListBreakpoints has correct to_string":
        val f = FeatureId.ListBreakpoints
        expect(f.to_string()).to_equal("ListBreakpoints")

    it "SetBreakpoint has correct to_string":
        val f = FeatureId.SetBreakpoint
        expect(f.to_string()).to_equal("SetBreakpoint")

    it "ClearBreakpoint has correct to_string":
        val f = FeatureId.ClearBreakpoint
        expect(f.to_string()).to_equal("ClearBreakpoint")

    it "SetWatchpoint has correct to_string":
        val f = FeatureId.SetWatchpoint
        expect(f.to_string()).to_equal("SetWatchpoint")

# ============================================================================
# Frame Navigation Feature IDs
# ============================================================================

describe "FeatureId frame navigation variants":
    it "SelectFrame has correct to_string":
        val f = FeatureId.SelectFrame
        expect(f.to_string()).to_equal("SelectFrame")

    it "FrameLocals has correct to_string":
        val f = FeatureId.FrameLocals
        expect(f.to_string()).to_equal("FrameLocals")

    it "FrameArguments has correct to_string":
        val f = FeatureId.FrameArguments
        expect(f.to_string()).to_equal("FrameArguments")

    it "SetVariable has correct to_string":
        val f = FeatureId.SetVariable
        expect(f.to_string()).to_equal("SetVariable")

# ============================================================================
# Ptrace Feature IDs
# ============================================================================

describe "FeatureId ptrace variants":
    it "PtraceAttach has correct to_string":
        val f = FeatureId.PtraceAttach
        expect(f.to_string()).to_equal("PtraceAttach")

    it "PtraceDetach has correct to_string":
        val f = FeatureId.PtraceDetach
        expect(f.to_string()).to_equal("PtraceDetach")

    it "PtraceContinue has correct to_string":
        val f = FeatureId.PtraceContinue
        expect(f.to_string()).to_equal("PtraceContinue")

    it "PtraceSingleStep has correct to_string":
        val f = FeatureId.PtraceSingleStep
        expect(f.to_string()).to_equal("PtraceSingleStep")

    it "PtraceReadMemory has correct to_string":
        val f = FeatureId.PtraceReadMemory
        expect(f.to_string()).to_equal("PtraceReadMemory")

    it "PtraceWriteMemory has correct to_string":
        val f = FeatureId.PtraceWriteMemory
        expect(f.to_string()).to_equal("PtraceWriteMemory")

# ============================================================================
# DWARF Feature IDs
# ============================================================================

describe "FeatureId DWARF variants":
    it "DwarfAddrToSource has correct to_string":
        val f = FeatureId.DwarfAddrToSource
        expect(f.to_string()).to_equal("DwarfAddrToSource")

    it "DwarfSourceToAddr has correct to_string":
        val f = FeatureId.DwarfSourceToAddr
        expect(f.to_string()).to_equal("DwarfSourceToAddr")

    it "DwarfFunctionName has correct to_string":
        val f = FeatureId.DwarfFunctionName
        expect(f.to_string()).to_equal("DwarfFunctionName")

# ============================================================================
# Existing Feature IDs (regression tests)
# ============================================================================

describe "FeatureId existing variants":
    it "Halt has correct to_string":
        val f = FeatureId.Halt
        expect(f.to_string()).to_equal("Halt")

    it "Resume has correct to_string":
        val f = FeatureId.Resume
        expect(f.to_string()).to_equal("Resume")

    it "SingleStep has correct to_string":
        val f = FeatureId.SingleStep
        expect(f.to_string()).to_equal("SingleStep")

    it "StepOver has correct to_string":
        val f = FeatureId.StepOver
        expect(f.to_string()).to_equal("StepOver")

    it "ReadMemory has correct to_string":
        val f = FeatureId.ReadMemory
        expect(f.to_string()).to_equal("ReadMemory")

    it "WriteMemory has correct to_string":
        val f = FeatureId.WriteMemory
        expect(f.to_string()).to_equal("WriteMemory")

    it "ReadLocals has correct to_string":
        val f = FeatureId.ReadLocals
        expect(f.to_string()).to_equal("ReadLocals")

    it "ReadStackTrace has correct to_string":
        val f = FeatureId.ReadStackTrace
        expect(f.to_string()).to_equal("ReadStackTrace")

    it "EvaluateExpression has correct to_string":
        val f = FeatureId.EvaluateExpression
        expect(f.to_string()).to_equal("EvaluateExpression")

# ============================================================================
# Feature ID Equality
# ============================================================================

describe "FeatureId equality":
    it "same variant equals itself":
        val a = FeatureId.PtraceAttach
        val b = FeatureId.PtraceAttach
        expect(a.eq(b)).to_equal(true)

    it "different variants are not equal":
        val a = FeatureId.PtraceAttach
        val b = FeatureId.PtraceDetach
        expect(a.eq(b)).to_equal(false)

    it "breakpoint variants differ from ptrace variants":
        val a = FeatureId.ConditionalBreakpoint
        val b = FeatureId.PtraceAttach
        expect(a.eq(b)).to_equal(false)

    it "frame variants differ from DWARF variants":
        val a = FeatureId.SelectFrame
        val b = FeatureId.DwarfAddrToSource
        expect(a.eq(b)).to_equal(false)

    it "DWARF variants differ from each other":
        val a = FeatureId.DwarfAddrToSource
        val b = FeatureId.DwarfSourceToAddr
        expect(a.eq(b)).to_equal(false)

    it "system variants have correct to_string":
        val ps = FeatureId.ProfileSample
        val fp = FeatureId.FlashProgram
        val sr = FeatureId.SystemReset
        expect(ps.to_string()).to_equal("ProfileSample")
        expect(fp.to_string()).to_equal("FlashProgram")
        expect(sr.to_string()).to_equal("SystemReset")

    it "all breakpoint features are distinct":
        val features: [text] = [
            FeatureId.SetBreakpoint.to_string(),
            FeatureId.ClearBreakpoint.to_string(),
            FeatureId.ConditionalBreakpoint.to_string(),
            FeatureId.FunctionBreakpoint.to_string(),
            FeatureId.EnableBreakpoint.to_string(),
            FeatureId.DisableBreakpoint.to_string(),
            FeatureId.ListBreakpoints.to_string()
        ]
        # Verify they are all different by checking length of unique set
        # Each one is unique so just verify they all exist as non-empty strings
        var all_non_empty = true
        for name in features:
            if name.len() == 0:
                all_non_empty = false
        expect(all_non_empty).to_equal(true)
        expect(features.len()).to_equal(7)

    it "all ptrace features are distinct":
        val pa = FeatureId.PtraceAttach.to_string()
        val pd = FeatureId.PtraceDetach.to_string()
        val pc = FeatureId.PtraceContinue.to_string()
        val ps = FeatureId.PtraceSingleStep.to_string()
        val pr = FeatureId.PtraceReadMemory.to_string()
        val pw = FeatureId.PtraceWriteMemory.to_string()
        # Verify all are unique
        expect(pa).to_equal("PtraceAttach")
        expect(pd).to_equal("PtraceDetach")
        expect(pc).to_equal("PtraceContinue")
        expect(ps).to_equal("PtraceSingleStep")
        expect(pr).to_equal("PtraceReadMemory")
        expect(pw).to_equal("PtraceWriteMemory")
