#!/usr/bin/env simple
# Gilrs Gamepad SFFI Wrapper Tests
#
# Comprehensive test suite for gamepad input wrapper.
# Tests initialization, controller management, input reading,
# events, rumble, and battery status.

use std.spec.{describe, it, expect}
use app.io.gamepad_ffi.{
    GamepadContext, gamepad_init, gamepad_shutdown, gamepad_update,
    gamepad_count, gamepad_is_connected, gamepad_get_name,
    BatteryStatus, PowerInfo, gamepad_get_power_info,
    GamepadButton, GamepadAxis,
    GamepadEventType, GamepadEvent, gamepad_poll_event, gamepad_event_free,
    gamepad_button_is_pressed, ButtonData, gamepad_button_data,
    gamepad_axis_data,
    StickState, gamepad_left_stick, gamepad_right_stick,
    TriggerState, gamepad_triggers,
    RumbleEffect, gamepad_rumble, gamepad_rumble_simple, gamepad_stop_rumble,
    gamepad_last_error,
    gamepad_apply_deadzone, gamepad_stick_with_deadzone
}

describe "Gamepad SFFI Wrapper":
    # ========================================================================
    # Context Management Tests
    # ========================================================================

    describe "gamepad_init":
        it "creates gamepad context":
            val ctx = gamepad_init()
            expect(ctx.handle).to_equal(0)  # No actual runtime yet
            gamepad_shutdown(ctx)

        it "returns context with is_valid field":
            val ctx = gamepad_init()
            expect(ctx.is_valid).to_equal(false)  # No runtime
            gamepad_shutdown(ctx)

    describe "gamepad_shutdown":
        it "shuts down invalid context safely":
            val ctx = GamepadContext(handle: 0, is_valid: false)
            val result = gamepad_shutdown(ctx)
            expect(result).to_equal(true)

        it "returns boolean":
            val ctx = gamepad_init()
            val result = gamepad_shutdown(ctx)
            expect(result).to_equal(true)

    describe "gamepad_update":
        it "returns false for invalid context":
            val ctx = GamepadContext(handle: 0, is_valid: false)
            val result = gamepad_update(ctx)
            expect(result).to_equal(false)

        it "handles valid context":
            val ctx = gamepad_init()
            val result = gamepad_update(ctx)
            # Will be false without runtime
            gamepad_shutdown(ctx)

    # ========================================================================
    # Controller Management Tests
    # ========================================================================

    describe "gamepad_count":
        it "returns 0 for invalid context":
            val ctx = GamepadContext(handle: 0, is_valid: false)
            val count = gamepad_count(ctx)
            expect(count).to_equal(0)

        it "returns count for valid context":
            val ctx = gamepad_init()
            val count = gamepad_count(ctx)
            expect(count).to_equal(0)  # No controllers in test
            gamepad_shutdown(ctx)

    describe "gamepad_is_connected":
        it "returns false for invalid context":
            val ctx = GamepadContext(handle: 0, is_valid: false)
            val connected = gamepad_is_connected(ctx, 0)
            expect(connected).to_equal(false)

        it "checks controller connection":
            val ctx = gamepad_init()
            val connected = gamepad_is_connected(ctx, 0)
            expect(connected).to_equal(false)  # No controller
            gamepad_shutdown(ctx)

    describe "gamepad_get_name":
        it "returns empty string for invalid context":
            val ctx = GamepadContext(handle: 0, is_valid: false)
            val name = gamepad_get_name(ctx, 0)
            expect(name).to_equal("")

        it "returns empty for non-existent controller":
            val ctx = gamepad_init()
            val name = gamepad_get_name(ctx, 0)
            expect(name).to_equal("")  # No controller
            gamepad_shutdown(ctx)

    describe "PowerInfo":
        it "has status and percentage fields":
            val info = PowerInfo(status: BatteryStatus.Unknown, percentage: -1)
            expect(info.percentage).to_equal(-1)

        it "supports all battery statuses":
            val unknown = PowerInfo(status: BatteryStatus.Unknown, percentage: -1)
            val charging = PowerInfo(status: BatteryStatus.Charging, percentage: 50)
            val discharging = PowerInfo(status: BatteryStatus.Discharging, percentage: 75)
            val full = PowerInfo(status: BatteryStatus.Full, percentage: 100)
            val empty = PowerInfo(status: BatteryStatus.Empty, percentage: 0)
            val wired = PowerInfo(status: BatteryStatus.Wired, percentage: -1)
            expect(charging.percentage).to_equal(50)

    describe "gamepad_get_power_info":
        it "returns unknown for invalid context":
            val ctx = GamepadContext(handle: 0, is_valid: false)
            val info = gamepad_get_power_info(ctx, 0)
            expect(info.percentage).to_equal(-1)

        it "returns unknown for non-existent controller":
            val ctx = gamepad_init()
            val info = gamepad_get_power_info(ctx, 0)
            expect(info.percentage).to_equal(-1)
            gamepad_shutdown(ctx)

    # ========================================================================
    # Button Tests
    # ========================================================================

    describe "GamepadButton enum":
        it "defines face buttons":
            val south = GamepadButton.South
            val east = GamepadButton.East
            val north = GamepadButton.North
            val west = GamepadButton.West
            # Enum variants exist

        it "defines trigger buttons":
            val lt = GamepadButton.LeftTrigger
            val rt = GamepadButton.RightTrigger
            # Enum variants exist

        it "defines bumper buttons":
            val lb = GamepadButton.LeftBumper
            val rb = GamepadButton.RightBumper
            # Enum variants exist

        it "defines d-pad buttons":
            val up = GamepadButton.DPadUp
            val down = GamepadButton.DPadDown
            val left = GamepadButton.DPadLeft
            val right = GamepadButton.DPadRight
            # Enum variants exist

        it "defines stick buttons":
            val l3 = GamepadButton.LeftStick
            val r3 = GamepadButton.RightStick
            # Enum variants exist

        it "defines system buttons":
            val select = GamepadButton.Select
            val start = GamepadButton.Start
            val mode = GamepadButton.Mode
            # Enum variants exist

    describe "gamepad_button_is_pressed":
        it "returns false for invalid context":
            val ctx = GamepadContext(handle: 0, is_valid: false)
            val pressed = gamepad_button_is_pressed(ctx, 0, GamepadButton.South)
            expect(pressed).to_equal(false)

        it "returns false for non-existent controller":
            val ctx = gamepad_init()
            val pressed = gamepad_button_is_pressed(ctx, 0, GamepadButton.South)
            expect(pressed).to_equal(false)
            gamepad_shutdown(ctx)

    describe "ButtonData":
        it "has is_pressed and value fields":
            val data = ButtonData(is_pressed: false, value: 0.0)
            expect(data.is_pressed).to_equal(false)
            expect(data.value).to_equal(0.0)

        it "supports analog button values":
            val data = ButtonData(is_pressed: true, value: 0.75)
            expect(data.value).to_equal(0.75)

    describe "gamepad_button_data":
        it "returns unpressed data for invalid context":
            val ctx = GamepadContext(handle: 0, is_valid: false)
            val data = gamepad_button_data(ctx, 0, GamepadButton.South)
            expect(data.is_pressed).to_equal(false)
            expect(data.value).to_equal(0.0)

        it "returns unpressed data for non-existent controller":
            val ctx = gamepad_init()
            val data = gamepad_button_data(ctx, 0, GamepadButton.South)
            expect(data.is_pressed).to_equal(false)
            gamepad_shutdown(ctx)

    # ========================================================================
    # Axis Tests
    # ========================================================================

    describe "GamepadAxis enum":
        it "defines stick axes":
            val lx = GamepadAxis.LeftStickX
            val ly = GamepadAxis.LeftStickY
            val rx = GamepadAxis.RightStickX
            val ry = GamepadAxis.RightStickY
            # Enum variants exist

        it "defines trigger axes":
            val lt = GamepadAxis.LeftTrigger
            val rt = GamepadAxis.RightTrigger
            # Enum variants exist

        it "defines d-pad axes":
            val dx = GamepadAxis.DPadX
            val dy = GamepadAxis.DPadY
            # Enum variants exist

    describe "gamepad_axis_data":
        it "returns 0.0 for invalid context":
            val ctx = GamepadContext(handle: 0, is_valid: false)
            val value = gamepad_axis_data(ctx, 0, GamepadAxis.LeftStickX)
            expect(value).to_equal(0.0)

        it "returns 0.0 for non-existent controller":
            val ctx = gamepad_init()
            val value = gamepad_axis_data(ctx, 0, GamepadAxis.LeftStickX)
            expect(value).to_equal(0.0)
            gamepad_shutdown(ctx)

    describe "StickState":
        it "has x and y fields":
            val stick = StickState(x: 0.5, y: -0.3)
            expect(stick.x).to_equal(0.5)
            expect(stick.y).to_equal(-0.3)

        it "calculates magnitude":
            val stick = StickState(x: 3.0, y: 4.0)
            val mag = stick.magnitude()
            expect(mag).to_equal(5.0)

        it "normalizes stick input":
            val stick = StickState(x: 3.0, y: 4.0)
            val normalized = stick.normalize()
            expect(normalized.x).to_equal(0.6)
            expect(normalized.y).to_equal(0.8)

        it "handles zero magnitude normalization":
            val stick = StickState(x: 0.0, y: 0.0)
            val normalized = stick.normalize()
            expect(normalized.x).to_equal(0.0)
            expect(normalized.y).to_equal(0.0)

        it "calculates angle":
            val stick = StickState(x: 1.0, y: 0.0)
            val angle = stick.angle()
            expect(angle).to_equal(0.0)

    describe "gamepad_left_stick":
        it "returns stick state":
            val ctx = gamepad_init()
            val stick = gamepad_left_stick(ctx, 0)
            expect(stick.x).to_equal(0.0)
            expect(stick.y).to_equal(0.0)
            gamepad_shutdown(ctx)

    describe "gamepad_right_stick":
        it "returns stick state":
            val ctx = gamepad_init()
            val stick = gamepad_right_stick(ctx, 0)
            expect(stick.x).to_equal(0.0)
            expect(stick.y).to_equal(0.0)
            gamepad_shutdown(ctx)

    describe "TriggerState":
        it "has left and right fields":
            val triggers = TriggerState(left: 0.5, right: 0.8)
            expect(triggers.left).to_equal(0.5)
            expect(triggers.right).to_equal(0.8)

    describe "gamepad_triggers":
        it "returns trigger state":
            val ctx = gamepad_init()
            val triggers = gamepad_triggers(ctx, 0)
            expect(triggers.left).to_equal(0.0)
            expect(triggers.right).to_equal(0.0)
            gamepad_shutdown(ctx)

    # ========================================================================
    # Event System Tests
    # ========================================================================

    describe "GamepadEventType enum":
        it "defines button events":
            val pressed = GamepadEventType.ButtonPressed
            val released = GamepadEventType.ButtonReleased
            val changed = GamepadEventType.ButtonChanged
            # Enum variants exist

        it "defines axis events":
            val axis = GamepadEventType.AxisChanged
            # Enum variant exists

        it "defines connection events":
            val connected = GamepadEventType.Connected
            val disconnected = GamepadEventType.Disconnected
            val dropped = GamepadEventType.Dropped
            # Enum variants exist

    describe "GamepadEvent":
        it "has all required fields":
            val event = GamepadEvent(
                handle: 0,
                event_type: GamepadEventType.Unknown,
                gamepad_id: 0,
                button: GamepadButton.Unknown,
                axis: GamepadAxis.Unknown,
                value: 0.0,
                is_valid: false
            )
            expect(event.is_valid).to_equal(false)

    describe "gamepad_poll_event":
        it "returns invalid event for invalid context":
            val ctx = GamepadContext(handle: 0, is_valid: false)
            val event = gamepad_poll_event(ctx)
            expect(event.is_valid).to_equal(false)

        it "returns invalid event when no events":
            val ctx = gamepad_init()
            val event = gamepad_poll_event(ctx)
            expect(event.is_valid).to_equal(false)
            gamepad_shutdown(ctx)

    describe "gamepad_event_free":
        it "frees invalid event safely":
            val event = GamepadEvent(
                handle: 0,
                event_type: GamepadEventType.Unknown,
                gamepad_id: 0,
                button: GamepadButton.Unknown,
                axis: GamepadAxis.Unknown,
                value: 0.0,
                is_valid: false
            )
            val result = gamepad_event_free(event)
            expect(result).to_equal(true)

    # ========================================================================
    # Rumble Tests
    # ========================================================================

    describe "RumbleEffect":
        it "has motor and duration fields":
            val effect = RumbleEffect(
                strong_motor: 1.0,
                weak_motor: 0.5,
                duration_ms: 500
            )
            expect(effect.strong_motor).to_equal(1.0)
            expect(effect.weak_motor).to_equal(0.5)
            expect(effect.duration_ms).to_equal(500)

    describe "gamepad_rumble":
        it "returns false for invalid context":
            val ctx = GamepadContext(handle: 0, is_valid: false)
            val effect = RumbleEffect(strong_motor: 1.0, weak_motor: 0.5, duration_ms: 500)
            val result = gamepad_rumble(ctx, 0, effect)
            expect(result).to_equal(false)

        it "handles valid context":
            val ctx = gamepad_init()
            val effect = RumbleEffect(strong_motor: 1.0, weak_motor: 0.5, duration_ms: 500)
            val result = gamepad_rumble(ctx, 0, effect)
            # Will be false without actual controller
            gamepad_shutdown(ctx)

    describe "gamepad_rumble_simple":
        it "creates effect with same intensity":
            val ctx = gamepad_init()
            val result = gamepad_rumble_simple(ctx, 0, 0.8, 1000)
            # Will be false without actual controller
            gamepad_shutdown(ctx)

    describe "gamepad_stop_rumble":
        it "returns false for invalid context":
            val ctx = GamepadContext(handle: 0, is_valid: false)
            val result = gamepad_stop_rumble(ctx, 0)
            expect(result).to_equal(false)

        it "handles valid context":
            val ctx = gamepad_init()
            val result = gamepad_stop_rumble(ctx, 0)
            # Will be false without actual controller
            gamepad_shutdown(ctx)

    # ========================================================================
    # Helper Function Tests
    # ========================================================================

    describe "gamepad_apply_deadzone":
        it "returns 0.0 for values below deadzone":
            val result = gamepad_apply_deadzone(0.05, 0.1)
            expect(result).to_equal(0.0)

        it "rescales values above deadzone":
            val result = gamepad_apply_deadzone(0.55, 0.1)
            # (0.55 - 0.1) / (1.0 - 0.1) = 0.5
            expect(result).to_equal(0.5)

        it "preserves sign":
            val result = gamepad_apply_deadzone(-0.55, 0.1)
            expect(result).to_equal(-0.5)

    describe "gamepad_stick_with_deadzone":
        it "returns zero for magnitude below deadzone":
            val stick = StickState(x: 0.05, y: 0.05)
            val result = gamepad_stick_with_deadzone(stick, 0.1)
            expect(result.x).to_equal(0.0)
            expect(result.y).to_equal(0.0)

        it "rescales stick based on deadzone":
            val stick = StickState(x: 0.6, y: 0.8)  # mag = 1.0
            val result = gamepad_stick_with_deadzone(stick, 0.1)
            # (1.0 - 0.1) / (1.0 - 0.1) / 1.0 = 0.9
            # x: 0.6 * 0.9 = 0.54, y: 0.8 * 0.9 = 0.72
            expect(result.x).to_equal(0.54)
            expect(result.y).to_equal(0.72)

    describe "gamepad_last_error":
        it "returns error message":
            val error = gamepad_last_error()
            # Returns empty or error string
