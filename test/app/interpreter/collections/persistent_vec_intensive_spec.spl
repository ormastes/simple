# Persistent Vector - Intensive SSpec Tests
# Comprehensive tests for RRB-tree implementation

use app.interpreter.collections.persistent_vec.*
use sspec.*

describe "PersistentVec intensive tests":
    describe "Basic operations":
        it "creates empty vec":
            val vec = PersistentVec.new()
            assert vec.is_empty()
            assert vec.len() == 0

        it "push adds element":
            val vec1 = PersistentVec.new()
            val vec2 = vec1.push(42)

            assert vec1.is_empty()
            assert vec2.len() == 1
            assert vec2.get(0) == Some(42)

        it "multiple pushes":
            var vec = PersistentVec.new()
            for i in 0..100:
                vec = vec.push(i)

            assert vec.len() == 100
            for i in 0..100:
                assert vec.get(i) == Some(i)

    describe "Indexing":
        it "get with positive index":
            val vec = PersistentVec.from_array([10, 20, 30])
            assert vec.get(0) == Some(10)
            assert vec.get(1) == Some(20)
            assert vec.get(2) == Some(30)

        it "get with negative index":
            val vec = PersistentVec.from_array([10, 20, 30])
            assert vec.get(-1) == Some(30)
            assert vec.get(-2) == Some(20)
            assert vec.get(-3) == Some(10)

        it "get out of bounds returns None":
            val vec = PersistentVec.from_array([1, 2, 3])
            assert vec.get(3) == None
            assert vec.get(-4) == None

        it "first and last":
            val vec = PersistentVec.from_array([1, 2, 3])
            assert vec.first() == Some(1)
            assert vec.last() == Some(3)

        it "first/last on empty returns None":
            val vec = PersistentVec.new()
            assert vec.first() == None
            assert vec.last() == None

    describe "Immutability":
        it "push doesn't modify original":
            val vec1 = PersistentVec.from_array([1, 2, 3])
            val vec2 = vec1.push(4)

            assert vec1.len() == 3
            assert vec2.len() == 4

        it "set creates new version":
            val vec1 = PersistentVec.from_array([1, 2, 3])
            val vec2 = vec1.set(1, 99)

            assert vec1.get(1) == Some(2)
            assert vec2.get(1) == Some(99)

        it "pop creates new version":
            val vec1 = PersistentVec.from_array([1, 2, 3])
            val vec2 = vec1.pop()

            assert vec1.len() == 3
            assert vec2.len() == 2

    describe "Set operation":
        it "set updates element":
            val vec1 = PersistentVec.from_array([1, 2, 3])
            val vec2 = vec1.set(1, 99)

            assert vec2.get(0) == Some(1)
            assert vec2.get(1) == Some(99)
            assert vec2.get(2) == Some(3)

        it "set with negative index":
            val vec1 = PersistentVec.from_array([1, 2, 3])
            val vec2 = vec1.set(-1, 99)

            assert vec2.get(2) == Some(99)

        it "set out of bounds returns unchanged":
            val vec1 = PersistentVec.from_array([1, 2, 3])
            val vec2 = vec1.set(10, 99)

            assert vec1.len() == vec2.len()

    describe "Pop operation":
        it "pop removes last element":
            val vec1 = PersistentVec.from_array([1, 2, 3])
            val vec2 = vec1.pop()

            assert vec2.len() == 2
            assert vec2.get(0) == Some(1)
            assert vec2.get(1) == Some(2)
            assert vec2.get(2) == None

        it "pop from empty returns empty":
            val vec1 = PersistentVec.new()
            val vec2 = vec1.pop()

            assert vec2.is_empty()

        it "pop single element":
            val vec1 = PersistentVec.new().push(42)
            val vec2 = vec1.pop()

            assert vec2.is_empty()

        it "repeated pops":
            var vec = PersistentVec.from_array([1, 2, 3, 4, 5])

            for i in 5..0 by -1:
                assert vec.len() == i
                vec = vec.pop()

            assert vec.is_empty()

        it "pop maintains correct values":
            var vec = PersistentVec.new()
            for i in 0..100:
                vec = vec.push(i)

            # Pop half
            for _ in 0..50:
                vec = vec.pop()

            # Check remaining values
            assert vec.len() == 50
            for i in 0..50:
                assert vec.get(i) == Some(i)

    describe "Large vector (stress test tail buffer)":
        it "handles > 32 elements (forces tree usage)":
            var vec = PersistentVec.new()
            for i in 0..100:
                vec = vec.push(i)

            assert vec.len() == 100
            for i in 0..100:
                assert vec.get(i) == Some(i)

        it "tail buffer transition":
            # Push exactly 32 elements (fills tail)
            var vec = PersistentVec.new()
            for i in 0..32:
                vec = vec.push(i)

            # Push one more (forces tail to tree)
            vec = vec.push(32)

            assert vec.len() == 33
            for i in 0..33:
                assert vec.get(i) == Some(i)

    describe "Bulk operations":
        it "concat combines vectors":
            val vec1 = PersistentVec.from_array([1, 2, 3])
            val vec2 = PersistentVec.from_array([4, 5, 6])
            val vec3 = vec1.concat(vec2)

            assert vec3.len() == 6
            assert vec3.to_array() == [1, 2, 3, 4, 5, 6]

        it "map transforms elements":
            val vec1 = PersistentVec.from_array([1, 2, 3])
            val vec2 = vec1.map(\x: x * 2)

            assert vec2.to_array() == [2, 4, 6]

        it "filter keeps matching elements":
            val vec1 = PersistentVec.from_array([1, 2, 3, 4, 5, 6])
            val vec2 = vec1.filter(\x: x % 2 == 0)

            assert vec2.to_array() == [2, 4, 6]

        it "fold reduces to single value":
            val vec = PersistentVec.from_array([1, 2, 3, 4, 5])
            val sum = vec.fold(0, \acc, x: acc + x)

            assert sum == 15

    describe "Slicing operations":
        it "take first n elements":
            val vec = PersistentVec.from_array([1, 2, 3, 4, 5])
            val taken = vec.take(3)

            assert taken.to_array() == [1, 2, 3]

        it "drop first n elements":
            val vec = PersistentVec.from_array([1, 2, 3, 4, 5])
            val dropped = vec.drop(2)

            assert dropped.to_array() == [3, 4, 5]

        it "slice range":
            val vec = PersistentVec.from_array([1, 2, 3, 4, 5])
            val sliced = vec.slice(1, 4)

            assert sliced.to_array() == [2, 3, 4]

        it "reverse":
            val vec = PersistentVec.from_array([1, 2, 3, 4, 5])
            val reversed = vec.reverse()

            assert reversed.to_array() == [5, 4, 3, 2, 1]

    describe "Performance tests":
        it "push 10000 elements efficiently":
            val start = time.now()

            var vec = PersistentVec.new()
            for i in 0..10000:
                vec = vec.push(i)

            val elapsed = time.now() - start

            assert vec.len() == 10000
            # Should be < 50ms
            assert elapsed < 50.ms

        it "random access is O(log n)":
            var vec = PersistentVec.new()
            for i in 0..10000:
                vec = vec.push(i)

            val start = time.now()
            for i in 0..10000 by 10:
                val _ = vec.get(i)
            val elapsed = time.now() - start

            # 1000 random accesses should be < 10ms
            assert elapsed < 10.ms

        it "pop 1000 elements efficiently":
            var vec = PersistentVec.new()
            for i in 0..1000:
                vec = vec.push(i)

            val start = time.now()
            for _ in 0..1000:
                vec = vec.pop()
            val elapsed = time.now() - start

            # Should be O(log n) per pop, < 20ms total
            assert elapsed < 20.ms

        it "structural sharing is efficient":
            # Build base vector
            var base = PersistentVec.new()
            for i in 0..1000:
                base = base.push(i)

            # Create 1000 versions with small changes
            val start = time.now()
            var versions: [PersistentVec] = []
            for i in 0..1000:
                versions = versions.push(base.set(i, i * 2))
            val elapsed = time.now() - start

            # With sharing, should be fast (< 30ms)
            # Without sharing, would be very slow
            assert elapsed < 30.ms

    describe "Edge cases":
        it "contains checks membership":
            val vec = PersistentVec.from_array([1, 2, 3])
            assert vec.contains(2)
            assert not vec.contains(99)

        it "handles empty conversions":
            val vec = PersistentVec.new()
            assert vec.to_array() == []

    describe "Correctness after many operations":
        it "maintains correctness through mixed operations":
            var vec = PersistentVec.new()

            # Build up
            for i in 0..100:
                vec = vec.push(i)

            # Update some
            for i in 0..50:
                vec = vec.set(i, i * 2)

            # Pop some
            for _ in 0..25:
                vec = vec.pop()

            # Verify
            assert vec.len() == 75
            for i in 0..50:
                assert vec.get(i) == Some(i * 2)
            for i in 50..75:
                assert vec.get(i) == Some(i)
