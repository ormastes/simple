# PersistentVec Tests
#
# Tests for the RRB-tree based persistent vector.

# @skip
use std.spec.{check}
use app.interpreter.collections.persistent_vec.{PersistentVec}

describe "PersistentVec - Basic Operations":
    it "creates empty vector":
        val vec_val = PersistentVec.empty()
        check(vec_val.is_empty())
        check(vec_val.len() == 0)

    it "pushes single element":
        val vec_val = PersistentVec.empty()
        val vec2 = vec_val.push(42)

        check(vec2.len() == 1)
        check(vec2.get(0).unwrap() == 42)

    it "original unchanged after push":
        val vec1 = PersistentVec.empty()
        val vec2 = vec1.push(1)

        check(vec1.is_empty())
        check(vec2.len() == 1)

    it "pushes multiple elements":
        var vec_val = PersistentVec.empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)

        check(vec_val.len() == 3)
        check(vec_val.get(0).unwrap() == 1)
        check(vec_val.get(1).unwrap() == 2)
        check(vec_val.get(2).unwrap() == 3)

    it "gets with negative index":
        var vec_val = PersistentVec.empty()
        vec_val = vec_val.push(10).push(20).push(30)

        check(vec_val.get(-1).unwrap() == 30)  # Last
        check(vec_val.get(-2).unwrap() == 20)  # Second to last
        check(vec_val.get(-3).unwrap() == 10)  # First

    it "returns None for out of bounds":
        val vec_val = PersistentVec.empty().push(1)

        check(not vec_val.get(5).?)
        check(not vec_val.get(-10).?)

describe "PersistentVec - Update":
    it "updates element at index":
        var vec_val = PersistentVec.empty()
        vec_val = vec_val.push(1).push(2).push(3)

        val vec2 = vec_val.set(1, 99)

        check(vec_val.get(1).unwrap() == 2)   # Original unchanged
        check(vec2.get(1).unwrap() == 99)  # Updated

    it "updates with negative index":
        var vec_val = PersistentVec.empty()
        vec_val = vec_val.push(1).push(2).push(3)

        val vec2 = vec_val.set(-1, 999)

        check(vec2.get(2).unwrap() == 999)

    it "ignores out of bounds update":
        val vec_val = PersistentVec.empty().push(1)
        val vec2 = vec_val.set(100, 999)

        check(vec2.len() == 1)
        check(vec2.get(0).unwrap() == 1)

describe "PersistentVec - Pop":
    it "pops last element":
        var vec_val = PersistentVec.empty()
        vec_val = vec_val.push(1).push(2).push(3)

        val vec2 = vec_val.pop()

        check(vec_val.len() == 3)
        check(vec2.len() == 2)
        check(vec2.get(0).unwrap() == 1)
        check(vec2.get(1).unwrap() == 2)

    it "handles pop on empty vector":
        val vec_val = PersistentVec.empty()
        val vec2 = vec_val.pop()

        check(vec2.is_empty())

    it "handles pop to empty":
        val vec_val = PersistentVec.empty().push(1)
        val vec2 = vec_val.pop()

        check(vec2.is_empty())

describe "PersistentVec - First/Last":
    it "gets first element":
        val vec_val = PersistentVec.empty().push(10).push(20)
        check(vec_val.first().unwrap() == 10)

    it "gets last element":
        val vec_val = PersistentVec.empty().push(10).push(20)
        check(vec_val.last().unwrap() == 20)

    it "returns None for empty vector":
        val vec_val = PersistentVec.empty()
        check(not vec_val.first().?)
        check(not vec_val.last().?)

describe "PersistentVec - Contains":
    it "checks if element exists":
        val vec_val = PersistentVec.empty().push(1).push(2).push(3)

        check(vec_val.contains(2))
        check(not vec_val.contains(99))

describe "PersistentVec - Structural Sharing":
    it "shares structure between versions":
        var vec1 = PersistentVec.empty()
        for i in 0..100:
            vec1 = vec1.push(i)

        val vec2 = vec1.push(999)

        check(vec1.len() == 100)
        check(vec2.len() == 101)

        check(vec1.get(50).unwrap() == 50)
        check(vec2.get(50).unwrap() == 50)
        check(not vec1.get(100).?)
        check(vec2.get(100).unwrap() == 999)

    it "handles many pushes efficiently":
        var vec_val = PersistentVec.empty()

        for i in 0..1000:
            vec_val = vec_val.push(i)

        check(vec_val.len() == 1000)

        for i in 0..1000:
            check(vec_val.get(i).unwrap() == i)

describe "PersistentVec - Bulk Operations":
    it "concatenates vectors":
        val vec1 = PersistentVec.empty().push(1).push(2)
        val vec2 = PersistentVec.empty().push(3).push(4)

        val concat = vec1.concat(vec2)

        check(concat.len() == 4)
        check(concat.get(0).unwrap() == 1)
        check(concat.get(2).unwrap() == 3)

    it "maps elements":
        val vec_val = PersistentVec.empty().push(1).push(2).push(3)
        val doubled = vec_val.map(\x: x * 2)

        check(doubled.get(0).unwrap() == 2)
        check(doubled.get(1).unwrap() == 4)
        check(doubled.get(2).unwrap() == 6)

    it "filters elements":
        val vec_val = PersistentVec.empty().push(1).push(2).push(3).push(4)
        val evens = vec_val.filter(\x: x % 2 == 0)

        check(evens.len() == 2)
        check(evens.get(0).unwrap() == 2)
        check(evens.get(1).unwrap() == 4)

    it "folds elements":
        val vec_val = PersistentVec.empty().push(1).push(2).push(3)
        val sum = vec_val.fold(0, \acc, x: acc + x)

        check(sum == 6)

    it "takes first n elements":
        val vec_val = PersistentVec.empty().push(1).push(2).push(3).push(4)
        val first2 = vec_val.take(2)

        check(first2.len() == 2)
        check(first2.get(0).unwrap() == 1)
        check(first2.get(1).unwrap() == 2)

    it "drops first n elements":
        val vec_val = PersistentVec.empty().push(1).push(2).push(3).push(4)
        val last2 = vec_val.drop(2)

        check(last2.len() == 2)
        check(last2.get(0).unwrap() == 3)
        check(last2.get(1).unwrap() == 4)

    it "slices vector":
        val vec_val = PersistentVec.empty().push(0).push(1).push(2).push(3).push(4)
        val sliced = vec_val.slice(1, 4)

        check(sliced.len() == 3)
        check(slice.get(0).unwrap() == 1)
        check(slice.get(1).unwrap() == 2)
        check(slice.get(2).unwrap() == 3)

    it "reverses vector":
        val vec_val = PersistentVec.empty().push(1).push(2).push(3)
        val reversed = vec_val.reverse()

        check(reversed.get(0).unwrap() == 3)
        check(reversed.get(1).unwrap() == 2)
        check(reversed.get(2).unwrap() == 1)

describe "PersistentVec - Conversion":
    it "creates from array":
        val vec_val = PersistentVec.from_array([10, 20, 30])

        check(vec_val.len() == 3)
        check(vec_val.get(1).unwrap() == 20)

    it "creates with of()":
        val vec_val = PersistentVec.of(["a", "b", "c"])

        check(vec_val.len() == 3)
        check(vec_val.get(0).unwrap() == "a")

    it "converts to array":
        val vec_val = PersistentVec.empty().push(1).push(2).push(3)
        val arr = vec_val.to_array()

        check(arr.len() == 3)
        check(arr[0] == 1)
        check(arr[1] == 2)
        check(arr[2] == 3)

describe "PersistentVec - String Elements":
    it "handles string elements":
        var vec_val = PersistentVec.empty()
        vec_val = vec_val.push("hello")
        vec_val = vec_val.push("world")

        check(vec_val.get(0).unwrap() == "hello")
        check(vec_val.get(1).unwrap() == "world")

describe "PersistentVec - Edge Cases":
    it "handles single element operations":
        val vec_val = PersistentVec.empty().push(42)

        check(vec_val.first().unwrap() == 42)
        check(vec_val.last().unwrap() == 42)
        check(vec_val.len() == 1)

        val popped = vec_val.pop()
        check(popped.is_empty())

    it "handles boundary at branch factor":
        var vec_val = PersistentVec.empty()

        # Push exactly 32 elements (one full leaf)
        for i in 0..32:
            vec_val = vec_val.push(i)

        check(vec_val.len() == 32)
        check(vec_val.get(0).unwrap() == 0)
        check(vec_val.get(31).unwrap() == 31)

        # Push one more (forces tree growth)
        vec_val = vec_val.push(32)

        check(vec_val.len() == 33)
        check(vec_val.get(32).unwrap() == 32)

    it "handles large vectors":
        var vec_val = PersistentVec.empty()

        for i in 0..500:
            vec_val = vec_val.push(i * 2)

        check(vec_val.len() == 500)

        # Spot check
        check(vec_val.get(0).unwrap() == 0)
        check(vec_val.get(100).unwrap() == 200)
        check(vec_val.get(499).unwrap() == 998)
