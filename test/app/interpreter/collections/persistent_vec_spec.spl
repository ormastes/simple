# PersistentVec Tests
#
# Tests for the RRB-tree based persistent vector.

from persistent_vec import {PersistentVec}

describe "PersistentVec - Basic Operations":
    it "creates empty vector":
        val vec = PersistentVec.empty()
        assert vec.is_empty()
        assert vec.len() == 0

    it "pushes single element":
        val vec = PersistentVec.empty()
        val vec2 = vec.push(42)

        assert vec2.len() == 1
        assert vec2.get(0).unwrap() == 42

    it "original unchanged after push":
        val vec1 = PersistentVec.empty()
        val vec2 = vec1.push(1)

        assert vec1.is_empty()
        assert vec2.len() == 1

    it "pushes multiple elements":
        var vec = PersistentVec.empty()
        vec = vec.push(1)
        vec = vec.push(2)
        vec = vec.push(3)

        assert vec.len() == 3
        assert vec.get(0).unwrap() == 1
        assert vec.get(1).unwrap() == 2
        assert vec.get(2).unwrap() == 3

    it "gets with negative index":
        var vec = PersistentVec.empty()
        vec = vec.push(10).push(20).push(30)

        assert vec.get(-1).unwrap() == 30  # Last
        assert vec.get(-2).unwrap() == 20  # Second to last
        assert vec.get(-3).unwrap() == 10  # First

    it "returns None for out of bounds":
        val vec = PersistentVec.empty().push(1)

        assert not vec.get(5).?
        assert not vec.get(-10).?

describe "PersistentVec - Update":
    it "updates element at index":
        var vec = PersistentVec.empty()
        vec = vec.push(1).push(2).push(3)

        val vec2 = vec.set(1, 99)

        assert vec.get(1).unwrap() == 2   # Original unchanged
        assert vec2.get(1).unwrap() == 99  # Updated

    it "updates with negative index":
        var vec = PersistentVec.empty()
        vec = vec.push(1).push(2).push(3)

        val vec2 = vec.set(-1, 999)

        assert vec2.get(2).unwrap() == 999

    it "ignores out of bounds update":
        val vec = PersistentVec.empty().push(1)
        val vec2 = vec.set(100, 999)

        assert vec2.len() == 1
        assert vec2.get(0).unwrap() == 1

describe "PersistentVec - Pop":
    it "pops last element":
        var vec = PersistentVec.empty()
        vec = vec.push(1).push(2).push(3)

        val vec2 = vec.pop()

        assert vec.len() == 3
        assert vec2.len() == 2
        assert vec2.get(0).unwrap() == 1
        assert vec2.get(1).unwrap() == 2

    it "handles pop on empty vector":
        val vec = PersistentVec.empty()
        val vec2 = vec.pop()

        assert vec2.is_empty()

    it "handles pop to empty":
        val vec = PersistentVec.empty().push(1)
        val vec2 = vec.pop()

        assert vec2.is_empty()

describe "PersistentVec - First/Last":
    it "gets first element":
        val vec = PersistentVec.empty().push(10).push(20)
        assert vec.first().unwrap() == 10

    it "gets last element":
        val vec = PersistentVec.empty().push(10).push(20)
        assert vec.last().unwrap() == 20

    it "returns None for empty vector":
        val vec = PersistentVec.empty()
        assert not vec.first().?
        assert not vec.last().?

describe "PersistentVec - Contains":
    it "checks if element exists":
        val vec = PersistentVec.empty().push(1).push(2).push(3)

        assert vec.contains(2)
        assert not vec.contains(99)

describe "PersistentVec - Structural Sharing":
    it "shares structure between versions":
        var vec1 = PersistentVec.empty()
        for i in 0..100:
            vec1 = vec1.push(i)

        val vec2 = vec1.push(999)

        assert vec1.len() == 100
        assert vec2.len() == 101

        assert vec1.get(50).unwrap() == 50
        assert vec2.get(50).unwrap() == 50
        assert not vec1.get(100).?
        assert vec2.get(100).unwrap() == 999

    it "handles many pushes efficiently":
        var vec = PersistentVec.empty()

        for i in 0..1000:
            vec = vec.push(i)

        assert vec.len() == 1000

        for i in 0..1000:
            assert vec.get(i).unwrap() == i

describe "PersistentVec - Bulk Operations":
    it "concatenates vectors":
        val vec1 = PersistentVec.empty().push(1).push(2)
        val vec2 = PersistentVec.empty().push(3).push(4)

        val concat = vec1.concat(vec2)

        assert concat.len() == 4
        assert concat.get(0).unwrap() == 1
        assert concat.get(2).unwrap() == 3

    it "maps elements":
        val vec = PersistentVec.empty().push(1).push(2).push(3)
        val doubled = vec.map(\x: x * 2)

        assert doubled.get(0).unwrap() == 2
        assert doubled.get(1).unwrap() == 4
        assert doubled.get(2).unwrap() == 6

    it "filters elements":
        val vec = PersistentVec.empty().push(1).push(2).push(3).push(4)
        val evens = vec.filter(\x: x % 2 == 0)

        assert evens.len() == 2
        assert evens.get(0).unwrap() == 2
        assert evens.get(1).unwrap() == 4

    it "folds elements":
        val vec = PersistentVec.empty().push(1).push(2).push(3)
        val sum = vec.fold(0, \acc, x: acc + x)

        assert sum == 6

    it "takes first n elements":
        val vec = PersistentVec.empty().push(1).push(2).push(3).push(4)
        val first2 = vec.take(2)

        assert first2.len() == 2
        assert first2.get(0).unwrap() == 1
        assert first2.get(1).unwrap() == 2

    it "drops first n elements":
        val vec = PersistentVec.empty().push(1).push(2).push(3).push(4)
        val last2 = vec.drop(2)

        assert last2.len() == 2
        assert last2.get(0).unwrap() == 3
        assert last2.get(1).unwrap() == 4

    it "slices vector":
        val vec = PersistentVec.empty().push(0).push(1).push(2).push(3).push(4)
        val slice = vec.slice(1, 4)

        assert slice.len() == 3
        assert slice.get(0).unwrap() == 1
        assert slice.get(1).unwrap() == 2
        assert slice.get(2).unwrap() == 3

    it "reverses vector":
        val vec = PersistentVec.empty().push(1).push(2).push(3)
        val reversed = vec.reverse()

        assert reversed.get(0).unwrap() == 3
        assert reversed.get(1).unwrap() == 2
        assert reversed.get(2).unwrap() == 1

describe "PersistentVec - Conversion":
    it "creates from array":
        val vec = PersistentVec.from_array([10, 20, 30])

        assert vec.len() == 3
        assert vec.get(1).unwrap() == 20

    it "creates with of()":
        val vec = PersistentVec.of(["a", "b", "c"])

        assert vec.len() == 3
        assert vec.get(0).unwrap() == "a"

    it "converts to array":
        val vec = PersistentVec.empty().push(1).push(2).push(3)
        val arr = vec.to_array()

        assert arr.len() == 3
        assert arr[0] == 1
        assert arr[1] == 2
        assert arr[2] == 3

describe "PersistentVec - String Elements":
    it "handles string elements":
        var vec = PersistentVec.empty()
        vec = vec.push("hello")
        vec = vec.push("world")

        assert vec.get(0).unwrap() == "hello"
        assert vec.get(1).unwrap() == "world"

describe "PersistentVec - Edge Cases":
    it "handles single element operations":
        val vec = PersistentVec.empty().push(42)

        assert vec.first().unwrap() == 42
        assert vec.last().unwrap() == 42
        assert vec.len() == 1

        val popped = vec.pop()
        assert popped.is_empty()

    it "handles boundary at branch factor":
        var vec = PersistentVec.empty()

        # Push exactly 32 elements (one full leaf)
        for i in 0..32:
            vec = vec.push(i)

        assert vec.len() == 32
        assert vec.get(0).unwrap() == 0
        assert vec.get(31).unwrap() == 31

        # Push one more (forces tree growth)
        vec = vec.push(32)

        assert vec.len() == 33
        assert vec.get(32).unwrap() == 32

    it "handles large vectors":
        var vec = PersistentVec.empty()

        for i in 0..500:
            vec = vec.push(i * 2)

        assert vec.len() == 500

        # Spot check
        assert vec.get(0).unwrap() == 0
        assert vec.get(100).unwrap() == 200
        assert vec.get(499).unwrap() == 998
