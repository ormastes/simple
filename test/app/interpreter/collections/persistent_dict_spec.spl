# PersistentDict Tests
#
# Tests for the HAMT-based persistent dictionary.

# @skip
use app.interpreter.collections.{PersistentDict}

describe "PersistentDict - Basic Operations":
    it "creates empty dictionary":
        val dict = PersistentDict.empty()
        check(dict.is_empty())
        check(dict.len() == 0)

    it "sets and gets a single entry":
        val dict = PersistentDict.empty()
        val dict2 = dict.set("key", 42)
        check(dict2.get("key").?)
        check(dict2.get("key").unwrap() == 42)
        check(dict2.len() == 1)

    it "returns None for missing key":
        val dict = PersistentDict.empty()
        check(not dict.get("missing").?)

    it "original is unchanged after set":
        val dict1 = PersistentDict.empty()
        val dict2 = dict1.set("key", 100)

        # Original still empty
        check(dict1.is_empty())
        check(dict1.len() == 0)
        check(not dict1.get("key").?)

        # New dict has entry
        check(dict2.len() == 1)
        check(dict2.get("key").unwrap() == 100)

    it "updates existing key":
        val dict1 = PersistentDict.empty()
        val dict2 = dict1.set("x", 1)
        val dict3 = dict2.set("x", 2)

        check(dict2.get("x").unwrap() == 1)
        check(dict3.get("x").unwrap() == 2)
        check(dict3.len() == 1  # Still one entry)

    it "handles multiple keys":
        var dict = PersistentDict.empty()
        dict = dict.set("a", 1)
        dict = dict.set("b", 2)
        dict = dict.set("c", 3)

        check(dict.len() == 3)
        check(dict.get("a").unwrap() == 1)
        check(dict.get("b").unwrap() == 2)
        check(dict.get("c").unwrap() == 3)

describe "PersistentDict - Remove":
    it "removes existing key":
        var dict = PersistentDict.empty()
        dict = dict.set("key", 42)
        val dict2 = dict.remove("key")

        check(dict.len() == 1)
        check(dict.get("key").?)

        check(dict2.is_empty())
        check(not dict2.get("key").?)

    it "handles remove of non-existent key":
        val dict = PersistentDict.empty()
        val dict2 = dict.set("a", 1)
        val dict3 = dict2.remove("b")  # Key doesn't exist

        check(dict3.len() == 1)
        check(dict3.get("a").unwrap() == 1)

    it "removes from multiple entries":
        var dict = PersistentDict.empty()
        dict = dict.set("a", 1).set("b", 2).set("c", 3)

        val dict2 = dict.remove("b")

        check(dict2.len() == 2)
        check(dict2.get("a").unwrap() == 1)
        check(not dict2.get("b").?)
        check(dict2.get("c").unwrap() == 3)

describe "PersistentDict - Structural Sharing":
    it "shares structure between versions":
        var dict1 = PersistentDict.empty()
        for i in 0..100:
            dict1 = dict1.set("key_{i}", i)

        val dict2 = dict1.set("new_key", 999)

        # Both should work independently
        check(dict1.len() == 100)
        check(dict2.len() == 101)

        check(not dict1.get("new_key").?)
        check(dict2.get("new_key").unwrap() == 999)

        # Original entries preserved in both
        check(dict1.get("key_50").unwrap() == 50)
        check(dict2.get("key_50").unwrap() == 50)

    it "handles many insertions efficiently":
        var dict = PersistentDict.empty()

        for i in 0..1000:
            dict = dict.set(i, i * 2)

        check(dict.len() == 1000)

        for i in 0..1000:
            check(dict.get(i).unwrap() == i * 2)

describe "PersistentDict - Query Methods":
    it "checks contains":
        var dict = PersistentDict.empty()
        dict = dict.set("exists", 1)

        check(dict.contains("exists"))
        check(not dict.contains("missing"))

    it "gets with default":
        var dict = PersistentDict.empty()
        dict = dict.set("key", 42)

        check(dict.get_or("key", 0) == 42)
        check(dict.get_or("missing", -1) == -1)

describe "PersistentDict - Bulk Operations":
    it "merges dictionaries":
        var dict1 = PersistentDict.empty()
        dict1 = dict1.set("a", 1).set("b", 2)

        var dict2 = PersistentDict.empty()
        dict2 = dict2.set("b", 20).set("c", 3)

        val merged = dict1.merge(dict2)

        check(merged.len() == 3)
        check(merged.get("a").unwrap() == 1)
        check(merged.get("b").unwrap() == 20  # dict2 wins)
        check(merged.get("c").unwrap() == 3)

    it "filters entries":
        var dict = PersistentDict.empty()
        dict = dict.set("a", 1).set("b", 2).set("c", 3).set("d", 4)

        val filtered = dict.filter(\k, v: v > 2)

        check(filtered.len() == 2)
        check(filtered.get("c").unwrap() == 3)
        check(filtered.get("d").unwrap() == 4)

    it "maps values":
        var dict = PersistentDict.empty()
        dict = dict.set("a", 1).set("b", 2)

        val mapped = dict.map_values(\v: v * 10)

        check(mapped.get("a").unwrap() == 10)
        check(mapped.get("b").unwrap() == 20)

describe "PersistentDict - Conversion":
    it "creates from entries":
        val dict = PersistentDict.from_entries([
            ("x", 10),
            ("y", 20),
            ("z", 30)
        ])

        check(dict.len() == 3)
        check(dict.get("y").unwrap() == 20)

    it "gets all entries":
        var dict = PersistentDict.empty()
        dict = dict.set("a", 1).set("b", 2)

        val entries = dict.entries()
        check(entries.len() == 2)

    it "gets all keys":
        var dict = PersistentDict.empty()
        dict = dict.set("x", 1).set("y", 2)

        val keys = dict.keys()
        check(keys.len() == 2)

    it "gets all values":
        var dict = PersistentDict.empty()
        dict = dict.set("a", 100).set("b", 200)

        val values = dict.values()
        check(values.len() == 2)

    it "converts to regular Dict":
        var pdict = PersistentDict.empty()
        pdict = pdict.set("key", 42)

        val dict = pdict.to_dict()
        check(dict["key"] == 42)

    it "creates from regular Dict":
        val dict: Dict<text, i64> = {"a": 1, "b": 2}
        val pdict = PersistentDict.from_dict(dict)

        check(pdict.len() == 2)
        check(pdict.get("a").unwrap() == 1)

describe "PersistentDict - Update":
    it "updates with function":
        var dict = PersistentDict.empty()
        dict = dict.set("counter", 0)

        val dict2 = dict.update("counter", \v:
            match v:
                case Some(n): n + 1
                case None: 0
        )

        check(dict2.get("counter").unwrap() == 1)

    it "inserts via update when key missing":
        val dict = PersistentDict.empty()

        val dict2 = dict.update("new", \v:
            match v:
                case Some(n): n
                case None: 42
        )

        check(dict2.get("new").unwrap() == 42)

describe "PersistentDict - Integer Keys":
    it "handles integer keys":
        var dict = PersistentDict.empty()
        dict = dict.set(1, "one")
        dict = dict.set(2, "two")
        dict = dict.set(1000, "thousand")

        check(dict.get(1).unwrap() == "one")
        check(dict.get(2).unwrap() == "two")
        check(dict.get(1000).unwrap() == "thousand")

describe "PersistentDict - Hash Collisions":
    # These tests verify collision handling works correctly
    it "handles entries with similar hashes":
        var dict = PersistentDict.empty()

        # Insert many entries - some may collide
        for i in 0..100:
            dict = dict.set(i * 32, i)  # Multiples of 32 may collide at level 0

        check(dict.len() == 100)

        for i in 0..100:
            check(dict.get(i * 32).unwrap() == i)
