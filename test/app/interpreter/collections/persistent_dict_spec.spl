# PersistentDict Tests
#
# Tests for the HAMT-based persistent dictionary.

# @skip
from persistent_dict import {PersistentDict}

describe "PersistentDict - Basic Operations":
    it "creates empty dictionary":
        val dict = PersistentDict.empty()
        assert dict.is_empty()
        assert dict.len() == 0

    it "sets and gets a single entry":
        val dict = PersistentDict.empty()
        val dict2 = dict.set("key", 42)
        assert dict2.get("key").?
        assert dict2.get("key").unwrap() == 42
        assert dict2.len() == 1

    it "returns None for missing key":
        val dict = PersistentDict.empty()
        assert not dict.get("missing").?

    it "original is unchanged after set":
        val dict1 = PersistentDict.empty()
        val dict2 = dict1.set("key", 100)

        # Original still empty
        assert dict1.is_empty()
        assert dict1.len() == 0
        assert not dict1.get("key").?

        # New dict has entry
        assert dict2.len() == 1
        assert dict2.get("key").unwrap() == 100

    it "updates existing key":
        val dict1 = PersistentDict.empty()
        val dict2 = dict1.set("x", 1)
        val dict3 = dict2.set("x", 2)

        assert dict2.get("x").unwrap() == 1
        assert dict3.get("x").unwrap() == 2
        assert dict3.len() == 1  # Still one entry

    it "handles multiple keys":
        var dict = PersistentDict.empty()
        dict = dict.set("a", 1)
        dict = dict.set("b", 2)
        dict = dict.set("c", 3)

        assert dict.len() == 3
        assert dict.get("a").unwrap() == 1
        assert dict.get("b").unwrap() == 2
        assert dict.get("c").unwrap() == 3

describe "PersistentDict - Remove":
    it "removes existing key":
        var dict = PersistentDict.empty()
        dict = dict.set("key", 42)
        val dict2 = dict.remove("key")

        assert dict.len() == 1
        assert dict.get("key").?

        assert dict2.is_empty()
        assert not dict2.get("key").?

    it "handles remove of non-existent key":
        val dict = PersistentDict.empty()
        val dict2 = dict.set("a", 1)
        val dict3 = dict2.remove("b")  # Key doesn't exist

        assert dict3.len() == 1
        assert dict3.get("a").unwrap() == 1

    it "removes from multiple entries":
        var dict = PersistentDict.empty()
        dict = dict.set("a", 1).set("b", 2).set("c", 3)

        val dict2 = dict.remove("b")

        assert dict2.len() == 2
        assert dict2.get("a").unwrap() == 1
        assert not dict2.get("b").?
        assert dict2.get("c").unwrap() == 3

describe "PersistentDict - Structural Sharing":
    it "shares structure between versions":
        var dict1 = PersistentDict.empty()
        for i in 0..100:
            dict1 = dict1.set("key_{i}", i)

        val dict2 = dict1.set("new_key", 999)

        # Both should work independently
        assert dict1.len() == 100
        assert dict2.len() == 101

        assert not dict1.get("new_key").?
        assert dict2.get("new_key").unwrap() == 999

        # Original entries preserved in both
        assert dict1.get("key_50").unwrap() == 50
        assert dict2.get("key_50").unwrap() == 50

    it "handles many insertions efficiently":
        var dict = PersistentDict.empty()

        for i in 0..1000:
            dict = dict.set(i, i * 2)

        assert dict.len() == 1000

        for i in 0..1000:
            assert dict.get(i).unwrap() == i * 2

describe "PersistentDict - Query Methods":
    it "checks contains":
        var dict = PersistentDict.empty()
        dict = dict.set("exists", 1)

        assert dict.contains("exists")
        assert not dict.contains("missing")

    it "gets with default":
        var dict = PersistentDict.empty()
        dict = dict.set("key", 42)

        assert dict.get_or("key", 0) == 42
        assert dict.get_or("missing", -1) == -1

describe "PersistentDict - Bulk Operations":
    it "merges dictionaries":
        var dict1 = PersistentDict.empty()
        dict1 = dict1.set("a", 1).set("b", 2)

        var dict2 = PersistentDict.empty()
        dict2 = dict2.set("b", 20).set("c", 3)

        val merged = dict1.merge(dict2)

        assert merged.len() == 3
        assert merged.get("a").unwrap() == 1
        assert merged.get("b").unwrap() == 20  # dict2 wins
        assert merged.get("c").unwrap() == 3

    it "filters entries":
        var dict = PersistentDict.empty()
        dict = dict.set("a", 1).set("b", 2).set("c", 3).set("d", 4)

        val filtered = dict.filter(\k, v: v > 2)

        assert filtered.len() == 2
        assert filtered.get("c").unwrap() == 3
        assert filtered.get("d").unwrap() == 4

    it "maps values":
        var dict = PersistentDict.empty()
        dict = dict.set("a", 1).set("b", 2)

        val mapped = dict.map_values(\v: v * 10)

        assert mapped.get("a").unwrap() == 10
        assert mapped.get("b").unwrap() == 20

describe "PersistentDict - Conversion":
    it "creates from entries":
        val dict = PersistentDict.from_entries([
            ("x", 10),
            ("y", 20),
            ("z", 30)
        ])

        assert dict.len() == 3
        assert dict.get("y").unwrap() == 20

    it "gets all entries":
        var dict = PersistentDict.empty()
        dict = dict.set("a", 1).set("b", 2)

        val entries = dict.entries()
        assert entries.len() == 2

    it "gets all keys":
        var dict = PersistentDict.empty()
        dict = dict.set("x", 1).set("y", 2)

        val keys = dict.keys()
        assert keys.len() == 2

    it "gets all values":
        var dict = PersistentDict.empty()
        dict = dict.set("a", 100).set("b", 200)

        val values = dict.values()
        assert values.len() == 2

    it "converts to regular Dict":
        var pdict = PersistentDict.empty()
        pdict = pdict.set("key", 42)

        val dict = pdict.to_dict()
        assert dict["key"] == 42

    it "creates from regular Dict":
        val dict: Dict<text, i64> = {"a": 1, "b": 2}
        val pdict = PersistentDict.from_dict(dict)

        assert pdict.len() == 2
        assert pdict.get("a").unwrap() == 1

describe "PersistentDict - Update":
    it "updates with function":
        var dict = PersistentDict.empty()
        dict = dict.set("counter", 0)

        val dict2 = dict.update("counter", \v:
            match v:
                case Some(n): n + 1
                case None: 0
        )

        assert dict2.get("counter").unwrap() == 1

    it "inserts via update when key missing":
        val dict = PersistentDict.empty()

        val dict2 = dict.update("new", \v:
            match v:
                case Some(n): n
                case None: 42
        )

        assert dict2.get("new").unwrap() == 42

describe "PersistentDict - Integer Keys":
    it "handles integer keys":
        var dict = PersistentDict.empty()
        dict = dict.set(1, "one")
        dict = dict.set(2, "two")
        dict = dict.set(1000, "thousand")

        assert dict.get(1).unwrap() == "one"
        assert dict.get(2).unwrap() == "two"
        assert dict.get(1000).unwrap() == "thousand"

describe "PersistentDict - Hash Collisions":
    # These tests verify collision handling works correctly
    it "handles entries with similar hashes":
        var dict = PersistentDict.empty()

        # Insert many entries - some may collide
        for i in 0..100:
            dict = dict.set(i * 32, i)  # Multiples of 32 may collide at level 0

        assert dict.len() == 100

        for i in 0..100:
            assert dict.get(i * 32).unwrap() == i
