# Persistent Dictionary - Intensive SSpec Tests
# Comprehensive tests for HAMT implementation correctness

use app.interpreter.collections.persistent_dict.*
use sspec.*

describe "PersistentDict intensive tests":
    describe "HAMT correctness":
        it "empty dict has size 0":
            val dict = PersistentDict.new()
            assert dict.len() == 0
            assert dict.is_empty()

        it "single entry":
            val dict = PersistentDict.new().set("key", 42)
            assert dict.len() == 1
            assert dict.get("key") == Some(42)

        it "multiple entries":
            var dict = PersistentDict.new()
            for i in 0..100:
                dict = dict.set("key_{i}", i)

            assert dict.len() == 100
            for i in 0..100:
                assert dict.get("key_{i}") == Some(i)

        it "update existing key":
            val dict1 = PersistentDict.new().set("key", 1)
            val dict2 = dict1.set("key", 2)

            # Both versions coexist
            assert dict1.get("key") == Some(1)
            assert dict2.get("key") == Some(2)

    describe "Immutability":
        it "original unchanged after set":
            val dict1 = PersistentDict.new()
            val dict2 = dict1.set("key", 1)

            assert dict1.is_empty()
            assert dict2.len() == 1

        it "multiple versions coexist":
            var dict0 = PersistentDict.new()
            var dict1 = dict0.set("a", 1)
            var dict2 = dict1.set("b", 2)
            var dict3 = dict2.set("c", 3)

            # All versions independent
            assert dict0.len() == 0
            assert dict1.len() == 1
            assert dict2.len() == 2
            assert dict3.len() == 3

            assert dict1.get("a") == Some(1)
            assert dict1.get("b") == None

            assert dict3.get("a") == Some(1)
            assert dict3.get("b") == Some(2)
            assert dict3.get("c") == Some(3)

    describe "Removal":
        it "removes entry":
            val dict1 = PersistentDict.new()
                .set("a", 1)
                .set("b", 2)
            val dict2 = dict1.remove("a")

            assert dict1.len() == 2
            assert dict2.len() == 1
            assert dict2.get("a") == None
            assert dict2.get("b") == Some(2)

        it "remove of missing key returns same dict":
            val dict1 = PersistentDict.new().set("a", 1)
            val dict2 = dict1.remove("missing")

            # Should return same reference (optimization)
            assert dict1.len() == dict2.len()

    describe "Hash collisions":
        it "handles keys with same hash":
            # Create keys that will collide
            # (This requires knowing hash function internals,
            # but tests collision handling)
            var dict = PersistentDict.new()

            # Insert many keys to increase collision probability
            for i in 0..1000:
                dict = dict.set("collision_test_{i}", i)

            # All should be retrievable
            for i in 0..1000:
                assert dict.get("collision_test_{i}") == Some(i)

    describe "Deep nesting":
        it "handles deep trie depth":
            var dict = PersistentDict.new()

            # Insert enough entries to create deep trie
            # (32^7 = 34 billion entries would reach max depth,
            # but even 10000 should create depth > 3)
            for i in 0..10000:
                dict = dict.set("key_{i}", i)

            # All retrievable
            for i in 0..10000:
                assert dict.get("key_{i}") == Some(i)

    describe "Bulk operations":
        it "merge combines dicts":
            val dict1 = PersistentDict.new()
                .set("a", 1)
                .set("b", 2)

            val dict2 = PersistentDict.new()
                .set("b", 20)
                .set("c", 3)

            val merged = dict1.merge(dict2)

            assert merged.len() == 3
            assert merged.get("a") == Some(1)
            assert merged.get("b") == Some(20)  # dict2 wins
            assert merged.get("c") == Some(3)

        it "filter keeps matching entries":
            var dict = PersistentDict.new()
            for i in 0..20:
                dict = dict.set("key_{i}", i)

            val evens = dict.filter(\k, v: v % 2 == 0)

            assert evens.len() == 10
            for i in 0..20:
                if i % 2 == 0:
                    assert evens.get("key_{i}") == Some(i)
                else:
                    assert evens.get("key_{i}") == None

        it "map_values transforms values":
            val dict = PersistentDict.new()
                .set("a", 1)
                .set("b", 2)

            val doubled = dict.map_values(\v: v * 2)

            assert doubled.get("a") == Some(2)
            assert doubled.get("b") == Some(4)

    describe "Conversion":
        it "converts to/from entries":
            val dict1 = PersistentDict.from_entries([
                ("a", 1),
                ("b", 2),
                ("c", 3)
            ])

            assert dict1.len() == 3

            val entries = dict1.entries()
            assert entries.len() == 3
            assert entries.contains(("a", 1))
            assert entries.contains(("b", 2))
            assert entries.contains(("c", 3))

        it "gets keys":
            val dict = PersistentDict.from_entries([
                ("a", 1),
                ("b", 2)
            ])

            val keys = dict.keys()
            assert keys.len() == 2
            assert keys.contains("a")
            assert keys.contains("b")

        it "gets values":
            val dict = PersistentDict.from_entries([
                ("a", 1),
                ("b", 2)
            ])

            val values = dict.values()
            assert values.len() == 2
            assert values.contains(1)
            assert values.contains(2)

    describe "Performance - structural sharing":
        it "updates are O(log n) not O(n)":
            # Build large dict
            var dict = PersistentDict.new()
            for i in 0..10000:
                dict = dict.set("key_{i}", i)

            # Single update should be fast
            val start = time.now()
            val dict2 = dict.set("new_key", 42)
            val elapsed = time.now() - start

            # Should be < 1ms (would be ~10ms if copying entire dict)
            assert elapsed < 1.ms

        it "memory is shared between versions":
            # This is hard to test directly, but we can verify
            # that operations complete in expected time

            var dict = PersistentDict.new()
            for i in 0..1000:
                dict = dict.set("key_{i}", i)

            # Create 1000 versions with small changes
            val start = time.now()
            var versions: [PersistentDict] = []
            for i in 0..1000:
                versions = versions.push(dict.set("version_{i}", i))
            val elapsed = time.now() - start

            # If sharing works, this should be fast (< 20ms)
            # Without sharing, would be very slow (seconds)
            assert elapsed < 20.ms

    describe "Stress tests":
        it "handles 10000 insertions":
            val start = time.now()

            var dict = PersistentDict.new()
            for i in 0..10000:
                dict = dict.set("key_{i}", i)

            val elapsed = time.now() - start

            assert dict.len() == 10000
            # Should complete in < 100ms
            assert elapsed < 100.ms

        it "handles mixed operations":
            var dict = PersistentDict.new()

            # Insert
            for i in 0..1000:
                dict = dict.set("key_{i}", i)

            # Update some
            for i in 0..500:
                dict = dict.set("key_{i}", i * 2)

            # Remove some
            for i in 500..750:
                dict = dict.remove("key_{i}")

            # Verify final state
            assert dict.len() == 750
            for i in 0..500:
                assert dict.get("key_{i}") == Some(i * 2)
            for i in 500..750:
                assert dict.get("key_{i}") == None
            for i in 750..1000:
                assert dict.get("key_{i}") == Some(i)

    describe "Edge cases":
        it "handles empty string key":
            val dict = PersistentDict.new().set("", 42)
            assert dict.get("") == Some(42)

        it "handles long string keys":
            val long_key = "x" * 1000
            val dict = PersistentDict.new().set(long_key, 1)
            assert dict.get(long_key) == Some(1)

        it "handles unicode keys":
            val dict = PersistentDict.new()
                .set("hÃ©llo", 1)
                .set("ä¸–ç•Œ", 2)
                .set("ðŸš€", 3)

            assert dict.get("hÃ©llo") == Some(1)
            assert dict.get("ä¸–ç•Œ") == Some(2)
            assert dict.get("ðŸš€") == Some(3)

    describe "Array helper correctness":
        it "array_insert places at correct position":
            val arr = [1, 2, 3]
            val result = array_insert(arr, 1, 99)
            assert result == [1, 99, 2, 3]

        it "array_insert at end":
            val arr = [1, 2]
            val result = array_insert(arr, 2, 3)
            assert result == [1, 2, 3]

        it "array_update modifies correct element":
            val arr = [1, 2, 3]
            val result = array_update(arr, 1, 99)
            assert result == [1, 99, 3]

        it "array_remove deletes correct element":
            val arr = [1, 2, 3]
            val result = array_remove(arr, 1)
            assert result == [1, 3]

        it "array helpers don't mutate original":
            val arr = [1, 2, 3]
            val _ = array_insert(arr, 1, 99)
            val _ = array_update(arr, 1, 99)
            val _ = array_remove(arr, 1)

            # Original unchanged
            assert arr == [1, 2, 3]
