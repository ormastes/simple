# MessageTransfer Tests
#
# Tests for intelligent message transfer between actors.

# @skip
from message_transfer import {
    MessageTransfer,
    TransferResult,
    TransferStats,
    ValueWrapper,
    ValueType,
    MailboxMessage,
    send_value,
    receive_value,
    estimate_size
}
from refc_binary import {
    SharedHeap,
    SharedHeapConfig,
    BinaryRef,
    SMALL_BINARY_THRESHOLD
}

describe "ValueWrapper - Inline Types":
    it "wraps nil":
        val wrapper = ValueWrapper.InlineNil

        check(not wrapper.is_shared())
        check(wrapper.estimated_size() == 1)

    it "wraps integer":
        val wrapper = ValueWrapper.InlineInt(42)

        check(not wrapper.is_shared())
        check(wrapper.estimated_size() == 8)

    it "wraps float":
        val wrapper = ValueWrapper.InlineFloat(3.14)

        check(not wrapper.is_shared())
        check(wrapper.estimated_size() == 8)

    it "wraps bool":
        val wrapper = ValueWrapper.InlineBool(true)

        check(not wrapper.is_shared())
        check(wrapper.estimated_size() == 1)

    it "wraps small text":
        val wrapper = ValueWrapper.InlineSmallText("hello")

        check(not wrapper.is_shared())
        check(wrapper.estimated_size() == 5)

    it "wraps small array":
        val wrapper = ValueWrapper.InlineSmallArray([
            ValueWrapper.InlineInt(1),
            ValueWrapper.InlineInt(2)
        ])

        check(not wrapper.is_shared())
        check(wrapper.estimated_size() == 16  # 2 * 8 bytes)

describe "ValueWrapper - Shared Types":
    it "wraps shared ref":
        val ref = BinaryRef__new(1, 0, 1024)
        val wrapper = ValueWrapper.SharedRef(ref)

        check(wrapper.is_shared())
        check(wrapper.estimated_size() == 1024)

    it "extracts shared refs":
        val ref = BinaryRef__new(1, 0, 256)
        val wrapper = ValueWrapper.SharedRef(ref)

        val refs = wrapper.shared_refs()

        check(refs.len() == 1)
        check(refs[0].id == 1)

    it "extracts refs from composite":
        val ref1 = BinaryRef__new(1, 0, 100)
        val ref2 = BinaryRef__new(2, 0, 200)

        val wrapper = ValueWrapper.Composite([
            ValueWrapper.SharedRef(ref1),
            ValueWrapper.InlineInt(42),
            ValueWrapper.SharedRef(ref2)
        ])

        val refs = wrapper.shared_refs()

        check(refs.len() == 2)

describe "ValueWrapper - Display":
    it "formats inline types":
        check(ValueWrapper.InlineNil__fmt() == "nil")
        check(ValueWrapper.InlineInt(42).fmt().contains("42"))
        check(ValueWrapper.InlineBool(true).fmt().contains("true"))

    it "formats shared ref":
        val ref = BinaryRef__new(1, 0, 256)
        val wrapper = ValueWrapper.SharedRef(ref)

        check(wrapper.fmt().contains("Shared"))

    it "formats composite":
        val wrapper = ValueWrapper.Composite([
            ValueWrapper.InlineInt(1),
            ValueWrapper.InlineInt(2)
        ])

        check(wrapper.fmt().contains("Composite"))
        check(wrapper.fmt().contains("2"))

describe "TransferStats":
    it "creates empty stats":
        val stats = TransferStats__new()

        check(stats.total_transfers == 0)
        check(stats.inline_transfers == 0)
        check(stats.shared_transfers == 0)

    it "calculates sharing ratio":
        var stats = TransferStats__new()
        stats.total_transfers = 10
        stats.shared_transfers = 4

        check(stats.sharing_ratio() == 0.4)

    it "calculates efficiency":
        var stats = TransferStats__new()
        stats.inline_bytes = 100
        stats.shared_bytes = 900

        val eff = stats.efficiency()
        check(eff == 0.9)

    it "handles zero transfers":
        val stats = TransferStats__new()

        check(stats.sharing_ratio() == 0.0)
        check(stats.efficiency() == 1.0)

describe "MessageTransfer - Wrapping Primitives":
    it "wraps nil":
        var transfer = MessageTransfer__new()

        val result = transfer.wrap_nil()

        check(result.is_success())
        match result.unwrap():
            case InlineNil: assert true
            case _: assert false

    it "wraps integer":
        var transfer = MessageTransfer__new()

        val result = transfer.wrap_int(42)

        check(result.is_success())
        match result.unwrap():
            case InlineInt(v): assert v == 42
            case _: assert false

    it "wraps float":
        var transfer = MessageTransfer__new()

        val result = transfer.wrap_float(3.14)

        check(result.is_success())
        match result.unwrap():
            case InlineFloat(_): assert true
            case _: assert false

    it "wraps bool":
        var transfer = MessageTransfer__new()

        val result = transfer.wrap_bool(true)

        check(result.is_success())
        match result.unwrap():
            case InlineBool(v): assert v == true
            case _: assert false

describe "MessageTransfer - Wrapping Text":
    it "wraps small text inline":
        var transfer = MessageTransfer__new()

        val result = transfer.wrap_text("hello")

        check(result.is_success())
        match result.unwrap():
            case InlineSmallText(s): assert s == "hello"
            case _: assert false

    it "wraps large text as shared":
        var transfer = MessageTransfer__new()

        # Create text > 64 bytes
        val large_text = "x".repeat(100)
        val result = transfer.wrap_text(large_text)

        check(result.is_success())
        match result.unwrap():
            case SharedRef(_): assert true
            case _: assert false

describe "MessageTransfer - Strategy Selection":
    it "uses hybrid strategy by default":
        var transfer = MessageTransfer__new()

        # Small value - should be inline
        val small_result = transfer.wrap_for_send(0, 32, ValueType.Binary)
        match small_result.unwrap():
            case SharedRef(_): assert false
            case _: assert true

    it "always copies with DeepCopy strategy":
        var transfer = MessageTransfer__always_copy()

        val result = transfer.wrap_for_send(0, 1024, ValueType.Binary)

        # Even large value should not be shared
        match result.unwrap():
            case SharedRef(_): assert false
            case _: assert true

    it "always shares with ShareRef strategy":
        var transfer = MessageTransfer__always_share()

        val result = transfer.wrap_for_send(0, 32, ValueType.Binary)

        # Even small value should be shared
        match result.unwrap():
            case SharedRef(_): assert true
            case _: assert false

describe "MessageTransfer - Large Values":
    it "allocates large value in shared heap":
        val heap = SharedHeap__new(SharedHeapConfig.small())
        var transfer = MessageTransfer__with_heap(heap)

        val result = transfer.wrap_for_send(0, 1024, ValueType.Binary)

        check(result.is_success())
        match result.unwrap():
            case SharedRef(ref):
                check(ref.length == 1024)
            case _:
                check(false)

    it "tracks shared transfer stats":
        var transfer = MessageTransfer__new()

        transfer.wrap_for_send(0, 1024, ValueType.Binary)

        val stats = transfer.get_stats()
        check(stats.shared_transfers == 1)
        check(stats.shared_bytes == 1024)
        check(stats.bytes_saved == 1024)

describe "MessageTransfer - Reference Sharing":
    it "increments refcount when sharing":
        val heap = SharedHeap__new(SharedHeapConfig.small())
        var transfer = MessageTransfer__with_heap(heap)

        val result = transfer.wrap_for_send(0, 1024, ValueType.Binary)
        val wrapper = result.unwrap()

        # Share with another actor
        transfer.share_wrapper(wrapper)

        # Check refcount increased
        match wrapper:
            case SharedRef(ref):
                val binary = heap.get(ref.id)
                check(binary.?.refcount == 2)
            case _:
                check(false)

    it "decrements refcount on release":
        val heap = SharedHeap__new(SharedHeapConfig.small())
        var transfer = MessageTransfer__with_heap(heap)

        val result = transfer.wrap_for_send(0, 1024, ValueType.Binary)
        val wrapper = result.unwrap()
        transfer.share_wrapper(wrapper)

        transfer.release_wrapper(wrapper)

        match wrapper:
            case SharedRef(ref):
                val binary = heap.get(ref.id)
                check(binary.?.refcount == 1)
            case _:
                check(false)

describe "MessageTransfer - Statistics":
    it "tracks total transfers":
        var transfer = MessageTransfer__new()

        transfer.wrap_nil()
        transfer.wrap_int(1)
        transfer.wrap_int(2)

        val stats = transfer.get_stats()
        check(stats.total_transfers == 3)

    it "tracks inline vs shared":
        var transfer = MessageTransfer__new()

        transfer.wrap_int(42)  # Inline
        transfer.wrap_for_send(0, 1024, ValueType.Binary)  # Shared

        val stats = transfer.get_stats()
        check(stats.inline_transfers == 1)
        check(stats.shared_transfers == 1)

    it "reports heap stats":
        val heap = SharedHeap__new(SharedHeapConfig.small())
        var transfer = MessageTransfer__with_heap(heap)

        transfer.wrap_for_send(0, 1024, ValueType.Binary)

        val heap_stats = transfer.heap_stats()
        check(heap_stats.binary_count == 1)

describe "TransferResult":
    it "checks success":
        val success = TransferResult.Success(ValueWrapper.InlineNil)
        val failure = TransferResult.OutOfMemory

        check(success.is_success())
        check(not failure.is_success())

    it "unwraps success":
        val result = TransferResult.Success(ValueWrapper.InlineInt(42))
        val wrapper = result.unwrap()

        match wrapper:
            case InlineInt(v): assert v == 42
            case _: assert false

    it "gets optional wrapper":
        val success = TransferResult.Success(ValueWrapper.InlineNil)
        val failure = TransferResult.OutOfMemory

        check(success.wrapper().?)
        check(not failure.wrapper().?)

describe "MailboxMessage":
    it "creates message":
        val wrapper = ValueWrapper.InlineInt(42)
        val msg = MailboxMessage__new(1, Some(10), wrapper)

        check(msg.id == 1)
        check(msg.sender_id == Some(10))

    it "reports size":
        val wrapper = ValueWrapper.InlineInt(42)
        val msg = MailboxMessage__new(1, None, wrapper)

        check(msg.size() == 8)

    it "detects shared messages":
        val ref = BinaryRef__new(1, 0, 1024)
        val wrapper = ValueWrapper.SharedRef(ref)
        val msg = MailboxMessage__new(1, None, wrapper)

        check(msg.is_shared())

    it "detects inline messages":
        val wrapper = ValueWrapper.InlineInt(42)
        val msg = MailboxMessage__new(1, None, wrapper)

        check(not msg.is_shared())

describe "ValueType":
    it "estimates primitive sizes":
        check(estimate_size(ValueType.Nil, 0) == 1)
        check(estimate_size(ValueType.Int, 0) == 8)
        check(estimate_size(ValueType.Float, 0) == 8)
        check(estimate_size(ValueType.Bool, 0) == 1)

describe "Convenience Functions":
    it "sends small value":
        val result = send_value(0, 32, ValueType.Binary)

        check(result.is_success())

    it "sends large value":
        val result = send_value(0, 1024, ValueType.Binary)

        check(result.is_success())
        check(result.unwrap().is_shared())
