# ActorHeap Tests
#
# Tests for per-actor heap isolation.

# @skip
use app.interpreter.async_runtime.actor_heap.{
    ActorHeap, HeapConfig, HeapStats, AllocationResult,
    HeapConfig__default, HeapConfig__small, HeapConfig__large, HeapConfig__no_gc,
    HeapStats__new, ActorHeap__new
}
use std.spec.{check, check_msg}

# Constants (workaround for nested module export limitation - copied from actor_heap.spl)
val DEFAULT_HEAP_SIZE: i64 = 2048
val DEFAULT_MAX_HEAP_SIZE: i64 = 16777216
val MIN_HEAP_SIZE: i64 = 512
val HEAP_GROWTH_FACTOR: f64 = 1.5
val GC_THRESHOLD_PERCENT: i64 = 80

describe "ActorHeap - Configuration":
    it "creates with default config":
        val heap = ActorHeap__new(HeapConfig__default())
        val config = heap.config

        check(config.initial_size == 2048)
        check(config.gc_enabled)
        check(config.generational)

    it "creates with custom config":
        val config = HeapConfig(
            initial_size: 1024,
            max_size: 4096,
            gc_enabled: true,
            generational: false,
            pretenure_threshold: 5
        )
        val heap = ActorHeap__new(config)

        check(heap.config.initial_size == 1024)
        check(heap.config.max_size == 4096)
        check(not heap.config.generational)

    it "creates small heap":
        val heap = ActorHeap__new(HeapConfig__small())
        check(heap.config.initial_size == 512)

    it "creates large heap":
        val heap = ActorHeap__new(HeapConfig__large())
        check(heap.config.initial_size == 65536)

describe "ActorHeap - Allocation":
    it "allocates memory":
        var heap = ActorHeap__new(HeapConfig__default())
        val result = heap.allocate(100)

        check(result.is_success())

    it "tracks allocation stats":
        var heap = ActorHeap__new(HeapConfig__default())
        heap.allocate(100)
        heap.allocate(200)

        val stats = heap.get_stats()
        check(stats.used_bytes == 300)
        check(stats.object_count == 2)

    it "fails when heap exhausted":
        val config = HeapConfig(
            initial_size: 100,
            max_size: 100,
            gc_enabled: false,
            generational: false,
            pretenure_threshold: 0
        )
        var heap = ActorHeap__new(config)

        # Fill the heap
        heap.allocate(90)

        # Next allocation should fail
        val result = heap.allocate(50)
        check(not result.is_success())

    it "handles zero-size allocation":
        var heap = ActorHeap__new(HeapConfig__default())
        val result = heap.allocate(0)

        check(result.is_success())

describe "ActorHeap - Garbage Collection":
    it "triggers GC when threshold reached":
        val config = HeapConfig__default()
        var heap = ActorHeap__new(config)

        # Allocate near threshold
        heap.allocate(200 * 1024)

        val stats = heap.get_stats()
        # GC may have been triggered
        check(stats.allocated_bytes >= 0)

    it "collects garbage manually":
        var heap = ActorHeap__new(HeapConfig__default())
        heap.allocate(1000)

        heap.collect_garbage()

        val stats = heap.get_stats()
        check(stats.gc_count >= 1)

    it "collects young generation only":
        var heap = ActorHeap__new(HeapConfig__default())
        heap.allocate(500)

        heap.collect_young_generation()

        val stats = heap.get_stats()
        check(stats.young_gen_size >= 0)

    it "respects gc_enabled flag":
        val config = HeapConfig(
            initial_size: 1024,
            max_size: 4096,
            gc_enabled: false,
            generational: false,
            pretenure_threshold: 0
        )
        var heap = ActorHeap__new(config)

        heap.collect_garbage()

        val stats = heap.get_stats()
        check(stats.gc_count == 0)

describe "ActorHeap - Statistics":
    it "tracks peak usage":
        var heap = ActorHeap__new(HeapConfig__default())

        heap.allocate(100)
        heap.allocate(200)

        val stats = heap.get_stats()
        check(stats.peak_used_bytes >= 300)

    it "reports usage percent":
        var heap = ActorHeap__new(HeapConfig__default())
        heap.allocate(100)

        val usage = heap.usage_percent()
        check(usage >= 0)
        check(usage <= 100)

    it "checks heap health":
        var heap = ActorHeap__new(HeapConfig__default())
        heap.allocate(1000)

        check(heap.is_healthy())

describe "ActorHeap - Display":
    it "formats heap for display":
        val heap = ActorHeap__new(HeapConfig__default())
        val str = heap.fmt()

        check(str.contains("ActorHeap"))

    it "formats stats for display":
        val stats = HeapStats__new()
        val str = stats.fmt()

        check(str.contains("HeapStats"))

describe "ActorHeap - Region Management":
    it "tracks young generation":
        var heap = ActorHeap__new(HeapConfig__default())
        heap.allocate(100)

        check(heap.young_generation.used >= 100)

    it "handles non-generational heap":
        val config = HeapConfig__no_gc(1024)
        var heap = ActorHeap__new(config)

        heap.allocate(100)

        check(not heap.old_generation.?)
