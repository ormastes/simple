# ActorScheduler Tests
#
# Tests for reductions-based fair scheduling.

# @skip
use std.spec.{check, check_msg}
use app.interpreter.async_runtime.actor_scheduler.{
    ActorScheduler,
    SchedulerConfig,
    SchedulerStats,
    ActorContext,
    ActorPriority,
    ActorState,
    RunQueue,
    ActorScheduler__new,
    SchedulerConfig__default,
    SchedulerConfig__single_threaded,
    SchedulerConfig__low_latency,
    SchedulerConfig__high_throughput,
    ActorPriority__from_i64,
    ActorContext__with_defaults,
    RunQueue__new,
    SchedulerStats__new
}

# Constants (workaround for nested module export limitation)
val DEFAULT_REDUCTIONS_PER_TIMESLICE: i64 = 2000
val DEFAULT_MAX_RUN_QUEUE_LENGTH: i64 = 10000
val DEFAULT_SCHEDULER_COUNT: i64 = 4

# From actor_heap (needed by HeapConfig__default)
val DEFAULT_HEAP_SIZE: i64 = 2048
val DEFAULT_MAX_HEAP_SIZE: i64 = 16777216

describe "SchedulerConfig":
    it "creates default config":
        val config = SchedulerConfig__default()

        check(config.reductions_per_timeslice == 2000)
        check(config.scheduler_count == 4)
        check(config.work_stealing_enabled)
        check(config.priority_scheduling)

    it "creates single-threaded config":
        val config = SchedulerConfig__single_threaded()

        check(config.scheduler_count == 1)
        check(not config.work_stealing_enabled)

    it "creates low-latency config":
        val config = SchedulerConfig__low_latency()

        check(config.reductions_per_timeslice == 500)

    it "creates high-throughput config":
        val config = SchedulerConfig__high_throughput()

        check(config.reductions_per_timeslice == 8000)
        check(not config.priority_scheduling)

describe "ActorPriority":
    it "converts to i64":
        check(ActorPriority.Max.to_i64() == 0)
        check(ActorPriority.High.to_i64() == 1)
        check(ActorPriority.Normal.to_i64() == 2)
        check(ActorPriority.Low.to_i64() == 3)

    it "converts from i64":
        check(ActorPriority__from_i64(0) == ActorPriority.Max)
        check(ActorPriority__from_i64(1) == ActorPriority.High)
        check(ActorPriority__from_i64(2) == ActorPriority.Normal)
        check(ActorPriority__from_i64(99) == ActorPriority.Low)  # Default

    it "compares priorities":
        check(ActorPriority.Max.cmp(ActorPriority.High) < 0)
        check(ActorPriority.Normal.cmp(ActorPriority.Low) < 0)
        check(ActorPriority.Low.cmp(ActorPriority.Max) > 0)

describe "ActorState":
    it "checks alive status":
        check(ActorState.Runnable.is_alive())
        check(ActorState.Running.is_alive())
        check(ActorState.Waiting.is_alive())
        check(ActorState.Suspended.is_alive())
        check(not ActorState.Exiting.is_alive())
        check(not ActorState.Dead.is_alive())

    it "checks can_run status":
        check(ActorState.Runnable.can_run())
        check(not ActorState.Running.can_run())
        check(not ActorState.Waiting.can_run())
        check(not ActorState.Dead.can_run())

    it "formats for display":
        check(ActorState.Runnable.fmt() == "runnable")
        check(ActorState.Dead.fmt() == "dead")

describe "RunQueue":
    it "creates empty queue":
        val queue = RunQueue__new()

        check(queue.is_empty())
        check(queue.len() == 0)

    it "enqueues by priority":
        var queue = RunQueue__new()

        queue.enqueue(1, ActorPriority.Normal)
        queue.enqueue(2, ActorPriority.High)
        queue.enqueue(3, ActorPriority.Low)

        check(queue.len() == 3)
        check(queue.len_by_priority(ActorPriority.Normal) == 1)
        check(queue.len_by_priority(ActorPriority.High) == 1)
        check(queue.len_by_priority(ActorPriority.Low) == 1)

    it "dequeues by priority order":
        var queue = RunQueue__new()

        queue.enqueue(1, ActorPriority.Low)
        queue.enqueue(2, ActorPriority.Normal)
        queue.enqueue(3, ActorPriority.Max)

        # Should get max priority first
        val first = queue.dequeue()
        check(first.unwrap() == 3)

        val second = queue.dequeue()
        check(second.unwrap() == 2)

        val third = queue.dequeue()
        check(third.unwrap() == 1)

    it "returns nil when empty":
        var queue = RunQueue__new()
        val result = queue.dequeue()

        check(not result.?)

    it "removes specific actor":
        var queue = RunQueue__new()

        queue.enqueue(1, ActorPriority.Normal)
        queue.enqueue(2, ActorPriority.Normal)
        queue.enqueue(3, ActorPriority.Normal)

        queue.remove(2)

        check(queue.len() == 2)

describe "ActorContext":
    it "creates with defaults":
        val ctx = ActorContext__with_defaults(1, Some("test"), 2000)

        check(ctx.id == 1)
        check(ctx.name == Some("test"))
        check(ctx.priority == ActorPriority.Normal)
        check(ctx.state == ActorState.Runnable)
        check(ctx.reductions_left == 2000)

    it "consumes reductions":
        var ctx = ActorContext__with_defaults(1, nil, 2000)

        val exhausted1 = ctx.consume_reductions(500)
        check(not exhausted1)
        check(ctx.reductions_left == 1500)

        val exhausted2 = ctx.consume_reductions(2000)
        check(exhausted2)
        check(ctx.reductions_left < 0)

    it "resets reductions":
        var ctx = ActorContext__with_defaults(1, nil, 2000)

        ctx.consume_reductions(2000)
        ctx.reset_reductions(2000)

        check(ctx.reductions_left == 2000)
        check(ctx.timeslice_count == 1)

    it "transitions states":
        var ctx = ActorContext__with_defaults(1, nil, 2000)

        ctx.set_running()
        check(ctx.state == ActorState.Running)

        ctx.set_waiting()
        check(ctx.state == ActorState.Waiting)

        ctx.set_suspended()
        check(ctx.state == ActorState.Suspended)

        ctx.set_runnable()
        check(ctx.state == ActorState.Runnable)

        ctx.set_dead()
        check(ctx.state == ActorState.Dead)

    it "manages links":
        var ctx = ActorContext__with_defaults(1, nil, 2000)

        ctx.link(2)
        ctx.link(3)

        check(ctx.links.len() == 2)

        ctx.unlink(2)

        check(ctx.links.len() == 1)
        check(ctx.links[0] == 3)

    it "manages monitors":
        var ctx = ActorContext__with_defaults(1, nil, 2000)

        ctx.monitor(5)
        ctx.add_monitored_by(10)

        check(ctx.monitors.len() == 1)
        check(ctx.monitored_by.len() == 1)

        ctx.demonitor(5)
        ctx.remove_monitored_by(10)

        check(ctx.monitors.len() == 0)
        check(ctx.monitored_by.len() == 0)

    it "formats for display":
        val ctx = ActorContext__with_defaults(1, Some("worker"), 2000)
        val str = ctx.fmt()

        check(str.contains("Actor"))
        check(str.contains("worker"))

describe "ActorScheduler - Spawning":
    it "spawns actors":
        var scheduler = ActorScheduler__default()

        val id1 = scheduler.spawn_actor(Some("actor1"))
        val id2 = scheduler.spawn_actor(Some("actor2"))

        check(id1 == 0)
        check(id2 == 1)
        check(scheduler.actor_count() == 2)

    it "spawns with priority":
        var scheduler = ActorScheduler__default()

        val id = scheduler.spawn_with_priority(Some("high"), ActorPriority.High)
        val act = scheduler.get_actor(id)

        match act:
            case Some(a):
                check(a.priority == ActorPriority.High)
            case nil:
                fail "actor not found"

    it "updates stats on spawn":
        var scheduler = ActorScheduler__default()

        scheduler.spawn_actor(nil)
        scheduler.spawn_actor(nil)

        val stats = scheduler.get_stats()
        check(stats.total_actors_created == 2)
        check(stats.current_actor_count == 2)
        check(stats.peak_actor_count == 2)

describe "ActorScheduler - Termination":
    it "terminates actors":
        var scheduler = ActorScheduler__default()

        val id = scheduler.spawn_actor(Some("test"))
        scheduler.terminate(id)

        val act = scheduler.get_actor(id)
        match act:
            case Some(a):
                check(a.state == ActorState.Dead)
            case nil:
                fail "actor not found"

    it "updates stats on termination":
        var scheduler = ActorScheduler__default()

        val id = scheduler.spawn_actor(nil)
        scheduler.terminate(id)

        val stats = scheduler.get_stats()
        check(stats.total_actors_terminated == 1)
        check(stats.current_actor_count == 0)

describe "ActorScheduler - Scheduling":
    it "runs one timeslice":
        var scheduler = ActorScheduler__default()
        scheduler.spawn_actor(nil)

        val did_work = scheduler.run_one_timeslice()

        check(did_work)

    it "returns false when no runnable":
        var scheduler = ActorScheduler__default()

        val did_work = scheduler.run_one_timeslice()

        check(not did_work)

    it "tracks context switches":
        var scheduler = ActorScheduler__default()
        scheduler.spawn_actor(nil)

        scheduler.run_one_timeslice()
        scheduler.run_one_timeslice()

        val stats = scheduler.get_stats()
        check(stats.total_context_switches >= 2)

    it "runs until idle":
        var scheduler = ActorScheduler__new(SchedulerConfig__single_threaded())

        # Spawn actors
        scheduler.spawn_actor(nil)
        scheduler.spawn_actor(nil)

        scheduler.start()
        scheduler.run_n_timeslices(5)

        val stats = scheduler.get_stats()
        check(stats.total_timeslices == 5)

    it "checks runnable status":
        var scheduler = ActorScheduler__default()

        check(not scheduler.has_runnable())

        scheduler.spawn_actor(nil)
        check(scheduler.has_runnable())

describe "ActorScheduler - Wake/Suspend":
    it "suspends actor":
        var scheduler = ActorScheduler__default()
        val id = scheduler.spawn_actor(nil)

        scheduler.suspend_actor(id)

        val act = scheduler.get_actor(id)
        match act:
            case Some(a):
                check(a.state == ActorState.Suspended)
            case nil:
                fail "actor not found"

    it "resumes actor":
        var scheduler = ActorScheduler__default()
        val id = scheduler.spawn_actor(nil)

        scheduler.suspend_actor(id)
        scheduler.resume_actor(id)

        val act = scheduler.get_actor(id)
        match act:
            case Some(a):
                check(a.state == ActorState.Runnable)
            case nil:
                fail "actor not found"

describe "ActorScheduler - Messaging":
    it "sends message":
        var scheduler = ActorScheduler__default()
        val id = scheduler.spawn_actor(nil)

        val success = scheduler.send_message(id, 12345, 100, nil)

        check(success)

        val act = scheduler.get_actor(id)
        match act:
            case Some(a):
                check(a.mailbox.total_size() == 1)
            case nil:
                fail "actor not found"

    it "sends high priority message":
        var scheduler = ActorScheduler__default()
        val id = scheduler.spawn_actor(nil)

        val success = scheduler.send_high_priority(id, 12345, 100, nil)

        check(success)

    it "fails to send to nonexistent actor":
        var scheduler = ActorScheduler__default()

        val success = scheduler.send_message(999, 12345, 100, nil)

        check(not success)

describe "ActorScheduler - Linking":
    it "links actors":
        var scheduler = ActorScheduler__default()
        val id1 = scheduler.spawn_actor(nil)
        val id2 = scheduler.spawn_actor(nil)

        scheduler.link_actors(id1, id2)

        val act1 = scheduler.get_actor(id1)
        val act2 = scheduler.get_actor(id2)

        match act1:
            case Some(a1):
                check(a1.links.contains(id2))
            case nil:
                fail "actor1 not found"

        match act2:
            case Some(a2):
                check(a2.links.contains(id1))
            case nil:
                fail "actor2 not found"

    it "unlinks actors":
        var scheduler = ActorScheduler__default()
        val id1 = scheduler.spawn_actor(nil)
        val id2 = scheduler.spawn_actor(nil)

        scheduler.link_actors(id1, id2)
        scheduler.unlink_actors(id1, id2)

        val act1 = scheduler.get_actor(id1)
        match act1:
            case Some(a):
                check(not a.links.contains(id2))
            case nil:
                fail "actor not found"

describe "ActorScheduler - Monitoring":
    it "sets up monitoring":
        var scheduler = ActorScheduler__default()
        val monitor_id = scheduler.spawn_actor(Some("monitor"))
        val target_id = scheduler.spawn_actor(Some("target"))

        scheduler.monitor_actor(monitor_id, target_id)

        val mon = scheduler.get_actor(monitor_id)
        val tgt = scheduler.get_actor(target_id)

        match mon:
            case Some(m):
                check(m.monitors.contains(target_id))
            case nil:
                fail "monitor actor not found"

        match tgt:
            case Some(t):
                check(t.monitored_by.contains(monitor_id))
            case nil:
                fail "target actor not found"

    it "removes monitoring":
        var scheduler = ActorScheduler__default()
        val monitor_id = scheduler.spawn_actor(nil)
        val target_id = scheduler.spawn_actor(nil)

        scheduler.monitor_actor(monitor_id, target_id)
        scheduler.demonitor_actor(monitor_id, target_id)

        val mon = scheduler.get_actor(monitor_id)
        match mon:
            case Some(m):
                check(not m.monitors.contains(target_id))
            case nil:
                fail "monitor actor not found"

describe "ActorScheduler - Statistics":
    it "reports utilization":
        var scheduler = ActorScheduler__default()
        scheduler.spawn_actor(nil)
        scheduler.run_one_timeslice()

        val stats = scheduler.get_stats()
        # With no timing, utilization is 0%
        check(stats.utilization() >= 0.0)

    it "tracks reductions":
        var scheduler = ActorScheduler__default()
        scheduler.spawn_actor(nil)
        scheduler.run_one_timeslice()

        val stats = scheduler.get_stats()
        check(stats.total_reductions_executed == 2000)

describe "ActorScheduler - Display":
    it "formats scheduler for display":
        val scheduler = ActorScheduler__default()
        val str = scheduler.fmt()

        check(str.contains("ActorScheduler"))

    it "formats stats for display":
        val stats = SchedulerStats__new()
        val str = stats.fmt()

        check(str.contains("SchedulerStats"))
