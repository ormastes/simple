# Lazy Value Tests
#
# Tests for lazy evaluation and memoization.

# @skip
use std.spec.{check}
use lazy_val.{
    Lazy,
    LazyState,
    LazyError,
    LazyStats,
    Memo,
    lazy,
    force,
    is_evaluated,
    get_lazy_stats,
    reset_lazy_stats
}

describe "LazyState":
    it "checks pending state":
        val state = LazyState.Pending

        check(state.is_pending())
        check(not state.is_ready())
        check(not state.is_evaluating())

    it "checks ready state":
        val state = LazyState.Ready(42)

        check(state.is_ready())
        check(not state.is_pending())

    it "checks evaluating state":
        val state = LazyState.Evaluating

        check(state.is_evaluating())
        check(not state.is_pending())

    it "checks failed state":
        val state = LazyState.Failed("error")

        check(state.is_failed())
        check(not state.is_ready())

describe "Lazy - Creation":
    it "creates lazy value":
        var computed = false
        val lazy_val = Lazy.new(\:
            computed = true
            42
        )

        check(not computed)
        check(lazy_val.is_pending())

    it "creates already-evaluated value":
        val lazy_val = Lazy.of(42)

        check(lazy_val.is_evaluated())
        check(lazy_val.get() == Some(42))

    it "creates failed value":
        val lazy_val = Lazy.failed("test error")

        check(lazy_val.is_failed())

    it "uses shorthand constructor":
        val lazy_val = lazy(\: 42)

        check(lazy_val.is_pending())

describe "Lazy - Force Evaluation":
    it "forces evaluation":
        var lazy_val = Lazy.new(\: 42)

        val result = lazy_val.force()

        check(result == Ok(42))
        check(lazy_val.is_evaluated())

    it "caches result":
        var call_count = 0
        var lazy_val = Lazy.new(\:
            call_count = call_count + 1
            42
        )

        lazy_val.force()
        lazy_val.force()
        lazy_val.force()

        check(call_count == 1)

    it "returns cached value":
        var lazy_val = Lazy.of(42)

        val r1 = lazy_val.force()
        val r2 = lazy_val.force()

        check(r1 == Ok(42))
        check(r2 == Ok(42))

    it "handles force_or_default":
        var lazy_val = Lazy.new(\: 42)

        val result = lazy_val.force_or_default(0)

        check(result == 42)

    it "uses default on failed value":
        var lazy_val = Lazy.failed("error")

        val result = lazy_val.force_or_default(99)

        check(result == 99)

describe "Lazy - Cycle Detection":
    # Note: Actual cycle detection requires self-referential lazy values
    # which are tricky to set up in tests. This tests the mechanism.

    it "detects evaluation state":
        val lazy_val = Lazy.new(\: 42)

        check(not lazy_val.state.is_evaluating())

describe "Lazy - Queries":
    it "checks is_evaluated":
        var lazy_val = Lazy.new(\: 42)

        check(not lazy_val.is_evaluated())

        lazy_val.force()

        check(lazy_val.is_evaluated())

    it "checks is_pending":
        var lazy_val = Lazy.new(\: 42)

        check(lazy_val.is_pending())

        lazy_val.force()

        check(not lazy_val.is_pending())

    it "gets value without forcing":
        var lazy_val = Lazy.new(\: 42)

        check(lazy_val.get() == nil)

        lazy_val.force()

        check(lazy_val.get() == Some(42))

describe "Lazy - Transformations":
    it "maps lazily":
        var lazy_val = Lazy.new(\: 21)
        val doubled = lazy_val.map(\x: x * 2)

        check(not lazy_val.is_evaluated())
        check(not doubled.is_evaluated())

        var d = doubled
        val result = d.force()

        check(result == Ok(42))

    it "flat_maps lazily":
        var lazy_val = Lazy.new(\: 10)
        val chained = lazy_val.flat_map(\x: Lazy.new(\: x + 5))

        var c = chained
        val result = c.force()

        check(result == Ok(15))

    it "zips two lazy values":
        val lazy1 = Lazy.new(\: 10)
        val lazy2 = Lazy.new(\: 20)

        val zipped = lazy1.zip(lazy2)

        var z = zipped
        val result = z.force()

        check(result == Ok((10, 20)))

    it "filters lazy value":
        val lazy_val = Lazy.new(\: 42)
        val filtered = lazy_val.filter(\x: x > 40)

        var f = filtered
        val result = f.force()

        check(result == Ok(Some(42)))

    it "filters out non-matching":
        val lazy_val = Lazy.new(\: 10)
        val filtered = lazy_val.filter(\x: x > 40)

        var f = filtered
        val result = f.force()

        check(result == Ok(nil))

describe "Lazy - Display":
    it "formats pending":
        val lazy_val = Lazy.new(\: 42)
        check(lazy_val.fmt().contains("pending"))

    it "formats ready":
        var lazy_val = Lazy.of(42)
        check(lazy_val.fmt().contains("ready"))

    it "formats failed":
        val lazy_val = Lazy.failed("error")
        check(lazy_val.fmt().contains("failed"))

describe "Lazy - Statistics":
    it "tracks created count":
        reset_lazy_stats()

        Lazy.new(\: 1)
        Lazy.new(\: 2)
        Lazy.new(\: 3)

        val stats = get_lazy_stats()
        check(stats.total_created >= 3)

    it "tracks forced count":
        reset_lazy_stats()

        var lazy_val = Lazy.new(\: 42)
        lazy_val.force()

        val stats = get_lazy_stats()
        check(stats.total_forced >= 1)

    it "tracks cache hits and misses":
        reset_lazy_stats()

        var lazy_val = Lazy.new(\: 42)
        lazy_val.force()  # Miss
        lazy_val.force()  # Hit
        lazy_val.force()  # Hit

        val stats = get_lazy_stats()
        check(stats.cache_misses >= 1)
        check(stats.cache_hits >= 2)

    it "calculates hit rate":
        reset_lazy_stats()

        var lazy_val = Lazy.new(\: 42)
        lazy_val.force()  # Miss
        lazy_val.force()  # Hit

        val stats = get_lazy_stats()
        check(stats.hit_rate() == 0.5)

describe "LazyError":
    it "formats cycle detected":
        val err = LazyError.CycleDetected
        check(err.message().contains("Cycle"))

    it "formats evaluation failed":
        val err = LazyError.EvaluationFailed("test error")
        check(err.message().contains("test error"))

describe "Memo - Basic Operations":
    it "creates empty memo":
        val memo = Memo.new()

        check(memo.size() == 0)

    it "computes and caches":
        var memo = Memo.new()

        val result = memo.get_or_compute(5, \: 5 * 5)

        check(result == 25)
        check(memo.size() == 1)

    it "returns cached value":
        var memo = Memo.new()
        var call_count = 0

        memo.get_or_compute(5, \:
            call_count = call_count + 1
            25
        )
        memo.get_or_compute(5, \:
            call_count = call_count + 1
            25
        )

        check(call_count == 1)

    it "computes different keys":
        var memo = Memo.new()

        memo.get_or_compute(2, \: 4)
        memo.get_or_compute(3, \: 9)
        memo.get_or_compute(4, \: 16)

        check(memo.size() == 3)
        check(memo.get(2) == Some(4))
        check(memo.get(3) == Some(9))
        check(memo.get(4) == Some(16))

    it "checks containment":
        var memo = Memo.new()

        memo.get_or_compute(5, \: 25)

        check(memo.contains(5))
        check(not memo.contains(10))

    it "clears cache":
        var memo = Memo.new()

        memo.get_or_compute(1, \: 1)
        memo.get_or_compute(2, \: 4)
        memo.clear()

        check(memo.size() == 0)

describe "Memo - Statistics":
    it "tracks lookups":
        var memo = Memo.new()

        memo.get_or_compute(1, \: 1)
        memo.get_or_compute(1, \: 1)
        memo.get_or_compute(2, \: 4)

        val stats = memo.get_stats()
        check(stats.total_lookups == 3)

    it "tracks hits and misses":
        var memo = Memo.new()

        memo.get_or_compute(1, \: 1)  # Miss
        memo.get_or_compute(1, \: 1)  # Hit
        memo.get_or_compute(2, \: 4)  # Miss

        val stats = memo.get_stats()
        check(stats.cache_misses == 2)
        check(stats.cache_hits == 1)

    it "calculates hit rate":
        var memo = Memo.new()

        memo.get_or_compute(1, \: 1)  # Miss
        memo.get_or_compute(1, \: 1)  # Hit
        memo.get_or_compute(1, \: 1)  # Hit

        val stats = memo.get_stats()
        val hit_rate = stats.hit_rate()
        # 2 hits / 3 lookups = 0.666...
        check(hit_rate > 0.6 and hit_rate < 0.7)
