# Lazy Sequence Tests
#
# Tests for lazy/infinite sequences.

# @skip
use std.spec.{check, check_msg}
use app.interpreter.lazy.lazy_seq.{
    LazySeq,
    LazySeqNode,
    SeqIterator,
    naturals,
    naturals_from,
    fibonacci,
    primes,
    repeat,
    cycle,
    range_lazy,
    range_step,
    LazySeq__empty,
    LazySeq__single,
    LazySeq__cons,
    LazySeq__from_array,
    LazySeq__iterate,
    LazySeq__unfold,
    LazySeq__generate,
    LazySeq__repeat_val,
    LazySeq__repeat_n,
    SeqIterator__new
}

describe "LazySeq - Creation":
    it "creates empty sequence":
        val seq = LazySeq__empty()

        check(seq.is_empty())

    it "creates single element":
        val seq = LazySeq__single(42)

        check(not seq.is_empty())
        check(seq.head() == Some(42))
        check(seq.tail().is_empty())

    it "creates from array":
        val seq = LazySeq__from_array([1, 2, 3])

        check(seq.head() == Some(1))
        check(seq.tail().head() == Some(2))
        check(seq.tail().tail().head() == Some(3))

    it "creates with cons":
        val tail = LazySeq__single(2)
        val seq = LazySeq__cons(1, tail)

        check(seq.head() == Some(1))
        check(seq.tail().head() == Some(2))

    it "creates with iterate":
        val seq = LazySeq__iterate(1, \x: x * 2)

        check(seq.head() == Some(1))
        check(seq.tail().head() == Some(2))
        check(seq.tail().tail().head() == Some(4))

    it "creates with unfold":
        val seq = LazySeq__unfold(0, \n:
            if n < 3:
                Some((n * 10, n + 1))
            else:
                nil
        )

        val arr = seq.to_array()
        check(arr == [0, 10, 20])

    it "creates with generate":
        val seq = LazySeq__generate(\i:
            if i < 3:
                Some(i * i)
            else:
                nil
        )

        val arr = seq.to_array()
        check(arr == [0, 1, 4])

    it "creates repeat":
        val seq = LazySeq__repeat_val(5)

        check(seq.take(4).to_array() == [5, 5, 5, 5])

    it "creates repeat_n":
        val seq = LazySeq__repeat_n(7, 3)

        check(seq.to_array() == [7, 7, 7])

describe "LazySeq - Basic Operations":
    it "gets head":
        val seq = LazySeq__from_array([10, 20, 30])

        check(seq.head() == Some(10))

    it "returns None for empty head":
        val seq = LazySeq__empty()

        check(seq.head() == nil)

    it "gets tail":
        val seq = LazySeq__from_array([1, 2, 3])
        val tail = seq.tail()

        check(tail.head() == Some(2))

    it "gets head_tail together":
        val seq = LazySeq__from_array([1, 2, 3])

        match seq.head_tail():
            case Some((h, t)):
                check(h == 1)
                check(t.head() == Some(2))
            case None:
                check(false)

    it "gets nth element":
        val seq = LazySeq__from_array([10, 20, 30, 40, 50])

        check(seq.nth(0) == Some(10))
        check(seq.nth(2) == Some(30))
        check(seq.nth(4) == Some(50))
        check(seq.nth(10) == nil)

describe "LazySeq - Transformations":
    it "maps elements":
        val seq = LazySeq__from_array([1, 2, 3])
        val doubled = seq.map(\x: x * 2)

        check(doubled.to_array() == [2, 4, 6])

    it "filters elements":
        val seq = LazySeq__from_array([1, 2, 3, 4, 5, 6])
        val evens = seq.filter(\x: x % 2 == 0)

        check(evens.to_array() == [2, 4, 6])

    it "flat_maps elements":
        val seq = LazySeq__from_array([1, 2, 3])
        val expanded = seq.flat_map(\x: LazySeq__from_array([x, x * 10]))

        check(expanded.to_array() == [1, 10, 2, 20, 3, 30])

    it "takes first n elements":
        val seq = naturals()
        val first5 = seq.take(5)

        check(first5.to_array() == [0, 1, 2, 3, 4])

    it "drops first n elements":
        val seq = LazySeq__from_array([1, 2, 3, 4, 5])
        val dropped = seq.drop(2)

        check(dropped.to_array() == [3, 4, 5])

    it "takes while predicate":
        val seq = LazySeq__from_array([1, 2, 3, 10, 4, 5])
        val small = seq.take_while(\x: x < 5)

        check(small.to_array() == [1, 2, 3])

    it "drops while predicate":
        val seq = LazySeq__from_array([1, 2, 3, 10, 4, 5])
        val rest = seq.drop_while(\x: x < 5)

        check(rest.to_array() == [10, 4, 5])

    it "zips two sequences":
        val seq1 = LazySeq__from_array([1, 2, 3])
        val seq2 = LazySeq__from_array(["a", "b", "c"])
        val zipped = seq1.zip(seq2)

        check(zipped.to_array() == [(1, "a"), (2, "b"), (3, "c")])

    it "zips with shorter sequence":
        val seq1 = LazySeq__from_array([1, 2, 3, 4, 5])
        val seq2 = LazySeq__from_array(["a", "b"])
        val zipped = seq1.zip(seq2)

        check(zipped.to_array() == [(1, "a"), (2, "b")])

    it "zips with index":
        val seq = LazySeq__from_array(["a", "b", "c"])
        val indexed = seq.zip_with_index()

        val arr = indexed.take(3).to_array()
        check(arr == [("a", 0), ("b", 1), ("c", 2)])

    it "concatenates sequences":
        val seq1 = LazySeq__from_array([1, 2])
        val seq2 = LazySeq__from_array([3, 4])
        val concat = seq1.concat(seq2)

        check(concat.to_array() == [1, 2, 3, 4])

    it "interleaves sequences":
        val seq1 = LazySeq__from_array([1, 3, 5])
        val seq2 = LazySeq__from_array([2, 4, 6])
        val interleaved = seq1.interleave(seq2)

        check(interleaved.to_array() == [1, 2, 3, 4, 5, 6])

describe "LazySeq - Terminal Operations":
    it "converts to array":
        val seq = LazySeq__from_array([1, 2, 3])

        check(seq.to_array() == [1, 2, 3])

    it "converts to array with limit":
        val seq = naturals()

        check(seq.to_array_n(5) == [0, 1, 2, 3, 4])

    it "folds elements":
        val seq = LazySeq__from_array([1, 2, 3, 4])
        val sum = seq.fold(0, \acc, x: acc + x)

        check(sum == 10)

    it "reduces elements":
        val seq = LazySeq__from_array([1, 2, 3, 4])
        val product = seq.reduce(\a, b: a * b)

        check(product == Some(24))

    it "reduces empty sequence":
        val seq = LazySeq__empty()
        val result = seq.reduce(\a, b: a + b)

        check(result == nil)

    it "finds element":
        val seq = LazySeq__from_array([1, 5, 10, 15, 20])
        val found = seq.find(\x: x > 8)

        check(found == Some(10))

    it "finds nothing":
        val seq = LazySeq__from_array([1, 2, 3])
        val found = seq.find(\x: x > 100)

        check(found == nil)

    it "checks any":
        val seq = LazySeq__from_array([1, 2, 3, 4, 5])

        check(seq.any(\x: x == 3))
        check(not seq.any(\x: x == 10))

    it "checks all":
        val seq = LazySeq__from_array([2, 4, 6, 8])

        check(seq.all(\x: x % 2 == 0))
        check(not seq.all(\x: x < 5))

    it "counts elements":
        val seq = LazySeq__from_array([1, 2, 3, 4, 5])

        check(seq.count() == 5)

    it "checks contains":
        val seq = LazySeq__from_array([1, 2, 3])

        check(seq.contains(2))
        check(not seq.contains(10))

describe "LazySeq - Laziness":
    it "doesn't evaluate until needed":
        var evaluated = false
        val seq = LazySeq__iterate(0, \x:
            evaluated = true
            x + 1
        )

        check(not evaluated) # Just creating doesn't evaluate

        seq.head()  # Force first element
        # First element is seed, so still no evaluation needed

    it "evaluates incrementally":
        var count = 0
        val seq = LazySeq__generate(\i:
            count = count + 1
            if i < 100:
                Some(i)
            else:
                nil
        )

        # Take only 3
        val first3 = seq.take(3).to_array()

        check(first3 == [0, 1, 2])
        check(count == 4) # One extra to check for end

describe "Standard Sequences - Naturals":
    it "generates natural numbers":
        val first10 = naturals().take(10).to_array()

        check(first10 == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

    it "generates from starting point":
        val first5 = naturals_from(100).take(5).to_array()

        check(first5 == [100, 101, 102, 103, 104])

describe "Standard Sequences - Fibonacci":
    it "generates fibonacci numbers":
        val first10 = fibonacci().take(10).to_array()

        check(first10 == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34])

describe "Standard Sequences - Primes":
    it "generates prime numbers":
        val first10 = primes().take(10).to_array()

        check(first10 == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29])

describe "Standard Sequences - Repeat":
    it "repeats value infinitely":
        val first5 = repeat(42).take(5).to_array()

        check(first5 == [42, 42, 42, 42, 42])

describe "Standard Sequences - Cycle":
    it "cycles through array":
        val first8 = cycle([1, 2, 3]).take(8).to_array()

        check(first8 == [1, 2, 3, 1, 2, 3, 1, 2])

    it "handles empty array":
        val seq = cycle([])

        check(seq.is_empty())

describe "Standard Sequences - Range":
    it "creates lazy range":
        val seq = range_lazy(0, 5)

        check(seq.to_array() == [0, 1, 2, 3, 4])

    it "creates empty range":
        val seq = range_lazy(5, 5)

        check(seq.is_empty())

    it "creates range with step":
        val seq = range_step(0, 10, 2)

        check(seq.to_array() == [0, 2, 4, 6, 8])

    it "creates reverse range":
        val seq = range_step(10, 0, -2)

        check(seq.to_array() == [10, 8, 6, 4, 2])

describe "SeqIterator":
    it "iterates over sequence":
        val seq = LazySeq__from_array([1, 2, 3])
        var iter = SeqIterator__new(seq)

        check(iter.has_next())
        check(iter.next() == Some(1))
        check(iter.next() == Some(2))
        check(iter.next() == Some(3))
        check(not iter.has_next())
        check(iter.next() == nil)

describe "LazySeq - Complex Examples":
    it "finds first 5 primes greater than 100":
        val result = primes()
            .filter(\p: p > 100)
            .take(5)
            .to_array()

        check(result == [101, 103, 107, 109, 113])

    it "computes sum of first 100 naturals":
        val sum = naturals()
            .take(101)  # 0 to 100
            .fold(0, \acc, x: acc + x)

        check(sum == 5050)

    it "finds first fibonacci > 1000":
        val result = fibonacci()
            .find(\x: x > 1000)

        check(result == Some(1597))

    it "generates pairs":
        val pairs = naturals()
            .take(3)
            .flat_map(\x:
                naturals().take(3).map(\y: (x, y))
            )
            .to_array()

        check(pairs == [
            (0, 0), (0, 1), (0, 2),
            (1, 0), (1, 1), (1, 2),
            (2, 0), (2, 1), (2, 2)
        ])

    it "composes multiple transformations":
        val result = naturals()
            .map(\x: x * x)       # Squares
            .filter(\x: x % 2 == 0)  # Even squares
            .take(5)
            .to_array()

        check(result == [0, 4, 16, 36, 64])
