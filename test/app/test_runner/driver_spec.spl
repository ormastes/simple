# Test Runner Driver Module Tests
#
# Tests for configuration, argument parsing, and test runner.

fn main():
    print "=================================================="
    print "      Test Runner Driver Module Tests"
    print "=================================================="
    print ""

    var passed = 0
    var failed = 0

    # =========================================================================
    # Config Tests
    # =========================================================================

    if test_config_default():
        print "[PASS] RunConfig default values"
        passed = passed + 1
    else:
        print "[FAIL] RunConfig default values"
        failed = failed + 1

    if test_config_qemu():
        print "[PASS] RunConfig QEMU creation"
        passed = passed + 1
    else:
        print "[FAIL] RunConfig QEMU creation"
        failed = failed + 1

    if test_config_validation_empty():
        print "[PASS] Config validation requires binary"
        passed = passed + 1
    else:
        print "[FAIL] Config validation requires binary"
        failed = failed + 1

    if test_config_validation_valid():
        print "[PASS] Config validation passes with binary"
        passed = passed + 1
    else:
        print "[FAIL] Config validation passes with binary"
        failed = failed + 1

    # =========================================================================
    # ArgParser Tests
    # =========================================================================

    if test_argparser_empty():
        print "[PASS] ArgParser with no args"
        passed = passed + 1
    else:
        print "[FAIL] ArgParser with no args"
        failed = failed + 1

    if test_argparser_binary():
        print "[PASS] ArgParser with binary path"
        passed = passed + 1
    else:
        print "[FAIL] ArgParser with binary path"
        failed = failed + 1

    if test_argparser_verbose():
        print "[PASS] ArgParser with --verbose"
        passed = passed + 1
    else:
        print "[FAIL] ArgParser with --verbose"
        failed = failed + 1

    if test_argparser_arch():
        print "[PASS] ArgParser with --arch"
        passed = passed + 1
    else:
        print "[FAIL] ArgParser with --arch"
        failed = failed + 1

    if test_argparser_combined():
        print "[PASS] ArgParser with multiple options"
        passed = passed + 1
    else:
        print "[FAIL] ArgParser with multiple options"
        failed = failed + 1

    # =========================================================================
    # TestRunner Tests
    # =========================================================================

    if test_runner_creation():
        print "[PASS] TestRunner creation"
        passed = passed + 1
    else:
        print "[FAIL] TestRunner creation"
        failed = failed + 1

    if test_runner_no_binary():
        print "[PASS] TestRunner fails without binary"
        passed = passed + 1
    else:
        print "[FAIL] TestRunner fails without binary"
        failed = failed + 1

    if test_runner_with_binary():
        print "[PASS] TestRunner runs with binary"
        passed = passed + 1
    else:
        print "[FAIL] TestRunner runs with binary"
        failed = failed + 1

    # =========================================================================
    # Summary
    # =========================================================================

    print ""
    print "=================================================="
    print "  Summary: {passed}/{passed + failed} passed, {failed} failed"
    print "=================================================="

    if failed == 0:
        print "ALL TESTS PASSED"
    else:
        print "SOME TESTS FAILED"

# =========================================================================
# Config Test Implementations
# =========================================================================

fn test_config_default() -> bool:
    val config = RunConfig_default()
    val ok1 = config.loader_type == 0
    val ok2 = config.target_arch == "x86"
    val ok3 = config.binary_path == ""
    val ok4 = config.timeout_ms == 30000
    ok1 and ok2 and ok3 and ok4

fn test_config_qemu() -> bool:
    val config = RunConfig_qemu("test.elf", "arm")
    val ok1 = config.loader_type == 0
    val ok2 = config.binary_path == "test.elf"
    val ok3 = config.target_arch == "arm"
    ok1 and ok2 and ok3

fn test_config_validation_empty() -> bool:
    val config = RunConfig_default()
    val errors = validate_config(config)
    errors.len() > 0

fn test_config_validation_valid() -> bool:
    val config = RunConfig_qemu("test.elf", "x86")
    val errors = validate_config(config)
    errors.len() == 0

# =========================================================================
# ArgParser Test Implementations
# =========================================================================

fn test_argparser_empty() -> bool:
    var args: [text] = []
    var parser = ArgParser_create(args)
    val config = parser.parse()
    config.binary_path == ""

fn test_argparser_binary() -> bool:
    val args: [text] = ["test.elf"]
    var parser = ArgParser_create(args)
    val config = parser.parse()
    config.binary_path == "test.elf"

fn test_argparser_verbose() -> bool:
    val args: [text] = ["--verbose", "test.elf"]
    var parser = ArgParser_create(args)
    val config = parser.parse()
    config.verbose and config.binary_path == "test.elf"

fn test_argparser_arch() -> bool:
    val args: [text] = ["--arch", "arm", "test.elf"]
    var parser = ArgParser_create(args)
    val config = parser.parse()
    config.target_arch == "arm" and config.binary_path == "test.elf"

fn test_argparser_combined() -> bool:
    val args: [text] = ["--verbose", "--arch", "riscv32", "firmware.elf"]
    var parser = ArgParser_create(args)
    val config = parser.parse()
    config.verbose and config.target_arch == "riscv32" and config.binary_path == "firmware.elf"

# =========================================================================
# TestRunner Test Implementations
# =========================================================================

fn test_runner_creation() -> bool:
    val config = RunConfig_qemu("test.elf", "x86")
    val runner = TestRunner_create(config)
    not runner.started and not runner.completed

fn test_runner_no_binary() -> bool:
    val config = RunConfig_default()
    var runner = TestRunner_create(config)
    val result = runner.run()
    result == 1  # Should fail

fn test_runner_with_binary() -> bool:
    val config = RunConfig_qemu("test.elf", "x86")
    var runner = TestRunner_create(config)
    val result = runner.run()
    result == 0  # Should succeed (simulated)

# =========================================================================
# Type Definitions
# =========================================================================

class RunConfig:
    loader_type: i32
    target_arch: text
    binary_path: text
    transport_type: i32
    transport_path: text
    timeout_ms: i64
    test_timeout_ms: i64
    format_type: i32
    color_output: bool
    verbose: bool
    smf_root: text
    extra_args: text

fn RunConfig_default() -> RunConfig:
    RunConfig(
        loader_type: 0,
        target_arch: "x86",
        binary_path: "",
        transport_type: 0,
        transport_path: "",
        timeout_ms: 30000,
        test_timeout_ms: 5000,
        format_type: 0,
        color_output: true,
        verbose: false,
        smf_root: "",
        extra_args: ""
    )

fn RunConfig_qemu(binary: text, arch: text) -> RunConfig:
    var config = RunConfig_default()
    config.binary_path = binary
    config.target_arch = arch
    config

impl RunConfig:
    fn has_smf() -> bool:
        self.smf_root != ""

fn validate_config(config: RunConfig) -> [text]:
    var errors: [text] = []
    if config.binary_path == "":
        errors.push("Binary path is required")
    errors

class ArgParser:
    args: [text]
    index: i32
    config: RunConfig
    errors: [text]

fn ArgParser_create(args: [text]) -> ArgParser:
    ArgParser(args: args, index: 0, config: RunConfig_default(), errors: [])

impl ArgParser:
    fn has_next() -> bool:
        self.index < self.args.len() as i32

    me next() -> text:
        if self.has_next():
            val arg = self.args[self.index]
            self.index = self.index + 1
            arg
        else:
            ""

    me parse() -> RunConfig:
        while self.has_next():
            val arg = self.next()
            if arg == "--verbose" or arg == "-v":
                self.config.verbose = true
            elif arg == "--arch" or arg == "-a":
                self.config.target_arch = self.next()
            elif arg == "--binary" or arg == "-b":
                self.config.binary_path = self.next()
            elif arg.starts_with("-"):
                self.errors.push("Unknown: {arg}")
            else:
                if self.config.binary_path == "":
                    self.config.binary_path = arg
        self.config

    fn has_errors() -> bool:
        self.errors.len() > 0

# From host modules (simplified)
class LoaderConfig:
    loader_type: i32
    binary_path: text
    target_arch: text
    timeout_ms: i64
    extra_args: text

class LoaderResult:
    success: bool
    process_id: i32
    transport_path: text
    error_message: text

fn LoaderResult_failure(msg: text) -> LoaderResult:
    LoaderResult(success: false, process_id: 0, transport_path: "", error_message: msg)

fn LoaderResult_success(pid: i32, transport: text) -> LoaderResult:
    LoaderResult(success: true, process_id: pid, transport_path: transport, error_message: "")

class Loader:
    config: LoaderConfig
    result: LoaderResult
    running: bool

fn Loader_create(config: LoaderConfig) -> Loader:
    Loader(config: config, result: LoaderResult_failure("Not started"), running: false)

impl Loader:
    me start() -> LoaderResult:
        if self.config.binary_path == "":
            self.result = LoaderResult_failure("No binary path")
        else:
            self.result = LoaderResult_success(12345, "stdio")
            self.running = true
        self.result

    me stop():
        self.running = false

class TransportConfig:
    transport_type: i32
    path: text
    baudrate: i32
    timeout_ms: i64

class Transport:
    config: TransportConfig
    buffer: [i32]
    connected: bool
    error: text

fn Transport_create(config: TransportConfig) -> Transport:
    Transport(config: config, buffer: [], connected: false, error: "")

impl Transport:
    me connect() -> bool:
        self.connected = true
        true

    me disconnect():
        self.connected = false

    fn get_error() -> text:
        self.error

class StringInternTable:
    entries: [StringInternEntry]
    next_handle: i32

class StringInternEntry:
    handle: i32
    value: text

fn StringInternTable_empty() -> StringInternTable:
    StringInternTable(entries: [], next_handle: 1)

class TestResults:
    total: i32
    passed: i32
    failed: i32
    skipped: i32
    timeout: i32
    crashed: i32
    duration_ms: i64
    start_time_ms: i64
    end_time_ms: i64

fn TestResults_empty() -> TestResults:
    TestResults(total: 0, passed: 0, failed: 0, skipped: 0, timeout: 0, crashed: 0, duration_ms: 0, start_time_ms: 0, end_time_ms: 0)

impl TestResults:
    fn is_success() -> bool:
        self.failed == 0 and self.timeout == 0 and self.crashed == 0

class HostParser:
    buffer: [i32]
    string_table: StringInternTable
    results: TestResults
    current_suite: text
    verbose: bool

fn HostParser_create() -> HostParser:
    HostParser(buffer: [], string_table: StringInternTable_empty(), results: TestResults_empty(), current_suite: "", verbose: false)

fn HostParser_verbose() -> HostParser:
    HostParser(buffer: [], string_table: StringInternTable_empty(), results: TestResults_empty(), current_suite: "", verbose: true)

impl HostParser:
    fn is_success() -> bool:
        self.results.is_success()

    fn get_results() -> TestResults:
        self.results

class TestRunner:
    config: RunConfig
    loader: Loader
    transport: Transport
    parser: HostParser
    started: bool
    completed: bool

fn TestRunner_create(config: RunConfig) -> TestRunner:
    val loader_config = LoaderConfig(
        loader_type: config.loader_type,
        binary_path: config.binary_path,
        target_arch: config.target_arch,
        timeout_ms: config.timeout_ms,
        extra_args: config.extra_args
    )
    val transport_config = TransportConfig(
        transport_type: config.transport_type,
        path: config.transport_path,
        baudrate: 115200,
        timeout_ms: config.timeout_ms
    )
    val loader = Loader_create(loader_config)
    val transport = Transport_create(transport_config)
    val parser = if config.verbose: HostParser_verbose() else: HostParser_create()

    TestRunner(
        config: config,
        loader: loader,
        transport: transport,
        parser: parser,
        started: false,
        completed: false
    )

impl TestRunner:
    me run() -> i32:
        val errors = validate_config(self.config)
        if errors.len() > 0:
            return 1

        val loader_result = self.loader.start()
        if not loader_result.success:
            return 1

        self.started = true

        if not self.transport.connect():
            self.loader.stop()
            return 1

        self.completed = true
        self.transport.disconnect()
        self.loader.stop()

        if self.parser.is_success():
            0
        else:
            1
