# @Feature 703.1: Simple linter
# @Description: Test the Simple language linter

# NOTE: describe, it, expect are built-in - no imports needed

describe "Linter - code quality checks":
    it "validates variable naming conventions":
        # Variables should use snake_case
        val good_name = "valid_variable"
        val bad_name = "InvalidCamelCase"

        # Test that snake_case is valid
        expect good_name.contains("_")
        expect not bad_name.contains("_")

    it "validates function naming conventions":
        # Functions should use snake_case
        fn valid_function_name() -> bool:
            true

        fn InvalidFunctionName() -> bool:
            false

        expect valid_function_name()
        expect not InvalidFunctionName()

    it "validates class naming conventions":
        # Classes should use PascalCase
        class ValidClassName:
            value: i64

        class invalid_class_name:
            value: i64

        val good_class = ValidClassName(value: 1)
        val bad_class = invalid_class_name(value: 2)

        expect good_class.value == 1
        expect bad_class.value == 2

describe "Linter - code patterns":
    it "detects unused variable declarations":
        # This would normally be flagged by linter
        var unused_var = 42
        var used_var = 10

        # Using used_var
        val result = used_var * 2
        expect result == 20

    it "detects missing return type annotations":
        # Function without explicit return type
        fn no_return_type(x):
            x * 2

        # Function with explicit return type
        fn with_return_type(x: i64) -> i64:
            x * 2

        expect no_return_type(5) == 10
        expect with_return_type(5) == 10

    it "validates error handling patterns":
        # Functions that can fail should return Result
        fn may_fail(x: i64) -> Result<i64, text>:
            if x < 0:
                Err("Negative value")
            else:
                Ok(x * 2)

        val result = may_fail(5)
        match result:
            case Ok(value):
                expect value == 10
            case Err(msg):
                expect false  # Shouldn't reach here

describe "Linter - best practices":
    it "prefers val over var when possible":
        # Immutable by default
        val immutable = 42
        var mutable = 10

        # Can reassign mutable
        mutable = mutable + 5
        expect mutable == 15

        # Cannot reassign immutable (would be caught by linter)
        expect immutable == 42

    it "validates proper use of Option types":
        # Functions returning optional values
        fn find_value(arr: [i64], target: i64) -> Option<i64>:
            for item in arr:
                if item == target:
                    return Some(item)
            None

        val result = find_value([1, 2, 3], 2)
        match result:
            case Some(v):
                expect v == 2
            case None:
                expect false

    it "validates match exhaustiveness":
        # All cases should be covered
        enum Color:
            Red
            Green
            Blue

        fn describe_color(c: Color) -> text:
            match c:
                case Color.Red:
                    "red"
                case Color.Green:
                    "green"
                case Color.Blue:
                    "blue"

        val desc = describe_color(Color.Red)
        expect desc == "red"

describe "Linter - performance hints":
    it "suggests using iterators over loops":
        # Less efficient: manual loop
        var sum1 = 0
        for i in [1, 2, 3, 4, 5]:
            sum1 = sum1 + i

        # More efficient: using iterator methods
        val sum2 = [1, 2, 3, 4, 5].sum()

        expect sum1 == 15
        expect sum2 == 15

    it "suggests const for compile-time constants":
        # Should be const, not val
        val PI_VAL = 3.14159
        const PI_CONST = 3.14159

        expect PI_VAL > 3.0
        expect PI_CONST > 3.0
