# @Feature 702: Simple Formatter - Comprehensive Tests
# @Description: Test all formatter functionality for branch coverage

# Import formatter implementation
use app.formatter.main.*

# Test FormatConfig creation and configuration
describe "FormatConfig":
    it "creates default configuration":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        expect config.indent_size == 4
        expect config.max_line_length == 100
        expect config.use_tabs == false
        expect config.blank_lines_between_items == 2
        expect config.continuation_indent == 8

    it "creates custom configuration":
        val config = FormatConfig(
            indent_size: 2,
            max_line_length: 80,
            use_tabs: true,
            blank_lines_between_items: 1,
            continuation_indent: 4
        )
        expect config.indent_size == 2
        expect config.max_line_length == 80
        expect config.use_tabs == true
        expect config.blank_lines_between_items == 1
        expect config.continuation_indent == 4

# Test Formatter creation
describe "Formatter creation":
    it "creates formatter with default config":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.indent_level == 0

    it "creates formatter with custom config":
        val config = FormatConfig(
            indent_size: 2,
            max_line_length: 80,
            use_tabs: false,
            blank_lines_between_items: 1,
            continuation_indent: 4
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.config.indent_size == 2

# Test leading space counting
describe "count_leading_spaces":
    it "counts spaces in indented line":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val count = formatter.count_leading_spaces("    hello")
        expect count == 4

    it "returns 0 for no leading spaces":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val count = formatter.count_leading_spaces("hello")
        expect count == 0

    it "counts large indentation":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val count = formatter.count_leading_spaces("        hello")
        expect count == 8

    it "handles empty string":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val count = formatter.count_leading_spaces("")
        expect count == 0

# Test definition line detection
describe "is_definition":
    it "detects function definition":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_definition("fn foo():")
        expect formatter.is_definition("    fn bar():")

    it "detects class definition":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_definition("class Foo:")
        expect formatter.is_definition("    class Bar:")

    it "detects struct definition":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_definition("struct Point:")

    it "detects enum definition":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_definition("enum Color:")

    it "detects impl definition":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_definition("impl MyClass:")

    it "rejects non-definitions":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect not formatter.is_definition("val x = 5")
        expect not formatter.is_definition("    print hello")

# Test indent/dedent line detection
describe "is_indent_line":
    it "detects if statement":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_indent_line("if x > 0:")
        expect formatter.is_indent_line("    if y < 10:")

    it "detects for loop":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_indent_line("for item in items:")

    it "detects while loop":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_indent_line("while condition:")

    it "detects match statement":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_indent_line("match value:")

    it "detects function definition":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_indent_line("fn test():")

    it "detects class definition":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_indent_line("class Foo:")

    it "rejects non-indent lines":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect not formatter.is_indent_line("val x = 5")
        expect not formatter.is_indent_line("return 42")

describe "is_dedent_line":
    it "detects else":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_dedent_line("else:")
        expect formatter.is_dedent_line("    else:")

    it "detects elif":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_dedent_line("elif x > 5:")

    it "detects case":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_dedent_line("case Some(x):")

    it "rejects non-dedent lines":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect not formatter.is_dedent_line("val x = 5")
        expect not formatter.is_dedent_line("if x > 0:")

# Test method chain detection
describe "is_method_chain":
    it "detects method chain with dot":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_method_chain("obj.method1().method2()")

    it "detects single method call as chain":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_method_chain("obj.method()")

    it "rejects non-chain lines":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect not formatter.is_method_chain("val x = 5")

    it "rejects lines without dots":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect not formatter.is_method_chain("function(arg)")

# Test expression spacing
describe "add_expression_spacing":
    it "adds spaces around plus operator":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.add_expression_spacing("x+y")
        expect result == "x + y"

    it "adds spaces around minus operator":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.add_expression_spacing("x-y")
        expect result == "x - y"

    it "adds spaces around multiply operator":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.add_expression_spacing("x*y")
        expect result == "x * y"

    it "adds spaces around division operator":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.add_expression_spacing("x/y")
        expect result == "x / y"

    it "adds spaces around equality operator":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.add_expression_spacing("x==y")
        expect result == "x == y"

    it "adds spaces around assignment operator":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.add_expression_spacing("x=y")
        expect result == "x = y"

    it "adds spaces around comparison operators":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.add_expression_spacing("x<y") == "x < y"
        expect formatter.add_expression_spacing("x>y") == "x > y"
        expect formatter.add_expression_spacing("x<=y") == "x <= y"
        expect formatter.add_expression_spacing("x>=y") == "x >= y"

    it "preserves already-spaced expressions":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.add_expression_spacing("x + y")
        expect result == "x + y"

    it "handles multiple operators":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.add_expression_spacing("x+y*z")
        expect result == "x + y * z"

    it "preserves spaces in strings":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.add_expression_spacing("\"hello+world\"")
        # Should not add spaces inside strings
        expect result.contains("hello+world")

# Test comma fixing
describe "fix_missing_commas":
    it "fixes missing commas in arrays":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.fix_missing_commas("[1 2 3]")
        expect result.contains(",")

    it "fixes missing commas in function params":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.fix_missing_commas("fn test(a: Int b: Int):")
        expect result.contains(",")

    it "preserves existing commas":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.fix_missing_commas("[1, 2, 3]")
        expect result == "[1, 2, 3]"

# Test source formatting (integration)
describe "format_source":
    it "formats simple code":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val source = "val x=5"
        val result = formatter.format_source(source)
        match result:
            case Ok(formatted):
                expect formatted.contains("x = 5")
            case Err(e):
                expect false

    it "sorts imports alphabetically":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val source = "import z\nimport a\nimport m"
        val result = formatter.format_source(source)
        match result:
            case Ok(formatted):
                # First import should be 'a' after sorting
                val lines = formatted.split("\n")
                expect lines[0].contains("import a")
            case Err(e):
                expect false

    it "removes blank lines in import section":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val source = "import a\n\nimport b\n\nval x = 5"
        val result = formatter.format_source(source)
        match result:
            case Ok(formatted):
                # Should not have extra blank lines between imports
                expect not formatted.contains("import a\n\nimport b")
            case Err(e):
                expect false

    it "handles code with no imports":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val source = "val x = 5\nval y = 10"
        val result = formatter.format_source(source)
        match result:
            case Ok(formatted):
                expect formatted.contains("x = 5")
            case Err(e):
                expect false

    it "handles empty source":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val source = ""
        val result = formatter.format_source(source)
        match result:
            case Ok(formatted):
                expect formatted.len() >= 0
            case Err(e):
                expect false

# Test indentation fixing
describe "fix_indentation":
    it "fixes inconsistent indentation":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val source = "  val x = 5\n    val y = 10"
        val result = formatter.fix_indentation(source)
        # Should normalize indentation
        expect result.len() > 0

    it "handles already-correct indentation":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val source = "val x = 5\n    val y = 10"
        val result = formatter.fix_indentation(source)
        expect result.contains("val x")

    it "fixes excessive indentation":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val source = "        val x = 5"
        val result = formatter.fix_indentation(source)
        # Should reduce excessive indentation
        expect result.len() > 0

# Test trailing comma removal
describe "remove_trailing_comma":
    it "removes trailing comma from last line":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val lines = ["item1,", "item2,"]
        val result = formatter.remove_trailing_comma(lines)
        expect result[1] == "item2"

    it "preserves non-trailing commas":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val lines = ["item1,", "item2"]
        val result = formatter.remove_trailing_comma(lines)
        expect result[0] == "item1,"

    it "handles empty list":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val lines: [String] = []
        val result = formatter.remove_trailing_comma(lines)
        expect result.len() == 0

    it "handles single item":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val lines = ["item1,"]
        val result = formatter.remove_trailing_comma(lines)
        expect result[0] == "item1"

# Test long line breaking
describe "break_long_line":
    it "breaks method chains":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val line = "obj.method1().method2().method3()"
        val result = formatter.break_long_line(line, 0)
        expect result.len() > 1

    it "breaks function signatures":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val line = "fn long_function_name(param1: Int, param2: String) -> Result"
        val result = formatter.break_long_line(line, 0)
        # Should break long function signature
        expect result.len() >= 1

    it "breaks function calls":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val line = "function(arg1, arg2, arg3)"
        val result = formatter.break_long_line(line, 0)
        expect result.len() >= 1

    it "breaks collection literals":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val line = "[1, 2, 3, 4, 5]"
        val result = formatter.break_long_line(line, 0)
        expect result.len() >= 1

    it "breaks at operators for other lines":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val line = "val x = a + b + c + d"
        val result = formatter.break_long_line(line, 0)
        expect result.len() >= 1

    it "respects base indentation":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val line = "obj.method1().method2()"
        val result = formatter.break_long_line(line, 2)
        # Should have indentation
        expect result[0].starts_with(" ")

# Test method chain breaking
describe "break_method_chain":
    it "breaks chain into multiple lines":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val line = "obj.method1().method2().method3()"
        val result = formatter.break_method_chain(line, "", "    ")
        expect result.len() == 4  # obj + 3 methods

    it "preserves first part without dot":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val line = "obj.method()"
        val result = formatter.break_method_chain(line, "", "    ")
        expect not result[0].contains(".")

    it "adds dots to continuation lines":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val line = "obj.method1().method2()"
        val result = formatter.break_method_chain(line, "", "    ")
        expect result[1].contains(".")
        expect result[2].contains(".")

    it "handles single method call":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val line = "obj.method()"
        val result = formatter.break_method_chain(line, "", "    ")
        expect result.len() == 2

# Test method chain detection (extended)
describe "is_method_chain extended":
    it "detects chains with 2 dots":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_method_chain("a.b.c")

    it "detects chains with 3 dots":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect formatter.is_method_chain("a.b.c.d")

    it "rejects single dot (not a chain)":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect not formatter.is_method_chain("obj.method()")

    it "rejects no dots":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        expect not formatter.is_method_chain("function()")

# Test comma fixing methods
describe "fix_array_commas":
    it "adds commas between array elements":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.fix_array_commas("[1 2 3]")
        expect result.contains(",")

    it "preserves existing commas in arrays":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.fix_array_commas("[1, 2, 3]")
        expect result == "[1, 2, 3]"

describe "fix_dict_commas":
    it "adds commas between dict entries":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.fix_dict_commas(r"{a: 1 b: 2}")
        expect result.contains(",")

    it "preserves existing commas in dicts":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.fix_dict_commas(r"{a: 1, b: 2}")
        expect result == r"{a: 1, b: 2}"

describe "fix_param_commas":
    it "adds commas between parameters":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.fix_param_commas("fn test(a: Int b: Int):")
        expect result.contains(",")

    it "preserves existing parameter commas":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.fix_param_commas("fn test(a: Int, b: Int):")
        expect result == "fn test(a: Int, b: Int):"

# Test edge cases
describe "formatter edge cases":
    it "handles very long lines":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val long_line = "val x = very_long_function_name(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)"
        val result = formatter.break_long_line(long_line, 0)
        expect result.len() >= 1

    it "handles lines with unicode":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val result = formatter.add_expression_spacing("x+y")
        expect result.contains(" ")

    it "handles nested structures":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val nested = "[[1, 2], [3, 4]]"
        val result = formatter.break_long_line(nested, 0)
        expect result.len() >= 1

    it "handles mixed quotes":
        val config = FormatConfig(
            indent_size: 4,
            max_line_length: 100,
            use_tabs: false,
            blank_lines_between_items: 2,
            continuation_indent: 8
        )
        val formatter = Formatter(config: config, indent_level: 0)
        val source = "val s = \"hello 'world'\""
        val result = formatter.format_source(source)
        match result:
            case Ok(formatted):
                expect formatted.len() > 0
            case Err(e):
                expect false
