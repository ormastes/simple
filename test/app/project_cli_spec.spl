# Project CLI Commands - SSpec Tests
# Tests for: init, env, query, qualify-ignore

use std.spec.{check, check_msg}

extern fn rt_file_exists(path: text) -> bool
use std.spec.{check, check_msg}

extern fn rt_file_read_text(path: text) -> text
use std.spec.{check, check_msg}

extern fn rt_file_write_text(path: text, content: text) -> bool
use std.spec.{check, check_msg}

extern fn rt_dir_create(path: text, recursive: bool) -> bool
use std.spec.{check, check_msg}

extern fn rt_package_remove_dir_all(path: text) -> i32
use std.spec.{check, check_msg}

extern fn rt_package_is_dir(path: text) -> i32

use std.spec.{check, check_msg}

val test_dir = "/tmp/simple-test-project-cli"

use std.spec.{check, check_msg}

fn cleanup():
use std.spec.{check, check_msg}

    rt_package_remove_dir_all(test_dir)

use std.spec.{check, check_msg}

describe "Project CLI - init command":
use std.spec.{check, check_msg}

    before_each:
use std.spec.{check, check_msg}

        cleanup()
use std.spec.{check, check_msg}

        rt_dir_create(test_dir, true)
use std.spec.{check, check_msg}

    after_each:
use std.spec.{check, check_msg}

        cleanup()

use std.spec.{check, check_msg}

    it "creates simple.sdn manifest":
use std.spec.{check, check_msg}

        # Init should create a manifest file
use std.spec.{check, check_msg}

        val manifest = "package:\n  name: test-project\n  version: 0.1.0\n  license: MIT\n  main: src/main.spl\n"
use std.spec.{check, check_msg}

        rt_file_write_text("{test_dir}/simple.sdn", manifest)
use std.spec.{check, check_msg}

        check(rt_file_exists("{test_dir}/simple.sdn"))

use std.spec.{check, check_msg}

    it "creates src directory":
use std.spec.{check, check_msg}

        rt_dir_create("{test_dir}/src", true)
use std.spec.{check, check_msg}

        check(rt_package_is_dir("{test_dir}/src") == 1)

use std.spec.{check, check_msg}

    it "creates test directory":
use std.spec.{check, check_msg}

        rt_dir_create("{test_dir}/test", true)
use std.spec.{check, check_msg}

        check(rt_package_is_dir("{test_dir}/test") == 1)

use std.spec.{check, check_msg}

    it "refuses to init if simple.sdn exists":
use std.spec.{check, check_msg}

        rt_file_write_text("{test_dir}/simple.sdn", "existing")
use std.spec.{check, check_msg}

        check(rt_file_exists("{test_dir}/simple.sdn"))

use std.spec.{check, check_msg}

describe "Project CLI - env command":
use std.spec.{check, check_msg}

    before_each:
use std.spec.{check, check_msg}

        cleanup()
use std.spec.{check, check_msg}

        rt_dir_create(test_dir, true)
use std.spec.{check, check_msg}

    after_each:
use std.spec.{check, check_msg}

        cleanup()

use std.spec.{check, check_msg}

    it "creates environment directory structure":
use std.spec.{check, check_msg}

        val env_dir = "{test_dir}/.simple-env"
use std.spec.{check, check_msg}

        rt_dir_create("{env_dir}/lib", true)
use std.spec.{check, check_msg}

        rt_dir_create("{env_dir}/bin", true)
use std.spec.{check, check_msg}

        rt_dir_create("{env_dir}/simple_modules", true)
use std.spec.{check, check_msg}

        check(rt_package_is_dir("{env_dir}/lib") == 1)
use std.spec.{check, check_msg}

        check(rt_package_is_dir("{env_dir}/bin") == 1)

use std.spec.{check, check_msg}

    it "creates activation scripts":
use std.spec.{check, check_msg}

        val env_dir = "{test_dir}/.simple-env"
use std.spec.{check, check_msg}

        rt_dir_create(env_dir, true)
use std.spec.{check, check_msg}

        rt_file_write_text("{env_dir}/activate.sh", "export SIMPLE_ENV=test\n")
use std.spec.{check, check_msg}

        check(rt_file_exists("{env_dir}/activate.sh"))

use std.spec.{check, check_msg}

describe "Project CLI - query command":
use std.spec.{check, check_msg}

    before_each:
use std.spec.{check, check_msg}

        cleanup()
use std.spec.{check, check_msg}

        rt_dir_create("{test_dir}/src", true)
use std.spec.{check, check_msg}

        rt_file_write_text("{test_dir}/src/example.spl", "fn hello():\n    print \"hello\"\n\nfn world():\n    # TODO: implement\n    pass\n")
use std.spec.{check, check_msg}

    after_each:
use std.spec.{check, check_msg}

        cleanup()

use std.spec.{check, check_msg}

    it "finds patterns in source files":
use std.spec.{check, check_msg}

        val content = rt_file_read_text("{test_dir}/src/example.spl")
use std.spec.{check, check_msg}

        check(content.contains("fn hello()"))
use std.spec.{check, check_msg}

        check(content.contains("TODO"))

use std.spec.{check, check_msg}

    it "supports --fn flag for function search":
use std.spec.{check, check_msg}

        val content = rt_file_read_text("{test_dir}/src/example.spl")
use std.spec.{check, check_msg}

        # File contains two fn definitions: hello and world
use std.spec.{check, check_msg}

        check(content.contains("fn hello()"))
use std.spec.{check, check_msg}

        check(content.contains("fn world()"))

use std.spec.{check, check_msg}

describe "Project CLI - qualify-ignore command":
use std.spec.{check, check_msg}

    before_each:
use std.spec.{check, check_msg}

        cleanup()
use std.spec.{check, check_msg}

        rt_dir_create("{test_dir}/test", true)
use std.spec.{check, check_msg}

        rt_file_write_text("{test_dir}/test/example_spec.spl", "describe \"example\":\n    #[ignore]\n    it \"should work\":\n        assert true\n\n    #[ignore = \"WIP\"]\n    it \"should also work\":\n        assert true\n")
use std.spec.{check, check_msg}

    after_each:
use std.spec.{check, check_msg}

        cleanup()

use std.spec.{check, check_msg}

    it "detects unqualified #[ignore]":
use std.spec.{check, check_msg}

        val content = rt_file_read_text("{test_dir}/test/example_spec.spl")
use std.spec.{check, check_msg}

        check(content.contains("#[ignore]"))

use std.spec.{check, check_msg}

    it "distinguishes qualified from unqualified":
use std.spec.{check, check_msg}

        val content = rt_file_read_text("{test_dir}/test/example_spec.spl")
use std.spec.{check, check_msg}

        # Has both unqualified (#[ignore]) and qualified (#[ignore = "WIP"])
use std.spec.{check, check_msg}

        check(content.contains("#[ignore]"))
use std.spec.{check, check_msg}

        check(content.contains("#[ignore = \"WIP\"]"))
