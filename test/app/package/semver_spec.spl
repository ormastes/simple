# SemVer Parser - SSpec Tests
import std.spec

use package.types
use package.semver

describe "SemVer Version Parsing":

    describe "Basic version strings":

        it "parses simple version":
            val version = parse_version("1.2.3")
            expect(version.is_ok()).to_be(true)

            val v = version.unwrap()
            expect(v.major).to_equal(1)
            expect(v.minor).to_equal(2)
            expect(v.patch).to_equal(3)
            expect(v.prerelease.is_none()).to_be(true)

        it "parses version with prerelease":
            val version = parse_version("1.2.3-alpha.1")
            expect(version.is_ok()).to_be(true)

            val v = version.unwrap()
            expect(v.major).to_equal(1)
            expect(v.minor).to_equal(2)
            expect(v.patch).to_equal(3)
            expect(v.prerelease.unwrap()).to_equal("alpha.1")

        it "parses version with build metadata":
            val version = parse_version("1.2.3+20130313144700")
            expect(version.is_ok()).to_be(true)

            val v = version.unwrap()
            expect(v.major).to_equal(1)
            expect(v.build.unwrap()).to_equal("20130313144700")

        it "parses version with both prerelease and build":
            val version = parse_version("1.2.3-beta.2+exp.sha.5114f85")
            expect(version.is_ok()).to_be(true)

            val v = version.unwrap()
            expect(v.prerelease.unwrap()).to_equal("beta.2")
            expect(v.build.unwrap()).to_equal("exp.sha.5114f85")

    describe "Version comparison":

        it "compares major versions":
            val v1 = parse_version("2.0.0").unwrap()
            val v2 = parse_version("1.9.9").unwrap()

            expect(version_greater(v1, v2)).to_be(true)
            expect(version_greater(v2, v1)).to_be(false)
            expect(version_equal(v1, v2)).to_be(false)

        it "compares minor versions when major equal":
            val v1 = parse_version("1.5.0").unwrap()
            val v2 = parse_version("1.3.9").unwrap()

            expect(version_greater(v1, v2)).to_be(true)

        it "compares patch versions when major and minor equal":
            val v1 = parse_version("1.2.5").unwrap()
            val v2 = parse_version("1.2.3").unwrap()

            expect(version_greater(v1, v2)).to_be(true)

        it "treats equal versions as equal":
            val v1 = parse_version("1.2.3").unwrap()
            val v2 = parse_version("1.2.3").unwrap()

            expect(version_equal(v1, v2)).to_be(true)
            expect(version_greater(v1, v2)).to_be(false)

        it "prerelease versions have lower precedence":
            val v1 = parse_version("1.2.3").unwrap()
            val v2 = parse_version("1.2.3-alpha.1").unwrap()

            expect(version_greater(v1, v2)).to_be(true)

describe "SemVer Constraint Parsing":

    describe "Caret constraints (^)":

        it "parses caret constraint":
            val constraint = parse_constraint("^1.2.3")
            expect(constraint.is_ok()).to_be(true)

            # Should match VersionConstraint.Caret with base 1.2.3

        it "caret allows compatible versions":
            val constraint = parse_constraint("^1.2.3").unwrap()

            # Should match 1.2.3, 1.2.4, 1.9.9
            expect(satisfies(parse_version("1.2.3").unwrap(), constraint)).to_be(true)
            expect(satisfies(parse_version("1.2.4").unwrap(), constraint)).to_be(true)
            expect(satisfies(parse_version("1.9.9").unwrap(), constraint)).to_be(true)

            # Should NOT match 2.0.0, 1.1.0, 0.9.9
            expect(satisfies(parse_version("2.0.0").unwrap(), constraint)).to_be(false)
            expect(satisfies(parse_version("1.1.0").unwrap(), constraint)).to_be(false)

        it "caret on 0.x is more restrictive":
            val constraint = parse_constraint("^0.2.3").unwrap()

            # 0.x is unstable - only allow 0.2.x
            expect(satisfies(parse_version("0.2.3").unwrap(), constraint)).to_be(true)
            expect(satisfies(parse_version("0.2.4").unwrap(), constraint)).to_be(true)
            expect(satisfies(parse_version("0.3.0").unwrap(), constraint)).to_be(false)

        it "caret on 0.0.x is exact":
            val constraint = parse_constraint("^0.0.3").unwrap()

            # 0.0.x is highly unstable - only exact match
            expect(satisfies(parse_version("0.0.3").unwrap(), constraint)).to_be(true)
            expect(satisfies(parse_version("0.0.4").unwrap(), constraint)).to_be(false)

    describe "Tilde constraints (~)":

        it "parses tilde constraint":
            val constraint = parse_constraint("~1.2.3")
            expect(constraint.is_ok()).to_be(true)

        it "tilde allows patch-level changes":
            val constraint = parse_constraint("~1.2.3").unwrap()

            # Should match 1.2.3, 1.2.4, 1.2.9
            expect(satisfies(parse_version("1.2.3").unwrap(), constraint)).to_be(true)
            expect(satisfies(parse_version("1.2.9").unwrap(), constraint)).to_be(true)

            # Should NOT match 1.3.0
            expect(satisfies(parse_version("1.3.0").unwrap(), constraint)).to_be(false)

    describe "Range constraints":

        it "parses range constraint":
            val constraint = parse_constraint(">=1.0.0, <2.0.0")
            expect(constraint.is_ok()).to_be(true)

        it "range matches within bounds":
            val constraint = parse_constraint(">=1.0.0, <2.0.0").unwrap()

            expect(satisfies(parse_version("1.0.0").unwrap(), constraint)).to_be(true)
            expect(satisfies(parse_version("1.5.0").unwrap(), constraint)).to_be(true)
            expect(satisfies(parse_version("1.9.9").unwrap(), constraint)).to_be(true)

            expect(satisfies(parse_version("0.9.9").unwrap(), constraint)).to_be(false)
            expect(satisfies(parse_version("2.0.0").unwrap(), constraint)).to_be(false)

    describe "Exact constraints":

        it "parses exact version":
            val constraint = parse_constraint("1.2.3")
            expect(constraint.is_ok()).to_be(true)

        it "exact only matches exact version":
            val constraint = parse_constraint("1.2.3").unwrap()

            expect(satisfies(parse_version("1.2.3").unwrap(), constraint)).to_be(true)
            expect(satisfies(parse_version("1.2.4").unwrap(), constraint)).to_be(false)

    describe "Wildcard constraints":

        it "parses wildcard":
            val constraint = parse_constraint("*")
            expect(constraint.is_ok()).to_be(true)

        it "wildcard matches any version":
            val constraint = parse_constraint("*").unwrap()

            expect(satisfies(parse_version("0.1.0").unwrap(), constraint)).to_be(true)
            expect(satisfies(parse_version("1.0.0").unwrap(), constraint)).to_be(true)
            expect(satisfies(parse_version("99.99.99").unwrap(), constraint)).to_be(true)

describe "SemVer Edge Cases":

    describe "Invalid versions":

        it "rejects non-numeric components":
            val version = parse_version("1.x.3")
            expect(version.is_err()).to_be(true)

        it "rejects missing components":
            val version = parse_version("1.2")
            expect(version.is_err()).to_be(true)

        it "rejects negative numbers":
            val version = parse_version("1.-2.3")
            expect(version.is_err()).to_be(true)

    describe "String representation":

        it "converts version to string":
            val v = parse_version("1.2.3").unwrap()
            expect(v.to_string()).to_equal("1.2.3")

        it "includes prerelease in string":
            val v = parse_version("1.2.3-alpha.1").unwrap()
            expect(v.to_string()).to_equal("1.2.3-alpha.1")

        it "includes build metadata in string":
            val v = parse_version("1.2.3+build").unwrap()
            expect(v.to_string()).to_equal("1.2.3+build")
