# Package FFI Layer Tests
# Tests the Rust FFI functions for package operations

import std.package_ffi

describe "Package FFI Operations":

    describe "SHA256 Checksum":

        it "calculates SHA256 for a file":
            # Create test file
            val test_file = "/tmp/ffi-checksum-test.txt"

            # Write known content
            val content = "Hello, World!"
            # Use file write operation
            # TODO: This assumes we have file write via fs or similar

            # For now, skip this test if we can't create the file
            # In practice, this would use std.fs.write_file
            pass

        it "returns correct format for checksum":
            # The checksum should be in format: sha256:hexdigest
            # We'll test this with a real file once file ops are available
            pass

    describe "Tarball Operations":

        it "creates a tarball from directory":
            val source_dir = "/tmp/tarball-test-source"
            val tarball_path = "/tmp/test-package.tar.gz"

            # Would need directory creation
            # package_ffi.mkdir_all(source_dir)
            # Then create tarball
            # val result = package_ffi.create_tarball(source_dir, tarball_path)
            # expect(result).to_be(true)

            pass

        it "extracts a tarball to directory":
            # Similar to above - needs file system setup
            pass

    describe "File System Operations":

        it "creates directory with parents":
            val test_dir = "/tmp/package-test/nested/deep"

            # Clean up if exists
            if package_ffi.path_exists("/tmp/package-test"):
                package_ffi.remove_dir_all("/tmp/package-test")

            # Create nested directory
            val result = package_ffi.mkdir_all(test_dir)
            expect(result).to_be(true)

            # Verify it exists
            expect(package_ffi.path_exists(test_dir)).to_be(true)
            expect(package_ffi.is_directory(test_dir)).to_be(true)

            # Cleanup
            package_ffi.remove_dir_all("/tmp/package-test")

        it "removes directory recursively":
            val test_dir = "/tmp/package-remove-test"

            # Create directory
            package_ffi.mkdir_all(test_dir)
            expect(package_ffi.path_exists(test_dir)).to_be(true)

            # Remove it
            val result = package_ffi.remove_dir_all(test_dir)
            expect(result).to_be(true)

            # Verify removed
            expect(package_ffi.path_exists(test_dir)).to_be(false)

        it "checks if path exists":
            val existing = "/tmp"
            val nonexistent = "/tmp/this-does-not-exist-random-12345"

            expect(package_ffi.path_exists(existing)).to_be(true)
            expect(package_ffi.path_exists(nonexistent)).to_be(false)

        it "checks if path is directory":
            val dir = "/tmp"

            # /tmp is always a directory
            expect(package_ffi.is_directory(dir)).to_be(true)

            # A file should return false
            # (we'd need to create a test file to verify this properly)

    describe "Path Detection":

        it "detects platform correctly":
            val platform = detect_platform()

            # Should be in format: os-arch
            expect(platform.contains("-")).to_be(true)

            val parts = platform.split("-")
            expect(parts.length).to_equal(2)

    describe "Manifest Generation":

        it "generates valid bootstrap manifest":
            val manifest = PackageManifest.generate_bootstrap("0.3.0", "linux-x86_64")

            expect(manifest.name).to_equal("simple-bootstrap")
            expect(manifest.version).to_equal("0.3.0")
            expect(manifest.package_type).to_equal("bootstrap")
            expect(manifest.platform).to_equal("linux-x86_64")

        it "includes correct app directories":
            val manifest = PackageManifest.generate_bootstrap("0.3.0", "linux-x86_64")

            # Should have exactly 5 essential apps
            expect(manifest.app_dirs.length).to_equal(5)

            # Verify each essential app is present
            val apps = manifest.app_dirs
            expect(apps.contains("cli")).to_be(true)
            expect(apps.contains("run")).to_be(true)
            expect(apps.contains("compile")).to_be(true)
            expect(apps.contains("check")).to_be(true)
            expect(apps.contains("repl")).to_be(true)

    describe "Path Resolution":

        it "resolves user paths correctly":
            val paths = PackagePaths(
                prefix: "/home/user/.local",
                is_system: false,
                platform: "linux-x86_64"
            )

            expect(paths.bin_dir()).to_equal("/home/user/.local/bin")
            expect(paths.lib_dir()).to_equal("/home/user/.local/lib/simple")
            expect(paths.runtime_path()).to_equal("/home/user/.local/lib/simple/simple_runtime")
            expect(paths.stdlib_dir()).to_equal("/home/user/.local/lib/simple/stdlib")
            expect(paths.app_dir()).to_equal("/home/user/.local/lib/simple/app")

        it "resolves system paths correctly":
            val paths = PackagePaths(
                prefix: "/usr/local",
                is_system: true,
                platform: "linux-x86_64"
            )

            expect(paths.bin_dir()).to_equal("/usr/local/bin")
            expect(paths.lib_dir()).to_equal("/usr/local/lib/simple")
            expect(paths.config_dir()).to_equal("/etc/simple")
            expect(paths.cache_dir()).to_equal("/var/cache/simple")
