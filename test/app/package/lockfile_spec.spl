# Lockfile Parser - SSpec Tests
# @skip
import std.spec

use package.types
use package.semver
use package.lockfile

describe "Lockfile Parsing":

    describe "Basic lockfile structure":

        it "parses minimal lockfile":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum|
              http, 1.1.0, registry, sha256:abc123
            """

            val lockfile = parse_lockfile_string(sdn_content)
            expect(lockfile.is_ok()).to_be(true)

            val lf = lockfile.unwrap()
            expect(lf.version).to_equal(1)
            expect(lf.packages.length).to_equal(1)

        it "parses multiple packages":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum|
              http, 1.1.0, registry, sha256:abc123
              json, 2.0.1, registry, sha256:def456
              url, 1.2.0, registry, sha256:789abc
            """

            val lockfile = parse_lockfile_string(sdn_content)
            expect(lockfile.is_ok()).to_be(true)

            val lf = lockfile.unwrap()
            expect(lf.packages.length).to_equal(3)

    describe "Package sources":

        it "parses registry source":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum|
              http, 1.1.0, registry, sha256:abc123
            """

            val lockfile = parse_lockfile_string(sdn_content).unwrap()
            val pkg = lockfile.packages[0]

            expect(pkg.name).to_equal("http")
            expect(pkg.version.to_string()).to_equal("1.1.0")
            expect(pkg.source).to_equal("registry")

        it "parses git source":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum|
              mylib, 0.5.0, git+https://github.com/alice/mylib#abc1234, sha256:def456
            """

            val lockfile = parse_lockfile_string(sdn_content).unwrap()
            val pkg = lockfile.packages[0]

            expect(pkg.name).to_equal("mylib")
            expect(pkg.source.starts_with("git+")).to_be(true)

        it "parses path source":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum|
              utils, 0.1.0, path+../utils, sha256:123abc
            """

            val lockfile = parse_lockfile_string(sdn_content).unwrap()
            val pkg = lockfile.packages[0]

            expect(pkg.name).to_equal("utils")
            expect(pkg.source.starts_with("path+")).to_be(true)

    describe "Checksum validation":

        it "parses SHA256 checksums":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum|
              http, 1.1.0, registry, sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
            """

            val lockfile = parse_lockfile_string(sdn_content).unwrap()
            val pkg = lockfile.packages[0]

            expect(pkg.checksum.starts_with("sha256:")).to_be(true)
            expect(pkg.checksum.length).to_equal(71)  # "sha256:" + 64 hex chars

        it "validates checksum format":
            val valid = validate_checksum("sha256:abc123def456")
            expect(valid).to_be(true)

            val invalid = validate_checksum("md5:abc123")
            expect(invalid).to_be(false)

    describe "Dependency tracking":

        it "parses package dependencies":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum, deps|
              http, 1.1.0, registry, sha256:abc, [url@1.2.0]
              url, 1.2.0, registry, sha256:def, []
            """

            val lockfile = parse_lockfile_string(sdn_content).unwrap()
            val http_pkg = lockfile.packages[0]

            expect(http_pkg.dependencies.length).to_equal(1)
            expect(http_pkg.dependencies[0]).to_equal("url@1.2.0")

        it "parses empty dependencies":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum, deps|
              standalone, 1.0.0, registry, sha256:abc, []
            """

            val lockfile = parse_lockfile_string(sdn_content).unwrap()
            val pkg = lockfile.packages[0]

            expect(pkg.dependencies.length).to_equal(0)

    describe "Lockfile queries":

        it "finds package by name":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum|
              http, 1.1.0, registry, sha256:abc
              json, 2.0.1, registry, sha256:def
            """

            val lockfile = parse_lockfile_string(sdn_content).unwrap()

            val found = lockfile.find_package("http")
            expect(found.is_some()).to_be(true)
            expect(found.unwrap().name).to_equal("http")

        it "returns None for missing package":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum|
              http, 1.1.0, registry, sha256:abc
            """

            val lockfile = parse_lockfile_string(sdn_content).unwrap()

            val found = lockfile.find_package("nonexistent")
            expect(found.is_none()).to_be(true)

        it "checks package existence":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum|
              http, 1.1.0, registry, sha256:abc
            """

            val lockfile = parse_lockfile_string(sdn_content).unwrap()

            expect(lockfile.has_package("http")).to_be(true)
            expect(lockfile.has_package("json")).to_be(false)

describe "Lockfile Generation":

    describe "Creating lockfile from resolution":

        it "generates lockfile from resolved packages":
            var packages = []
            packages.push(ResolvedDependency(
                name: "http",
                version: parse_version("1.1.0").unwrap(),
                source: DependencySource.Registry,
                checksum: Some("sha256:abc123")
            )

            val lockfile = generate_lockfile(packages)

            expect(lockfile.version).to_equal(1)
            expect(lockfile.packages.length).to_equal(1)

        it "includes current timestamp":
            val packages = []
            val lockfile = generate_lockfile(packages)

            # Timestamp should be ISO 8601 format
            expect(lockfile.generated.contains("T")).to_be(true)
            expect(lockfile.generated.contains("Z")).to_be(true)

        it "converts git sources to lockfile format":
            var packages = []
            packages.push(ResolvedDependency(
                name: "mylib",
                version: parse_version("0.5.0").unwrap(),
                source: DependencySource.Git(
                    url: "https://github.com/alice/mylib",
                    ref: GitRef.Commit(hash: "abc1234")
                ),
                checksum: Some("sha256:def456")
            )

            val lockfile = generate_lockfile(packages)
            val pkg = lockfile.packages[0]

            expect(pkg.source.starts_with("git+")).to_be(true)
            expect(pkg.source.contains("abc1234")).to_be(true)

        it "converts path sources to lockfile format":
            var packages = []
            packages.push(ResolvedDependency(
                name: "utils",
                version: parse_version("0.1.0").unwrap(),
                source: DependencySource.Path(path: "../utils"),
                checksum: Some("sha256:123abc")
            )

            val lockfile = generate_lockfile(packages)
            val pkg = lockfile.packages[0]

            expect(pkg.source).to_equal("path+../utils")

describe "Lockfile Serialization":

    describe "Converting to SDN format":

        it "serializes lockfile to string":
            var packages = []
            packages.push(LockedPackage(
                name: "http",
                version: parse_version("1.1.0").unwrap(),
                source: "registry",
                checksum: "sha256:abc123",
                dependencies: []
            )

            val lockfile = Lockfile(
                version: 1,
                generated: "2026-02-01T12:34:56Z",
                packages: packages
            )

            val sdn_string = lockfile_to_string(lockfile)

            expect(sdn_string.contains("lockfile_version: 1")).to_be(true)
            expect(sdn_string.contains("http")).to_be(true)

        it "formats table structure correctly":
            var packages = []
            packages.push(LockedPackage(
                name: "http",
                version: parse_version("1.1.0").unwrap(),
                source: "registry",
                checksum: "sha256:abc",
                dependencies: []
            )

            val lockfile = Lockfile(
                version: 1,
                generated: "2026-02-01T12:34:56Z",
                packages: packages
            )

            val sdn_string = lockfile_to_string(lockfile)

            # Should contain table header
            expect(sdn_string.contains("packages |")).to_be(true)

describe "Lockfile Validation":

    describe "Version compatibility":

        it "accepts version 1 lockfiles":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum|
            """

            val lockfile = parse_lockfile_string(sdn_content)
            expect(lockfile.is_ok()).to_be(true)

        it "rejects unknown lockfile versions":
            val sdn_content = """
            lockfile_version: 999
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum|
            """

            val lockfile = parse_lockfile_string(sdn_content)
            expect(lockfile.is_err()).to_be(true)

    describe "Integrity checks":

        it "validates all packages have checksums":
            val sdn_content = """
            lockfile_version: 1
            generated: 2026-02-01T12:34:56Z

            packages |name, version, source, checksum|
              http, 1.1.0, registry, sha256:abc
            """

            val lockfile = parse_lockfile_string(sdn_content).unwrap()
            val valid = validate_lockfile(lockfile)

            expect(valid).to_be(true)

describe "Lockfile File Operations":

    describe "Reading from file":

        it "reads lockfile from file path":
            # Will implement when file I/O is ready
            pass

        it "creates lockfile if missing":
            # Will implement with install command
            pass

    describe "Writing lockfile":

        it "writes lockfile to simple.lock":
            # Will implement when file I/O is ready
            pass

        it "preserves formatting for git diffs":
            # SDN table format should be merge-friendly
            pass
