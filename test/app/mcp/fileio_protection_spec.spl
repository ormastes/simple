# File I/O Protection Engine Tests
# Tests rule matching, action enforcement, and edge cases

use app.mcp.fileio_protection (ProtectionEngine, RuleType, RuleAction, ProtectionResult, create_engine)

describe "File I/O Protection Engine":

    describe "Rule Matching":

        it "matches exact paths":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("CLAUDE.md", RuleType.Exact, RuleAction.Protect, "Test")

            val result = engine.check_path("CLAUDE.md", "write")
            match result:
                ProtectionResult.Denied(_): assert true
                _: assert false, "Expected denied result"

        it "matches glob patterns with *":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("*.sdn", RuleType.Glob, RuleAction.Atomic, "Test")

            val result = engine.check_path("test.sdn", "write")
            match result:
                ProtectionResult.RequiresAtomic: assert true
                _: assert false, "Expected requires atomic"

        it "matches glob patterns with multiple *":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("doc/*.sdn", RuleType.Glob, RuleAction.Atomic, "Test")

            val result = engine.check_path("doc/test.sdn", "write")
            match result:
                ProtectionResult.RequiresAtomic: assert true
                _: assert false, "Expected requires atomic"

        it "does not match non-matching patterns":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("*.sdn", RuleType.Glob, RuleAction.Atomic, "Test")

            val result = engine.check_path("test.txt", "write")
            match result:
                ProtectionResult.Allowed: assert true
                _: assert false, "Expected allowed"

        it "normalizes paths with trailing slash":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("src/", RuleType.Exact, RuleAction.Protect, "Test")

            val result1 = engine.check_path("src/", "write")
            val result2 = engine.check_path("src", "write")

            match result1:
                ProtectionResult.Denied(_): assert true
                _: assert false, "Expected denied for src/"

            match result2:
                ProtectionResult.Denied(_): assert true
                _: assert false, "Expected denied for src"

        it "normalizes relative paths":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("test.txt", RuleType.Exact, RuleAction.Protect, "Test")

            val result = engine.check_path("./test.txt", "write")
            match result:
                ProtectionResult.Denied(_): assert true
                _: assert false, "Expected denied"

        it "returns first matching rule":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("*.txt", RuleType.Glob, RuleAction.Deny, "First")
            engine.add_rule("*.txt", RuleType.Glob, RuleAction.Allow, "Second")

            val result = engine.check_path("test.txt", "write")
            match result:
                ProtectionResult.Denied(reason):
                    check(reason.contains("First"))
                _: assert false, "Expected first rule to match"

    describe "Action Enforcement":

        it "allows read on protected files":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("test.txt", RuleType.Exact, RuleAction.Protect, "Test")

            val result = engine.check_path("test.txt", "read")
            match result:
                ProtectionResult.Allowed: assert true
                _: assert false, "Expected allowed for read"

        it "denies write on protected files":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("test.txt", RuleType.Exact, RuleAction.Protect, "Test")

            val result = engine.check_path("test.txt", "write")
            match result:
                ProtectionResult.Denied(_): assert true
                _: assert false, "Expected denied for write"

        it "denies delete on protected files":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("test.txt", RuleType.Exact, RuleAction.Protect, "Test")

            val result = engine.check_path("test.txt", "delete")
            match result:
                ProtectionResult.Denied(_): assert true
                _: assert false, "Expected denied for delete"

        it "denies all operations on denied files":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("/", RuleType.Exact, RuleAction.Deny, "Test")

            val read_result = engine.check_path("/", "read")
            val write_result = engine.check_path("/", "write")

            match read_result:
                ProtectionResult.Denied(_): assert true
                _: assert false, "Expected denied for read"

            match write_result:
                ProtectionResult.Denied(_): assert true
                _: assert false, "Expected denied for write"

        it "redirects files to temp directory":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp/test")
            engine.add_rule("*.sh", RuleType.Glob, RuleAction.Redirect, "Test")

            val result = engine.check_path("script.sh", "write")
            match result:
                ProtectionResult.Redirected(path):
                    check(path.contains("/tmp/test"))
                    check(path.contains("script.sh"))
                _: assert false, "Expected redirected"

        it "requires atomic writes for atomic action":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("*.sdn", RuleType.Glob, RuleAction.Atomic, "Test")

            val result = engine.check_path("test.sdn", "write")
            match result:
                ProtectionResult.RequiresAtomic: assert true
                _: assert false, "Expected requires atomic"

        it "allows all operations for allow action":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("doc/", RuleType.Exact, RuleAction.Allow, "Test")

            val result = engine.check_path("doc/", "write")
            match result:
                ProtectionResult.Allowed: assert true
                _: assert false, "Expected allowed"

    describe "Edge Cases":

        it "handles empty path":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            val result = engine.check_path("", "write")
            match result:
                ProtectionResult.Allowed: assert true
                _: assert false, "Expected allowed for empty path"

        it "handles no matching rules":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            val result = engine.check_path("random.txt", "write")
            match result:
                ProtectionResult.Allowed: assert true
                _: assert false, "Expected allowed when no rules match"

        it "handles nested paths":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("src/", RuleType.Exact, RuleAction.Protect, "Test")

            # Should not match nested paths
            val result = engine.check_path("src/app/main.spl", "write")
            match result:
                ProtectionResult.Allowed: assert true
                _: assert false, "Expected allowed for nested path"

        it "handles multiple rules for same path":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("test.txt", RuleType.Exact, RuleAction.Protect, "Rule 1")
            engine.add_rule("test.txt", RuleType.Exact, RuleAction.Allow, "Rule 2")

            # First rule should win
            val result = engine.check_path("test.txt", "write")
            match result:
                ProtectionResult.Denied(reason):
                    check(reason.contains("Rule 1"))
                _: assert false, "Expected first rule to match"

        it "lists protected files with wildcard":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("CLAUDE.md", RuleType.Exact, RuleAction.Protect, "Test 1")
            engine.add_rule("src/", RuleType.Exact, RuleAction.Protect, "Test 2")
            engine.add_rule("*.txt", RuleType.Glob, RuleAction.Allow, "Test 3")

            val files = engine.list_protected_files("*")
            expect(files.len()).to_equal(2)
            expect(files.contains("CLAUDE.md")).to_equal(true)
            expect(files.contains("src/")).to_equal(true)

        it "lists protected files with pattern":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("CLAUDE.md", RuleType.Exact, RuleAction.Protect, "Test 1")
            engine.add_rule("src/", RuleType.Exact, RuleAction.Protect, "Test 2")

            val files = engine.list_protected_files("CLAUDE")
            expect(files.len()).to_equal(1)
            expect(files.contains("CLAUDE.md")).to_equal(true)

        it "gets protection info for path":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            engine.add_rule("CLAUDE.md", RuleType.Exact, RuleAction.Protect, "Important file")

            val info = engine.get_protection_info("CLAUDE.md")
            expect(info.contains("Protect")).to_equal(true)
            expect(info.contains("Important file")).to_equal(true)

        it "gets protection info for unprotected path":
            val engine = ProtectionEngine(rules: [], temp_base: "/tmp")
            val info = engine.get_protection_info("random.txt")
            expect(info.contains("No protection")).to_equal(true)
