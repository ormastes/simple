extern fn rt_env_get(key: text) -> text
extern fn rt_env_set(key: text, value: text)

class DiContainer:
    bindings: text
    singletons: text
    profile: text
    all_bindings: list
    locked: bool

    fn _is_env_locked() -> bool:
        val sys = rt_env_get("SIMPLE_SYSTEM_TEST")
        val di_test = rt_env_get("SIMPLE_DI_TEST")
        if sys == "1":
            if di_test == "1":
                return false
            return true
        false

    fn is_locked() -> bool:
        if self.locked:
            return true
        self._is_env_locked()

    me lock():
        self.locked = true

    me unlock():
        self.locked = false

    me bind_instance(key: text, value):
        if self.is_locked():
            return nil
        var new_bindings = []
        for entry in self.all_bindings:
            if entry[0] != key:
                new_bindings = new_bindings + [entry]
        new_bindings = new_bindings + [[key, value]]
        self.all_bindings = new_bindings

    me bind(key: text, factory):
        if self.is_locked():
            return nil
        val value = factory()
        var new_bindings = []
        for entry in self.all_bindings:
            if entry[0] != key:
                new_bindings = new_bindings + [entry]
        new_bindings = new_bindings + [[key, value]]
        self.all_bindings = new_bindings

    fn has(key: text) -> bool:
        for entry in self.all_bindings:
            if entry[0] == key:
                return true
        false

    fn resolve(key: text):
        for entry in self.all_bindings:
            if entry[0] == key:
                return entry[1]
        nil

    fn resolve_or(key: text, default_val):
        for entry in self.all_bindings:
            if entry[0] == key:
                return entry[1]
        default_val

describe "edge cases":
    it "empty string key can be stored and retrieved":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("", "empty_key_val")
        expect(di.resolve("")).to_equal("empty_key_val")

    it "overwriting key keeps the latest value":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("key", "first")
        di.bind_instance("key", "second")
        expect(di.resolve("key")).to_equal("second")

    it "multiple distinct keys are independent":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("a", "val_a")
        di.bind_instance("b", "val_b")
        expect(di.resolve("a")).to_equal("val_a")
        expect(di.resolve("b")).to_equal("val_b")

    it "singleton is resolved from singletons not bindings":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("svc", "singleton_val")
        expect(di.has("svc")).to_equal(true)
        expect(di.resolve("svc")).to_equal("singleton_val")

    it "factory binding is callable after bind":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind("computed", fn(): "computed_result")
        expect(di.has("computed")).to_equal(true)
        val result = di.resolve("computed")
        expect(result).to_equal("computed_result")
