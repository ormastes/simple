"""
Parser Roundtrip Fuzz Specification

Fuzz tests for string/expression manipulation stability.
Uses inline LCG PRNG for deterministic randomness without imports.

Feature: Parser Roundtrip Stability
Category: Fuzz Testing
Status: Active
"""

# Inline LCG random number generator
var lcg_state = 12345

fn lcg_seed(s: i64):
    lcg_state = s

fn lcg_next() -> i64:
    lcg_state = (1103515245 * lcg_state + 12345) % 2147483647
    if lcg_state < 0: lcg_state = -lcg_state
    return lcg_state

fn lcg_range(lo: i64, hi: i64) -> i64:
    val raw = lcg_next()
    val range_size = hi - lo
    if range_size <= 0: return lo
    return lo + (raw % range_size)

describe "fuzz: parser roundtrip":
    it "integer literals are stable through to_text/int conversion":
        lcg_seed(12345)
        var failures = 0
        for i in 0..200:
            val n = lcg_range(-5000, 5000)
            val s = "{n}"
            val back = int(s)
            if back != n:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "string concatenation is associative":
        lcg_seed(67890)
        var failures = 0
        for i in 0..100:
            val a_num = lcg_range(0, 100)
            val b_num = lcg_range(0, 100)
            val c_num = lcg_range(0, 100)
            val a = "s_{a_num}"
            val b = "s_{b_num}"
            val c = "s_{c_num}"
            val ab_c = a + b + c
            val a_bc = a + (b + c)
            if ab_c != a_bc:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "integer negation is involutory":
        lcg_seed(11111)
        var failures = 0
        for i in 0..200:
            val n = lcg_range(-10000, 10000)
            val neg_neg = -(-n)
            if neg_neg != n:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "string length matches content after interpolation":
        lcg_seed(22222)
        var failures = 0
        for i in 0..100:
            val x = lcg_range(0, 1000)
            val s = "{x}"
            val expected_len = "{x}".len()
            if s.len() != expected_len:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "repeated string building is consistent":
        lcg_seed(33333)
        var failures = 0
        for i in 0..50:
            val count = lcg_range(1, 10)
            var built1 = ""
            var built2 = ""
            for j in 0..count:
                built1 = built1 + "x"
                built2 = built2 + "x"
            if built1 != built2:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "integer to text roundtrip preserves sign":
        lcg_seed(44444)
        var failures = 0
        for i in 0..200:
            val n = lcg_range(-9999, 9999)
            val s = "{n}"
            val back = int(s)
            val sign_original = if n < 0: -1 else: if n > 0: 1 else: 0
            val sign_back = if back < 0: -1 else: if back > 0: 1 else: 0
            if sign_original != sign_back:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "addition is commutative across random pairs":
        lcg_seed(55555)
        var failures = 0
        for i in 0..200:
            val a = lcg_range(-10000, 10000)
            val b = lcg_range(-10000, 10000)
            if a + b != b + a:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "multiplication is commutative across random pairs":
        lcg_seed(66666)
        var failures = 0
        for i in 0..200:
            val a = lcg_range(-1000, 1000)
            val b = lcg_range(-1000, 1000)
            if a * b != b * a:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "string repeat length is predictable":
        lcg_seed(77777)
        var failures = 0
        for i in 0..50:
            val count = lcg_range(0, 20)
            var s = ""
            for j in 0..count:
                s = s + "ab"
            if s.len() != count * 2:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "zero is additive identity for random numbers":
        lcg_seed(88888)
        var failures = 0
        for i in 0..200:
            val n = lcg_range(-100000, 100000)
            if n + 0 != n:
                failures = failures + 1
            if 0 + n != n:
                failures = failures + 1
        expect(failures).to_equal(0)
