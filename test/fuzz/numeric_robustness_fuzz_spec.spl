# Numeric Robustness Fuzz Specification
#
# Fuzz tests for arithmetic edge cases: zero, one, negative one,
# large numbers, comparisons, modulo, division, and overflow handling.
#
# Feature: Numeric Operation Robustness
# Category: Fuzz Testing
# Status: Active

# Inline LCG random number generator
var lcg_state = 54321

fn lcg_seed(s: i64):
    lcg_state = s

fn lcg_next() -> i64:
    lcg_state = (1103515245 * lcg_state + 12345) % 2147483647
    if lcg_state < 0: lcg_state = -lcg_state
    return lcg_state

fn lcg_range(lo: i64, hi: i64) -> i64:
    val raw = lcg_next()
    val range_size = hi - lo
    if range_size <= 0: return lo
    return lo + (raw % range_size)

# Helper: absolute value
fn abs_val(n: i64) -> i64:
    if n < 0: return -n
    return n

describe "fuzz: numeric robustness":
    it "multiplication by zero always yields zero":
        lcg_seed(20001)
        var failures = 0
        for i in 0..200:
            val n = lcg_range(-100000, 100000)
            if n * 0 != 0:
                failures = failures + 1
            if 0 * n != 0:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "multiplication by one is identity":
        lcg_seed(20002)
        var failures = 0
        for i in 0..200:
            val n = lcg_range(-100000, 100000)
            if n * 1 != n:
                failures = failures + 1
            if 1 * n != n:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "multiplication by negative one negates":
        lcg_seed(20003)
        var failures = 0
        for i in 0..200:
            val n = lcg_range(-100000, 100000)
            if n * -1 != -n:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "comparison consistency: a < b implies not b < a":
        lcg_seed(20004)
        var failures = 0
        for i in 0..200:
            val a = lcg_range(-10000, 10000)
            val b = lcg_range(-10000, 10000)
            if a < b:
                if b < a:
                    failures = failures + 1
        expect(failures).to_equal(0)

    it "comparison trichotomy: exactly one of <, ==, > holds":
        lcg_seed(20005)
        var failures = 0
        for i in 0..200:
            val a = lcg_range(-10000, 10000)
            val b = lcg_range(-10000, 10000)
            var count = 0
            if a < b: count = count + 1
            if a == b: count = count + 1
            if a > b: count = count + 1
            if count != 1:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "modulo result has same sign behavior":
        lcg_seed(20006)
        var failures = 0
        for i in 0..200:
            val divisor = lcg_range(1, 1000)
            val n = lcg_range(-10000, 10000)
            val remainder = n % divisor
            # remainder magnitude should be less than divisor
            if abs_val(remainder) >= divisor:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "division and modulo are consistent: n == (n / d) * d + (n % d)":
        lcg_seed(20007)
        var failures = 0
        for i in 0..200:
            val d = lcg_range(1, 1000)
            val n = lcg_range(-10000, 10000)
            val quotient = n / d
            val remainder = n % d
            val reconstructed = quotient * d + remainder
            if reconstructed != n:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "subtraction is inverse of addition":
        lcg_seed(20008)
        var failures = 0
        for i in 0..200:
            val a = lcg_range(-50000, 50000)
            val b = lcg_range(-50000, 50000)
            val sum = a + b
            val diff = sum - b
            if diff != a:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "addition is associative for random triples":
        lcg_seed(20009)
        var failures = 0
        for i in 0..100:
            val a = lcg_range(-10000, 10000)
            val b = lcg_range(-10000, 10000)
            val c = lcg_range(-10000, 10000)
            val left = (a + b) + c
            val right = a + (b + c)
            if left != right:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "distributive law holds: a * (b + c) == a * b + a * c":
        lcg_seed(20010)
        var failures = 0
        for i in 0..100:
            val a = lcg_range(-100, 100)
            val b = lcg_range(-100, 100)
            val c = lcg_range(-100, 100)
            val left = a * (b + c)
            val right = a * b + a * c
            if left != right:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "absolute value is always non-negative":
        lcg_seed(20011)
        var failures = 0
        for i in 0..200:
            val n = lcg_range(-100000, 100000)
            val a = abs_val(n)
            if a < 0:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "large number addition does not silently lose precision":
        lcg_seed(20012)
        var failures = 0
        val big = 1000000000
        for i in 0..100:
            val offset = lcg_range(0, 1000000)
            val n = big + offset
            val back = n - big
            if back != offset:
                failures = failures + 1
        expect(failures).to_equal(0)
