# String Operations Fuzz Specification
#
# Fuzz tests for string operations: length, slicing, contains,
# replace, and empty string handling.
#
# Feature: String Operation Stability
# Category: Fuzz Testing
# Status: Active

# Inline LCG random number generator
var lcg_state = 99999

fn lcg_seed(s: i64):
    lcg_state = s

fn lcg_next() -> i64:
    lcg_state = (1103515245 * lcg_state + 12345) % 2147483647
    if lcg_state < 0: lcg_state = -lcg_state
    return lcg_state

fn lcg_range(lo: i64, hi: i64) -> i64:
    val raw = lcg_next()
    val range_size = hi - lo
    if range_size <= 0: return lo
    return lo + (raw % range_size)

# Helper: build a string of given length from a character
fn build_string(ch: text, count: i64) -> text:
    var result = ""
    for i in 0..count:
        result = result + ch
    return result

# Helper: build a random-ish string of given length
fn build_random_string(length: i64) -> text:
    val chars = "abcdefghijklmnopqrstuvwxyz"
    var result = ""
    for i in 0..length:
        val idx = lcg_range(0, 26)
        result = result + chars[idx]
    return result

describe "fuzz: string operations":
    it "string length is always non-negative":
        lcg_seed(10001)
        var failures = 0
        for i in 0..100:
            val len = lcg_range(0, 50)
            val s = build_string("a", len)
            if s.len() < 0:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "string length matches constructed length":
        lcg_seed(10002)
        var failures = 0
        for i in 0..100:
            val len = lcg_range(0, 30)
            val s = build_string("x", len)
            if s.len() != len:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "slicing with valid bounds works":
        lcg_seed(10003)
        var failures = 0
        for i in 0..100:
            val len = lcg_range(2, 20)
            val s = build_string("m", len)
            val start = lcg_range(0, len - 1)
            val end = lcg_range(start + 1, len)
            val sliced = s[start:end]
            val expected_len = end - start
            if sliced.len() != expected_len:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "contains finds substring that was appended":
        lcg_seed(10004)
        var failures = 0
        for i in 0..50:
            val base = build_random_string(lcg_range(3, 10))
            val needle = build_random_string(lcg_range(1, 3))
            val combined = base + needle
            if combined.contains(needle) != true:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "empty string concatenation is identity":
        lcg_seed(10005)
        var failures = 0
        for i in 0..100:
            val s = build_random_string(lcg_range(0, 20))
            val with_empty = s + ""
            val empty_with = "" + s
            if with_empty != s:
                failures = failures + 1
            if empty_with != s:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "empty string has length zero":
        val s = ""
        expect(s.len()).to_equal(0)

    it "replace preserves length when replacement has same length":
        lcg_seed(10006)
        var failures = 0
        for i in 0..50:
            val len = lcg_range(5, 20)
            val s = build_string("a", len)
            # Replace single char with single char
            var replaced = s.replace("a", "b")
            if replaced.len() != s.len():
                failures = failures + 1
        expect(failures).to_equal(0)

    it "contains returns false for longer needle than haystack":
        lcg_seed(10007)
        var failures = 0
        for i in 0..50:
            val short_len = lcg_range(1, 5)
            val long_len = lcg_range(6, 15)
            val haystack = build_string("z", short_len)
            val needle = build_string("a", long_len)
            if haystack.contains(needle) != false:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "string equality is reflexive":
        lcg_seed(10008)
        var failures = 0
        for i in 0..100:
            val s = build_random_string(lcg_range(0, 30))
            if s != s:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "starts_with works for prefix of constructed string":
        lcg_seed(10009)
        var failures = 0
        for i in 0..50:
            val prefix = build_random_string(lcg_range(1, 5))
            val suffix = build_random_string(lcg_range(1, 10))
            val combined = prefix + suffix
            if combined.starts_with(prefix) != true:
                failures = failures + 1
        expect(failures).to_equal(0)

    it "ends_with works for suffix of constructed string":
        lcg_seed(10010)
        var failures = 0
        for i in 0..50:
            val prefix = build_random_string(lcg_range(1, 5))
            val suffix = build_random_string(lcg_range(1, 10))
            val combined = prefix + suffix
            if combined.ends_with(suffix) != true:
                failures = failures + 1
        expect(failures).to_equal(0)
