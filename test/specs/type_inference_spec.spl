"""
# Type Inference Specification - Test Specification

**Status:** Partial Implementation (Hindley-Milner scaffold working)
**Feature IDs:** #13
**Last Updated:** 2026-02-08
**Migrated From:** doc/spec/type_inference.md

## Overview

Simple uses a Hindley-Milner-style type inference system that automatically deduces types
for expressions, variables, and functions without requiring explicit type annotations.

This test file covers basic type inference rules that work in the current runtime.
"""

use std.spec
use std.spec.{check, check_msg, expect}

describe "Type Inference Spec":
    it "inference rules - literals":
        # Integer, float, string, boolean literals infer their types
        val x = 42
        val y = 3.14
        val s = "hello"
        val b = true
        check(true)

    it "inference rules - arithmetic":
        # Operators infer types from operands
        val a = 1 + 2
        val b = 3.0 * 1.5
        expect(a).to_equal(3)

    it "inference rules - comparison":
        # Comparison operators return bool
        val cmp = 1 < 2
        expect(cmp).to_equal(true)

    it "inference rules - logical":
        # Logical operators return bool
        val logic = true and false
        expect(logic).to_equal(false)

    it "inference rules - bitwise":
        # Bitwise operators work on integers
        val bits = 5 << 2
        expect(bits).to_equal(20)

    it "inference rules - arrays":
        # Arrays infer element type from literals
        val arr = [1, 2, 3]
        expect(arr[0]).to_equal(1)

    it "inference rules - tuples":
        # Tuples can have mixed types
        val t = (1, "hi", true)
        check(true)

    it "inference rules - dictionaries":
        # Dictionaries infer key/value types
        val dict = {"a": 1, "b": 2}
        check(true)

    it "inference rules - functions with explicit types":
        # Functions can have explicit return types
        fn add(a: i64, b: i64) -> i64:
            a + b
        val result = add(3, 4)
        expect(result).to_equal(7)

    it "inference rules - lambda types":
        # Lambda expressions infer from context
        val double = \x: x * 2
        val result = double(5)
        expect(result).to_equal(10)

    it "inference rules - higher-order functions":
        # Functions can take functions as arguments
        fn apply(f: fn(i64) -> i64, x: i64) -> i64:
            f(x)

        val square = \n: n * n
        val result = apply(square, 5)
        expect(result).to_equal(25)

    it "inference rules - if expressions":
        # If-else expressions infer unified type
        val x = 1
        val v = if x > 0:
            1
        else:
            2
        expect(v).to_equal(1)

    it "inference rules - loops":
        # Loops with type-stable variables
        # Note: Closure variable capture has known limitations
        var i = 0
        while i < 3:
            i = i + 1
        check(true)  # Loop completes without error

    it "examples - basic iteration":
        # For loop with array inference
        val numbers = [1, 2, 3, 4, 5]
        var sum = 0
        for n in numbers:
            sum = sum + n
        expect(sum).to_equal(15)

    it "examples - map function":
        # Higher-order function with generics
        fn map_simple(arr: [i64], f: fn(i64) -> i64) -> [i64]:
            var result = []
            for x in arr:
                result = result + [f(x)]
            result

        val numbers = [1, 2, 3]
        val doubled = map_simple(numbers, \x: x * 2)
        expect(doubled[0]).to_equal(2)
        expect(doubled[1]).to_equal(4)
        expect(doubled[2]).to_equal(6)

    it "examples - option type with match":
        # Option type with pattern matching
        fn find_first(arr: [i64], target: i64) -> i64:
            for x in arr:
                if x == target:
                    return x
            return -1

        val numbers = [10, 20, 30]
        val found = find_first(numbers, 20)
        val not_found = find_first(numbers, 99)

        expect(found).to_equal(20)
        expect(not_found).to_equal(-1)
