# @pending
# @skip - Uses unsupported keyword: async
"""
# Simple Language Functions and Pattern Matching - Test Specification

**Status:** Reference
**Feature IDs:** 
**Source:** functions.md
**Type:** Extracted Examples (Category B)

## Overview

This file contains executable test cases extracted from functions.md.
The original specification file remains as architectural reference documentation.

**Note:** This is a test extraction file. For complete specification text,
design rationale, and architecture, see doc/spec/functions.md

## Extracted Test Cases

24 test cases extracted covering:
- Core functionality examples
- Edge cases and validation
- Integration patterns
"""

## Test: Functions (Line ~7)

"""
Functions in Simple are defined with the `fn` keyword. The syntax is inspired by Python's definition...
"""
fn add(a: i64, b: i64) -> i64:
    return a + b

## Test: Functions (Line ~18)

"""
Functions have an inferred async/sync effect based on their body:
"""
it "functions_2":
    # Inferred as SYNC: only pure computation
    fn double(x: i64) -> i64:
        return x * 2

    # Inferred as ASYNC: uses suspension operator
    fn fetch_user(id: UserId) -> User:
        val user ~= http.get("/users/{id}")
        return user

    # Explicit SYNC: compiler verifies no suspension
    sync fn compute(x: i64) -> i64:
        return x * x

    # Explicit ASYNC: documentation, no behavioral change
    async fn load_data() -> Data:
        val d ~= read_file(path)
        return d
    pass

## Test: Functions (Line ~52)

"""
Simple supports first-class functions - you can assign functions to variables or pass them as argume...
"""
it "functions_3":
    val math_op = add
    val result = math_op(2, 3)  # 5

    fn apply(f: fn(i64, i64) -> i64, x: i64, y: i64) -> i64:
        return f(x, y)

    apply(add, 10, 20)  # 30
    pass

## Test: Lambdas and Closures (Line ~7)

"""
An inline lambda uses a backslash to introduce parameters (inspired by ML-family languages):
"""
it "lambdas_and_closures_4":
    val square = \x: x * x
    val double = \x: x * 2

    # With explicit type annotations (TODO: not yet supported)
    # val typed_square = \(x: i64) -> i64: x * x
    pass

## Test: Lambdas and Closures (Line ~19)

"""
The backslash syntax was chosen for one-pass parsing - seeing `\` immediately signals a lambda, requ...
"""
it "lambdas_and_closures_5":
    val add = \a, b: a + b
    val sum = add(3, 4)  # 7

    # With types (TODO: not yet supported)
    # val typed_add = \(a: i64, b: i64) -> i64: a + b
    pass

## Test: Lambdas and Closures (Line ~31)

"""
Lambdas capture variables from their enclosing scope:
"""
it "lambdas_and_closures_6":
    val multiplier = 3
    val scale = \x: x * multiplier

    scale(10)  # 30
    pass

## Test: Lambdas and Closures (Line ~42)

"""
Methods can accept trailing blocks for iteration or DSL constructs:
"""
it "lambdas_and_closures_7":
    list.each \item:
        print "Item: {item}"

    map.each \key, value:
        print "{key}: {value}"

    # Filtering
    val positives = numbers.filter \x: x > 0

    # Mapping
    val doubled = numbers.map \x: x * 2
    pass

## Test: Pattern Matching (Line ~7)

"""
Pattern matching is a powerful feature enabling branching on the structure of data. The `match` expr...
"""
it "pattern_matching_8":
    enum Token:
        Number(value: i64)
        Plus
        Minus
        EOF

    fn describe_token(tok: Token) -> String:
        match tok:
            case Number(val):
                return "Number({val})"
            case Plus:
                return "Plus sign"
            case Minus:
                return "Minus sign"
            case EOF:
                return "End of input"
    pass

## Test: Pattern Matching (Line ~30)

"""
fn describe_token(tok: Token) -> String:
    match tok:
        case Number(val):
            return...
"""
it "pattern_matching_9":
    match x:
        case 0:
            print "Zero"
        case 1:
            print "One"
    pass

## Test: Pattern Matching (Line ~40)

"""
```simple
match x:
    case 0:
        print "Zero"
    case 1:
        print "One"
```
"""
it "pattern_matching_10":
    match x:
        case 1 | 2 | 3:
            print "Small number"
    pass

## Test: Pattern Matching (Line ~48)

"""
```simple
match x:
    case 1 | 2 | 3:
        print "Small number"
```
"""
it "pattern_matching_11":
    match x:
        case n if n < 0:
            print "Negative number: {n}"
        case n if n > 100:
            print "Large number: {n}"
        case n:
            print "Normal number: {n}"
    pass

## Test: Pattern Matching (Line ~60)

"""
```simple
match x:
    case n if n < 0:
        print "Negative number: {n}"
    case n if n > 100:
...
"""
it "pattern_matching_12":
    match x:
        case 0:
            print "Zero"
        case _:
            print "Non-zero"
    pass

## Test: Pattern Matching (Line ~70)

"""
```simple
match x:
    case 0:
        print "Zero"
    case _:
        print "Non-zero"
```
"""
it "pattern_matching_13":
    struct Point:
        x: f64
        y: f64

    val p = Point(x: 5, y: 0)
    match p:
        case Point(0, 0):
            print "Origin"
        case Point(x_val, 0):
            print "On X axis at {x_val}"
        case Point(0, y_val):
            print "On Y axis at {y_val}"
        case Point(_, _):
            print "Somewhere else"
    pass

## Test: Pattern Matching (Line ~89)

"""
val p = Point(x: 5, y: 0)
match p:
    case Point(x: 0, y: 0):
        print "Origin"
    case Point...
"""
it "pattern_matching_14":
    val pair = (1, "hello")
    match pair:
        case (0, _):
            print "Starts with zero"
        case (n, s):
            print "Number {n} with string '{s}'"
    pass

## Test: Pattern Matching (Line ~102)

"""
All possibilities must be covered (exhaustive matching), otherwise the code will not compile:
"""
it "pattern_matching_15":
    enum Color:
        Red
        Green
        Blue

    fn name(c: Color) -> str:
        match c:
            case Red: "red"
            case Green: "green"
            # Error: missing case Blue
    pass

## Test: Constructor Polymorphism (Line ~9)

"""
The `Constructor<T>` type represents any constructor that produces an instance of `T` or a subtype:
"""
it "constructor_polymorphism_16":
    # Constructor<T> - type for constructors producing T or subtypes
    val factory: Constructor<Widget> = Button    # Button extends Widget
    val widget = factory("OK")                   # Creates a Button
    pass

## Test: Constructor Polymorphism (Line ~17)

"""
```simple
# Constructor<T> - type for constructors producing T or subtypes
val factory: Constructor[...
"""
it "constructor_polymorphism_17":
    class Widget:
        name: str

        fn new(name: str) -> Self:
            return Widget(name: name)

    class Button(Widget):
        enabled: bool

        fn new(name: str, enabled: bool = true) -> Self:
            super(name)
            self.enabled = enabled

    # Pass constructor as parameter
    fn create_widget(ctor: Constructor<Widget>, name: str) -> Widget:
        return ctor(name)

    val b = create_widget(Button, "Click")    # Creates Button
    val l = create_widget(Label, "Hello")     # Creates Label
    pass

## Test: Constructor Polymorphism (Line ~47)

"""
1. Must accept all required parameters of parent constructor
2. Additional parameters must have defa...
"""
it "constructor_polymorphism_18":
    class Base:
        fn new(name: str, value: i32) -> Self:
            ...

    class ValidChild(Base):
        # OK: has parent params + extra with default
        fn new(name: str, value: i32, extra: bool = false) -> Self:
            super(name, value)
            ...

    class InvalidChild(Base):
        # ERROR: extra param without default
        fn new(name: str, value: i32, extra: bool) -> Self:  # Compile error!
            ...
    pass

## Test: Constructor Polymorphism (Line ~76)

"""
| Parent Constructor | Child Constructor | Valid? | Reason |
|-------------------|------------------...
"""
it "constructor_polymorphism_19":
    # Generic factory function
    fn create_many<T>(ctor: Constructor<T>, names: [str]) -> [T]:
        return [ctor(name) for name in names]

    val buttons = create_many(Button, ["OK", "Cancel", "Help"])

    # Factory selector
    fn get_widget_factory(kind: str) -> Constructor<Widget>:
        match kind:
            case "button": return Button
            case "label": return Label
            case _: return Widget

    val factory = get_widget_factory("button")
    val w = factory("Dynamic Button")
    pass

## Test: Constructor Polymorphism (Line ~96)

"""
val factory = get_widget_factory("button")
val w = factory("Dynamic Button")
```
"""
it "constructor_polymorphism_20":
    # In variables
    val ctor: Constructor<Widget> = Button

    # In collections
    val factories: [Constructor<Widget>] = [Button, Label, Slider]

    # In dictionaries
    val registry: Dict<str, Constructor<Widget>> = {
        "button": Button,
        "label": Label
    }

    val widget = registry["button"]("Created from registry")
    pass

## Test: Constructor Polymorphism (Line ~116)

"""
Specify exact constructor signatures:
"""
## TODO: Tuple syntax in generic type parameters not yet supported
# it "constructor_polymorphism_21":
#     # Constructor that takes exactly (str, i32)
#     fn exact_factory(ctor: Constructor<Widget, (str, i32)>) -> Widget:
#         return ctor("default", 42)
#
#     # Constructor that takes no parameters
#     fn no_arg_factory<T>(ctor: Constructor<T, ()>) -> T:
#         return ctor()
#     pass

## Test: Constructor Polymorphism (Line ~130)

"""
Constructor polymorphism enables clean dependency injection:
"""
it "constructor_polymorphism_22":
    class Service:
        fn new(config: Config) -> Self:
            ...

    class MockService(Service):
        fn new(config: Config, mock_data: Data = Data.empty()) -> Self:
            super(config)
            ...

    class ProductionService(Service):
        fn new(config: Config, pool_size: i32 = 10) -> Self:
            super(config)
            ...

    class Application:
        service: Service

        fn new(service_ctor: Constructor<Service>, config: Config) -> Self:
            self.service = service_ctor(config)

    # Production
    val app = Application(ProductionService, prod_config)

    # Testing
    val test_app = Application(MockService, test_config)
    pass

## Test: Constructor Polymorphism (Line ~162)

"""
Use traits to define abstract constructor requirements:
"""
it "constructor_polymorphism_23":
    trait Creatable:
        fn create(name: str) -> Self

    impl Creatable for Widget:
        fn create(name: str) -> Widget:
            return Widget.new(name)

    fn make<T: Creatable>(name: str) -> T:
        return T.create(name)
    pass

## Test: Semantic Types in Function Signatures (Line ~5)

"""
Public functions should use semantic types (unit types, enums, Option) instead of bare primitives. S...
"""
it "semantic_types_in_function_signatures_24":
    # WARNING: Bare primitives in public API
    pub fn get_user_id() -> i64:        # Warning: use unit type
        return 42

    # GOOD: Semantic types (no warning)
    pub fn get_user_id() -> UserId:     # OK
        return 42_uid

    # GOOD: Enums instead of bool
    pub fn set_status(status: UserStatus):  # OK
        ...

    # GOOD: Option for nullable returns
    pub fn find_user(id: UserId) -> Option<User>:  # OK
        ...
    pass

