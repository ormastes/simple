"""
# Simple Language Data Structures - Test Specification

**Status:** Reference
**Feature IDs:** 
**Source:** data_structures.md
**Type:** Extracted Examples (Category B)

## Overview

This file contains executable test cases extracted from data_structures.md.
The original specification file remains as architectural reference documentation.

**Note:** This is a test extraction file. For complete specification text,
design rationale, and architecture, see doc/spec/data_structures.md

## Extracted Test Cases

32 test cases extracted covering:
- Core functionality examples
- Edge cases and validation
- Integration patterns
"""

## Test: Structs (Value Types) (Line ~7)

"""
Structs are value types (similar to structs in C or Rust). They are copied on assignment and passed ...
"""
test "structs_value_types_1":
    struct Point:
        x: f64
        y: f64

    a = Point(x: 1, y: 2)
    b = a              # copies the values x=1, y=2 into b
    # a.x = 5          # Error: Point is immutable by default
    assert_compiles()

## Test: Structs (Value Types) (Line ~21)

"""
Unless marked `mut`, a struct's fields cannot be changed after construction:
"""
test "structs_value_types_2":
    mut struct Cursor:
        x: f64
        y: f64

    val c = Cursor(x: 0, y: 0)
    c.x = 10           # OK: Cursor is mutable
    assert_compiles()

## Test: Classes (Reference Types) (Line ~7)

"""
Classes are reference types, allocated on the heap and managed by the runtime (with garbage collecti...
"""
test "classes_reference_types_3":
    class Person:
        name: String
        age: i32

        fn birthday():
            self.age = self.age + 1

    val p = Person(name: "Alice", age: 30)
    p.birthday()          # now age is 31
    assert_compiles()

## Test: Classes (Reference Types) (Line ~23)

"""
By default, class instances are mutable. Use `immut` for immutable classes:
"""
test "classes_reference_types_4":
    immut class Color:
        red: u8
        green: u8
        blue: u8

    # Fields cannot be changed after construction
    assert_compiles()

## Test: Classes (Reference Types) (Line ~42)

"""
- Mutable by default - Use `immut class` for immutable classes
- Reference equality by default - Ove...
"""
test "classes_reference_types_5":
    val p = Person(name: "Alice", age: 30)
    val q = p              # q and p refer to the same object
    q.age = 31             # p.age is also 31
    assert_compiles()

## Test: Auto-Forwarding Properties (get/set/is) (Line ~7)

"""
Simple provides automatic property forwarding for methods prefixed with `get_`, `set_`, or `is_`. Th...
"""
test "auto_forwarding_properties_getsetis_6":
    class Person:
        # These methods auto-create private backing field '_name'
        fn get_name() -> str:
            return _name

        fn set_name(value: str):
            _name = value

        # 'is_' prefix for boolean properties
        fn is_active() -> bool:
            return _active

    val p = Person()
    p.set_name("Alice")      # Sets _name
    print p.get_name()       # Gets _name -> "Alice"
    assert_compiles()

## Test: Auto-Forwarding Properties (get/set/is) (Line ~37)

"""
If only `get_` is defined, the property is read-only from outside:
"""
test "auto_forwarding_properties_getsetis_7":
    class Counter:
        fn get_count() -> i64:
            return _count

        fn increment():
            _count = _count + 1  # Internal modification OK

    val c = Counter()
    c.increment()
    print c.get_count()  # OK: 1
    # c.set_count(100)   # Error: no setter defined
    assert_compiles()

## Test: Auto-Forwarding Properties (get/set/is) (Line ~55)

"""
If only `set_` is defined, the property is write-only from outside:
"""
test "auto_forwarding_properties_getsetis_8":
    class SecureData:
        fn set_password(value: str):
            _password = hash(value)

        fn verify(input: str) -> bool:
            return hash(input) == _password

    val s = SecureData()
    s.set_password("secret123")
    # print s.get_password()  # Error: no getter defined
    assert_compiles()

## Test: Enums (Algebraic Data Types) (Line ~7)

"""
Enums define a type that can be one of several variants, each possibly carrying data. They are algeb...
"""
test "enums_algebraic_data_types_9":
    enum Result<T>:
        Ok(value: T)
        Err(error: String)
    assert_compiles()

## Test: Enums (Algebraic Data Types) (Line ~19)

"""
Enums are typically used with pattern matching:
"""
fn handle(result: Result<i64>):
    match result:
        case Ok(val):
            print "Success: {val}"
        case Err(msg):
            print "Error: {msg}"

## Test: Enums (Algebraic Data Types) (Line ~39)

"""
Enums can have methods added via impl blocks:
"""
test "enums_algebraic_data_types_11":
    enum Shape:
        Circle(radius: f64)
        Rectangle(width: f64, height: f64)

    impl Shape:
        fn area() -> f64:
            match self:
                case Circle(r): return 3.14159 * r * r
                case Rectangle(w, h): return w * h

        fn scale(factor: f64) -> Shape:
            match self:
                case Circle(r): return Shape.Circle(radius: r * factor)
                case Rectangle(w, h): return Shape.Rectangle(width: w * factor, height: h * factor)

        # Associated function (no self)
        fn unit_circle() -> Shape:
            return Shape.Circle(radius: 1.0)

    # Usage
    val s = Shape.Circle(radius: 5.0)
    print s.area()           # 78.54
    val s2 = s.scale(2.0)    # Circle with radius 10.0
    assert_compiles()

## Test: Enums (Algebraic Data Types) (Line ~67)

"""
fn scale(factor: f64) -> Shape:
        match self:
            case Circle(r): return Shape.C...
"""
test "enums_algebraic_data_types_12":
    trait Drawable:
        fn draw()

    impl Drawable for Shape:
        fn draw():
            match self:
                case Circle(r): draw_circle(r)
                case Rectangle(w, h): draw_rect(w, h)

    # Common traits can be derived
    #[derive(Eq, Clone, Debug)]
    enum Color:
        Red
        Green
        Blue
    assert_compiles()

## Test: Strong Enums (Line ~7)

"""
The `#[strong]` attribute enforces exhaustive explicit matching, disallowing wildcard `_` patterns.
"""
test "strong_enums_13":
    #[strong]
    enum HttpStatus:
        Ok
        NotFound
        ServerError
        BadRequest
        Unauthorized

    fn handle_status(status: HttpStatus) -> str:
        match status:
            case Ok: "Success"
            case NotFound: "Not found"
            case ServerError: "Server error"
            case BadRequest: "Bad request"
            case Unauthorized: "Unauthorized"
            # No _ allowed - all cases must be explicit
    assert_compiles()

## Test: Strong Enums (Line ~30)

"""
Strong enums prevent bugs when new variants are added:
"""
test "strong_enums_14":
    # Without #[strong] - wildcard hides missing cases
    enum Status:
        Active
        Inactive
        Pending      # Added later

    fn process(s: Status):
        match s:
            case Active: activate()
            case Inactive: deactivate()
            case _: pass     # Silently ignores Pending - BUG!

    # With #[strong] - compiler catches missing cases
    #[strong]
    enum Status:
        Active
        Inactive
        Pending

    fn process(s: Status):
        match s:
            case Active: activate()
            case Inactive: deactivate()
            # ERROR: missing case 'Pending', wildcards not allowed
    assert_compiles()

## Test: Strong Enums (Line ~70)

"""
Use `#[allow(wildcard_match)]` to allow wildcards in specific functions:
"""
test "strong_enums_15":
    #[allow(wildcard_match)]
    fn handle_some(e: Event):
        match e:
            case Click: on_click()
            case _: pass     # OK with attribute
    assert_compiles()

## Test: Union Types (Line ~7)

"""
Simple supports union types for cases where a variable might hold one of multiple types.
"""
fn example(x: i64 | str):
    match x:
        case i: i64:
            print "Integer: {i}"
        case s: String:
            print "String: {s}"

## Test: Option Type (Line ~5)

"""
A common enum representing "something or nothing":
"""
test "option_type_17":
    enum Option<T>:
        Some(value: T)
        None

    fn find(id: UserId) -> Option<User>:
        match lookup(id):
            case found:
                return Some(found)
            case _:
                return None
    assert_compiles()

## Test: Option Type (Line ~20)

"""
Important: Simple requires explicit `Option<T>` for nullable values. Implicit `nil` is a compile err...
"""
test "option_type_18":
    # ERROR: Implicit nullable return
    fn find_user(id: UserId) -> User:  # Compile error if function can return nil
        ...

    # CORRECT: Explicit Option
    fn find_user(id: UserId) -> Option<User>:
        ...
    assert_compiles()

## Test: Visibility and Access (Line ~5)

"""
By default, all struct and class fields are publicly readable but only modifiable according to mutab...
"""
test "visibility_and_access_19":
    class User:
        pub id: UserId           # Public field - uses semantic type
        pub name: str            # OK: str is allowed in public APIs
        pub status: UserStatus   # Uses enum instead of bool
        private password: str    # Private field

        fn verify(input: str) -> bool:   # OK: bool in private method
            return hash(input) == self.password
    assert_compiles()

## Test: Result Type (Line ~5)

"""
A common enum representing "success or error":
"""
test "result_type_20":
    enum Result<T, E>:
        Ok(value: T)
        Err(error: E)

    fn parse_int(s: str) -> Result<i64, ParseError>:
        if s.is_numeric():
            return Ok(s.to_int())
        return Err(ParseError(msg: "Invalid number: {s}"))
    assert_compiles()

## Test: Result Type (Line ~20)

"""
The `?` operator propagates errors automatically:
"""
fn read_config() -> Result<Config, IoError>:
    val content = read_file("config.toml")?  # Returns early if Err
    val parsed = parse_toml(content)?        # Returns early if Err
    return Ok(Config(parsed))

# Equivalent to:
fn read_config_verbose() -> Result<Config, IoError>:
    match read_file("config.toml"):
        case Ok(content):
            match parse_toml(content):
                case Ok(parsed): return Ok(Config(parsed))
                case Err(e): return Err(e)
        case Err(e): return Err(e)

## Test: Result Type (Line ~38)

"""
```simple
fn read_config() -> Result<Config, IoError>:
    val content = read_file("config.toml")?  ...
"""
test "result_type_22":
    impl Result<T, E>:
        fn is_ok() -> bool
        fn is_err() -> bool
        fn unwrap() -> T                    # Panics if Err
        fn unwrap_or(default: T) -> T
        fn unwrap_err() -> E                # Panics if Ok
        fn map<U>(f: fn(T) -> U) -> Result<U, E>
        fn map_err<F>(f: fn(E) -> F) -> Result<T, F>
        fn and_then<U>(f: fn(T) -> Result<U, E>) -> Result<U, E>
    assert_compiles()

## Test: Result Type (Line ~52)

"""
```simple
impl Result<T, E>:
    fn is_ok() -> bool
    fn is_err() -> bool
    fn unwrap() -> T    ...
"""
test "result_type_23":
    # These are equivalent:
    fn foo() -> Result<i64, Error>
    fn foo() -> i64 | Error
    assert_compiles()

## Test: Bitfields (Line ~7)

"""
Bitfields allow compact representation of data at the bit level, useful for hardware registers, prot...
"""
test "bitfields_24":
    bitfield Flags(u8):
        readable: 1      # bit 0
        writable: 1      # bit 1
        executable: 1    # bit 2
        _reserved: 5     # bits 3-7 (padding, not accessible)
    assert_compiles()

## Test: Bitfields (Line ~19)

"""
The backing type (`u8`, `u16`, `u32`, `u64`) determines the total size.
"""
test "bitfields_25":
    val f = Flags(readable: 1, writable: 1, executable: 0)
    print f.readable     # 1
    f.writable = 0       # Clear write bit
    val raw = f.raw()    # Get underlying u8 value: 0b00000001
    assert_compiles()

## Test: Bitfields (Line ~30)

"""
Fields can span multiple bits:
"""
test "bitfields_26":
    bitfield Color(u32):
        red: 8           # bits 0-7
        green: 8         # bits 8-15
        blue: 8          # bits 16-23
        alpha: 8         # bits 24-31

    val c = Color(red: 255, green: 128, blue: 64, alpha: 255)
    assert_compiles()

## Test: Bitfields (Line ~51)

"""
| Property | Description |
|----------|-------------|
| Packed | Fields are tightly packed with no p...
"""
test "bitfields_27":
    bitfield Permission(u8):
        read: 1
        write: 1
        execute: 1

        const READ_ONLY = Permission(read: 1, write: 0, execute: 0)
        const READ_WRITE = Permission(read: 1, write: 1, execute: 0)
        const FULL = Permission(read: 1, write: 1, execute: 1)
    assert_compiles()

## Test: Bitfields (Line ~70)

"""
Use `suffix:repr` for simple bit-width specification. In type positions, use bare unit suffix (no un...
"""
test "bitfields_28":
    bitfield RobotArm:
        x: cm:i12           # 12-bit signed centimeters
        y: cm:i12           # 12-bit signed centimeters
        z: cm:u10           # 10-bit unsigned centimeters
        angle: deg:u9       # 9-bit unsigned degrees (0-511)
        grip: pct:u7        # 7-bit percentage (0-100)

    # Literals still use underscore prefix
    val arm = RobotArm(x: 100_cm, y: -50_cm, z: 200_cm, angle: 180_deg, grip: 75_pct)
    print arm.x              # 100_cm (typed value, not raw bits)
    print arm.angle          # 180_deg
    assert_compiles()

## Test: Bitfields (Line ~88)

"""
Use `where` for range inference, overflow behavior, and debug checking:
"""
test "bitfields_29":
    bitfield SensorData:
        # Range inference - compiler calculates minimum bits
        temp: celsius where range: -40..125            # infers i8
        humidity: pct where range: 0..100              # infers u7

        # Explicit repr + overflow behavior
        pressure: hpa:u16 where checked                # panic on overflow
        altitude: m:i16 where saturate                 # clamp to min/max
        heading: deg:u9 where wrap                     # modular arithmetic (0-511)

    bitfield MotorControl:
        # Combined constraints
        position: cm where range: -1000..1000, checked     # i11, debug-checked
        velocity: mps:u8 where saturate                    # clamp to 0-255
        torque: nm where range: 0..100, default: 0_nm      # with default value
    assert_compiles()

## Test: Bitfields (Line ~146)

"""
Unit-typed bitfield fields maintain full type safety:
"""
test "bitfields_30":
    bitfield Position:
        x: cm:i12
        y: cm:i12

    val pos = Position(x: 100_cm, y: 200_cm)
    # pos.x = 50_m      # ERROR: cannot assign m to cm field
    # pos.x = 50        # ERROR: cannot assign bare integer to cm field
    pos.x = 50_cm       # OK: same unit type

    # Arithmetic preserves unit type
    val new_x = pos.x + 10_cm    # Result: cm:i12
    assert_compiles()

## Test: Bitfields (Line ~162)

"""
val pos = Position(x: 100_cm, y: 200_cm)
# pos.x = 50_m      # ERROR: cannot assign m to cm field
# ...
"""
test "bitfields_31":
    bitfield Compact:
        dist: cm:u8

    bitfield Wide:
        dist: cm:u16

    val c = Compact(dist: 100_cm)
    val w = Wide(dist: c.dist.widen())    # Explicit widening
    # val w2 = Wide(dist: c.dist)         # OK: implicit widening allowed

    val c2 = Compact(dist: w.dist.narrow())   # Explicit narrowing (checked)
    val c3 = Compact(dist: w.dist.saturate()) # Clamp to 0-255
    assert_compiles()

## Test: Bitfields (Line ~181)

"""
In debug builds, assignments to bit-limited fields are checked:
"""
test "bitfields_32":
    bitfield Test:
        value: cm:u8              # 0-255 range

    val t = Test(value: 255_cm)   # OK
    # t.value = 256_cm            # Debug: panic! Release: undefined behavior

    bitfield SafeTest:
        value: cm:u8 where checked    # Always checked

    val s = SafeTest(value: 255_cm)
    # s.value = 256_cm            # Always panic (debug and release)

    bitfield ClampTest:
        value: cm:u8 where saturate

    val cl = ClampTest(value: 300_cm)
    print cl.value                # 255_cm (clamped)
    assert_compiles()

