# @pending
use std.spec.{check, check_msg}

"""
# Shell API Specification

use std.spec.{check, check_msg}

**Status:** Implementing
use std.spec.{check, check_msg}

**Feature IDs:** #900-905
use std.spec.{check, check_msg}

**Keywords:** shell, process, filesystem, io, scripting
use std.spec.{check, check_msg}

**Topics:** stdlib, scripting

## Overview

use std.spec.{check, check_msg}

Shell API provides access to system operations commonly used in shell scripts:
use std.spec.{check, check_msg}

- Process execution with output capture
use std.spec.{check, check_msg}

- File system operations (read, write, list, delete)
use std.spec.{check, check_msg}

- Path manipulation
use std.spec.{check, check_msg}

- Environment variables
use std.spec.{check, check_msg}

- Exit codes and error handling

use std.spec.{check, check_msg}

This API enables writing shell scripts in Simple language, replacing Python and Bash scripts.

## Design Goals

use std.spec.{check, check_msg}

1. **Simple and intuitive** - Match common shell/Python patterns
use std.spec.{check, check_msg}

2. **Safe by default** - Error handling built-in
use std.spec.{check, check_msg}

3. **Cross-platform** - Works on Linux, macOS, Windows
use std.spec.{check, check_msg}

4. **Composable** - Easy to chain operations
use std.spec.{check, check_msg}

5. **Testable** - Can be unit tested unlike shell scripts

## Related Specifications

use std.spec.{check, check_msg}

- **File I/O** - File operations
use std.spec.{check, check_msg}

- **Process Management** - Process control
use std.spec.{check, check_msg}

- **Error Handling** - Result types
use std.spec.{check, check_msg}

"""

## Test: Process Execution

use std.spec.{check, check_msg}

"""
### Scenario: Execute command and capture output

use std.spec.{check, check_msg}

Shell scripts frequently need to run commands and capture their output.
use std.spec.{check, check_msg}

The API should make this simple and handle errors gracefully.
use std.spec.{check, check_msg}

"""

use std.spec.{check, check_msg}

it "execute_command_basic":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Execute a simple command and get output as string.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    val result = shell.run("echo hello")
use std.spec.{check, check_msg}

    check(result.ok())
use std.spec.{check, check_msg}

    check(result.stdout == "hello\n")
use std.spec.{check, check_msg}

    check(result.exit_code == 0)

use std.spec.{check, check_msg}

it "execute_command_with_args":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Execute command with arguments safely (no shell injection).
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    val result = shell.run("ls", ["-la", "/tmp"])
use std.spec.{check, check_msg}

    check(result.ok())
use std.spec.{check, check_msg}

    check(result.stdout.contains("total"))

use std.spec.{check, check_msg}

it "execute_command_capture_stderr":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Capture both stdout and stderr separately.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    val result = shell.run("ls /nonexistent")
use std.spec.{check, check_msg}

    check(not result.ok())
use std.spec.{check, check_msg}

    check(result.stderr.contains("No such file"))
use std.spec.{check, check_msg}

    check(result.exit_code != 0)

## Test: File Operations

use std.spec.{check, check_msg}

"""
### Scenario: Read and write files

use std.spec.{check, check_msg}

Common file operations needed by scripts.
use std.spec.{check, check_msg}

"""

use std.spec.{check, check_msg}

it "read_file_contents":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Read entire file as string.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    val content = file.read_text("/etc/hostname")
use std.spec.{check, check_msg}

    check(content.len() > 0)
use std.spec.{check, check_msg}

    check(not content.contains("\0"))

use std.spec.{check, check_msg}

it "write_file_contents":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Write string to file, creating if needed.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    file.write_text("/tmp/test.txt", "hello world")
use std.spec.{check, check_msg}

    val content = file.read_text("/tmp/test.txt")
use std.spec.{check, check_msg}

    check(content == "hello world")

use std.spec.{check, check_msg}

it "append_to_file":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Append to existing file.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    file.write_text("/tmp/test.txt", "line 1\n")
use std.spec.{check, check_msg}

    file.append_text("/tmp/test.txt", "line 2\n")
use std.spec.{check, check_msg}

    val content = file.read_text("/tmp/test.txt")
use std.spec.{check, check_msg}

    check(content == "line 1\nline 2\n")

use std.spec.{check, check_msg}

it "check_file_exists":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Check if file or directory exists.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    check(file.exists("/etc/hostname"))
use std.spec.{check, check_msg}

    check(not file.exists("/nonexistent/file.txt"))

## Test: Directory Operations

use std.spec.{check, check_msg}

"""
### Scenario: List and manipulate directories

use std.spec.{check, check_msg}

Scripts often need to traverse directories and find files.
use std.spec.{check, check_msg}

"""

use std.spec.{check, check_msg}

it "list_directory":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    List all entries in a directory.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    val entries = dir.list("/tmp")
use std.spec.{check, check_msg}

    check(entries.len() > 0)
use std.spec.{check, check_msg}

    # Returns list of names
use std.spec.{check, check_msg}

    check(entries.all(fn(e): e is str))

use std.spec.{check, check_msg}

it "list_directory_with_pattern":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    List files matching a glob pattern.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    val txt_files = dir.glob("/tmp", "*.txt")
use std.spec.{check, check_msg}

    # All entries should end with .txt
use std.spec.{check, check_msg}

    check(txt_files.all(fn(f): f.ends_with(".txt")))

use std.spec.{check, check_msg}

it "create_directory":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Create directory with parents.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    dir.create("/tmp/test/nested/path", recursive: true)
use std.spec.{check, check_msg}

    check(dir.exists("/tmp/test/nested/path"))

use std.spec.{check, check_msg}

it "remove_directory":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Remove directory and contents.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    dir.remove("/tmp/test", recursive: true)
use std.spec.{check, check_msg}

    check(not dir.exists("/tmp/test"))

## Test: Path Operations

use std.spec.{check, check_msg}

"""
### Scenario: Manipulate file paths

use std.spec.{check, check_msg}

Path operations are common in scripts for building file paths.
use std.spec.{check, check_msg}

"""

use std.spec.{check, check_msg}

it "join_paths":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Join path components safely.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    val path = path.join("/home", "user", "file.txt")
use std.spec.{check, check_msg}

    check(path == "/home/user/file.txt")

use std.spec.{check, check_msg}

it "get_basename":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Extract filename from path.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    check(path.basename("/home/user/file.txt") == "file.txt")
use std.spec.{check, check_msg}

    check(path.basename("/home/user/") == "user")

use std.spec.{check, check_msg}

it "get_dirname":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Extract directory from path.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    check(path.dirname("/home/user/file.txt") == "/home/user")

use std.spec.{check, check_msg}

it "get_extension":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Extract file extension.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    check(path.ext("/home/user/file.txt") == ".txt")
use std.spec.{check, check_msg}

    check(path.ext("/home/user/archive.tar.gz") == ".gz")

use std.spec.{check, check_msg}

it "absolute_path":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Convert relative path to absolute.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    val abs = path.absolute("../file.txt")
use std.spec.{check, check_msg}

    check(abs.starts_with("/"))

## Test: Environment Variables

use std.spec.{check, check_msg}

"""
### Scenario: Access environment variables

use std.spec.{check, check_msg}

Scripts need to read and set environment variables.
use std.spec.{check, check_msg}

"""

use std.spec.{check, check_msg}

it "get_environment_variable":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Read environment variable with default.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    val home = env.get("HOME", default: "/tmp")
use std.spec.{check, check_msg}

    check(home.len() > 0)
use std.spec.{check, check_msg}

    
use std.spec.{check, check_msg}

    val missing = env.get("NONEXISTENT_VAR", default: "default")
use std.spec.{check, check_msg}

    check(missing == "default")

use std.spec.{check, check_msg}

it "set_environment_variable":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Set environment variable for child processes.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    env.set("MY_VAR", "value")
use std.spec.{check, check_msg}

    val result = shell.run("echo $MY_VAR")
use std.spec.{check, check_msg}

    check(result.stdout.trim() == "value")

## Test: Error Handling

use std.spec.{check, check_msg}

"""
### Scenario: Handle errors gracefully

use std.spec.{check, check_msg}

Scripts need robust error handling.
use std.spec.{check, check_msg}

"""

use std.spec.{check, check_msg}

it "command_failure_result":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Failed commands return Result with error info.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    val result = shell.run("false")
use std.spec.{check, check_msg}

    check(not result.ok())
use std.spec.{check, check_msg}

    check(result.exit_code == 1)

use std.spec.{check, check_msg}

it "file_not_found_error":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    File operations return Result types.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    # This should return Result<str, Error>
use std.spec.{check, check_msg}

    # Can use ? operator or check explicitly
use std.spec.{check, check_msg}

    val result = try file.read_text("/nonexistent")
use std.spec.{check, check_msg}

    check(result.is_err())

## Test: Piping and Chaining

use std.spec.{check, check_msg}

"""
### Scenario: Chain commands like shell pipes

use std.spec.{check, check_msg}

Enable composable operations.
use std.spec.{check, check_msg}

"""

use std.spec.{check, check_msg}

it "pipe_commands":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Pipe output of one command to another.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    val result = shell.pipe([
use std.spec.{check, check_msg}

        ["echo", "hello world"],
use std.spec.{check, check_msg}

        ["grep", "world"],
use std.spec.{check, check_msg}

        ["wc", "-l"]
use std.spec.{check, check_msg}

    ])
use std.spec.{check, check_msg}

    check(result.stdout.trim() == "1")

use std.spec.{check, check_msg}

it "chain_operations":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Chain multiple file operations.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    file.write_text("/tmp/input.txt", "line1\nline2\nline3")
use std.spec.{check, check_msg}

    
use std.spec.{check, check_msg}

    val lines = file.read_text("/tmp/input.txt")
use std.spec.{check, check_msg}

        .split("\n")
use std.spec.{check, check_msg}

        .filter(fn(l): l.len() > 0)
use std.spec.{check, check_msg}

    
use std.spec.{check, check_msg}

    check(lines.len() == 3)

## Test: Script Utilities

use std.spec.{check, check_msg}

"""
### Scenario: Common script utilities

use std.spec.{check, check_msg}

Helper functions for common script patterns.
use std.spec.{check, check_msg}

"""

use std.spec.{check, check_msg}

it "find_files_recursive":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Find all files matching pattern recursively.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    val files = file.find("/tmp", pattern: "*.txt", recursive: true)
use std.spec.{check, check_msg}

    check(files.all(fn(f): f.ends_with(".txt")))

use std.spec.{check, check_msg}

it "copy_file":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Copy file from source to destination.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    file.write_text("/tmp/source.txt", "content")
use std.spec.{check, check_msg}

    file.copy("/tmp/source.txt", "/tmp/dest.txt")
use std.spec.{check, check_msg}

    check(file.read_text("/tmp/dest.txt") == "content")

use std.spec.{check, check_msg}

it "move_file":
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    Move/rename file.
use std.spec.{check, check_msg}

    """
use std.spec.{check, check_msg}

    file.write_text("/tmp/old.txt", "content")
use std.spec.{check, check_msg}

    file.move("/tmp/old.txt", "/tmp/new.txt")
use std.spec.{check, check_msg}

    check(file.exists("/tmp/new.txt"))
use std.spec.{check, check_msg}

    check(not file.exists("/tmp/old.txt"))
