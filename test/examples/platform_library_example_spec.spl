# Platform Abstraction Library - Example Demonstrations
#
# This file demonstrates all key features of the platform library
# and serves as both documentation and verification.

use std.platform.config.{host_config, make_config, network_config}
use std.platform.convert.{send_u32, recv_u32, send_text, recv_text}
use std.platform.wire.{wire_writer_network, wire_reader_new}
use std.platform.text_io.{text_file_write_local, text_file_read_local}
use std.common.target.{TargetArch, TargetOS}

describe "Platform Library Examples":

    it "Example 1: Auto-detect host platform":
        val host = host_config()

        # Platform information is automatically detected
        val arch_name = host.arch.name()
        val os_name = host.os.name()
        val endian_name = host.endian.name()

        print "  Host: {arch_name}-{os_name} ({endian_name}-endian)"

        # Verify detection worked
        expect(arch_name.len() > 0).to_equal(true)
        expect(os_name.len() > 0).to_equal(true)
        expect(host.pointer_bytes > 0).to_equal(true)

    it "Example 2: Same-platform conversion (zero-cost no-op)":
        val host = host_config()
        val value = 42

        # When host == remote, no conversion happens
        val result = send_u32(host, host, value)

        print "  Value: {value} → {result} (no conversion)"

        expect(result).to_equal(value)

    it "Example 3: Cross-endian byte swapping":
        # Create configs for little-endian and big-endian platforms
        val le = make_config(TargetArch.X86_64, TargetOS.Linux)
        val be = make_config(TargetArch.MCS51, TargetOS.BareMetal)

        val original = 0x12345678
        val swapped = send_u32(le, be, original)
        val restored = recv_u32(le, be, swapped)

        print "  LE: 0x{original:x} → BE: 0x{swapped:x} → LE: 0x{restored:x}"

        # Verify byte swap happened
        expect(swapped).to_equal(0x78563412)
        # Verify round-trip
        expect(restored).to_equal(original)

    it "Example 4: Network byte order (always big-endian)":
        val host = host_config()
        val net = network_config()

        val value = 0x1A2B3C4D
        val network_val = send_u32(host, net, value)
        val restored = recv_u32(host, net, network_val)

        print "  Local: 0x{value:x} → Network: 0x{network_val:x}"

        # Network byte order is big-endian
        expect(network_val == 0x4D3C2B1A or network_val == value).to_equal(true)
        # Round-trip works
        expect(restored).to_equal(value)

    it "Example 5: Text newline conversion (LF ↔ CRLF)":
        val unix = make_config(TargetArch.X86_64, TargetOS.Linux)
        val win = make_config(TargetArch.X86_64, TargetOS.Windows)

        val unix_text = "Line1\nLine2\nLine3"
        val win_text = send_text(unix, win, unix_text)
        val back = recv_text(unix, win, win_text)

        print "  Unix ({unix_text.len()}b) → Win ({win_text.len()}b) → Unix ({back.len()}b)"

        # Windows text is longer (CRLF vs LF)
        expect(win_text.len()).to_equal(24)
        expect(unix_text.len()).to_equal(18)
        # Round-trip preserves content
        expect(back).to_equal(unix_text)

    it "Example 6: Wire format serialization":
        # Serialize data in network byte order
        var writer = wire_writer_network()
        writer.write_u32(12345)
        writer.write_text("Protocol")
        writer.write_u32(67890)

        val bytes = writer.to_bytes()

        print "  Serialized {bytes.len()} bytes"

        # Deserialize from network byte order
        var reader = wire_reader_new(bytes, network_config())
        val n1 = reader.read_u32()
        val msg = reader.read_text()
        val n2 = reader.read_u32()

        print "  Deserialized: {n1}, \"{msg}\", {n2}"

        # Verify round-trip
        expect(n1).to_equal(12345)
        expect(msg).to_equal("Protocol")
        expect(n2).to_equal(67890)

    it "Example 7: Platform-aware file I/O":
        val path = "/tmp/platform_test.txt"
        val content = "First\nSecond\nThird\n"

        # Write with host platform newlines
        text_file_write_local(path, content)

        # Read back (normalized to LF)
        val read_back = text_file_read_local(path)

        print "  Wrote & read {content.len()} bytes"

        # Clean up
        use app.io.mod.{file_delete}
        file_delete(path)

        # Content preserved
        expect(read_back).to_equal(content)

    it "Example 8: Creating custom platform configs":
        # Create configs for various platforms
        val arm_linux = make_config(TargetArch.Arm, TargetOS.Linux)
        val riscv_bare = make_config(TargetArch.Riscv64, TargetOS.BareMetal)
        val x86_win = make_config(TargetArch.X86_64, TargetOS.Windows)

        print "  ARM/Linux: {arm_linux.pointer_bytes}b ptr, {arm_linux.newline.len()}b nl"
        print "  RISC-V bare: {riscv_bare.pointer_bytes}b ptr, {riscv_bare.newline.len()}b nl"
        print "  x86_64/Win: {x86_win.pointer_bytes}b ptr, {x86_win.newline.len()}b nl"

        # Verify configs
        expect(arm_linux.pointer_bytes).to_equal(4)
        expect(riscv_bare.pointer_bytes).to_equal(8)
        expect(x86_win.newline).to_equal("\r\n")

    it "Example 9: Checking platform compatibility":
        use std.platform.config.{same_platform, needs_swap}

        val host = host_config()
        val net = network_config()

        # Check if platforms are the same
        val is_same = same_platform(host, host)
        val needs_convert = needs_swap(host, net)

        print "  Same platform: {is_same}"
        print "  Needs swap: {needs_convert}"

        expect(is_same).to_equal(true)
