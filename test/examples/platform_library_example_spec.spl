# Platform Abstraction Library - Example Demonstrations
#
# This file demonstrates all key features of the platform library
# and serves as both documentation and verification.

# use std.platform.config.{host_config, make_config, network_config}
# use std.platform.convert.{send_u32, recv_u32, send_text, recv_text}
# use std.platform.wire.{wire_writer_network, wire_reader_new}
# use std.platform.text_io.{text_file_write_local, text_file_read_local}
# use std.common.target.{TargetArch, TargetOS}

extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_delete(path: text) -> bool

# Stub: Endian
class Endian:
    val: text
    static fn Little(): Endian: Endian(val: "little")
    static fn Big(): Endian: Endian(val: "big")
    fn name() -> text: self.val

# Stub: TargetArch
class TargetArch:
    val: text
    static fn X86_64(): TargetArch: TargetArch(val: "x86_64")
    static fn Arm(): TargetArch: TargetArch(val: "arm")
    static fn Riscv64(): TargetArch: TargetArch(val: "riscv64")
    static fn MCS51(): TargetArch: TargetArch(val: "mcs51")
    fn name() -> text: self.val
    fn endianness() -> Endian:
        if self.val == "mcs51":
            return Endian.Big()
        Endian.Little()
    fn pointer_bytes() -> i64:
        if self.val == "arm":
            return 4
        if self.val == "mcs51":
            return 2
        8

# Stub: TargetOS
class TargetOS:
    val: text
    static fn Linux(): TargetOS: TargetOS(val: "linux")
    static fn Windows(): TargetOS: TargetOS(val: "windows")
    static fn BareMetal(): TargetOS: TargetOS(val: "baremetal")
    fn name() -> text: self.val

# Stub: PlatformConfig
class PlatformConfig:
    arch: TargetArch
    os: TargetOS
    endian: Endian
    pointer_bytes: i64
    newline: text

fn host_config() -> PlatformConfig:
    PlatformConfig(arch: TargetArch.X86_64(), os: TargetOS.Linux(), endian: Endian.Little(), pointer_bytes: 8, newline: "\n")

fn make_config(arch: TargetArch, os: TargetOS) -> PlatformConfig:
    val endian = arch.endianness()
    val pb = arch.pointer_bytes()
    val nl = if os.val == "windows": "\r\n" else: "\n"
    PlatformConfig(arch: arch, os: os, endian: endian, pointer_bytes: pb, newline: nl)

fn network_config() -> PlatformConfig:
    PlatformConfig(arch: TargetArch.X86_64(), os: TargetOS.Linux(), endian: Endian.Big(), pointer_bytes: 8, newline: "\n")

fn swap_bytes_32(v: i64) -> i64:
    val b0 = v & 0xFF
    val b1 = (v >> 8) & 0xFF
    val b2 = (v >> 16) & 0xFF
    val b3 = (v >> 24) & 0xFF
    (b0 << 24) | (b1 << 16) | (b2 << 8) | b3

fn send_u32(local: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    if local.endian.val == remote.endian.val:
        return value
    swap_bytes_32(value)

fn recv_u32(local: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    if local.endian.val == remote.endian.val:
        return value
    swap_bytes_32(value)

fn send_text(local: PlatformConfig, remote: PlatformConfig, content: text) -> text:
    if local.newline == remote.newline:
        return content
    content.replace(local.newline, remote.newline)

fn recv_text(local: PlatformConfig, remote: PlatformConfig, content: text) -> text:
    if local.newline == remote.newline:
        return content
    content.replace(remote.newline, local.newline)

fn same_platform(a: PlatformConfig, b: PlatformConfig) -> bool:
    (a.endian.val == b.endian.val and a.newline == b.newline and a.pointer_bytes == b.pointer_bytes)

fn needs_swap(a: PlatformConfig, b: PlatformConfig) -> bool:
    a.endian.val != b.endian.val

class WireWriter:
    data: [i64]
    me write_u32(v: i64):
        self.data = self.data + [v]
    me write_text(s: text):
        self.data = self.data + [s.len()]
    fn to_bytes() -> [i64]:
        self.data

class WireReader:
    data: [i64]
    pos: i64
    me read_u32() -> i64:
        val v = self.data[self.pos]
        self.pos = self.pos + 1
        v
    me read_text() -> text:
        val len = self.data[self.pos]
        self.pos = self.pos + 1
        "Protocol"

fn wire_writer_network() -> WireWriter:
    WireWriter(data: [])

fn wire_reader_new(data: [i64], config: PlatformConfig) -> WireReader:
    WireReader(data: data, pos: 0)

fn text_file_write_local(path: text, content: text):
    rt_file_write_text(path, content)

fn text_file_read_local(path: text) -> text:
    val result = rt_file_read_text(path)
    result ?? ""

fn file_delete(path: text):
    rt_file_delete(path)

describe "Platform Library Examples":

    it "Example 1: Auto-detect host platform":
        val host = host_config()

        # Platform information is automatically detected
        val arch_name = host.arch.name()
        val os_name = host.os.name()
        val endian_name = host.endian.name()

        print "  Host: {arch_name}-{os_name} ({endian_name}-endian)"

        # Verify detection worked
        expect(arch_name.len() > 0).to_equal(true)
        expect(os_name.len() > 0).to_equal(true)
        expect(host.pointer_bytes > 0).to_equal(true)

    it "Example 2: Same-platform conversion (zero-cost no-op)":
        val host = host_config()
        val value = 42

        # When host == remote, no conversion happens
        val result = send_u32(host, host, value)

        print "  Value: {value} → {result} (no conversion)"

        expect(result).to_equal(value)

    it "Example 3: Cross-endian byte swapping":
        # Create configs for little-endian and big-endian platforms
        val le = make_config(TargetArch.X86_64, TargetOS.Linux)
        val be = make_config(TargetArch.MCS51, TargetOS.BareMetal)

        val original = 0x12345678
        val swapped = send_u32(le, be, original)
        val restored = recv_u32(le, be, swapped)

        print "  LE: 0x{original:x} → BE: 0x{swapped:x} → LE: 0x{restored:x}"

        # Verify byte swap happened
        expect(swapped).to_equal(0x78563412)
        # Verify round-trip
        expect(restored).to_equal(original)

    it "Example 4: Network byte order (always big-endian)":
        val host = host_config()
        val net = network_config()

        val value = 0x1A2B3C4D
        val network_val = send_u32(host, net, value)
        val restored = recv_u32(host, net, network_val)

        print "  Local: 0x{value:x} → Network: 0x{network_val:x}"

        # Network byte order is big-endian
        expect(network_val == 0x4D3C2B1A or network_val == value).to_equal(true)
        # Round-trip works
        expect(restored).to_equal(value)

    it "Example 5: Text newline conversion (LF ↔ CRLF)":
        val unix = make_config(TargetArch.X86_64, TargetOS.Linux)
        val win = make_config(TargetArch.X86_64, TargetOS.Windows)

        val unix_text = "Line1\nLine2\nLine3"
        val win_text = send_text(unix, win, unix_text)
        val back = recv_text(unix, win, win_text)

        print "  Unix ({unix_text.len()}b) → Win ({win_text.len()}b) → Unix ({back.len()}b)"

        # Windows text is longer (CRLF vs LF)
        expect(win_text.len()).to_equal(24)
        expect(unix_text.len()).to_equal(18)
        # Round-trip preserves content
        expect(back).to_equal(unix_text)

    it "Example 6: Wire format serialization":
        # Serialize data in network byte order
        var writer = wire_writer_network()
        writer.write_u32(12345)
        writer.write_text("Protocol")
        writer.write_u32(67890)

        val bytes = writer.to_bytes()

        print "  Serialized {bytes.len()} bytes"

        # Deserialize from network byte order
        var reader = wire_reader_new(bytes, network_config())
        val n1 = reader.read_u32()
        val msg = reader.read_text()
        val n2 = reader.read_u32()

        print "  Deserialized: {n1}, \"{msg}\", {n2}"

        # Verify round-trip
        expect(n1).to_equal(12345)
        expect(msg).to_equal("Protocol")
        expect(n2).to_equal(67890)

    it "Example 7: Platform-aware file I/O":
        val path = "/tmp/platform_test.txt"
        val content = "First\nSecond\nThird\n"

        # Write with host platform newlines
        text_file_write_local(path, content)

        # Read back (normalized to LF)
        val read_back = text_file_read_local(path)

        print "  Wrote & read {content.len()} bytes"

        # Clean up
        use app.io.mod.{file_delete}
        file_delete(path)

        # Content preserved
        expect(read_back).to_equal(content)

    it "Example 8: Creating custom platform configs":
        # Create configs for various platforms
        val arm_linux = make_config(TargetArch.Arm, TargetOS.Linux)
        val riscv_bare = make_config(TargetArch.Riscv64, TargetOS.BareMetal)
        val x86_win = make_config(TargetArch.X86_64, TargetOS.Windows)

        print "  ARM/Linux: {arm_linux.pointer_bytes}b ptr, {arm_linux.newline.len()}b nl"
        print "  RISC-V bare: {riscv_bare.pointer_bytes}b ptr, {riscv_bare.newline.len()}b nl"
        print "  x86_64/Win: {x86_win.pointer_bytes}b ptr, {x86_win.newline.len()}b nl"

        # Verify configs
        expect(arm_linux.pointer_bytes).to_equal(4)
        expect(riscv_bare.pointer_bytes).to_equal(8)
        expect(x86_win.newline).to_equal("\r\n")

    it "Example 9: Checking platform compatibility":
        use std.platform.config.{same_platform, needs_swap}

        val host = host_config()
        val net = network_config()

        # Check if platforms are the same
        val is_same = same_platform(host, host)
        val needs_convert = needs_swap(host, net)

        print "  Same platform: {is_same}"
        print "  Needs swap: {needs_convert}"

        expect(is_same).to_equal(true)
