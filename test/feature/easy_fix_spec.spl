# @pending
"""
# EasyFix Auto-Fix System Specification

**Feature IDs:** #2200-2210
**Category:** Tooling
**Difficulty:** 3/5
**Status:** Implemented

## Overview

The EasyFix system provides machine-applicable fixes for diagnostics (errors,
warnings, info). It integrates with compilation, linting, and an interactive
prompt mode. Each fix has a confidence level (Safe, Likely, Uncertain) that
determines whether it can be auto-applied.

## Syntax

```simple
# Fix flags on CLI:
# simple lint --fix           Apply safe fixes
# simple lint --fix-all       Apply all fixes
# simple lint --fix-dry-run   Preview fixes
# simple lint --fix-interactive  Prompt per fix
# simple fix file.spl         Standalone fix command
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| EasyFix | A machine-applicable fix with ID, description, replacements, confidence |
| Replacement | A text substitution: file, span (start/end), new_text |
| FixConfidence | Safe (auto-apply), Likely (review), Uncertain (human review) |
| FixApplicator | Engine that sorts, validates, and applies replacements |
| FixReport | Summary of applied/skipped fixes and modified files |

## Behavior

- Fixes are attached to diagnostics via `easy_fix: Option<EasyFix>`
- Replacements are applied from end-to-start to preserve byte offsets
- Overlapping spans are detected and rejected as conflicts
- Confidence levels control which fixes are auto-applied
- Interactive mode prompts: [y]es / [n]o / [a]ll / [q]uit
"""

use std.tooling.easy_fix.*

# ============================================================================
# Test Group 1: EasyFix Data Structures
# ============================================================================

describe "EasyFix Data Structures":
    """
    ## Core Data Model

    Validates the EasyFix, Replacement, and FixConfidence types
    that form the foundation of the auto-fix system.
    """

    context "FixConfidence enum":
        """
        ### Scenario: Confidence Levels

        Three levels of confidence determine auto-apply behavior:
        Safe (auto), Likely (review), Uncertain (human required).
        """

        it "has Safe level":
            val c = FixConfidence.Safe
            expect c == FixConfidence.Safe

        it "has Likely level":
            val c = FixConfidence.Likely
            expect c == FixConfidence.Likely

        it "has Uncertain level":
            val c = FixConfidence.Uncertain
            expect c == FixConfidence.Uncertain

        it "Safe != Likely":
            expect FixConfidence.Safe != FixConfidence.Likely

        it "Safe != Uncertain":
            expect FixConfidence.Safe != FixConfidence.Uncertain

        it "Likely != Uncertain":
            expect FixConfidence.Likely != FixConfidence.Uncertain

    context "Replacement creation":
        """
        ### Scenario: Text Replacement Records

        Each replacement specifies a file, byte span, and new text.
        """

        it "creates a replacement with all fields":
            val rep = Replacement.create(
                file: "test.spl",
                start: 10,
                end: 15,
                line: 2,
                column: 5,
                new_text: "new_value"
            )
            expect rep.file == "test.spl"
            expect rep.start == 10
            expect rep.end == 15
            expect rep.line == 2
            expect rep.column == 5
            expect rep.new_text == "new_value"

        it "creates a zero-length insertion":
            val rep = Replacement.create(
                file: "test.spl",
                start: 10,
                end: 10,
                line: 1,
                column: 11,
                new_text: "inserted "
            )
            expect rep.start == rep.end
            expect rep.new_text == "inserted "

        it "creates a deletion (empty new_text)":
            val rep = Replacement.create(
                file: "test.spl",
                start: 5,
                end: 10,
                line: 1,
                column: 6,
                new_text: ""
            )
            expect rep.new_text == ""
            expect rep.end - rep.start == 5

        it "formats for display":
            val rep = Replacement.create(
                file: "src/main.spl",
                start: 0,
                end: 5,
                line: 1,
                column: 1,
                new_text: "hello"
            )
            val formatted = rep.format()
            expect formatted.contains("src/main.spl")
            expect formatted.contains("hello")

    context "EasyFix creation":
        """
        ### Scenario: Building Fix Objects

        EasyFix objects aggregate replacements with metadata.
        """

        it "creates an empty fix":
            val fix = EasyFix.create(
                id: "L:test:1",
                description: "test fix",
                confidence: FixConfidence.Safe
            )
            expect fix.id == "L:test:1"
            expect fix.description == "test fix"
            expect fix.replacements.len() == 0

        it "adds replacements":
            var fix = EasyFix.create(
                id: "L:test:1",
                description: "test fix",
                confidence: FixConfidence.Safe
            )
            fix.add_replacement(Replacement.create(
                file: "test.spl", start: 0, end: 5, line: 1, column: 1, new_text: "hello"
            ))
            expect fix.replacements.len() == 1

        it "adds multiple replacements":
            var fix = EasyFix.create(
                id: "L:test:1",
                description: "multi-replacement fix",
                confidence: FixConfidence.Likely
            )
            fix.add_replacement(Replacement.create(
                file: "a.spl", start: 0, end: 3, line: 1, column: 1, new_text: "xxx"
            ))
            fix.add_replacement(Replacement.create(
                file: "b.spl", start: 10, end: 15, line: 2, column: 1, new_text: "yyy"
            ))
            expect fix.replacements.len() == 2

        it "reports safe confidence":
            val fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            expect fix.is_safe() == true

        it "reports non-safe for Likely":
            val fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Likely)
            expect fix.is_safe() == false

        it "reports non-safe for Uncertain":
            val fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Uncertain)
            expect fix.is_safe() == false

        it "formats confidence as string":
            val safe = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            val likely = EasyFix.create(id: "f2", description: "d", confidence: FixConfidence.Likely)
            val uncertain = EasyFix.create(id: "f3", description: "d", confidence: FixConfidence.Uncertain)
            expect safe.confidence_str() == "safe"
            expect likely.confidence_str() == "likely"
            expect uncertain.confidence_str() == "uncertain"

# ============================================================================
# Test Group 2: Fix Application Engine
# ============================================================================

describe "FixApplicator Engine":
    """
    ## Fix Application Logic

    Tests the core engine that applies text replacements to source files,
    including sorting, conflict detection, and multi-file support.
    """

    context "single replacement":
        """
        ### Scenario: Applying One Fix

        The simplest case: one replacement in one file.
        """

        it "replaces text at the beginning":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "hello world"

            var fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix.add_replacement(Replacement.create(
                file: "test.spl", start: 0, end: 5, line: 1, column: 1, new_text: "goodbye"
            ))

            val result = FixApplicator.apply([fix], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "goodbye world"
                case Err(e):
                    expect false

        it "replaces text at the end":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "hello world"

            var fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix.add_replacement(Replacement.create(
                file: "test.spl", start: 6, end: 11, line: 1, column: 7, new_text: "earth"
            ))

            val result = FixApplicator.apply([fix], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "hello earth"
                case Err(e):
                    expect false

        it "replaces text in the middle":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "aaa bbb ccc"

            var fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix.add_replacement(Replacement.create(
                file: "test.spl", start: 4, end: 7, line: 1, column: 5, new_text: "xxx"
            ))

            val result = FixApplicator.apply([fix], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "aaa xxx ccc"
                case Err(e):
                    expect false

        it "inserts text (zero-length span)":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "hello world"

            var fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix.add_replacement(Replacement.create(
                file: "test.spl", start: 5, end: 5, line: 1, column: 6, new_text: " beautiful"
            ))

            val result = FixApplicator.apply([fix], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "hello beautiful world"
                case Err(e):
                    expect false

        it "deletes text (empty new_text)":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "hello beautiful world"

            var fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix.add_replacement(Replacement.create(
                file: "test.spl", start: 5, end: 15, line: 1, column: 6, new_text: ""
            ))

            val result = FixApplicator.apply([fix], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "hello world"
                case Err(e):
                    expect false

    context "multiple non-overlapping replacements":
        """
        ### Scenario: Multiple Fixes in One File

        When multiple fixes target different parts of the same file,
        they must be sorted and applied from end-to-start.
        """

        it "applies two fixes in same file":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "aaa bbb ccc"

            var fix1 = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix1.add_replacement(Replacement.create(
                file: "test.spl", start: 0, end: 3, line: 1, column: 1, new_text: "xxx"
            ))

            var fix2 = EasyFix.create(id: "f2", description: "d", confidence: FixConfidence.Safe)
            fix2.add_replacement(Replacement.create(
                file: "test.spl", start: 8, end: 11, line: 1, column: 9, new_text: "zzz"
            ))

            val result = FixApplicator.apply([fix1, fix2], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "xxx bbb zzz"
                case Err(e):
                    expect false

        it "applies three fixes preserving order":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "111 222 333 444"

            var fix1 = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix1.add_replacement(Replacement.create(
                file: "test.spl", start: 0, end: 3, line: 1, column: 1, new_text: "aaa"
            ))
            var fix2 = EasyFix.create(id: "f2", description: "d", confidence: FixConfidence.Safe)
            fix2.add_replacement(Replacement.create(
                file: "test.spl", start: 4, end: 7, line: 1, column: 5, new_text: "bbb"
            ))
            var fix3 = EasyFix.create(id: "f3", description: "d", confidence: FixConfidence.Safe)
            fix3.add_replacement(Replacement.create(
                file: "test.spl", start: 12, end: 15, line: 1, column: 13, new_text: "ddd"
            ))

            val result = FixApplicator.apply([fix1, fix2, fix3], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "aaa bbb 333 ddd"
                case Err(e):
                    expect false

    context "conflicting replacements":
        """
        ### Scenario: Overlapping Spans

        When two replacements overlap in the same file, the applicator
        must detect the conflict and return an error.
        """

        it "detects overlapping spans":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "hello world"

            var fix1 = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix1.add_replacement(Replacement.create(
                file: "test.spl", start: 0, end: 8, line: 1, column: 1, new_text: "xxx"
            ))
            var fix2 = EasyFix.create(id: "f2", description: "d", confidence: FixConfidence.Safe)
            fix2.add_replacement(Replacement.create(
                file: "test.spl", start: 5, end: 11, line: 1, column: 6, new_text: "yyy"
            ))

            val result = FixApplicator.apply([fix1, fix2], sources)
            match result:
                case Ok(_):
                    expect false  # Should have failed
                case Err(e):
                    expect e.contains("overlap") or e.contains("Conflicting")

    context "multi-file fixes":
        """
        ### Scenario: Fixes Across Multiple Files

        Fixes can span multiple files; each file is processed independently.
        """

        it "applies fixes to different files":
            var sources: Dict<String, String> = {}
            sources["a.spl"] = "file_a content"
            sources["b.spl"] = "file_b content"

            var fix1 = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix1.add_replacement(Replacement.create(
                file: "a.spl", start: 0, end: 6, line: 1, column: 1, new_text: "alpha"
            ))
            var fix2 = EasyFix.create(id: "f2", description: "d", confidence: FixConfidence.Safe)
            fix2.add_replacement(Replacement.create(
                file: "b.spl", start: 0, end: 6, line: 1, column: 1, new_text: "beta"
            ))

            val result = FixApplicator.apply([fix1, fix2], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["a.spl"] == "alpha content"
                    expect new_sources["b.spl"] == "beta content"
                case Err(e):
                    expect false

    context "missing file":
        """
        ### Scenario: File Not in Source Registry

        If a replacement references a file not in the source registry,
        an error is returned.
        """

        it "returns error for missing file":
            var sources: Dict<String, String> = {}
            sources["exists.spl"] = "content"

            var fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix.add_replacement(Replacement.create(
                file: "missing.spl", start: 0, end: 5, line: 1, column: 1, new_text: "x"
            ))

            val result = FixApplicator.apply([fix], sources)
            match result:
                case Ok(_):
                    expect false
                case Err(e):
                    expect e.contains("not found") or e.contains("File not found")

# ============================================================================
# Test Group 3: Fix Filtering
# ============================================================================

describe "Fix Filtering":
    """
    ## Filtering Fixes by Criteria

    Tests confidence-based and ID-based filtering of fix collections.
    """

    context "confidence filtering":
        """
        ### Scenario: Filter by Confidence Level

        Only fixes meeting the minimum confidence threshold are included.
        """

        it "Safe filter returns only safe fixes":
            val safe = EasyFix.create(id: "safe", description: "d", confidence: FixConfidence.Safe)
            val likely = EasyFix.create(id: "likely", description: "d", confidence: FixConfidence.Likely)
            val uncertain = EasyFix.create(id: "uncertain", description: "d", confidence: FixConfidence.Uncertain)
            val fixes = [safe, likely, uncertain]

            val filtered = FixApplicator.filter_by_confidence(fixes, FixConfidence.Safe)
            expect filtered.len() == 1
            expect filtered[0].id == "safe"

        it "Likely filter returns safe and likely":
            val safe = EasyFix.create(id: "safe", description: "d", confidence: FixConfidence.Safe)
            val likely = EasyFix.create(id: "likely", description: "d", confidence: FixConfidence.Likely)
            val uncertain = EasyFix.create(id: "uncertain", description: "d", confidence: FixConfidence.Uncertain)
            val fixes = [safe, likely, uncertain]

            val filtered = FixApplicator.filter_by_confidence(fixes, FixConfidence.Likely)
            expect filtered.len() == 2

        it "Uncertain filter returns all":
            val safe = EasyFix.create(id: "safe", description: "d", confidence: FixConfidence.Safe)
            val likely = EasyFix.create(id: "likely", description: "d", confidence: FixConfidence.Likely)
            val uncertain = EasyFix.create(id: "uncertain", description: "d", confidence: FixConfidence.Uncertain)
            val fixes = [safe, likely, uncertain]

            val filtered = FixApplicator.filter_by_confidence(fixes, FixConfidence.Uncertain)
            expect filtered.len() == 3

        it "returns empty list when no fixes match":
            val uncertain = EasyFix.create(id: "u1", description: "d", confidence: FixConfidence.Uncertain)
            val filtered = FixApplicator.filter_by_confidence([uncertain], FixConfidence.Safe)
            expect filtered.len() == 0

    context "ID prefix filtering":
        """
        ### Scenario: Filter by Fix ID

        Select fixes whose IDs start with a given prefix.
        """

        it "filters by prefix":
            val f1 = EasyFix.create(id: "L:todo_format:1", description: "d", confidence: FixConfidence.Safe)
            val f2 = EasyFix.create(id: "L:bare_bool:1", description: "d", confidence: FixConfidence.Safe)
            val f3 = EasyFix.create(id: "L:todo_format:2", description: "d", confidence: FixConfidence.Safe)

            val filtered = FixApplicator.filter_by_id([f1, f2, f3], "L:todo_format")
            expect filtered.len() == 2

        it "returns empty when no match":
            val f1 = EasyFix.create(id: "L:todo:1", description: "d", confidence: FixConfidence.Safe)
            val filtered = FixApplicator.filter_by_id([f1], "E:type")
            expect filtered.len() == 0

        it "matches exact prefix":
            val f1 = EasyFix.create(id: "L:abc", description: "d", confidence: FixConfidence.Safe)
            val f2 = EasyFix.create(id: "L:abcdef", description: "d", confidence: FixConfidence.Safe)
            val filtered = FixApplicator.filter_by_id([f1, f2], "L:abc")
            expect filtered.len() == 2  # Both start with "L:abc"

# ============================================================================
# Test Group 4: Fix Report
# ============================================================================

describe "FixReport":
    """
    ## Fix Application Reporting

    After fixes are applied, a report summarizes what was done.
    """

    context "empty report":
        it "starts with zero counts":
            val report = FixReport.empty()
            expect report.applied == 0
            expect report.skipped == 0
            expect report.modified_files.len() == 0
            expect report.details.len() == 0

    context "report formatting":
        it "formats dry-run report":
            var report = FixReport.empty()
            report.applied = 2
            report.modified_files = ["a.spl", "b.spl"]
            report.details = ["[f1] fix one", "[f2] fix two"]

            val output = report.format(true)
            expect output.contains("Would apply")
            expect output.contains("2 fix(es)")

        it "formats applied report":
            var report = FixReport.empty()
            report.applied = 1
            report.modified_files = ["test.spl"]
            report.details = ["[f1] fixed issue"]

            val output = report.format(false)
            expect output.contains("Applied")
            expect output.contains("1 fix(es)")

# ============================================================================
# Test Group 5: Lint Integration
# ============================================================================

describe "Lint-EasyFix Integration":
    """
    ## Integration with Lint System

    Tests that lint diagnostics can carry EasyFix data and that
    the fix hint and easy_fix fields work together.
    """

    context "Lint with EasyFix":
        it "creates lint with easy_fix":
            var fix = EasyFix.create(
                id: "L:todo_format:1",
                description: "add format tags",
                confidence: FixConfidence.Uncertain
            )
            fix.add_replacement(Replacement.create(
                file: "test.spl", start: 10, end: 10, line: 1, column: 11, new_text: "[runtime][P2] "
            ))

            val lint = Lint.new("T001", LintLevel.Warn, LintCategory.Style,
                "TODO/FIXME missing [area][priority] format")
                .with_fix("Use: TODO: [area][P0-P3] description")
                .with_easy_fix(fix)

            expect lint.easy_fix.? == true
            expect lint.fix_hint.? == true

        it "creates lint without easy_fix":
            val lint = Lint.new("W001", LintLevel.Warn, LintCategory.Warning, "unused variable")
            expect lint.easy_fix.? == false
            expect lint.fix_hint.? == false

    context "LintResult with EasyFix":
        it "reports has_easy_fix true when present":
            var fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            val lint = Lint.new("T001", LintLevel.Warn, LintCategory.Style, "msg")
                .with_easy_fix(fix)
            val result = LintResult.new("test.spl", 1, 1, lint)
            expect result.has_easy_fix() == true

        it "reports has_easy_fix false when absent":
            val lint = Lint.new("W001", LintLevel.Warn, LintCategory.Warning, "msg")
            val result = LintResult.new("test.spl", 1, 1, lint)
            expect result.has_easy_fix() == false

        it "includes fix info in formatted output":
            var fix = EasyFix.create(id: "L:test:1", description: "d", confidence: FixConfidence.Safe)
            val lint = Lint.new("T001", LintLevel.Warn, LintCategory.Style, "msg")
                .with_easy_fix(fix)
            val result = LintResult.new("test.spl", 1, 1, lint)
            val formatted = result.format()
            expect formatted.contains("fix: available")
            expect formatted.contains("L:test:1")

# ============================================================================
# Test Group 6: Edge Cases
# ============================================================================

describe "EasyFix Edge Cases":
    """
    ## Edge Cases and Boundary Conditions

    Tests unusual inputs and boundary conditions in the fix system.
    """

    context "empty inputs":
        it "handles empty fix list":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "hello"
            val result = FixApplicator.apply([], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources.len() == 0  # No files modified
                case Err(_):
                    expect false

        it "handles fix with no replacements":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "hello"
            val fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            val result = FixApplicator.apply([fix], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources.len() == 0  # No changes needed
                case Err(_):
                    expect false

    context "replacement at file boundaries":
        it "replaces entire file content":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "old"

            var fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix.add_replacement(Replacement.create(
                file: "test.spl", start: 0, end: 3, line: 1, column: 1, new_text: "new content"
            ))

            val result = FixApplicator.apply([fix], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "new content"
                case Err(_):
                    expect false

        it "inserts at beginning of file":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "world"

            var fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix.add_replacement(Replacement.create(
                file: "test.spl", start: 0, end: 0, line: 1, column: 1, new_text: "hello "
            ))

            val result = FixApplicator.apply([fix], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "hello world"
                case Err(_):
                    expect false

        it "appends at end of file":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "hello"

            var fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix.add_replacement(Replacement.create(
                file: "test.spl", start: 5, end: 5, line: 1, column: 6, new_text: " world"
            ))

            val result = FixApplicator.apply([fix], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "hello world"
                case Err(_):
                    expect false

    context "replacement size changes":
        it "handles replacement longer than original":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "ab"

            var fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix.add_replacement(Replacement.create(
                file: "test.spl", start: 0, end: 2, line: 1, column: 1, new_text: "abcdef"
            ))

            val result = FixApplicator.apply([fix], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "abcdef"
                case Err(_):
                    expect false

        it "handles replacement shorter than original":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "abcdef"

            var fix = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix.add_replacement(Replacement.create(
                file: "test.spl", start: 0, end: 6, line: 1, column: 1, new_text: "ab"
            ))

            val result = FixApplicator.apply([fix], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "ab"
                case Err(_):
                    expect false

    context "adjacent replacements":
        it "applies adjacent non-overlapping fixes":
            var sources: Dict<String, String> = {}
            sources["test.spl"] = "aabbcc"

            var fix1 = EasyFix.create(id: "f1", description: "d", confidence: FixConfidence.Safe)
            fix1.add_replacement(Replacement.create(
                file: "test.spl", start: 0, end: 2, line: 1, column: 1, new_text: "xx"
            ))
            var fix2 = EasyFix.create(id: "f2", description: "d", confidence: FixConfidence.Safe)
            fix2.add_replacement(Replacement.create(
                file: "test.spl", start: 2, end: 4, line: 1, column: 3, new_text: "yy"
            ))
            var fix3 = EasyFix.create(id: "f3", description: "d", confidence: FixConfidence.Safe)
            fix3.add_replacement(Replacement.create(
                file: "test.spl", start: 4, end: 6, line: 1, column: 5, new_text: "zz"
            ))

            val result = FixApplicator.apply([fix1, fix2, fix3], sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"] == "xxyyzz"
                case Err(_):
                    expect false
