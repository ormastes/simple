# # ARM32 (Cortex-M) Bare-Metal Boot Tests
#
# **Feature ID:** #BAREMETAL-002
# **Category:** Baremetal
# **Status:** In Progress
#
# ## Overview
#
# Tests ARM Cortex-M bare-metal boot functionality including vector table generation,
# reset handler behavior, stack pointer initialization, and NVIC interrupt controller setup.
# Validates that the ARM32 boot infrastructure correctly places exception vectors, initializes
# .data and .bss sections, and maintains AAPCS stack alignment.
#
# ## Syntax
#
# ```simple
# val vt = create_vector_table()
# expect(vt.initial_sp).to_equal(STACK_TOP)
# expect(check_vector_alignment(0x08000000)).to_equal(true)
# expect(check_data_init(0x20000000, 0x20001000)).to_equal(true)
# ```
# @platform: baremetal(arm32)
# ARM32 (Cortex-M) Bare-Metal Boot Tests
#
# Tests ARM Cortex-M bare-metal boot functionality:
# - Vector table generation
# - Reset handler
# - Stack pointer initialization
# - Startup code
#
# These tests verify the ARM32 boot infrastructure works correctly.

use std.spec
fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")
use baremetal.arm.test_support.{create_vector_table, validate_vector_table, check_exception_count, check_vector_alignment, check_stack_alignment, check_data_init, check_bss_init, STACK_TOP, ExceptionVector}

# ===========================================================================
# Vector Table Tests
# ===========================================================================

fn skip_it(name: text, block: fn()):
    print "    it {name} ... skipped (compiled-only)"

describe "ARM32 Vector Table":
    it "generates valid vector table":
        val vt = create_vector_table()
        # Initial SP should be at top of SRAM
        expect(vt.initial_sp).to_equal(STACK_TOP)
        # Reset handler should be in flash range
        expect(vt.reset > 0x08000000).to_equal(true)
        expect(vt.reset < 0x08100000).to_equal(true)

    it "has correct exception count":
        val count = check_exception_count()
        # Cortex-M has 16 exception vectors
        expect(count).to_equal(16)

    it "places vector table at aligned address":
        # Flash base 0x08000000 should be 128-byte aligned
        expect(check_vector_alignment(0x08000000)).to_equal(true)

    it "has zero reserved entries":
        val vt = create_vector_table()
        expect(vt.reserved1).to_equal(0)
        expect(vt.reserved2).to_equal(0)
        expect(vt.reserved3).to_equal(0)
        expect(vt.reserved4).to_equal(0)
        expect(vt.reserved5).to_equal(0)

# ===========================================================================
# Reset Handler Tests
# ===========================================================================

describe "ARM32 Reset Handler":
    it "initializes .data section":
        # Data section in SRAM (0x20000000 - 0x20100000)
        expect(check_data_init(0x20000000, 0x20001000)).to_equal(true)

    it "zeros .bss section":
        # BSS section in SRAM
        expect(check_bss_init(0x20001000, 0x20002000)).to_equal(true)

    it "sets up stack pointer":
        # STACK_TOP should be at top of SRAM, 8-byte aligned (AAPCS)
        expect(STACK_TOP > 0x20000000).to_equal(true)
        expect(check_stack_alignment(STACK_TOP)).to_equal(true)

# ===========================================================================
# NVIC Tests
# ===========================================================================

describe "ARM32 NVIC (Nested Vectored Interrupt Controller)":
    skip_it "enables interrupts correctly":
        # Requires NVIC register interaction
        check(true)

    skip_it "handles interrupt priorities":
        # Requires priority grouping configuration
        check(true)

# ===========================================================================
# QEMU Boot Tests
# ===========================================================================

describe "ARM32 QEMU Boot":
    skip_it "boots on LM3S6965 (Cortex-M3)":
        # Requires QEMU installation
        check(true)

    skip_it "handles SysTick interrupt":
        # Requires QEMU + test kernel with SysTick
        check(true)
