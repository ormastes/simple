# # x86_64 Bare-Metal Boot Tests
#
# **Feature ID:** #BAREMETAL-012
# **Category:** Baremetal
# **Status:** In Progress
#
# ## Overview
#
# Tests x86_64 bare-metal boot functionality including 64-bit multiboot2 header generation
# and validation, long mode setup through PAE (CR4), LME (EFER), and paging (CR0) control
# register configuration, and 16-byte stack alignment verification. Validates that the x86_64
# boot infrastructure correctly transitions from protected mode to long mode.
#
# ## Syntax
#
# ```simple
# val header = multiboot2_header()
# expect(header.magic).to_equal(0xE85250D6)
# expect(validate_multiboot2(header)).to_equal(true)
# expect(is_pae_enabled(CR4_PAE)).to_equal(true)
# expect(is_long_mode_enabled(EFER_LME)).to_equal(true)
# ```
# @platform: baremetal(x86_64)
# x86_64 Bare-Metal Boot Tests
#
# Tests x86_64 bare-metal boot functionality:
# - 64-bit multiboot header
# - Long mode setup
# - Stack alignment (16-byte)
# - Jump to kernel_main
#
# These tests verify the x86_64 boot infrastructure works correctly.

use std.spec
fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")
use baremetal.x86_64.test_support.{Multiboot2Header, multiboot2_header, validate_multiboot2, get_stack_pointer, check_stack_alignment, STACK_SIZE, CR4_PAE, EFER_LME, CR0_PG, is_pae_enabled, is_long_mode_enabled, is_paging_enabled}

# ===========================================================================
# Boot Code Tests
# ===========================================================================

fn skip_it(name: text, block: fn()):
    print "    it {name} ... skipped (compiled-only)"

describe "x86_64 Boot Code":
    it "generates valid 64-bit multiboot header":
        val header = multiboot2_header()
        expect(header.magic).to_equal(0xE85250D6)
        expect(header.architecture).to_equal(0)
        expect(header.header_length).to_equal(24)

    it "validates multiboot2 header successfully":
        val header = multiboot2_header()
        expect(validate_multiboot2(header)).to_equal(true)

    it "sets up long mode correctly":
        # Simulate control register values with all bits set for long mode
        val cr4 = CR4_PAE
        val efer = EFER_LME
        val cr0 = CR0_PG
        expect(is_pae_enabled(cr4)).to_equal(true)
        expect(is_long_mode_enabled(efer)).to_equal(true)
        expect(is_paging_enabled(cr0)).to_equal(true)

    it "maintains 16-byte stack alignment":
        val sp = get_stack_pointer()
        expect(check_stack_alignment(sp)).to_equal(true)
        expect(STACK_SIZE % 16).to_equal(0)

# ===========================================================================
# QEMU Boot Tests
# ===========================================================================

describe "x86_64 QEMU Boot":
    skip_it "boots successfully in QEMU":
        # Requires QEMU installation
        check(true)

    skip_it "handles 64-bit interrupts":
        # Requires QEMU + test kernel with IDT in long mode
        check(true)
