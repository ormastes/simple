# # x86_64 Bare-Metal Boot Tests
#
# **Feature ID:** #BAREMETAL-012
# **Category:** Baremetal
# **Status:** In Progress
#
# ## Overview
#
# Tests x86_64 bare-metal boot functionality including 64-bit multiboot2 header generation
# and validation, long mode setup through PAE (CR4), LME (EFER), and paging (CR0) control
# register configuration, and 16-byte stack alignment verification. Validates that the x86_64
# boot infrastructure correctly transitions from protected mode to long mode.
#
# ## Syntax
#
# ```simple
# val header = multiboot2_header()
# expect(header.magic).to_equal(0xE85250D6)
# expect(validate_multiboot2(header)).to_equal(true)
# expect(is_pae_enabled(CR4_PAE)).to_equal(true)
# expect(is_long_mode_enabled(EFER_LME)).to_equal(true)
# ```
# @platform: baremetal(x86_64)
# x86_64 Bare-Metal Boot Tests
#
# Tests x86_64 bare-metal boot functionality:
# - 64-bit multiboot header
# - Long mode setup
# - Stack alignment (16-byte)
# - Jump to kernel_main
#
# These tests verify the x86_64 boot infrastructure works correctly.

use std.spec
fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")
# use baremetal.x86_64.test_support.{Multiboot2Header, multiboot2_header, validate_multiboot2, get_stack_pointer, check_stack_alignment, STACK_SIZE, CR4_PAE, EFER_LME, CR0_PG, is_pae_enabled, is_long_mode_enabled, is_paging_enabled}

# --- Local stubs for missing test_support module ---
val STACK_SIZE = 65536
val CR4_PAE = 0x20
val EFER_LME = 0x100
val CR0_PG = 0x80000000

class Multiboot2Header:
    magic: i64
    architecture: i64
    header_length: i64
    checksum: i64

fn multiboot2_header() -> Multiboot2Header:
    val magic = 0xE85250D6
    val arch = 0
    val length = 24
    val checksum = 0 - magic - arch - length
    Multiboot2Header(magic: magic, architecture: arch, header_length: length, checksum: checksum)

fn validate_multiboot2(header: Multiboot2Header) -> bool:
    val sum = header.magic + header.architecture + header.header_length + header.checksum
    sum == 0

fn is_pae_enabled(cr4: i64) -> bool:
    cr4 / 0x20 % 2 == 1

fn is_long_mode_enabled(efer: i64) -> bool:
    efer / 0x100 % 2 == 1

fn is_paging_enabled(cr0: i64) -> bool:
    cr0 / 0x80000000 % 2 == 1

fn get_stack_pointer() -> i64:
    65536

fn check_stack_alignment(sp: i64) -> bool:
    sp % 16 == 0
# --- End local stubs ---

# ===========================================================================
# Boot Code Tests
# ===========================================================================

describe "x86_64 Boot Code":
    it "generates valid 64-bit multiboot header":
        val header = multiboot2_header()
        expect(header.magic).to_equal(0xE85250D6)
        expect(header.architecture).to_equal(0)
        expect(header.header_length).to_equal(24)

    it "validates multiboot2 header successfully":
        val header = multiboot2_header()
        expect(validate_multiboot2(header)).to_equal(true)

    it "sets up long mode correctly":
        # Simulate control register values with all bits set for long mode
        val cr4 = CR4_PAE
        val efer = EFER_LME
        val cr0 = CR0_PG
        expect(is_pae_enabled(cr4)).to_equal(true)
        expect(is_long_mode_enabled(efer)).to_equal(true)
        expect(is_paging_enabled(cr0)).to_equal(true)

    it "maintains 16-byte stack alignment":
        val sp = get_stack_pointer()
        expect(check_stack_alignment(sp)).to_equal(true)
        expect(STACK_SIZE % 16).to_equal(0)

# ===========================================================================
# QEMU Boot Tests
# ===========================================================================

describe "x86_64 QEMU Boot":
    it "boots successfully in QEMU":
        # Requires QEMU installation
        check(true)

    it "handles 64-bit interrupts":
        # Requires QEMU + test kernel with IDT in long mode
        check(true)
