# # RISC-V 64-bit Bare-Metal Boot Tests
#
# **Feature ID:** #BAREMETAL-009
# **Category:** Baremetal
# **Status:** In Progress
#
# ## Overview
#
# Tests RISC-V 64-bit bare-metal boot functionality including machine mode startup,
# trap vector setup with direct and vectored modes, machine status register initialization,
# interrupt enable configuration (timer, external, software), and 16-byte stack alignment.
# Validates that the RISC-V 64 boot infrastructure correctly initializes mtvec, mstatus, and mie CSRs.
#
# ## Syntax
#
# ```simple
# val mstatus = MSTATUS_MPP_MACHINE
# expect(check_machine_mode(mstatus)).to_equal(true)
#
# val mtvec = 0x80000100
# val (base, mode) = parse_mtvec(mtvec)
# expect(mode).to_equal(MTVEC_MODE_DIRECT)
# expect(validate_trap_vector(mtvec)).to_equal(true)
# ```
# @platform: baremetal(riscv)
# RISC-V 64-bit Bare-Metal Boot Tests
#
# Tests RISC-V 64-bit bare-metal boot functionality:
# - Machine mode startup
# - Trap vector setup
# - Stack setup
# - Jump to kernel_main
#
# These tests verify the RISC-V 64 boot infrastructure works correctly.

use std.spec
fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")
# use baremetal.riscv.test_support.{check_machine_mode, check_mtvec_alignment, check_mstatus_bits, get_stack_pointer, check_stack_alignment_rv64, parse_mtvec, validate_trap_vector, check_mstatus_init, check_interrupt_enabled, STACK_SIZE, RAM_BASE, MSTATUS_MIE, MSTATUS_MPIE, MSTATUS_MPP_MACHINE, MIE_MSIE, MIE_MTIE, MIE_MEIE, MTVEC_MODE_DIRECT, MTVEC_MODE_VECTORED}

# --- Local stubs for missing test_support module ---
val STACK_SIZE = 65536
val RAM_BASE = 0x80000000
val MSTATUS_MIE = 0x8
val MSTATUS_MPIE = 0x80
val MSTATUS_MPP_MACHINE = 0x1800
val MIE_MSIE = 0x8
val MIE_MTIE = 0x80
val MIE_MEIE = 0x800
val MTVEC_MODE_DIRECT = 0
val MTVEC_MODE_VECTORED = 1

class MtvecResult:
    base: i64
    mode: i64

fn check_machine_mode(mstatus: i64) -> bool:
    val mpp = (mstatus / 0x800) % 4
    mpp == 3

fn check_mstatus_init(mstatus: i64) -> bool:
    val mpp = (mstatus / 0x800) % 4
    val mie_bit = mstatus % 16 / 8
    mpp == 3 and mie_bit == 0

fn parse_mtvec(mtvec: i64) -> MtvecResult:
    val mode = mtvec % 4
    val base = mtvec - mode
    MtvecResult(base: base, mode: mode)

fn check_mtvec_alignment(base: i64, mode: i64) -> bool:
    if mode == MTVEC_MODE_DIRECT:
        base % 4 == 0
    else:
        base % 256 == 0

fn validate_trap_vector(mtvec: i64) -> bool:
    val result = parse_mtvec(mtvec)
    val mode = result.mode
    val base = result.base
    if mode > 1:
        false
    else:
        check_mtvec_alignment(base, mode)

fn check_interrupt_enabled(mie: i64, bit: i64) -> bool:
    val masked = mie / bit % 2
    masked == 1

fn get_stack_pointer() -> i64:
    RAM_BASE + STACK_SIZE

fn check_stack_alignment_rv64(sp: i64) -> bool:
    sp % 16 == 0
# --- End local stubs ---

# ===========================================================================
# Boot Code Tests
# ===========================================================================

describe "RISC-V 64 Boot Code":
    it "starts in machine mode":
        # After reset: MPP = 11 (machine mode), MIE = 0 (interrupts disabled)
        val mstatus = MSTATUS_MPP_MACHINE
        expect(check_machine_mode(mstatus)).to_equal(true)
        expect(check_mstatus_init(mstatus)).to_equal(true)

    it "sets up trap vector":
        # Direct mode trap vector at 0x80000100
        val mtvec = 0x80000100
        val result = parse_mtvec(mtvec)
        val base = result.base
        val mode = result.mode
        expect(mode).to_equal(MTVEC_MODE_DIRECT)
        expect(check_mtvec_alignment(base, mode)).to_equal(true)
        expect(validate_trap_vector(mtvec)).to_equal(true)

    it "configures machine registers":
        # Verify interrupt enable bits
        val mie = MIE_MTIE + MIE_MEIE
        expect(check_interrupt_enabled(mie, MIE_MTIE)).to_equal(true)
        expect(check_interrupt_enabled(mie, MIE_MEIE)).to_equal(true)
        expect(check_interrupt_enabled(mie, MIE_MSIE)).to_equal(false)

        # Verify stack setup
        val sp = get_stack_pointer()
        expect(sp).to_equal(RAM_BASE + STACK_SIZE)
        expect(check_stack_alignment_rv64(sp)).to_equal(true)

# ===========================================================================
# QEMU Boot Tests
# ===========================================================================

describe "RISC-V 64 QEMU Boot":
    it "boots on virt machine":
        # Requires QEMU installation
        check(true)

    it "handles traps correctly":
        # Requires QEMU + test kernel with trap handlers
        check(true)
