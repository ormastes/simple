# # ARM64 (AArch64) Bare-Metal Boot Tests
#
# **Feature ID:** #BAREMETAL-003
# **Category:** Baremetal
# **Status:** In Progress
#
# ## Overview
#
# Tests ARM64 (AArch64) bare-metal boot functionality including exception vector table
# generation, exception level (EL0-EL3) setup and transitions, VBAR alignment validation,
# and 16-byte stack pointer alignment. Verifies the ARM64 boot infrastructure handles
# EL transitions correctly and maintains AArch64 calling convention requirements.
#
# ## Syntax
#
# ```simple
# val vt = create_vector_table()
# expect(vt.sync_current_sp0.handler > 0).to_equal(true)
# expect(check_vbar_alignment(0x40000000)).to_equal(true)
# expect(check_el_transition(EL3, EL1)).to_equal(true)
# ```
# @platform: baremetal(aarch64)
# ARM64 (AArch64) Bare-Metal Boot Tests
#
# Tests ARM64 bare-metal boot functionality:
# - Exception vector table
# - EL1/EL2/EL3 setup
# - Stack pointer alignment
# - Jump to kernel_main
#
# These tests verify the ARM64 boot infrastructure works correctly.

use std.spec
fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")
use baremetal.arm64.test_support.{ExceptionVector, create_vector_table, validate_vector_table, check_exception_level, check_vbar_alignment, check_stack_alignment, check_el_transition, get_stack_pointer, STACK_SIZE, EL0, EL1, EL2, EL3}

# ===========================================================================
# Boot Code Tests
# ===========================================================================

fn skip_it(name: text, block: fn()):
    print "    it {name} ... skipped (compiled-only)"

describe "ARM64 Boot Code":
    it "generates valid exception vector table":
        val vt = create_vector_table()
        # All handler addresses should be non-zero
        expect(vt.sync_current_sp0.handler > 0).to_equal(true)
        expect(vt.irq_current_spx.handler > 0).to_equal(true)
        expect(vt.sync_lower64.handler > 0).to_equal(true)

    it "checks vector table alignment":
        # VBAR must be 2KB aligned
        expect(check_vbar_alignment(0x40000000)).to_equal(true)
        expect(check_vbar_alignment(0x40000800)).to_equal(true)
        # Not 2KB aligned
        expect(check_vbar_alignment(0x40000100)).to_equal(false)

    it "sets up exception levels correctly":
        # All 4 exception levels should be valid
        expect(check_exception_level(EL0)).to_equal(true)
        expect(check_exception_level(EL1)).to_equal(true)
        expect(check_exception_level(EL2)).to_equal(true)
        expect(check_exception_level(EL3)).to_equal(true)
        # EL transitions: higher â†’ lower
        expect(check_el_transition(EL3, EL1)).to_equal(true)
        expect(check_el_transition(EL1, EL3)).to_equal(false)

    it "maintains stack pointer alignment":
        val sp = get_stack_pointer()
        # AArch64 requires 16-byte stack alignment
        expect(check_stack_alignment(sp)).to_equal(true)
        expect(STACK_SIZE % 16).to_equal(0)

# ===========================================================================
# QEMU Boot Tests
# ===========================================================================

describe "ARM64 QEMU Boot":
    skip_it "boots on virt machine":
        # Requires QEMU installation
        check(true)

    skip_it "handles exceptions correctly":
        # Requires QEMU + test kernel with exception handlers
        check(true)
