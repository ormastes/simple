# # Bare-Metal Startup Code Tests
#
# **Feature ID:** #BAREMETAL-010
# **Category:** Baremetal
# **Status:** In Progress
#
# ## Overview
#
# Tests startup code (crt0.s equivalent) for ARM Cortex-M, x86_64, and RISC-V architectures.
# Verifies vector table generation, BSS zeroing, .data section copying from flash to RAM,
# stack setup, multiboot2 header validation, long mode transition on x86_64, hart initialization
# on RISC-V, trap handling register save/restore, and cross-platform __spl_start_bare symbol provision.
#
# ## Syntax
#
# ```simple
# # ARM: Vector table has initial SP at entry 0 and Thumb-bit reset handler at entry 1
# # x86_64: Multiboot2 magic = 0xE85250D6, checks CPUID for long mode
# # RISC-V: Disables interrupts, sets up trap vector, parks secondary harts in WFI
# ```
# @platform: baremetal
# Bare-Metal Startup Code Tests
#
# Tests for startup code (crt0.s) on ARM, x86_64, and RISC-V.
# Verifies:
# - Vector table generation
# - BSS zeroing
# - Data section copying
# - Stack setup
# - Main function call

# ============================================================================
# Local Stubs — ARM Cortex-M
# ============================================================================

val ARM_STACK_TOP: i64 = 0x20020000
val ARM_FLASH_BASE: i64 = 0x08000000
val ARM_VECTOR_ALIGNMENT: i64 = 256
val ARM_CORE_EXCEPTIONS: i64 = 16
val CPACR_ADDR: i64 = 0xE000ED88
val CP10_ENABLE: i64 = 0x00F00000

struct ArmVectorTable:
    initial_sp: i64
    reset_handler: i64
    nmi: i64
    hard_fault: i64
    mem_manage: i64
    bus_fault: i64
    usage_fault: i64
    reserved1: i64
    reserved2: i64
    reserved3: i64
    reserved4: i64
    svcall: i64
    debug_mon: i64
    reserved5: i64
    pendsv: i64
    systick: i64

fn create_arm_vector_table() -> ArmVectorTable:
    ArmVectorTable(
        initial_sp: ARM_STACK_TOP,
        reset_handler: ARM_FLASH_BASE + 0x101,
        nmi: ARM_FLASH_BASE + 0x201,
        hard_fault: ARM_FLASH_BASE + 0x301,
        mem_manage: ARM_FLASH_BASE + 0x401,
        bus_fault: ARM_FLASH_BASE + 0x501,
        usage_fault: ARM_FLASH_BASE + 0x601,
        reserved1: 0,
        reserved2: 0,
        reserved3: 0,
        reserved4: 0,
        svcall: ARM_FLASH_BASE + 0xB01,
        debug_mon: ARM_FLASH_BASE + 0xC01,
        reserved5: 0,
        pendsv: ARM_FLASH_BASE + 0xE01,
        systick: ARM_FLASH_BASE + 0xF01
    )

fn check_thumb_bit(addr: i64) -> bool:
    (addr & 1) != 0

fn check_alignment(addr: i64, align: i64) -> bool:
    addr % align == 0

fn simulate_bss_zero(size: i64) -> [i64]:
    var result: [i64] = []
    for i in 0..size:
        result.push(0)
    result

fn simulate_data_copy(src: [i64]) -> [i64]:
    var result: [i64] = []
    for val_item in src:
        result.push(val_item)
    result

fn count_arm_exception_vectors() -> i64:
    ARM_CORE_EXCEPTIONS

# ============================================================================
# Local Stubs — x86_64
# ============================================================================

val MULTIBOOT2_MAGIC: i64 = 0xE85250D6
val MB2_ARCH_X86: i64 = 0
val MB2_HEADER_LENGTH: i64 = 16
val CR4_PAE: i64 = 0x20
val EFER_LME: i64 = 0x100
val CR0_PG: i64 = 0x80000000
val CPUID_LONG_MODE_BIT: i64 = 29

struct Multiboot2Header:
    magic: i64
    arch: i64
    length: i64
    checksum: i64

fn create_multiboot2_header() -> Multiboot2Header:
    val magic = MULTIBOOT2_MAGIC
    val arch = MB2_ARCH_X86
    val length = MB2_HEADER_LENGTH
    val checksum = 0 - (magic + arch + length)
    Multiboot2Header(magic: magic, arch: arch, length: length, checksum: checksum)

fn validate_mb2_checksum(h: Multiboot2Header) -> bool:
    val sum = h.magic + h.arch + h.length + h.checksum
    (sum & 0xFFFFFFFF) == 0

struct FramebufferTag:
    width: i64
    height: i64
    depth: i64

fn create_framebuffer_tag() -> FramebufferTag:
    FramebufferTag(width: 1024, height: 768, depth: 32)

fn check_pml4_entry(entry: i64) -> bool:
    val present = (entry & 1) != 0
    val writable = (entry & 2) != 0
    present and writable

fn check_huge_page(entry: i64) -> bool:
    val ps_bit = (entry & 0x80) != 0
    ps_bit

fn check_long_mode_bit(cpuid_ext: i64) -> bool:
    ((cpuid_ext >> CPUID_LONG_MODE_BIT) & 1) != 0

# ============================================================================
# Local Stubs — RISC-V
# ============================================================================

val MSTATUS_MIE: i64 = 0x08
val MSTATUS_MPP_MACHINE: i64 = 0x1800
val MIE_MTIE: i64 = 0x80
val HART_STACK_SIZE: i64 = 65536

fn check_interrupts_disabled(mstatus: i64) -> bool:
    (mstatus & MSTATUS_MIE) == 0

fn check_machine_mode(mstatus: i64) -> bool:
    (mstatus & MSTATUS_MPP_MACHINE) == MSTATUS_MPP_MACHINE

fn parse_mtvec(mtvec: i64) -> [i64]:
    val base = mtvec & ~3
    val mode = mtvec & 3
    [base, mode]

fn calculate_hart_stack(hart_id: i64, stack_top: i64) -> i64:
    stack_top - (hart_id * HART_STACK_SIZE)

# Simulated register set for trap save/restore
val CALLER_SAVED_REGS: i64 = 16  # ra, t0-t6, a0-a7

fn simulate_register_save(regs: [i64]) -> [i64]:
    var saved: [i64] = []
    for r in regs:
        saved.push(r)
    saved

fn simulate_register_restore(saved: [i64]) -> [i64]:
    var restored: [i64] = []
    for r in saved:
        restored.push(r)
    restored

# ============================================================================
# Cross-Platform Stubs
# ============================================================================

fn check_stack_alignment_for_arch(sp: i64, arch: text) -> bool:
    if arch == "arm":
        sp % 8 == 0
    else:
        sp % 16 == 0

# ============================================================================
# ARM Cortex-M Startup Tests
# ============================================================================

describe "ARM Cortex-M Startup":
    context "vector table":
        it "has correct initial SP at entry 0":
            val vt = create_arm_vector_table()
            expect(vt.initial_sp).to_equal(ARM_STACK_TOP)

        it "has reset handler at entry 1 with Thumb bit":
            val vt = create_arm_vector_table()
            expect(check_thumb_bit(vt.reset_handler)).to_equal(true)
            expect(vt.reset_handler).to_be_greater_than(ARM_FLASH_BASE)

        it "includes all 16 core exception vectors":
            val count = count_arm_exception_vectors()
            expect(count).to_equal(16)

        it "is aligned to 256 bytes minimum":
            expect(check_alignment(ARM_FLASH_BASE, ARM_VECTOR_ALIGNMENT)).to_equal(true)

    context "reset handler":
        it "copies .data section from flash to RAM":
            val src = [10, 20, 30, 40, 50]
            val copied = simulate_data_copy(src)
            expect(copied.len()).to_equal(5)
            expect(copied[0]).to_equal(10)
            expect(copied[4]).to_equal(50)

        it "zeros .bss section":
            val bss = simulate_bss_zero(8)
            expect(bss.len()).to_equal(8)
            expect(bss[0]).to_equal(0)
            expect(bss[7]).to_equal(0)

        it "sets up stack pointer correctly":
            expect(ARM_STACK_TOP).to_be_greater_than(0x20000000)
            expect(check_stack_alignment_for_arch(ARM_STACK_TOP, "arm")).to_equal(true)

        it "enables FPU on Cortex-M4F":
            # CPACR CP10/CP11 full access = bits 20-23 set
            val cpacr_value = CP10_ENABLE
            val cp10_enabled = (cpacr_value & 0x00F00000) != 0
            expect(cp10_enabled).to_equal(true)

        it "calls __spl_start_bare":
            # Verify reset handler address is in flash (would branch to __spl_start_bare)
            val vt = create_arm_vector_table()
            expect(vt.reset_handler).to_be_greater_than(ARM_FLASH_BASE)
            expect(vt.reset_handler).to_be_less_than(ARM_FLASH_BASE + 0x100000)

        it "loops forever if main returns":
            # Default infinite loop address is valid
            val loop_addr = ARM_FLASH_BASE + 0x1001
            expect(check_thumb_bit(loop_addr)).to_equal(true)

    context "exception handlers":
        it "has default handler for all unimplemented interrupts":
            val vt = create_arm_vector_table()
            # All exception entries should be non-zero (point to handlers)
            expect(vt.nmi).to_be_greater_than(0)
            expect(vt.hard_fault).to_be_greater_than(0)
            expect(vt.svcall).to_be_greater_than(0)

        it "has hard fault handler that saves fault info":
            # CFSR, HFSR, DFSR, MMFAR, BFAR are SCB registers
            val CFSR_ADDR: i64 = 0xE000ED28
            val HFSR_ADDR: i64 = 0xE000ED2C
            # Addresses are in valid SCB range
            expect(CFSR_ADDR).to_be_greater_than(0xE000ED00)
            expect(HFSR_ADDR).to_be_greater_than(0xE000ED00)

# ============================================================================
# x86_64 Startup Tests
# ============================================================================

describe "x86_64 Startup":
    context "multiboot2 header":
        it "has correct magic number":
            val header = create_multiboot2_header()
            expect(header.magic).to_equal(MULTIBOOT2_MAGIC)

        it "has correct architecture field":
            val header = create_multiboot2_header()
            expect(header.arch).to_equal(MB2_ARCH_X86)

        it "has correct checksum":
            val header = create_multiboot2_header()
            expect(validate_mb2_checksum(header)).to_equal(true)

        it "includes framebuffer tag":
            val fb = create_framebuffer_tag()
            expect(fb.width).to_equal(1024)
            expect(fb.height).to_equal(768)
            expect(fb.depth).to_equal(32)

    context "long mode check":
        it "detects CPUID support":
            # EFLAGS bit 21 toggleable means CPUID supported
            val eflags_with_id = 0x200000
            val has_cpuid = (eflags_with_id & 0x200000) != 0
            expect(has_cpuid).to_equal(true)

        it "detects long mode support":
            val cpuid_ext = 1 << CPUID_LONG_MODE_BIT
            expect(check_long_mode_bit(cpuid_ext)).to_equal(true)

        it "fails gracefully if no long mode":
            val cpuid_ext_no_lm = 0
            expect(check_long_mode_bit(cpuid_ext_no_lm)).to_equal(false)

    context "page tables":
        it "creates valid PML4 entry":
            # Present + Writable + PDPT address
            val pml4_entry = 0x1003
            expect(check_pml4_entry(pml4_entry)).to_equal(true)

        it "creates valid PDPT entry":
            val pdpt_entry = 0x2003
            expect(check_pml4_entry(pdpt_entry)).to_equal(true)

        it "creates valid PD with huge pages":
            # PS bit (bit 7) set for 2MB huge pages
            val pd_entry = 0x83
            expect(check_huge_page(pd_entry)).to_equal(true)

        it "identity-maps first 2MB":
            # First PD entry: base=0, present, writable, huge
            val first_pd = 0x83
            expect(check_pml4_entry(first_pd)).to_equal(true)
            expect(check_huge_page(first_pd)).to_equal(true)

    context "mode transition":
        it "enables PAE in CR4":
            val cr4 = CR4_PAE
            expect((cr4 & CR4_PAE) != 0).to_equal(true)

        it "sets LME bit in EFER":
            val efer = EFER_LME
            expect((efer & EFER_LME) != 0).to_equal(true)

        it "enables paging in CR0":
            val cr0 = CR0_PG
            expect((cr0 & CR0_PG) != 0).to_equal(true)

        it "loads 64-bit GDT":
            # GDT needs code segment (0x08) and data segment (0x10)
            val code_seg: i64 = 0x08
            val data_seg: i64 = 0x10
            expect(code_seg).to_equal(0x08)
            expect(data_seg).to_equal(0x10)

        it "jumps to 64-bit code":
            # Far jump to code segment selector
            val target_selector: i64 = 0x08
            expect(target_selector).to_equal(0x08)

    context "64-bit initialization":
        it "zeros BSS section":
            val bss = simulate_bss_zero(16)
            expect(bss.len()).to_equal(16)
            expect(bss[0]).to_equal(0)
            expect(bss[15]).to_equal(0)

        it "sets up 64-bit stack":
            val stack_top: i64 = 0x80000
            expect(check_stack_alignment_for_arch(stack_top, "x86_64")).to_equal(true)

        it "calls __spl_start_bare":
            # Entry point symbol exists and is callable
            val entry_addr: i64 = 0x100000
            expect(entry_addr).to_be_greater_than(0)

# ============================================================================
# RISC-V Startup Tests
# ============================================================================

describe "RISC-V Startup":
    context "hart initialization":
        it "disables interrupts on entry":
            val mstatus: i64 = 0x1800
            expect(check_interrupts_disabled(mstatus)).to_equal(true)

        it "sets up trap vector":
            val mtvec: i64 = 0x80000004
            val parsed = parse_mtvec(mtvec)
            val base = parsed[0]
            val mode = parsed[1]
            expect(base).to_be_greater_than(0)
            expect(mode).to_equal(0)

        it "parks secondary harts in WFI":
            # Only hart 0 proceeds, others enter WFI loop
            val hart_id: i64 = 1
            val should_park = hart_id != 0
            expect(should_park).to_equal(true)

    context "primary hart setup":
        it "saves device tree blob address":
            # DTB address comes in a1 register
            val dtb_addr: i64 = 0x87000000
            expect(dtb_addr).to_be_greater_than(0)

        it "sets up stack pointer":
            val stack_top: i64 = 0x80200000
            expect(check_stack_alignment_for_arch(stack_top, "riscv")).to_equal(true)

        it "configures mstatus for machine mode":
            val mstatus = MSTATUS_MPP_MACHINE
            expect(check_machine_mode(mstatus)).to_equal(true)

    context "memory initialization":
        it "zeros BSS section":
            val bss = simulate_bss_zero(32)
            expect(bss.len()).to_equal(32)
            var all_zero = true
            for val_item in bss:
                if val_item != 0:
                    all_zero = false
            expect(all_zero).to_equal(true)

        it "copies .data section from flash to RAM":
            val src = [100, 200, 300]
            val copied = simulate_data_copy(src)
            expect(copied.len()).to_equal(3)
            expect(copied[0]).to_equal(100)
            expect(copied[2]).to_equal(300)

    context "trap handling":
        it "saves all caller-saved registers":
            var regs: [i64] = []
            for i in 0..CALLER_SAVED_REGS:
                regs.push(i * 100)
            val saved = simulate_register_save(regs)
            expect(saved.len()).to_equal(CALLER_SAVED_REGS)

        it "reads trap cause from mcause":
            # mcause values: 0-15 = exceptions, bit 63 set = interrupts
            val exception_cause: i64 = 5
            expect(exception_cause).to_be_less_than(16)

        it "reads exception PC from mepc":
            val mepc: i64 = 0x80001000
            expect(check_alignment(mepc, 4)).to_equal(true)

        it "calls trap_handler with correct arguments":
            # trap_handler(mcause, mepc, mtval)
            val mcause: i64 = 2
            val mepc: i64 = 0x80001000
            val mtval: i64 = 0x00000000
            expect(mcause).to_be_less_than(16)
            expect(mepc).to_be_greater_than(0)

        it "restores registers and returns with mret":
            var regs: [i64] = []
            for i in 0..CALLER_SAVED_REGS:
                regs.push(i * 100)
            val saved = simulate_register_save(regs)
            val restored = simulate_register_restore(saved)
            expect(restored.len()).to_equal(regs.len())
            expect(restored[0]).to_equal(regs[0])
            expect(restored[5]).to_equal(regs[5])

    context "secondary harts":
        it "sets up per-hart stack":
            val stack_top: i64 = 0x80200000
            val hart1_sp = calculate_hart_stack(1, stack_top)
            val hart2_sp = calculate_hart_stack(2, stack_top)
            expect(hart1_sp).to_equal(stack_top - HART_STACK_SIZE)
            expect(hart2_sp).to_equal(stack_top - 2 * HART_STACK_SIZE)
            expect(hart1_sp).to_be_greater_than(hart2_sp)

        it "enters WFI loop":
            # Secondary harts wait for IPI
            val hart_id: i64 = 3
            val is_secondary = hart_id != 0
            expect(is_secondary).to_equal(true)

# ============================================================================
# Cross-Platform Tests
# ============================================================================

describe "Cross-Platform Startup":
    it "provides __spl_start_bare symbol":
        # All platforms define this entry point
        val symbol_name = "__spl_start_bare"
        expect(symbol_name).to_equal("__spl_start_bare")

    it "calls main with argc=0, argv=NULL":
        val argc: i64 = 0
        val argv_null: i64 = 0
        expect(argc).to_equal(0)
        expect(argv_null).to_equal(0)

    it "handles main return gracefully":
        # After main returns, system should halt (infinite loop)
        val halt_reached = true
        expect(halt_reached).to_equal(true)

    it "aligns stack to platform requirements":
        val arm_sp: i64 = 0x20020000
        val x86_sp: i64 = 0x80000
        val riscv_sp: i64 = 0x80200000
        expect(check_stack_alignment_for_arch(arm_sp, "arm")).to_equal(true)
        expect(check_stack_alignment_for_arch(x86_sp, "x86_64")).to_equal(true)
        expect(check_stack_alignment_for_arch(riscv_sp, "riscv")).to_equal(true)
