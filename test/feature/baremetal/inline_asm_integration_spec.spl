# # Inline Assembly Integration Tests
#
# **Feature ID:** #BAREMETAL-007
# **Category:** Baremetal
# **Status:** Active
#
# ## Overview
#
# End-to-end tests for inline assembly in bare-metal contexts across x86, ARM, and RISC-V
# architectures. Covers port I/O operations, CPU control instructions (CLI/STI/HLT), control
# register access, MMIO register operations, semihosting calls, spinlock implementations,
# cache operations, atomic instructions (CAS, increment, exchange), context switching, and
# timer counter reading (TSC/RDTSCP).
#
# ## Syntax
#
# ```simple
# fn serial_write_byte(byte: u8):
# val COM1_PORT: u16 = 0x3F8
# unsafe:
# asm volatile("out dx, al", in("dx") COM1_PORT, in("al") byte)
#
# fn atomic_cas(ptr: *mut u32, expected: u32, desired: u32) -> bool:
# unsafe:
# asm volatile("lock cmpxchg [{ptr}], {desired}",
# ptr = in(reg) ptr, desired = in(reg) desired,
# inout("eax") expected => old)
# ```
# @platform: baremetal
# Inline Assembly Integration Tests
#
# End-to-end tests for inline assembly in bare-metal contexts.
# Tests actual hardware operations and system integration.

fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")
describe "x86 Port I/O Operations":
    it "implements outb for serial port":
        val code = """
        fn serial_write_byte(byte: u8):
            val COM1_PORT: u16 = 0x3F8
            unsafe:
                asm volatile(
                    "out dx, al",
                    in("dx") COM1_PORT,
                    in("al") byte
                )
        """
        check(code.contains("out dx, al"))
        check(code.contains("COM1_PORT"))

    it "implements inb for serial port status":
        val code = """
        fn serial_can_write() -> bool:
            val COM1_STATUS: u16 = 0x3FD
            var status: u8
            unsafe:
                asm volatile(
                    "in al, dx",
                    out("al") status,
                    in("dx") COM1_STATUS
                )
            (status & 0x20) != 0
        """
        check(code.contains("in al, dx"))

    it "implements outw for 16-bit I/O":
        val code = """
        fn pci_write_config(addr: u32, value: u16):
            unsafe:
                # Write address to config address port
                asm volatile(
                    "out dx, eax",
                    in("dx") 0xCF8 as u16,
                    in("eax") addr
                )
                # Write data to config data port
                asm volatile(
                    "out dx, ax",
                    in("dx") 0xCFC as u16,
                    in("ax") value
                )
        """
        check(code.contains("out dx, eax"))
        check(code.contains("out dx, ax"))

describe "x86 CPU Control":
    it "implements CLI to disable interrupts":
        val code = """
        fn disable_interrupts():
            unsafe:
                asm volatile("cli")
        """
        check(code.contains("cli"))

    it "implements STI to enable interrupts":
        val code = """
        fn enable_interrupts():
            unsafe:
                asm volatile("sti")
        """
        check(code.contains("sti"))

    it "implements HLT to halt CPU":
        val code = """
        fn halt():
            unsafe:
                asm volatile("hlt")
        """
        check(code.contains("hlt"))

    it "implements LGDT to load GDT":
        val code = """
        fn load_gdt(gdt_ptr: u64):
            unsafe:
                asm volatile(
                    "lgdt [{ptr}]",
                    ptr = in(reg) gdt_ptr
                )
        """
        check(code.contains("lgdt"))

    it "implements LIDT to load IDT":
        val code = """
        fn load_idt(idt_ptr: u64):
            unsafe:
                asm volatile(
                    "lidt [{ptr}]",
                    ptr = in(reg) idt_ptr
                )
        """
        check(code.contains("lidt"))

describe "x86 Control Registers":
    it "reads CR0 control register":
        val code = """
        fn read_cr0() -> u32:
            var value: u32
            unsafe:
                asm(
                    "mov {val}, cr0",
                    val = out(reg) value
                )
            value
        """
        check(code.contains("mov"))
        check(code.contains("cr0"))

    it "writes CR3 page directory":
        val code = """
        fn load_page_directory(addr: u32):
            unsafe:
                asm volatile(
                    "mov cr3, {addr}",
                    addr = in(reg) addr
                )
        """
        check(code.contains("cr3"))

describe "ARM Bare-Metal Operations":
    it "implements ARM semihosting call":
        val code = """
        fn arm_semihost(op: u32, params: u64) -> i64:
            var result: i64
            unsafe:
                asm volatile(
                    "mov r0, {op}",
                    "mov r1, {params}",
                    "bkpt #0xAB",
                    "mov {result}, r0",
                    op = in(reg) op,
                    params = in(reg) params,
                    result = lateout(reg) result,
                    clobber_abi("C")
                )
            result
        """
        check(code.contains("bkpt #0xAB"))
        check(code.contains("mov r0"))

    it "implements ARM WFI (wait for interrupt)":
        val code = """
        fn wait_for_interrupt():
            unsafe:
                asm volatile("wfi")
        """
        check(code.contains("wfi"))

    it "implements ARM data barrier":
        val code = """
        fn data_memory_barrier():
            unsafe:
                asm volatile("dmb")
        """
        check(code.contains("dmb"))

    it "implements ARM instruction barrier":
        val code = """
        fn instruction_sync_barrier():
            unsafe:
                asm volatile("isb")
        """
        check(code.contains("isb"))

describe "RISC-V Bare-Metal Operations":
    it "implements RISC-V semihosting":
        val code = """
        fn riscv_semihost(op: u32, params: u64) -> i64:
            var result: i64
            unsafe:
                asm volatile(
                    "mv a0, {op}",
                    "mv a1, {params}",
                    "ebreak",
                    "mv {result}, a0",
                    op = in(reg) op,
                    params = in(reg) params,
                    result = lateout(reg) result
                )
            result
        """
        check(code.contains("ebreak"))

    it "implements RISC-V WFI":
        val code = """
        fn wait_for_interrupt():
            unsafe:
                asm volatile("wfi")
        """
        check(code.contains("wfi"))

    it "implements RISC-V fence":
        val code = """
        fn memory_fence():
            unsafe:
                asm volatile("fence")
        """
        check(code.contains("fence"))

describe "MMIO Register Access":
    it "reads MMIO register":
        val code = """
        fn mmio_read(addr: u64) -> u32:
            var value: u32
            unsafe:
                asm volatile(
                    "ldr {val}, [{addr}]",
                    val = out(reg) value,
                    addr = in(reg) addr
                )
            value
        """
        check(code.contains("ldr"))

    it "writes MMIO register":
        val code = """
        fn mmio_write(addr: u64, value: u32):
            unsafe:
                asm volatile(
                    "str {val}, [{addr}]",
                    addr = in(reg) addr,
                    val = in(reg) value
                )
        """
        check(code.contains("str"))

    it "atomic MMIO update":
        val code = """
        fn mmio_set_bits(addr: u64, mask: u32):
            unsafe:
                asm volatile(
                    "ldr r0, [{addr}]",
                    "orr r0, r0, {mask}",
                    "str r0, [{addr}]",
                    addr = in(reg) addr,
                    mask = in(reg) mask,
                    out("r0") _
                )
        """
        check(code.contains("orr"))

describe "Spinlock Implementation":
    it "implements test-and-set spinlock":
        val code = """
        fn spinlock_acquire(lock: *mut u32):
            unsafe:
                asm(
                    "1:",
                    "mov eax, 1",
                    "xchg eax, [{lock}]",
                    "test eax, eax",
                    "jnz 1b",
                    lock = in(reg) lock,
                    out("eax") _
                )
        """
        check(code.contains("xchg"))
        check(code.contains("test"))

    it "implements spinlock release":
        val code = """
        fn spinlock_release(lock: *mut u32):
            unsafe:
                asm volatile(
                    "mov dword ptr [{lock}], 0",
                    lock = in(reg) lock
                )
        """
        check(code.contains("mov dword ptr"))

describe "Cache Operations":
    it "implements cache flush (x86)":
        val code = """
        fn flush_cache_line(addr: u64):
            unsafe:
                asm volatile(
                    "clflush [{addr}]",
                    addr = in(reg) addr
                )
        """
        check(code.contains("clflush"))

    it "implements write-back and invalidate":
        val code = """
        fn cache_wbinvd():
            unsafe:
                asm volatile("wbinvd")
        """
        check(code.contains("wbinvd"))

describe "Atomic Operations":
    it "implements compare-and-swap":
        val code = """
        fn atomic_cas(ptr: *mut u32, expected: u32, desired: u32) -> bool:
            var old: u32
            unsafe:
                asm volatile(
                    "lock cmpxchg [{ptr}], {desired}",
                    ptr = in(reg) ptr,
                    desired = in(reg) desired,
                    inout("eax") expected => old
                )
            old == expected
        """
        check(code.contains("lock cmpxchg"))

    it "implements atomic increment":
        val code = """
        fn atomic_inc(ptr: *mut u32):
            unsafe:
                asm volatile(
                    "lock inc dword ptr [{ptr}]",
                    ptr = in(reg) ptr
                )
        """
        check(code.contains("lock inc"))

    it "implements atomic exchange":
        val code = """
        fn atomic_swap(ptr: *mut u32, new_val: u32) -> u32:
            var old: u32
            unsafe:
                asm(
                    "xchg [{ptr}], {val}",
                    ptr = in(reg) ptr,
                    val = inout(reg) new_val => old
                )
            old
        """
        check(code.contains("xchg"))

describe "Context Switching":
    it "saves registers for context switch":
        val code = """
        fn save_context(ctx: *mut Context):
            unsafe:
                asm(
                    "mov [rdi + 0], rax",
                    "mov [rdi + 8], rbx",
                    "mov [rdi + 16], rcx",
                    in("rdi") ctx,
                    out("rax") _,
                    out("rbx") _,
                    out("rcx") _
                )
        """
        check(code.contains("mov [rdi"))

    it "restores registers for context switch":
        val code = """
        fn restore_context(ctx: *Context):
            unsafe:
                asm(
                    "mov rax, [rdi + 0]",
                    "mov rbx, [rdi + 8]",
                    "mov rcx, [rdi + 16]",
                    in("rdi") ctx,
                    out("rax") _,
                    out("rbx") _,
                    out("rcx") _
                )
        """
        check(code.contains("mov rax, [rdi"))

describe "Timer Operations":
    it "reads TSC timestamp counter":
        val code = """
        fn read_tsc() -> u64:
            var low: u32
            var high: u32
            unsafe:
                asm(
                    "rdtsc",
                    low = out("eax") low,
                    high = out("edx") high
                )
            ((high as u64) << 32) | (low as u64)
        """
        check(code.contains("rdtsc"))

    it "reads RDTSCP with core ID":
        val code = """
        fn read_tscp() -> (u64, u32):
            var low: u32
            var high: u32
            var core: u32
            unsafe:
                asm(
                    "rdtscp",
                    low = out("eax") low,
                    high = out("edx") high,
                    core = out("ecx") core
                )
            (((high as u64) << 32) | (low as u64), core)
        """
        check(code.contains("rdtscp"))
