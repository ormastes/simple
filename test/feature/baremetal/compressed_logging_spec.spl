# Compressed Logging E2E Tests
#
# Tests the full pipeline: QEMU -> file -> decoded text
# Uses SYS_WRITEC-based binary protocol (v3) with standard QEMU semihosting.
#
# Pipeline:
#   1. QEMU runs v3 ELF, outputs binary protocol frames to file
#   2. Test parses binary frames and looks up string handles
#   3. Verify decoded text matches expected output
# @platform: baremetal(riscv32)

val V3_ELF = "examples/09_embedded/baremetal/baremetal/hello_riscv32_compressed_v3.elf"
val SMT_FILE = "examples/09_embedded/baremetal/baremetal/hello_riscv32_interned.smt"
val QEMU_BIN = "qemu-system-riscv32"
val OUTPUT_FILE = "/tmp/compressed_v3_test_out.bin"

extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_read_bytes(path: text) -> [u8]
extern fn rt_file_read_text(path: text) -> text
extern fn rt_process_run_timeout(cmd: text, args: [text], timeout_ms: i64) -> (text, text, i32)

fn file_exists(path: text) -> bool:
    rt_file_exists(path)

fn read_file_bytes(path: text) -> [u8]:
    rt_file_read_bytes(path) ?? []

fn read_file_text(path: text) -> text:
    rt_file_read_text(path) ?? ""

# Run QEMU with semihost chardev redirected to file
fn run_qemu_to_file(elf_path: text, out_path: text, timeout_ms: i64) -> i32:
    var chardev_arg = "file,id=sh,path=" + out_path
    var args: [text] = [
        "-M", "virt",
        "-bios", "none",
        "-kernel", elf_path,
        "-chardev", chardev_arg,
        "-semihosting-config", "enable=on,target=native,chardev=sh",
        "-nographic"
    ]
    val (stdout, stderr, exit_code) = rt_process_run_timeout(QEMU_BIN, args, timeout_ms)
    exit_code

# Read u32 little-endian from byte array
fn read_u32_le(data: [u8], offset: i64) -> i64:
    val b0 = data[offset] as i64
    val b1 = data[offset + 1] as i64
    val b2 = data[offset + 2] as i64
    val b3 = data[offset + 3] as i64
    b0 + (b1 * 256) + (b2 * 65536) + (b3 * 16777216)

# Parse binary frames and return list of handle IDs
fn extract_handles(bytes: [u8]) -> [i64]:
    var handles: [i64] = []
    var offset = 0
    while offset + 14 <= bytes.len():
        # Check magic = 0xAB and version = 0x01
        if bytes[offset] as i64 == 171 and bytes[offset + 1] as i64 == 1:
            val op = read_u32_le(bytes, offset + 2)
            val payload_len = read_u32_le(bytes, offset + 6)
            if op == 256 and payload_len == 4:
                # SYS_WRITE_HANDLE (0x100), extract handle
                val handle = read_u32_le(bytes, offset + 10)
                handles.push(handle)
            offset = offset + 10 + payload_len as i64
        else:
            offset = offset + 1
    handles

# Simple JSON parser: extract id->text mapping from .smt file
fn load_smt_texts(smt_path: text) -> [text]:
    # Returns array where index = handle ID, value = text
    # (handles are 1-based, so index 0 is unused)
    var texts: [text] = [""]  # placeholder for index 0
    val content = read_file_text(smt_path)
    if content == "":
        return texts

    # Find each "id": N and corresponding "text": "..."
    var pos = 0
    while pos < content.len():
        val id_marker = "\"id\":"
        var id_pos = -1
        # Manual index_of
        var si = pos
        while si < content.len() - id_marker.len():
            var match_ok = true
            var ci = 0
            while ci < id_marker.len():
                if content[si + ci] != id_marker[ci]:
                    match_ok = false
                    ci = id_marker.len()
                ci = ci + 1
            if match_ok:
                id_pos = si
                si = content.len()
            si = si + 1
        if id_pos < 0:
            pos = content.len()
            continue

        # Parse id number
        var id_start = id_pos + id_marker.len()
        while id_start < content.len() and content[id_start] == " ":
            id_start = id_start + 1
        var id_end = id_start
        while id_end < content.len() and content[id_end] >= "0" and content[id_end] <= "9":
            id_end = id_end + 1
        val id_str = content.substring(id_start, id_end)
        val handle_id = id_str.parse_int() ?? 0

        # Find "text": after this position
        val text_marker = "\"text\":"
        var text_pos = -1
        si = id_end
        while si < content.len() - text_marker.len():
            var match_ok2 = true
            var ci2 = 0
            while ci2 < text_marker.len():
                if content[si + ci2] != text_marker[ci2]:
                    match_ok2 = false
                    ci2 = text_marker.len()
                ci2 = ci2 + 1
            if match_ok2:
                text_pos = si
                si = content.len()
            si = si + 1
        if text_pos < 0:
            pos = content.len()
            continue

        # Extract text value between quotes
        var quote_start = text_pos + text_marker.len()
        while quote_start < content.len() and content[quote_start] != "\"":
            quote_start = quote_start + 1
        quote_start = quote_start + 1
        var quote_end = quote_start
        while quote_end < content.len() and content[quote_end] != "\"":
            if content[quote_end] == "\\":
                quote_end = quote_end + 2
            else:
                quote_end = quote_end + 1
        val entry_text = content.substring(quote_start, quote_end)

        # Pad texts array to handle_id
        while texts.len() <= handle_id:
            texts.push("")
        texts[handle_id] = entry_text

        pos = quote_end + 1

    texts

# Decode binary output to messages using SMT
fn decode_binary_output(bin_path: text, smt_path: text) -> text:
    val bytes = read_file_bytes(bin_path)
    var handles = extract_handles(bytes)
    val smt_texts = load_smt_texts(smt_path)

    var result = ""
    var i = 0
    while i < handles.len():
        val h = handles[i]
        if h < smt_texts.len() as i64:
            result = result + smt_texts[h]
        i = i + 1
    result

describe "Compressed Logging v3 (SYS_WRITEC)":
    it "QEMU produces binary protocol output":
        if not file_exists(V3_ELF):
            print "SKIP: V3 ELF not built: {V3_ELF}"
            return

        run_qemu_to_file(V3_ELF, OUTPUT_FILE, 10000)
        expect(file_exists(OUTPUT_FILE)).to_equal(true)

        val bytes = read_file_bytes(OUTPUT_FILE)
        # Should have at least two frames (14 bytes each = 28 bytes)
        expect(bytes.len()).to_be_greater_than(20)
        # First byte should be protocol magic 0xAB = 171
        expect(bytes[0] as i64).to_equal(171)

    it "binary output contains valid frame structure":
        if not file_exists(V3_ELF):
            print "SKIP: V3 ELF not built"
            return

        run_qemu_to_file(V3_ELF, OUTPUT_FILE, 10000)
        val bytes = read_file_bytes(OUTPUT_FILE)
        # Two frames of 14 bytes each
        expect(bytes.len()).to_equal(28)
        # Frame 1: magic=0xAB, version=0x01
        expect(bytes[0] as i64).to_equal(171)
        expect(bytes[1] as i64).to_equal(1)
        # Frame 2: magic=0xAB, version=0x01
        expect(bytes[14] as i64).to_equal(171)
        expect(bytes[15] as i64).to_equal(1)

    it "decoder resolves handles to Hello message":
        if not file_exists(V3_ELF):
            print "SKIP: V3 ELF not built"
            return

        run_qemu_to_file(V3_ELF, OUTPUT_FILE, 10000)
        val decoded = decode_binary_output(OUTPUT_FILE, SMT_FILE)
        expect(decoded).to_contain("Hello, RISC-V 32!")

    it "decoder resolves all messages":
        if not file_exists(V3_ELF):
            print "SKIP: V3 ELF not built"
            return

        run_qemu_to_file(V3_ELF, OUTPUT_FILE, 10000)
        val decoded = decode_binary_output(OUTPUT_FILE, SMT_FILE)
        expect(decoded).to_contain("Hello, RISC-V 32!")
        expect(decoded).to_contain("SEMIHOST TEST")
        expect(decoded).to_contain("Success")

    it "compressed binary data is smaller than text strings":
        if not file_exists(V3_ELF):
            print "SKIP: V3 ELF not built"
            return

        run_qemu_to_file(V3_ELF, OUTPUT_FILE, 10000)
        val bytes = read_file_bytes(OUTPUT_FILE)
        # 28 bytes of binary protocol vs ~57+ bytes of raw text
        expect(bytes.len()).to_be_less_than(50)
