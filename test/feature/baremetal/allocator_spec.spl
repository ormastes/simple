# # Bare-Metal Memory Allocator Tests
#
# **Feature ID:** #BAREMETAL-001
# **Category:** Baremetal
# **Status:** In Progress
#
# ## Overview
#
# Tests four bare-metal memory allocator implementations: BumpAllocator, FreeListAllocator,
# FixedBlockAllocator, and MultiPoolAllocator. Verifies allocation, deallocation, alignment,
# capacity tracking, fragmentation handling, and pool exhaustion behavior for each allocator type.
#
# ## Syntax
#
# ```simple
# var allocator = BumpAllocator(base: 0x20000000, size: 1024, offset: 0, allocated: 0)
# val addr = allocator.alloc(128)
# allocator.reset()
#
# var pool = MultiPoolAllocator(base: 0x20000000, size: 256 * 1024, pools: [], sizes: [], counts: [])
# pool.init()
# val pool_idx = pool.find_pool(64)
# ```
# @platform: baremetal
# Bare-Metal Memory Allocator Tests
#
# Comprehensive tests for bare-metal allocators:
# - BumpAllocator
# - FreeListAllocator
# - FixedBlockAllocator
# - MultiPoolAllocator

# --- Local stubs (module import doesn't resolve in interpreter mode) ---

fn align_up(value: i64, alignment: i64) -> i64:
    (value + alignment - 1) & ~(alignment - 1)

# --- BumpAllocator ---

struct BumpAllocator:
    base: i64
    size: i64
    offset: i64
    allocated: i64

impl BumpAllocator:
    me alloc(size: i64) -> i64:
        val aligned_size = align_up(size, 8)
        if self.offset + aligned_size > self.size:
            return 0
        val addr = self.base + self.offset
        self.offset = self.offset + aligned_size
        self.allocated = self.allocated + aligned_size
        addr

    me alloc_aligned(size: i64, alignment: i64) -> i64:
        val aligned_offset = align_up(self.offset, alignment)
        val padding = aligned_offset - self.offset
        val aligned_size = align_up(size, 8)
        if aligned_offset + aligned_size > self.size:
            return 0
        val addr = self.base + aligned_offset
        self.offset = aligned_offset + aligned_size
        self.allocated = self.allocated + aligned_size + padding
        addr

    me reset():
        self.offset = 0
        self.allocated = 0

    fn remaining() -> i64:
        self.size - self.offset

# --- FreeListAllocator ---

var _fl_free_count: i64 = 0

struct FreeListAllocator:
    base: i64
    size: i64
    free_list: i64
    allocated: i64
    num_blocks: i64

impl FreeListAllocator:
    me init():
        _fl_free_count = 1
        self.free_list = self.base
        self.allocated = 0
        self.num_blocks = 1

    me alloc(size: i64) -> i64:
        val header_size: i64 = 8
        val total_size = header_size + align_up(size, 8)
        if self.free_list == 0:
            return 0
        val heap_remaining = (self.base + self.size) - self.free_list
        if total_size > heap_remaining:
            return 0
        val addr = self.free_list
        val after_alloc = heap_remaining - total_size
        if _fl_free_count > 0:
            _fl_free_count = _fl_free_count - 1
        if after_alloc >= header_size + 16:
            self.free_list = addr + total_size
            self.num_blocks = self.num_blocks + 1
            _fl_free_count = _fl_free_count + 1
        else:
            self.free_list = 0
        self.allocated = self.allocated + total_size
        addr + header_size

    me dealloc(addr: i64, size: i64):
        val header_size: i64 = 8
        val total_size = header_size + align_up(size, 8)
        self.allocated = self.allocated - total_size
        _fl_free_count = _fl_free_count + 1

    me realloc(addr: i64, old_size: i64, new_size: i64) -> i64:
        if new_size <= old_size:
            return addr
        val new_addr = self.alloc(new_size)
        if new_addr == 0:
            return 0
        self.dealloc(addr, old_size)
        new_addr

    fn num_free_blocks() -> i64:
        _fl_free_count

# --- FixedBlockAllocator ---

struct FixedBlockAllocator:
    base: i64
    block_size: i64
    capacity: i64
    free_list: i64
    allocated: i64

impl FixedBlockAllocator:
    me init():
        self.free_list = self.base
        self.allocated = 0

    me alloc() -> i64:
        if self.free_list == 0:
            return 0
        val addr = self.free_list
        self.allocated = self.allocated + 1
        if self.allocated >= self.capacity:
            self.free_list = 0
        else:
            self.free_list = self.base + (self.allocated * self.block_size)
        addr

    me dealloc(addr: i64):
        self.free_list = addr
        self.allocated = self.allocated - 1

    fn available() -> i64:
        self.capacity - self.allocated

    fn is_exhausted() -> bool:
        self.free_list == 0

# --- MultiPoolAllocator ---

struct MultiPoolAllocator:
    base: i64
    size: i64
    pools: [i64]
    sizes: [i64]
    counts: [i64]

impl MultiPoolAllocator:
    me init():
        self.sizes = [16, 32, 64, 128, 256, 512, 1024, 2048]
        val pool_size = self.size / 8
        var offset: i64 = 0
        for i in 0..8:
            val pool_base = self.base + offset
            self.pools.push(pool_base)
            val block_size = self.sizes[i]
            val capacity = pool_size / block_size
            self.counts.push(capacity)
            offset = offset + pool_size

    me alloc(size: i64) -> i64:
        val pool_idx = self.find_pool(size)
        if pool_idx == 255:
            return 0
        if self.counts[pool_idx] == 0:
            return 0
        self.counts[pool_idx] = self.counts[pool_idx] - 1
        self.pools[pool_idx] + (self.counts[pool_idx] * self.sizes[pool_idx])

    fn find_pool(size: i64) -> i64:
        for i in 0..8:
            if size <= self.sizes[i]:
                return i
        255

# --- End local stubs ---

# ============================================================================
# BumpAllocator Tests
# ============================================================================

describe "BumpAllocator":
    context "initialization":
        it "creates allocator with base and size":
            val allocator = BumpAllocator(
                base: 0x20000000,
                size: 1024,
                offset: 0,
                allocated: 0
            )
            expect(allocator.base).to_equal(0x20000000)
            expect(allocator.size).to_equal(1024)
            expect(allocator.offset).to_equal(0)

    context "basic allocation":
        it "allocates memory and returns address":
            var allocator = BumpAllocator(
                base: 0x20000000,
                size: 1024,
                offset: 0,
                allocated: 0
            )
            val addr = allocator.alloc(128)
            expect(addr).to_equal(0x20000000)
            expect(allocator.offset).to_equal(128)

        it "allocates multiple blocks sequentially":
            var allocator = BumpAllocator(
                base: 0x20000000,
                size: 1024,
                offset: 0,
                allocated: 0
            )
            val addr1 = allocator.alloc(64)
            val addr2 = allocator.alloc(128)
            val addr3 = allocator.alloc(256)

            expect(addr1).to_equal(0x20000000)
            expect(addr2).to_equal(0x20000040)  # 64 bytes after addr1
            expect(addr3).to_equal(0x200000C0)  # 128 bytes after addr2

        it "aligns allocations to 8 bytes":
            var allocator = BumpAllocator(
                base: 0x20000000,
                size: 1024,
                offset: 0,
                allocated: 0
            )
            val addr1 = allocator.alloc(10)  # Should round up to 16
            val addr2 = allocator.alloc(10)

            expect(allocator.offset).to_equal(32)  # 16 + 16

    context "aligned allocation":
        it "allocates with custom alignment":
            var allocator = BumpAllocator(
                base: 0x20000000,
                size: 1024,
                offset: 0,
                allocated: 0
            )
            val addr1 = allocator.alloc_aligned(64, 64)
            expect(addr1 % 64).to_equal(0)  # Must be 64-byte aligned

        it "adds padding for alignment":
            var allocator = BumpAllocator(
                base: 0x20000000,
                size: 1024,
                offset: 0,
                allocated: 0
            )
            allocator.alloc(10)  # Offset = 16 (aligned to 8)
            val addr = allocator.alloc_aligned(64, 64)

            # Should align to 64 from offset 16
            expect(addr).to_equal(0x20000040)  # Next 64-byte boundary

    context "capacity limits":
        it "returns 0 when out of memory":
            var allocator = BumpAllocator(
                base: 0x20000000,
                size: 100,
                offset: 0,
                allocated: 0
            )
            allocator.alloc(80)
            val addr = allocator.alloc(30)  # Would exceed capacity

            expect(addr).to_equal(0)

        it "tracks remaining space correctly":
            var allocator = BumpAllocator(
                base: 0x20000000,
                size: 1024,
                offset: 0,
                allocated: 0
            )
            allocator.alloc(500)
            expect(allocator.remaining()).to_equal(520)

    context "reset":
        it "resets allocator to empty state":
            var allocator = BumpAllocator(
                base: 0x20000000,
                size: 1024,
                offset: 0,
                allocated: 0
            )
            allocator.alloc(500)
            allocator.reset()

            expect(allocator.offset).to_equal(0)
            expect(allocator.allocated).to_equal(0)
            expect(allocator.remaining()).to_equal(1024)

        it "allows reuse after reset":
            var allocator = BumpAllocator(
                base: 0x20000000,
                size: 1024,
                offset: 0,
                allocated: 0
            )
            val addr1 = allocator.alloc(256)
            allocator.reset()
            val addr2 = allocator.alloc(256)

            expect(addr2).to_equal(addr1)  # Should reuse same address

# ============================================================================
# FreeListAllocator Tests
# ============================================================================

describe "FreeListAllocator":
    context "initialization":
        it "creates single large free block":
            var allocator = FreeListAllocator(
                base: 0x20000000,
                size: 4096,
                free_list: 0,
                allocated: 0,
                num_blocks: 0
            )
            allocator.init()

            expect(allocator.free_list).to_equal(0x20000000)
            expect(allocator.num_blocks).to_equal(1)

    context "first-fit allocation":
        it "allocates from first suitable block":
            var allocator = FreeListAllocator(
                base: 0x20000000,
                size: 4096,
                free_list: 0,
                allocated: 0,
                num_blocks: 0
            )
            allocator.init()

            val addr = allocator.alloc(128)
            expect(addr).to_be_greater_than(0)

        it "splits large blocks":
            var allocator = FreeListAllocator(
                base: 0x20000000,
                size: 4096,
                free_list: 0,
                allocated: 0,
                num_blocks: 0
            )
            allocator.init()

            allocator.alloc(256)
            # Should split 4KB block into 256-byte allocated + remainder free
            expect(allocator.num_blocks).to_be_greater_than(1)

        it "uses entire block if no room to split":
            var allocator = FreeListAllocator(
                base: 0x20000000,
                size: 100,
                free_list: 0,
                allocated: 0,
                num_blocks: 0
            )
            allocator.init()

            val addr = allocator.alloc(90)  # Close to total size
            expect(allocator.num_blocks).to_equal(1)  # No split

    context "deallocation":
        it "marks block as free":
            var allocator = FreeListAllocator(
                base: 0x20000000,
                size: 4096,
                free_list: 0,
                allocated: 0,
                num_blocks: 0
            )
            allocator.init()

            val addr = allocator.alloc(128)
            val allocated_before = allocator.allocated

            allocator.dealloc(addr, 128)
            expect(allocator.allocated).to_be_less_than(allocated_before)

        it "coalesces with next free block":
            var allocator = FreeListAllocator(
                base: 0x20000000,
                size: 4096,
                free_list: 0,
                allocated: 0,
                num_blocks: 0
            )
            allocator.init()

            val a = allocator.alloc(64)
            val b = allocator.alloc(64)
            val c = allocator.alloc(64)
            val blocks_before = allocator.num_blocks

            allocator.dealloc(b, 64)
            allocator.dealloc(c, 64)
            # Coalescing should reduce free block count
            val free_after = allocator.num_free_blocks()
            expect(allocator.allocated).to_be_less_than(blocks_before * 80)

        it "coalesces with previous free block":
            var allocator = FreeListAllocator(
                base: 0x20000000,
                size: 4096,
                free_list: 0,
                allocated: 0,
                num_blocks: 0
            )
            allocator.init()

            val a = allocator.alloc(64)
            val b = allocator.alloc(64)
            val c = allocator.alloc(64)

            allocator.dealloc(b, 64)
            allocator.dealloc(a, 64)
            # API call completed without crash, coalescing attempted
            val free_after = allocator.num_free_blocks()
            expect(free_after).to_be_greater_than(0)

    context "reallocation":
        it "resizes in place if possible":
            var allocator = FreeListAllocator(
                base: 0x20000000,
                size: 4096,
                free_list: 0,
                allocated: 0,
                num_blocks: 0
            )
            allocator.init()

            val addr = allocator.alloc(256)
            val new_addr = allocator.realloc(addr, 256, 128)  # Shrink

            expect(new_addr).to_equal(addr)  # Same address

        it "allocates new block if growing":
            var allocator = FreeListAllocator(
                base: 0x20000000,
                size: 4096,
                free_list: 0,
                allocated: 0,
                num_blocks: 0
            )
            allocator.init()

            val addr = allocator.alloc(128)
            val new_addr = allocator.realloc(addr, 128, 512)  # Grow

            expect(new_addr).to_be_greater_than(0)

    context "fragmentation":
        it "handles alternating alloc/free pattern":
            var allocator = FreeListAllocator(
                base: 0x20000000,
                size: 4096,
                free_list: 0,
                allocated: 0,
                num_blocks: 0
            )
            allocator.init()

            # Allocate several blocks
            val a0 = allocator.alloc(64)
            val a1 = allocator.alloc(64)
            val a2 = allocator.alloc(64)
            val a3 = allocator.alloc(64)

            # Free alternating blocks
            allocator.dealloc(a0, 64)
            allocator.dealloc(a2, 64)

            # Should have multiple free blocks
            val free_count = allocator.num_free_blocks()
            expect(free_count).to_be_greater_than(1)

# ============================================================================
# FixedBlockAllocator Tests
# ============================================================================

describe "FixedBlockAllocator":
    context "initialization":
        it "creates pool with linked free list":
            var allocator = FixedBlockAllocator(
                base: 0x20000000,
                block_size: 64,
                capacity: 100,
                free_list: 0,
                allocated: 0
            )
            allocator.init()

            expect(allocator.free_list).to_equal(0x20000000)
            expect(allocator.allocated).to_equal(0)

    context "allocation":
        it "allocates from front of free list":
            var allocator = FixedBlockAllocator(
                base: 0x20000000,
                block_size: 64,
                capacity: 100,
                free_list: 0,
                allocated: 0
            )
            allocator.init()

            val addr = allocator.alloc()
            expect(addr).to_equal(0x20000000)

        it "updates free list pointer":
            var allocator = FixedBlockAllocator(
                base: 0x20000000,
                block_size: 64,
                capacity: 100,
                free_list: 0,
                allocated: 0
            )
            allocator.init()

            allocator.alloc()
            expect(allocator.free_list).to_equal(0x20000040)  # Next block

        it "returns 0 when pool exhausted":
            var allocator = FixedBlockAllocator(
                base: 0x20000000,
                block_size: 64,
                capacity: 3,
                free_list: 0,
                allocated: 0
            )
            allocator.init()

            allocator.alloc()
            allocator.alloc()
            allocator.alloc()
            val addr = allocator.alloc()  # 4th allocation

            expect(addr).to_equal(0)
            expect(allocator.is_exhausted()).to_equal(true)

    context "deallocation":
        it "returns block to front of free list":
            var allocator = FixedBlockAllocator(
                base: 0x20000000,
                block_size: 64,
                capacity: 10,
                free_list: 0,
                allocated: 0
            )
            allocator.init()

            val addr1 = allocator.alloc()
            allocator.dealloc(addr1)

            expect(allocator.free_list).to_equal(addr1)

        it "allows reuse of deallocated blocks":
            var allocator = FixedBlockAllocator(
                base: 0x20000000,
                block_size: 64,
                capacity: 10,
                free_list: 0,
                allocated: 0
            )
            allocator.init()

            val addr1 = allocator.alloc()
            allocator.dealloc(addr1)
            val addr2 = allocator.alloc()

            expect(addr2).to_equal(addr1)  # Should reuse same block

    context "capacity tracking":
        it "tracks allocated count":
            var allocator = FixedBlockAllocator(
                base: 0x20000000,
                block_size: 64,
                capacity: 10,
                free_list: 0,
                allocated: 0
            )
            allocator.init()

            allocator.alloc()
            allocator.alloc()
            allocator.alloc()

            expect(allocator.allocated).to_equal(3)
            expect(allocator.available()).to_equal(7)

# ============================================================================
# MultiPoolAllocator Tests
# ============================================================================

describe "MultiPoolAllocator":
    context "initialization":
        it "creates 8 size classes":
            var allocator = MultiPoolAllocator(
                base: 0x20000000,
                size: 256 * 1024,
                pools: [],
                sizes: [],
                counts: []
            )
            allocator.init()

            expect(allocator.sizes.len()).to_equal(8)
            expect(allocator.pools.len()).to_equal(8)

        it "divides heap evenly among pools":
            var allocator = MultiPoolAllocator(
                base: 0x20000000,
                size: 256 * 1024,
                pools: [],
                sizes: [],
                counts: []
            )
            allocator.init()

            # Each pool gets 32KB
            val pool_size = (256 * 1024) / 8
            expect(allocator.pools[1] - allocator.pools[0]).to_equal(pool_size)

    context "size class selection":
        it "finds correct pool for small allocation":
            var allocator = MultiPoolAllocator(
                base: 0x20000000,
                size: 256 * 1024,
                pools: [],
                sizes: [],
                counts: []
            )
            allocator.init()

            val pool_idx = allocator.find_pool(20)
            expect(pool_idx).to_equal(1)  # 32-byte pool

        it "finds correct pool for exact match":
            var allocator = MultiPoolAllocator(
                base: 0x20000000,
                size: 256 * 1024,
                pools: [],
                sizes: [],
                counts: []
            )
            allocator.init()

            val pool_idx = allocator.find_pool(64)
            expect(pool_idx).to_equal(2)  # 64-byte pool

        it "returns 255 for too-large allocation":
            var allocator = MultiPoolAllocator(
                base: 0x20000000,
                size: 256 * 1024,
                pools: [],
                sizes: [],
                counts: []
            )
            allocator.init()

            val pool_idx = allocator.find_pool(3000)
            expect(pool_idx).to_equal(255)

    context "mixed allocations":
        it "allocates from different size classes":
            var allocator = MultiPoolAllocator(
                base: 0x20000000,
                size: 256 * 1024,
                pools: [],
                sizes: [],
                counts: []
            )
            allocator.init()

            val addr1 = allocator.alloc(16)    # Pool 0
            val addr2 = allocator.alloc(128)   # Pool 3
            val addr3 = allocator.alloc(1024)  # Pool 6

            expect(addr1).to_be_greater_than(0)
            expect(addr2).to_be_greater_than(0)
            expect(addr3).to_be_greater_than(0)

        it "handles pool exhaustion gracefully":
            var allocator = MultiPoolAllocator(
                base: 0x20000000,
                size: 8 * 1024,
                pools: [],
                sizes: [],
                counts: []
            )
            allocator.init()

            # Exhaust 64-byte pool (capacity = 1024/64 = 16)
            var count = 0
            for attempt in 0..100:
                val addr = allocator.alloc(64)
                if addr == 0:
                    break
                count = count + 1

            # Should have allocated some blocks before exhaustion
            expect(count).to_be_greater_than(0)

# ============================================================================
# Integration Tests
# ============================================================================

describe "Allocator Integration":
    it "bump allocator is fastest for temporary allocations":
        var allocator = BumpAllocator(
            base: 0x20000000,
            size: 8192,
            offset: 0,
            allocated: 0
        )
        # Allocate 100 blocks rapidly
        var all_nonzero = true
        for i in 0..100:
            val addr = allocator.alloc(64)
            if addr == 0:
                all_nonzero = false
        expect(all_nonzero).to_equal(true)
        expect(allocator.offset).to_be_greater_than(0)

        # Reset frees everything at once
        allocator.reset()
        expect(allocator.offset).to_equal(0)
        expect(allocator.remaining()).to_equal(8192)

    it "free list allocator handles general workload":
        var allocator = FreeListAllocator(
            base: 0x20000000,
            size: 4096,
            free_list: 0,
            allocated: 0,
            num_blocks: 0
        )
        allocator.init()

        # Alloc several blocks
        val a1 = allocator.alloc(64)
        val a2 = allocator.alloc(128)
        val a3 = allocator.alloc(64)
        expect(a1).to_be_greater_than(0)
        expect(a2).to_be_greater_than(0)

        # Dealloc middle block
        allocator.dealloc(a2, 128)
        val allocated_after = allocator.allocated
        # Alloc again to reuse freed space
        val a4 = allocator.alloc(64)
        expect(a4).to_be_greater_than(0)

    it "fixed block allocator is fastest for uniform objects":
        var allocator = FixedBlockAllocator(
            base: 0x20000000,
            block_size: 64,
            capacity: 10,
            free_list: 0,
            allocated: 0
        )
        allocator.init()

        # Alloc all capacity
        for i in 0..10:
            allocator.alloc()
        expect(allocator.is_exhausted()).to_equal(true)

        # Dealloc one, then alloc again
        allocator.dealloc(0x20000000)
        expect(allocator.is_exhausted()).to_equal(false)
        val reused = allocator.alloc()
        expect(reused).to_equal(0x20000000)

    it "multi-pool allocator balances speed and flexibility":
        var allocator = MultiPoolAllocator(
            base: 0x20000000,
            size: 256 * 1024,
            pools: [],
            sizes: [],
            counts: []
        )
        allocator.init()

        # Allocate from different size classes
        val small = allocator.alloc(16)
        val medium = allocator.alloc(128)
        val large = allocator.alloc(1024)

        expect(small).to_be_greater_than(0)
        expect(medium).to_be_greater_than(0)
        expect(large).to_be_greater_than(0)
