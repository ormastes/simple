"""
# Parser Edge Cases for Operators, Keywords, and Type Syntax

**Feature ID:** #PARSER-015
**Category:** Syntax
**Status:** In Progress

## Overview

The Simple parser must handle several non-trivial syntactic forms that are easy to
mis-parse: the matrix-multiplication operator `@`, the keyword-style bitwise `xor`
operator, and bracket-based array type annotations `[T]`. This spec exercises each
form in isolation and in combination, verifying correct tokenisation, operator
precedence, and type annotation parsing. A `super` keyword test is planned but
commented out pending interpreter support for inheritance dispatch.

## Syntax

```simple
# Matrix multiplication operator (@)
val result = 3 @ 4          # => 12

# Bitwise XOR keyword operator
val bits = 5 xor 3          # => 6

# Array type annotations with square brackets
fn takes_array(items: [i64]) -> [i64]:
    return items

# Combined precedence
val c = (a xor b) @ 2       # xor first, then @
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| `@` operator | Matrix multiplication infix operator parsed as a binary expression |
| `xor` keyword operator | Bitwise XOR expressed as an alphabetic keyword, not a symbol |
| Array type syntax | `[T]` bracket notation used in parameter and return type positions |
| Operator precedence | Verifies correct evaluation order when `@` and `xor` appear together |
"""

describe "Parser Edge Cases":
    """
    Tests for parser edge cases and bug fixes.
    """

    context "Matrix Multiplication Operator":
        it "parses @ operator in expressions":
            val result = 3 @ 4
            expect result == 12

        it "parses @ operator with variables":
            val a = 2
            val b = 5
            val result = a @ b
            expect result == 10

    context "Bitwise XOR Keyword":
        it "parses xor keyword in expressions":
            val result = 5 xor 3
            expect result == 6

        it "parses xor keyword with variables":
            val a = 12
            val b = 7
            val result = a xor b
            expect result == 11

        it "parses xor in complex expressions":
            val result = (5 xor 3) xor 1
            expect result == 7

    # TODO: super keyword not yet implemented in interpreter
    # context "Super Keyword":
    #     it "parses super in simple context":
    #         class Base:
    #             fn greet(): return "Hello"
    #         class Derived(Base):
    #             fn greet():
    #                 val base_msg = super.greet()
    #                 return base_msg + " World"
    #         val obj = Derived()
    #         expect obj.greet() == "Hello World"

    context "Array Type Syntax":
        it "parses array types with square brackets":
            fn takes_array(items: [i64]) -> [i64]:
                return items

            val nums = [1, 2, 3]
            val result = takes_array(nums)
            expect result.length() == 3

        it "parses array return types":
            fn make_array() -> [str]:
                return ["a", "b", "c"]

            val result = make_array()
            expect result[0] == "a"

    context "Operator Precedence":
        it "handles @ and xor together":
            val result = (3 @ 2) xor 5
            expect result == 3  # (3 @ 2) = 6, 6 xor 5 = 3

        it "handles multiple operators":
            val a = 10
            val b = 3
            val c = (a xor b) @ 2
            expect c == 18  # 10 xor 3 = 9, 9 @ 2 = 18
