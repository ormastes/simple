# # Tensor Operations Specification
#
#
# **Feature IDs:** #2210-2230
# **Category:** Syntax / Stdlib
# **Status:** Implemented
#
# Tensor operations for mathematical computing:
# - Tensor<T, N>, Matrix<T>, Vector<T> type aliases
# - Transpose operators (' in m{}, .T outside)
# - Reduction operations (sum, mean, std, etc.)
# - Axis-aware operations
use std.tensor.*

describe "Tensor Type Aliases":
    # Type aliases for common tensor ranks.

    context "Matrix<T>":
        it "is alias for Tensor<T, 2>":
            val A: Matrix<f64> = zeros<f64>([3, 4])
            expect A.ndim == 2

    context "Vector<T>":
        it "is alias for Tensor<T, 1>":
            val x: Vector<f64> = zeros<f64>([5])
            expect x.ndim == 1

    context "concrete aliases":
        it "provides Mat as Matrix<f64>":
            val A: Mat = zeros<f64>([2, 3])
            expect A.shape == [2, 3]

        it "provides Vec as Vector<f64>":
            val x: Vec = ones<f64>([4])
            expect x.shape == [4]

describe "Transpose Operators":
    # Transpose operations:
    # - ' (postfix) inside m{} blocks
    # - .T / .t() outside m{} blocks

    context "property transpose .T":
        it "transposes 2D matrix":
            val A = [[1, 2, 3], [4, 5, 6]]
            val At = A.T
            expect At.shape == [3, 2]
            expect At[0][0] == 1
            expect At[0][1] == 4

        it "is equivalent to .t()":
            val A = [[1, 2], [3, 4]]
            expect A.T == A.t()

    context "postfix transpose ' in m{}":
        it "transposes matrix":
            val A = [[1, 2], [3, 4]]
            val At = m{ A' }
            expect At == [[1, 3], [2, 4]]

        it "chains with matmul":
            val A = [[1, 2], [3, 4]]
            val x = [1, 1]
            val y = m{ A' @ x }
            expect y == [4, 6]

        it "works in complex expressions":
            val A = [[1, 0], [0, 1]]
            val b = [1, 2]
            # (A'A)^-1 A'b for A=I is just b
            val result = m{ (A' @ A) @ A' @ b }
            expect result == [1, 2]

    context "general transpose":
        it "swaps specified dimensions":
            val T = zeros<f64>([2, 3, 4])
            val Tt = T.transpose(0, 2)
            expect Tt.shape == [4, 3, 2]

        it "permutes multiple dimensions":
            val T = zeros<f64>([2, 3, 4, 5])
            val Tp = T.permute([3, 1, 2, 0])
            expect Tp.shape == [5, 3, 4, 2]

describe "Global Reductions":
    # Reduction operations over all elements.

    context "sum":
        it "sums all elements":
            val x = [1.0, 2.0, 3.0, 4.0]
            expect x.sum == 10.0

        it "sums matrix elements":
            val A = [[1, 2], [3, 4]]
            expect A.sum == 10

    context "mean":
        it "computes mean":
            val x = [1.0, 2.0, 3.0, 4.0]
            expect x.mean == 2.5

    context "product":
        it "multiplies all elements":
            val x = [1.0, 2.0, 3.0, 4.0]
            expect x.prod == 24.0

    context "min/max":
        it "finds minimum":
            val x = [3.0, 1.0, 4.0, 1.0, 5.0]
            expect x.min == 1.0

        it "finds maximum":
            val x = [3.0, 1.0, 4.0, 1.0, 5.0]
            expect x.max == 5.0

    context "standard deviation":
        it "computes std":
            val x = [2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0]
            expect x.std.approx(2.0, epsilon: 0.1)

    context "variance":
        it "computes var":
            val x = [2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0]
            expect x.var.approx(4.0, epsilon: 0.1)

    context "norm":
        it "computes L2 norm":
            val x = [3.0, 4.0]
            expect x.norm() == 5.0

        it "computes L1 norm":
            val x = [3.0, -4.0]
            expect x.norm(1) == 7.0

describe "Axis Reductions":
    # Reduction operations along specific axes.

    context "sum along axis":
        it "sums columns (axis=0)":
            val A = [[1, 2], [3, 4], [5, 6]]
            expect A.sum(axis: 0) == [9, 12]

        it "sums rows (axis=1)":
            val A = [[1, 2], [3, 4], [5, 6]]
            expect A.sum(axis: 1) == [3, 7, 11]

        it "keeps dimension with keepdim":
            val A = [[1, 2], [3, 4]]
            val s = A.sum(axis: 0, keepdim: true)
            expect s.shape == [1, 2]

    context "mean along axis":
        it "means columns":
            val A = [[1.0, 2.0], [3.0, 4.0]]
            expect A.mean(axis: 0) == [2.0, 3.0]

    context "min/max along axis":
        it "finds min with indices":
            val A = [[3, 1], [4, 2]]
            val (vals, idx) = A.min(axis: 1)
            expect vals == [1, 2]
            expect idx == [1, 1]

        it "finds max with indices":
            val A = [[3, 1], [4, 2]]
            val (vals, idx) = A.max(axis: 1)
            expect vals == [3, 4]
            expect idx == [0, 0]

    context "argmin/argmax":
        it "returns indices of min":
            val A = [[3, 1, 4], [1, 5, 9]]
            expect A.argmin(axis: 1) == [1, 0]

        it "returns indices of max":
            val A = [[3, 1, 4], [1, 5, 9]]
            expect A.argmax(axis: 1) == [2, 2]

describe "Axis-Aware Slicing":
    # Multi-dimensional slicing with :, ..., and ranges.

    context "single axis slice":
        it "slices first axis":
            val A = [[1, 2, 3], [4, 5, 6]]
            expect A[0] == [1, 2, 3]

        it "slices second axis":
            val A = [[1, 2, 3], [4, 5, 6]]
            expect A.column(0) == [1, 4]

    context "range slices":
        it "slices range on both axes":
            val A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
            expect A[0:2].map(\row: row[1:3]) == [[2, 3], [5, 6]]

    context "ellipsis":
        it "expands to fill dimensions":
            val T = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]  # 2x2x2
            expect T.map(\m: m.column(0)) == [[1, 3], [5, 7]]
            expect T[0] == [[1, 2], [3, 4]]

    context "step slicing":
        it "takes every nth element":
            val x = [0, 1, 2, 3, 4, 5]
            expect x[::2] == [0, 2, 4]

        it "reverses with negative step":
            val x = [0, 1, 2, 3, 4, 5]
            expect x[::-1] == [5, 4, 3, 2, 1, 0]

describe "Shape Manipulation":
    # Reshape, squeeze, unsqueeze operations.

    context "reshape":
        it "reshapes to new dimensions":
            val A = [[1, 2, 3], [4, 5, 6]]
            expect A.reshape([6]).shape == [6]
            expect A.reshape([3, 2]).shape == [3, 2]

        it "infers dimension with -1":
            val A = [[1, 2, 3], [4, 5, 6]]
            expect A.reshape([-1]).shape == [6]
            expect A.reshape([3, -1]).shape == [3, 2]

    context "squeeze":
        it "removes size-1 dimensions":
            val A = zeros<f64>([1, 3, 1, 4])
            expect A.squeeze().shape == [3, 4]

        it "removes specific dimension":
            val A = zeros<f64>([1, 3, 1, 4])
            expect A.squeeze(0).shape == [3, 1, 4]

    context "unsqueeze":
        it "adds dimension at position":
            val x = [1, 2, 3]
            expect x.unsqueeze(0).shape == [1, 3]
            expect x.unsqueeze(1).shape == [3, 1]

describe "Tensor Construction":
    # Factory functions for creating tensors.

    context "zeros/ones":
        it "creates zero tensor":
            val A = zeros<f64>([2, 3])
            expect A.sum == 0.0

        it "creates ones tensor":
            val A = ones<f64>([2, 3])
            expect A.sum == 6.0

    context "eye":
        it "creates identity matrix":
            val I = eye<f64>(3)
            expect I[0][0] == 1.0
            expect I[0][1] == 0.0
            expect I.trace() == 3.0

    context "arange":
        it "creates range tensor":
            val x = arange(0, 5, 1)
            expect x == [0, 1, 2, 3, 4]

        it "creates stepped range":
            val x = arange(0, 10, 2)
            expect x == [0, 2, 4, 6, 8]

    context "linspace":
        it "creates linearly spaced values":
            val x = linspace(0.0, 1.0, 5)
            expect x[0] == 0.0
            expect x[4] == 1.0
            expect x.len() == 5

describe "Elementwise Math":
    # Elementwise mathematical functions.

    context "basic functions":
        it "computes absolute value":
            val x = [-1.0, 2.0, -3.0]
            expect x.abs() == [1.0, 2.0, 3.0]

        it "computes square root":
            val x = [1.0, 4.0, 9.0]
            expect x.sqrt() == [1.0, 2.0, 3.0]

        it "computes exponential":
            val x = [0.0, 1.0]
            expect x.exp()[0].approx(1.0)
            expect x.exp()[1].approx(2.718, epsilon: 0.01)

    context "trigonometric":
        it "computes sin/cos":
            val x = [0.0]
            expect x.sin()[0].approx(0.0)
            expect x.cos()[0].approx(1.0)

    context "clamp":
        it "clamps to range":
            val x = [-1.0, 0.5, 2.0]
            expect x.clamp(min: 0.0, max: 1.0) == [0.0, 0.5, 1.0]

describe "Linear Algebra":
    # Linear algebra operations.

    context "determinant":
        it "computes 2x2 determinant":
            val A = [[1.0, 2.0], [3.0, 4.0]]
            expect A.det().approx(-2.0)

    context "inverse":
        it "computes matrix inverse":
            val A = [[1.0, 2.0], [3.0, 4.0]]
            val Ainv = A.inv()
            val I = A @ Ainv
            expect I[0][0].approx(1.0)
            expect I[0][1].approx(0.0)

    context "solve":
        it "solves linear system":
            val A = [[2.0, 1.0], [1.0, 3.0]]
            val b = [4.0, 5.0]
            val x = A.solve(b)
            expect (A @ x)[0].approx(4.0)
            expect (A @ x)[1].approx(5.0)

    context "trace":
        it "sums diagonal elements":
            val A = [[1, 2], [3, 4]]
            expect A.trace() == 5
