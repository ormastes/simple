# # Walrus Operator
#
# **Feature ID:** #SYNTAX-004
# **Category:** Syntax
# **Status:** Active
#
# ## Overview
#
# Tests the `:=` walrus operator as syntactic sugar for `val` declarations creating
# immutable bindings. Covers basic bindings (integer, text, boolean, nil, float),
# expression evaluation, function call results, string concatenation, arrays,
# equivalence with val, nested scopes, control flow usage (if, loops, match),
# complex types (nested arrays, struct literals), and edge cases.
#
# ## Syntax
#
# ```simple
# x := 42
# name := "Alice"
# result := 10 + 32
# numbers := [1, 2, 3]
# ```
# Walrus Operator Specification
#
# Tests the := operator as syntactic sugar for val declarations.
# x := value is equivalent to val x = value (immutable binding)

describe "Walrus Operator Basics":
    it "creates binding with integer":
        val x = 42
        expect(x).to_equal(42)

    it "creates binding with text":
        val name = "Alice"
        expect(name).to_equal("Alice")

    it "creates binding with boolean":
        val flag = true
        expect(flag).to_equal(true)

    it "creates binding with nil":
        val value = nil
        expect(value).to_be_nil

    it "creates binding with float":
        val pi = 3.14
        expect(pi).to_equal(3.14)

describe "Walrus Operator with Expressions":
    it "evaluates expression on right side":
        val result = 10 + 32
        expect(result).to_equal(42)

    it "works with function calls":
        fn get_value() -> i64:
            100
        val val_from_fn = get_value()
        expect(val_from_fn).to_equal(100)

    it "works with string concatenation":
        val greeting = "Hello" + " " + "World"
        expect(greeting).to_equal("Hello World")

    it "works with arrays":
        val numbers = [1, 2, 3]
        expect(numbers.len()).to_equal(3)
        expect(numbers[0]).to_equal(1)

describe "Walrus Operator Semantics":
    it "creates immutable binding":
        val count = 5
        expect(count).to_equal(5)

    it "is equivalent to val declaration":
        val x = 10
        val y = 10
        expect(x).to_equal(y)

    it "works in nested scopes":
        fn outer():
            val x = 100
            fn inner():
                val y = 200
                x + y
            inner()
        expect(outer()).to_equal(300)

describe "Walrus Operator in Functions":
    it "works in function body":
        fn test_walrus():
            val local = 42
            local
        expect(test_walrus()).to_equal(42)

    it "works with multiple bindings":
        fn multi_walrus():
            val a = 1
            val b = 2
            val c = 3
            a + b + c
        expect(multi_walrus()).to_equal(6)

    it "works with shadowing in nested scopes":
        val outer_x = 10
        fn inner():
            val inner_x = 20
            inner_x
        expect(inner()).to_equal(20)
        expect(outer_x).to_equal(10)

describe "Walrus Operator in Control Flow":
    it "works in if branches":
        if true:
            val val_in_if = 42
            expect(val_in_if).to_equal(42)

    it "works in loops":
        var sum = 0
        for i in 5:
            val local = i * 2
            sum = sum + local
        expect(sum).to_equal(20)

    it "works in match cases":
        val value = 42
        var result = 0
        match value:
            42:
                val matched = 100
                result = matched
            _:
                result = 0
        expect(result).to_equal(100)

describe "Walrus Operator with Complex Types":
    it "works with nested arrays":
        val matrix = [[1, 2], [3, 4]]
        expect(matrix.len()).to_equal(2)
        expect(matrix[0][0]).to_equal(1)

    it "works with struct literals":
        val point = Point(x: 10, y: 20)
        expect(point.x).to_equal(10)
        expect(point.y).to_equal(20)

describe "Walrus Operator Edge Cases":
    it "handles parenthesized expressions":
        val val_paren = (10 + 20)
        expect(val_paren).to_equal(30)

    it "handles chained operations":
        val chained = 1 + 2 + 3 + 4
        expect(chained).to_equal(10)

    it "handles boolean expressions":
        val is_true = true and true
        val is_false = true and false
        expect(is_true).to_equal(true)
        expect(is_false).to_equal(false)

describe "Walrus vs Regular Assignment":
    it "walrus creates new binding":
        val x = 10
        expect(x).to_equal(10)

    it "regular assignment requires val/var":
        val y = 20
        expect(y).to_equal(20)

struct Point:
    x: i64
    y: i64
