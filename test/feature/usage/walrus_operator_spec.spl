# # Walrus Operator
#
# **Feature ID:** #SYNTAX-004
# **Category:** Syntax
# **Status:** Active
#
# ## Overview
#
# Tests the `:=` walrus operator as syntactic sugar for `val` declarations creating
# immutable bindings. Covers basic bindings (integer, text, boolean, nil, float),
# expression evaluation, function call results, string concatenation, arrays,
# equivalence with val, nested scopes, control flow usage (if, loops, match),
# complex types (nested arrays, struct literals), and edge cases.
#
# ## Syntax
#
# ```simple
# x := 42
# name := "Alice"
# result := 10 + 32
# numbers := [1, 2, 3]
# ```
# Walrus Operator Specification
#
# Tests the := operator as syntactic sugar for val declarations.
# x := value is equivalent to val x = value (immutable binding)

describe "Walrus Operator Basics":
    it "creates binding with integer":
        x := 42
        expect(x).to_equal(42)

    it "creates binding with text":
        name := "Alice"
        expect(name).to_equal("Alice")

    it "creates binding with boolean":
        flag := true
        expect(flag).to_equal(true)

    it "creates binding with nil":
        value := nil
        expect(value).to_be_nil()

    it "creates binding with float":
        pi := 3.14
        expect(pi).to_equal(3.14)

describe "Walrus Operator with Expressions":
    it "evaluates expression on right side":
        result := 10 + 32
        expect(result).to_equal(42)

    it "works with function calls":
        fn get_value() -> i64:
            100
        val_from_fn := get_value()
        expect(val_from_fn).to_equal(100)

    it "works with string concatenation":
        greeting := "Hello" + " " + "World"
        expect(greeting).to_equal("Hello World")

    it "works with arrays":
        numbers := [1, 2, 3]
        expect(numbers.len()).to_equal(3)
        expect(numbers[0]).to_equal(1)

describe "Walrus Operator Semantics":
    it "creates immutable binding":
        count := 5
        expect(count).to_equal(5)

    it "is equivalent to val declaration":
        x := 10
        val y = 10
        expect(x).to_equal(y)

    it "works in nested scopes":
        fn outer():
            x := 100
            fn inner():
                y := 200
                x + y
            inner()
        expect(outer()).to_equal(300)

describe "Walrus Operator in Functions":
    it "works in function body":
        fn test_walrus():
            local := 42
            local
        expect(test_walrus()).to_equal(42)

    it "works with multiple bindings":
        fn multi_walrus():
            a := 1
            b := 2
            c := 3
            a + b + c
        expect(multi_walrus()).to_equal(6)

    it "works with shadowing in nested scopes":
        outer_x := 10
        fn inner():
            inner_x := 20
            inner_x
        expect(inner()).to_equal(20)
        expect(outer_x).to_equal(10)

describe "Walrus Operator in Control Flow":
    it "works in if branches":
        if true:
            val_in_if := 42
            expect(val_in_if).to_equal(42)

    it "works in loops":
        var sum = 0
        for i in 5:
            local := i * 2
            sum = sum + local
        expect(sum).to_equal(20)

    it "works in match cases":
        val value = 42
        var result = 0
        match value:
            case 42:
                matched := 100
                result = matched
            case _:
                result = 0
        expect(result).to_equal(100)

describe "Walrus Operator with Complex Types":
    it "works with nested arrays":
        matrix := [[1, 2], [3, 4]]
        expect(matrix.len()).to_equal(2)
        expect(matrix[0][0]).to_equal(1)

    it "works with struct literals":
        point := Point(x: 10, y: 20)
        expect(point.x).to_equal(10)
        expect(point.y).to_equal(20)

describe "Walrus Operator Edge Cases":
    it "handles parenthesized expressions":
        val_paren := (10 + 20)
        expect(val_paren).to_equal(30)

    it "handles chained operations":
        chained := 1 + 2 + 3 + 4
        expect(chained).to_equal(10)

    it "handles boolean expressions":
        is_true := true and true
        is_false := true and false
        expect(is_true).to_equal(true)
        expect(is_false).to_equal(false)

describe "Walrus vs Regular Assignment":
    it "walrus creates new binding":
        x := 10
        expect(x).to_equal(10)

    it "regular assignment requires val/var":
        val y = 20
        expect(y).to_equal(20)

struct Point:
    x: i64
    y: i64
