# # Quaternion Specification
#
#
# **Feature IDs:** #MATH-003
# **Category:** Stdlib
# **Difficulty:** 3/5
# **Status:** Implemented
#
# ## Overview
# Quat (f32) and Quatd (f64) quaternion types for 3D rotations.
#
# ## Key Concepts
# | Concept | Description |
# |---------|-------------|
# | Quat | Quaternion with f32 precision |
# | SLERP | Spherical linear interpolation |
# | Composition | Rotation composition via multiplication |
#
# ## Behavior
# - Identity quaternion represents no rotation
# - from_axis_angle and from_euler constructors
# - SLERP interpolation for smooth rotation
# - Quaternion-vector rotation

use math

# ============================================================================
# Quaternion Construction
# ============================================================================

describe "Quaternion Construction":
    it "creates identity quaternion":
        val q = math.Quat.identity()
        expect q.w == 1.0
        expect q.x == 0.0
        expect q.y == 0.0
        expect q.z == 0.0

    it "creates from axis-angle":
        val axis = math.Vec3(0.0, 1.0, 0.0)
        val q = math.Quat.from_axis_angle(axis, 0.0)
        # Zero rotation = identity
        expect q.w == 1.0

    it "normalizes a quaternion":
        val q = math.Quat(2.0, 0.0, 0.0, 0.0)
        val n = q.normalize()
        expect n.w == 1.0
        expect n.x == 0.0

# ============================================================================
# Quaternion Rotation
# ============================================================================

describe "Quaternion Rotation":
    it "identity rotation leaves vector unchanged":
        val q = math.Quat.identity()
        val v = math.Vec3(1.0, 2.0, 3.0)
        val r = q.rotate_vector(v)
        expect r.x == 1.0
        expect r.y == 2.0
        expect r.z == 3.0

    it "composes rotations via multiplication":
        val q1 = math.Quat.identity()
        val q2 = math.Quat.identity()
        val q3 = q1.mul(q2)
        expect q3.w == 1.0
        expect q3.x == 0.0

    it "conjugate negates vector part":
        val q = math.Quat(1.0, 2.0, 3.0, 4.0)
        val c = q.conjugate()
        expect c.w == 1.0
        expect c.x == -2.0
        expect c.y == -3.0
        expect c.z == -4.0

# ============================================================================
# Quaternion SLERP
# ============================================================================

describe "Quaternion SLERP":
    it "slerp at t=0 returns start":
        val a = math.Quat.identity()
        val b = math.Quat.from_axis_angle(math.Vec3.up(), 1.57)
        val r = a.slerp(b, 0.0)
        expect r.w == a.w

    it "slerp at t=1 returns end":
        val a = math.Quat.identity()
        val axis = math.Vec3(0.0, 1.0, 0.0)
        val b = math.Quat.from_axis_angle(axis, 1.57)
        val r = a.slerp(b, 1.0)
        # Should be close to b
        val diff = (r.w - b.w).abs()
        expect diff < 0.01

# ============================================================================
# Quaternion Conversions
# ============================================================================

describe "Quaternion Conversions":
    it "converts to rotation matrix":
        val q = math.Quat.identity()
        val m = q.to_mat4()
        expect m.data[0] == 1.0
        expect m.data[5] == 1.0
        expect m.data[10] == 1.0

    it "converts between f32 and f64":
        val q32 = math.Quat(1.0, 0.0, 0.0, 0.0)
        val q64 = q32.to_f64()
        expect q64.w == 1.0
        val q32b = q64.to_f32()
        expect q32b.w == 1.0
