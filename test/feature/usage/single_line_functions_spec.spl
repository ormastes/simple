# # Single-Line Function Definitions Specification
#
# **Feature IDs:** #SYNTAX-INLINE
# **Category:** Syntax
# **Status:** Implemented
#
# Single-line (inline) function definitions allow functions to be defined with
# an implicit return expression on the same line as the function signature.
# The syntax replaces the indented block with an expression that is automatically
# returned.
#
# ## Syntax
#
# ```simple
# fn name(): implicit_return_expr
# fn name(param: Type) -> ReturnType: expr
# ```
#
# ## Key Behaviors
#
# - Single-line functions have an implicit return expression (no explicit `return` needed)
# - The expression is evaluated and returned automatically
# - Explicit return types are optional but supported
# - Works with zero, one, or multiple parameters
# - Compatible with class methods and static functions
# - Traditional block syntax is still supported and can be mixed in the same file



describe "Single-Line Function Definitions":
    # Verifies that inline expression body syntax works correctly for function
    # definitions. Tests cover basic single-line syntax, return types,
    # method definitions, and interaction with traditional block syntax.

    context "basic syntax":
        it "parses inline expression body":
            fn double(x): x * 2
            expect double(5) == 10

        it "parses with multiple parameters":
            fn add(a, b): a + b
            expect add(3, 4) == 7

        it "parses with no parameters":
            fn get_answer(): 42
            expect get_answer() == 42

        it "handles complex expressions":
            fn complex(x): (x * 2) + (x / 2)
            expect complex(10) == 25

        it "returns immediately without explicit return":
            fn square(x): x * x
            expect square(4) == 16

    context "with explicit return types":
        it "supports explicit return type annotation":
            fn typed_double(x: i64) -> i64: x * 2
            expect typed_double(5) == 10

        it "works with function parameter types":
            fn typed_add(a: i64, b: i64) -> i64: a + b
            expect typed_add(10, 20) == 30

        it "infers return type from expression":
            fn inferred(x): x + 1
            expect inferred(41) == 42

    context "with method definitions":
        it "works with class methods":
            class Counter:
                count: i64

                fn get_count(): self.count

            val c = Counter(count: 42)
            expect c.get_count() == 42

        it "works with mutable methods":
            class Accumulator:
                total: i64

                me add(value: i64):
                    self.total = self.total + value

            val acc = Accumulator(total: 0)
            acc.add(5)
            acc.add(10)
            expect acc.total == 15

        it "works with static functions":
            class MathHelper:
                static fn pi_approximation(): 3.14159

            expect MathHelper.pi_approximation() == 3.14159

    context "with collection operations":
        it "works with lambda-like expressions":
            fn twice_each(items: List<i64>): items.map(\x: x * 2)
            expect twice_each([1, 2, 3]) == [2, 4, 6]

        it "handles filtering in single line":
            fn evens_only(items: List<i64>): items.filter(\x: x % 2 == 0)
            expect evens_only([1, 2, 3, 4, 5]) == [2, 4]

    context "mixing with block syntax":
        it "can coexist with traditional block functions":
            fn inline(x): x * 2
            fn block(x):
                val doubled = inline(x)
                doubled + 1
            expect block(5) == 11

        it "block functions still work normally":
            fn block_complex(x):
                val y = x * 2
                y + 1
            expect block_complex(5) == 11

        it "allows either style in same module":
            fn style1(x): x + 1
            fn style2(x):
                x + 2
            expect style1(10) == 11
            expect style2(10) == 12

    context "edge cases":
        it "works with nested function calls":
            fn inner(x): x + 1
            fn outer(x):
                inner(x * 2)
            expect outer(5) == 11

        it "handles string expressions":
            fn greeting(name): "Hello, {name}!"
            expect greeting("World") == "Hello, World!"

        it "works with conditional expressions":
            fn max_of_two(a, b): if a > b: a else: b
            expect max_of_two(10, 5) == 10
            expect max_of_two(3, 8) == 8
