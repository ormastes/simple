# # Parser Type Annotations Specification
#
# **Feature IDs:** #PARSER-TYPE-001 to #PARSER-TYPE-012
# **Category:** Infrastructure | Parser
# **Status:** Implemented
#
# Tests that the parser correctly parses type annotations including
# SIMD types, unit types, typed strings, and array types.
#
# ## Type Syntax
#
# ```simple
# # SIMD vectors
# let v: vec[4, f32] = simd_vec
#
# # Unit types
# unit UserId: i64 as uid
# unit IpAddr: str | u32 as ip
#
# # Typed strings
# let addr = "127.0.0.1"_ip
# let path = 'C:/data.txt'_file
#
# # Array types
# let arr: [i32] = []       # Dynamic
# let fixed: [i32; 10] = [] # Fixed size
# ```

use std.spec


# ============================================================================
# Test Group 1: SIMD Type Parsing
# ============================================================================

describe "SIMD Type Parsing":
    # ## SIMD Vector Types
    #
    # Tests parsing of SIMD vector type annotations.

    it "parses vec[4, f32] type":
        let v: vec[4, f32] = simd_zero()
        # If it parses, the type annotation is valid
        expect true

    it "parses vec[8, i32] type":
        let v: vec[8, i32] = simd_zero()
        expect true

    it "parses vec[2, f64] type":
        let v: vec[2, f64] = simd_zero()
        expect true

    it "parses SIMD function parameters":
        fn add_vectors(a: vec[4, f32], b: vec[4, f32]) -> vec[4, f32]:
            a  # placeholder
        expect true

    it "parses SIMD return type":
        fn get_vector() -> vec[4, f32]:
            simd_zero()
        expect true


# ============================================================================
# Test Group 2: Unit Type Declarations
# ============================================================================

describe "Unit Type Declarations":
    # ## Unit Type Syntax
    #
    # Tests parsing of unit type declarations.

    context "single base unit":
        it "parses unit with single base type":
            unit UserId: i64 as uid
            val id: UserId = 42_uid
            expect true

        it "parses unit with suffix":
            unit Temperature: f64 as deg
            val temp: Temperature = 98.6_deg
            expect true

    context "multi-base unit":
        it "parses unit with two base types":
            unit IpAddr: str | u32 as ip
            expect true

        it "parses unit with multiple base types":
            unit MacAddr: str | u64 as mac
            expect true


# ============================================================================
# Test Group 3: Typed String Literals
# ============================================================================

describe "Typed String Literals":
    # ## String Suffix Syntax
    #
    # Tests parsing of strings with unit suffixes.

    it "parses string with _ip suffix":
        unit IpAddr: str as ip
        let addr = "127.0.0.1"_ip
        expect true

    it "parses raw string with _file suffix":
        unit FilePath: str as file
        let path = 'C:/Users/data.txt'_file
        expect true

    it "parses string with _http suffix":
        unit HttpUrl: str as http
        let url = "https://example.com"_http
        expect true

    it "parses string with custom suffix":
        unit Email: str as email
        let addr = "user@example.com"_email
        expect true


# ============================================================================
# Test Group 4: Array Type Syntax
# ============================================================================

describe "Array Type Syntax":
    # ## Array Type Annotations
    #
    # Tests parsing of array type annotations.

    context "dynamic arrays":
        it "parses [i32] type":
            let arr: [i32] = [1, 2, 3]
            expect arr.len() == 3

        it "parses [str] type":
            let names: [str] = ["a", "b", "c"]
            expect names.len() == 3

        it "parses nested array type":
            let matrix: [[i32]] = [[1, 2], [3, 4]]
            expect matrix.len() == 2

    context "fixed-size arrays":
        it "parses [i32; 10] type":
            let arr: [i32; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            expect arr.len() == 10

        it "parses [f64; 3] type":
            let vec: [f64; 3] = [1.0, 2.0, 3.0]
            expect vec.len() == 3


# ============================================================================
# Test Group 5: Generic Type Annotations
# ============================================================================

describe "Generic Type Annotations":
    # ## Generic Type Syntax
    #
    # Tests parsing of generic type annotations.

    it "parses Option<T> type":
        let opt: Option<i64> = Some(42)
        expect opt.?

    it "parses Result<T, E> type":
        let res: Result<i64, str> = Ok(42)
        expect res.ok.?

    it "parses nested generic type":
        let opt: Option<Option<i64>> = Some(Some(42))
        expect opt.?

    it "parses generic with multiple params":
        let map: Dict<str, i64> = {"a": 1}
        expect map.len() == 1


# ============================================================================
# Test Group 6: Function Type Annotations
# ============================================================================

describe "Function Type Annotations":
    # ## Function Type Syntax
    #
    # Tests parsing of function type annotations.

    it "parses fn type annotation":
        let f: fn(i64) -> i64 = \x: x * 2
        expect f(21) == 42

    it "parses fn with multiple params":
        let add: fn(i64, i64) -> i64 = \a, b: a + b
        expect add(20, 22) == 42

    it "parses fn returning unit":
        let printer: fn(str) -> () = \s: print(s)
        expect true


# ============================================================================
# Test Group 7: Tuple Type Annotations
# ============================================================================

describe "Tuple Type Annotations":
    # ## Tuple Type Syntax
    #
    # Tests parsing of tuple type annotations.

    it "parses (i64, str) type":
        let pair: (i64, str) = (42, "hello")
        expect pair.0 == 42

    it "parses triple tuple":
        let triple: (i64, str, bool) = (1, "a", true)
        expect triple.2 == true

    it "parses nested tuple":
        let nested: ((i64, i64), str) = ((1, 2), "point")
        expect nested.0.0 == 1


# ============================================================================
# Test Group 8: Reference Type Annotations
# ============================================================================

describe "Reference Type Annotations":
    # ## Reference Type Syntax
    #
    # Tests parsing of reference type annotations.

    it "parses mutable reference":
        fn modify(x: mut i64):
            x = x + 1
        var n = 41
        modify(n)
        expect n == 42

    it "parses immutable reference":
        fn read_only(x: i64) -> i64:
            x * 2
        val n = 21
        expect read_only(n) == 42


# ============================================================================
# Test Group 9: Complex Type Combinations
# ============================================================================

describe "Complex Type Combinations":
    # ## Combined Type Annotations
    #
    # Tests parsing of complex combined types.

    it "parses Option<[i64]>":
        let opt: Option<[i64]> = Some([1, 2, 3])
        expect opt.?

    it "parses Result<(i64, str), str>":
        let res: Result<(i64, str), str> = Ok((42, "answer"))
        expect res.ok.?

    it "parses fn returning Option":
        let f: fn(i64) -> Option<i64> = \x: if x > 0: Some(x) else: None
        expect f(42).?

