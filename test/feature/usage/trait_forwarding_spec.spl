# Trait Alias Forwarding Tests (Phase 3)
#
# Tests verify the delegation pattern that desugar generates from
# `alias TraitName = field_name` inside class bodies.
#
# Since the desugar pass produces forwarding methods like:
#   fn method(): self.field.method()
#   me mutate(x): self.field.mutate(x)
# these tests exercise that generated delegation pattern directly.

# ============================================================================
# Helper classes used across tests
# ============================================================================

class SizedCollection:
    count: i64
    fn size() -> i64:
        self.count

class MutableList:
    length: i64
    last_added: i64
    me add(item: i64):
        self.length = self.length + 1
        self.last_added = item
    fn size() -> i64:
        self.length
    fn last() -> i64:
        self.last_added

class Logger:
    entries: i64
    prefix: text
    me log(msg: text):
        self.entries = self.entries + 1
    fn entry_count() -> i64:
        self.entries
    fn get_prefix() -> text:
        self.prefix

class Formatter:
    style: text
    fn format(value: text) -> text:
        "{self.style}: {value}"

# ============================================================================
# Tests
# ============================================================================

describe "Trait Alias Forwarding (Phase 3)":

    it "delegates immutable method to field":
        class Inner:
            data: i64
            fn get_data() -> i64:
                self.data

        # This is what desugar generates from "alias Readable = inner"
        class Wrapper:
            inner: Inner
            fn get_data() -> i64:
                self.inner.get_data()

        val w = Wrapper(inner: Inner(data: 42))
        expect(w.get_data()).to_equal(42)

    it "delegates mutable method to field":
        # Desugar generates: me add(item): self.items.add(item)
        class Container:
            items: MutableList
            me add(item: i64):
                self.items.add(item)
            fn size() -> i64:
                self.items.size()

        var c = Container(items: MutableList(length: 0, last_added: 0))
        c.add(99)
        expect(c.size()).to_equal(1)

    it "forwards to multiple different fields":
        # Desugar generates forwarding for two separate fields
        class App:
            log: Logger
            fmt: Formatter
            me record(msg: text):
                self.log.log(msg)
            fn entry_count() -> i64:
                self.log.entry_count()
            fn style_text(value: text) -> text:
                self.fmt.format(value)

        var app = App(log: Logger(entries: 0, prefix: "APP"), fmt: Formatter(style: "bold"))
        app.record("hello")
        expect(app.entry_count()).to_equal(1)
        val styled = app.style_text("test")
        expect(styled).to_equal("bold: test")

    it "forwards methods that take arguments":
        class Calculator:
            x: i64
            y: i64
            fn add(a: i64, b: i64) -> i64:
                a + b + self.x
            fn multiply(a: i64, b: i64) -> i64:
                a * b

        # Desugar generates: fn add(a, b): self.calc.add(a, b)
        class MathWrapper:
            calc: Calculator
            fn add(a: i64, b: i64) -> i64:
                self.calc.add(a, b)
            fn multiply(a: i64, b: i64) -> i64:
                self.calc.multiply(a, b)

        val w = MathWrapper(calc: Calculator(x: 10, y: 0))
        expect(w.add(3, 4)).to_equal(17)
        expect(w.multiply(5, 6)).to_equal(30)

    it "preserves state across mutable forwarding calls":
        # Forwarded me methods must mutate the actual field
        class Counter:
            n: i64
            me increment():
                self.n = self.n + 1
            me decrement():
                self.n = self.n - 1
            fn value() -> i64:
                self.n

        class TrackedCounter:
            counter: Counter
            me increment():
                self.counter.increment()
            me decrement():
                self.counter.decrement()
            fn value() -> i64:
                self.counter.value()

        var tc = TrackedCounter(counter: Counter(n: 0))
        tc.increment()
        tc.increment()
        tc.increment()
        tc.decrement()
        expect(tc.value()).to_equal(2)

    it "returns correct values through forwarding chain":
        class DataStore:
            name: text
            version: i64
            fn get_name() -> text:
                self.name
            fn get_version() -> i64:
                self.version
            fn describe() -> text:
                "{self.name} v{self.version}"

        # Desugar generates three fn forwarding methods
        class Service:
            store: DataStore
            fn get_name() -> text:
                self.store.get_name()
            fn get_version() -> i64:
                self.store.get_version()
            fn describe() -> text:
                self.store.describe()

        val svc = Service(store: DataStore(name: "myapp", version: 3))
        expect(svc.get_name()).to_equal("myapp")
        expect(svc.get_version()).to_equal(3)
        expect(svc.describe()).to_equal("myapp v3")

    it "forwarding works alongside own methods":
        class Engine:
            power: i64
            fn horsepower() -> i64:
                self.power

        # Class has its own methods AND forwarded methods
        class Car:
            engine: Engine
            color: text
            fn horsepower() -> i64:
                self.engine.horsepower()
            fn get_color() -> text:
                self.color
            fn summary() -> text:
                "{self.color} car with {self.engine.horsepower()}hp"

        val car = Car(engine: Engine(power: 200), color: "red")
        expect(car.horsepower()).to_equal(200)
        expect(car.get_color()).to_equal("red")
        expect(car.summary()).to_equal("red car with 200hp")

    it "forwarding with mixed mutable and immutable methods":
        class Buffer:
            content: text
            size: i64
            me write(data: text):
                self.content = self.content + data
                self.size = self.size + 1
            fn read() -> text:
                self.content
            fn count() -> i64:
                self.size

        # Desugar generates both fn and me forwarding methods
        class Stream:
            buf: Buffer
            me write(data: text):
                self.buf.write(data)
            fn read() -> text:
                self.buf.read()
            fn count() -> i64:
                self.buf.count()

        var s = Stream(buf: Buffer(content: "", size: 0))
        s.write("hello")
        s.write(" world")
        expect(s.read()).to_equal("hello world")
        expect(s.count()).to_equal(2)
