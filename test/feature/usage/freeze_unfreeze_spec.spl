# # Freeze and Unfreeze Collections for Immutability
#
# **Feature ID:** #LANG-025
# **Category:** Language
# **Status:** Active
#
# ## Overview
#
# The `freeze()` function converts mutable collections (arrays and dicts) into immutable
# snapshots that support read operations but prevent modification. Frozen collections
# retain full access to non-mutating operations like indexing, iteration, `map`, `filter`,
# `reduce`, `keys`, `values`, and `contains`. This spec validates freeze behavior on arrays
# and dicts, confirms idempotence (freezing an already-frozen collection is a no-op),
# and verifies that functional operations produce correct results on frozen data.
#
# ## Syntax
#
# ```simple
# var arr = [1, 2, 3]
# val frozen = freeze(arr)           # immutable snapshot
# frozen.map(\x: x * 2)             # [2, 4, 6] - functional ops work
# frozen.filter(\x: x % 2 == 0)     # filtering works on frozen
#
# var dict = {"a": 1, "b": 2}
# val frozen_dict = freeze(dict)     # frozen dict
# frozen_dict.keys()                 # read-only access to keys
# ```
#
# ## Key Concepts
#
# | Concept | Description |
# |---------|-------------|
# | `freeze()` | Converts a mutable collection into an immutable copy |
# | Idempotence | Calling `freeze()` on an already-frozen collection returns an equivalent value |
# | Read-only access | Frozen collections support indexing, `len`, `first`, `last`, negative indexing |
# | Functional operations | `map`, `filter`, `reduce`, `contains` all work on frozen collections |
# | Dict freeze | Frozen dicts support `keys`, `values`, `contains_key`, and key-based access |

describe "Freeze and Unfreeze":

    context "Freeze Function":
        it "freezes mutable array":
            var arr = [1, 2, 3]
            val frozen = freeze(arr)
            expect frozen[0] == 1
            expect frozen.len() == 3

        it "freezes mutable dict":
            var dict = {"a": 1}
            val frozen = freeze(dict)
            expect frozen["a"] == 1

        it "is idempotent":
            val arr = freeze([1, 2, 3])
            val frozen_again = freeze(arr)
            expect frozen_again[0] == arr[0]
            expect frozen_again.len() == arr.len()

        it "freezes empty array":
            val frozen = freeze([])
            expect frozen.len() == 0

        it "freezes empty dict":
            val frozen = freeze({})
            expect frozen.len() == 0

    context "Frozen Array Operations":
        it "allows reads on frozen array":
            val frozen = freeze([1, 2, 3])
            expect frozen[0] == 1
            expect frozen[2] == 3

        it "allows len on frozen array":
            val frozen = freeze([1, 2, 3])
            expect frozen.len() == 3

        it "allows iteration on frozen array":
            val frozen = freeze([1, 2, 3])
            var sum = 0
            for x in frozen:
                sum = sum + x
            expect sum == 6

        it "allows first and last on frozen array":
            val frozen = freeze([1, 2, 3])
            expect frozen.first() == 1
            expect frozen.last() == 3

        it "allows negative indexing on frozen array":
            val frozen = freeze([1, 2, 3])
            expect frozen[-1] == 3
            expect frozen[-2] == 2

    context "Functional Operations on Frozen":
        it "allows map on frozen array":
            val frozen = freeze([1, 2, 3])
            val doubled = frozen.map(\x: x * 2)
            expect doubled[0] == 2
            expect doubled[1] == 4
            expect doubled[2] == 6

        it "allows filter on frozen array":
            val frozen = freeze([1, 2, 3, 4, 5])
            val evens = frozen.filter(\x: x % 2 == 0)
            expect evens.len() == 2
            expect evens[0] == 2
            expect evens[1] == 4

        it "allows reduce on frozen array":
            val frozen = freeze([1, 2, 3, 4])
            val sum = frozen.reduce(0, \acc, x: acc + x)
            expect sum == 10

        it "allows contains on frozen array":
            val frozen = freeze([1, 2, 3])
            expect frozen.contains(2)
            expect not frozen.contains(5)

    context "Frozen Dict Operations":
        it "allows reads on frozen dict":
            val frozen = freeze({"a": 1, "b": 2})
            expect frozen["a"] == 1
            expect frozen["b"] == 2

        it "allows len on frozen dict":
            val frozen = freeze({"a": 1, "b": 2})
            expect frozen.len() == 2

        it "allows keys on frozen dict":
            val frozen = freeze({"a": 1, "b": 2})
            val keys = frozen.keys()
            expect keys.len() == 2

        it "allows values on frozen dict":
            val frozen = freeze({"a": 1, "b": 2})
            val values = frozen.values()
            expect values.len() == 2

        it "allows contains_key on frozen dict":
            val frozen = freeze({"a": 1})
            expect frozen.contains_key("a")
            expect not frozen.contains_key("b")

    context "Type Behavior":
        it "treats frozen arrays as arrays":
            val frozen = freeze([1, 2, 3])
            expect frozen.len() == 3
            expect frozen[0] == 1

        it "treats frozen dicts as dicts":
            val frozen = freeze({"a": 1})
            expect frozen["a"] == 1
