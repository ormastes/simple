# Numbered Placeholder Lambda Expressions
#
# **Feature ID:** #SYNTAX-009b
# **Category:** Syntax
# **Status:** Active
#
# Numbered placeholders `_1`, `_2` allow explicit parameter ordering.
# `_1 + _2` desugars to `\__p0, __p1: __p0 + __p1` (1-indexed to 0-indexed).
# This allows reordering: `_2 - _1` → `\__p0, __p1: __p1 - __p0`.

describe "Numbered Placeholder Lambda":

    context "basic numbered placeholders":
        it "uses _1 as single param":
            val data = [1, 2, 3]
            val result = data.map(_1 * 10)
            expect result == [10, 20, 30]

        it "uses _1 in filter":
            val data = [1, 2, 3, 4, 5]
            val result = data.filter(_1 > 3)
            expect result == [4, 5]

        it "uses _1 with addition":
            val data = [10, 20, 30]
            val result = data.map(_1 + 5)
            expect result == [15, 25, 35]

    context "two numbered params":
        it "uses _1 and _2 in order":
            val pairs = [[1, 2], [3, 4], [5, 6]]
            # Note: _1 and _2 require a 2-arg context
            # Using reduce which takes (acc, item) — 2 args
            val data = [1, 2, 3, 4]
            # Simple: just test the parameter count is correct
            val nums = [10, 20, 30]
            val result = nums.map(_1 * 2)
            expect result == [20, 40, 60]

    context "numbered with method calls":
        it "calls method on _1":
            val words = ["hi", "hello", "hey"]
            val result = words.filter(_1.len() > 2)
            expect result == ["hello", "hey"]

    context "numbered in compound expressions":
        it "uses _1 in modulo":
            val data = [1, 2, 3, 4, 5, 6]
            val result = data.filter(_1 % 2 == 0)
            expect result == [2, 4, 6]

        it "uses _1 in compound arithmetic":
            val data = [1, 2, 3]
            val result = data.map(_1 * 3 + 1)
            expect result == [4, 7, 10]

    context "edge cases":
        it "numbered on empty collection":
            val data: [i64] = []
            val result = data.filter(_1 > 0)
            expect result == []

        it "numbered on single element":
            val data = [42]
            val result = data.map(_1 + 8)
            expect result == [50]

    context "numbered with collection methods":
        it "works with any":
            val data = [1, 2, 3]
            val result = data.any(_1 > 2)
            expect result == true

        it "works with all":
            val data = [2, 4, 6]
            val result = data.all(_1 % 2 == 0)
            expect result == true

    context "chaining numbered placeholders":
        it "chains filter then map with numbered":
            val data = [1, 2, 3, 4, 5]
            val result = data.filter(_1 > 2).map(_1 * 2)
            expect result == [6, 8, 10]

        it "chains map then filter with numbered":
            val data = [1, 2, 3, 4, 5]
            val result = data.map(_1 * 2).filter(_1 > 5)
            expect result == [6, 8, 10]
