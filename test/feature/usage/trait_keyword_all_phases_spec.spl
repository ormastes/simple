"""
# Trait Keyword - All Phases

**Feature ID:** #TRAIT-002
**Category:** Language
**Status:** Active

## Overview

Comprehensive phase tests for the trait keyword desugaring feature covering all
five phases: trait detection via scan_traits, method signature extraction
(fn/me, parameters, return types), default method detection (has_default),
forwarding generation (alias fn/me and alias TraitName = field), and end-to-end
workflows from trait definition through implementation to usage with correct
forwarding of abstract-only methods.

## Syntax

```simple
trait Formatter:
    fn format(value: text) -> text
class TextFormatter:
    inner: BaseFormatter
    alias Formatter = inner
```
"""
# Trait Keyword All Phases Spec
#
# Comprehensive phase tests for Feature 4: trait keyword.
# Covers all 5 phases of the trait keyword desugaring feature.
#
# Feature: trait keyword (Feature 4)
# Sources:
#   src/app/desugar/trait_scanner.spl   - scan source text for trait definitions
#   src/app/desugar/forwarding.spl      - desugar alias forwarding declarations
#
# Phases:
#   Phase 1 - Trait detection: scanning source text and identifying trait blocks
#   Phase 2 - Struct generation: extracting method signatures from trait body
#   Phase 3 - impl generates factory: forwarding from alias TraitName = field
#   Phase 4 - Forwarding: alias fn/me and blanket alias field
#   Phase 5 - End-to-end: complete trait workflow define, implement, use

use app.desugar.trait_scanner (scan_traits, find_trait, ScannedTrait, TraitMethod)
use app.desugar.forwarding (desugar_forwarding)
use std.text.{NL}

# ============================================================================
# Phase 1 - Trait Detection
# ============================================================================

describe "Trait Keyword: Phase 1 - Trait detection":

    context "basic detection":
        it "trait declaration is recognized":
            var src = "trait Display:" + NL
            src = src + "    fn to_string() -> text" + NL
            val traits = scan_traits(src)
            expect(traits.len()).to_equal(1)
            expect(traits[0].name).to_equal("Display")

        it "trait name is extracted correctly":
            var src = "trait Container:" + NL
            src = src + "    fn size() -> i64" + NL
            val traits = scan_traits(src)
            expect(traits[0].name).to_equal("Container")

        it "trait without methods has empty method list":
            var src = "trait Marker:" + NL
            val traits = scan_traits(src)
            expect(traits.len()).to_equal(1)
            expect(traits[0].methods.len()).to_equal(0)

        it "source with no traits returns empty list":
            var src = "class Foo:" + NL
            src = src + "    x: i64" + NL
            val traits = scan_traits(src)
            expect(traits.len()).to_equal(0)

    context "multiple traits":
        it "finds two traits in source":
            var src = "trait Readable:" + NL
            src = src + "    fn read() -> text" + NL
            src = src + NL
            src = src + "trait Writable:" + NL
            src = src + "    me write(data: text)" + NL
            val traits = scan_traits(src)
            expect(traits.len()).to_equal(2)
            expect(traits[0].name).to_equal("Readable")
            expect(traits[1].name).to_equal("Writable")

        it "traits mixed with non-trait declarations are detected":
            var src = "class Helper:" + NL
            src = src + "    x: i64" + NL
            src = src + NL
            src = src + "trait Sizeable:" + NL
            src = src + "    fn size() -> i64" + NL
            src = src + NL
            src = src + "fn helper():" + NL
            src = src + "    42" + NL
            val traits = scan_traits(src)
            expect(traits.len()).to_equal(1)
            expect(traits[0].name).to_equal("Sizeable")

        it "trait with lowercase start is ignored":
            var src = "trait myTrait:" + NL
            src = src + "    fn method() -> i64" + NL
            val traits = scan_traits(src)
            expect(traits.len()).to_equal(0)

    context "find_trait":
        it "find_trait returns matching trait":
            var src = "trait Logger:" + NL
            src = src + "    me log(msg: text)" + NL
            val traits = scan_traits(src)
            val found = find_trait("Logger", traits)
            expect(found.name).to_equal("Logger")
            expect(found.methods.len()).to_equal(1)

        it "find_trait returns empty trait for unknown name":
            var src = "trait Display:" + NL
            src = src + "    fn to_string() -> text" + NL
            val traits = scan_traits(src)
            val found = find_trait("Unknown", traits)
            expect(found.name).to_equal("Unknown")
            expect(found.methods.len()).to_equal(0)

# ============================================================================
# Phase 2 - Struct Generation (Method Signatures)
# ============================================================================

describe "Trait Keyword: Phase 2 - Method signature extraction":

    context "fn methods":
        it "fn method is detected with is_me=false":
            var src = "trait Inspect:" + NL
            src = src + "    fn inspect() -> text" + NL
            val traits = scan_traits(src)
            val t = traits[0]
            expect(t.methods[0].name).to_equal("inspect")
            expect(t.methods[0].is_me).to_equal(false)

        it "fn method with return type extracts name correctly":
            var src = "trait Measurable:" + NL
            src = src + "    fn length() -> i64" + NL
            src = src + "    fn weight() -> f64" + NL
            val traits = scan_traits(src)
            val t = traits[0]
            expect(t.methods.len()).to_equal(2)
            expect(t.methods[0].name).to_equal("length")
            expect(t.methods[1].name).to_equal("weight")

    context "me methods":
        it "me method is detected with is_me=true":
            var src = "trait Mutable:" + NL
            src = src + "    me update(val: i64)" + NL
            val traits = scan_traits(src)
            val t = traits[0]
            expect(t.methods[0].name).to_equal("update")
            expect(t.methods[0].is_me).to_equal(true)

        it "mixed fn and me methods in same trait":
            var src = "trait Repository:" + NL
            src = src + "    fn get(key: text) -> text" + NL
            src = src + "    me set(key: text, val: text)" + NL
            src = src + "    me delete(key: text)" + NL
            val traits = scan_traits(src)
            val t = traits[0]
            expect(t.methods.len()).to_equal(3)
            expect(t.methods[0].is_me).to_equal(false)
            expect(t.methods[1].is_me).to_equal(true)
            expect(t.methods[2].is_me).to_equal(true)

    context "parameter extraction":
        it "no-arg method has empty param_names":
            var src = "trait Closeable:" + NL
            src = src + "    me close()" + NL
            val traits = scan_traits(src)
            expect(traits[0].methods[0].param_names.len()).to_equal(0)

        it "single-param method extracts name":
            var src = "trait Processor:" + NL
            src = src + "    me process(item: text)" + NL
            val traits = scan_traits(src)
            expect(traits[0].methods[0].param_names.len()).to_equal(1)
            expect(traits[0].methods[0].param_names[0]).to_equal("item")

        it "multi-param method extracts all param names":
            var src = "trait Transformer:" + NL
            src = src + "    fn transform(input: text, count: i64, flag: bool) -> text" + NL
            val traits = scan_traits(src)
            val method = traits[0].methods[0]
            expect(method.param_names.len()).to_equal(3)
            expect(method.param_names[0]).to_equal("input")
            expect(method.param_names[1]).to_equal("count")
            expect(method.param_names[2]).to_equal("flag")

    context "comments and type lines skipped":
        it "comment lines in trait body are skipped":
            var src = "trait Iter:" + NL
            src = src + "    # This is a comment" + NL
            src = src + "    fn next() -> i64" + NL
            val traits = scan_traits(src)
            expect(traits[0].methods.len()).to_equal(1)
            expect(traits[0].methods[0].name).to_equal("next")

        it "type declaration lines in trait body are skipped":
            var src = "trait Collection:" + NL
            src = src + "    type Item" + NL
            src = src + "    fn get_item() -> Item" + NL
            val traits = scan_traits(src)
            expect(traits[0].methods.len()).to_equal(1)
            expect(traits[0].methods[0].name).to_equal("get_item")

# ============================================================================
# Phase 3 - impl Generates Factory (has_default detection)
# ============================================================================

describe "Trait Keyword: Phase 3 - Default method detection":

    context "abstract vs default methods":
        it "method without body has has_default=false":
            var src = "trait Eq:" + NL
            src = src + "    fn eq(other: Self) -> bool" + NL
            val traits = scan_traits(src)
            expect(traits[0].methods[0].has_default).to_equal(false)

        it "method with multi-line body has has_default=true":
            var src = "trait Eq:" + NL
            src = src + "    fn eq(other: Self) -> bool" + NL
            src = src + "    fn ne(other: Self) -> bool:" + NL
            src = src + "        not self.eq(other)" + NL
            val traits = scan_traits(src)
            expect(traits[0].methods[0].has_default).to_equal(false)
            expect(traits[0].methods[1].has_default).to_equal(true)

        it "method with inline body has has_default=true":
            var src = "trait StringProvider:" + NL
            src = src + "    fn prefix() -> text: \"default_prefix\"" + NL
            val traits = scan_traits(src)
            expect(traits[0].methods[0].has_default).to_equal(true)

    context "trait alias forwarding skips default methods":
        it "alias TraitName=field only generates for abstract methods":
            var src = "trait Eq:" + NL
            src = src + "    fn eq(other: Self) -> bool" + NL
            src = src + "    fn ne(other: Self) -> bool:" + NL
            src = src + "        not self.eq(other)" + NL
            src = src + NL
            src = src + "class Point:" + NL
            src = src + "    inner: Coord" + NL
            src = src + "    alias Eq = inner" + NL
            val out = desugar_forwarding(src)
            # eq is abstract (no default) - should be forwarded
            expect(out).to_contain("fn eq(other):")
            expect(out).to_contain("self.inner.eq(other)")
            # ne has default - should NOT be forwarded
            val has_ne = out.contains("self.inner.ne(")
            expect(has_ne).to_equal(false)

        it "all-abstract trait generates forwarding for every method":
            var src = "trait Printable:" + NL
            src = src + "    fn print_text() -> text" + NL
            src = src + "    fn print_count() -> i64" + NL
            src = src + NL
            src = src + "class Document:" + NL
            src = src + "    content: Inner" + NL
            src = src + "    alias Printable = content" + NL
            val out = desugar_forwarding(src)
            expect(out).to_contain("fn print_text():")
            expect(out).to_contain("self.content.print_text()")
            expect(out).to_contain("fn print_count():")
            expect(out).to_contain("self.content.print_count()")

# ============================================================================
# Phase 4 - Forwarding
# ============================================================================

describe "Trait Keyword: Phase 4 - Forwarding":

    context "Phase 2: alias fn and alias me":
        it "alias fn generates immutable forwarding method":
            var src = "class Wrapper:" + NL
            src = src + "    inner: Inner" + NL
            src = src + "    alias fn len = inner.len" + NL
            val out = desugar_forwarding(src)
            expect(out).to_contain("fn len():")
            expect(out).to_contain("self.inner.len()")

        it "alias fn with args generates forwarding with parameters":
            var src = "class Wrapper:" + NL
            src = src + "    inner: Inner" + NL
            src = src + "    alias fn get(key, default_val) = inner.get" + NL
            val out = desugar_forwarding(src)
            expect(out).to_contain("fn get(key, default_val):")
            expect(out).to_contain("self.inner.get(key, default_val)")

        it "alias me generates mutable forwarding method":
            var src = "class Wrapper:" + NL
            src = src + "    inner: Inner" + NL
            src = src + "    alias me push(item) = inner.push" + NL
            val out = desugar_forwarding(src)
            expect(out).to_contain("me push(item):")
            expect(out).to_contain("self.inner.push(item)")

    context "Phase 3: alias TraitName = field":
        it "alias Trait generates fn forwarding for fn methods":
            var src = "trait Sizeable:" + NL
            src = src + "    fn size() -> i64" + NL
            src = src + "    fn is_empty() -> bool" + NL
            src = src + NL
            src = src + "class MyList:" + NL
            src = src + "    items: Storage" + NL
            src = src + "    alias Sizeable = items" + NL
            val out = desugar_forwarding(src)
            expect(out).to_contain("fn size():")
            expect(out).to_contain("self.items.size()")
            expect(out).to_contain("fn is_empty():")
            expect(out).to_contain("self.items.is_empty()")

        it "alias Trait generates me forwarding for me methods":
            var src = "trait Writable:" + NL
            src = src + "    me write(data: text)" + NL
            src = src + "    me clear()" + NL
            src = src + NL
            src = src + "class Stream:" + NL
            src = src + "    buf: Buffer" + NL
            src = src + "    alias Writable = buf" + NL
            val out = desugar_forwarding(src)
            expect(out).to_contain("me write(data):")
            expect(out).to_contain("self.buf.write(data)")
            expect(out).to_contain("me clear():")
            expect(out).to_contain("self.buf.clear()")

        it "unknown trait generates no forwarding code":
            var src = "class Wrapper:" + NL
            src = src + "    inner: Inner" + NL
            src = src + "    alias UnknownTrait = inner" + NL
            val out = desugar_forwarding(src)
            val has_self_inner = out.contains("self.inner.")
            expect(has_self_inner).to_equal(false)

    context "Phase 4: blanket alias field":
        it "alias field_name forwards all methods from field type":
            var src = "class Storage:" + NL
            src = src + "    fn size() -> i64:" + NL
            src = src + "        0" + NL
            src = src + "    me clear():" + NL
            src = src + "        pass_do_nothing" + NL
            src = src + NL
            src = src + "class Wrapper:" + NL
            src = src + "    store: Storage" + NL
            src = src + "    alias store" + NL
            val out = desugar_forwarding(src)
            expect(out).to_contain("fn size():")
            expect(out).to_contain("self.store.size()")
            expect(out).to_contain("me clear():")
            expect(out).to_contain("self.store.clear()")

# ============================================================================
# Phase 5 - End-to-End Usage
# ============================================================================

describe "Trait Keyword: Phase 5 - End-to-end usage":

    context "complete trait workflow":
        it "define a trait, scan it, use find_trait to retrieve":
            var src = "trait EventHandler:" + NL
            src = src + "    me on_event(event: text)" + NL
            src = src + "    fn handler_name() -> text" + NL
            val traits = scan_traits(src)
            val handler = find_trait("EventHandler", traits)
            expect(handler.name).to_equal("EventHandler")
            expect(handler.methods.len()).to_equal(2)
            expect(handler.methods[0].name).to_equal("on_event")
            expect(handler.methods[0].is_me).to_equal(true)
            expect(handler.methods[1].name).to_equal("handler_name")
            expect(handler.methods[1].is_me).to_equal(false)

        it "complete define-implement-forward workflow":
            var src = "trait Formatter:" + NL
            src = src + "    fn format(value: text) -> text" + NL
            src = src + "    fn name() -> text" + NL
            src = src + NL
            src = src + "class TextFormatter:" + NL
            src = src + "    inner: BaseFormatter" + NL
            src = src + "    alias Formatter = inner" + NL
            val out = desugar_forwarding(src)
            expect(out).to_contain("fn format(value):")
            expect(out).to_contain("self.inner.format(value)")
            expect(out).to_contain("fn name():")
            expect(out).to_contain("self.inner.name()")

        it "multiple traits in source: each generates correct forwarding":
            var src = "trait Readable:" + NL
            src = src + "    fn read() -> text" + NL
            src = src + NL
            src = src + "trait Closeable:" + NL
            src = src + "    me close()" + NL
            src = src + NL
            src = src + "class FileStream:" + NL
            src = src + "    reader: Reader" + NL
            src = src + "    handle: Handle" + NL
            src = src + "    alias Readable = reader" + NL
            src = src + "    alias Closeable = handle" + NL
            val out = desugar_forwarding(src)
            expect(out).to_contain("fn read():")
            expect(out).to_contain("self.reader.read()")
            expect(out).to_contain("me close():")
            expect(out).to_contain("self.handle.close()")

        it "trait with default methods: only abstract methods are forwarded":
            var src = "trait Comparable:" + NL
            src = src + "    fn compare_to(other: Self) -> i64" + NL
            src = src + "    fn less_than(other: Self) -> bool:" + NL
            src = src + "        self.compare_to(other) < 0" + NL
            src = src + "    fn greater_than(other: Self) -> bool:" + NL
            src = src + "        self.compare_to(other) > 0" + NL
            src = src + NL
            src = src + "class Priority:" + NL
            src = src + "    inner: PriorityCore" + NL
            src = src + "    alias Comparable = inner" + NL
            val out = desugar_forwarding(src)
            # compare_to has no default - forwarded
            expect(out).to_contain("fn compare_to(other):")
            expect(out).to_contain("self.inner.compare_to(other)")
            # less_than and greater_than have defaults - NOT forwarded
            val has_less = out.contains("self.inner.less_than(")
            val has_greater = out.contains("self.inner.greater_than(")
            expect(has_less).to_equal(false)
            expect(has_greater).to_equal(false)

        it "trait scanner and forwarding agree on method count":
            var src = "trait Pipeline:" + NL
            src = src + "    me run(input: text)" + NL
            src = src + "    fn status() -> text" + NL
            src = src + "    fn name() -> text" + NL
            src = src + NL
            src = src + "class DataPipeline:" + NL
            src = src + "    impl: PipelineImpl" + NL
            src = src + "    alias Pipeline = impl" + NL
            # Verify scanner sees 3 methods
            val traits = scan_traits(src)
            val t = find_trait("Pipeline", traits)
            expect(t.methods.len()).to_equal(3)
            # Verify forwarding generates all 3 method signatures
            val out = desugar_forwarding(src)
            expect(out).to_contain("me run(input):")
            expect(out).to_contain("self.impl.run(input)")
            expect(out).to_contain("fn status():")
            expect(out).to_contain("self.impl.status()")
            expect(out).to_contain("fn name():")
            expect(out).to_contain("self.impl.name()")
