# # AOP Debug Logger
#
# **Feature ID:** #AOP-001
# **Category:** Compiler
# **Status:** Active
#
# ## Overview
#
# Validates the AOP debug logging subsystem including enable/disable toggling,
# entry creation with depth tracking, group pairing of enter/exit calls,
# wildcard and prefix-based filter patterns, incremental entry querying,
# and ring buffer trimming when the entry limit is exceeded.
#
# ## Syntax
#
# ```simple
# debug_log_enable("parse_*")
# val gid = debug_log_enter("my_func", "app.mcp.main", "Server", 42, "path=\"/src\"")
# debug_log_exit("my_func", "app.mcp.main", gid, 0)
# val entries = debug_log_get_entries()
# ```
# AOP Debug Logger Specification
#
# Tests for src/compiler/aop_debug_log.spl
# Core debug logging with depth tracking, group pairing, ring buffer.

use compiler.core.aop_debug_log.{DebugLogEntry, debug_log_enter, debug_log_exit, debug_log_enable, debug_log_disable, debug_log_clear, debug_log_get_entries, debug_log_get_entries_since, debug_log_get_status, debug_log_is_enabled, debug_log_set_max_entries}

describe "AOP Debug Logger":

    context "enable and disable":
        it "starts disabled by default when SIMPLE_AOP_DEBUG not set":
            debug_log_clear()
            debug_log_disable()
            val enabled = debug_log_is_enabled()
            # After explicit disable, should be disabled
            expect(enabled).to_equal(false)

        it "enables with wildcard pattern":
            debug_log_clear()
            debug_log_enable("*")
            expect(debug_log_is_enabled()).to_equal(true)
            val (en, pat, cnt, dep) = debug_log_get_status()
            expect(en).to_equal(true)
            expect(pat).to_equal("*")
            debug_log_disable()

        it "enables with specific pattern":
            debug_log_clear()
            debug_log_enable("parse_*")
            val (en, pat, cnt, dep) = debug_log_get_status()
            expect(en).to_equal(true)
            expect(pat).to_equal("parse_*")
            debug_log_disable()

        it "disables logging":
            debug_log_enable("*")
            debug_log_disable()
            expect(debug_log_is_enabled()).to_equal(false)

    context "entry creation":
        it "creates enter entry with correct fields":
            debug_log_clear()
            debug_log_enable("*")
            val gid = debug_log_enter("my_func", "app.mcp.main", "Server", 42, "path=\"/src\"")
            val entries = debug_log_get_entries()
            expect(entries.len()).to_equal(1)
            val e = entries[0]
            expect(e.entry_type).to_equal("enter")
            expect(e.function_name).to_equal("my_func")
            expect(e.package_path).to_equal("app.mcp.main")
            expect(e.class_name).to_equal("Server")
            expect(e.line_number).to_equal(42)
            expect(e.params_text).to_equal("path=\"/src\"")
            expect(e.depth).to_equal(0)
            expect(e.group_id).to_equal(gid)
            debug_log_disable()

        it "creates exit entry paired with enter":
            debug_log_clear()
            debug_log_enable("*")
            val gid = debug_log_enter("my_func", "app.mcp.main", "", 10, "")
            debug_log_exit("my_func", "app.mcp.main", gid, 0)
            val entries = debug_log_get_entries()
            expect(entries.len()).to_equal(2)
            expect(entries[0].entry_type).to_equal("enter")
            expect(entries[1].entry_type).to_equal("exit")
            expect(entries[0].group_id).to_equal(entries[1].group_id)
            debug_log_disable()

        it "skips entries when disabled":
            debug_log_clear()
            debug_log_disable()
            val gid = debug_log_enter("my_func", "mod", "", 1, "")
            expect(gid).to_equal(-1)
            expect(debug_log_get_entries().len()).to_equal(0)

    context "depth tracking":
        it "tracks nested call depth":
            debug_log_clear()
            debug_log_enable("*")
            val g1 = debug_log_enter("outer", "mod", "", 1, "")
            val g2 = debug_log_enter("inner", "mod", "", 2, "")
            val g3 = debug_log_enter("deep", "mod", "", 3, "")
            debug_log_exit("deep", "mod", g3, 0)
            debug_log_exit("inner", "mod", g2, 0)
            debug_log_exit("outer", "mod", g1, 0)
            val entries = debug_log_get_entries()
            expect(entries.len()).to_equal(6)
            # Enter depths: 0, 1, 2
            expect(entries[0].depth).to_equal(0)
            expect(entries[1].depth).to_equal(1)
            expect(entries[2].depth).to_equal(2)
            # Exit depths: 2, 1, 0
            expect(entries[3].depth).to_equal(2)
            expect(entries[4].depth).to_equal(1)
            expect(entries[5].depth).to_equal(0)
            debug_log_disable()

    context "group pairing":
        it "assigns unique group IDs":
            debug_log_clear()
            debug_log_enable("*")
            val g1 = debug_log_enter("func_a", "mod", "", 1, "")
            debug_log_exit("func_a", "mod", g1, 0)
            val g2 = debug_log_enter("func_b", "mod", "", 2, "")
            debug_log_exit("func_b", "mod", g2, 0)
            expect(g1).to_be_greater_than(0)
            expect(g2).to_be_greater_than(g1)
            debug_log_disable()

        it "tracks parent group IDs":
            debug_log_clear()
            debug_log_enable("*")
            val g_outer = debug_log_enter("outer", "mod", "", 1, "")
            val g_inner = debug_log_enter("inner", "mod", "", 2, "")
            debug_log_exit("inner", "mod", g_inner, 0)
            debug_log_exit("outer", "mod", g_outer, 0)
            val entries = debug_log_get_entries()
            # Inner enter should have outer as parent
            expect(entries[1].parent_group_id).to_equal(g_outer)
            # Outer enter should have 0 (no parent)
            expect(entries[0].parent_group_id).to_equal(0)
            debug_log_disable()

    context "filter pattern":
        it "filters by prefix pattern":
            debug_log_clear()
            debug_log_enable("parse_*")
            val g1 = debug_log_enter("parse_expr", "mod", "", 1, "")
            val g2 = debug_log_enter("eval_expr", "mod", "", 2, "")
            expect(g1).to_be_greater_than(0)
            expect(g2).to_equal(-1)
            expect(debug_log_get_entries().len()).to_equal(1)
            debug_log_disable()

        it "filters by module path":
            debug_log_clear()
            debug_log_enable("app.mcp*")
            val g1 = debug_log_enter("handle", "app.mcp.main", "", 1, "")
            val g2 = debug_log_enter("handle", "app.cli.main", "", 2, "")
            expect(g1).to_be_greater_than(0)
            expect(g2).to_equal(-1)
            debug_log_disable()

        it "matches exact function name":
            debug_log_clear()
            debug_log_enable("my_exact_func")
            val g1 = debug_log_enter("my_exact_func", "mod", "", 1, "")
            val g2 = debug_log_enter("other_func", "mod", "", 2, "")
            expect(g1).to_be_greater_than(0)
            expect(g2).to_equal(-1)
            debug_log_disable()

    context "query entries":
        it "returns entries since a given ID":
            debug_log_clear()
            debug_log_enable("*")
            val g1 = debug_log_enter("a", "mod", "", 1, "")
            debug_log_exit("a", "mod", g1, 0)
            val entries_before = debug_log_get_entries()
            val last_id = entries_before[entries_before.len() - 1].entry_id
            val g2 = debug_log_enter("b", "mod", "", 2, "")
            debug_log_exit("b", "mod", g2, 0)
            val new_entries = debug_log_get_entries_since(last_id)
            expect(new_entries.len()).to_equal(2)
            expect(new_entries[0].function_name).to_equal("b")
            debug_log_disable()

    context "ring buffer":
        it "trims entries when exceeding max":
            debug_log_clear()
            debug_log_enable("*")
            debug_log_set_max_entries(20)
            # Add 25 enter entries
            for i in range(0, 25):
                debug_log_enter("func", "mod", "", i, "")
            val entries = debug_log_get_entries()
            # Should have trimmed: 25 > 20, so trim 1000 (but only 25 total)
            # With trim_count=1000 and only 25 entries, trim removes up to 1000 but only 5 needed
            # Actually trim_count is 1000 which is > total, so all but max_entries remain
            expect(entries.len()).to_be_less_than(26)
            # Reset max for other tests
            debug_log_set_max_entries(10000)
            debug_log_disable()

    context "clear":
        it "resets all state":
            debug_log_enable("*")
            debug_log_enter("func", "mod", "", 1, "")
            debug_log_clear()
            val (en, pat, cnt, dep) = debug_log_get_status()
            expect(cnt).to_equal(0)
            expect(dep).to_equal(0)
            debug_log_disable()
