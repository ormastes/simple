# Nested Placeholder Scoping
#
# **Feature ID:** #SYNTAX-009c
# **Category:** Syntax
# **Status:** Active
#
# When placeholder lambdas appear in nested call arguments, each nesting
# level gets its own independent transform. This means:
# `_.items.any(_ > 3)` becomes:
#   outer: `\__p0: __p0.items.any(INNER)`
#   inner: `\__p0: __p0 > 3`
#
# The key rule: placeholders in nested call arguments do NOT count toward
# the outer expression's placeholder count.

describe "Nested Placeholder Scoping":

    context "method call with nested placeholder":
        it "scopes inner and outer placeholders independently":
            val data = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
            val result = data.filter(_.any(_ > 5))
            expect result == [[4, 5, 6], [7, 8, 9]]

        it "filters arrays that have all elements above threshold":
            val data = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
            val result = data.filter(_.all(_ > 3))
            expect result == [[4, 5, 6], [7, 8, 9]]

    context "chained placeholders with nested":
        it "chains outer filter with inner any":
            val data = [[1, 5], [2, 3], [4, 6]]
            val result = data.filter(_.any(_ > 4))
            expect result == [[1, 5], [4, 6]]

    context "map with nested filter":
        it "maps then filters within nested context":
            val data = [[1, 2, 3, 4], [5, 6, 7, 8]]
            val result = data.map(_.filter(_ > 2))
            expect result == [[3, 4], [5, 6, 7, 8]]

    context "simple nested independence":
        it "outer placeholder is independent of inner":
            val nums = [1, 2, 3, 4, 5]
            # filter + map as separate operations (each has own _ scope)
            val evens = nums.filter(_ % 2 == 0)
            val doubled = evens.map(_ * 2)
            expect doubled == [4, 8]

        it "chained operations maintain separate scopes":
            val data = [1, 2, 3, 4, 5]
            val result = data.filter(_ > 1).map(_ * 3)
            expect result == [6, 9, 12, 15]

    context "deeply nested":
        it "handles three levels of nesting via chaining":
            val data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
            val result = data.filter(_ > 3).filter(_ < 8).map(_ * 2)
            expect result == [8, 10, 12, 14]

    context "nested with string methods":
        it "filters strings containing substrings":
            val words = ["hello", "world", "help", "word"]
            val result = words.filter(_.len() > 4)
            expect result == ["hello", "world"]

    context "edge cases":
        it "nested placeholder on empty inner list":
            val data = [[], [1, 2], []]
            val result = data.filter(_.any(_ > 0))
            expect result == [[1, 2]]
