"""
# Advanced Pattern Matching Specification


**Feature IDs:** #PAT-ADV-001 to #PAT-ADV-018
**Category:** Language | Pattern Matching
**Status:** Implemented

Tests advanced pattern matching features including:
- Match guards (if conditions)
- If let / While let expressions
- Or patterns (|)
- Range patterns (.., ..=)

## Syntax

```simple
# Match guards
match x:
    n if n > 0 => "positive"
    n if n < 0 => "negative"
    _ => "zero"

# If val (if let is deprecated)
if val Some(value) = opt:
    print(value)

# While val (while let is deprecated)
while val Some(item) = iterator.next():
    process(item)

# Or patterns
match x:
    1 | 2 | 3 => "small"
    _ => "large"

# Range patterns
match x:
    0..10 => "single digit"
    10..100 => "double digit"
    _ => "large"
```
"""



# ============================================================================
# Test Group 1: Match Guards
# ============================================================================

describe "Match Guards":
    """
    ## Conditional Pattern Matching

    Tests match guards with if conditions.
    """

    it "matches with basic guard":
        fn classify(x: i64) -> i64:
            match x:
                n if n < 0 =>
                    -1
                n if n == 0 =>
                    0
                n if n > 0 =>
                    1
            -99

        expect classify(5) == 1

    it "matches negative with guard":
        fn classify(x: i64) -> i64:
            match x:
                n if n < 0 =>
                    -1
                n if n == 0 =>
                    0
                n if n > 0 =>
                    1
            -99

        expect classify(-10) == -1

    it "uses binding in guard":
        fn verify(pair: (i64, i64)) -> i64:
            match pair:
                (a, b) if a + b > 10 =>
                    1
                (a, b) if a + b == 10 =>
                    0
                _ =>
                    -1

        expect verify((7, 5)) == 1  # 7 + 5 = 12 > 10

    it "falls through when guard fails":
        fn test(x: i64) -> i64:
            match x:
                n if n > 100 =>
                    100
                n if n > 10 =>
                    10
                n =>
                    n

        expect test(50) == 10  # 50 > 100? No. 50 > 10? Yes


# ============================================================================
# Test Group 2: If Let
# ============================================================================

describe "If Val Expressions":
    """
    ## Pattern Matching in If

    Tests if val/var syntax for conditional pattern matching.
    Note: `if let` is deprecated in favor of `if val` (immutable) and `if var` (mutable).
    """

    it "matches Some with if val":
        val opt = Some(42)
        var res = 0
        if val Some(x) = opt:
            res = x
        expect res == 42

    it "uses else branch for non-matching":
        val opt: Option<i64> = nil
        var res = 0
        if val Some(x) = opt:
            res = x
        else:
            res = -1
        expect res == -1

    it "matches Ok with if val":
        val res = Ok(100)
        var output = 0
        if val Ok(value) = res:
            output = value
        expect output == 100

    it "matches Some with if var":
        val opt = Some(42)
        var res = 0
        if var Some(x) = opt:
            res = x
        expect res == 42


# ============================================================================
# Test Group 3: While Let
# ============================================================================

describe "While Let Expressions":
    """
    ## Pattern Matching in While

    Tests while let syntax for iterative pattern matching.
    """

    it "loops while pattern matches":
        fn next_item(n: i64) -> Option<i64>:
            if n > 0:
                Some(n)
            else:
                None

        var counter = 3
        var sum = 0
        while let Some(value) = next_item(counter):
            sum = sum + value
            counter = counter - 1
        expect sum == 6  # 3 + 2 + 1


# ============================================================================
# Test Group 4: Or Patterns
# ============================================================================

describe "Or Patterns":
    """
    ## Multiple Patterns with |

    Tests or patterns matching multiple values.
    """

    it "matches multiple literals":
        fn classify(x: i64) -> i64:
            match x:
                1 | 2 | 3 =>
                    1  # small
                4 | 5 | 6 =>
                    2  # medium
                _ =>
                    3  # large

        expect classify(2) == 1

    it "matches medium group":
        fn classify(x: i64) -> i64:
            match x:
                1 | 2 | 3 =>
                    1
                4 | 5 | 6 =>
                    2
                _ =>
                    3

        expect classify(5) == 2

    it "falls through to wildcard":
        fn verify(x: i64) -> i64:
            match x:
                0 | 1 =>
                    10
                _ =>
                    99

        expect verify(99) == 99


# ============================================================================
# Test Group 5: Range Patterns
# ============================================================================

describe "Range Patterns":
    """
    ## Range Matching with .. and ..=

    Tests exclusive and inclusive range patterns.
    """

    it "matches exclusive range":
        fn classify(x: i64) -> i64:
            match x:
                0..10 =>
                    1
                10..20 =>
                    2
                _ =>
                    3

        expect classify(5) == 1

    it "exclusive range excludes end":
        fn classify(x: i64) -> i64:
            match x:
                0..10 =>
                    1
                10..20 =>
                    2
                _ =>
                    3

        expect classify(10) == 2  # 10 not in 0..10

    it "matches inclusive range":
        fn classify(x: i64) -> i64:
            match x:
                0..=5 =>
                    1
                6..=10 =>
                    2
                _ =>
                    3

        expect classify(5) == 1  # 5 is in 0..=5


# ============================================================================
# Test Group 6: Numeric Literals
# ============================================================================

describe "Numeric Literals":
    """
    ## Hex, Binary, Octal Literals

    Tests various numeric literal formats.
    """

    it "parses hex literal":
        val x = 0xFF
        expect x == 255

    it "hex arithmetic":
        val x = 0x10 + 0x20
        expect x == 48  # 16 + 32

    it "parses binary literal":
        val x = 0b1010
        expect x == 10

    it "binary with underscores":
        val x = 0b1111_0000
        expect x == 240

    it "parses octal literal":
        val x = 0o755
        expect x == 493  # 7*64 + 5*8 + 5

