"""
# AOP Pointcut Expression Specification

**Feature IDs:** #AOP-PC-001 to #AOP-PC-015
**Category:** Language
**Status:** In Progress
**Tags:** aop

Pointcut expressions define where advice should be applied. The `pc{...}` syntactic
island contains pointcut predicates that match against the program structure.

## Syntax

```simple
pc{ selector(pattern) }
pc{ selector1(...) & selector2(...) }  # AND
pc{ selector1(...) | selector2(...) }  # OR
pc{ !selector(...) }                   # NOT
```

## Selectors

| Selector | Description | Example |
|----------|-------------|---------|
| execution | Match function execution | `execution(* foo(..))` |
| within | Match code in module/class | `within(services.*)` |
| attr | Match by attribute | `attr(logged)` |

## Limitations (Current Implementation)

- Init selector not yet implemented (requires around advice)
- Inline module definitions in test blocks not supported
"""



# ============================================================================
# Test Group 1: Execution Selector
# ============================================================================

describe "Execution Pointcut Selector":
    """
    ## execution(signature) Selector

    Matches join points at function execution. The signature pattern includes
    return type, function name, and parameter types.
    """

    context "return type patterns":
        it "matches any return type with wildcard":
            var matched = false

            fn marker():
                matched = true

            fn returns_int() -> i64:
                42

            fn returns_text() -> text:
                "hello"

            on pc{ execution(* returns*(..)) } use marker before priority 10

            returns_int()
            expect matched == true

            matched = false
            returns_text()
            expect matched == true

    context "function name patterns":
        it "matches exact function name":
            var called = false

            fn marker():
                called = true

            fn exact_name() -> i64:
                42

            fn other_name() -> i64:
                0

            on pc{ execution(* exact_name(..)) } use marker before priority 10

            exact_name()
            expect called == true

        it "matches prefix wildcard":
            var count = 0

            fn counter():
                count = count + 1

            fn handle_request() -> i64:
                1

            fn handle_response() -> i64:
                2

            fn process_data() -> i64:
                3

            on pc{ execution(* handle*(..)) } use counter before priority 10

            handle_request()
            handle_response()
            process_data()
            expect count == 2

        it "matches suffix wildcard":
            var count = 0

            fn counter():
                count = count + 1

            fn get_user() -> i64:
                1

            fn get_order() -> i64:
                2

            fn set_user() -> i64:
                3

            on pc{ execution(* get*(..)) } use counter before priority 10

            get_user()
            get_order()
            set_user()
            expect count == 2

    context "parameter patterns":
        it "matches any parameters with (..)":
            var called = false

            fn marker():
                called = true

            fn no_params() -> i64:
                1

            fn one_param(x: i64) -> i64:
                x

            fn two_params(x: i64, y: i64) -> i64:
                x + y

            on pc{ execution(* *_params(..)) } use marker before priority 10

            no_params()
            expect called == true

            called = false
            one_param(1)
            expect called == true

            called = false
            two_params(1, 2)
            expect called == true


# ============================================================================
# Test Group 2: Attribute Selector
# ============================================================================

describe "Attribute Pointcut Selector":
    """
    ## attr(name) Selector

    Matches join points on elements decorated with the specified attribute.
    """

    context "function attributes":
        it "matches function with attribute":
            var logged = false

            fn logger():
                logged = true

            @traced
            fn traced_operation() -> i64:
                42

            fn untraced_operation() -> i64:
                0

            on pc{ attr(traced) } use logger before priority 10

            traced_operation()
            expect logged == true

            logged = false
            untraced_operation()
            expect logged == false

        it "matches multiple attributes":
            var count = 0

            fn counter():
                count = count + 1

            @critical
            @logged
            fn important() -> i64:
                42

            @logged
            fn regular() -> i64:
                0

            on pc{ attr(critical) & attr(logged) } use counter before priority 10

            important()
            expect count == 1

            regular()
            expect count == 1  # Still 1, regular doesn't have @critical


# ============================================================================
# Test Group 3: Logical Operators
# ============================================================================

describe "Pointcut Logical Operators":
    """
    ## Combining Pointcuts

    Pointcuts can be combined using logical operators with precedence:
    ! (NOT) > & (AND) > | (OR)
    """

    context "AND operator":
        it "requires both conditions":
            var called = false

            fn marker():
                called = true

            @important
            fn important_calc() -> i64:
                42

            fn regular_calc() -> i64:
                0

            @important
            fn important_other() -> i64:
                1

            on pc{ execution(* *_calc(..)) & attr(important) } use marker before priority 10

            important_calc()
            expect called == true

            called = false
            regular_calc()
            expect called == false  # Missing @important

            called = false
            important_other()
            expect called == false  # Not *_calc

    context "OR operator":
        it "matches either condition":
            var count = 0

            fn counter():
                count = count + 1

            fn option_a() -> i64:
                1

            fn option_b() -> i64:
                2

            fn option_c() -> i64:
                3

            on pc{ execution(* option_a(..)) | execution(* option_b(..)) } use counter before priority 10

            option_a()
            option_b()
            option_c()
            expect count == 2

    context "NOT operator":
        it "excludes matching pointcuts":
            var count = 0

            fn counter():
                count = count + 1

            fn included() -> i64:
                1

            fn excluded() -> i64:
                2

            on pc{ execution(* *(..)) & !execution(* excluded(..)) } use counter before priority 10

            included()
            excluded()
            expect count == 1


# ============================================================================
# Test Group 4: Wildcard Patterns
# ============================================================================

describe "Wildcard Patterns in Pointcuts":
    """
    ## Path and Name Wildcards

    Wildcards allow flexible matching in pointcut expressions:
    - `*` matches one segment/character sequence
    """

    context "prefix and suffix wildcards":
        it "matches prefix with name*":
            var count = 0

            fn counter():
                count = count + 1

            fn get_user() -> i64:
                1

            fn get_order() -> i64:
                2

            fn set_user() -> i64:
                3

            on pc{ execution(* get*(..)) } use counter before priority 10

            get_user()
            get_order()
            set_user()
            expect count == 2

        it "matches suffix with *name":
            var count = 0

            fn counter():
                count = count + 1

            fn user_service() -> i64:
                1

            fn order_service() -> i64:
                2

            fn user_controller() -> i64:
                3

            on pc{ execution(* *_service(..)) } use counter before priority 10

            user_service()
            order_service()
            user_controller()
            expect count == 2
