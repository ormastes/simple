# # DI Container Error Cases
#
# **Feature ID:** #DI-001
# **Category:** Compiler
# **Status:** Active
#
# ## Overview
#
# Tests failure paths and edge cases of the DiContainer including locked container
# behavior (silently rejecting bind operations), missing key resolution with
# fallback defaults, empty and overwritten key handling, and environment variable
# based system test locking with SIMPLE_SYSTEM_TEST and SIMPLE_DI_TEST bypass.
#
# ## Syntax
#
# ```simple
# val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
# di.bind_instance("key", "value")
# di.lock()
# val result = di.resolve_or("missing_key", "default_val")
# ```
# DI Error Cases - Negative/Error Path Tests
#
# Tests the failure paths and edge cases of DiContainer:
# - locked container rejects bindings
# - missing key resolution behavior
# - resolve_or fallback for missing keys
# - edge cases: empty key, overwrite key
#
# Features: 5 (DI Container), 9 (System Test Lock)
# Source: src/compiler/di.spl

use compiler.di.{DiContainer, di_is_system_test_locked}

extern fn rt_env_set(key: text, value: text)

# ============================================================================
# Locked container: bind operations are silently rejected
# ============================================================================

describe "DI Error Cases: locked container rejects bindings":

    it "bind_instance on locked container does not store value":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("existing", "before")
        di.lock()
        di.bind_instance("new_key", "should_not_appear")
        expect(di.has("new_key")).to_equal(false)

    it "bind factory on locked container does not register":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.lock()
        di.bind("FactoryKey", fn(): "factory_result")
        expect(di.has("FactoryKey")).to_equal(false)

    it "bind_for_profile on locked container does not register":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.lock()
        di.bind_for_profile("ProfileKey", CompilerProfile.Dev, fn(): "profiled")
        expect(di.has("ProfileKey")).to_equal(false)

    it "locked container does not overwrite previously bound value":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("Service", "original")
        di.lock()
        di.bind_instance("Service", "overwrite_attempt")
        expect(di.resolve("Service")).to_equal("original")

    it "is_locked returns true after explicit lock":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        expect(di.is_locked()).to_equal(false)
        di.lock()
        expect(di.is_locked()).to_equal(true)

    it "is_locked returns false after unlock":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.lock()
        expect(di.is_locked()).to_equal(true)
        di.unlock()
        expect(di.is_locked()).to_equal(false)

# ============================================================================
# Missing key: resolve_or returns fallback
# ============================================================================

describe "DI Error Cases: missing key fallback":

    it "resolve_or returns default text for missing key":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        val result = di.resolve_or("nonexistent_key", "default_val")
        expect(result).to_equal("default_val")

    it "resolve_or returns default integer for missing key":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        val result = di.resolve_or("missing_int", 42)
        expect(result).to_equal(42)

    it "has returns false for missing key":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        expect(di.has("definitely_not_there")).to_equal(false)

    it "resolve_or returns bound value when key exists":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("existing", "found_value")
        val result = di.resolve_or("existing", "should_not_be_used")
        expect(result).to_equal("found_value")

    it "has returns true after bind_instance":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("present", "value")
        expect(di.has("present")).to_equal(true)

# ============================================================================
# Edge cases: empty key, key overwrite
# ============================================================================

describe "DI Error Cases: edge cases":

    it "empty string key can be stored and retrieved":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("", "empty_key_val")
        expect(di.resolve("")).to_equal("empty_key_val")

    it "overwriting key keeps the latest value":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("key", "first")
        di.bind_instance("key", "second")
        expect(di.resolve("key")).to_equal("second")

    it "multiple distinct keys are independent":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("a", "val_a")
        di.bind_instance("b", "val_b")
        expect(di.resolve("a")).to_equal("val_a")
        expect(di.resolve("b")).to_equal("val_b")

    it "singleton is resolved from singletons not bindings":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("svc", "singleton_val")
        expect(di.has("svc")).to_equal(true)
        expect(di.resolve("svc")).to_equal("singleton_val")

    it "factory binding is callable after bind":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind("computed", fn(): "computed_result")
        expect(di.has("computed")).to_equal(true)
        val result = di.resolve("computed")
        expect(result).to_equal("computed_result")

# ============================================================================
# resolve_or on locked container still works for existing keys
# ============================================================================

describe "DI Error Cases: resolve works through lock":

    it "resolve_or for existing key works when locked":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("Config", "prod-config")
        di.lock()
        val result = di.resolve_or("Config", "default")
        expect(result).to_equal("prod-config")

    it "resolve_or for missing key returns default when locked":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.lock()
        val result = di.resolve_or("NotPresent", "fallback")
        expect(result).to_equal("fallback")

    it "resolve for pre-lock binding works after lock":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("Backend", "production-backend")
        di.lock()
        expect(di.resolve("Backend")).to_equal("production-backend")

# ============================================================================
# System test env-var lock
# ============================================================================

describe "DI Error Cases: env-var lock rejects bindings":

    it "bind rejected when SIMPLE_SYSTEM_TEST=1 and SIMPLE_DI_TEST not set":
        rt_env_set("SIMPLE_SYSTEM_TEST", "1")
        rt_env_set("SIMPLE_DI_TEST", "0")
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("MockSvc", "mock")
        expect(di.has("MockSvc")).to_equal(false)
        rt_env_set("SIMPLE_SYSTEM_TEST", "0")

    it "bind allowed when SIMPLE_DI_TEST=1 bypasses env lock":
        rt_env_set("SIMPLE_SYSTEM_TEST", "1")
        rt_env_set("SIMPLE_DI_TEST", "1")
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("TestMock", "allowed")
        expect(di.has("TestMock")).to_equal(true)
        rt_env_set("SIMPLE_SYSTEM_TEST", "0")
        rt_env_set("SIMPLE_DI_TEST", "0")

    it "di_is_system_test_locked returns false when env not set":
        rt_env_set("SIMPLE_SYSTEM_TEST", "")
        rt_env_set("SIMPLE_DI_TEST", "")
        expect(di_is_system_test_locked()).to_equal(false)
