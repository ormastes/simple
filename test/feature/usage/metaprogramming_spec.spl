# # Simple Language Metaprogramming - Test Specification
#
#
# **Status:** Partial Implementation
# **Feature IDs:** Various
# **Source:** metaprogramming.md
# **Type:** Extracted Examples
# **Last Updated:** 2026-02-08
#
# ## Overview
#
# This file contains executable test cases for metaprogramming features that are
# currently implemented in Simple's runtime.
#
# Tests cover: comprehensions, indexing, pattern matching, and basic error handling.
#
# **Note:** Advanced features (DSL blocks, decorators, slicing, context managers, move closures)
# are not yet fully implemented.

use std.spec
fn check(condition: bool):
    expect(condition).to_equal(true)

describe "Metaprogramming Spec":
    it "list comprehensions":
        # List comprehensions with filters
        val evens = [for x in 0..10 if x % 2 == 0: x]
        expect(evens[0]).to_equal(0)
        expect(evens[1]).to_equal(2)
        expect(evens[2]).to_equal(4)

    it "list comprehensions - transformation":
        # Transform elements in comprehension
        val squares = [for x in 1..6: x * x]
        expect(squares[0]).to_equal(1)
        expect(squares[1]).to_equal(4)
        expect(squares[2]).to_equal(9)

    it "array indexing - basic":
        # Basic array indexing
        val arr = [10, 20, 30, 40, 50]
        expect(arr[0]).to_equal(10)
        expect(arr[2]).to_equal(30)
        expect(arr[4]).to_equal(50)

    it "array indexing - last element":
        # Access last element using len()
        val arr = [10, 20, 30, 40, 50]
        val last = arr[arr.len() - 1]
        expect(last).to_equal(50)

    it "pattern matching - guard patterns":
        # Guard patterns using if/else
        fn classify(n: i64) -> text:
            if n < 0:
                return "negative"
            else if n == 0:
                return "zero"
            else:
                return "positive"

        expect(classify(-5)).to_equal("negative")
        expect(classify(0)).to_equal("zero")
        expect(classify(10)).to_equal("positive")

    it "pattern matching - simple matching":
        # Simple value matching with functions
        fn find_value(arr: [i64], target: i64) -> text:
            for x in arr:
                if x == target:
                    return "found"
            return "not found"

        val numbers = [10, 20, 30]
        expect(find_value(numbers, 20)).to_equal("found")
        expect(find_value(numbers, 99)).to_equal("not found")

    it "error handling - safe division":
        # Safe operations with error returns
        fn safe_divide(a: i64, b: i64) -> i64:
            if b == 0:
                return 0  # Error sentinel
            a / b

        val result1 = safe_divide(10, 2)
        val result2 = safe_divide(10, 0)

        expect(result1).to_equal(5)
        expect(result2).to_equal(0)

    it "error handling - option pattern":
        # Option pattern with nil checking
        fn find_first_even(arr: [i64]) -> i64:
            for x in arr:
                if x % 2 == 0:
                    return x
            return -1  # Not found sentinel

        val numbers = [1, 3, 6, 9]
        val result = find_first_even(numbers)
        expect(result).to_equal(6)

        val odd_only = [1, 3, 5]
        val not_found = find_first_even(odd_only)
        expect(not_found).to_equal(-1)
