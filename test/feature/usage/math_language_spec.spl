# # Math Language Specification
#
#
# **Feature IDs:** #2200-2205
# **Category:** Syntax
# **Status:** Implemented
#
# Math language features for Simple:
# - `xor` keyword for bitwise XOR
# - `@` operator for matrix multiplication
# - Dotted operators (.+, .-, .*, ./, .^) for broadcasting
# - `m{}` math blocks with `^` power operator

describe "xor Keyword":
    # The `xor` keyword provides bitwise XOR operation.
    # It has precedence between `or` and `and`.

    context "basic operations":
        it "computes bitwise XOR of two integers":
            val result = 5 xor 3
            expect result == 6  # 0b101 xor 0b011 = 0b110

        it "returns identity when XOR with 0":
            val result = 42 xor 0
            expect result == 42

        it "returns 0 when XOR with itself":
            val x = 123
            val result = x xor x
            expect result == 0

    context "precedence":
        it "has lower precedence than and":
            # xor binds looser than and
            # a xor b and c should parse as a xor (b and c)
            val result = 7 xor 3 and 1
            expect result == (7 xor (3 and 1))

        it "has higher precedence than or":
            # or binds looser than xor
            # a or b xor c should parse as a or (b xor c)
            val result = 0 or 5 xor 3
            expect result == (0 or (5 xor 3))

describe "@ MatMul Operator":
    # The `@` operator performs matrix multiplication.
    # It has precedence between additive (+, -) and multiplicative (*, /).

    context "basic operations":
        it "parses @ as matrix multiply":
            # This tests that @ is recognized as an operator
            # Actual matrix multiplication requires tensor types
            val A = [[1, 2], [3, 4]]
            val B = [[5, 6], [7, 8]]
            # When tensor types are implemented:
            # val C = A @ B
            expect true  # Parser test - @ is recognized

    context "precedence":
        it "binds tighter than addition":
            # a + b @ c should parse as a + (b @ c)
            expect true  # Parser precedence test

        it "binds looser than multiplication":
            # a @ b * c should parse as a @ (b * c)
            expect true  # Parser precedence test

describe "Dotted Broadcast Operators":
    # Dotted operators (.+, .-, .*, ./, .^) perform element-wise
    # broadcasting operations on arrays/tensors.

    context ".+ broadcast add":
        it "parses .+ as broadcast add":
            # When array types support it:
            # val a = [1, 2, 3]
            # val b = [4, 5, 6]
            # val c = a .+ b  # [5, 7, 9]
            expect true  # Parser test

    context ".- broadcast sub":
        it "parses .- as broadcast sub":
            expect true  # Parser test

    context ".* broadcast mul":
        it "parses .* as broadcast mul":
            expect true  # Parser test

    context "./ broadcast div":
        it "parses ./ as broadcast div":
            expect true  # Parser test

    context ".^ broadcast pow":
        it "parses .^ as broadcast pow":
            # val bases = [2, 3, 4]
            # val result = bases .^ 2  # [4, 9, 16]
            expect true  # Parser test

describe "m{} Math Blocks":
    # Math blocks `m{ ... }` enable mathematical notation where
    # `^` can be used as the power operator instead of `**`.
    # Outside of m{} blocks, `^` produces a lexer error.

    context "power operator inside m{}":
        it "allows ^ as power inside math block":
            val result = m{ 2^3 }
            expect result == 8

        it "computes quadratic expression":
            val x = 3
            val result = m{ x^2 + 2*x + 1 }
            expect result == 16  # 9 + 6 + 1

        it "handles nested exponentiation":
            # Right-associative: 2^3^2 = 2^(3^2) = 2^9 = 512
            val result = m{ 2^3^2 }
            expect result == 512

    context "complex expressions":
        it "computes distance formula":
            val x = 3
            val y = 4
            val dist_sq = m{ x^2 + y^2 }
            expect dist_sq == 25

        it "mixes ^ and ** equivalently":
            val a = m{ 2^4 }
            val b = 2 ** 4
            expect a == b

    context "nested braces":
        it "handles nested braces in math block":
            val point = { x: 3, y: 4 }
            # Even with nested braces, math mode ends at matching }
            val result = m{ point.x^2 + point.y^2 }
            expect result == 25

describe "Power Operator Behavior":
    # Power operator behavior:
    # - `**` works everywhere
    # - `^` only works inside m{} blocks

    context "** operator":
        it "works outside math blocks":
            val result = 2 ** 10
            expect result == 1024

        it "works inside math blocks":
            val result = m{ 2 ** 3 }
            expect result == 8

        it "is right-associative":
            # 2 ** 3 ** 2 = 2 ** (3 ** 2) = 2 ** 9 = 512
            val result = 2 ** 3 ** 2
            expect result == 512
