# Method Reference Syntax
#
# **Feature ID:** #SYNTAX-011
# **Category:** Syntax
# **Status:** Active
#
# The `&:method` syntax creates a lambda that calls the given method on its
# argument. `&:to_s` desugars to `\__p0: __p0.to_s()`.
# This is inspired by Ruby's `&:method` Symbol#to_proc.
#
# ## Syntax
#
# ```simple
# val lengths = ["hi", "hello", "hey"].map(&:len)  # => [2, 5, 3]
# val strs = [1, 2, 3].map(&:to_s)                 # => ["1", "2", "3"]
# ```

describe "Method Reference":

    context "basic method reference":
        it "calls len on strings":
            val words = ["hi", "hello", "hey"]
            val result = words.map(&:len)
            expect result == [2, 5, 3]

        it "calls to_s on integers":
            val nums = [1, 2, 3]
            val result = nums.map(&:to_s)
            expect result == ["1", "2", "3"]

    context "with filter":
        it "filters with boolean method":
            val data = [[], [1], [], [2, 3]]
            val result = data.filter(&:is_empty)
            expect result == [[], []]

    context "chaining method references":
        it "chains map with method reference":
            val words = ["hello", "world"]
            val lengths = words.map(&:len)
            val strs = lengths.map(&:to_s)
            expect strs == ["5", "5"]

    context "method reference as value":
        it "stores method reference in variable":
            val to_str = &:to_s
            expect to_str(42) == "42"

        it "stores len reference":
            val get_len = &:len
            expect get_len("hello") == 5

    context "method reference with various types":
        it "calls len on arrays":
            val data = [[1, 2], [3], [4, 5, 6]]
            val result = data.map(&:len)
            expect result == [2, 1, 3]

    context "edge cases":
        it "method reference on empty collection":
            val data: [text] = []
            val result = data.map(&:len)
            expect result == []

        it "method reference on single element":
            val data = ["hello"]
            val result = data.map(&:len)
            expect result == [5]

        it "combines method reference with placeholder":
            val words = ["hello", "hi", "hey", "howdy"]
            val lengths = words.map(&:len)
            val result = lengths.filter(_ > 2)
            expect result == [5, 5]
