# # Serial Port Driver Specification
#
# **Feature IDs:** #BM-SERIAL-001
# **Category:** Bare-Metal / Drivers
# **Difficulty:** 2/5
# **Status:** In Progress
#
# ## Overview
#
# UART serial driver for bare-metal systems supporting:
# - COM1-COM4 port access
# - Configurable baud rates (9600-115200)
# - 8N1 configuration (8 data bits, no parity, 1 stop bit)
# - FIFO buffering
# - CR/LF newline handling
#
# ## Key Concepts
#
# | Concept | Description |
# |---------|-------------|
# | COM Port | Standard PC serial ports (0x3F8, 0x2F8, etc.) |
# | Baud Rate | Data transmission speed (bits per second) |
# | DLAB | Divisor Latch Access Bit for baud rate config |
# | LSR | Line Status Register for TX/RX status |
#
# ## Implementation Notes
#
# - QEMU uses -serial stdio to connect COM1 to terminal
# - LF (0x0A) automatically converted to CR+LF for terminals
# - Transmit waits for buffer empty before sending

describe "COM Port Addresses":
    # Verify standard PC serial port addresses.

    it "COM1 is at 0x3F8":
        val COM1 = 0x3F8
        expect(COM1).to_equal(0x3F8)

    it "COM2 is at 0x2F8":
        val COM2 = 0x2F8
        expect(COM2).to_equal(0x2F8)

    it "COM3 is at 0x3E8":
        val COM3 = 0x3E8
        expect(COM3).to_equal(0x3E8)

    it "COM4 is at 0x2E8":
        val COM4 = 0x2E8
        expect(COM4).to_equal(0x2E8)

describe "UART Register Offsets":
    # Verify UART register offsets from base address.

    it "DATA register at offset 0":
        val UART_DATA = 0
        expect(UART_DATA).to_equal(0)

    it "IER register at offset 1":
        # Interrupt Enable Register.
        val UART_IER = 1
        expect(UART_IER).to_equal(1)

    it "FCR/IIR register at offset 2":
        # FIFO Control / Interrupt Identification.
        val UART_FCR = 2
        val UART_IIR = 2
        expect(UART_FCR).to_equal(2)
        expect(UART_IIR).to_equal(2)

    it "LCR register at offset 3":
        # Line Control Register.
        val UART_LCR = 3
        expect(UART_LCR).to_equal(3)

    it "MCR register at offset 4":
        # Modem Control Register.
        val UART_MCR = 4
        expect(UART_MCR).to_equal(4)

    it "LSR register at offset 5":
        # Line Status Register.
        val UART_LSR = 5
        expect(UART_LSR).to_equal(5)

    it "MSR register at offset 6":
        # Modem Status Register.
        val UART_MSR = 6
        expect(UART_MSR).to_equal(6)

    it "Scratch register at offset 7":
        val UART_SCRATCH = 7
        expect(UART_SCRATCH).to_equal(7)

describe "Line Status Register Bits":
    # Verify LSR bit definitions.

    it "DATA_READY is bit 0":
        val LSR_DATA_READY = 1 << 0
        expect(LSR_DATA_READY).to_equal(1)

    it "OVERRUN_ERR is bit 1":
        val LSR_OVERRUN_ERR = 1 << 1
        expect(LSR_OVERRUN_ERR).to_equal(2)

    it "PARITY_ERR is bit 2":
        val LSR_PARITY_ERR = 1 << 2
        expect(LSR_PARITY_ERR).to_equal(4)

    it "FRAMING_ERR is bit 3":
        val LSR_FRAMING_ERR = 1 << 3
        expect(LSR_FRAMING_ERR).to_equal(8)

    it "BREAK is bit 4":
        val LSR_BREAK = 1 << 4
        expect(LSR_BREAK).to_equal(16)

    it "THRE is bit 5":
        # Transmit Holding Register Empty.
        val LSR_THRE = 1 << 5
        expect(LSR_THRE).to_equal(32)

    it "TEMT is bit 6":
        # Transmitter Empty.
        val LSR_TEMT = 1 << 6
        expect(LSR_TEMT).to_equal(64)

describe "Baud Rate Divisors":
    # Verify baud rate divisor calculations.

    context "Standard baud rates":
        it "115200 baud uses divisor 1":
            val BAUD_115200 = 1
            expect(BAUD_115200).to_equal(1)

        it "57600 baud uses divisor 2":
            val BAUD_57600 = 2
            expect(BAUD_57600).to_equal(2)

        it "38400 baud uses divisor 3":
            val BAUD_38400 = 3
            expect(BAUD_38400).to_equal(3)

        it "19200 baud uses divisor 6":
            val BAUD_19200 = 6
            expect(BAUD_19200).to_equal(6)

        it "9600 baud uses divisor 12":
            val BAUD_9600 = 12
            expect(BAUD_9600).to_equal(12)

    context "Divisor calculation":
        it "divisor = 115200 / baud_rate":
            # Base clock is 115200 Hz.
            val BASE_CLOCK = 115200
            val BAUD_RATE = 9600
            val divisor = BASE_CLOCK / BAUD_RATE
            expect(divisor).to_equal(12)

describe "Line Control Register":
    # Verify LCR configuration values.

    it "DLAB is bit 7":
        # Divisor Latch Access Bit.
        val LCR_DLAB = 1 << 7
        expect(LCR_DLAB).to_equal(128)

    it "8N1 configuration is 0x03":
        # 8 data bits, no parity, 1 stop bit.
        val LCR_8N1 = 0x03
        expect(LCR_8N1).to_equal(3)

    it "8 data bits is bits 0-1 set":
        # Word length: 00=5, 01=6, 10=7, 11=8.
        val WORD_LEN_8 = 0x03
        expect(WORD_LEN_8).to_equal(3)

describe "FIFO Control":
    # Verify FIFO configuration.

    it "FIFO enable with 14-byte threshold is 0xC7":
        # Enable FIFO, clear TX/RX, 14-byte trigger.
        val FCR_CONFIG = 0xC7
        expect(FCR_CONFIG).to_equal(199)

    it "FIFO enable bit is bit 0":
        val FCR_ENABLE = 1 << 0
        expect(FCR_ENABLE).to_equal(1)

    it "Clear RX FIFO is bit 1":
        val FCR_CLEAR_RX = 1 << 1
        expect(FCR_CLEAR_RX).to_equal(2)

    it "Clear TX FIFO is bit 2":
        val FCR_CLEAR_TX = 1 << 2
        expect(FCR_CLEAR_TX).to_equal(4)

describe "Modem Control Register":
    # Verify MCR configuration.

    it "Normal operation mode is 0x0F":
        # RTS, DTR, OUT1, OUT2 all set.
        val MCR_NORMAL = 0x0F
        expect(MCR_NORMAL).to_equal(15)

    it "Loopback mode is 0x1E":
        # For self-test during initialization.
        val MCR_LOOPBACK = 0x1E
        expect(MCR_LOOPBACK).to_equal(30)

    it "DTR is bit 0":
        val MCR_DTR = 1 << 0
        expect(MCR_DTR).to_equal(1)

    it "RTS is bit 1":
        val MCR_RTS = 1 << 1
        expect(MCR_RTS).to_equal(2)

describe "Newline Handling":
    # Verify CR/LF newline conversion.

    it "LF byte is 0x0A":
        val LF = 0x0A
        expect(LF).to_equal(10)

    it "CR byte is 0x0D":
        val CR = 0x0D
        expect(CR).to_equal(13)

    it "LF converted to CR+LF for terminals":
        # Standard terminal newline sequence.
        val expected_sequence = [0x0D, 0x0A]
        expect(expected_sequence[0]).to_equal(13)
        expect(expected_sequence[1]).to_equal(10)

describe "Test Byte for Loopback":
    # Verify loopback test byte.

    it "test byte is 0xAE":
        # Arbitrary byte used for loopback test.
        val TEST_BYTE = 0xAE
        expect(TEST_BYTE).to_equal(174)
