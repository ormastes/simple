extern fn rt_env_get(key: text) -> text

fn _is_env_locked() -> bool:
    val sys = rt_env_get("SIMPLE_SYSTEM_TEST")
    val di_test = rt_env_get("SIMPLE_DI_TEST")
    if sys == "1":
        if di_test == "1":
            return false
        return true
    false

class DiContainer:
    bindings: map
    singletons: map
    profile: text
    all_bindings: list
    locked: bool

    fn is_locked() -> bool:
        if self.locked:
            return true
        _is_env_locked()

    me lock():
        self.locked = true

    me bind_instance(key: text, value):
        if self.is_locked():
            return nil
        var new_bindings = []
        for entry in self.all_bindings:
            if entry[0] != key:
                new_bindings = new_bindings + [entry]
        new_bindings = new_bindings + [[key, value]]
        self.all_bindings = new_bindings

    fn has(key: text) -> bool:
        for entry in self.all_bindings:
            if entry[0] == key:
                return true
        false

describe "di with external env lock":
    it "bind works when unlocked":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.bind_instance("key", "value")
        expect(di.has("key")).to_equal(true)
    it "lock blocks bind":
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
        di.lock()
        di.bind_instance("key", "value")
        expect(di.has("key")).to_equal(false)
