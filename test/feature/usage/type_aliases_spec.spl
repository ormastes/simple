# # Type Aliases Specification
#
# **Feature IDs:** #TYPE-ALIAS-001 to #TYPE-ALIAS-012
# **Category:** Language
# **Difficulty:** 2/5
# **Status:** Implemented
#
# ## Overview
#
# Type aliases allow creating alternative names for existing types, improving
# code readability and maintainability. They enable domain-specific naming
# without introducing new types, and support generic type aliases for
# parameterized type shortcuts.
#
# ## Syntax
#
# ```simple
# type UserId = i64
# type IntList = [i64]
# type StringMap = {str: str}
# ```
#
# ## Key Concepts
#
# | Concept | Description |
# |---------|-------------|
# | Type Alias | Alternative name for an existing type |
# | Collection Alias | Alias for array or dict types |
# | Alias Chain | Alias that references another alias |
#
# ## Behavior
#
# - Type aliases are fully interchangeable with their target type
# - Aliases can reference collection types
# - Aliases do not create new types (unlike newtypes)
# - Aliases can reference other aliases (chaining)



# ============================================================================
# Type Alias Basics
# ============================================================================

describe "Type Aliases":
    # ## Core Type Alias Functionality
    #
    # Tests for defining and using type aliases including simple aliases,
    # collection aliases, and alias chains.

    context "with simple aliases":
        # ### Scenario: Simple Type Alias
        #
        # Creates an alternative name for an existing type.

        it "aliases primitive types":
            type UserId = i64
            val user: UserId = 42
            expect user to eq(42)

        it "allows alias in function signature":
            type Score = i64

            fn double_score(s: Score) -> Score:
                s * 2

            val result = double_score(21)
            expect result to eq(42)

        it "is interchangeable with base type":
            type Age = i64

            fn process_int(n: i64) -> i64:
                n + 10

            val age: Age = 25
            val result = process_int(age)
            expect result to eq(35)

    context "with collection aliases":
        # ### Scenario: Collection Type Alias
        #
        # Creates aliases for array and dict types.

        it "aliases array types":
            type IntList = [i64]
            val numbers: IntList = [1, 2, 3, 4, 5]
            expect numbers.len() to eq(5)

        it "aliases dict types":
            type StringMap = {str: str}
            val data: StringMap = {"key": "value"}
            expect data["key"] to eq("value")

        it "allows nested collection aliases":
            type Matrix = [[i64]]
            val m: Matrix = [[1, 2], [3, 4]]
            expect m[0][0] to eq(1)
            expect m[1][1] to eq(4)

    context "with alias chains":
        # ### Scenario: Alias Chain
        #
        # Creates an alias that references another alias.

        it "supports alias of alias":
            type Id = i64
            type UserId = Id
            val user: UserId = 100
            expect user to eq(100)

        it "supports multiple levels of aliasing":
            type Base = i64
            type Middle = Base
            type Top = Middle
            val value: Top = 42
            expect value to eq(42)


# ============================================================================
# Type Alias in Different Contexts
# ============================================================================

describe "Type Alias Usage":
    # ## Type Alias in Various Contexts
    #
    # Tests using type aliases in structs, classes, and complex expressions.

    context "in struct fields":
        it "uses alias in struct definition":
            type Timestamp = i64

            class Event:
                time: Timestamp
                name: str

            val e = Event(time: 1234567890, name: "test")
            expect e.time to eq(1234567890)

    context "in class fields":
        it "uses alias in class definition":
            type Count = i64

            class Counter:
                value: Count

                fn get() -> Count:
                    self.value

            val c = Counter(value: 10)
            expect c.get() to eq(10)

    context "with return types":
        it "uses alias as return type":
            type Result = i64

            fn compute() -> Result:
                42

            val r: Result = compute()
            expect r to eq(42)
