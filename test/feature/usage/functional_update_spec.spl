# # In-Place Functional Update with the Arrow Operator
#
# **Feature ID:** #LANG-031
# **Category:** Language
# **Status:** Active
#
# ## Overview
#
# The functional update operator `->` applies transformations to collections in place,
# enabling fluent data processing pipelines. Unlike method chaining with `.`, the arrow
# operator mutates the target variable directly (e.g., `arr->map(...)` transforms `arr`
# in place). This spec validates `->concat`, `->map`, `->filter`, and `->set` operations
# on arrays and dicts, verifies correct chaining of multiple operations in sequence,
# and confirms that lambda expressions with closures work within functional updates.
#
# ## Syntax
#
# ```simple
# var arr = [1, 2, 3]
# arr->map(\x: x + 1)               # arr is now [2, 3, 4]
# arr->filter(\x: x > 2)            # arr is now [3, 4]
#
# var d = {"a": 1}
# d->set("b", 2)                    # d now has keys "a" and "b"
#
# var items = [5, 10, 15, 20]
# items->filter(\x: x > 5)          # chained in-place transforms
# items->map(\x: x - 5)             # items is now [5, 10, 15]
# ```
#
# ## Key Concepts
#
# | Concept | Description |
# |---------|-------------|
# | `->` operator | Applies a transformation to a collection in place, mutating the variable |
# | `->map` | Transforms each element using a lambda, updating the collection in place |
# | `->filter` | Retains only elements matching a predicate, modifying the collection in place |
# | `->concat` | Appends another collection's elements to the target in place |
# | `->set` | Adds or updates a key-value pair in a dict in place |
# | Chained updates | Multiple `->` operations can be applied sequentially for data pipelines |



# ============================================================================
# Test Group 1: Basic Functional Updates
# ============================================================================

describe "Functional Update Syntax":
    # Tests for basic functional update patterns on structs and records.
    # Verifies that copies are created with specific field modifications.

    context "when updating a struct field":
        # ### Scenario: Single Field Update
        #
        # Tests updating a single field in a struct via functional update.

        it "creates new struct with updated field":
            # Functional update with concat - modifies in place and returns
            var arr = [1, 2]
            arr->concat([3, 4])
            expect arr.len() == 4

        it "leaves original struct unchanged":
            # Functional update with map - transforms elements in place
            var arr = [1, 2, 3]
            arr->map(\x: x * 2)
            expect arr[1] == 4

    context "when updating multiple fields":
        # ### Scenario: Multi-Field Update
        #
        # Tests updating several fields in a single functional update expression.

        it "updates all specified fields":
            # Functional update with filter - filters elements in place
            var arr = [1, 2, 3, 4, 5]
            arr->filter(\x: x > 2)
            expect arr.len() == 3

        it "preserves unmodified fields":
            # Dict functional update - adds new key
            var d = {"a": 1}
            d->set("b", 2)
            expect d.len() == 2


# ============================================================================
# Test Group 2: Nested Updates
# ============================================================================

describe "Functional Update with Nesting":
    # Tests for functional updates on nested structures,
    # including lens-like patterns and deep updates.

    context "when updating nested struct fields":
        # ### Scenario: Nested Functional Update
        #
        # Tests updating fields in nested structures.

        it "updates nested field values":
            # Chained functional updates - map then filter
            var arr = [1, 2, 3]
            arr->map(\x: x + 1)
            arr->filter(\x: x > 2)
            expect arr.len() == 2

        it "preserves sibling fields in nested structures":
            # Multiple dict operations
            var d = {"x": 1, "y": 2}
            d->set("z", 3)
            expect d["x"] == 1
            expect d["z"] == 3

    context "when chaining functional updates":
        # ### Scenario: Update Chaining
        #
        # Tests chaining multiple functional updates in sequence.

        it "applies updates in correct order":
            # Chained array operations: [1,2,3] -> [2,3,4] -> [3,4]
            var arr = [1, 2, 3]
            arr->map(\x: x + 1)
            arr->filter(\x: x > 2)
            expect arr == [3, 4]

        it "maintains immutability through chain":
            # Multiple transformations preserve data integrity
            var original = [1, 2, 3, 4, 5]
            original->filter(\x: x % 2 == 0)
            original->map(\x: x * 10)
            expect original == [20, 40]


# ============================================================================
# Test Group 3: Advanced Patterns
# ============================================================================

describe "Functional Update Advanced Patterns":
    # Tests for advanced functional update patterns,
    # including conditional updates and integration with other features.

    it "works with generic types":
        # Functional update works with any collection type
        var numbers = [10, 20, 30]
        numbers->map(\x: x / 10)
        expect numbers == [1, 2, 3]

    it "supports computed field values in update":
        # Lambda with complex computation in functional update
        var arr = [1, 2, 3, 4, 5]
        val threshold = 2
        arr->filter(\x: x > threshold)
        expect arr.len() == 3

    it "handles update expressions with side effects":
        # Functional update with multiple operations
        var items = [5, 10, 15, 20]
        items->filter(\x: x > 5)
        items->map(\x: x - 5)
        expect items == [5, 10, 15]
