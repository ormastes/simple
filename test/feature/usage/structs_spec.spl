# # Structs Specification
#
# **Feature IDs:** #TBD
# **Category:** Language
# **Difficulty:** 2/5
# **Status:** Implemented
#
# ## Overview
#
# Structs are user-defined data types that group related fields together.
# They support named fields with type annotations, default values, and can
# have methods defined via impl blocks. Structs are the primary way to
# define custom data structures in Simple.
#
# ## Syntax
#
# ```simple
# struct Point:
# x: i64
# y: i64
#
# struct Config:
# host: String = "localhost"
# port: i64 = 8080
#
# val p = Point { x: 3, y: 4 }
# val c = Config { port: 9000 }  # host uses default
# ```
#
# ## Key Concepts
#
# | Concept | Description |
# |---------|-------------|
# | Struct | User-defined data type with named fields |
# | Field | Named member of a struct with type annotation |
# | Default Value | Optional value used when field not provided |
# | Construction | Creating struct instance with field values |
#
# ## Behavior
#
# - Fields are accessed using dot notation: `point.x`
# - Construction requires all fields without defaults
# - Fields can have default values
# - Structs are value types (copied by default)



# ============================================================================
# Struct Basics
# ============================================================================

describe "Structs":
    # ## Core Struct Functionality
    #
    # Tests for struct definition, construction, field access, and default values.
    # Validates struct behavior as value types with named fields.

    context "struct definition and construction":
        # ### Scenario: Struct Creation
        #
        # Defines and constructs structs with typed fields.

        it "defines struct with fields":
            struct Point:
                x: i64
                y: i64

            val p = Point { x: 10, y: 20 }
            expect p.x + p.y == 30

        it "constructs struct with all fields":
            struct Config:
                host: str
                port: i64

            val c = Config { host: "localhost", port: 8080 }
            expect c.port == 8080

    context "struct field access":
        # ### Scenario: Accessing Struct Fields
        #
        # Reads field values using dot notation.

        it "accesses struct fields":
            struct Rectangle:
                width: i64
                height: i64

            val r = Rectangle { width: 10, height: 5 }
            expect r.width * r.height == 50


# ============================================================================
# Impl Blocks
# ============================================================================

describe "Impl Blocks":
    # ## Methods via Impl Blocks
    #
    # Tests for adding methods to structs using impl blocks.

    it "adds method to struct":
        struct Point:
            x: i64
            y: i64

        impl Point:
            fn sum(self):
                return self.x + self.y

        val p = Point { x: 15, y: 25 }
        expect p.sum() == 40

    it "adds method with arguments":
        struct Counter:
            value: i64

        impl Counter:
            fn add(self, n):
                return self.value + n

        val c = Counter { value: 10 }
        expect c.add(5) == 15


# ============================================================================
# Classes with Static Methods
# ============================================================================

describe "Classes":
    # ## Class Definitions
    #
    # Tests for classes with static methods.

    it "defines class with static method":
        class Calculator:
            static fn add(a, b):
                return a + b

        expect Calculator.add(3, 4) == 7


# ============================================================================
# Context Blocks
# ============================================================================

describe "Context Blocks":
    # ## Context Block Syntax
    #
    # Tests for context blocks that provide implicit receiver.

    it "dispatches methods to context object":
        class Calculator:
            fn double(self, x):
                return x * 2

        val calc = Calculator {}
        var res = 0
        context calc:
            res = double(21)
        expect res == 42

    it "accesses self fields in context":
        class Adder:
            base: i64 = 10

            fn add(self, x):
                return self.base + x

        val a = Adder { base: 30 }
        var res = 0
        context a:
            res = add(12)
        expect res == 42


# ============================================================================
# Method Missing
# ============================================================================

describe "Method Missing":
    # ## Dynamic Method Handling
    #
    # Tests for method_missing to handle undefined methods.

    it "calls method_missing for unknown method":
        class DSL:
            fn method_missing(self, name, args, block):
                return 42

        val d = DSL {}
        expect d.unknown_method() == 42

    it "passes arguments to method_missing":
        class Multiplier:
            factor: i64 = 10

            fn method_missing(self, name, args, block):
                val x = args[0]
                return self.factor * x

        val m = Multiplier { factor: 7 }
        expect m.any_method(6) == 42
