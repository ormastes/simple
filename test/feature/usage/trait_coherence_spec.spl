# # Trait Coherence Specification
#
# **Feature IDs:** #TRAIT-COH-001 to #TRAIT-COH-017
# **Category:** Type System | Traits
# **Status:** Implemented
#
# Tests trait coherence rules including:
# - Orphan rule enforcement
# - Overlap detection
# - Blanket impl conflicts
# - Associated type coherence
# - Specialization with #[default]
#
# ## Coherence Rules
#
# 1. **Orphan Rule**: Either trait OR type must be local
# 2. **Overlap Rule**: No two impls for same trait+type
# 3. **Blanket Conflict**: Generic impl conflicts with specific
# 4. **Associated Types**: Same type must be declared consistently

use std.spec


# ============================================================================
# Test Group 1: Orphan Rule - Allowed Cases
# ============================================================================

describe "Orphan Rule - Allowed Cases":
    # ## Local Trait or Local Type
    #
    # Tests that orphan rule allows local trait + foreign type.

    it "allows local trait on foreign type":
        trait MyTrait:
            fn process() -> i64

        impl MyTrait for str:
            fn process() -> i64:
                42

        expect "test".process() == 42

    it "allows foreign trait on local type":
        struct MyType:
            value: i64

        impl Display for MyType:
            fn to_string() -> str:
                "MyType"

        val t = MyType(value: 42)
        expect t.to_string() == "MyType"

    it "allows local trait on local type":
        trait LocalTrait:
            fn get() -> i64

        struct LocalType:
            x: i64

        impl LocalTrait for LocalType:
            fn get() -> i64:
                self.x

        val t = LocalType(x: 42)
        expect t.get() == 42


# ============================================================================
# Test Group 2: Orphan Rule - Rejection
# ============================================================================

describe "Orphan Rule - Rejection":
    # ## Foreign Trait + Foreign Type
    #
    # Tests that orphan rule rejects foreign trait on foreign type.

    # Note: This test verifies compile-time rejection
    # The compiler should reject: impl Display for String
    it "foreign trait on foreign type is rejected at compile time":
        # This would be a compile error:
        # impl Display for String:
        #     fn to_string() -> str:
        #         self
        expect true  # Placeholder - compile-time check


# ============================================================================
# Test Group 3: Overlap Detection - Same Type
# ============================================================================

describe "Overlap Detection - Same Type":
    # ## Duplicate Impl Detection
    #
    # Tests that duplicate impls for same trait+type are rejected.

    it "single impl is allowed":
        trait Process:
            fn run() -> i64

        impl Process for i32:
            fn run() -> i64:
                42

        val x: i32 = 21
        expect x.run() == 42

    # Note: This test verifies compile-time rejection
    it "duplicate impl is rejected at compile time":
        # This would be a compile error (second impl):
        # impl Process for i32:
        #     fn run() -> i64:
        #         0
        expect true


# ============================================================================
# Test Group 4: Overlap Detection - Generic vs Concrete
# ============================================================================

describe "Overlap Detection - Generic vs Concrete":
    # ## Generic/Concrete Conflict
    #
    # Tests that generic impl conflicts with concrete impl.

    it "specific impl is allowed alone":
        trait Handler:
            fn handle() -> i64

        impl Handler for i32:
            fn handle() -> i64:
                1

        val x: i32 = 0
        expect x.handle() == 1

    # Note: This test verifies compile-time conflict detection
    it "generic impl conflicts with specific":
        # This would be a compile error (blanket conflicts):
        # impl<T> Handler for T:
        #     fn handle() -> i64:
        #         0
        expect true


# ============================================================================
# Test Group 5: No Overlap - Different Types
# ============================================================================

describe "No Overlap - Different Types":
    # ## Separate Impls Allowed
    #
    # Tests that impls for different types don't conflict.

    it "different types can have same trait":
        trait Convert:
            fn convert() -> str

        impl Convert for i32:
            fn convert() -> str:
                "i32"

        impl Convert for str:
            fn convert() -> str:
                "str"

        val x: i32 = 42
        val s: str = "hello"
        expect x.convert() == "i32"
        expect s.convert() == "str"


# ============================================================================
# Test Group 6: Associated Type Coherence
# ============================================================================

describe "Associated Type Coherence":
    # ## Consistent Associated Types
    #
    # Tests that associated types are declared consistently.

    it "associated type in impl is valid":
        trait Container:
            type Item

            fn get() -> Item

        struct IntList:
            items: [i64]

        impl Container for IntList:
            type Item = i64

            fn get() -> i64:
                if self.items.?:
                    self.items[0]
                else:
                    0

        val list = IntList(items: [42])
        expect list.get() == 42

    # Note: Compile-time check for conflicting associated types
    it "conflicting associated type is rejected":
        # This would be a compile error (conflicting Item type):
        # impl Container for IntList:
        #     type Item = str  # Conflicts with i64
        expect true


# ============================================================================
# Test Group 7: Blanket Impl Conflict
# ============================================================================

describe "Blanket Impl Conflict":
    # ## Generic Impl Conflicts
    #
    # Tests that blanket impls conflict with specific impls.

    it "specific impl alone works":
        trait Serialize:
            fn serialize() -> str

        impl Serialize for i64:
            fn serialize() -> str:
                "i64"

        val x: i64 = 42
        expect x.serialize() == "i64"


# ============================================================================
# Test Group 8: Module Integration
# ============================================================================

describe "Module Coherence Integration":
    # ## Full Module Check
    #
    # Tests coherence checking across a module.

    it "module with trait, struct, and impl passes":
        trait Printable:
            fn print_value() -> str

        struct Person:
            name: str

        impl Printable for Person:
            fn print_value() -> str:
                self.name

        val p = Person(name: "Alice")
        expect p.print_value() == "Alice"


# ============================================================================
# Test Group 9: Inherent Impl
# ============================================================================

describe "Inherent Impl":
    # ## Methods Without Trait
    #
    # Tests that inherent impls (no trait) are allowed.

    it "inherent impl on local type is allowed":
        struct Point:
            x: i64
            y: i64

        impl Point:
            fn magnitude_squared() -> i64:
                self.x * self.x + self.y * self.y

        val p = Point(x: 3, y: 4)
        expect p.magnitude_squared() == 25


# ============================================================================
# Test Group 10: Multiple Traits Same Type
# ============================================================================

describe "Multiple Traits Same Type":
    # ## Different Traits, Same Type
    #
    # Tests that multiple different traits can be implemented.

    it "multiple traits on same type":
        trait Printable:
            fn to_str() -> str

        trait Comparable:
            fn compare(other: Self) -> i64

        struct Value:
            n: i64

        impl Printable for Value:
            fn to_str() -> str:
                "Value"

        impl Comparable for Value:
            fn compare(other: Value) -> i64:
                self.n - other.n

        val v1 = Value(n: 10)
        val v2 = Value(n: 5)
        expect v1.to_str() == "Value"
        expect v1.compare(v2) == 5


# ============================================================================
# Test Group 11: Generic Type Impl
# ============================================================================

describe "Generic Type Impl":
    # ## Impl on Generic Type
    #
    # Tests impls on generic types like Vec<T>.

    it "impl on generic type":
        trait Container:
            fn size() -> i64

        impl<T> Container for [T]:
            fn size() -> i64:
                self.len()

        val arr = [1, 2, 3, 4, 5]
        expect arr.size() == 5


# ============================================================================
# Test Group 12: Specialization with Default
# ============================================================================

describe "Specialization with Default":
    # ## #[default] Attribute
    #
    # Tests that #[default] allows specialization.

    # TODO: Enable when decorator on impl blocks is supported
    # it "default impl can be specialized":
    #     trait Process:
    #         fn process() -> str
    #
    #     @default
    #     impl<T> Process for T:
    #         fn process() -> str:
    #             "default"
    #
    #     impl Process for i64:
    #         fn process() -> str:
    #             "specialized for i64"
    #
    #     val x: i64 = 42
    #     expect x.process() == "specialized for i64"
    it "specialization placeholder":
        expect true  # TODO: Implement @default on impl blocks


# ============================================================================
# Test Group 13: Extension Trait Pattern
# ============================================================================

describe "Extension Trait Pattern":
    # ## Local Trait Extending Foreign Type
    #
    # Tests the extension trait pattern.

    it "extension trait on foreign type":
        trait StringExt:
            fn shout() -> str

        impl StringExt for str:
            fn shout() -> str:
                self.upper() + "!"

        expect "hello".shout() == "HELLO!"

    it "generic extension trait":
        trait SliceExt<T>:
            fn first_or_default(default: T) -> T

        impl<T> SliceExt<T> for [T]:
            fn first_or_default(default: T) -> T:
                if self.?:
                    self[0]
                else:
                    default

        val arr = [1, 2, 3]
        expect arr.first_or_default(0) == 1

        val empty: [i64] = []
        expect empty.first_or_default(42) == 42


# ============================================================================
# Test Group 14: Negative Bounds Infrastructure
# ============================================================================

describe "Negative Bounds Infrastructure":
    # ## Future: !Trait Syntax
    #
    # Tests infrastructure for negative trait bounds.

    it "impl with where clause":
        trait Clone:
            fn clone() -> Self

        trait Process:
            fn run() -> i64

        impl<T> Process for T where T: Clone:
            fn run() -> i64:
                42

        # Future: where T: !Clone would exclude Clone types
        expect true

