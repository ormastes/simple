"""
# Variables and Bindings Specification


use std.text.{NL}
**Feature ID:** #1050
**Category:** Language
**Status:** Implemented

## Overview

Tests for variable declarations including val (immutable) and var (mutable)
bindings, type inference, and scoping rules.

## Syntax

```simple
# Immutable binding (preferred)
val name = "Alice"

# Mutable binding
var count = 0
count = count + 1

# Tuple destructuring
var (a, b) = (1, 2)
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| val | Immutable binding - cannot be reassigned |
| var | Mutable binding - can be reassigned |

## Deprecated

- `let` - Use `val` instead
- `let mut` - Use `var` instead
"""



# ============================================================================
# Test Group 1: Basic Bindings
# ============================================================================

describe "Variables and Bindings":
    """
    ## Variable Declaration Support

    Verifies val/var declarations, type inference, mutability rules,
    and proper scoping behavior.
    """

    context "val bindings":
        """
        ### Scenario: Immutable Bindings

        Tests for val keyword creating immutable bindings.
        """

        it "creates immutable binding":
            val x = 42
            expect x == 42

        it "allows shadowing with new val":
            val x = 1
            val x = 2
            expect x == 2

        it "binds expression results":
            val result = 10 + 20 * 2
            expect result == 50

        it "binds complex expressions":
            val result = (5 + 3) * 4 - 10 / 2
            expect result == 27

    context "var bindings":
        """
        ### Scenario: Mutable Bindings

        Tests for var keyword creating mutable bindings.
        """

        it "creates mutable binding":
            var x = 0
            x = 10
            expect x == 10

        it "allows multiple reassignments":
            var x = 1
            x = 2
            x = 3
            expect x == 3


# ============================================================================
# Test Group 2: Scoping and Nesting
# ============================================================================

describe "Scoping and Nesting":
    """
    ## Variable Scoping Behavior

    Tests for variable scoping with nested blocks.
    """

    context "nested scopes":
        """
        ### Scenario: Block Scoping

        Tests that inner scope can shadow outer variables.
        """

        it "inner scope shadows outer":
            val x = 1
            if true:
                val x = 2
                expect x == 2
            expect x == 1

        it "inner scope can read outer":
            val x = 10
            var result = 0
            if true:
                result = x + 5
            expect result == 15

    context "loop scoping":
        """
        ### Scenario: Loop Variable Scope

        Tests that loop variables are properly scoped.
        """

        it "loop variable isolated to loop":
            val i = 100
            var sum = 0
            for i in 0..5:
                sum = sum + i
            expect i == 100
            expect sum == 10


# ============================================================================
# Test Group 3: Additional val/var Patterns
# ============================================================================

describe "Additional val/var Patterns":
    """
    ## More Binding Patterns

    Tests for additional val/var usage patterns.
    """

    context "val with different types":
        """
        ### Scenario: Immutable Different Types

        Tests val bindings with various types.
        """

        it "creates immutable boolean":
            val flag = true
            expect flag == true

        it "creates immutable float":
            val pi = 3.14
            expect pi > 3.0

    context "var initialization patterns":
        """
        ### Scenario: Mutable Initialization

        Tests var initialization and modification.
        """

        it "initializes var with expression":
            var x = 5 * 2
            x = x + 10
            expect x == 20

        it "modifies var in loop":
            var sum = 0
            for i in 1..4:
                sum = sum + i
            expect sum == 6


# ============================================================================
# Test Group 4: Tuple Destructuring
# ============================================================================

describe "Tuple Destructuring Bindings":
    """
    ## Destructuring in Bindings

    Tests for tuple destructuring in variable declarations.
    """

    context "var with tuples":
        """
        ### Scenario: Mutable Tuple Destructuring

        Tests for destructuring tuples with mutable bindings.
        """

        it "destructures tuple into mutable bindings":
            var (a, b) = (1, 2)
            a = 10
            b = 20
            expect a + b == 30

    context "val with tuples":
        """
        ### Scenario: Immutable Tuple Destructuring

        Tests for destructuring tuples with immutable bindings.
        """

        it "destructures tuple into immutable bindings":
            val (x, y) = (3, 4)
            expect x + y == 7


# ============================================================================
# Test Group 5: Type Inference
# ============================================================================

describe "Type Inference":
    """
    ## Automatic Type Deduction

    Tests for type inference on variable bindings.
    """

    context "primitive type inference":
        """
        ### Scenario: Infer Primitive Types

        Tests that primitive types are inferred correctly.
        """

        it "infers integer type":
            val x = 42
            expect x + 8 == 50

        it "infers string type":
            val s = "hello"
            expect s.len() == 5

        it "infers array type":
            val arr = [1, 2, 3]
            expect arr.len() == 3


# ============================================================================
# Test Group 6: Global Functions and Collections
# ============================================================================

describe "Global Functions with Bindings":
    """
    ## Built-in Functions

    Tests for global functions like len() working with bindings.
    """

    context "len function":
        """
        ### Scenario: Length of Collections

        Tests the global len() function with arrays.
        """

        it "gets length of array":
            val arr = [1, 2, 3, 4, 5]
            expect len(arr) == 5

        it "gets length using method syntax":
            val arr = [1, 2, 3]
            expect arr.len() == 3


# ============================================================================
# Test Group 7: Option Type Bindings
# ============================================================================

describe "Option Type Bindings":
    """
    ## Option Types

    Tests for binding Option values (Some and None).
    """

    context "Some bindings":
        """
        ### Scenario: Some Value Binding

        Tests binding Some values.
        """

        it "binds Some value":
            val opt: Option<i64> = Some(42)
            expect opt.?

        it "unwraps Some value":
            val opt: Option<i64> = Some(99)
            expect opt.unwrap() == 99

    context "None bindings":
        """
        ### Scenario: None Value Binding

        Tests binding None values.
        """

        it "binds None value":
            val opt: Option<i64> = None
            expect not opt.?
