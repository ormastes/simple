# # Primitive Types Specification
#
# **Feature ID:** #PRIM-001
# **Category:** Language | Types
# **Status:** Implemented
#
# ## Overview
#
# Tests for primitive types, type suffixes, union types, type aliases,
# and generic types.
#
# ## Syntax
#
# ```simple
# val x = 42i32                             # Type suffix
# type Number = i64                         # Type alias
# fn process(x: i64 | str) -> i64: ...      # Union type
# fn identity<T>(x: T) -> T: x              # Generic function
# ```



# ============================================================================
# Test Group 1: Enum Types
# ============================================================================

describe "Enum Types":
    # ## Enum Comparison and Matching
    #
    # Tests for enum type operations.

    it "compares enum variants":
        enum Color:
            Red
            Green
        val c = Color.Green
        var result = 0
        if c == Color.Red:
            result = 1
        else:
            result = 0
        expect result == 0


# ============================================================================
# Test Group 2: Union Types
# ============================================================================

describe "Union Types":
    # ## Union Type Annotations
    #
    # Tests for union types in function signatures.

    it "accepts union type parameter":
        fn test(x: i64 | str) -> i64:
            return 42
        expect test(10) == 42

    # TODO: Type-based pattern matching on union types not yet implemented
    # it "matches int in union":
    #     fn process(x: i64 | str) -> i64:
    #         match x:
    #             case n: i64: return n * 2
    #             case s: str: return 0
    #         return -1
    #     expect process(21) == 42

    # it "matches str in union":
    #     ...

    # it "handles three-type union":
    #     ...


# ============================================================================
# Test Group 3: Type Aliases
# ============================================================================

describe "Type Aliases":
    # ## Type Alias Definitions
    #
    # Tests for type alias declarations.

    it "uses simple type alias":
        type Number = i64
        fn double(x: Number) -> Number:
            return x * 2
        expect double(21) == 42


# ============================================================================
# Test Group 4: Optional Types
# ============================================================================

describe "Optional Types":
    # ## Optional Type Syntax (T?)
    #
    # Tests for optional type annotations.

    it "accepts optional parameter":
        fn maybe_value(x: i64?) -> i64:
            return 5
        expect maybe_value(10) == 5


# ============================================================================
# Test Group 5: Generic Functions
# ============================================================================

describe "Generic Functions":
    # ## Generic Function Definitions
    #
    # Tests for generic functions with type parameters.

    it "defines identity function":
        fn identity<T>(x: T) -> T:
            return x
        expect identity(42) == 42

    it "uses two type parameters":
        fn first<A, B>(a: A, b: B) -> A:
            return a
        fn second<A, B>(a: A, b: B) -> B:
            return b
        val x = first(10, 20)
        val y = second(30, 40)
        expect x + y == 50


# ============================================================================
# Test Group 6: Generic Structs
# ============================================================================

describe "Generic Structs":
    # ## Generic Struct Definitions
    #
    # Tests for generic structs with type parameters.

    it "creates generic struct":
        struct Box<T>:
            value: T
        val b = Box { value: 42 }
        expect b.value == 42


# ============================================================================
# Test Group 7: Option Type
# ============================================================================

describe "Option Type Operations":
    # ## Option Some/None Operations
    #
    # Tests for Option type methods.

    it "unwraps Some value":
        val opt = Some(42)
        expect opt.unwrap() == 42

    it "unwraps None with default":
        val opt = None
        expect opt.unwrap_or(99) == 99

    it "checks is_some":
        val opt = Some(1)
        var result = 0
        if opt.is_some():
            result = 1
        expect result == 1

    it "checks is_none":
        val opt = None
        var result = 0
        if opt.is_none():
            result = 1
        expect result == 1

    it "maps Some value":
        val opt = Some(10)
        val res = opt.map(\x: x * 2)
        expect res.unwrap() == 20


# ============================================================================
# Test Group 8: Type Suffixes
# ============================================================================

describe "Type Suffixes":
    # ## Numeric Type Suffixes
    #
    # Tests for numeric literals with type suffixes.

    it "uses i32 suffix":
        val x = 42i32
        expect x == 42

    it "uses i64 suffix":
        val x = 100i64
        expect x == 100

    it "uses u32 suffix":
        val x = 255u32
        expect x == 255

    it "uses unit suffix km":
        val distance = 100_km
        expect distance == 100

    it "uses unit suffix in expression":
        val a = 50_m
        val b = 30_m
        expect a + b == 80

    it "uses f64 suffix":
        val x = 3.15f64
        expect 1 == 1  # parsing test

    it "uses f32 suffix":
        val x = 1.5f32
        expect 1 == 1  # parsing test


# ============================================================================
# Test Group 9: Strong Enums
# ============================================================================

describe "Strong Enums":
    # ## Strong Enum Exhaustive Matching
    #
    # Tests for #[strong] enum attribute.

    it "matches exhaustively without wildcard":
        #[strong]
        enum Status:
            Active
            Inactive
            Pending
        val s = Status.Active
        var r = 0
        match s:
            case Status.Active:
                r = 1
            case Status.Inactive:
                r = 2
            case Status.Pending:
                r = 3
        expect r == 1

    it "allows wildcard in weak enum":
        enum Status:
            Active
            Inactive
            Pending
        val s = Status.Active
        var result = 0
        match s:
            case Status.Active:
                result = 1
            case _:
                result = 0
        expect result == 1

