# # Mutable Collections by Default
#
# **Feature ID:** #LANG-024
# **Category:** Language
# **Status:** Active
#
# ## Overview
#
# Simple follows the design decision that collections (arrays and dicts) are mutable by
# default, consistent with Python, JavaScript, and Java. Variables declared with `var`
# can freely `push`, `pop`, `insert`, `remove`, `clear`, and use index assignment on
# arrays and dicts without any special annotation. Even `val` bindings to collections
# allow mutation of the collection contents (the binding is immutable, not the data).
# This spec comprehensively validates all mutation operations on arrays and dicts,
# sequential borrow patterns (read after write), and edge cases like empty collections.
#
# ## Syntax
#
# ```simple
# var arr = [1, 2, 3]
# arr.push(4)                # append element
# arr.pop()                  # remove and return last
# arr.insert(1, 2)           # insert at index
# arr.remove(0)              # remove at index
# arr[1] = 10                # index assignment
# arr.clear()                # remove all elements
#
# var dict = {"a": 1}
# dict["b"] = 2              # add new key
# dict["a"] = 10             # update existing key
# dict.remove("a")           # remove key
# dict.clear()               # remove all entries
# ```
#
# ## Key Concepts
#
# | Concept | Description |
# |---------|-------------|
# | Mutable by default | Arrays and dicts support mutation without explicit mutability annotations |
# | `var` vs `val` binding | `var` allows rebinding; `val` prevents rebinding but both allow collection mutation |
# | Array mutations | `push`, `pop`, `insert`, `remove`, `clear`, and index assignment |
# | Dict mutations | Key assignment (`dict[k] = v`), `remove`, and `clear` |
# | Sequential borrows | Reading after writing (e.g., `arr.push(4)` then `arr[3]`) works correctly |
# | Empty collection edge cases | Pushing to `[]`, popping from `[1]`, inserting into `{}` all behave correctly |

describe "Mutable Collections by Default":

    context "Array Mutability":
        it "allows push on default arrays":
            var arr = [1, 2, 3]
            arr.push(4)
            expect arr.len() == 4
            expect arr[3] == 4

        it "allows pop on default arrays":
            var arr = [1, 2, 3]
            val last = arr.pop()
            expect last == 3
            expect arr.len() == 2

        it "allows multiple pops":
            var arr = [1, 2, 3, 4, 5]
            arr.pop()
            arr.pop()
            expect arr.len() == 3
            expect arr[2] == 3

        it "allows insert on default arrays":
            var arr = [1, 3]
            arr.insert(1, 2)
            expect arr.len() == 3
            expect arr[1] == 2

        it "allows insert at beginning":
            var arr = [2, 3]
            arr.insert(0, 1)
            expect arr[0] == 1

        it "allows insert at end":
            var arr = [1, 2]
            arr.insert(2, 3)
            expect arr[2] == 3

        it "allows remove on default arrays":
            var arr = [1, 2, 3]
            val removed = arr.remove(1)
            expect removed == 2
            expect arr.len() == 2

        it "allows remove first element":
            var arr = [1, 2, 3]
            val removed = arr.remove(0)
            expect removed == 1
            expect arr[0] == 2

        it "allows remove last element":
            var arr = [1, 2, 3]
            val removed = arr.remove(2)
            expect removed == 3
            expect arr.len() == 2

        it "allows clear on default arrays":
            var arr = [1, 2, 3]
            arr.clear()
            expect arr.len() == 0

        it "allows indexing assignment":
            var arr = [1, 2, 3]
            arr[1] = 10
            expect arr[1] == 10

        it "allows indexing assignment at boundaries":
            var arr = [1, 2, 3]
            arr[0] = 10
            arr[2] = 30
            expect arr[0] == 10
            expect arr[2] == 30

    context "Dict Mutability":
        it "allows insert on default dicts":
            var dict = {"a": 1}
            dict["b"] = 2
            expect dict["b"] == 2

        it "allows update existing key":
            var dict = {"a": 1}
            dict["a"] = 10
            expect dict["a"] == 10

        it "allows remove on default dicts":
            var dict = {"a": 1, "b": 2}
            dict.remove("a")
            expect dict.len() == 1

        it "allows clear on default dicts":
            var dict = {"a": 1, "b": 2}
            dict.clear()
            expect dict.len() == 0

    context "var binding with mutable collection":
        it "allows mutation with var binding":
            var arr = [1, 2, 3]
            arr.push(4)
            expect arr.len() == 4
            expect arr[3] == 4

        it "allows pop with var binding":
            var arr = [1, 2, 3]
            arr.pop()
            expect arr.len() == 2

        it "works with dict and val binding":
            val dict = {"a": 1}
            dict["b"] = 2
            expect dict["b"] == 2

    context "Sequential operations":
        it "handles sequential borrows":
            var arr = [1, 2, 3]
            val len = arr.len()
            expect len == 3
            arr.push(4)
            expect arr.len() == 4

        it "allows read after write":
            var arr = [1, 2, 3]
            arr.push(4)
            val last = arr[3]
            expect last == 4

    context "Empty collection mutations":
        it "allows push to empty array":
            var arr = []
            arr.push(1)
            expect arr.len() == 1
            expect arr[0] == 1

        it "handles pop from singleton":
            var arr = [1]
            val elem = arr.pop()
            expect elem == 1
            expect arr.len() == 0

        it "allows insert into empty dict":
            var dict = {}
            dict["key"] = "value"
            expect dict["key"] == "value"
