# # LLVM Backend AArch64 Specification
#
#
# **Feature IDs:** #4002
# **Category:** Infrastructure
# **Difficulty:** 3/5
# **Status:** In Progress
#
# Validates that the LLVM backend correctly generates code for AArch64 (ARM 64-bit) targets.

use compiler.backend.llvm_ir_builder.{LlvmIRBuilder, LlvmIRBuilder__create, MirToLlvm, MirToLlvm__create}
use compiler.backend.llvm_target.{LlvmTargetTriple, LlvmTargetTriple__from_target, LlvmTargetTriple__from_target_baremetal, LlvmTargetConfig, LlvmTargetConfig__for_target}
use compiler.backend.llvm_type_mapper.{LlvmTypeMapper, LlvmTypeMapper__create_for_target}
use compiler.backend.entry_point.halt_instruction_for_target
use compiler.backend.backend_types.{CodegenTarget, OptimizationLevel}

describe "LLVM Backend AArch64":

    context "target triple":
        it "generates correct aarch64 triple":
            val triple = LlvmTargetTriple__from_target(CodegenTarget.AArch64)
            expect(triple.arch).to_equal("aarch64")
            expect(triple.to_text()).to_contain("aarch64")

    context "datalayout":
        it "contains correct aarch64 layout":
            val triple = LlvmTargetTriple__from_target(CodegenTarget.AArch64)
            val dl = triple.datalayout()
            expect(dl).to_contain("n32:64-S128")

        it "emits datalayout in module header":
            val triple = LlvmTargetTriple__from_target(CodegenTarget.AArch64)
            var builder = LlvmIRBuilder__create("test_aarch64", triple)
            builder.emit_module_header()
            val ir = builder.instructions.join("\n")
            expect(ir).to_contain("target datalayout")

    context "CPU defaults":
        it "defaults to cortex-a53":
            val config = LlvmTargetConfig__for_target(CodegenTarget.AArch64, nil)
            expect(config.cpu).to_equal("cortex-a53")

        it "includes neon feature":
            val config = LlvmTargetConfig__for_target(CodegenTarget.AArch64, nil)
            expect(config.features).to_contain("+neon")

        it "includes fp-armv8 feature":
            val config = LlvmTargetConfig__for_target(CodegenTarget.AArch64, nil)
            expect(config.features).to_contain("+fp-armv8")

    context "native integer type":
        it "native_int_type is i64":
            var translator = MirToLlvm__create("test", CodegenTarget.AArch64, nil)
            expect(translator.native_int()).to_equal("i64")

    context "type mapping":
        it "uses 64-bit target_bits":
            val mapper = LlvmTypeMapper__create_for_target(CodegenTarget.AArch64)
            expect(mapper.target_bits).to_equal(64)

    context "bare-metal entry":
        it "uses wfi instruction for halt":
            val halt = halt_instruction_for_target(CodegenTarget.AArch64)
            expect(halt).to_equal("wfi")

    context "builder size type":
        it "uses i64 size type":
            val triple = LlvmTargetTriple__from_target(CodegenTarget.AArch64)
            var builder = LlvmIRBuilder__create("test", triple)
            expect(builder.size_type).to_equal("i64")
