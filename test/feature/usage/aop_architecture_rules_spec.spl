"""
# AOP Architecture Rules Specification


**Feature IDs:** #AOP-ARCH-001 to #AOP-ARCH-010
**Category:** Language
**Status:** Implemented

Architecture rules enforce structural constraints on the codebase using the same
unified predicate grammar as AOP. Rules are validated at compile time and can
forbid or allow certain dependency patterns.

## Syntax

```simple
# Forbid pattern with error message
forbid pc{ import(from_pattern, to_pattern) } "Error message"
forbid pc{ depend(from_pattern, to_pattern) } "Error message"

# Allow pattern (exceptions)
allow pc{ depend(within(api.**), within(core.**)) } "Allowed exception"
```

## Architecture Selectors

| Selector | Description |
|----------|-------------|
| import(from, to) | Match import statements |
| depend(from, to) | Match module dependencies |
| use(pattern) | Match type/function usage |
| export(pattern) | Match exported symbols |
| config(string) | Match configuration values |
"""



# ============================================================================
# Test Group 1: Forbid Rules
# ============================================================================

describe "Architecture Forbid Rules":
    """
    ## Forbidding Dependencies

    The `forbid` keyword declares patterns that should cause compile errors
    if matched. Used to enforce architectural boundaries.
    """

    context "import rules":
        it "forbids importing test internals in production":
            # This rule prevents production code from importing test helpers
            forbid pc{ import(test.internal.*) } "Production code cannot import test internals"

            # Rule declared successfully
            expect true == true

        it "forbids importing implementation details":
            forbid pc{ import(*.internal.*) } "Cannot import internal modules directly"

            expect true == true

    context "dependency rules":
        it "forbids domain depending on infrastructure":
            # Classic clean architecture constraint
            forbid pc{ depend(within(domain.**), within(infrastructure.**)) } "Domain layer cannot depend on infrastructure"

            expect true == true

        it "forbids circular dependencies":
            forbid pc{ depend(within(module_a.**), within(module_b.**)) & depend(within(module_b.**), within(module_a.**)) } "Circular dependency detected"

            expect true == true

    context "usage rules":
        it "forbids using Container in domain":
            forbid pc{ use(Container) & within(domain.**) } "Domain should not use DI Container directly"

            expect true == true

        it "forbids using deprecated types":
            forbid pc{ use(LegacyService) } "LegacyService is deprecated, use NewService"

            expect true == true

    context "config rules":
        it "forbids test config in release":
            forbid pc{ config("profiles.test") & attr(release) } "Cannot use test profile in release build"

            expect true == true


# ============================================================================
# Test Group 2: Allow Rules
# ============================================================================

describe "Architecture Allow Rules":
    """
    ## Allowing Exceptions

    The `allow` keyword creates exceptions to forbid rules, enabling specific
    patterns that would otherwise be forbidden.
    """

    context "selective allows":
        it "allows api to depend on core":
            # First forbid broad dependency
            forbid pc{ depend(within(api.**), within(**)) } "API should not depend on anything"

            # Then allow specific exception
            allow pc{ depend(within(api.**), within(core.**)) } "API can depend on core"

            expect true == true

        it "allows test code to use internal modules":
            forbid pc{ import(*.internal.*) } "Cannot import internal modules"
            allow pc{ import(*.internal.*) & within(test.**) } "Tests can import internals"

            expect true == true

    context "priority-based overrides":
        it "allow with higher priority overrides forbid":
            # Rules are resolved by priority
            forbid pc{ use(DebugHelper) } "DebugHelper forbidden" # priority default: 0
            allow pc{ use(DebugHelper) & within(debug.**) } "Debug module can use DebugHelper" # priority: 10

            expect true == true


# ============================================================================
# Test Group 3: Layered Architecture
# ============================================================================

describe "Layered Architecture Constraints":
    """
    ## Clean/Onion Architecture Rules

    Common architectural patterns can be enforced with a set of forbid/allow
    rules that define layer boundaries.
    """

    context "three-layer architecture":
        it "defines presentation layer constraints":
            # Presentation can only depend on application layer
            forbid pc{ depend(within(presentation.**), within(domain.**)) } "Presentation cannot access domain directly"
            forbid pc{ depend(within(presentation.**), within(infrastructure.**)) } "Presentation cannot access infrastructure"
            allow pc{ depend(within(presentation.**), within(application.**)) } "Presentation depends on application"

            expect true == true

        it "defines application layer constraints":
            # Application can depend on domain
            forbid pc{ depend(within(application.**), within(infrastructure.**)) } "Application cannot depend on infrastructure"
            allow pc{ depend(within(application.**), within(domain.**)) } "Application depends on domain"

            expect true == true

        it "defines domain layer constraints":
            # Domain is the core, depends on nothing
            forbid pc{ depend(within(domain.**), within(application.**)) } "Domain cannot depend on application"
            forbid pc{ depend(within(domain.**), within(infrastructure.**)) } "Domain cannot depend on infrastructure"
            forbid pc{ depend(within(domain.**), within(presentation.**)) } "Domain cannot depend on presentation"

            expect true == true

    context "hexagonal architecture":
        it "enforces port-adapter boundaries":
            # Adapters implement ports, core doesn't know about adapters
            forbid pc{ depend(within(core.**), within(adapters.**)) } "Core cannot depend on adapters"
            forbid pc{ import(adapters.*.internal.*) } "Cannot import adapter internals"

            expect true == true


# ============================================================================
# Test Group 4: Module Boundaries
# ============================================================================

describe "Module Boundary Rules":
    """
    ## Encapsulation Enforcement

    Architecture rules can enforce module encapsulation by controlling
    what can be exported and imported.
    """

    context "internal modules":
        it "forbids importing internal submodules":
            forbid pc{ import(*.internal.*) } "Internal modules are not public API"

            expect true == true

        it "requires using public facade":
            # Force usage through public module
            forbid pc{ import(services.user.repository) } "Use services.user instead"
            allow pc{ import(services.user) } "Public facade allowed"

            expect true == true

    context "export restrictions":
        it "forbids exporting internal types":
            forbid pc{ export(*Internal) } "Types ending in Internal should not be exported"

            expect true == true


# ============================================================================
# Test Group 5: Security Constraints
# ============================================================================

describe "Security Architecture Rules":
    """
    ## Security-Related Constraints

    Architecture rules can enforce security patterns by restricting access
    to sensitive operations and data.
    """

    context "credential access":
        it "restricts credential usage":
            # Only auth module can access credentials
            forbid pc{ use(Credentials) & !within(auth.**) } "Only auth module can use Credentials"

            expect true == true

        it "forbids storing secrets in plain text":
            forbid pc{ use(PlainTextSecret) } "Use EncryptedSecret instead of PlainTextSecret"

            expect true == true

    context "network boundaries":
        it "restricts direct network access":
            forbid pc{ use(HttpClient) & within(domain.**) } "Domain should not make HTTP calls directly"

            expect true == true


# ============================================================================
# Test Group 6: Test Isolation
# ============================================================================

describe "Test Isolation Rules":
    """
    ## Test Code Boundaries

    Architecture rules ensure test code doesn't leak into production
    and production code doesn't depend on test utilities.
    """

    context "test-only code":
        it "forbids mock in production":
            forbid pc{ use(Mock*) & !within(test.**) } "Mocks can only be used in test code"

            expect true == true

        it "forbids test utilities in production":
            forbid pc{ import(test.helpers.*) & !within(test.**) } "Test helpers cannot be used in production"

            expect true == true

    context "test profile restrictions":
        it "forbids test profile in release":
            forbid pc{ config("profile.test") & attr(release) } "Cannot use test profile in release"

            expect true == true


# ============================================================================
# Test Group 7: Diagnostic Messages
# ============================================================================

describe "Architecture Rule Diagnostics":
    """
    ## Error Message Quality

    Architecture rules include descriptive error messages that help
    developers understand and fix violations.
    """

    context "violation messages":
        it "provides actionable error message":
            # Good error messages explain:
            # 1. What is forbidden
            # 2. Why it's forbidden
            # 3. What to do instead
            forbid pc{ use(OldApi) } "OldApi is deprecated since v2.0. Use NewApi.method() instead. See migration guide: /docs/migration/v2"

            expect true == true

        it "identifies violation location":
            # The compiler should report:
            # - File and line of violation
            # - The rule that was violated
            # - Suggested fix
            forbid pc{ depend(within(ui.**), within(db.**)) } "UI layer cannot access database directly. Inject a repository interface instead."

            expect true == true


# ============================================================================
# Test Group 8: Rule Composition
# ============================================================================

describe "Architecture Rule Composition":
    """
    ## Combining Rules

    Multiple architecture rules can be composed to express complex
    constraints using the same logical operators as pointcuts.
    """

    context "complex patterns":
        it "combines multiple conditions":
            forbid pc{ (depend(within(a.**), within(b.**)) | depend(within(a.**), within(c.**))) & !attr(allowed_dependency) } "Module A has restricted dependencies"

            expect true == true

        it "uses negation for exceptions":
            # Forbid everything except specific patterns
            forbid pc{ export(*) & !export(*Service) & !export(*Repository) & within(core.**) } "Core should only export Services and Repositories"

            expect true == true
