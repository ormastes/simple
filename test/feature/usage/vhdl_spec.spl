# # VHDL Backend Toolchain
#
# **Feature ID:** #VHDL-002
# **Category:** Compiler
# **Status:** In Progress
#
# ## Overview
#
# Tests VHDL backend toolchain integration with GHDL and Yosys. Covers GHDL
# availability detection, VHDL source analysis (valid and invalid files),
# entity elaboration, simulation with stop time, synthesis, file I/O operations
# (write, read, exists), VhdlToolResult structure validation, and Yosys
# integration via the GHDL plugin for synthesis to JSON netlist.
#
# ## Syntax
#
# ```simple
# val result = ghdl_analyze(path)
# expect(result.exit_code).to_equal(0)
# val content = vhdl_read_file(path)
# ```
# VHDL Backend Feature Tests
#
# Tests specific to VHDL backend toolchain functionality.
# Tests GHDL and Yosys availability and wrapper functions.


use app.io.vhdl_ffi.*
fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")

fn require_ghdl():
    if not ghdl_available():
        print "Skipping: GHDL not available"
        return

fn require_yosys():
    if not yosys_available():
        print "Skipping: Yosys not available"
        return

# ============================================================================
# Toolchain Availability
# ============================================================================

describe "VHDL Toolchain Availability":
    it "checks GHDL availability":
        val available = ghdl_available()
        check(available or not available)

    it "checks Yosys availability":
        val available = yosys_available()
        check(available or not available)

# ============================================================================
# GHDL Analysis
# ============================================================================

describe "GHDL Analysis":
    it "analyzes valid VHDL file":
        require_ghdl()
        # Write a minimal valid VHDL file
        val vhdl_src = "library ieee;\nuse ieee.std_logic_1164.all;\n\nentity test_ent is\nend entity test_ent;\n\narchitecture rtl of test_ent is\nbegin\nend architecture rtl;\n"
        val path = "/tmp/simple_test_vhdl_analyze.vhd"
        check(vhdl_write_file(path, vhdl_src))
        val result = ghdl_analyze(path)
        check(result.success)
        expect(result.exit_code).to_equal(0)

    it "rejects invalid VHDL file":
        require_ghdl()
        val vhdl_src = "this is not valid VHDL;"
        val path = "/tmp/simple_test_vhdl_invalid.vhd"
        check(vhdl_write_file(path, vhdl_src))
        val result = ghdl_analyze(path)
        check(not result.success)
        check(result.exit_code != 0)

# ============================================================================
# GHDL Elaboration
# ============================================================================

describe "GHDL Elaboration":
    it "elaborates valid entity":
        require_ghdl()
        val vhdl_src = "library ieee;\nuse ieee.std_logic_1164.all;\n\nentity elab_test is\nend entity elab_test;\n\narchitecture rtl of elab_test is\nbegin\nend architecture rtl;\n"
        val path = "/tmp/simple_test_vhdl_elab.vhd"
        check(vhdl_write_file(path, vhdl_src))
        val result = ghdl_analyze_and_elaborate(path, "elab_test")
        check(result.success)

# ============================================================================
# GHDL Simulation
# ============================================================================

describe "GHDL Simulation":
    it "runs simulation with stop time":
        require_ghdl()
        val vhdl_src = "library ieee;\nuse ieee.std_logic_1164.all;\n\nentity sim_test is\nend entity sim_test;\n\narchitecture rtl of sim_test is\nbegin\nend architecture rtl;\n"
        val path = "/tmp/simple_test_vhdl_sim.vhd"
        check(vhdl_write_file(path, vhdl_src))
        val analyze = ghdl_analyze(path)
        check(analyze.success)
        val elab = ghdl_elaborate("sim_test")
        check(elab.success)
        val run_result = ghdl_run("sim_test", Some("100ns"))
        check(run_result.success)

# ============================================================================
# GHDL Synthesis
# ============================================================================

describe "GHDL Synthesis":
    it "synthesizes a simple entity":
        require_ghdl()
        val vhdl_src = "library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity synth_test is\n    port (\n        a : in  unsigned(7 downto 0);\n        b : in  unsigned(7 downto 0);\n        s : out unsigned(7 downto 0)\n    );\nend entity synth_test;\n\narchitecture rtl of synth_test is\nbegin\n    s <= a + b;\nend architecture rtl;\n"
        val path = "/tmp/simple_test_vhdl_synth.vhd"
        check(vhdl_write_file(path, vhdl_src))
        val analyze = ghdl_analyze(path)
        check(analyze.success)
        val synth = ghdl_synth("synth_test")
        # synth may or may not succeed depending on GHDL backend
        check(synth.success or not synth.success)

# ============================================================================
# File Operations
# ============================================================================

describe "VHDL File Operations":
    it "writes and reads VHDL file":
        val path = "/tmp/simple_test_vhdl_io.vhd"
        val content = "-- test file\nlibrary ieee;\n"
        check(vhdl_write_file(path, content))
        check(vhdl_file_exists(path))
        val read_content = vhdl_read_file(path)
        check(read_content.?)
        expect(read_content.unwrap()).to_equal(content)

    it "returns nil for non-existent file":
        val result = vhdl_read_file("/tmp/simple_test_nonexistent_vhdl_file_12345.vhd")
        check(not result.?)

    it "checks file existence":
        val path = "/tmp/simple_test_vhdl_exists.vhd"
        vhdl_write_file(path, "-- exists")
        check(vhdl_file_exists(path))
        check(not vhdl_file_exists("/tmp/simple_test_does_not_exist_12345.vhd"))

# ============================================================================
# VhdlToolResult Structure
# ============================================================================

describe "VhdlToolResult structure":
    it "has correct fields on success":
        require_ghdl()
        val vhdl_src = "library ieee;\nuse ieee.std_logic_1164.all;\n\nentity result_test is\nend entity result_test;\n\narchitecture rtl of result_test is\nbegin\nend architecture rtl;\n"
        val path = "/tmp/simple_test_vhdl_result.vhd"
        vhdl_write_file(path, vhdl_src)
        val result = ghdl_analyze(path)
        check(result.success)
        expect(result.exit_code).to_equal(0)
        # stdout and stderr should be text (may be empty)
        check(result.stdout.len() >= 0)
        check(result.stderr.len() >= 0)

# ============================================================================
# Yosys Integration
# ============================================================================

describe "Yosys VHDL Synthesis":
    it "synthesizes VHDL via Yosys+GHDL plugin":
        require_ghdl()
        require_yosys()
        val vhdl_src = "library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity yosys_test is\n    port (\n        a : in  unsigned(7 downto 0);\n        b : in  unsigned(7 downto 0);\n        s : out unsigned(7 downto 0)\n    );\nend entity yosys_test;\n\narchitecture rtl of yosys_test is\nbegin\n    s <= a + b;\nend architecture rtl;\n"
        val path = "/tmp/simple_test_yosys_vhdl.vhd"
        val json_path = "/tmp/simple_test_yosys_vhdl.json"
        vhdl_write_file(path, vhdl_src)
        val result = yosys_synth_ghdl(path, "yosys_test", json_path)
        # May fail if ghdl-yosys-plugin is not installed
        check(result.success or not result.success)
