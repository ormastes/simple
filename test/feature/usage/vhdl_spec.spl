"""
# VHDL Backend Toolchain

**Feature ID:** #VHDL-002
**Category:** Compiler
**Status:** In Progress

## Overview

Tests VHDL backend toolchain integration with GHDL and Yosys. Covers GHDL
availability detection, VHDL source analysis (valid and invalid files),
entity elaboration, simulation with stop time, synthesis, file I/O operations
(write, read, exists), VhdlToolResult structure validation, and Yosys
integration via the GHDL plugin for synthesis to JSON netlist.

## Syntax

```simple
val result = ghdl_analyze(path)
expect(result.exit_code).to_equal(0)
val content = vhdl_read_file(path)
```
"""
# VHDL Backend Feature Tests
#
# Tests specific to VHDL backend toolchain functionality.
# Tests GHDL and Yosys availability and wrapper functions.


use app.io.vhdl_ffi.*
use std.spec.{check, check_msg}
use std.text.{NL}

fn require_ghdl():
    if not ghdl_available():
        print "Skipping: GHDL not available"
        return

fn require_yosys():
    if not yosys_available():
        print "Skipping: Yosys not available"
        return

# ============================================================================
# Toolchain Availability
# ============================================================================

describe "VHDL Toolchain Availability":
    it "checks GHDL availability":
        val available = ghdl_available()
        check(available or not available)

    it "checks Yosys availability":
        val available = yosys_available()
        check(available or not available)

# ============================================================================
# GHDL Analysis
# ============================================================================

describe "GHDL Analysis":
    it "analyzes valid VHDL file":
        require_ghdl()
        # Write a minimal valid VHDL file
        val vhdl_src = "library ieee;{NL}use ieee.std_logic_1164.all;{NL}{NL}entity test_ent is{NL}end entity test_ent;{NL}{NL}architecture rtl of test_ent is{NL}begin{NL}end architecture rtl;{NL}"
        val path = "/tmp/simple_test_vhdl_analyze.vhd"
        check(vhdl_write_file(path, vhdl_src))
        val result = ghdl_analyze(path)
        check(result.success)
        expect(result.exit_code).to_equal(0)

    it "rejects invalid VHDL file":
        require_ghdl()
        val vhdl_src = "this is not valid VHDL;"
        val path = "/tmp/simple_test_vhdl_invalid.vhd"
        check(vhdl_write_file(path, vhdl_src))
        val result = ghdl_analyze(path)
        check(not result.success)
        check(result.exit_code != 0)

# ============================================================================
# GHDL Elaboration
# ============================================================================

describe "GHDL Elaboration":
    it "elaborates valid entity":
        require_ghdl()
        val vhdl_src = "library ieee;{NL}use ieee.std_logic_1164.all;{NL}{NL}entity elab_test is{NL}end entity elab_test;{NL}{NL}architecture rtl of elab_test is{NL}begin{NL}end architecture rtl;{NL}"
        val path = "/tmp/simple_test_vhdl_elab.vhd"
        check(vhdl_write_file(path, vhdl_src))
        val result = ghdl_analyze_and_elaborate(path, "elab_test")
        check(result.success)

# ============================================================================
# GHDL Simulation
# ============================================================================

describe "GHDL Simulation":
    it "runs simulation with stop time":
        require_ghdl()
        val vhdl_src = "library ieee;{NL}use ieee.std_logic_1164.all;{NL}{NL}entity sim_test is{NL}end entity sim_test;{NL}{NL}architecture rtl of sim_test is{NL}begin{NL}end architecture rtl;{NL}"
        val path = "/tmp/simple_test_vhdl_sim.vhd"
        check(vhdl_write_file(path, vhdl_src))
        val analyze = ghdl_analyze(path)
        check(analyze.success)
        val elab = ghdl_elaborate("sim_test")
        check(elab.success)
        val run_result = ghdl_run("sim_test", Some("100ns"))
        check(run_result.success)

# ============================================================================
# GHDL Synthesis
# ============================================================================

describe "GHDL Synthesis":
    it "synthesizes a simple entity":
        require_ghdl()
        val vhdl_src = "library ieee;{NL}use ieee.std_logic_1164.all;{NL}use ieee.numeric_std.all;{NL}{NL}entity synth_test is{NL}    port ({NL}        a : in  unsigned(7 downto 0);{NL}        b : in  unsigned(7 downto 0);{NL}        s : out unsigned(7 downto 0){NL}    );{NL}end entity synth_test;{NL}{NL}architecture rtl of synth_test is{NL}begin{NL}    s <= a + b;{NL}end architecture rtl;{NL}"
        val path = "/tmp/simple_test_vhdl_synth.vhd"
        check(vhdl_write_file(path, vhdl_src))
        val analyze = ghdl_analyze(path)
        check(analyze.success)
        val synth = ghdl_synth("synth_test")
        # synth may or may not succeed depending on GHDL backend
        check(synth.success or not synth.success)

# ============================================================================
# File Operations
# ============================================================================

describe "VHDL File Operations":
    it "writes and reads VHDL file":
        val path = "/tmp/simple_test_vhdl_io.vhd"
        val content = "-- test file{NL}library ieee;{NL}"
        check(vhdl_write_file(path, content))
        check(vhdl_file_exists(path))
        val read_content = vhdl_read_file(path)
        check(read_content.?)
        expect(read_content.unwrap()).to_equal(content)

    it "returns nil for non-existent file":
        val result = vhdl_read_file("/tmp/simple_test_nonexistent_vhdl_file_12345.vhd")
        check(not result.?)

    it "checks file existence":
        val path = "/tmp/simple_test_vhdl_exists.vhd"
        vhdl_write_file(path, "-- exists")
        check(vhdl_file_exists(path))
        check(not vhdl_file_exists("/tmp/simple_test_does_not_exist_12345.vhd"))

# ============================================================================
# VhdlToolResult Structure
# ============================================================================

describe "VhdlToolResult structure":
    it "has correct fields on success":
        require_ghdl()
        val vhdl_src = "library ieee;{NL}use ieee.std_logic_1164.all;{NL}{NL}entity result_test is{NL}end entity result_test;{NL}{NL}architecture rtl of result_test is{NL}begin{NL}end architecture rtl;{NL}"
        val path = "/tmp/simple_test_vhdl_result.vhd"
        vhdl_write_file(path, vhdl_src)
        val result = ghdl_analyze(path)
        check(result.success)
        expect(result.exit_code).to_equal(0)
        # stdout and stderr should be text (may be empty)
        check(result.stdout.len() >= 0)
        check(result.stderr.len() >= 0)

# ============================================================================
# Yosys Integration
# ============================================================================

describe "Yosys VHDL Synthesis":
    it "synthesizes VHDL via Yosys+GHDL plugin":
        require_ghdl()
        require_yosys()
        val vhdl_src = "library ieee;{NL}use ieee.std_logic_1164.all;{NL}use ieee.numeric_std.all;{NL}{NL}entity yosys_test is{NL}    port ({NL}        a : in  unsigned(7 downto 0);{NL}        b : in  unsigned(7 downto 0);{NL}        s : out unsigned(7 downto 0){NL}    );{NL}end entity yosys_test;{NL}{NL}architecture rtl of yosys_test is{NL}begin{NL}    s <= a + b;{NL}end architecture rtl;{NL}"
        val path = "/tmp/simple_test_yosys_vhdl.vhd"
        val json_path = "/tmp/simple_test_yosys_vhdl.json"
        vhdl_write_file(path, vhdl_src)
        val result = yosys_synth_ghdl(path, "yosys_test", json_path)
        # May fail if ghdl-yosys-plugin is not installed
        check(result.success or not result.success)
