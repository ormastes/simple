# # Multi-Architecture Support
#
# **Feature ID:** #ARCH-002
# **Category:** Compiler
# **Status:** In Progress
#
# ## Overview
#
# Tests multi-architecture support across 8-bit, 16-bit, 32-bit, and 64-bit targets
# including AVR, MCS51, MSP430, x86, ARM, RISC-V, x86_64, and AArch64. Validates
# architecture properties (pointer size, stack alignment, FPU, endianness),
# target triple generation for bare-metal and hosted environments, and
# TargetConfig generation for each bit-width class.
#
# ## Syntax
#
# ```simple
# val avr = TargetArch.AVR
# expect(avr.bits()).to_equal(8)
# val config = TargetConfig__for_arch(TargetArch.X86_64)
# ```
# Architecture Support Specification
#
# Tests multi-architecture support (8/16/32/64-bit) including:
# - Target architecture properties
# - Pointer-sized types (usize/isize)
# - Calling conventions
# - Type layout per architecture
#
# Feature IDs: #BM-ARCH-001
# Category: Bare-Metal
# Status: In Progress
#
# NOTE: parse tests use parse_target_arch() free function wrapper
# instead of TargetArch__parse() static method (not supported in interpreter)

use std.common.target.{TargetArch, PointerSize, Endian, TargetConfig, parse_target_arch}

describe "Target Architecture":
    describe "8-bit Architectures":
        it "AVR has correct properties":
            val avr = TargetArch.AVR
            expect(avr.bits()).to_equal(8)
            expect(avr.pointer_bytes()).to_equal(2)
            expect(avr.stack_align()).to_equal(1)
            expect(avr.max_atomic_width()).to_equal(8)
            expect(avr.has_fpu()).to_equal(false)
            expect(avr.is_harvard()).to_equal(true)
            expect(avr.endianness()).to_equal(Endian.Little)

        it "MCS51 has correct properties":
            val mcs51 = TargetArch.MCS51
            expect(mcs51.bits()).to_equal(8)
            expect(mcs51.pointer_bytes()).to_equal(2)
            expect(mcs51.stack_align()).to_equal(1)
            expect(mcs51.has_fpu()).to_equal(false)
            expect(mcs51.is_harvard()).to_equal(true)
            expect(mcs51.endianness()).to_equal(Endian.Big)

        it "AVR parses from string":
            val parsed = parse_target_arch("avr")
            expect(parsed.?).to_equal(true)
            expect(parsed.unwrap()).to_equal(TargetArch.AVR)

            val parsed2 = parse_target_arch("atmega")
            expect(parsed2.?).to_equal(true)
            expect(parsed2.unwrap()).to_equal(TargetArch.AVR)

    describe "16-bit Architectures":
        it "MSP430 has correct properties":
            val msp = TargetArch.MSP430
            expect(msp.bits()).to_equal(16)
            expect(msp.pointer_bytes()).to_equal(2)
            expect(msp.stack_align()).to_equal(2)
            expect(msp.max_atomic_width()).to_equal(16)
            expect(msp.has_fpu()).to_equal(false)
            expect(msp.is_harvard()).to_equal(false)
            expect(msp.endianness()).to_equal(Endian.Little)

        it "MSP430 parses from string":
            val parsed = parse_target_arch("msp430")
            expect(parsed.?).to_equal(true)
            expect(parsed.unwrap()).to_equal(TargetArch.MSP430)

    describe "32-bit Architectures":
        it "x86 has correct properties":
            val x86 = TargetArch.X86
            expect(x86.bits()).to_equal(32)
            expect(x86.pointer_bytes()).to_equal(4)
            expect(x86.stack_align()).to_equal(4)
            expect(x86.max_atomic_width()).to_equal(64)
            expect(x86.has_fpu()).to_equal(true)
            expect(x86.is_harvard()).to_equal(false)

        it "ARM has correct properties":
            val arm = TargetArch.Arm
            expect(arm.bits()).to_equal(32)
            expect(arm.pointer_bytes()).to_equal(4)
            expect(arm.stack_align()).to_equal(4)
            expect(arm.has_fpu()).to_equal(false)  # Cortex-M0/M3

        it "RISC-V 32 has correct properties":
            val rv32 = TargetArch.Riscv32
            expect(rv32.bits()).to_equal(32)
            expect(rv32.pointer_bytes()).to_equal(4)

    describe "64-bit Architectures":
        it "x86_64 has correct properties":
            val x64 = TargetArch.X86_64
            expect(x64.bits()).to_equal(64)
            expect(x64.pointer_bytes()).to_equal(8)
            expect(x64.stack_align()).to_equal(16)
            expect(x64.max_atomic_width()).to_equal(128)
            expect(x64.has_fpu()).to_equal(true)

        it "AArch64 has correct properties":
            val arm64 = TargetArch.Aarch64
            expect(arm64.bits()).to_equal(64)
            expect(arm64.pointer_bytes()).to_equal(8)
            expect(arm64.stack_align()).to_equal(16)

        it "RISC-V 64 has correct properties":
            val rv64 = TargetArch.Riscv64
            expect(rv64.bits()).to_equal(64)
            expect(rv64.pointer_bytes()).to_equal(8)

describe "Pointer Size":
    it "8-bit and 16-bit use 16-bit pointers":
        expect(TargetArch.AVR__pointer_size()).to_equal(PointerSize.Bits16)
        expect(TargetArch.MCS51__pointer_size()).to_equal(PointerSize.Bits16)
        expect(TargetArch.MSP430__pointer_size()).to_equal(PointerSize.Bits16)

    it "32-bit uses 32-bit pointers":
        expect(TargetArch.X86__pointer_size()).to_equal(PointerSize.Bits32)
        expect(TargetArch.Arm__pointer_size()).to_equal(PointerSize.Bits32)
        expect(TargetArch.Riscv32__pointer_size()).to_equal(PointerSize.Bits32)

    it "64-bit uses 64-bit pointers":
        expect(TargetArch.X86_64__pointer_size()).to_equal(PointerSize.Bits64)
        expect(TargetArch.Aarch64__pointer_size()).to_equal(PointerSize.Bits64)
        expect(TargetArch.Riscv64__pointer_size()).to_equal(PointerSize.Bits64)

    it "PointerSize returns correct byte count":
        expect(PointerSize.Bits16__bytes()).to_equal(2)
        expect(PointerSize.Bits32__bytes()).to_equal(4)
        expect(PointerSize.Bits64__bytes()).to_equal(8)

describe "Target Triple":
    it "generates correct bare-metal triples":
        expect(TargetArch.AVR__triple_str_baremetal()).to_equal("avr-unknown-unknown")
        expect(TargetArch.MSP430__triple_str_baremetal()).to_equal("msp430-none-elf")
        expect(TargetArch.X86__triple_str_baremetal()).to_equal("i686-unknown-none")
        expect(TargetArch.Arm__triple_str_baremetal()).to_equal("thumbv7m-none-eabi")
        expect(TargetArch.X86_64__triple_str_baremetal()).to_equal("x86_64-unknown-none")

    it "generates correct hosted triples":
        expect(TargetArch.X86__triple_str()).to_equal("i686-unknown-linux-gnu")
        expect(TargetArch.X86_64__triple_str()).to_equal("x86_64-unknown-linux-gnu")
        expect(TargetArch.Arm__triple_str()).to_equal("armv7-unknown-linux-gnueabihf")

describe "Target Config":
    it "configures 8-bit correctly":
        val config = TargetConfig__for_arch(TargetArch.AVR)
        expect(config.pointer_bytes).to_equal(2)
        expect(config.value_bytes).to_equal(2)
        expect(config.tag_bits).to_equal(0)
        expect(config.heap_align).to_equal(1)
        expect(config.default_stack_size).to_equal(256)

    it "configures 16-bit correctly":
        val config = TargetConfig__for_arch(TargetArch.MSP430)
        expect(config.pointer_bytes).to_equal(2)
        expect(config.value_bytes).to_equal(2)
        expect(config.tag_bits).to_equal(1)
        expect(config.heap_align).to_equal(2)
        expect(config.default_stack_size).to_equal(512)

    it "configures 32-bit correctly":
        val config = TargetConfig__for_arch(TargetArch.X86)
        expect(config.pointer_bytes).to_equal(4)
        expect(config.value_bytes).to_equal(8)
        expect(config.tag_bits).to_equal(2)
        expect(config.heap_align).to_equal(4)

    it "configures 64-bit correctly":
        val config = TargetConfig__for_arch(TargetArch.X86_64)
        expect(config.pointer_bytes).to_equal(8)
        expect(config.value_bytes).to_equal(8)
        expect(config.tag_bits).to_equal(3)
        expect(config.heap_align).to_equal(8)

describe "Architecture Bit Width Helpers":
    it "is_8bit returns true for 8-bit":
        expect(TargetArch.AVR__is_8bit()).to_equal(true)
        expect(TargetArch.MCS51__is_8bit()).to_equal(true)
        expect(TargetArch.X86__is_8bit()).to_equal(false)

    it "is_16bit returns true for 16-bit":
        expect(TargetArch.MSP430__is_16bit()).to_equal(true)
        expect(TargetArch.AVR__is_16bit()).to_equal(false)

    it "is_32bit returns true for 32-bit":
        expect(TargetArch.X86__is_32bit()).to_equal(true)
        expect(TargetArch.Arm__is_32bit()).to_equal(true)
        expect(TargetArch.X86_64__is_32bit()).to_equal(false)

    it "is_64bit returns true for 64-bit":
        expect(TargetArch.X86_64__is_64bit()).to_equal(true)
        expect(TargetArch.Aarch64__is_64bit()).to_equal(true)
        expect(TargetArch.X86__is_64bit()).to_equal(false)

describe "Endianness":
    it "most architectures are little-endian":
        expect(TargetArch.AVR__endianness()).to_equal(Endian.Little)
        expect(TargetArch.MSP430__endianness()).to_equal(Endian.Little)
        expect(TargetArch.X86__endianness()).to_equal(Endian.Little)
        expect(TargetArch.X86_64__endianness()).to_equal(Endian.Little)

    it "MCS51 is big-endian":
        expect(TargetArch.MCS51__endianness()).to_equal(Endian.Big)
