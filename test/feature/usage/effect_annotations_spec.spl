# # Effect Annotations Specification
#
#
# **Feature IDs:** #EFFECT-ANN-001 to #EFFECT-ANN-012
# **Category:** Type System | Effects
# **Status:** Implemented
#
# Tests that effect annotations (@pure, @io, @net, @fs, @unsafe, @async)
# are correctly parsed and applied to functions.
#
# ## Effect Types
#
# - `@pure` - No side effects, referentially transparent
# - `@io` - Console/terminal I/O operations
# - `@net` - Network operations
# - `@fs` - File system operations
# - `@unsafe` - Unsafe memory operations
# - `@async` - Asynchronous operations
#
# ## Syntax
#
# ```simple
# @pure
# fn add(x: i64, y: i64) -> i64:
# x + y
#
# @io @net
# fn fetch_and_log(url: str):
# val data = http_get(url)
# print(data)
# ```

use std.effects.{Effect}


# ============================================================================
# Test Group 1: Single Effect Annotations
# ============================================================================

describe "Single Effect Annotations":
    # ## Basic Effect Decorators
    #
    # Tests that single effect decorators are correctly parsed.

    context "@pure effect":
        it "parses @pure on function":
            @pure
            fn add(x: i64, y: i64) -> i64:
                x + y
            expect add(20, 22) == 42

        it "pure function has no side effects":
            @pure
            fn double(x: i64) -> i64:
                x * 2
            expect double(21) == 42

    context "@io effect":
        it "parses @io on function":
            @io
            fn print_hello():
                print("Hello, World!")
            expect true  # Parsed successfully

    context "@net effect":
        it "parses @net on function":
            @net
            fn fetch(url: str) -> str:
                "mock response"  # Placeholder
            expect true

    context "@fs effect":
        it "parses @fs on function":
            @fs
            fn read_file(path: str) -> str:
                "file contents"  # Placeholder
            expect true

    context "@unsafe effect":
        it "parses @unsafe on function":
            @unsafe
            fn raw_cast(ptr: i64) -> i64:
                ptr
            expect true

    context "@async effect":
        it "parses @async on function":
            @async
            fn delayed_task():
                pass
            expect true


# ============================================================================
# Test Group 2: Multiple Effect Annotations
# ============================================================================

describe "Multiple Effect Annotations":
    # ## Combined Effects
    #
    # Tests that multiple effect decorators can be applied.

    it "parses two effects":
        @io
        @net
        fn fetch_and_log(url: str):
            val data = "mock"
            print(data)
        expect true

    it "parses three effects":
        @io
        @net
        @fs
        fn sync_remote_file(url: str, path: str):
            val data = "mock"
            print("Synced!")
        expect true

    it "parses io and fs together":
        @io
        @fs
        fn log_to_file(path: str, message: str):
            print("Logging: {message}")
        expect true


# ============================================================================
# Test Group 3: No Effects
# ============================================================================

describe "Functions Without Effects":
    # ## Unrestricted Functions
    #
    # Tests that functions without effect annotations are unrestricted.

    it "function with no effects parses":
        fn unrestricted_function():
            print("Can do anything!")
        expect true

    it "no-effect function can call anything":
        fn flexible():
            val x = 42
            x
        expect flexible() == 42


# ============================================================================
# Test Group 4: Effects with Other Decorators
# ============================================================================

describe "Effects with Other Decorators":
    # ## Mixed Decorator Usage
    #
    # Tests effects combined with non-effect decorators.

    it "combines @pure with @inline":
        @pure
        @inline
        fn fast_add(x: i64, y: i64) -> i64:
            x + y
        expect fast_add(20, 22) == 42

    it "combines @io with @deprecated":
        @io
        @deprecated
        fn old_print(msg: str):
            print(msg)
        expect true

    it "effects separate from other decorators":
        @pure
        @memoize
        fn cached_compute(x: i64) -> i64:
            x * x
        expect cached_compute(6) == 36


# ============================================================================
# Test Group 5: Effect Enum Values
# ============================================================================

describe "Effect Enum":
    # ## Effect Type System
    #
    # Tests the Effect enum values.

    it "Effect has Pure variant":
        val e = Effect.Pure
        expect e == Effect.Pure

    it "Effect has Io variant":
        val e = Effect.Io
        expect e == Effect.Io

    it "Effect has Net variant":
        val e = Effect.Net
        expect e == Effect.Net

    it "Effect has Fs variant":
        val e = Effect.Fs
        expect e == Effect.Fs

    it "Effect has Unsafe variant":
        val e = Effect.Unsafe
        expect e == Effect.Unsafe

    it "Effect has Async variant":
        val e = Effect.Async
        expect e == Effect.Async


# ============================================================================
# Test Group 6: Effect from Decorator Name
# ============================================================================

describe "Effect from Decorator Name":
    # ## String to Effect Conversion
    #
    # Tests converting decorator names to Effect values.

    it "converts 'pure' to Pure":
        val e = Effect.from_decorator_name("pure")
        expect e == Some(Effect.Pure)

    it "converts 'io' to Io":
        val e = Effect.from_decorator_name("io")
        expect e == Some(Effect.Io)

    it "converts 'net' to Net":
        val e = Effect.from_decorator_name("net")
        expect e == Some(Effect.Net)

    it "converts 'fs' to Fs":
        val e = Effect.from_decorator_name("fs")
        expect e == Some(Effect.Fs)

    it "converts 'unsafe' to Unsafe":
        val e = Effect.from_decorator_name("unsafe")
        expect e == Some(Effect.Unsafe)

    it "converts 'async' to Async":
        val e = Effect.from_decorator_name("async")
        expect e == Some(Effect.Async)

    it "returns None for unknown":
        val e = Effect.from_decorator_name("unknown")
        expect not e.?

    it "returns None for inline":
        val e = Effect.from_decorator_name("inline")
        expect not e.?


# ============================================================================
# Test Group 7: Effect Decorator Name
# ============================================================================

describe "Effect Decorator Name":
    # ## Effect to String Conversion
    #
    # Tests converting Effect values to decorator names.

    it "Pure decorator name is 'pure'":
        expect Effect.Pure.decorator_name() == "pure"

    it "Io decorator name is 'io'":
        expect Effect.Io.decorator_name() == "io"

    it "Net decorator name is 'net'":
        expect Effect.Net.decorator_name() == "net"

    it "Fs decorator name is 'fs'":
        expect Effect.Fs.decorator_name() == "fs"

    it "Unsafe decorator name is 'unsafe'":
        expect Effect.Unsafe.decorator_name() == "unsafe"

    it "Async decorator name is 'async'":
        expect Effect.Async.decorator_name() == "async"

