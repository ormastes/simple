"""
# Architecture Check Error Cases

**Feature ID:** #ARCH-001
**Category:** Tooling
**Status:** Active

## Overview

Tests failure paths and edge cases in the architecture validation system.
Covers boundary conditions for string trimming, pattern list parsing,
import pattern matching with glob-style wildcards, allow/deny rule evaluation,
import statement extraction from source content, and module path resolution.

## Syntax

```simple
val result = _match_pattern("core/lexer", "core/*")
val allowed = _is_import_allowed("core/ast", rule)
```
"""
# Arch Check Error Cases - Negative/Edge Path Tests
#
# Tests failure paths and edge cases in architecture validation:
# - empty/degenerate inputs to pattern matching
# - pattern boundary conditions
# - import parsing edge cases
# - rule evaluation with empty allow/deny lists
#
# Feature: 8 (Architecture Validation)
# Source: src/app/cli/arch_check.spl

use app.cli.arch_check (
    _str_trim, _parse_pattern_list, _parse_arch_block,
    _match_pattern, _is_import_allowed,
    _parse_imports_from_content,
    _module_path_from_init_file,
    _file_is_under_module,
    ArchRule, FileImports, ArchViolation
)

# ============================================================================
# _str_trim edge cases
# ============================================================================

describe "Arch Check Error Cases: _str_trim edge cases":

    it "handles already-trimmed string unchanged":
        expect(_str_trim("clean")).to_equal("clean")

    it "handles empty string":
        expect(_str_trim("")).to_equal("")

    it "handles string of only spaces":
        expect(_str_trim("   ")).to_equal("")

    it "handles string of only tabs":
        expect(_str_trim("\t\t")).to_equal("")

    it "handles single character":
        expect(_str_trim("x")).to_equal("x")

    it "handles string with tab and spaces":
        expect(_str_trim("\t  hello  \t")).to_equal("hello")

# ============================================================================
# _parse_pattern_list edge cases
# ============================================================================

describe "Arch Check Error Cases: _parse_pattern_list edge cases":

    it "returns empty list for empty brackets":
        val result = _parse_pattern_list("allow = []")
        expect(result.len()).to_equal(0)

    it "returns empty list for missing brackets":
        val result = _parse_pattern_list("allow = core")
        expect(result.len()).to_equal(0)

    it "returns empty list for empty input string":
        val result = _parse_pattern_list("")
        expect(result.len()).to_equal(0)

    it "parses single quoted pattern":
        val result = _parse_pattern_list("allow = ['core/**']")
        expect(result.len()).to_equal(1)
        expect(result[0]).to_equal("core/**")

    it "parses single item with double quotes":
        val result = _parse_pattern_list("allow = [\"core/**\"]")
        expect(result.len()).to_equal(1)
        expect(result[0]).to_equal("core/**")

    it "ignores whitespace around patterns":
        val result = _parse_pattern_list("deny = [ \"compiler/**\" ]")
        expect(result.len()).to_equal(1)
        expect(result[0]).to_equal("compiler/**")

# ============================================================================
# _match_pattern edge cases
# ============================================================================

describe "Arch Check Error Cases: _match_pattern edge cases":

    it "empty pattern does not match non-empty import":
        val result = _match_pattern("core/lexer", "")
        expect(result).to_equal(false)

    it "empty import does not match non-empty pattern":
        val result = _match_pattern("", "core/lexer")
        expect(result).to_equal(false)

    it "empty import matches empty pattern exactly":
        val result = _match_pattern("", "")
        expect(result).to_equal(true)

    it "/** suffix matches any subpath of prefix":
        val result = _match_pattern("a/b/c", "a/**")
        expect(result).to_equal(true)

    it "pattern exact does not match import with extra segment":
        val result = _match_pattern("core/lexer/extra", "core/lexer")
        expect(result).to_equal(true)

    it "/* does not match two levels deep":
        val result = _match_pattern("core/lexer/submodule", "core/*")
        expect(result).to_equal(false)

    it "/* matches single level sub-path":
        val result = _match_pattern("core/lexer", "core/*")
        expect(result).to_equal(true)

    it "prefix match requires slash boundary":
        val result = _match_pattern("compiler_other/ast", "compiler")
        expect(result).to_equal(false)

    it "exact match succeeds for identical strings":
        val result = _match_pattern("std/text", "std/text")
        expect(result).to_equal(true)

    it "pattern with /** matches direct child":
        val result = _match_pattern("core/ast", "core/**")
        expect(result).to_equal(true)

# ============================================================================
# _is_import_allowed edge cases
# ============================================================================

describe "Arch Check Error Cases: _is_import_allowed edge cases":

    it "import allowed when both allow and deny lists are empty":
        val rule = ArchRule(
            init_file: "src/__init__.spl",
            module_path: "src",
            allow_patterns: [],
            deny_patterns: []
        )
        expect(_is_import_allowed("any/import", rule)).to_equal(true)

    it "import denied when not in non-empty allow list":
        val rule = ArchRule(
            init_file: "src/__init__.spl",
            module_path: "src",
            allow_patterns: ["core/**"],
            deny_patterns: []
        )
        expect(_is_import_allowed("compiler/backend", rule)).to_equal(false)

    it "import allowed when in allow list and deny list is empty":
        val rule = ArchRule(
            init_file: "src/__init__.spl",
            module_path: "src",
            allow_patterns: ["core/**"],
            deny_patterns: []
        )
        expect(_is_import_allowed("core/ast", rule)).to_equal(true)

    it "import denied when matched by deny pattern even if in allow list":
        val rule = ArchRule(
            init_file: "src/__init__.spl",
            module_path: "src",
            allow_patterns: ["core/**"],
            deny_patterns: ["core/compiler/**"]
        )
        expect(_is_import_allowed("core/compiler/backend", rule)).to_equal(false)

    it "import allowed when in allow but not in deny":
        val rule = ArchRule(
            init_file: "src/__init__.spl",
            module_path: "src",
            allow_patterns: ["core/**"],
            deny_patterns: ["core/compiler/**"]
        )
        expect(_is_import_allowed("core/ast", rule)).to_equal(true)

# ============================================================================
# _parse_imports_from_content edge cases
# ============================================================================

describe "Arch Check Error Cases: _parse_imports_from_content edge cases":

    it "returns empty list for empty content":
        val result = _parse_imports_from_content("")
        expect(result.len()).to_equal(0)

    it "returns empty list for content with no use statements":
        val content = "fn main():\n    print \"hello\"\n"
        val result = _parse_imports_from_content(content)
        expect(result.len()).to_equal(0)

    it "ignores comment lines starting with #":
        val content = "# use app.io.mod (file_read)\nfn foo(): ()\n"
        val result = _parse_imports_from_content(content)
        expect(result.len()).to_equal(0)

    it "strips trailing dot from module path":
        val content = "use std.text. ("\n")\n"
        val result = _parse_imports_from_content(content)
        expect(result.len()).to_equal(1)
        expect(result[0]).to_equal("std/text")

    it "converts dot notation to slash notation":
        val content = "use compiler.frontend.core.ast (CoreExpr)\n"
        val result = _parse_imports_from_content(content)
        expect(result.len()).to_equal(1)
        expect(result[0]).to_equal("frontend/core/ast")

# ============================================================================
# _module_path_from_init_file edge cases
# ============================================================================

describe "Arch Check Error Cases: _module_path_from_init_file edge cases":

    it "returns __init__.spl when init file is directly under root with no subdir":
        # When path is /project/__init__.spl and root is /project:
        # after removing root prefix: /__init__.spl
        # after removing leading /: __init__.spl
        # __init__.spl does not end with /__init__.spl so suffix is not stripped
        # Result is "__init__.spl" not ""
        val path = "/project/__init__.spl"
        val root = "/project"
        val result = _module_path_from_init_file(path, root)
        expect(result).to_equal("__init__.spl")

    it "handles path not under root unchanged":
        val path = "/other/__init__.spl"
        val root = "/project"
        val result = _module_path_from_init_file(path, root)
        expect(result).to_equal("/other")

# ============================================================================
# _file_is_under_module edge cases
# ============================================================================

describe "Arch Check Error Cases: _file_is_under_module edge cases":

    it "empty module path matches any file":
        val result = _file_is_under_module("/project/src/anything.spl", "", "/project")
        expect(result).to_equal(true)

    it "file at exact module boundary matches":
        val result = _file_is_under_module("/project/src/compiler/10.frontend/core/file.spl", "src/compiler/10.frontend/core", "/project")
        expect(result).to_equal(true)

    it "file outside module boundary does not match":
        val result = _file_is_under_module("/project/src/compiler/70.backend/file.spl", "src/compiler/10.frontend/core", "/project")
        expect(result).to_equal(false)

    it "file with similar prefix but different module does not match":
        val result = _file_is_under_module("/project/src/compiler/10.frontend/core_ext/file.spl", "src/compiler/10.frontend/core", "/project")
        expect(result).to_equal(false)

# ============================================================================
# _parse_arch_block edge cases
# ============================================================================

describe "Arch Check Error Cases: _parse_arch_block edge cases":

    it "returns false for empty content":
        val result = _parse_arch_block("")
        expect(result.0).to_equal(false)

    it "returns true when arch keyword appears in comment because parser has no comment awareness":
        # The parser uses content.contains("arch {") which matches in comments too.
        # This documents the known limitation: comments are not stripped before scanning.
        val content = "# arch { deny = [] }\nfn foo(): ()\n"
        val result = _parse_arch_block(content)
        expect(result.0).to_equal(true)

    it "returns empty allow and deny for arch block with no imports section":
        var content = "arch {\n"
        content = content + "  dimension = \"entity\"\n"
        content = content + "}\n"
        val result = _parse_arch_block(content)
        expect(result.0).to_equal(true)
        expect(result.1.len()).to_equal(0)
        expect(result.2.len()).to_equal(0)

    it "parses arch block with empty allow list":
        var content = "arch {\n"
        content = content + "  imports {\n"
        content = content + "    allow = []\n"
        content = content + "  }\n"
        content = content + "}\n"
        val result = _parse_arch_block(content)
        expect(result.0).to_equal(true)
        expect(result.1.len()).to_equal(0)

    it "parses arch block with empty deny list":
        var content = "arch {\n"
        content = content + "  imports {\n"
        content = content + "    deny = []\n"
        content = content + "  }\n"
        content = content + "}\n"
        val result = _parse_arch_block(content)
        expect(result.0).to_equal(true)
        expect(result.2.len()).to_equal(0)
