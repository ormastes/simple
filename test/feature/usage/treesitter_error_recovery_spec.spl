"""
# TreeSitter Error Handling and Edge Cases Specification

**Feature IDs:** #TS-ERR-001 to #TS-ERR-020
**Category:** Infrastructure | Parser
**Status:** Implemented

Tests error handling and edge cases in the compiler.treesitter outline parser,
including ParseError collection, recovery after errors, doc comment
accumulation, and various declaration modifiers.

## API

```simple
use compiler.treesitter.*

var ts = TreeSitter.new(source)
val outline = ts.parse_outline()
# outline.errors contains ParseError items
```
"""

use compiler.treesitter.*
use std.text.{NL}


# ============================================================================
# Test Group 1: Empty and Minimal Source
# ============================================================================

describe "TreeSitter Edge Cases - Empty Source":
    """
    Tests parsing empty and minimal source code.
    """

    it "produces empty module for empty source":
        var ts = TreeSitter.new("")
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 0
        expect outline.classes.len() to_equal 0
        expect outline.structs.len() to_equal 0
        expect outline.enums.len() to_equal 0

    it "produces empty module for whitespace only":
        var ts = TreeSitter.new("   {NL}   {NL}   ")
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 0

    it "produces empty module for comments only":
        var ts = TreeSitter.new("# just a comment{NL}# another comment")
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 0


# ============================================================================
# Test Group 2: Multiple Functions
# ============================================================================

describe "TreeSitter Multiple Function Parsing":
    """
    Tests parsing multiple function declarations.
    """

    it "parses three functions":
        val source = "fn alpha():{NL}    1{NL}{NL}fn beta():{NL}    2{NL}{NL}fn gamma():{NL}    3"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 3

    it "preserves function names":
        val source = "fn first():{NL}    1{NL}{NL}fn second():{NL}    2"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.functions[0].name to_equal "first"
        expect outline.functions[1].name to_equal "second"


# ============================================================================
# Test Group 3: Extern Functions
# ============================================================================

describe "TreeSitter Extern Function Parsing":
    """
    Tests parsing extern function declarations.
    """

    it "parses extern fn":
        val source = "extern fn rt_read(path: text) -> text"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 1
        val f = outline.functions[0]
        expect f.name to_equal "rt_read"
        expect f.is_extern to_equal true

    it "parses extern fn with params":
        val source = "extern fn rt_write(path: text, content: text) -> bool"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        val f = outline.functions[0]
        expect f.params.len() to_equal 2


# ============================================================================
# Test Group 4: Method Modifiers
# ============================================================================

describe "TreeSitter Method Modifiers":
    """
    Tests parsing method modifiers (static, mutable, const, etc).
    """

    it "parses static method in impl":
        val source = "impl Point:{NL}    static fn origin() -> Point:{NL}        Point(x: 0, y: 0)"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.impls.len() to_equal 1
        val impl_block = outline.impls[0]
        expect impl_block.methods.len() to_equal 1
        val m = impl_block.methods[0]
        expect m.is_static to_equal true

    it "parses mutable method in impl":
        val source = "impl Point:{NL}    me move(dx: i64):{NL}        self.x = self.x + dx"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.impls.len() to_equal 1
        val impl_block = outline.impls[0]
        expect impl_block.methods.len() to_equal 1
        val m = impl_block.methods[0]
        expect m.is_mutable to_equal true


# ============================================================================
# Test Group 5: Doc Comments
# ============================================================================

describe "TreeSitter Doc Comment Parsing":
    """
    Tests that doc comments are accumulated and attached.
    """

    it "attaches doc comment to function":
        val source = "## This is a doc comment{NL}fn hello():{NL}    42"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 1
        val f = outline.functions[0]
        expect f.has_doc_comment to_equal true

    it "attaches doc comment to struct":
        val source = "## A 2D point{NL}struct Point:{NL}    x: i64{NL}    y: i64"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.structs.len() to_equal 1
        val s = outline.structs[0]
        expect s.has_doc_comment to_equal true


# ============================================================================
# Test Group 6: Recovery After Errors
# ============================================================================

describe "TreeSitter Error Recovery":
    """
    Tests that the parser recovers and continues after errors.
    """

    it "continues parsing after valid declarations":
        val source = "fn valid_first():{NL}    1{NL}{NL}fn valid_second():{NL}    2"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 2

    it "parses complex source without crashing":
        val source = "use std.text.{NL2}{NL}{NL}fn main():{NL}    val x = 42{NL}    print x{NL}{NL}struct Config:{NL}    name: text{NL}    debug: bool"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        # Should find at least the function and struct
        expect outline.functions.len() >= 1


# ============================================================================
# Test Group 7: Trait and Impl Combinations
# ============================================================================

describe "TreeSitter Trait-Impl Parsing":
    """
    Tests parsing trait definitions and their implementations.
    """

    it "parses trait followed by impl":
        val source = "trait Greetable:{NL}    fn greet() -> text:{NL}        pass{NL}{NL}impl Person:{NL}    fn greet() -> text:{NL}        self.name"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.traits.len() to_equal 1
        expect outline.impls.len() to_equal 1

    it "parses impl methods":
        val source = "impl Calculator:{NL}    fn add(a: i64, b: i64) -> i64:{NL}        a + b{NL}    fn sub(a: i64, b: i64) -> i64:{NL}        a - b"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        val impl_block = outline.impls[0]
        expect impl_block.methods.len() to_equal 2
