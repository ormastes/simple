# # TreeSitter Error Handling and Edge Cases Specification
#
# **Feature IDs:** #TS-ERR-001 to #TS-ERR-020
# **Category:** Infrastructure | Parser
# **Status:** Implemented
#
# Tests error handling and edge cases in the compiler.treesitter outline parser,
# including ParseError collection, recovery after errors, doc comment
# accumulation, and various declaration modifiers.
#
# ## API
#
# ```simple
# use compiler.treesitter.*
#
# var ts = TreeSitter.new(source)
# val outline = ts.parse_outline()
# # outline.errors contains ParseError items
# ```

use compiler.treesitter.*


# ============================================================================
# Test Group 1: Empty and Minimal Source
# ============================================================================

describe "TreeSitter Edge Cases - Empty Source":
    # Tests parsing empty and minimal source code.

    it "produces empty module for empty source":
        var ts = TreeSitter.new("")
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 0
        expect outline.classes.len() to_equal 0
        expect outline.structs.len() to_equal 0
        expect outline.enums.len() to_equal 0

    it "produces empty module for whitespace only":
        var ts = TreeSitter.new("   \n   \n   ")
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 0

    it "produces empty module for comments only":
        var ts = TreeSitter.new("# just a comment\n# another comment")
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 0


# ============================================================================
# Test Group 2: Multiple Functions
# ============================================================================

describe "TreeSitter Multiple Function Parsing":
    # Tests parsing multiple function declarations.

    it "parses three functions":
        val source = "fn alpha():\n    1\n\nfn beta():\n    2\n\nfn gamma():\n    3"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 3

    it "preserves function names":
        val source = "fn first():\n    1\n\nfn second():\n    2"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.functions[0].name to_equal "first"
        expect outline.functions[1].name to_equal "second"


# ============================================================================
# Test Group 3: Extern Functions
# ============================================================================

describe "TreeSitter Extern Function Parsing":
    # Tests parsing extern function declarations.

    it "parses extern fn":
        val source = "extern fn rt_read(path: text) -> text"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 1
        val f = outline.functions[0]
        expect f.name to_equal "rt_read"
        expect f.is_extern to_equal true

    it "parses extern fn with params":
        val source = "extern fn rt_write(path: text, content: text) -> bool"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        val f = outline.functions[0]
        expect f.params.len() to_equal 2


# ============================================================================
# Test Group 4: Method Modifiers
# ============================================================================

describe "TreeSitter Method Modifiers":
    # Tests parsing method modifiers (static, mutable, const, etc).

    it "parses static method in impl":
        val source = "impl Point:\n    static fn origin() -> Point:\n        Point(x: 0, y: 0)"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.impls.len() to_equal 1
        val impl_block = outline.impls[0]
        expect impl_block.methods.len() to_equal 1
        val m = impl_block.methods[0]
        expect m.is_static to_equal true

    it "parses mutable method in impl":
        val source = "impl Point:\n    me move(dx: i64):\n        self.x = self.x + dx"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.impls.len() to_equal 1
        val impl_block = outline.impls[0]
        expect impl_block.methods.len() to_equal 1
        val m = impl_block.methods[0]
        expect m.is_mutable to_equal true


# ============================================================================
# Test Group 5: Doc Comments
# ============================================================================

describe "TreeSitter Doc Comment Parsing":
    # Tests that doc comments are accumulated and attached.

    it "attaches doc comment to function":
        val source = "## This is a doc comment\nfn hello():\n    42"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 1
        val f = outline.functions[0]
        expect f.has_doc_comment to_equal true

    it "attaches doc comment to struct":
        val source = "## A 2D point\nstruct Point:\n    x: i64\n    y: i64"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.structs.len() to_equal 1
        val s = outline.structs[0]
        expect s.has_doc_comment to_equal true


# ============================================================================
# Test Group 6: Recovery After Errors
# ============================================================================

describe "TreeSitter Error Recovery":
    # Tests that the parser recovers and continues after errors.

    it "continues parsing after valid declarations":
        val source = "fn valid_first():\n    1\n\nfn valid_second():\n    2"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 2

    it "parses complex source without crashing":
        val source = "use std.text.{NL2}\n\nfn main():\n    val x = 42\n    print x\n\nstruct Config:\n    name: text\n    debug: bool"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        # Should find at least the function and struct
        expect outline.functions.len() >= 1


# ============================================================================
# Test Group 7: Trait and Impl Combinations
# ============================================================================

describe "TreeSitter Trait-Impl Parsing":
    # Tests parsing trait definitions and their implementations.

    it "parses trait followed by impl":
        val source = "trait Greetable:\n    fn greet() -> text:\n        pass\n\nimpl Person:\n    fn greet() -> text:\n        self.name"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        expect outline.traits.len() to_equal 1
        expect outline.impls.len() to_equal 1

    it "parses impl methods":
        val source = "impl Calculator:\n    fn add(a: i64, b: i64) -> i64:\n        a + b\n    fn sub(a: i64, b: i64) -> i64:\n        a - b"
        var ts = TreeSitter.new(source)
        val outline = ts.parse_outline()
        val impl_block = outline.impls[0]
        expect impl_block.methods.len() to_equal 2
