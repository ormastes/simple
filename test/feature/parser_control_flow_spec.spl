"""
# Parser Control Flow Specification

**Feature IDs:** #PARSER-CF-001 to #PARSER-CF-020
**Category:** Infrastructure | Parser
**Status:** Implemented

Tests that the parser correctly parses control flow statements including
if/elif/else, while, for, match, loop, and suspension operators.

## Syntax

```simple
if condition:
    body
elif condition:
    body
else:
    body

while condition:
    body

for item in collection:
    body

match value:
    case pattern:
        body

loop:
    body
    if done:
        break
```
"""



# ============================================================================
# Test Group 1: If Statements
# ============================================================================

use std.spec.{check, check_msg}
describe "If Statement Parsing":
    """
    ## Conditional Branching

    Tests parsing of if, elif, and else branches.
    """

    context "simple if":
        it "parses if with single statement":
            var result = 0
            if true:
                result = 42
            expect result == 42

        it "parses if with false condition":
            var result = 0
            if false:
                result = 1
            expect result == 0

    context "if-else":
        it "parses if-else":
            var result = 0
            if false:
                result = 1
            else:
                result = 42
            expect result == 42

    context "if-elif-else":
        it "parses multiple elif branches":
            fn classify(x: i64) -> text:
                if x < 0:
                    "negative"
                elif x == 0:
                    "zero"
                elif x < 10:
                    "small"
                else:
                    "large"
            expect classify(-5) == "negative"
            expect classify(0) == "zero"
            expect classify(5) == "small"
            expect classify(100) == "large"

    context "nested if":
        it "parses nested if statements":
            var result = 0
            if true:
                if true:
                    result = 42
            expect result == 42


# ============================================================================
# Test Group 2: While Loops
# ============================================================================

describe "While Loop Parsing":
    """
    ## Conditional Loops

    Tests parsing of while loop statements.
    """

    it "parses while loop":
        var x = 0
        while x < 5:
            x = x + 1
        expect x == 5

    it "parses while with complex condition":
        var x = 0
        var y = 10
        while x < 5 and y > 0:
            x = x + 1
            y = y - 1
        expect x == 5

    it "parses while false (no iterations)":
        var x = 42
        while false:
            x = 0
        expect x == 42


# ============================================================================
# Test Group 3: For Loops
# ============================================================================

describe "For Loop Parsing":
    """
    ## Collection Iteration

    Tests parsing of for loop statements.
    """

    it "parses for-in with array":
        var sum = 0
        for x in [1, 2, 3, 4, 5]:
            sum = sum + x
        expect sum == 15

    it "parses for-in with range":
        var sum = 0
        for i in 0..5:
            sum = sum + i
        expect sum == 10

    it "parses for-in with inclusive range":
        var sum = 0
        for i in 0..=5:
            sum = sum + i
        expect sum == 15

    it "parses for with tuple destructuring", skip:
        # TODO: Tuple destructuring in for loops has interpreter issues in test context
        # The parser handles this correctly, but runtime execution fails
        var sum = 0
        for (a, b) in [(1, 2), (3, 4)]:
            sum = sum + a + b
        expect sum == 10


# ============================================================================
# Test Group 4: Match Statements
# ============================================================================

describe "Match Statement Parsing":
    """
    ## Pattern Matching

    Tests parsing of match statements with various patterns.
    """

    context "literal patterns":
        it "parses match with integer patterns":
            fn describe(x: i64) -> text:
                match x:
                    case 0:
                        "zero"
                    case 1:
                        "one"
                    case _:
                        "other"
            expect describe(0) == "zero"
            expect describe(1) == "one"
            expect describe(99) == "other"

    context "guard clauses":
        it "parses match with guards":
            fn classify(x: i64) -> text:
                match x:
                    case n if n < 0:
                        "negative"
                    case n if n == 0:
                        "zero"
                    case _:
                        "positive"
            expect classify(-5) == "negative"
            expect classify(0) == "zero"
            expect classify(5) == "positive"

    context "enum patterns":
        it "parses match with enum variants", skip:
            # TODO: Enum variant constructors have interpreter issues in test context
            # The parser handles this correctly, but runtime execution fails
            enum Status:
                Ok(i64)
                Error(text)

            fn handle(s: Status) -> text:
                match s:
                    case Status.Ok(value):
                        "ok: {value}"
                    case Status.Error(msg):
                        "error: {msg}"
            expect handle(Status.Ok(42)) == "ok: 42"

    context "tuple patterns":
        it "parses match with tuple patterns":
            fn describe_point(p: (i64, i64)) -> text:
                match p:
                    case (0, 0):
                        "origin"
                    case (x, 0):
                        "x-axis"
                    case (0, y):
                        "y-axis"
                    case _:
                        "general"
            expect describe_point((0, 0)) == "origin"
            expect describe_point((5, 0)) == "x-axis"


# ============================================================================
# Test Group 5: Loop Statement
# ============================================================================

describe "Loop Statement Parsing":
    """
    ## Infinite Loops with Break

    Tests parsing of loop statements with break/continue.
    """

    it "parses loop with break":
        var x = 0
        loop:
            x = x + 1
            if x >= 5:
                break
        expect x == 5

    it "parses loop with continue":
        var sum = 0
        var i = 0
        loop:
            i = i + 1
            if i > 10:
                break
            if i % 2 == 0:
                continue
            sum = sum + i
        expect sum == 25  # 1+3+5+7+9


# ============================================================================
# Test Group 6: Suspension Control Flow
# ============================================================================

describe "Suspension Control Flow Parsing":
    """
    ## Async-by-Default Suspension Operators

    Tests parsing of if~, while~, for~ suspension variants.
    """

    context "suspension if":
        it "parses if~ statement":
            var result = 0
            if~ true:
                result = 42
            expect result == 42

    context "suspension while":
        it "parses while~ statement":
            var x = 0
            while~ x < 3:
                x = x + 1
            expect x == 3

    context "suspension for":
        it "parses for~ statement":
            var sum = 0
            for~ i in [1, 2, 3]:
                sum = sum + i
            expect sum == 6

    context "suspension assignment":
        it "parses ~= assignment":
            fn async_value() -> i64:
                42
            var x = 0
            x ~= async_value()
            expect x == 42


# ============================================================================
# Test Group 7: Return Statement
# ============================================================================

describe "Return Statement Parsing":
    """
    ## Early Return from Functions

    Tests parsing of return statements.
    """

    it "parses return with value":
        fn get_value() -> i64:
            return 42
        expect get_value() == 42

    it "parses early return":
        fn check(x: i64) -> text:
            if x < 0:
                return "negative"
            "non-negative"
        expect check(-5) == "negative"
        expect check(5) == "non-negative"

    it "parses return without value":
        fn do_nothing():
            return
        do_nothing()
        expect true


# ============================================================================
# Test Group 8: If Let / While Let
# ============================================================================

describe "If Val/Var and While Val Parsing":
    """
    ## Pattern Matching in Conditionals

    Tests parsing of if val, if var, and while val constructs.
    Note: `if let` / `while let` are deprecated; use `if val` / `while val` instead.
    """

    context "if val":
        it "parses if val with Some":
            val opt = Some(42)
            var result = 0
            if val Some(x) = opt:
                result = x
            expect result == 42

        it "parses if val with else":
            val opt: Option<i64> = None
            var result = 0
            if val Some(x) = opt:
                result = x
            else:
                result = -1
            expect result == -1

    context "if var":
        it "parses if var with Some":
            val opt = Some(10)
            var result = 0
            if var Some(x) = opt:
                result = x
            expect result == 10

    context "while val":
        it "parses while val":
            var values = [Some(1), Some(2), Some(3), None]
            var sum = 0
            var idx = 0
            while val Some(x) = values[idx]:
                sum = sum + x
                idx = idx + 1
                if idx >= values.len():
                    break
            expect sum == 6

    context "while var":
        it "parses while var":
            var values = [Some(1), Some(2), None]
            var sum = 0
            var idx = 0
            while var Some(x) = values[idx]:
                sum = sum + x
                idx = idx + 1
                if idx >= values.len():
                    break
            expect sum == 3


# ============================================================================
# Test Group 9: Complex Control Flow
# ============================================================================

describe "Complex Control Flow Parsing":
    """
    ## Nested and Combined Control Flow

    Tests parsing of complex nested control flow structures.
    """

    it "parses nested loops":
        var count = 0
        for i in 0..3:
            for j in 0..3:
                count = count + 1
        expect count == 9

    it "parses mixed control flow":
        var result = 0
        for i in 0..10:
            if i % 2 == 0:
                continue
            if i > 7:
                break
            result = result + i
        expect result == 1 + 3 + 5 + 7

    it "parses deeply nested conditions":
        fn classify(x: i64, y: i64, z: i64) -> text:
            if x > 0:
                if y > 0:
                    if z > 0:
                        "all positive"
                    else:
                        "x,y positive"
                else:
                    "x positive"
            else:
                "x not positive"
        expect classify(1, 2, 3) == "all positive"
