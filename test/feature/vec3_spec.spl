"""
# Vec3 Specification


**Feature IDs:** #MATH-001
**Category:** Stdlib
**Difficulty:** 2/5
**Status:** Implemented

## Overview
Vec3 (f32) and Vec3d (f64) 3D vector types with arithmetic, geometric, and utility methods.

## Key Concepts
| Concept | Description |
|---------|-------------|
| Vec3 | 3D vector with f32 precision |
| Vec3d | 3D vector with f64 precision |
| Dual precision | All types in both f32 and f64 |

## Behavior
- Supports add, sub, scale, dot, cross operations
- Magnitude/length aliases
- Static factory methods for common directions
- Conversion between f32 and f64
"""

use math
use std.text.{NL}

# ============================================================================
# Vec3 Construction and Constants
# ============================================================================

describe "Vec3 Construction":
    it "creates a vector with components":
        val v = math.Vec3(1.0, 2.0, 3.0)
        expect v.x == 1.0
        expect v.y == 2.0
        expect v.z == 3.0

    it "creates zero vector":
        val v = math.Vec3.zero()
        expect v.x == 0.0
        expect v.y == 0.0
        expect v.z == 0.0

    it "creates one vector":
        val v = math.Vec3.one()
        expect v.x == 1.0
        expect v.y == 1.0
        expect v.z == 1.0

    it "creates directional vectors":
        expect math.Vec3.up().y == 1.0
        expect math.Vec3.down().y == -1.0
        expect math.Vec3.left().x == -1.0
        expect math.Vec3.right().x == 1.0
        expect math.Vec3.forward().z == 1.0
        expect math.Vec3.back().z == -1.0

# ============================================================================
# Vec3 Arithmetic
# ============================================================================

describe "Vec3 Arithmetic":
    it "adds two vectors":
        val a = math.Vec3(1.0, 2.0, 3.0)
        val b = math.Vec3(4.0, 5.0, 6.0)
        val c = a.add(b)
        expect c.x == 5.0
        expect c.y == 7.0
        expect c.z == 9.0

    it "subtracts two vectors":
        val a = math.Vec3(4.0, 5.0, 6.0)
        val b = math.Vec3(1.0, 2.0, 3.0)
        val c = a.sub(b)
        expect c.x == 3.0
        expect c.y == 3.0
        expect c.z == 3.0

    it "scales a vector":
        val v = math.Vec3(1.0, 2.0, 3.0)
        val s = v.scale(2.0)
        expect s.x == 2.0
        expect s.y == 4.0
        expect s.z == 6.0

    it "computes dot product":
        val a = math.Vec3(1.0, 0.0, 0.0)
        val b = math.Vec3(0.0, 1.0, 0.0)
        expect a.dot(b) == 0.0

        val c = math.Vec3(1.0, 2.0, 3.0)
        val d = math.Vec3(4.0, 5.0, 6.0)
        expect c.dot(d) == 32.0

    it "computes cross product":
        val x = math.Vec3(1.0, 0.0, 0.0)
        val y = math.Vec3(0.0, 1.0, 0.0)
        val z = x.cross(y)
        expect z.x == 0.0
        expect z.y == 0.0
        expect z.z == 1.0

# ============================================================================
# Vec3 Geometric Methods
# ============================================================================

describe "Vec3 Geometric Methods":
    it "computes magnitude":
        val v = math.Vec3(3.0, 4.0, 0.0)
        expect v.magnitude() == 5.0

    it "magnitude and length are aliases":
        val v = math.Vec3(3.0, 4.0, 0.0)
        expect v.magnitude() == v.length()

    it "normalizes a vector":
        val v = math.Vec3(3.0, 0.0, 0.0)
        val n = v.normalize()
        expect n.x == 1.0
        expect n.y == 0.0
        expect n.z == 0.0

    it "computes distance":
        val a = math.Vec3(0.0, 0.0, 0.0)
        val b = math.Vec3(3.0, 4.0, 0.0)
        expect a.distance(b) == 5.0

    it "distance and distance_to are aliases":
        val a = math.Vec3(0.0, 0.0, 0.0)
        val b = math.Vec3(3.0, 4.0, 0.0)
        expect a.distance(b) == a.distance_to(b)

    it "interpolates linearly":
        val a = math.Vec3(0.0, 0.0, 0.0)
        val b = math.Vec3(10.0, 10.0, 10.0)
        val mid = a.lerp(b, 0.5)
        expect mid.x == 5.0
        expect mid.y == 5.0
        expect mid.z == 5.0

# ============================================================================
# Vec3 Utility Methods
# ============================================================================

describe "Vec3 Utility Methods":
    it "detects zero vector":
        expect math.Vec3.zero().is_zero() == true
        expect math.Vec3(1.0, 0.0, 0.0).is_zero() == false

    it "detects near-zero vector":
        val v = math.Vec3(0.0000001, 0.0, 0.0)
        expect v.is_near_zero() == true

    it "checks unit vector":
        expect math.Vec3(1.0, 0.0, 0.0).is_unit() == true
        expect math.Vec3(2.0, 0.0, 0.0).is_unit() == false

    it "computes component min/max":
        val a = math.Vec3(1.0, 5.0, 3.0)
        val b = math.Vec3(4.0, 2.0, 6.0)
        val mn = a.component_min(b)
        val mx = a.component_max(b)
        expect mn.x == 1.0
        expect mn.y == 2.0
        expect mn.z == 3.0
        expect mx.x == 4.0
        expect mx.y == 5.0
        expect mx.z == 6.0

# ============================================================================
# Vec3d (f64) and Conversions
# ============================================================================

describe "Vec3d and Conversions":
    it "creates Vec3d with f64 precision":
        val v = math.Vec3d(1.0, 2.0, 3.0)
        expect v.x == 1.0
        expect v.y == 2.0
        expect v.z == 3.0

    it "converts Vec3 to Vec3d":
        val v32 = math.Vec3(1.0, 2.0, 3.0)
        val v64 = v32.to_f64()
        expect v64.x == 1.0
        expect v64.y == 2.0
        expect v64.z == 3.0

    it "converts Vec3d to Vec3":
        val v64 = math.Vec3d(1.0, 2.0, 3.0)
        val v32 = v64.to_f32()
        expect v32.x == 1.0
        expect v32.y == 2.0
        expect v32.z == 3.0

    it "Vec3d has all Vec3 methods":
        val a = math.Vec3d(1.0, 2.0, 3.0)
        val b = math.Vec3d(4.0, 5.0, 6.0)
        expect a.dot(b) == 32.0
        val c = a.cross(b)
        expect c.x == -3.0
        expect c.y == 6.0
        expect c.z == -3.0
