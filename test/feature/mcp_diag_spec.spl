# MCP Virtual Diagnostic Tools Specification
#
# Tests for:
#   src/app/mcp/diag_core.spl        - Core diagnostic engine
#   src/app/mcp/diag_read_tools.spl  - Read-only tools
#   src/app/mcp/diag_edit_tools.spl  - Edit + delta tools
#   src/app/mcp/diag_vcs_tools.spl   - VCS tools


use app.mcp.diag_core.{DiagEntry, DiagResult, DiagDelta, run_diagnostics, parse_diag_output, overlay_virtual_text, compute_delta, format_delta_text, severity_tag, pad_line, diag_entry_to_json, diag_result_to_json, diag_delta_to_json, diag_entries_to_json}
use app.mcp.diag_read_tools.{schema_simple_read, schema_simple_check, schema_simple_symbols, schema_simple_status}
use app.mcp.diag_edit_tools.{schema_simple_edit, schema_simple_multi_edit, schema_simple_run}
use app.mcp.diag_vcs_tools.{schema_simple_diff, schema_simple_log, schema_simple_squash, schema_simple_new}

use std.string.{NL}
use std.string.{NL}

describe "MCP Virtual Diagnostic Tools":

    context "diag_core - severity_tag":
        it "returns [E] for error":
            expect(severity_tag("error")).to_equal("[E]")

        it "returns [W] for warning":
            expect(severity_tag("warning")).to_equal("[W]")

        it "returns [I] for info":
            expect(severity_tag("info")).to_equal("[I]")

        it "returns [H] for hint":
            expect(severity_tag("hint")).to_equal("[H]")

        it "returns [?] for unknown":
            expect(severity_tag("other")).to_equal("[?]")

    context "diag_core - pad_line":
        it "pads short line to target column":
            val padded = pad_line("hello", 10)
            expect(padded.len()).to_equal(10)
            expect(padded).to_start_with("hello")

        it "does not truncate long lines":
            val padded = pad_line("a very long line indeed", 5)
            expect(padded).to_equal("a very long line indeed")

    context "diag_core - parse_diag_output":
        it "returns empty for exit code 0":
            val entries = parse_diag_output("all good", 0, "test.spl")
            expect(entries.len()).to_equal(0)

        it "parses error bracket format":
            val output = "error[E:type_mismatch]: line 5:3: expected i64, got text"
            val entries = parse_diag_output(output, 1, "test.spl")
            expect(entries.len()).to_equal(1)
            expect(entries[0].severity).to_equal("error")
            expect(entries[0].line_num).to_equal(5)
            expect(entries[0].code).to_equal("E:type_mismatch")

        it "parses error semantic format":
            val output = "error: semantic: undefined variable 'foo'"
            val entries = parse_diag_output(output, 1, "test.spl")
            expect(entries.len()).to_equal(1)
            expect(entries[0].severity).to_equal("error")

        it "parses warning format":
            val output = "warning: unused variable 'x'"
            val entries = parse_diag_output(output, 1, "test.spl")
            expect(entries.len()).to_equal(1)
            expect(entries[0].severity).to_equal("warning")
            expect(entries[0].message).to_contain("unused variable")

        it "parses multiple diagnostics":
            val output = "error[E:a]: line 1: first{NL}error[E:b]: line 2: second"
            val entries = parse_diag_output(output, 1, "test.spl")
            expect(entries.len()).to_equal(2)

    context "diag_core - overlay_virtual_text":
        it "shows clean lines without annotation":
            val source = "val x = 1{NL}val y = 2"
            var entries: [DiagEntry] = []
            val result = overlay_virtual_text(source, entries, true, "compact")
            expect(result).to_contain("val x = 1")
            expect(result).to_contain("val y = 2")
            # No [E] or [W] markers
            expect(result).to_contain("1 |")
            expect(result).to_contain("2 |")

        it "annotates line with error entry":
            val source = "val x = 1{NL}val y = bad"
            var entries: [DiagEntry] = []
            val entry = DiagEntry(line_num: 2, col_num: 9, severity: "error", message: "undefined 'bad'", easyfix: "", code: "")
            entries.push(entry)
            val result = overlay_virtual_text(source, entries, true, "compact")
            expect(result).to_contain("[E]")
            expect(result).to_contain("undefined 'bad'")

        it "shows easyfix hint when show_hints is true":
            val source = "val x = foo"
            var entries: [DiagEntry] = []
            val entry = DiagEntry(line_num: 1, col_num: 9, severity: "error", message: "undefined 'foo'", easyfix: "did you mean 'f00'?", code: "")
            entries.push(entry)
            val result = overlay_virtual_text(source, entries, true, "compact")
            expect(result).to_contain("[H] easyfix:")
            expect(result).to_contain("did you mean 'f00'?")

        it "hides easyfix when show_hints is false":
            val source = "val x = foo"
            var entries: [DiagEntry] = []
            val entry = DiagEntry(line_num: 1, col_num: 9, severity: "error", message: "undefined 'foo'", easyfix: "did you mean 'f00'?", code: "")
            entries.push(entry)
            val result = overlay_virtual_text(source, entries, false, "compact")
            expect(result).to_contain("[E]")

    context "diag_core - compute_delta":
        it "detects resolved diagnostics":
            var baseline: [DiagEntry] = []
            baseline.push(DiagEntry(line_num: 1, col_num: 0, severity: "error", message: "bad", easyfix: "", code: ""))
            var current: [DiagEntry] = []
            val delta = compute_delta(baseline, current)
            expect(delta.resolved.len()).to_equal(1)
            expect(delta.introduced.len()).to_equal(0)
            expect(delta.remaining.len()).to_equal(0)

        it "detects introduced diagnostics":
            var baseline: [DiagEntry] = []
            var current: [DiagEntry] = []
            current.push(DiagEntry(line_num: 3, col_num: 0, severity: "error", message: "new error", easyfix: "", code: ""))
            val delta = compute_delta(baseline, current)
            expect(delta.resolved.len()).to_equal(0)
            expect(delta.introduced.len()).to_equal(1)
            expect(delta.remaining.len()).to_equal(0)

        it "detects remaining diagnostics":
            var baseline: [DiagEntry] = []
            baseline.push(DiagEntry(line_num: 5, col_num: 0, severity: "warning", message: "unused", easyfix: "", code: ""))
            var current: [DiagEntry] = []
            current.push(DiagEntry(line_num: 5, col_num: 0, severity: "warning", message: "unused", easyfix: "", code: ""))
            val delta = compute_delta(baseline, current)
            expect(delta.resolved.len()).to_equal(0)
            expect(delta.introduced.len()).to_equal(0)
            expect(delta.remaining.len()).to_equal(1)

        it "handles mixed delta":
            var baseline: [DiagEntry] = []
            baseline.push(DiagEntry(line_num: 1, col_num: 0, severity: "error", message: "fixed", easyfix: "", code: ""))
            baseline.push(DiagEntry(line_num: 5, col_num: 0, severity: "warning", message: "stays", easyfix: "", code: ""))
            var current: [DiagEntry] = []
            current.push(DiagEntry(line_num: 5, col_num: 0, severity: "warning", message: "stays", easyfix: "", code: ""))
            current.push(DiagEntry(line_num: 10, col_num: 0, severity: "error", message: "new", easyfix: "", code: ""))
            val delta = compute_delta(baseline, current)
            expect(delta.resolved.len()).to_equal(1)
            expect(delta.introduced.len()).to_equal(1)
            expect(delta.remaining.len()).to_equal(1)

    context "diag_core - format_delta_text":
        it "formats delta summary":
            var resolved: [DiagEntry] = []
            resolved.push(DiagEntry(line_num: 1, col_num: 0, severity: "error", message: "x", easyfix: "", code: ""))
            var introduced: [DiagEntry] = []
            var remaining: [DiagEntry] = []
            remaining.push(DiagEntry(line_num: 5, col_num: 0, severity: "warning", message: "y", easyfix: "", code: ""))
            val delta = DiagDelta(resolved: resolved, introduced: introduced, remaining: remaining)
            val text = format_delta_text(delta)
            expect(text).to_contain("resolved: 1 error(s)")
            expect(text).to_contain("introduced: 0 error(s)")
            expect(text).to_contain("remaining: 0 error(s), 1 warning(s)")

    context "diag_core - JSON serialization":
        it "serializes DiagEntry to JSON":
            val entry = DiagEntry(line_num: 10, col_num: 5, severity: "error", message: "bad type", easyfix: "use i64", code: "E:type")
            val json = diag_entry_to_json(entry)
            expect(json).to_contain("\"line\":10")
            expect(json).to_contain("\"severity\":\"error\"")
            expect(json).to_contain("\"easyfix\":\"use i64\"")
            expect(json).to_contain("\"code\":\"E:type\"")

        it "serializes DiagEntry without easyfix":
            val entry = DiagEntry(line_num: 1, col_num: 0, severity: "warning", message: "unused", easyfix: "", code: "")
            val json = diag_entry_to_json(entry)
            expect(json).to_contain("\"severity\":\"warning\"")

        it "serializes DiagResult to JSON":
            var entries: [DiagEntry] = []
            entries.push(DiagEntry(line_num: 1, col_num: 0, severity: "error", message: "err", easyfix: "", code: ""))
            val result = DiagResult(file_path: "test.spl", status: "type_errors", exit_code: 1, entries: entries, error_count: 1, warning_count: 0)
            val json = diag_result_to_json(result)
            expect(json).to_contain("\"status\":\"type_errors\"")
            expect(json).to_contain("\"error_count\":1")
            expect(json).to_contain("\"diagnostics\":[")

    context "tool schemas - read tools":
        it "generates simple_read schema":
            val schema = schema_simple_read()
            expect(schema).to_contain("simple_read")
            expect(schema).to_contain("path")
            expect(schema).to_contain("show_hints")
            expect(schema).to_contain("fold_mode")
            expect(schema).to_contain("\"readOnlyHint\":true")

        it "generates simple_check schema":
            val schema = schema_simple_check()
            expect(schema).to_contain("simple_check")
            expect(schema).to_contain("path")
            expect(schema).to_contain("\"readOnlyHint\":true")

        it "generates simple_symbols schema":
            val schema = schema_simple_symbols()
            expect(schema).to_contain("simple_symbols")
            expect(schema).to_contain("path")

        it "generates simple_status schema":
            val schema = schema_simple_status()
            expect(schema).to_contain("simple_status")
            expect(schema).to_contain("directory")
            expect(schema).to_contain("paths")

    context "tool schemas - edit tools":
        it "generates simple_edit schema":
            val schema = schema_simple_edit()
            expect(schema).to_contain("simple_edit")
            expect(schema).to_contain("old_string")
            expect(schema).to_contain("new_string")
            expect(schema).to_contain("\"readOnlyHint\":false")

        it "generates simple_multi_edit schema":
            val schema = schema_simple_multi_edit()
            expect(schema).to_contain("simple_multi_edit")
            expect(schema).to_contain("edits")

        it "generates simple_run schema":
            val schema = schema_simple_run()
            expect(schema).to_contain("simple_run")
            expect(schema).to_contain("timeout_sec")

    context "tool schemas - vcs tools":
        it "generates simple_diff schema":
            val schema = schema_simple_diff()
            expect(schema).to_contain("simple_diff")
            expect(schema).to_contain("revision")
            expect(schema).to_contain("\"readOnlyHint\":true")

        it "generates simple_log schema":
            val schema = schema_simple_log()
            expect(schema).to_contain("simple_log")
            expect(schema).to_contain("limit")

        it "generates simple_squash schema":
            val schema = schema_simple_squash()
            expect(schema).to_contain("simple_squash")
            expect(schema).to_contain("message")
            expect(schema).to_contain("\"readOnlyHint\":false")

        it "generates simple_new schema":
            val schema = schema_simple_new()
            expect(schema).to_contain("simple_new")
            expect(schema).to_contain("revision")
