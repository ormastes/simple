"""
# GPU PTX Code Generation Specification


**Feature IDs:** #816-820
**Category:** Compiler Backend
**Difficulty:** 4/5
**Status:** In Progress

## Overview

PTX code generation tests verify that the CUDA backend correctly translates
MIR instructions to NVIDIA PTX assembly. These tests do NOT require GPU
hardware - they only verify the text output of the code generator.

## Key Concepts

| Concept | Description |
|---------|-------------|
| PTX | NVIDIA Parallel Thread Execution virtual ISA |
| MIR | Mid-level Intermediate Representation |
| Kernel | GPU entry point function (.entry) |
| Device Function | GPU-callable function (.func) |

## Behavior

- CudaBackend compiles MIR modules to PTX text
- PTX header contains version, target, and address size
- Kernel functions use .visible .entry directive
- Device functions use .visible .func directive
- Thread IDs accessed via special registers %tid, %ctaid, %ntid
- Barrier synchronization via bar.sync
"""

use compiler.backend.cuda_backend.{CudaBackend, CudaCompiledModule}
use compiler.backend.cuda.ptx_builder.PtxBuilder
use compiler.backend.cuda_type_mapper.CudaTypeMapper
use compiler.backend.common.type_mapper.PrimitiveType
use std.text.{NL}

# ============================================================================
# PTX Builder Unit Tests
# ============================================================================

describe "PTX Builder - Module Header":
    """
    ## PTX Module Header Generation

    Tests that PTX module headers contain correct version and target info.
    """

    context "with SM 8.6 compute capability":
        it "generates correct PTX header":
            var builder = PtxBuilder__create((8, 6))
            builder.emit_module_header("test_module")
            val ptx = builder.build()

            expect(ptx).to_contain(".version 7.8")
            expect(ptx).to_contain(".target sm_86")
            expect(ptx).to_contain(".address_size 64")
            expect(ptx).to_contain("test_module")

    context "with SM 7.0 compute capability":
        it "generates correct target for Volta":
            var builder = PtxBuilder__create((7, 0))
            builder.emit_module_header("volta_module")
            val ptx = builder.build()

            expect(ptx).to_contain(".target sm_70")

describe "PTX Builder - Register Declarations":
    """
    ## Register Declaration Generation

    Tests PTX register declarations for various types.
    """

    it "declares integer registers":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_reg_decl("%r0", PrimitiveType.I64)
        val ptx = builder.build()

        expect(ptx).to_contain(".reg .s64 %r0;")

    it "declares float registers":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_reg_decl("%f0", PrimitiveType.F32)
        val ptx = builder.build()

        expect(ptx).to_contain(".reg .f32 %f0;")

    it "declares predicate registers":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_pred_decl("%p0")
        val ptx = builder.build()

        expect(ptx).to_contain(".reg .pred %p0;")

    it "declares unsigned integer registers":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_reg_decl("%u0", PrimitiveType.U32)
        val ptx = builder.build()

        expect(ptx).to_contain(".reg .u32 %u0;")

# ============================================================================
# PTX Arithmetic Instructions
# ============================================================================

describe "PTX Builder - Arithmetic Operations":
    """
    ## Arithmetic Instruction Generation

    Tests PTX arithmetic instruction emission.
    """

    it "generates integer add":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_add("%r0", PrimitiveType.I64, "%r1", "%r2")
        val ptx = builder.build()

        expect(ptx).to_contain("add.s64 %r0, %r1, %r2;")

    it "generates integer subtract":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_sub("%r0", PrimitiveType.I32, "%r1", "%r2")
        val ptx = builder.build()

        expect(ptx).to_contain("sub.s32 %r0, %r1, %r2;")

    it "generates integer multiply with low-word":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_mul("%r0", PrimitiveType.I64, "%r1", "%r2")
        val ptx = builder.build()

        expect(ptx).to_contain("mul.lo.s64 %r0, %r1, %r2;")

    it "generates float multiply":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_mul("%f0", PrimitiveType.F32, "%f1", "%f2")
        val ptx = builder.build()

        expect(ptx).to_contain("mul.f32 %f0, %f1, %f2;")

    it "generates float divide with rounding":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_div("%f0", PrimitiveType.F64, "%f1", "%f2")
        val ptx = builder.build()

        expect(ptx).to_contain("div.rn.f64 %f0, %f1, %f2;")

    it "generates approximate float divide for f32":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_div("%f0", PrimitiveType.F32, "%f1", "%f2")
        val ptx = builder.build()

        expect(ptx).to_contain("div.approx.f32 %f0, %f1, %f2;")

    it "generates negate":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_neg("%r0", PrimitiveType.I64, "%r1")
        val ptx = builder.build()

        expect(ptx).to_contain("neg.s64 %r0, %r1;")

# ============================================================================
# PTX Comparison Instructions
# ============================================================================

describe "PTX Builder - Comparisons":
    """
    ## Comparison and Predicate Generation

    Tests set-predicate instruction generation.
    """

    it "generates equality comparison":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_compare("%p0", "eq", PrimitiveType.I64, "%r0", "%r1")
        val ptx = builder.build()

        expect(ptx).to_contain("setp.eq.s64 %p0, %r0, %r1;")

    it "generates less-than comparison":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_compare("%p0", "lt", PrimitiveType.F32, "%f0", "%f1")
        val ptx = builder.build()

        expect(ptx).to_contain("setp.lt.f32 %p0, %f0, %f1;")

# ============================================================================
# PTX Memory Operations
# ============================================================================

describe "PTX Builder - Memory Operations":
    """
    ## Memory Load/Store Generation

    Tests global, shared, and local memory access instructions.
    """

    it "generates global memory load":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_load("%r0", PrimitiveType.I64, "%addr", MemorySpace.Global)
        val ptx = builder.build()

        expect(ptx).to_contain("ld.global.s64 %r0, [%addr];")

    it "generates global memory store":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_store(PrimitiveType.I64, "%addr", "%r0", MemorySpace.Global)
        val ptx = builder.build()

        expect(ptx).to_contain("st.global.s64 [%addr], %r0;")

    it "generates shared memory load":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_load("%r0", PrimitiveType.F32, "%saddr", MemorySpace.Shared)
        val ptx = builder.build()

        expect(ptx).to_contain("ld.shared.f32 %r0, [%saddr];")

    it "generates shared memory allocation":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_shared_memory("shared_buf", PrimitiveType.F32, 256)
        val ptx = builder.build()

        expect(ptx).to_contain(".shared .f32 shared_buf[256];")

    it "generates local memory allocation":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_local_alloc("local_buf", PrimitiveType.I64, 8)
        val ptx = builder.build()

        expect(ptx).to_contain(".local .s64 local_buf[8];")

# ============================================================================
# PTX Thread Identification
# ============================================================================

describe "PTX Builder - Thread IDs":
    """
    ## Thread and Block ID Access

    Tests special register access for thread identification.
    """

    it "generates thread ID access for x dimension":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_get_thread_id("%tid_x", 0)
        val ptx = builder.build()

        expect(ptx).to_contain("mov.u32 %tid_x, %tid.x;")

    it "generates thread ID access for y dimension":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_get_thread_id("%tid_y", 1)
        val ptx = builder.build()

        expect(ptx).to_contain("mov.u32 %tid_y, %tid.y;")

    it "generates block ID access":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_get_block_id("%bid_x", 0)
        val ptx = builder.build()

        expect(ptx).to_contain("mov.u32 %bid_x, %ctaid.x;")

    it "generates block dim access":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_get_block_dim("%bdim_x", 0)
        val ptx = builder.build()

        expect(ptx).to_contain("mov.u32 %bdim_x, %ntid.x;")

    it "generates grid dim access":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_get_grid_dim("%gdim_x", 0)
        val ptx = builder.build()

        expect(ptx).to_contain("mov.u32 %gdim_x, %nctaid.x;")

    it "computes global thread ID":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_compute_global_id("%gid", 0)
        val ptx = builder.build()

        # Global ID = blockIdx * blockDim + threadIdx
        expect(ptx).to_contain("mul.lo.u32")
        expect(ptx).to_contain("add.u32")

# ============================================================================
# PTX Synchronization
# ============================================================================

describe "PTX Builder - Synchronization":
    """
    ## Barrier and Memory Fence Generation

    Tests synchronization instruction generation.
    """

    it "generates block-level barrier":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_barrier()
        val ptx = builder.build()

        expect(ptx).to_contain("bar.sync 0;")

    it "generates CTA memory barrier":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_membar_cta()
        val ptx = builder.build()

        expect(ptx).to_contain("membar.cta;")

    it "generates global memory barrier":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_membar_gl()
        val ptx = builder.build()

        expect(ptx).to_contain("membar.gl;")

    it "generates system memory barrier":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_membar_sys()
        val ptx = builder.build()

        expect(ptx).to_contain("membar.sys;")

# ============================================================================
# PTX Atomic Operations
# ============================================================================

describe "PTX Builder - Atomic Operations":
    """
    ## Atomic Operation Generation

    Tests atomic instruction generation for global memory.
    """

    it "generates atomic add":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_atomic_add("%r0", PrimitiveType.I64, "%addr", "%val", MemorySpace.Global)
        val ptx = builder.build()

        expect(ptx).to_contain("atom.global.add.s64 %r0, [%addr], %val;")

    it "generates atomic min":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_atomic_min("%r0", PrimitiveType.I32, "%addr", "%val", MemorySpace.Global)
        val ptx = builder.build()

        expect(ptx).to_contain("atom.global.min.s32 %r0, [%addr], %val;")

    it "generates atomic max":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_atomic_max("%r0", PrimitiveType.U64, "%addr", "%val", MemorySpace.Global)
        val ptx = builder.build()

        expect(ptx).to_contain("atom.global.max.u64 %r0, [%addr], %val;")

    it "generates atomic compare-and-swap":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_atomic_cas("%r0", PrimitiveType.I64, "%addr", "%cmp", "%val", MemorySpace.Global)
        val ptx = builder.build()

        expect(ptx).to_contain("atom.global.cas.s64 %r0, [%addr], %cmp, %val;")

    it "generates shared memory atomic add":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_atomic_add("%r0", PrimitiveType.I32, "%saddr", "%val", MemorySpace.Shared)
        val ptx = builder.build()

        expect(ptx).to_contain("atom.shared.add.s32 %r0, [%saddr], %val;")

# ============================================================================
# PTX Type Conversion
# ============================================================================

describe "PTX Builder - Type Conversions":
    """
    ## Type Conversion (cvt) Instruction Generation

    Tests PTX type conversion instruction emission.
    """

    it "converts int to float":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_convert("%f0", PrimitiveType.F32, "%r0", PrimitiveType.I32)
        val ptx = builder.build()

        expect(ptx).to_contain("cvt.rn.f32.s32 %f0, %r0;")

    it "converts float to int":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_convert("%r0", PrimitiveType.I64, "%f0", PrimitiveType.F64)
        val ptx = builder.build()

        expect(ptx).to_contain("cvt.rzi.s64.f64 %r0, %f0;")

    it "converts float to float":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_convert("%f0", PrimitiveType.F64, "%f1", PrimitiveType.F32)
        val ptx = builder.build()

        expect(ptx).to_contain("cvt.rn.f64.f32 %f0, %f1;")

    it "converts int to int":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_convert("%r0", PrimitiveType.I64, "%r1", PrimitiveType.I32)
        val ptx = builder.build()

        expect(ptx).to_contain("cvt.s64.s32 %r0, %r1;")

# ============================================================================
# PTX Math Intrinsics
# ============================================================================

describe "PTX Builder - Math Intrinsics":
    """
    ## Math Intrinsic Generation

    Tests PTX special function unit (SFU) instruction emission.
    """

    it "generates sin approximation":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_intrinsic_sin("%f0", PrimitiveType.F32, "%f1")
        val ptx = builder.build()

        expect(ptx).to_contain("sin.approx.f32 %f0, %f1;")

    it "generates cos approximation":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_intrinsic_cos("%f0", PrimitiveType.F32, "%f1")
        val ptx = builder.build()

        expect(ptx).to_contain("cos.approx.f32 %f0, %f1;")

    it "generates sqrt approximation":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_intrinsic_sqrt("%f0", PrimitiveType.F32, "%f1")
        val ptx = builder.build()

        expect(ptx).to_contain("sqrt.approx.f32 %f0, %f1;")

    it "generates abs":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_intrinsic_abs("%f0", PrimitiveType.F32, "%f1")
        val ptx = builder.build()

        expect(ptx).to_contain("abs.f32 %f0, %f1;")

    it "generates fused multiply-add":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_intrinsic_fma("%f0", PrimitiveType.F32, "%f1", "%f2", "%f3")
        val ptx = builder.build()

        expect(ptx).to_contain("fma.rn.f32 %f0, %f1, %f2, %f3;")

    it "generates exp2 approximation":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_intrinsic_ex2("%f0", PrimitiveType.F32, "%f1")
        val ptx = builder.build()

        expect(ptx).to_contain("ex2.approx.f32 %f0, %f1;")

    it "generates log2 approximation":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_intrinsic_lg2("%f0", PrimitiveType.F32, "%f1")
        val ptx = builder.build()

        expect(ptx).to_contain("lg2.approx.f32 %f0, %f1;")

    it "generates reciprocal approximation":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_intrinsic_rcp("%f0", PrimitiveType.F32, "%f1")
        val ptx = builder.build()

        expect(ptx).to_contain("rcp.approx.f32 %f0, %f1;")

    it "generates min instruction":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_intrinsic_min("%f0", PrimitiveType.F32, "%f1", "%f2")
        val ptx = builder.build()

        expect(ptx).to_contain("min.f32 %f0, %f1, %f2;")

    it "generates max instruction":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_intrinsic_max("%f0", PrimitiveType.F32, "%f1", "%f2")
        val ptx = builder.build()

        expect(ptx).to_contain("max.f32 %f0, %f1, %f2;")

# ============================================================================
# PTX Control Flow
# ============================================================================

describe "PTX Builder - Control Flow":
    """
    ## Branch and Label Generation

    Tests control flow instruction generation.
    """

    it "generates unconditional branch":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_branch("BB1")
        val ptx = builder.build()

        expect(ptx).to_contain("bra BB1;")

    it "generates conditional branch":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_branch_if("%p0", "BB_true")
        val ptx = builder.build()

        expect(ptx).to_contain("@%p0 bra BB_true;")

    it "generates negated conditional branch":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_branch_if_not("%p0", "BB_false")
        val ptx = builder.build()

        expect(ptx).to_contain("@!%p0 bra BB_false;")

    it "generates labels":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_label("BB0")
        builder.emit_line("nop;")
        val ptx = builder.build()

        expect(ptx).to_contain("BB0:")

    it "generates return instruction":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_ret()
        val ptx = builder.build()

        expect(ptx).to_contain("ret;")

    it "generates exit instruction":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_exit()
        val ptx = builder.build()

        expect(ptx).to_contain("exit;")

# ============================================================================
# PTX Device Function Calls
# ============================================================================

describe "PTX Builder - Function Calls":
    """
    ## Device Function Call Generation

    Tests call instruction generation for device functions.
    """

    it "generates function call with return value":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_call("%r0", PrimitiveType.I64, "device_func", ["%r1", "%r2"])
        val ptx = builder.build()

        expect(ptx).to_contain("call (%r0), device_func, (%r1, %r2);")

    it "generates void function call":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_call_void("void_func", ["%r0"])
        val ptx = builder.build()

        expect(ptx).to_contain("call void_func, (%r0);")

# ============================================================================
# CUDA Type Mapper
# ============================================================================

describe "CUDA Type Mapper - Primitive Types":
    """
    ## Type Mapping Verification

    Tests CUDA type mapper for correct PTX type strings.
    """

    it "maps integer types to PTX":
        val mapper = CudaTypeMapper__create_sm(8, 6)
        expect(mapper.ptx_type(PrimitiveType.I64)).to_equal(".s64")
        expect(mapper.ptx_type(PrimitiveType.I32)).to_equal(".s32")
        expect(mapper.ptx_type(PrimitiveType.I16)).to_equal(".s16")
        expect(mapper.ptx_type(PrimitiveType.I8)).to_equal(".s8")

    it "maps unsigned integer types to PTX":
        val mapper = CudaTypeMapper__create_sm(8, 6)
        expect(mapper.ptx_type(PrimitiveType.U64)).to_equal(".u64")
        expect(mapper.ptx_type(PrimitiveType.U32)).to_equal(".u32")
        expect(mapper.ptx_type(PrimitiveType.U16)).to_equal(".u16")
        expect(mapper.ptx_type(PrimitiveType.U8)).to_equal(".u8")

    it "maps float types to PTX":
        val mapper = CudaTypeMapper__create_sm(8, 6)
        expect(mapper.ptx_type(PrimitiveType.F64)).to_equal(".f64")
        expect(mapper.ptx_type(PrimitiveType.F32)).to_equal(".f32")
        expect(mapper.ptx_type(PrimitiveType.F16)).to_equal(".f16")

    it "maps bool to predicate":
        val mapper = CudaTypeMapper__create_sm(8, 6)
        expect(mapper.ptx_type(PrimitiveType.Bool)).to_equal(".pred")

describe "CUDA Type Mapper - Compute Capabilities":
    """
    ## Compute Capability Feature Detection

    Tests feature detection based on GPU compute capability.
    """

    it "detects half precision support":
        val mapper_old = CudaTypeMapper__create_sm(5, 0)
        val mapper_new = CudaTypeMapper__create_sm(7, 0)
        expect(mapper_old.supports_half_precision()).to_equal(false)
        expect(mapper_new.supports_half_precision()).to_equal(true)

    it "detects tensor core support":
        val mapper_old = CudaTypeMapper__create_sm(6, 1)
        val mapper_new = CudaTypeMapper__create_sm(7, 0)
        expect(mapper_old.supports_tensor_cores()).to_equal(false)
        expect(mapper_new.supports_tensor_cores()).to_equal(true)

    it "reports correct max threads per block":
        val mapper = CudaTypeMapper__create_sm(8, 6)
        expect(mapper.max_threads_per_block()).to_equal(1024)

    it "reports correct warp size":
        val mapper = CudaTypeMapper__create_sm(8, 6)
        expect(mapper.warp_size()).to_equal(32)

    it "reports correct shared memory for Ampere":
        val mapper = CudaTypeMapper__create_sm(8, 6)
        expect(mapper.max_shared_memory()).to_equal(163840)

    it "reports correct shared memory for Volta":
        val mapper = CudaTypeMapper__create_sm(7, 0)
        val shared_mem = mapper.max_shared_memory()
        expect(shared_mem).to_equal(96 * 1024)

describe "CUDA Type Mapper - Memory Spaces":
    """
    ## Memory Space Mapping

    Tests PTX state space mapping.
    """

    it "maps global memory space":
        val mapper = CudaTypeMapper__create_sm(8, 6)
        expect(mapper.ptx_state_space(MemorySpace.Global)).to_equal(".global")

    it "maps shared memory space":
        val mapper = CudaTypeMapper__create_sm(8, 6)
        expect(mapper.ptx_state_space(MemorySpace.Shared)).to_equal(".shared")

    it "maps local memory space":
        val mapper = CudaTypeMapper__create_sm(8, 6)
        expect(mapper.ptx_state_space(MemorySpace.Local)).to_equal(".local")

    it "maps constant memory space":
        val mapper = CudaTypeMapper__create_sm(8, 6)
        expect(mapper.ptx_state_space(MemorySpace.Constant)).to_equal(".const")

# ============================================================================
# Launch Configuration Tests
# ============================================================================

describe "Launch Configuration":
    """
    ## Kernel Launch Configuration

    Tests launch configuration validation and computation.
    """

    it "creates 1D launch config":
        val config = LaunchConfig__for_1d(1024, 256)
        expect(config.grid_x).to_equal(4)
        expect(config.grid_y).to_equal(1)
        expect(config.grid_z).to_equal(1)
        expect(config.block_x).to_equal(256)
        expect(config.total_threads()).to_equal(1024)

    it "rounds up grid size for non-divisible total":
        val config = LaunchConfig__for_1d(1000, 256)
        expect(config.grid_x).to_equal(4)
        expect(config.total_threads()).to_be_greater_than(999)

    it "creates 2D launch config":
        val config = LaunchConfig__for_2d(512, 512, 16, 16)
        expect(config.grid_x).to_equal(32)
        expect(config.grid_y).to_equal(32)
        expect(config.block_x).to_equal(16)
        expect(config.block_y).to_equal(16)

    it "computes total blocks":
        val config = LaunchConfig__for_2d(512, 512, 16, 16)
        expect(config.total_blocks()).to_equal(1024)

    it "computes threads per block":
        val config = LaunchConfig__for_2d(512, 512, 16, 16)
        expect(config.threads_per_block()).to_equal(256)

    it "validates valid config":
        val config = LaunchConfig__for_1d(1024, 256)
        val err = config.validate()
        expect(err).to_be_nil()

    it "rejects zero block size":
        val config = LaunchConfig__for_1d(1024, 0)
        val err = config.validate()
        expect(err).to_be_nil()  # for_1d with 0 produces invalid config
        # The grid would be computed with division by zero;
        # real validation catches block dims

    it "adds shared memory to config":
        val config = LaunchConfig__for_1d(1024, 256).with_shared_mem(4096)
        expect(config.shared_mem_bytes).to_equal(4096)
        expect(config.block_x).to_equal(256)

# ============================================================================
# Constant Loading
# ============================================================================

describe "PTX Builder - Constants":
    """
    ## Constant Loading

    Tests constant value loading instructions.
    """

    it "loads integer constant":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_const_int("%r0", PrimitiveType.I64, 42)
        val ptx = builder.build()

        expect(ptx).to_contain("mov.s64 %r0, 42;")

    it "loads unsigned integer constant":
        var builder = PtxBuilder__create((8, 6))
        builder.emit_const_int("%r0", PrimitiveType.U32, 100)
        val ptx = builder.build()

        expect(ptx).to_contain("mov.u32 %r0, 100;")
