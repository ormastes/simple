"""
# Parser Literal Tokenization Specification


**Feature IDs:** #PARSER-LIT-001 to #PARSER-LIT-020
**Category:** Infrastructure | Parser
**Status:** Implemented

Tests that the parser correctly tokenizes and parses various literal types
including integers, floats, strings, booleans, symbols, and nil.

## Syntax

```simple
42              # Integer
0xFF            # Hex integer
0b1010          # Binary integer
0o77            # Octal integer
3.14            # Float
1.0e10          # Scientific notation
"hello"         # Interpolated string
'raw'           # Raw string
r"raw{NL}"        # Raw string (r prefix)
true false      # Booleans
nil             # Nil value
:symbol         # Symbol literal
```
"""
use std.string.{NL}
use std.string.{NL}



# ============================================================================
# Test Group 1: Integer Literals
# ============================================================================

describe "Integer Literal Parsing":
    """
    ## Decimal, Hex, Binary, Octal

    Tests that integer literals in various bases are correctly parsed.
    """

    context "decimal integers":
        it "parses simple decimal":
            val x = 42
            expect x == 42

        it "parses zero":
            val x = 0
            expect x == 0

        it "parses with underscores":
            val x = 1_000_000
            expect x == 1000000

        it "parses large numbers":
            val x = 9_223_372_036_854_775_807
            expect x > 0

    context "hexadecimal integers":
        it "parses hex with lowercase":
            val x = 0xff
            expect x == 255

        it "parses hex with uppercase":
            val x = 0xFF
            expect x == 255

        it "parses complex hex":
            val x = 0x1A2B
            expect x == 6699

    context "binary integers":
        it "parses simple binary":
            val x = 0b1010
            expect x == 10

        it "parses binary with underscores":
            val x = 0b1111_0000
            expect x == 240

        it "parses single bit":
            val x = 0b1
            expect x == 1

    context "octal integers":
        it "parses octal":
            val x = 0o77
            expect x == 63

        it "parses octal with zeros":
            val x = 0o755
            expect x == 493


# ============================================================================
# Test Group 2: Float Literals
# ============================================================================

describe "Float Literal Parsing":
    """
    ## Decimal and Scientific Notation

    Tests floating point literal parsing including scientific notation.
    """

    context "simple floats":
        it "parses decimal float":
            val x = 3.14
            expect x > 3.0
            expect x < 4.0

        it "parses float with leading zero":
            val x = 0.5
            expect x == 0.5

        it "parses whole number float":
            val x = 1.0
            expect x == 1.0

    context "scientific notation":
        it "parses positive exponent":
            val x = 1.0e10
            expect x == 10000000000.0

        it "parses negative exponent":
            val x = 2.5e-3
            expect x < 0.003

        it "parses uppercase E":
            val x = 1.5E5
            expect x == 150000.0


# ============================================================================
# Test Group 3: String Literals
# ============================================================================

describe "String Literal Parsing":
    """
    ## Interpolated, Raw, and Triple-Quoted Strings

    Tests string literal parsing with escape sequences and interpolation.
    """

    context "double-quoted strings (interpolated)":
        it "parses simple string":
            val s = "hello"
            expect s == "hello"

        it "parses escape sequences":
            val s = "hello{NL}world"
            expect s.contains("{NL}")

        it "parses tab escape":
            val s = "tab\there"
            expect s.contains("\t")

        it "interpolates variables":
            val name = "Alice"
            val s = "hello {name}"
            expect s == "hello Alice"

        it "interpolates expressions":
            val x = 6
            val y = 7
            val s = "result: {x * y}"
            expect s == "result: 42"

        it "escapes braces":
            val s = "literal {{braces}}"
            expect s == r"literal {braces}"

    context "single-quoted strings (raw)":
        it "parses raw string":
            val s = 'hello'
            expect s == "hello"

        it "does not process escapes":
            val s = 'hello{NL}world'
            expect s.contains("\{NL}")

        it "does not interpolate":
            val s = '{name}'
            expect s == r"{name}"

    context "raw prefix strings":
        it "parses r-prefix string":
            val s = r"hello"
            expect s == "hello"

        it "keeps backslashes literal":
            val s = r"hello{NL}world"
            expect s.contains("\{NL}")

        it "keeps braces literal":
            val s = r"{name}"
            expect s == r"{name}"

    context "triple-quoted strings":
        it "parses triple-quoted":
            val s = """hello"""
            expect s == "hello"

        it "preserves newlines":
            val s = """line1
line2"""
            expect s.contains("{NL}")

        it "does not interpolate by default":
            val s = """{name}"""
            expect s == r"{name}"

    context "triple-quoted f-strings":
        it "parses f-prefix triple-quoted":
            val s = f"""hello"""
            expect s == "hello"

        it "interpolates in f-strings":
            val name = "world"
            val s = f"""hello {name}"""
            expect s == "hello world"


# ============================================================================
# Test Group 4: Boolean Literals
# ============================================================================

describe "Boolean Literal Parsing":
    """
    ## true and false Keywords

    Tests that boolean literals are correctly parsed.
    """

    it "parses true":
        val x = true
        expect x == true

    it "parses false":
        val x = false
        expect x == false

    it "uses booleans in conditions":
        val condition = true
        if condition:
            expect true
        else:
            expect false  # Should not reach


# ============================================================================
# Test Group 5: Nil Literal
# ============================================================================

describe "Nil Literal Parsing":
    """
    ## nil Keyword

    Tests that the nil literal is correctly parsed.
    """

    it "parses nil":
        val x = nil
        expect x == nil

    it "nil equals nil":
        expect nil == nil


# ============================================================================
# Test Group 6: Symbol Literals
# ============================================================================

describe "Symbol Literal Parsing":
    """
    ## :symbol Syntax

    Tests that symbol literals with colon prefix are correctly parsed.
    """

    it "parses simple symbol":
        val s = :ok
        expect s == :ok

    it "parses symbol with underscore":
        val s = :error_code
        expect s == :error_code

    it "symbols are comparable":
        expect :ok == :ok
        expect :ok != :error


# ============================================================================
# Test Group 7: Collection Literals
# ============================================================================

describe "Collection Literal Parsing":
    """
    ## Arrays, Tuples, and Dictionaries

    Tests parsing of collection literal syntax.
    """

    context "array literals":
        it "parses array":
            val arr = [1, 2, 3]
            expect arr.len() == 3

        it "parses empty array":
            val arr = []
            expect arr.len() == 0

        it "parses nested array":
            val arr = [[1, 2], [3, 4]]
            expect arr[0][1] == 2

    context "tuple literals":
        it "parses tuple":
            val t = (1, 2, 3)
            expect t.0 == 1

        it "parses unit tuple":
            val t = ()
            expect true  # Compiles successfully

        it "parses two-element tuple":
            val t = (42, "hello")
            expect t.0 == 42

    context "dictionary literals":
        it "parses dictionary":
            val d = {"a": 1, "b": 2}
            expect d["a"] == 1

        it "parses empty dictionary":
            val d = {}
            expect d.len() == 0


# ============================================================================
# Test Group 8: Numeric Literal Edge Cases
# ============================================================================

describe "Numeric Literal Edge Cases":
    """
    ## Special Cases and Boundaries

    Tests edge cases in numeric literal parsing.
    """

    it "parses negative integers":
        val x = -42
        expect x == -42

    it "parses negative floats":
        val x = -3.14
        expect x < 0.0

    it "parses very small float":
        val x = 0.000001
        expect x > 0.0

    it "parses integer with many underscores":
        val x = 1_2_3_4_5
        expect x == 12345
