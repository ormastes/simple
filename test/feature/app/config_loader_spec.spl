"""
# Config Loader Specification


**Feature ID:** TBD
**Category:** Configuration / File Loading
**Status:** Implemented

## Overview

The config loader provides a Simple-native configuration format using `.spl`
syntax with variable assignments. It supports hierarchical config loading
with directory-based precedence.

## Config File Format

```simple
# Numbers
port = 8080
timeout = 30.5

# Booleans
logging = true
debug = false

# Strings
name = "MyApp"

# Identifiers (constants)
mode = PRODUCTION

# Arrays
ports = [8080, 8081, 8082]

# Nested values (dotted keys)
train.epochs = 100
train.lr = 0.001
```

## Hierarchy & Precedence

Config files are searched from the current directory up to the project root.
Configs closer to the current directory override those higher in the hierarchy.

```
/project/__init__.spl          (lowest precedence)
/project/subdir/__init__.spl   (highest precedence)
```
"""

use config


# ============================================================================
# Config File Parsing
# ============================================================================

describe "Config File Parsing":
    """
    Parse Simple-syntax config files into Config objects.
    """

    it "parses basic integers":
        val content = "port = 8080"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["port"]).to_equal(8080)
            case Err(_):
                fail("Parse failed")

    it "parses floats":
        val content = "timeout = 30.5"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["timeout"]).to_equal(30.5)
            case Err(_):
                fail("Parse failed")

    it "parses booleans":
        val content = "logging = true\ndebug = false"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["logging"]).to_equal(true)
                expect(dict["debug"]).to_equal(false)
            case Err(_):
                fail("Parse failed")

    it "parses strings":
        val content = "name = \"MyApp\""
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["name"]).to_equal("MyApp")
            case Err(_):
                fail("Parse failed")

    it "parses identifiers as constants":
        val content = "mode = PRODUCTION"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["mode"]).to_equal("PRODUCTION")
            case Err(_):
                fail("Parse failed")

    it "parses arrays":
        val content = "ports = [8080, 8081, 8082]"
        match config.parse_config_file(content):
            case Ok(dict):
                val ports = dict["ports"]
                expect(ports.len()).to_equal(3)
                expect(ports[0]).to_equal(8080)
                expect(ports[1]).to_equal(8081)
                expect(ports[2]).to_equal(8082)
            case Err(_):
                fail("Parse failed")

    it "parses nested values with dotted keys":
        val content = "train.epochs = 100\ntrain.lr = 0.001"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["train"]["epochs"]).to_equal(100)
                expect(dict["train"]["lr"]).to_equal(0.001)
            case Err(_):
                fail("Parse failed")

    it "skips comments":
        val content = "# This is a comment\nport = 8080\n# Another comment"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["port"]).to_equal(8080)
            case Err(_):
                fail("Parse failed")

    it "skips empty lines":
        val content = "port = 8080\n\nlogging = true"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["port"]).to_equal(8080)
                expect(dict["logging"]).to_equal(true)
            case Err(_):
                fail("Parse failed")

    it "handles multiline config":
        val content = """
            port = 8080
            timeout = 30.5
            logging = true
            app_name = "MyApp"
            mode = PRODUCTION
        """
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["port"]).to_equal(8080)
                expect(dict["timeout"]).to_equal(30.5)
                expect(dict["logging"]).to_equal(true)
                expect(dict["app_name"]).to_equal("MyApp")
                expect(dict["mode"]).to_equal("PRODUCTION")
            case Err(_):
                fail("Parse failed")


# ============================================================================
# File Loading
# ============================================================================

describe "Config File Loading":
    """
    Load config from files on disk.
    """

    it "loads basic config from file":
        val fixture_path = "simple/test/fixtures/config/basic_config.spl"
        match config.from_file(fixture_path):
            case Ok(cfg):
                match cfg.get("port"):
                    case Some(p): expect(p).to_equal(8080)
                    case None: fail("Port not found")
                match cfg.get("logging"):
                    case Some(l): expect(l).to_equal(true)
                    case None: fail("Logging not found")
            case Err(msg):
                fail("Load failed: " + msg)

    it "loads nested config from file":
        val fixture_path = "simple/test/fixtures/config/nested_config.spl"
        match config.from_file(fixture_path):
            case Ok(cfg):
                match cfg.get("server.port"):
                    case Some(p): expect(p).to_equal(8080)
                    case None: fail("server.port not found")
                match cfg.get("train.epochs"):
                    case Some(e): expect(e).to_equal(100)
                    case None: fail("train.epochs not found")
            case Err(msg):
                fail("Load failed: " + msg)

    it "returns error for non-existent file":
        match config.from_file("nonexistent.spl"):
            case Ok(_):
                fail("Should have failed")
            case Err(msg):
                # Success - expected error
                pass


# ============================================================================
# Hierarchical Loading
# ============================================================================

describe "Hierarchical Config Loading":
    """
    Load and merge configs from directory hierarchy.
    """

    it "loads from single config file":
        val root_path = "simple/test/fixtures/config/hierarchy/project_root.spl"
        match config.from_hierarchy(root_path):
            case Ok(cfg):
                match cfg.get("port"):
                    case Some(p): expect(p).to_equal(8080)
                    case None: fail("Port not found")
                match cfg.get("project_name"):
                    case Some(n): expect(n).to_equal("MyProject")
                    case None: fail("Project name not found")
            case Err(msg):
                fail("Load failed: " + msg)

    it "returns empty config when no files found":
        match config.from_hierarchy("/nonexistent/path"):
            case Ok(cfg):
                match cfg.get("anything"):
                    case Some(_): fail("Should be empty")
                    case None: pass  # Expected
            case Err(msg):
                fail("Should return empty config, not error: " + msg)


# ============================================================================
# Config Access
# ============================================================================

describe "Config Access":
    """
    Access config values using plain dict operations.
    """

    it "gets simple values":
        val cfg = {"port": 8080, "logging": true}
        expect cfg["port"] == 8080
        expect cfg["logging"] == true

    it "gets nested values":
        val cfg = {"server": {"port": 8080}}
        expect cfg["server"]["port"] == 8080

    it "handles missing keys with default":
        val cfg = {"port": 8080}
        val missing = cfg["missing"] ?? nil
        expect missing == nil


# ============================================================================
# Config Merging
# ============================================================================

describe "Config Merging":
    """

    Merge multiple configs with precedence using dict merge.
    """

    it "merges configs with overlay precedence":
        val base = {"a": 1, "b": 2}
        val overlay = {"b": 3, "c": 4}
        var merged = {}
        for key in base.keys():
            merged[key] = base[key]
        for key in overlay.keys():
            merged[key] = overlay[key]

        expect merged["a"] == 1
        expect merged["b"] == 3
        expect merged["c"] == 4
