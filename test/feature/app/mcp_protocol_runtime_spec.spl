# # MCP Protocol Runtime Spec
#
# Wire-level protocol checks for active simple-mcp server wrapper.

use std.spec
use app.io.mod.{shell}

extern fn rt_file_write_text(path: text, content: text) -> bool

fn mcp_msg(body: text) -> text:
    "Content-Length: " + body.len().to_string() + "\r\n\r\n" + body

fn init_request(id: text) -> text:
    val body = "{\"jsonrpc\":\"2.0\",\"id\":\"" + id + "\",\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-06-18\",\"capabilities\":{},\"clientInfo\":{\"name\":\"spec\",\"version\":\"1.0\"}}}"
    mcp_msg(body)

fn initialized_notification() -> text:
    mcp_msg("{\"jsonrpc\":\"2.0\",\"method\":\"initialized\",\"params\":{}}")

fn shutdown_request(id: text) -> text:
    mcp_msg("{\"jsonrpc\":\"2.0\",\"id\":\"" + id + "\",\"method\":\"shutdown\",\"params\":{}}")

fn generic_request(id: text, method: text, params_json: text) -> text:
    val body = "{\"jsonrpc\":\"2.0\",\"id\":\"" + id + "\",\"method\":\"" + method + "\",\"params\":" + params_json + "}"
    mcp_msg(body)

fn send_mcp(messages: text) -> text:
    val tmp = "/tmp/mcp_protocol_runtime_input.txt"
    rt_file_write_text(tmp, messages)
    val result = shell("cat " + tmp + " | bin/simple_mcp_server 2>/dev/null")
    result.stdout ?? ""

describe "MCP Protocol Runtime":

    it "preserves string id in initialize response":
        val input = init_request("abc-1") + initialized_notification() + shutdown_request("z")
        val output = send_mcp(input)
        expect(output.contains("\"id\":\"abc-1\"")).to_equal(true)
        expect(output.contains("\"capabilities\"")).to_equal(true)

    it "supports resources templates and read":
        val req1 = generic_request("2", "resources/templates/list", "{}")
        val req2 = generic_request("3", "resources/read", "{\"uri\":\"project:///info\"}")
        val input = init_request("1") + initialized_notification() + req1 + req2 + shutdown_request("4")
        val output = send_mcp(input)
        expect(output.contains("resourceTemplates")).to_equal(true)
        expect(output.contains("project:///info")).to_equal(true)
        expect(output.contains("Working Dir")).to_equal(true)

    it "supports prompts get":
        val req = generic_request("2", "prompts/get", "{\"name\":\"analyze-file\",\"arguments\":{\"path\":\"src/app/mcp/main_lazy.spl\"}}")
        val input = init_request("1") + initialized_notification() + req + shutdown_request("3")
        val output = send_mcp(input)
        expect(output.contains("\"description\":\"Analyze file\"")).to_equal(true)
        expect(output.contains("\"messages\"")).to_equal(true)

    it "supports completion endpoint":
        val req = generic_request("2", "completion/complete", "{\"ref\":{\"type\":\"ref/prompt\",\"name\":\"analyze-file\"},\"argument\":{\"name\":\"path\",\"value\":\"src\"}}")
        val input = init_request("1") + initialized_notification() + req + shutdown_request("3")
        val output = send_mcp(input)
        expect(output.contains("\"completion\"")).to_equal(true)
        expect(output.contains("\"values\":[")).to_equal(true)
        expect(output.contains("src/")).to_equal(true)

    it "supports logging and roots endpoints":
        val req1 = generic_request("2", "logging/setLevel", "{\"level\":\"debug\"}")
        val req2 = generic_request("3", "roots/list", "{}")
        val input = init_request("1") + initialized_notification() + req1 + req2 + shutdown_request("4")
        val output = send_mcp(input)
        expect(output.contains("\"level\":\"debug\"")).to_equal(true)
        expect(output.contains("\"roots\":[")).to_equal(true)
        expect(output.contains("\"uri\":\"file://")).to_equal(true)

    it "returns tool-level isError for unknown tool":
        val req = generic_request("2", "tools/call", "{\"name\":\"no_such_tool\",\"arguments\":{}}")
        val input = init_request("1") + initialized_notification() + req + shutdown_request("3")
        val output = send_mcp(input)
        expect(output.contains("\"isError\":true")).to_equal(true)
        expect(output.contains("Unknown tool")).to_equal(true)
        expect(output.contains("\"error\":")).to_equal(false)

    it "exposes required fields in tool schemas":
        val req = generic_request("2", "tools/list", "{}")
        val input = init_request("1") + initialized_notification() + req + shutdown_request("3")
        val output = send_mcp(input)
        expect(output.contains("\"name\":\"simple_read\"")).to_equal(true)
        expect(output.contains("\"required\":[\"path\"]")).to_equal(true)
        expect(output.contains("\"annotations\"")).to_equal(true)

    it "returns structuredContent with inferred type and shape":
        val req = generic_request("2", "tools/call", "{\"name\":\"debug_log_status\",\"arguments\":{}}")
        val input = init_request("1") + initialized_notification() + req + shutdown_request("3")
        val output = send_mcp(input)
        expect(output.contains("\"structuredContent\"")).to_equal(true)
        expect(output.contains("\"inferredType\":\"object\"")).to_equal(true)
        expect(output.contains("\"shape\":\"object")).to_equal(true)
