# # MCP Protocol Runtime Spec
#
# Wire-level protocol checks for active simple-mcp server wrapper.

use std.spec
use app.io.mod.{shell}

extern fn rt_file_write_text(path: text, content: text) -> bool

fn mcp_msg(body: text) -> text:
    "Content-Length: " + body.len().to_string() + "\r\n\r\n" + body

fn init_request(id: text) -> text:
    val body = "{\"jsonrpc\":\"2.0\",\"id\":\"" + id + "\",\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-06-18\",\"capabilities\":{},\"clientInfo\":{\"name\":\"spec\",\"version\":\"1.0\"}}}"
    mcp_msg(body)

fn initialized_notification() -> text:
    mcp_msg("{\"jsonrpc\":\"2.0\",\"method\":\"initialized\",\"params\":{}}")

fn shutdown_request(id: text) -> text:
    mcp_msg("{\"jsonrpc\":\"2.0\",\"id\":\"" + id + "\",\"method\":\"shutdown\",\"params\":{}}")

fn generic_request(id: text, method: text, params_json: text) -> text:
    val body = "{\"jsonrpc\":\"2.0\",\"id\":\"" + id + "\",\"method\":\"" + method + "\",\"params\":" + params_json + "}"
    mcp_msg(body)

fn send_mcp(messages: text) -> text:
    val mk = shell("mktemp /tmp/mcp_protocol_runtime_input.XXXXXX")
    val tmp = mk.stdout.trim()
    rt_file_write_text(tmp, messages)
    val result = shell("cat " + tmp + " | bin/simple_mcp_server 2>/dev/null; rm -f " + tmp)
    result.stdout ?? ""

describe "MCP Protocol Runtime":

    it "supports protocol/runtime matrix in one session":
        val req1 = generic_request("2", "resources/templates/list", "{}")
        val req2 = generic_request("3", "resources/read", "{\"uri\":\"project:///info\"}")
        val req3 = generic_request("4", "prompts/get", "{\"name\":\"analyze-file\",\"arguments\":{\"path\":\"src/app/mcp/main_lazy.spl\"}}")
        val req4 = generic_request("5", "completion/complete", "{\"ref\":{\"type\":\"ref/prompt\",\"name\":\"analyze-file\"},\"argument\":{\"name\":\"path\",\"value\":\"src\"}}")
        val req5 = generic_request("6", "logging/setLevel", "{\"level\":\"debug\"}")
        val req6 = generic_request("7", "roots/list", "{}")
        val req7 = generic_request("8", "tools/call", "{\"name\":\"no_such_tool\",\"arguments\":{}}")
        val req8 = generic_request("9", "tools/list", "{}")
        val req9 = generic_request("10", "tools/call", "{\"name\":\"debug_log_status\",\"arguments\":{}}")
        val input = init_request("abc-1") + initialized_notification() + req1 + req2 + req3 + req4 + req5 + req6 + req7 + req8 + req9 + shutdown_request("11")
        val output = send_mcp(input)
        expect(output.contains("\"id\":\"abc-1\"")).to_equal(true)
        expect(output.contains("\"capabilities\"")).to_equal(true)
        expect(output.contains("resourceTemplates")).to_equal(true)
        expect(output.contains("project:///info")).to_equal(true)
        expect(output.contains("Working Dir")).to_equal(true)
        expect(output.contains("\"description\":\"Analyze file\"")).to_equal(true)
        expect(output.contains("\"messages\"")).to_equal(true)
        expect(output.contains("\"completion\"")).to_equal(true)
        expect(output.contains("\"values\":[")).to_equal(true)
        expect(output.contains("src/")).to_equal(true)
        expect(output.contains("\"level\":\"debug\"")).to_equal(true)
        expect(output.contains("\"roots\":[")).to_equal(true)
        expect(output.contains("\"uri\":\"file://")).to_equal(true)
        expect(output.contains("\"isError\":true")).to_equal(true)
        expect(output.contains("Unknown tool")).to_equal(true)
        expect(output.contains("\"error\":")).to_equal(false)
        expect(output.contains("\"name\":\"simple_read\"")).to_equal(true)
        expect(output.contains("\"required\":[\"path\"]")).to_equal(true)
        expect(output.contains("\"annotations\"")).to_equal(true)
        expect(output.contains("\"structuredContent\"")).to_equal(true)
        expect(output.contains("\"inferredType\":\"object\"")).to_equal(true)
        expect(output.contains("\"shape\":\"object")).to_equal(true)
