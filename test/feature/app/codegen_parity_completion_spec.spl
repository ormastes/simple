# # Codegen Parity Completion Specification
#
#
# **Feature ID:** #CODEGEN-PARITY-001
# **Category:** Compilation
# **Status:** In Progress
#
# ## Overview
#
# Tests for code generation parity across backends (Interpreter, Cranelift JIT, LLVM).
# Each test exercises a specific MIR instruction category and verifies consistent
# results regardless of backend.
#
# ## Key Concepts
#
# | Concept | Description |
# |---------|-------------|
# | Backend Parity | Same source produces same result on all backends |
# | MIR Category | Group of related MIR instructions (constants, binops, control flow, etc.) |
# | Instruction Coverage | Each test targets specific MIR instruction(s) |
#
# ## Behavior
#
# - Every MIR instruction category is exercised at least once
# - Tests use only i64 returns for deterministic comparison
# - Tests are grouped by MIR category matching the Rust integration tests



# ============================================================================
# Top-level type definitions (must be outside describe blocks)
# ============================================================================

fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")
struct Point:
    x: i64
    y: i64

struct Inner:
    v: i64

struct Outer:
    a: i64
    b: i64

struct A:
    val_: i64

struct B:
    a: A

struct C:
    b: B

struct Counter:
    count: i64

impl Counter:
    me increment():
        self.count = self.count + 1

struct BigStruct:
    a: i64
    b: i64
    c: i64
    d: i64

enum Color:
    Red
    Green
    Blue

enum Shape:
    Circle(i64)
    Rect(i64, i64)

enum Op:
    Add
    Sub
    Mul

enum Wrapper:
    Val(i64)
    None_

fn helper_add(a, b):
    return a + b

fn helper_double(x):
    return x * 2

fn helper_add_doubled(a, b):
    return helper_double(a) + helper_double(b)

fn apply_op(op: Op, a: i64, b: i64) -> i64:
    match op:
        Op.Add: a + b
        Op.Sub: a - b
        Op.Mul: a * b

fn factorial(n: i64) -> i64:
    if n <= 1:
        return 1
    return n * factorial(n - 1)

fn classify(x: i64) -> i64:
    if x > 100:
        return 1
    if x > 50:
        return 2
    return 3

fn f1() -> i64:
    val a = 10
    val b = 20
    return a + b

fn f2() -> i64:
    val c = 12
    return c

fn implicit_value() -> i64:
    42

fn scoped_work() -> i64:
    val x: i64 = 10
    val y: i64 = 32
    return x + y

fn do_nothing():
    return

fn side_effect() -> i64:
    val _ = 10 + 20
    42

val GLOBAL_ANSWER = 42

fn ensure_positive(x: i64) -> i64:
    # ensures: result > 0
    return x

fn with_precondition(x: i64) -> i64:
    # requires: x > 0
    return x * 2


# ============================================================================
# Test Group 1: Constants
# ============================================================================

describe "Constants":
    # ## Constant Values
    #
    # Compile-time constant literals: integer, float, boolean.

    it "integer constant":
        val result = 42
        expect result == 42

    it "float constant cast to int":
        val x: f64 = 3.7
        val result = x as i64
        expect result == 3

    it "boolean true":
        val result = if true: 1 else: 0
        expect result == 1

    it "boolean false":
        val result = if false: 1 else: 0
        expect result == 0


# ============================================================================
# Test Group 2: Core Arithmetic Operations
# ============================================================================

describe "Core Arithmetic":
    # ## Binary Arithmetic Operations
    #
    # Addition, subtraction, multiplication, division, modulo.

    it "addition":
        expect 30 + 12 == 42

    it "subtraction":
        expect 50 - 8 == 42

    it "multiplication":
        expect 6 * 7 == 42

    it "division":
        expect 84 / 2 == 42

    it "modulo":
        expect 47 % 5 == 2

    it "nested arithmetic":
        expect (10 + 20) * 2 - 18 == 42

    it "copy operation":
        val x = 42
        val y = x
        expect y == 42


# ============================================================================
# Test Group 3: Comparison Operations
# ============================================================================

describe "Comparison Operations":
    # ## Relational Operators
    #
    # All six comparison operators: ==, !=, <, <=, >, >=.

    it "equal - true":
        expect (if 5 == 5: 1 else: 0) == 1

    it "equal - false":
        expect (if 5 == 3: 1 else: 0) == 0

    it "not equal - true":
        expect (if 5 != 3: 1 else: 0) == 1

    it "not equal - false":
        expect (if 5 != 5: 1 else: 0) == 0

    it "less than - true":
        expect (if 3 < 5: 1 else: 0) == 1

    it "less than - false":
        expect (if 5 < 3: 1 else: 0) == 0

    it "less than or equal - equal":
        expect (if 5 <= 5: 1 else: 0) == 1

    it "less than or equal - false":
        expect (if 6 <= 5: 1 else: 0) == 0

    it "greater than - true":
        expect (if 7 > 3: 1 else: 0) == 1

    it "greater than - false":
        expect (if 3 > 7: 1 else: 0) == 0

    it "greater than or equal - equal":
        expect (if 5 >= 5: 1 else: 0) == 1

    it "greater than or equal - false":
        expect (if 3 >= 5: 1 else: 0) == 0


# ============================================================================
# Test Group 4: Logical Operations
# ============================================================================

describe "Logical Operations":
    # ## Boolean Operators
    #
    # Short-circuit and, or, and bitwise xor.

    it "logical and - true":
        expect (if true and true: 1 else: 0) == 1

    it "logical and - false":
        expect (if true and false: 1 else: 0) == 0

    it "logical or - true":
        expect (if false or true: 1 else: 0) == 1

    it "logical or - false":
        expect (if false or false: 1 else: 0) == 0

    it "bitwise xor":
        expect (5 xor 3) == 6


# ============================================================================
# Test Group 5: Unary Operations
# ============================================================================

describe "Unary Operations":
    # ## Unary Operators
    #
    # Negation and logical not.

    it "negation":
        val x = -10
        expect (0 - x) == 10

    it "logical not":
        expect (if not false: 1 else: 0) == 1


# ============================================================================
# Test Group 6: Cast Operations
# ============================================================================

describe "Cast Operations":
    # ## Type Casting
    #
    # Integer to float and float to integer conversions.

    it "int to float to int roundtrip":
        val x: i64 = 42
        val f: f64 = x as f64
        val back: i64 = f as i64
        expect back == 42

    it "float truncation":
        val f: f64 = 3.9
        val i: i64 = f as i64
        expect i == 3


# ============================================================================
# Test Group 7: Control Flow
# ============================================================================

describe "Control Flow":
    # ## Branching and Loops
    #
    # If-else, while, for, break, continue.

    it "if-else true branch":
        val result = if true: 42 else: 0
        expect result == 42

    it "if-else false branch":
        val result = if false: 0 else: 42
        expect result == 42

    it "nested if-else":
        val x = 15
        val result = if x > 20: 1 else: if x > 10: 2 else: 3
        expect result == 2

    it "while loop accumulation":
        var sum = 0
        var i = 1
        while i <= 10:
            sum = sum + i
            i = i + 1
        expect sum == 55

    it "while with break":
        var i = 0
        while true:
            if i == 5:
                break
            i = i + 1
        expect i == 5

    it "while with continue":
        var sum = 0
        var i = 0
        while i < 10:
            i = i + 1
            if i % 2 == 0:
                continue
            sum = sum + i
        expect sum == 25

    it "for range exclusive":
        var sum = 0
        for i in 0..5:
            sum = sum + i
        expect sum == 10

    it "for range inclusive":
        var sum = 0
        for i in 0..=5:
            sum = sum + i
        expect sum == 15

    it "if expression without else":
        val x = 10
        if x > 100:
            val _ = 0
        expect x == 10

    it "while that does not execute":
        var x = 42
        while false:
            x = 0
        expect x == 42


# ============================================================================
# Test Group 8: Memory Operations
# ============================================================================

describe "Memory Operations":
    # ## Variable Assignment and Mutation
    #
    # Mutable variables, variable shadowing, scope cleanup.

    it "mutable variable assignment":
        var x: i64 = 0
        x = 42
        expect x == 42

    it "variable shadowing":
        val x = 10
        val x = 42
        expect x == 42

    it "scope cleanup":
        expect scoped_work() == 42


# ============================================================================
# Test Group 9: Struct and Field Operations
# ============================================================================

describe "Struct and Field Operations":
    # ## Struct Initialization and Field Access
    #
    # Construction, field get, nested structs.

    it "struct init and field access":
        val p = Point(x: 40, y: 2)
        expect p.x + p.y == 42

    it "nested struct":
        val inner = Inner(v: 10)
        val outer = Outer(a: inner.v, b: 32)
        expect outer.a + outer.b == 42

    it "deeply nested field access":
        val c = C(b: B(a: A(val_: 42)))
        expect c.b.a.val_ == 42


# ============================================================================
# Test Group 10: Collection Operations
# ============================================================================

describe "Collection Operations":
    # ## Arrays, Dicts, Tuples
    #
    # Literal construction, indexing, element types.

    it "array literal and indexing":
        var arr = [10, 20, 42, 30]
        expect arr[2] == 42

    it "empty array":
        var arr = []
        expect arr.len() == 0

    it "array with float elements":
        var arr = [1.5, 2.5, 3.5]
        expect arr.len() == 3

    it "array with bool elements":
        var arr = [true, false, true]
        expect arr.len() == 3

    it "dict literal":
        val d = {"a": 1, "b": 2, "c": 3}
        expect d["b"] == 2

    it "tuple literal and indexing":
        val t = (10, 32)
        expect t[0] + t[1] == 42

    it "tuple with float element":
        val t = (1, 2.5, 3)
        expect t[0] == 1

    it "tuple with bool element":
        val t = (true, 42)
        expect t[1] == 42

    it "negative array index":
        var arr = [10, 20, 42]
        expect arr[-1] == 42


# ============================================================================
# Test Group 11: String Operations
# ============================================================================

describe "String Operations":
    # ## String Literals and Interpolation
    #
    # Const strings, interpolation with different types.

    it "const string":
        val s = "hello"
        expect s == "hello"

    it "string interpolation with int":
        val x = 42
        val s = "value: {x}"
        expect s == "value: 42"

    it "string interpolation with float":
        val f = 3.14
        val s = "pi: {f}"
        expect s.len() > 0

    it "string as non-boxed value":
        val a = "hello"
        val b = a
        expect b == "hello"


# ============================================================================
# Test Group 12: Function Call Operations
# ============================================================================

describe "Function Calls":
    # ## Function Definitions, Calls, Recursion
    #
    # Simple calls, multi-arg, recursion, implicit return.

    it "simple function call":
        expect implicit_value() == 42

    it "function with parameters":
        expect helper_add(10, 32) == 42

    it "recursive function":
        expect factorial(5) == 120

    it "multiple functions with locals":
        expect f1() + f2() == 42

    it "implicit return":
        expect implicit_value() == 42

    it "nested function call":
        expect helper_add_doubled(10, 11) == 42


# ============================================================================
# Test Group 13: Closure Operations
# ============================================================================

describe "Closures":
    # ## Lambda Expressions and Captures
    #
    # Lambdas without captures, closures with captures.

    it "lambda no capture":
        val f = \x: x + 1
        expect f(41) == 42

    it "closure with capture":
        val offset = 40
        val f = \x: x + offset
        expect f(2) == 42


# ============================================================================
# Test Group 14: Method Calls
# ============================================================================

describe "Method Calls":
    # ## Builtin and User-Defined Methods
    #
    # String length, array push, mutable methods.

    it "string length":
        val s = "hello"
        expect s.len() == 5

    it "array push":
        var arr = [1, 2, 3]
        arr.push(4)
        expect arr.len() == 4

    it "mutable struct method":
        var c = Counter(count: 0)
        c.increment()
        c.increment()
        expect c.count == 2

    it "chained array operations":
        var arr = [1, 2, 3]
        arr.push(4)
        arr.push(5)
        expect arr.len() == 5


# ============================================================================
# Test Group 15: Enum Operations
# ============================================================================

describe "Enum Operations":
    # ## Enum Variants
    #
    # Unit variants, payload variants, multiple variants.

    it "enum unit variant":
        val c = Color.Red
        val result = match c:
            Color.Red: 42
            Color.Green: 0
            Color.Blue: 0
        expect result == 42

    it "enum with payload":
        val s = Shape.Circle(42)
        val result = match s:
            Shape.Circle(r): r
            Shape.Rect(w, h): w * h
        expect result == 42

    it "multiple enum variants":
        expect apply_op(Op.Add, 30, 12) == 42
        expect apply_op(Op.Sub, 50, 8) == 42
        expect apply_op(Op.Mul, 6, 7) == 42


# ============================================================================
# Test Group 16: Pattern Matching
# ============================================================================

describe "Pattern Matching":
    # ## Match Expressions
    #
    # Literal, binding, wildcard, enum, boolean, nested patterns.

    it "literal pattern":
        val x = 2
        val result = match x:
            1: 10
            2: 42
            3: 30
        expect result == 42

    it "binding pattern":
        val x = 42
        val result = match x:
            n: n
        expect result == 42

    it "wildcard pattern":
        val x = 99
        val result = match x:
            1: 0
            _: 42
        expect result == 42

    it "bool pattern":
        val b = true
        val result = match b:
            true: 42
            false: 0
        expect result == 42

    it "nested pattern matching":
        val w = Wrapper.Val(42)
        val result = match w:
            Wrapper.Val(x):
                match x:
                    42: 42
                    _: 0
            Wrapper.None_: 0
        expect result == 42


# ============================================================================
# Test Group 17: Pointer Operations
# ============================================================================

describe "Pointer Operations":
    # ## Reference and Dereference
    #
    # Pointer creation and dereference.

    it "pointer new and deref":
        val p = new &42
        val v = *p
        expect v == 42


# ============================================================================
# Test Group 18: Boxing and Unboxing
# ============================================================================

describe "Boxing and Unboxing":
    # ## Value Boxing
    #
    # Int, float, bool boxing for collections and generic contexts.

    it "box unbox int":
        val x: i64 = 42
        expect x == 42

    it "float in array":
        var arr = [1.5, 2.5, 3.5]
        val f = arr[0]
        expect f == 1.5

    it "index set with float value":
        var arr = [0.0, 0.0]
        arr[0] = 3.14
        expect arr[0] == 3.14

    it "index set with bool value":
        var arr = [false, false]
        arr[0] = true
        expect arr[0] == true


# ============================================================================
# Test Group 19: Option and Result Types
# ============================================================================

describe "Option and Result":
    # ## Option/Result Construction and Matching
    #
    # Some, None, Ok, Err.

    it "option some":
        val opt = Some(42)
        val result = match opt:
            Some(v): v
            None: 0
        expect result == 42

    it "option none":
        val opt = None
        val result = match opt:
            Some(v): v
            None: 42
        expect result == 42

    it "result ok":
        val r = Ok(42)
        val result = match r:
            Ok(v): v
            Err(_): 0
        expect result == 42

    it "result err":
        val r = Err("fail")
        val result = match r:
            Ok(v): v
            Err(_): 42
        expect result == 42


# ============================================================================
# Test Group 20: Contract Operations
# ============================================================================

describe "Contract Operations":
    # ## Assertions
    #
    # Assert true passes, assert false would fail.

    it "assert true passes":
        check(true)
        expect 42 == 42


# ============================================================================
# Test Group 21: Generator Operations
# ============================================================================

describe "Generators":
    # ## Generator Yield
    #
    # Basic generator with yield and collection.

    # Removed: stale duplicate of Group 40 "Generator and Yield"


# ============================================================================
# Test Group 22: Bitwise Operations
# ============================================================================

describe "Bitwise Operations":
    # ## Bitwise Operators
    #
    # And, or, xor, shift left, shift right.

    it "bitwise xor":
        expect (5 xor 3) == 6

    it "shift left":
        expect (1 << 5) == 32

    it "shift right":
        expect (64 >> 1) == 32


# ============================================================================
# Test Group 23: Float Arithmetic
# ============================================================================

describe "Float Arithmetic":
    # ## Floating-Point Operations
    #
    # Basic float math with cast to verify.

    it "float addition":
        val f = 3.0 + 4.0
        expect (f as i64) == 7

    it "float multiplication":
        val f = 6.0 * 7.0
        expect (f as i64) == 42


# ============================================================================
# Test Group 24: For Loop Over Collection
# ============================================================================

describe "For Loop Over Collection":
    # ## Collection Iteration
    #
    # For-in with array, not just range.

    it "for over array":
        val items = [10, 20, 12]
        var sum = 0
        for item in items:
            sum = sum + item
        expect sum == 42


# ============================================================================
# Test Group 25: Compound Boolean Expressions
# ============================================================================

describe "Compound Boolean Expressions":
    # ## Complex Boolean Logic
    #
    # Nested and/or, short-circuit evaluation.

    it "compound and-or":
        val a = true
        val b = false
        val c = true
        val result = if (a and b) or c: 42 else: 0
        expect result == 42

    it "nested and":
        val result = if true and true and true: 42 else: 0
        expect result == 42


# ============================================================================
# Test Group 26: Multiple Return Paths
# ============================================================================

describe "Multiple Return Paths":
    # ## Early Returns
    #
    # Functions with multiple return statements.

    it "early return from branch":
        expect classify(75) == 2
        expect classify(150) == 1
        expect classify(10) == 3

    it "return with no value":
        do_nothing()
        expect 42 == 42


# ============================================================================
# Test Group 27: Expression Statement
# ============================================================================

describe "Expression Statement":
    # ## Non-Returned Expressions
    #
    # Expression evaluated for side effects, result discarded.

    it "expression statement ignored":
        expect side_effect() == 42


# ============================================================================
# Test Group 28: Print with Typed Arguments
# ============================================================================

describe "Print with Types":
    # ## Print Builtin
    #
    # Print with bool and float arguments (boxing paths).

    it "print bool":
        print true
        expect 42 == 42

    it "print float":
        print 3.14
        expect 42 == 42


# ============================================================================
# Test Group 29: GC and Memory
# ============================================================================

describe "GC and Memory":
    # ## Garbage Collection
    #
    # Large struct allocation triggers GC paths.

    it "gc alloc large struct":
        val s = BigStruct(a: 10, b: 20, c: 10, d: 2)
        expect s.a + s.b + s.c + s.d == 42


# ============================================================================
# Test Group 30: Aggregate Operations
# ============================================================================

describe "Aggregate Operations":
    # ## Aggregate Construction
    #
    # Array, tuple, struct, and enum aggregate kinds for full MIR Aggregate coverage.

    it "array aggregate":
        var arr = [1, 2, 3, 4]
        expect arr[0] + arr[3] == 5

    it "tuple aggregate":
        val t = (10, 20, 12)
        expect t[0] + t[1] + t[2] == 42

    it "struct aggregate field init":
        val p = Point(x: 22, y: 20)
        expect p.x + p.y == 42

    it "enum with data aggregate":
        val s = Shape.Rect(6, 7)
        val result = match s:
            Shape.Circle(r): r
            Shape.Rect(w, h): w * h
        expect result == 42


# ============================================================================
# Test Group 31: Stack Allocation (Alloc instruction)
# ============================================================================

describe "Stack Allocation":
    # ## Alloc Instruction
    #
    # Mutable local allocation on stack.

    it "mutable local rewrite":
        var x: i64 = 10
        x = 42
        expect x == 42

    it "multiple mutable locals":
        var a: i64 = 0
        var b: i64 = 0
        a = 20
        b = 22
        expect a + b == 42

    it "mutable struct field update":
        var c = Counter(count: 0)
        c.count = 42
        expect c.count == 42


# ============================================================================
# Test Group 32: Bitwise Not
# ============================================================================

describe "Bitwise Not":
    # ## BitNot Unary Operator
    #
    # Bitwise complement operator.

    it "bitwise not zero":
        val x: i64 = 0
        val y: i64 = ~x
        expect y == -1

    it "bitwise not negative one":
        val x: i64 = -1
        val y: i64 = ~x
        expect y == 0


# ============================================================================
# Test Group 33: Float Comparison
# ============================================================================

describe "Float Comparison":
    # ## Float Comparison Operators
    #
    # Eq, ne, lt, le, gt, ge on floats.

    it "float equal":
        val a: f64 = 3.14
        val b: f64 = 3.14
        expect (if a == b: 1 else: 0) == 1

    it "float not equal":
        val a: f64 = 3.14
        val b: f64 = 2.71
        expect (if a != b: 1 else: 0) == 1

    it "float less than":
        val a: f64 = 2.0
        val b: f64 = 3.0
        expect (if a < b: 1 else: 0) == 1

    it "float greater than":
        val a: f64 = 5.0
        val b: f64 = 3.0
        expect (if a > b: 1 else: 0) == 1


# ============================================================================
# Test Group 34: Nop and Expression Discard
# ============================================================================

describe "Nop and Expression Discard":
    # ## Nop Instruction
    #
    # Statements that produce no-ops in MIR.

    it "standalone expression discard":
        42
        expect true

    it "void call discard":
        do_nothing()
        do_nothing()
        expect 42 == 42


# ============================================================================
# Test Group 35: Move vs Copy Semantics
# ============================================================================

describe "Move and Copy":
    # ## Move Instruction
    #
    # Move semantics for non-copyable types (strings, arrays).

    it "string move":
        val s = "hello"
        val t = s
        expect t == "hello"

    it "array move":
        val a = [1, 2, 3]
        val b = a
        expect b.len() == 3

    it "struct move":
        val p = Point(x: 40, y: 2)
        val q = p
        expect q.x + q.y == 42


# ============================================================================
# Test Group 36: Unsigned Arithmetic Paths
# ============================================================================

describe "Unsigned Arithmetic":
    # ## Unsigned Division and Remainder
    #
    # These exercise the udiv/urem codegen paths.

    it "unsigned modulo":
        val x: i64 = 47
        val r: i64 = x % 5
        expect r == 2

    it "integer remainder":
        val x: i64 = 100
        val r: i64 = x % 58
        expect r == 42


# ============================================================================
# Test Group 37: Type Conversion Paths
# ============================================================================

describe "Type Conversion":
    # ## Various Cast Paths
    #
    # Exercises different type conversion FFI paths in codegen.

    it "i64 to f64 and back":
        val x: i64 = 42
        val f: f64 = x as f64
        val back: i64 = f as i64
        expect back == 42

    it "bool to int":
        val b = true
        val i: i64 = if b: 1 else: 0
        expect i == 1

    it "negative int to float":
        val x: i64 = -42
        val f: f64 = x as f64
        val back: i64 = f as i64
        expect back == -42


# ============================================================================
# Test Group 38: Const Zero and Default Values
# ============================================================================

describe "Const Zero":
    # ## Zero/Default Constant
    #
    # Zero-initialized values for various types.

    it "zero int":
        val x: i64 = 0
        expect x == 0

    it "zero float":
        val f: f64 = 0.0
        expect (f as i64) == 0

    it "false bool":
        val b = false
        expect (if b: 1 else: 0) == 0


# ============================================================================
# Test Group 30: Nil Literal (lowering_expr.rs - HirExprKind.Nil)
# ============================================================================

describe "Nil Literal":
    # ## Nil Value
    #
    # The nil/null literal expression.

    it "nil value":
        val x = nil
        expect x == nil

    it "nil in conditional":
        val x = nil
        val result = if x == nil: 42 else: 0
        expect result == 42


# ============================================================================
# Test Group 31: Assume Statement (lowering_stmt.rs - HirStmt.Assume)
# ============================================================================

describe "Assume Statement":
    # ## Runtime Assumptions
    #
    # Assume statements declare runtime preconditions.

    it "assume true":
        assume true, "always holds"
        expect 42 == 42

    it "assume with expression":
        val x = 10
        assume x > 0, "positive"
        expect x == 10


# ============================================================================
# Test Group 32: Admit Statement (lowering_stmt.rs - HirStmt.Admit)
# ============================================================================

describe "Admit Statement":
    # ## Admit (Proof Skip)
    #
    # Admit is a no-op at runtime, used for proof obligations.

    it "admit true":
        admit true, "admitted"
        expect 42 == 42


# ============================================================================
# Test Group 33: Global Variable (lowering_expr.rs - HirExprKind.Global)
# ============================================================================

describe "Global Variable":
    # ## Global Variable Load
    #
    # Access to module-level global constants.

    it "global constant access":
        expect GLOBAL_ANSWER == 42

    it "global in expression":
        val x = GLOBAL_ANSWER + 8
        expect x == 50


# ============================================================================
# Test Group 34: Loop Statement (lowering_stmt.rs - HirStmt.Loop)
# ============================================================================

describe "Loop Statement":
    # ## Infinite Loop
    #
    # Loop with explicit break, distinct from while.

    it "loop with break":
        var i = 0
        loop:
            if i == 5:
                break
            i = i + 1
        expect i == 5

    it "loop with early return":
        fn find_first_even() -> i64:
            var i = 1
            loop:
                if i % 2 == 0:
                    return i
                i = i + 1
        expect find_first_even() == 2


# ============================================================================
# Test Group 35: Reference and Dereference (lowering_expr.rs - Ref/Deref)
# ============================================================================

describe "References":
    # ## Pointer Ref
    #
    # Reference creation with &.

    it "reference creation":
        val x = 42
        val r = &x
        expect 42 == 42


# ============================================================================
# Test Group 36: Contract Expressions (lowering_expr.rs - ensures/requires)
# ============================================================================

describe "Contract Expressions":
    # ## Function Contracts
    #
    # Ensures and requires clauses on functions.

    it "ensures postcondition":
        val r = ensure_positive(42)
        expect r == 42

    it "requires precondition":
        val r = with_precondition(21)
        expect r == 42


# ============================================================================
# Test Group 37: Bitwise Not (lowering_expr.rs - UnaryOp.BitNot)
# ============================================================================

describe "Bitwise Not":
    # ## Bitwise Complement
    #
    # The ~ operator for bitwise negation.

    it "bitnot zero":
        val x = 0
        val y = ~x
        expect y == -1

    it "bitnot identity":
        val x = 42
        val y = ~~x
        expect y == 42


# ============================================================================
# Test Group 38: If Expression (lowering_expr.rs - HirExprKind.If)
# ============================================================================

describe "If Expression":
    # ## If as Value
    #
    # If-else used as expression returning a value.

    it "if expression in binding":
        val x = if true: 42 else: 0
        expect x == 42

    it "nested if expression":
        val x = 15
        val r = if x > 20: 1 else: (if x > 10: 2 else: 3)
        expect r == 2

    it "if expression in call argument":
        fn identity(x: i64) -> i64:
            return x
        expect identity(if true: 42 else: 0) == 42


# ============================================================================
# Test Group 39: Future and Await (lowering_expr.rs - FutureCreate, Await)
# ============================================================================

describe "Future and Await":
    # ## Async Operations
    #
    # Future creation and await expressions.

    it "future create and await":
        val f = future(42)
        val result = await f
        expect result == 42

    it "future with expression":
        val f = future(20 + 22)
        val result = await f
        expect result == 42


# ============================================================================
# Test Group 40: Generator and Yield (lowering_expr.rs - GeneratorCreate, Yield)
# ============================================================================

describe "Generator and Yield":
    # ## Generator Operations
    #
    # Generator creation with yield expressions.

    it "generator create and yield":
        val g = generator(\: yield 42)
        val result = next(g)
        expect result == 42

    it "generator multiple yields":
        val g = generator(\: [yield 1, yield 2, yield 3])
        val a = next(g)
        val b = next(g)
        expect a == 1
        expect b == 2


# ============================================================================
# Test Group 41: Actor Spawn (lowering_expr.rs - ActorSpawn)
# ============================================================================

describe "Actor Spawn":
    # ## Actor Operations
    #
    # Spawning actor processes.

    it "actor spawn":
        fn worker() -> i64:
            42
        val h = spawn worker()
        expect true


# ============================================================================
# Test Group 42: Contract Old (lowering_expr.rs - ContractOld)
# ============================================================================

describe "Contract Old":
    # ## Old Expression in Postconditions
    #
    # The old(x) expression captures pre-state in ensures clauses.

    it "contract old in postcondition":
        fn increment_checked(x: i64) -> i64:
            # ensures: result == old(x) + 1
            return x + 1
        expect increment_checked(41) == 42


# ============================================================================
# Test Group 43: GPU Intrinsic (lowering_expr.rs - GpuIntrinsic)
# ============================================================================

describe "GPU Intrinsic":
    # ## GPU Operations
    #
    # GPU intrinsic function calls.

    it "gpu intrinsic":
        skip
        # TODO: GPU intrinsics require kernel context (this.index()) - no surface syntax available
        # expect 42 == 42


# ============================================================================
# Test Group 44: Neighbor Access (lowering_expr.rs - NeighborAccess)
# ============================================================================

describe "Neighbor Access":
    # ## GPU Stencil Neighbor
    #
    # Neighbor access for GPU stencil computations.

    it "neighbor access":
        var arr = [10, 20, 30]
        val left = arr.left_neighbor
        val right = arr.right_neighbor
        expect left == 10
        expect right == 30


# ============================================================================
# Test Group 45: Proof Hint (lowering_stmt.rs - ProofHint)
# ============================================================================

describe "Proof Hint":
    # ## Proof Hint Statement
    #
    # Proof hints are no-ops at runtime, used for verification.

    it "proof hint statement":
        lean hint: "simp"
        expect 42 == 42

    it "proof hint with expression context":
        val x = 42
        lean hint: "simp"
        expect x == 42


# ============================================================================
# Test Group 46: Calc Block (lowering_stmt.rs - Calc)
# ============================================================================

describe "Calc Block":
    # ## Calc Statement
    #
    # Calc blocks are verification constructs, no-ops at runtime.

    it "calc statement":
        val n = 42
        calc:
            n
            == n    by: "identity"
        expect 42 == 42


# ============================================================================
# Test Group 47: Vec Literal (lowering_expr.rs - VecLiteral)
# ============================================================================

describe "Vec Literal":
    # ## Vec Literal Expression
    #
    # Vec literals for growable array construction.

    it "vec literal":
        val v = vec[10, 20, 12]
        expect v.len() == 3
        expect v[0] + v[1] + v[2] == 42
