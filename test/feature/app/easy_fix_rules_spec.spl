"""
# EasyFix Rules Specification


**Feature IDs:** #2211-2220
**Category:** Tooling
**Difficulty:** 3/5
**Status:** Implemented

## Overview

Intensive tests for all 9 EasyFix rules. Each rule is tested with real
code snippets, edge cases, and round-trip verification.

## Rules Tested

| # | Rule | Confidence |
|---|------|------------|
| 1 | print_in_test_spec | Likely |
| 2 | unnamed_duplicate_typed_args | Uncertain |
| 3 | resource_leak | Uncertain |
| 4 | sspec_missing_docstrings | Safe |
| 5 | sspec_manual_assertions | Likely |
| 6 | non_exhaustive_match | Safe |
| 7 | typo_suggestion (Levenshtein) | Likely |
| 8 | parser_contextual_keyword | Safe |
| 9 | type_mismatch_coercion | Likely |
"""

use std.tooling.easy_fix.*
use std.text.{NL}
use std.text.{NL}

# ============================================================================
# Test Group 1: print_in_test_spec
# ============================================================================

describe "Rule: print_in_test_spec":
    """
    ## print_in_test_spec

    Detects `print()` calls in test spec files and suggests replacing
    with `expect()` assertions.
    """

    context "basic detection":
        """
        ### Scenario: Basic print() Detection

        Simple print() calls in spec files should be flagged.
        """

        it "detects print() in spec file":
            val source = "it \"test\":{NL}    print(42){NL}"
            val fixes = check_print_in_test_spec(source, "my_spec.spl")
            expect fixes.len() == 1
            expect fixes[0].id.contains("print_in_test_spec")

        it "detects print with string arg":
            val source = "it \"test\":{NL}    print(\"hello\"){NL}"
            val fixes = check_print_in_test_spec(source, "my_spec.spl")
            expect fixes.len() == 1

        it "detects print with expression":
            val source = "it \"test\":{NL}    print(x + y){NL}"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() == 1

        it "detects multiple prints":
            val source = "it \"a\":{NL}    print(1){NL}    print(2){NL}    print(3){NL}"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() == 3

        it "generates correct replacement":
            val source = "    print(42)"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() == 1
            expect fixes[0].replacements[0].new_text.contains("expect")

        it "preserves indentation":
            val source = "        print(x)"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() == 1
            val rep = fixes[0].replacements[0]
            expect rep.new_text.starts_with("        ")

    context "non-spec files":
        """
        ### Scenario: Non-spec Files Ignored

        print() in regular (non-spec) files should not be flagged.
        """

        it "ignores print in regular .spl files":
            val source = "fn main():{NL}    print(42){NL}"
            val fixes = check_print_in_test_spec(source, "main.spl")
            expect fixes.len() == 0

        it "ignores print in non-spl files":
            val source = "print(42)"
            val fixes = check_print_in_test_spec(source, "test.txt")
            expect fixes.len() == 0

    context "edge cases":
        """
        ### Scenario: Edge Cases

        Unusual inputs and boundary conditions.
        """

        it "handles empty file":
            val fixes = check_print_in_test_spec("", "test_spec.spl")
            expect fixes.len() == 0

        it "handles file with only comments":
            val source = "# comment{NL}# another{NL}"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() == 0

        it "has Likely confidence":
            val source = "    print(42)"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Likely: expect true
                _: fail("Expected Likely confidence")

# ============================================================================
# Test Group 2: unnamed_duplicate_typed_args
# ============================================================================

describe "Rule: unnamed_duplicate_typed_args":
    """
    ## unnamed_duplicate_typed_args

    Detects function signatures with duplicate type-only parameters
    and suggests adding distinct names.
    """

    context "basic detection":
        """
        ### Scenario: Duplicate Type-Only Parameters

        Functions with params like (Int, Int) should get named params.
        """

        it "detects fn with two same types":
            val source = "fn add(Int, Int) -> Int:{NL}    0{NL}"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 1

        it "generates named params":
            val source = "fn add(Int, Int) -> Int:{NL}    0{NL}"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.contains("int1: Int")
            expect rep.new_text.contains("int2: Int")

        it "detects three same types":
            val source = "fn triple(String, String, String):{NL}    pass{NL}"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 1

    context "no false positives":
        """
        ### Scenario: Named Parameters Not Flagged

        Functions with properly named params should not be flagged.
        """

        it "ignores named params":
            val source = "fn add(a: Int, b: Int) -> Int:{NL}    a + b{NL}"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 0

        it "ignores single type-only param":
            val source = "fn identity(Int) -> Int:{NL}    0{NL}"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 0

        it "ignores different types":
            val source = "fn convert(Int, String) -> Bool:{NL}    true{NL}"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 0

    context "edge cases":
        """
        ### Scenario: Edge Cases
        """

        it "handles empty file":
            val fixes = check_unnamed_duplicate_typed_args("", "test.spl")
            expect fixes.len() == 0

        it "handles me methods":
            val source = "me move(Int, Int):{NL}    pass{NL}"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 1

        it "handles static fn":
            val source = "static fn create(String, String) -> Self:{NL}    pass{NL}"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 1

        it "has Uncertain confidence":
            val source = "fn f(Int, Int):{NL}    pass{NL}"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Uncertain: expect true
                _: fail("Expected Uncertain confidence")

# ============================================================================
# Test Group 3: resource_leak
# ============================================================================

describe "Rule: resource_leak":
    """
    ## resource_leak

    Detects resource allocations not wrapped in `with` blocks.
    """

    context "basic detection":
        """
        ### Scenario: Unwrapped Resource Allocation
        """

        it "detects val x = open(...)":
            val source = "val f = open(\"file.txt\"){NL}"
            val fixes = check_resource_leak(source, "test.spl")
            expect fixes.len() == 1

        it "detects File.open":
            val source = "val f = File.open(\"path\"){NL}"
            val fixes = check_resource_leak(source, "test.spl")
            expect fixes.len() == 1

        it "detects connect":
            val source = "val conn = connect(\"localhost:8080\"){NL}"
            val fixes = check_resource_leak(source, "test.spl")
            expect fixes.len() == 1

        it "generates with block":
            val source = "val f = open(\"file.txt\"){NL}"
            val fixes = check_resource_leak(source, "test.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.contains("with f = open")

    context "no false positives":
        """
        ### Scenario: Already Wrapped Resources
        """

        it "ignores non-resource assignments":
            val source = "val x = compute(42){NL}"
            val fixes = check_resource_leak(source, "test.spl")
            expect fixes.len() == 0

        it "ignores var assignments":
            val source = "var f = open(\"file\"){NL}"
            val fixes = check_resource_leak(source, "test.spl")
            expect fixes.len() == 0

    context "edge cases":
        """
        ### Scenario: Edge Cases
        """

        it "handles empty file":
            val fixes = check_resource_leak("", "test.spl")
            expect fixes.len() == 0

        it "has Uncertain confidence":
            val source = "val f = open(\"x\"){NL}"
            val fixes = check_resource_leak(source, "test.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Uncertain: expect true
                _: fail("Expected Uncertain confidence")

# ============================================================================
# Test Group 4: sspec_missing_docstrings
# ============================================================================

describe "Rule: sspec_missing_docstrings":
    """
    ## sspec_missing_docstrings

    Detects describe/context blocks without docstrings and adds templates.
    """

    context "basic detection":
        """
        ### Scenario: Missing Docstrings
        """

        it "detects describe without docstring":
            val source = "describe \"My Feature\":{NL}    it \"works\":{NL}        expect true{NL}"
            val fixes = check_sspec_missing_docstrings(source, "test_spec.spl")
            expect fixes.len() >= 1
            expect fixes[0].id.contains("sspec_missing_docstrings")

        it "detects context without docstring":
            val source = "describe \"X\":{NL}    \"\"\"{NL}    ## X{NL}    \"\"\"{NL}    context \"when Y\":{NL}        it \"works\":{NL}            expect true{NL}"
            val fixes = check_sspec_missing_docstrings(source, "test_spec.spl")
            # context block should be detected (describe has docstring)
            expect fixes.len() >= 1

        it "generates docstring template":
            val source = "describe \"My Feature\":{NL}    it \"works\":{NL}        expect true{NL}"
            val fixes = check_sspec_missing_docstrings(source, "test_spec.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.contains("\"\"\"")
            expect rep.new_text.contains("My Feature")

    context "no false positives":
        """
        ### Scenario: Blocks With Docstrings
        """

        it "ignores describe with docstring":
            val source = "describe \"X\":{NL}    \"\"\"{NL}    ## X{NL}    \"\"\"{NL}    it \"works\":{NL}        expect true{NL}"
            val fixes = check_sspec_missing_docstrings(source, "test_spec.spl")
            expect fixes.len() == 0

        it "ignores non-spec files":
            val source = "describe \"X\":{NL}    pass{NL}"
            val fixes = check_sspec_missing_docstrings(source, "main.spl")
            expect fixes.len() == 0

    context "edge cases":
        """
        ### Scenario: Edge Cases
        """

        it "handles empty file":
            val fixes = check_sspec_missing_docstrings("", "test_spec.spl")
            expect fixes.len() == 0

        it "has Safe confidence":
            val source = "describe \"X\":{NL}    it \"y\":{NL}        expect true{NL}"
            val fixes = check_sspec_missing_docstrings(source, "test_spec.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Safe: expect true
                _: fail("Expected Safe confidence")

# ============================================================================
# Test Group 5: sspec_manual_assertions
# ============================================================================

describe "Rule: sspec_manual_assertions":
    """
    ## sspec_manual_assertions

    Detects `if cond: fail()` patterns and suggests `expect()`.
    """

    context "basic detection":
        """
        ### Scenario: Manual Assertions
        """

        it "detects if x: fail()":
            val source = "    if x > 5: fail(\"too big\"){NL}"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            expect fixes.len() == 1

        it "detects if not x: fail()":
            val source = "    if not valid: fail(\"invalid\"){NL}"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            expect fixes.len() == 1

        it "generates expect for positive condition":
            val source = "    if x > 5: fail(\"too big\"){NL}"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.contains("expect")
            expect rep.new_text.contains("to_be_falsy")

        it "generates expect for negated condition":
            val source = "    if not valid: fail(\"invalid\"){NL}"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.contains("expect(valid)")
            expect rep.new_text.contains("to_be_truthy")

        it "detects multiple manual assertions":
            val source = "    if a: fail(\"a\"){NL}    if b: fail(\"b\"){NL}"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            expect fixes.len() == 2

    context "no false positives":
        """
        ### Scenario: Non-matching Patterns
        """

        it "ignores if without fail":
            val source = "    if x > 5: print(x){NL}"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            expect fixes.len() == 0

        it "ignores non-spec files":
            val source = "    if x: fail(\"err\"){NL}"
            val fixes = check_sspec_manual_assertions(source, "main.spl")
            expect fixes.len() == 0

    context "edge cases":
        """
        ### Scenario: Edge Cases
        """

        it "handles empty file":
            val fixes = check_sspec_manual_assertions("", "test_spec.spl")
            expect fixes.len() == 0

        it "has Likely confidence":
            val source = "    if x: fail(\"y\"){NL}"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Likely: expect true
                _: fail("Expected Likely confidence")

        it "preserves indentation":
            val source = "        if x: fail(\"y\"){NL}"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.starts_with("        ")

# ============================================================================
# Test Group 6: non_exhaustive_match
# ============================================================================

describe "Rule: non_exhaustive_match":
    """
    ## non_exhaustive_match

    Detects match blocks without catch-all `case _:` arm.
    """

    context "basic detection":
        """
        ### Scenario: Missing Catch-All Arm
        """

        it "detects match without case _":
            val source = "match x:{NL}    case 1: \"one\"{NL}    case 2: \"two\"{NL}val y = 0{NL}"
            val fixes = check_non_exhaustive_match(source, "test.spl")
            expect fixes.len() == 1

        it "generates catch-all arm with todo":
            val source = "match x:{NL}    case 1: \"one\"{NL}val y = 0{NL}"
            val fixes = check_non_exhaustive_match(source, "test.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.contains("case _:")
            expect rep.new_text.contains("todo(")

    context "no false positives":
        """
        ### Scenario: Exhaustive Matches
        """

        it "ignores match with case _":
            val source = "match x:{NL}    case 1: \"one\"{NL}    case _: \"other\"{NL}val y = 0{NL}"
            val fixes = check_non_exhaustive_match(source, "test.spl")
            expect fixes.len() == 0

    context "edge cases":
        """
        ### Scenario: Edge Cases
        """

        it "handles empty file":
            val fixes = check_non_exhaustive_match("", "test.spl")
            expect fixes.len() == 0

        it "has Safe confidence":
            val source = "match x:{NL}    case 1: \"one\"{NL}val y = 0{NL}"
            val fixes = check_non_exhaustive_match(source, "test.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Safe: expect true
                _: fail("Expected Safe confidence")

# ============================================================================
# Test Group 7: typo_suggestion (Levenshtein)
# ============================================================================

describe "Rule: typo_suggestion":
    """
    ## typo_suggestion

    Uses Levenshtein distance to suggest corrections for misspelled identifiers.
    """

    context "Levenshtein distance":
        """
        ### Scenario: Distance Calculation
        """

        it "returns 0 for identical strings":
            expect levenshtein("hello", "hello") == 0

        it "returns length for empty string":
            expect levenshtein("", "abc") == 3
            expect levenshtein("abc", "") == 3

        it "returns 1 for single insertion":
            expect levenshtein("helo", "hello") == 1

        it "returns 1 for single deletion":
            expect levenshtein("hello", "helo") == 1

        it "returns 1 for single substitution":
            expect levenshtein("hello", "hallo") == 1

        it "returns 2 for two edits":
            expect levenshtein("kitten", "sitten") == 1
            expect levenshtein("kitten", "sittin") == 2

        it "handles completely different strings":
            expect levenshtein("abc", "xyz") == 3

        it "handles single character strings":
            expect levenshtein("a", "b") == 1
            expect levenshtein("a", "a") == 0

        it "handles both empty":
            expect levenshtein("", "") == 0

    context "typo fix suggestion":
        """
        ### Scenario: Suggesting Corrections
        """

        it "suggests close match":
            val known = ["println", "print", "format"]
            val result = suggest_typo_fix("test.spl", 1, 1, 0, 5, "prnt", known)
            match result:
                case Some(fix):
                    expect fix.id.contains("typo_suggestion")
                    expect fix.replacements[0].new_text == "print"
                case None:
                    expect false

        it "returns None for no close match":
            val known = ["println", "print", "format"]
            val result = suggest_typo_fix("test.spl", 1, 1, 0, 10, "xyzxyzxyz", known)
            match result:
                case Some(_):
                    expect false
                case None:
                    expect true

        it "has Likely confidence":
            val known = ["hello"]
            val result = suggest_typo_fix("test.spl", 1, 1, 0, 4, "helo", known)
            match result:
                case Some(fix):
                    match fix.confidence:
                        FixConfidence.Likely: expect true
                        _: fail("Expected Likely confidence")
                case None:
                    expect false

        it "picks closest match":
            val known = ["print", "println", "printf"]
            val result = suggest_typo_fix("test.spl", 1, 1, 0, 5, "prnt", known)
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == "print"
                case None:
                    expect false

# ============================================================================
# Test Group 8: parser_contextual_keyword
# ============================================================================

describe "Rule: parser_contextual_keyword":
    """
    ## parser_contextual_keyword

    Detects misordered keywords in function declarations and suggests
    the correct order.
    """

    context "async static reorder":
        """
        ### Scenario: async static fn → static async fn
        """

        it "detects async static fn":
            val source = "async static fn serve():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 1

        it "generates correct reorder":
            val source = "async static fn serve():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text == "static async fn "

        it "has Safe confidence":
            val source = "async static fn serve():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Safe: expect true
                _: fail("Expected Safe confidence")

    context "static pub reorder":
        """
        ### Scenario: static pub fn → pub static fn
        """

        it "detects static pub fn":
            val source = "static pub fn factory():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 1

        it "generates pub static fn":
            val source = "static pub fn factory():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text == "pub static fn "

    context "pub async static reorder":
        """
        ### Scenario: pub async static fn → pub static async fn
        """

        it "detects pub async static fn":
            val source = "pub async static fn handler():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 1

        it "generates pub static async fn":
            val source = "pub async static fn handler():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text == "pub static async fn "

    context "no false positives":
        """
        ### Scenario: Correct Keyword Order
        """

        it "ignores correct static async fn":
            val source = "static async fn serve():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 0

        it "ignores plain fn":
            val source = "fn simple():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 0

        it "ignores pub static fn":
            val source = "pub static fn factory():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 0

    context "edge cases":
        """
        ### Scenario: Edge Cases
        """

        it "handles empty file":
            val fixes = check_parser_contextual_keyword("", "test.spl")
            expect fixes.len() == 0

        it "handles indented keywords":
            val source = "    async static fn serve():{NL}        pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 1

# ============================================================================
# Test Group 9: type_mismatch_coercion
# ============================================================================

describe "Rule: type_mismatch_coercion":
    """
    ## type_mismatch_coercion

    Suggests type coercion methods for common type mismatches.
    """

    context "coercion suggestions":
        """
        ### Scenario: Common Type Conversions
        """

        it "suggests .to_string() for Int to String":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "String", "Int")
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == ".to_string()"
                case None:
                    expect false

        it "suggests .to_string() for Float to String":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "String", "Float")
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == ".to_string()"
                case None:
                    expect false

        it "suggests .to_string() for Bool to String":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "String", "Bool")
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == ".to_string()"
                case None:
                    expect false

        it "suggests .to_int() for Float to Int":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "Int", "Float")
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == ".to_int()"
                case None:
                    expect false

        it "suggests .to_float() for Int to Float":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "Float", "Int")
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == ".to_float()"
                case None:
                    expect false

        it "suggests != 0 for Int to Bool":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "Bool", "Int")
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == " != 0"
                case None:
                    expect false

    context "no coercion available":
        """
        ### Scenario: Unknown Type Pairs
        """

        it "returns None for unknown type pair":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "MyType", "OtherType")
            match result:
                case Some(_):
                    expect false
                case None:
                    expect true

        it "returns None for same types":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "Int", "Int")
            match result:
                case Some(_):
                    expect false
                case None:
                    expect true

    context "fix metadata":
        """
        ### Scenario: Fix Properties
        """

        it "has Likely confidence":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "String", "Int")
            match result:
                case Some(fix):
                    match fix.confidence:
                        FixConfidence.Likely: expect true
                        _: fail("Expected Likely confidence")
                case None:
                    expect false

        it "inserts at correct position":
            val result = suggest_type_coercion_fix("test.spl", 5, 20, 42, "String", "Int")
            match result:
                case Some(fix):
                    val rep = fix.replacements[0]
                    expect rep.start == 42
                    expect rep.end == 42
                    expect rep.line == 5
                case None:
                    expect false

# ============================================================================
# Test Group 10: check_all_rules integration
# ============================================================================

describe "check_all_rules integration":
    """
    ## Master Rule Runner

    Tests that check_all_rules correctly aggregates fixes from all rules.
    """

    context "aggregation":
        """
        ### Scenario: Multiple Rules Fire
        """

        it "returns empty for clean file":
            val source = "fn main():{NL}    val x = 42{NL}"
            val fixes = check_all_rules(source, "main.spl")
            expect fixes.len() == 0

        it "collects fixes from multiple rules":
            val source = "async static fn serve():{NL}    pass{NL}"
            val fixes = check_all_rules(source, "test.spl")
            # At minimum: parser_contextual_keyword should fire
            expect fixes.len() >= 1

        it "collects spec-related fixes for spec files":
            val source = "describe \"X\":{NL}    it \"y\":{NL}        print(42){NL}        if z: fail(\"err\"){NL}"
            val fixes = check_all_rules(source, "test_spec.spl")
            # Should get: missing docstring + print_in_test + manual assertion
            expect fixes.len() >= 2

    context "no duplicates":
        """
        ### Scenario: Rules Don't Overlap
        """

        it "each fix has unique ID":
            val source = "describe \"X\":{NL}    it \"y\":{NL}        print(1){NL}        print(2){NL}"
            val fixes = check_all_rules(source, "test_spec.spl")
            var ids: List<String> = []
            for fix in fixes:
                expect not ids.contains(fix.id)
                ids.push(fix.id)

# ============================================================================
# Test Group 11: Round-trip Verification
# ============================================================================

describe "Round-trip fix verification":
    """
    ## Round-Trip Tests

    Apply a fix, then re-check: the issue should be gone.
    """

    context "parser_contextual_keyword round-trip":
        """
        ### Scenario: Fix → Re-check → Clean
        """

        it "fixing async static fn clears the warning":
            val source = "async static fn serve():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 1

            # Apply fix manually
            val rep = fixes[0].replacements[0]
            val fixed = source.slice(0, rep.start) + rep.new_text + source.slice(rep.end)

            # Re-check: should be clean
            val recheck = check_parser_contextual_keyword(fixed, "test.spl")
            expect recheck.len() == 0

    context "print_in_test_spec round-trip":
        """
        ### Scenario: Fix print → Re-check → No print warning
        """

        it "fixing print clears the warning":
            val source = "    print(42)"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() == 1

            val rep = fixes[0].replacements[0]
            val fixed = source.slice(0, rep.start) + rep.new_text + source.slice(rep.end)

            val recheck = check_print_in_test_spec(fixed, "test_spec.spl")
            expect recheck.len() == 0

# ============================================================================
# Test Group 12: FixApplicator with Rules
# ============================================================================

describe "FixApplicator with shared rules":
    """
    ## Integration: Rules + Applicator

    Tests that fixes from rules can be applied via FixApplicator.
    """

    context "apply rule fixes":
        """
        ### Scenario: End-to-end fix application
        """

        it "applies parser keyword fix":
            val source = "async static fn serve():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")

            var sources: Dict<String, String> = {}
            sources["test.spl"] = source

            val result = FixApplicator.apply(fixes, sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"].contains("static async fn")
                case Err(e):
                    expect false

        it "applies multiple rule fixes without conflict":
            val source = "async static fn serve():{NL}    pass{NL}static pub fn make():{NL}    pass{NL}"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 2

            var sources: Dict<String, String> = {}
            sources["test.spl"] = source

            val result = FixApplicator.apply(fixes, sources)
            match result:
                case Ok(new_sources):
                    val fixed = new_sources["test.spl"]
                    expect fixed.contains("static async fn")
                    expect fixed.contains("pub static fn")
                case Err(e):
                    expect false
