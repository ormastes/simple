# # EasyFix Rules Specification
#
#
# **Feature IDs:** #2211-2220
# **Category:** Tooling
# **Difficulty:** 3/5
# **Status:** Implemented
#
# ## Overview
#
# Intensive tests for all 9 EasyFix rules. Each rule is tested with real
# code snippets, edge cases, and round-trip verification.
#
# ## Rules Tested
#
# | # | Rule | Confidence |
# |---|------|------------|
# | 1 | print_in_test_spec | Likely |
# | 2 | unnamed_duplicate_typed_args | Uncertain |
# | 3 | resource_leak | Uncertain |
# | 4 | sspec_missing_docstrings | Safe |
# | 5 | sspec_manual_assertions | Likely |
# | 6 | non_exhaustive_match | Safe |
# | 7 | typo_suggestion (Levenshtein) | Likely |
# | 8 | parser_contextual_keyword | Safe |
# | 9 | type_mismatch_coercion | Likely |

use std.tooling.easy_fix.*

# ============================================================================
# Test Group 1: print_in_test_spec
# ============================================================================

describe "Rule: print_in_test_spec":
    # ## print_in_test_spec
    #
    # Detects `print()` calls in test spec files and suggests replacing
    # with `expect()` assertions.

    context "basic detection":
        # ### Scenario: Basic print() Detection
        #
        # Simple print() calls in spec files should be flagged.

        it "detects print() in spec file":
            val source = "it \"test\":\n    print(42)\n"
            val fixes = check_print_in_test_spec(source, "my_spec.spl")
            expect fixes.len() == 1
            expect fixes[0].id.contains("print_in_test_spec")

        it "detects print with string arg":
            val source = "it \"test\":\n    print(\"hello\")\n"
            val fixes = check_print_in_test_spec(source, "my_spec.spl")
            expect fixes.len() == 1

        it "detects print with expression":
            val source = "it \"test\":\n    print(x + y)\n"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() == 1

        it "detects multiple prints":
            val source = "it \"a\":\n    print(1)\n    print(2)\n    print(3)\n"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() == 3

        it "generates correct replacement":
            val source = "    print(42)"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() == 1
            expect fixes[0].replacements[0].new_text.contains("expect")

        it "preserves indentation":
            val source = "        print(x)"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() == 1
            val rep = fixes[0].replacements[0]
            expect rep.new_text.starts_with("        ")

    context "non-spec files":
        # ### Scenario: Non-spec Files Ignored
        #
        # print() in regular (non-spec) files should not be flagged.

        it "ignores print in regular .spl files":
            val source = "fn main():\n    print(42)\n"
            val fixes = check_print_in_test_spec(source, "main.spl")
            expect fixes.len() == 0

        it "ignores print in non-spl files":
            val source = "print(42)"
            val fixes = check_print_in_test_spec(source, "test.txt")
            expect fixes.len() == 0

    context "edge cases":
        # ### Scenario: Edge Cases
        #
        # Unusual inputs and boundary conditions.

        it "handles empty file":
            val fixes = check_print_in_test_spec("", "test_spec.spl")
            expect fixes.len() == 0

        it "handles file with only comments":
            val source = "# comment\n# another\n"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() == 0

        it "has Likely confidence":
            val source = "    print(42)"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Likely: expect true
                _: fail("Expected Likely confidence")

# ============================================================================
# Test Group 2: unnamed_duplicate_typed_args
# ============================================================================

describe "Rule: unnamed_duplicate_typed_args":
    # ## unnamed_duplicate_typed_args
    #
    # Detects function signatures with duplicate type-only parameters
    # and suggests adding distinct names.

    context "basic detection":
        # ### Scenario: Duplicate Type-Only Parameters
        #
        # Functions with params like (Int, Int) should get named params.

        it "detects fn with two same types":
            val source = "fn add(Int, Int) -> Int:\n    0\n"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 1

        it "generates named params":
            val source = "fn add(Int, Int) -> Int:\n    0\n"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.contains("int1: Int")
            expect rep.new_text.contains("int2: Int")

        it "detects three same types":
            val source = "fn triple(String, String, String):\n    pass\n"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 1

    context "no false positives":
        # ### Scenario: Named Parameters Not Flagged
        #
        # Functions with properly named params should not be flagged.

        it "ignores named params":
            val source = "fn add(a: Int, b: Int) -> Int:\n    a + b\n"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 0

        it "ignores single type-only param":
            val source = "fn identity(Int) -> Int:\n    0\n"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 0

        it "ignores different types":
            val source = "fn convert(Int, String) -> Bool:\n    true\n"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 0

    context "edge cases":
        # ### Scenario: Edge Cases

        it "handles empty file":
            val fixes = check_unnamed_duplicate_typed_args("", "test.spl")
            expect fixes.len() == 0

        it "handles me methods":
            val source = "me move(Int, Int):\n    pass\n"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 1

        it "handles static fn":
            val source = "static fn create(String, String) -> Self:\n    pass\n"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() == 1

        it "has Uncertain confidence":
            val source = "fn f(Int, Int):\n    pass\n"
            val fixes = check_unnamed_duplicate_typed_args(source, "test.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Uncertain: expect true
                _: fail("Expected Uncertain confidence")

# ============================================================================
# Test Group 3: resource_leak
# ============================================================================

describe "Rule: resource_leak":
    # ## resource_leak
    #
    # Detects resource allocations not wrapped in `with` blocks.

    context "basic detection":
        # ### Scenario: Unwrapped Resource Allocation

        it "detects val x = open(...)":
            val source = "val f = open(\"file.txt\")\n"
            val fixes = check_resource_leak(source, "test.spl")
            expect fixes.len() == 1

        it "detects File.open":
            val source = "val f = File.open(\"path\")\n"
            val fixes = check_resource_leak(source, "test.spl")
            expect fixes.len() == 1

        it "detects connect":
            val source = "val conn = connect(\"localhost:8080\")\n"
            val fixes = check_resource_leak(source, "test.spl")
            expect fixes.len() == 1

        it "generates with block":
            val source = "val f = open(\"file.txt\")\n"
            val fixes = check_resource_leak(source, "test.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.contains("with f = open")

    context "no false positives":
        # ### Scenario: Already Wrapped Resources

        it "ignores non-resource assignments":
            val source = "val x = compute(42)\n"
            val fixes = check_resource_leak(source, "test.spl")
            expect fixes.len() == 0

        it "ignores var assignments":
            val source = "var f = open(\"file\")\n"
            val fixes = check_resource_leak(source, "test.spl")
            expect fixes.len() == 0

    context "edge cases":
        # ### Scenario: Edge Cases

        it "handles empty file":
            val fixes = check_resource_leak("", "test.spl")
            expect fixes.len() == 0

        it "has Uncertain confidence":
            val source = "val f = open(\"x\")\n"
            val fixes = check_resource_leak(source, "test.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Uncertain: expect true
                _: fail("Expected Uncertain confidence")

# ============================================================================
# Test Group 4: sspec_missing_docstrings
# ============================================================================

describe "Rule: sspec_missing_docstrings":
    # ## sspec_missing_docstrings
    #
    # Detects describe/context blocks without docstrings and adds templates.

    context "basic detection":
        # ### Scenario: Missing Docstrings

        it "detects describe without docstring":
            val source = "describe \"My Feature\":\n    it \"works\":\n        expect true\n"
            val fixes = check_sspec_missing_docstrings(source, "test_spec.spl")
            expect fixes.len() >= 1
            expect fixes[0].id.contains("sspec_missing_docstrings")

        it "detects context without docstring":
            val source = "describe \"X\":\n    \"\"\"\n    ## X\n    \"\"\"\n    context \"when Y\":\n        it \"works\":\n            expect true\n"
            val fixes = check_sspec_missing_docstrings(source, "test_spec.spl")
            # context block should be detected (describe has docstring)
            expect fixes.len() >= 1

        it "generates docstring template":
            val source = "describe \"My Feature\":\n    it \"works\":\n        expect true\n"
            val fixes = check_sspec_missing_docstrings(source, "test_spec.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.contains("\"\"\"")
            expect rep.new_text.contains("My Feature")

    context "no false positives":
        # ### Scenario: Blocks With Docstrings

        it "ignores describe with docstring":
            val source = "describe \"X\":\n    \"\"\"\n    ## X\n    \"\"\"\n    it \"works\":\n        expect true\n"
            val fixes = check_sspec_missing_docstrings(source, "test_spec.spl")
            expect fixes.len() == 0

        it "ignores non-spec files":
            val source = "describe \"X\":\n    pass\n"
            val fixes = check_sspec_missing_docstrings(source, "main.spl")
            expect fixes.len() == 0

    context "edge cases":
        # ### Scenario: Edge Cases

        it "handles empty file":
            val fixes = check_sspec_missing_docstrings("", "test_spec.spl")
            expect fixes.len() == 0

        it "has Safe confidence":
            val source = "describe \"X\":\n    it \"y\":\n        expect true\n"
            val fixes = check_sspec_missing_docstrings(source, "test_spec.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Safe: expect true
                _: fail("Expected Safe confidence")

# ============================================================================
# Test Group 5: sspec_manual_assertions
# ============================================================================

describe "Rule: sspec_manual_assertions":
    # ## sspec_manual_assertions
    #
    # Detects `if cond: fail()` patterns and suggests `expect()`.

    context "basic detection":
        # ### Scenario: Manual Assertions

        it "detects if x: fail()":
            val source = "    if x > 5: fail(\"too big\")\n"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            expect fixes.len() == 1

        it "detects if not x: fail()":
            val source = "    if not valid: fail(\"invalid\")\n"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            expect fixes.len() == 1

        it "generates expect for positive condition":
            val source = "    if x > 5: fail(\"too big\")\n"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.contains("expect")
            expect rep.new_text.contains("to_be_falsy")

        it "generates expect for negated condition":
            val source = "    if not valid: fail(\"invalid\")\n"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.contains("expect(valid)")
            expect rep.new_text.contains("to_be_truthy")

        it "detects multiple manual assertions":
            val source = "    if a: fail(\"a\")\n    if b: fail(\"b\")\n"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            expect fixes.len() == 2

    context "no false positives":
        # ### Scenario: Non-matching Patterns

        it "ignores if without fail":
            val source = "    if x > 5: print(x)\n"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            expect fixes.len() == 0

        it "ignores non-spec files":
            val source = "    if x: fail(\"err\")\n"
            val fixes = check_sspec_manual_assertions(source, "main.spl")
            expect fixes.len() == 0

    context "edge cases":
        # ### Scenario: Edge Cases

        it "handles empty file":
            val fixes = check_sspec_manual_assertions("", "test_spec.spl")
            expect fixes.len() == 0

        it "has Likely confidence":
            val source = "    if x: fail(\"y\")\n"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Likely: expect true
                _: fail("Expected Likely confidence")

        it "preserves indentation":
            val source = "        if x: fail(\"y\")\n"
            val fixes = check_sspec_manual_assertions(source, "test_spec.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.starts_with("        ")

# ============================================================================
# Test Group 6: non_exhaustive_match
# ============================================================================

describe "Rule: non_exhaustive_match":
    # ## non_exhaustive_match
    #
    # Detects match blocks without catch-all `case _:` arm.

    context "basic detection":
        # ### Scenario: Missing Catch-All Arm

        it "detects match without case _":
            val source = "match x:\n    case 1: \"one\"\n    case 2: \"two\"\nval y = 0\n"
            val fixes = check_non_exhaustive_match(source, "test.spl")
            expect fixes.len() == 1

        it "generates catch-all arm with todo":
            val source = "match x:\n    case 1: \"one\"\nval y = 0\n"
            val fixes = check_non_exhaustive_match(source, "test.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text.contains("case _:")
            expect rep.new_text.contains("todo(")

    context "no false positives":
        # ### Scenario: Exhaustive Matches

        it "ignores match with case _":
            val source = "match x:\n    case 1: \"one\"\n    case _: \"other\"\nval y = 0\n"
            val fixes = check_non_exhaustive_match(source, "test.spl")
            expect fixes.len() == 0

    context "edge cases":
        # ### Scenario: Edge Cases

        it "handles empty file":
            val fixes = check_non_exhaustive_match("", "test.spl")
            expect fixes.len() == 0

        it "has Safe confidence":
            val source = "match x:\n    case 1: \"one\"\nval y = 0\n"
            val fixes = check_non_exhaustive_match(source, "test.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Safe: expect true
                _: fail("Expected Safe confidence")

# ============================================================================
# Test Group 7: typo_suggestion (Levenshtein)
# ============================================================================

describe "Rule: typo_suggestion":
    # ## typo_suggestion
    #
    # Uses Levenshtein distance to suggest corrections for misspelled identifiers.

    context "Levenshtein distance":
        # ### Scenario: Distance Calculation

        it "returns 0 for identical strings":
            expect levenshtein("hello", "hello") == 0

        it "returns length for empty string":
            expect levenshtein("", "abc") == 3
            expect levenshtein("abc", "") == 3

        it "returns 1 for single insertion":
            expect levenshtein("helo", "hello") == 1

        it "returns 1 for single deletion":
            expect levenshtein("hello", "helo") == 1

        it "returns 1 for single substitution":
            expect levenshtein("hello", "hallo") == 1

        it "returns 2 for two edits":
            expect levenshtein("kitten", "sitten") == 1
            expect levenshtein("kitten", "sittin") == 2

        it "handles completely different strings":
            expect levenshtein("abc", "xyz") == 3

        it "handles single character strings":
            expect levenshtein("a", "b") == 1
            expect levenshtein("a", "a") == 0

        it "handles both empty":
            expect levenshtein("", "") == 0

    context "typo fix suggestion":
        # ### Scenario: Suggesting Corrections

        it "suggests close match":
            val known = ["println", "print", "format"]
            val result = suggest_typo_fix("test.spl", 1, 1, 0, 5, "prnt", known)
            match result:
                case Some(fix):
                    expect fix.id.contains("typo_suggestion")
                    expect fix.replacements[0].new_text == "print"
                case None:
                    expect false

        it "returns None for no close match":
            val known = ["println", "print", "format"]
            val result = suggest_typo_fix("test.spl", 1, 1, 0, 10, "xyzxyzxyz", known)
            match result:
                case Some(_):
                    expect false
                case None:
                    expect true

        it "has Likely confidence":
            val known = ["hello"]
            val result = suggest_typo_fix("test.spl", 1, 1, 0, 4, "helo", known)
            match result:
                case Some(fix):
                    match fix.confidence:
                        FixConfidence.Likely: expect true
                        _: fail("Expected Likely confidence")
                case None:
                    expect false

        it "picks closest match":
            val known = ["print", "println", "printf"]
            val result = suggest_typo_fix("test.spl", 1, 1, 0, 5, "prnt", known)
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == "print"
                case None:
                    expect false

# ============================================================================
# Test Group 8: parser_contextual_keyword
# ============================================================================

describe "Rule: parser_contextual_keyword":
    # ## parser_contextual_keyword
    #
    # Detects misordered keywords in function declarations and suggests
    # the correct order.

    context "async static reorder":
        # ### Scenario: async static fn → static async fn

        it "detects async static fn":
            val source = "async static fn serve():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 1

        it "generates correct reorder":
            val source = "async static fn serve():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text == "static async fn "

        it "has Safe confidence":
            val source = "async static fn serve():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() > 0
            match fixes[0].confidence:
                FixConfidence.Safe: expect true
                _: fail("Expected Safe confidence")

    context "static pub reorder":
        # ### Scenario: static pub fn → pub static fn

        it "detects static pub fn":
            val source = "static pub fn factory():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 1

        it "generates pub static fn":
            val source = "static pub fn factory():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text == "pub static fn "

    context "pub async static reorder":
        # ### Scenario: pub async static fn → pub static async fn

        it "detects pub async static fn":
            val source = "pub async static fn handler():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 1

        it "generates pub static async fn":
            val source = "pub async static fn handler():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            val rep = fixes[0].replacements[0]
            expect rep.new_text == "pub static async fn "

    context "no false positives":
        # ### Scenario: Correct Keyword Order

        it "ignores correct static async fn":
            val source = "static async fn serve():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 0

        it "ignores plain fn":
            val source = "fn simple():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 0

        it "ignores pub static fn":
            val source = "pub static fn factory():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 0

    context "edge cases":
        # ### Scenario: Edge Cases

        it "handles empty file":
            val fixes = check_parser_contextual_keyword("", "test.spl")
            expect fixes.len() == 0

        it "handles indented keywords":
            val source = "    async static fn serve():\n        pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 1

# ============================================================================
# Test Group 9: type_mismatch_coercion
# ============================================================================

describe "Rule: type_mismatch_coercion":
    # ## type_mismatch_coercion
    #
    # Suggests type coercion methods for common type mismatches.

    context "coercion suggestions":
        # ### Scenario: Common Type Conversions

        it "suggests .to_string() for Int to String":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "String", "Int")
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == ".to_string()"
                case None:
                    expect false

        it "suggests .to_string() for Float to String":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "String", "Float")
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == ".to_string()"
                case None:
                    expect false

        it "suggests .to_string() for Bool to String":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "String", "Bool")
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == ".to_string()"
                case None:
                    expect false

        it "suggests .to_int() for Float to Int":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "Int", "Float")
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == ".to_int()"
                case None:
                    expect false

        it "suggests .to_float() for Int to Float":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "Float", "Int")
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == ".to_float()"
                case None:
                    expect false

        it "suggests != 0 for Int to Bool":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "Bool", "Int")
            match result:
                case Some(fix):
                    expect fix.replacements[0].new_text == " != 0"
                case None:
                    expect false

    context "no coercion available":
        # ### Scenario: Unknown Type Pairs

        it "returns None for unknown type pair":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "MyType", "OtherType")
            match result:
                case Some(_):
                    expect false
                case None:
                    expect true

        it "returns None for same types":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "Int", "Int")
            match result:
                case Some(_):
                    expect false
                case None:
                    expect true

    context "fix metadata":
        # ### Scenario: Fix Properties

        it "has Likely confidence":
            val result = suggest_type_coercion_fix("test.spl", 1, 10, 15, "String", "Int")
            match result:
                case Some(fix):
                    match fix.confidence:
                        FixConfidence.Likely: expect true
                        _: fail("Expected Likely confidence")
                case None:
                    expect false

        it "inserts at correct position":
            val result = suggest_type_coercion_fix("test.spl", 5, 20, 42, "String", "Int")
            match result:
                case Some(fix):
                    val rep = fix.replacements[0]
                    expect rep.start == 42
                    expect rep.end == 42
                    expect rep.line == 5
                case None:
                    expect false

# ============================================================================
# Test Group 10: check_all_rules integration
# ============================================================================

describe "check_all_rules integration":
    # ## Master Rule Runner
    #
    # Tests that check_all_rules correctly aggregates fixes from all rules.

    context "aggregation":
        # ### Scenario: Multiple Rules Fire

        it "returns empty for clean file":
            val source = "fn main():\n    val x = 42\n"
            val fixes = check_all_rules(source, "main.spl")
            expect fixes.len() == 0

        it "collects fixes from multiple rules":
            val source = "async static fn serve():\n    pass\n"
            val fixes = check_all_rules(source, "test.spl")
            # At minimum: parser_contextual_keyword should fire
            expect fixes.len() >= 1

        it "collects spec-related fixes for spec files":
            val source = "describe \"X\":\n    it \"y\":\n        print(42)\n        if z: fail(\"err\")\n"
            val fixes = check_all_rules(source, "test_spec.spl")
            # Should get: missing docstring + print_in_test + manual assertion
            expect fixes.len() >= 2

    context "no duplicates":
        # ### Scenario: Rules Don't Overlap

        it "each fix has unique ID":
            val source = "describe \"X\":\n    it \"y\":\n        print(1)\n        print(2)\n"
            val fixes = check_all_rules(source, "test_spec.spl")
            var ids: List<String> = []
            for fix in fixes:
                expect not ids.contains(fix.id)
                ids.push(fix.id)

# ============================================================================
# Test Group 11: Round-trip Verification
# ============================================================================

describe "Round-trip fix verification":
    # ## Round-Trip Tests
    #
    # Apply a fix, then re-check: the issue should be gone.

    context "parser_contextual_keyword round-trip":
        # ### Scenario: Fix → Re-check → Clean

        it "fixing async static fn clears the warning":
            val source = "async static fn serve():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 1

            # Apply fix manually
            val rep = fixes[0].replacements[0]
            val fixed = source.slice(0, rep.start) + rep.new_text + source.slice(rep.end)

            # Re-check: should be clean
            val recheck = check_parser_contextual_keyword(fixed, "test.spl")
            expect recheck.len() == 0

    context "print_in_test_spec round-trip":
        # ### Scenario: Fix print → Re-check → No print warning

        it "fixing print clears the warning":
            val source = "    print(42)"
            val fixes = check_print_in_test_spec(source, "test_spec.spl")
            expect fixes.len() == 1

            val rep = fixes[0].replacements[0]
            val fixed = source.slice(0, rep.start) + rep.new_text + source.slice(rep.end)

            val recheck = check_print_in_test_spec(fixed, "test_spec.spl")
            expect recheck.len() == 0

# ============================================================================
# Test Group 12: FixApplicator with Rules
# ============================================================================

describe "FixApplicator with shared rules":
    # ## Integration: Rules + Applicator
    #
    # Tests that fixes from rules can be applied via FixApplicator.

    context "apply rule fixes":
        # ### Scenario: End-to-end fix application

        it "applies parser keyword fix":
            val source = "async static fn serve():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")

            var sources: Dict<String, String> = {}
            sources["test.spl"] = source

            val result = FixApplicator.apply(fixes, sources)
            match result:
                case Ok(new_sources):
                    expect new_sources["test.spl"].contains("static async fn")
                case Err(e):
                    expect false

        it "applies multiple rule fixes without conflict":
            val source = "async static fn serve():\n    pass\nstatic pub fn make():\n    pass\n"
            val fixes = check_parser_contextual_keyword(source, "test.spl")
            expect fixes.len() == 2

            var sources: Dict<String, String> = {}
            sources["test.spl"] = source

            val result = FixApplicator.apply(fixes, sources)
            match result:
                case Ok(new_sources):
                    val fixed = new_sources["test.spl"]
                    expect fixed.contains("static async fn")
                    expect fixed.contains("pub static fn")
                case Err(e):
                    expect false
