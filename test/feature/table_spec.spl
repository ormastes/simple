"""
# Table (DataFrame) Specification

**Feature IDs:** #2250-2260
**Category:** Stdlib
**Status:** Implemented

Table/DataFrame-like data structure for tabular data:
- Column-based storage with typed columns
- SQL-like operations (select, where, join)
- Aggregation and grouping
- Statistical operations
"""
use std.table.*

describe "Table Construction":
    """
    Creating tables from various sources.
    """

    context "from columns":
        it "creates table from column list", fn():
            val col1 = Column(name: "x", data: [1, 2, 3])
            val col2 = Column(name: "y", data: [4, 5, 6])
            val table = table_from_columns([col1, col2])

            expect(table.num_rows).to_equal(3)
            expect(table.column_names.len()).to_equal(2)

    context "from dictionary":
        it "creates table from dict of arrays", fn():
            var data = {}
            data["a"] = [1, 2, 3]
            data["b"] = [4, 5, 6]
            val table = table_from_dict(data)

            expect(table.num_rows).to_equal(3)
            expect(table.column_names.len()).to_equal(2)

describe "Column Access":
    """
    Accessing table columns.
    """

    context "by name":
        it "gets column via get()", fn():
            var data = {}
            data["x"] = [1, 2, 3]
            data["y"] = [4, 5, 6]
            val table = table_from_dict(data)

            val col_opt = table_get(table, "x")
            expect(col_opt.?).to_equal(true)

        it "returns nil for missing column", fn():
            val table = table_empty()
            val col_opt = table_get(table, "missing")
            expect(col_opt.?).to_equal(false)

describe "Column Reductions":
    """
    Statistical operations on columns.
    """

    context "sum":
        it "sums numeric column", fn():
            val col = Column(name: "x", data: [1, 2, 3, 4])
            val total = column_sum(col)
            expect(total).to_equal(10.0)

    context "mean":
        it "computes mean", fn():
            val col = Column(name: "x", data: [2, 4, 6, 8])
            val avg = column_mean(col)
            expect(avg).to_equal(5.0)

    context "min/max":
        it "finds minimum", fn():
            val col = Column(name: "x", data: [5, 2, 8, 1, 9])
            val minimum = column_min(col)
            expect(minimum).to_equal(1)

        it "finds maximum", fn():
            val col = Column(name: "x", data: [5, 2, 8, 1, 9])
            val maximum = column_max(col)
            expect(maximum).to_equal(9)

    context "std/var":
        it "computes standard deviation", fn():
            val col = Column(name: "x", data: [2, 4, 6, 8])
            val std = column_std_dev(col)
            # std_dev of [2,4,6,8] = sqrt(5) â‰ˆ 2.236
            expect(std > 2.0).to_equal(true)
            expect(std < 2.5).to_equal(true)

describe "Filtering":
    """
    Filtering table rows.
    """

    context "where":
        it "filters by predicate", fn():
            var data = {}
            data["x"] = [1, 2, 3, 4, 5]
            data["y"] = [10, 20, 30, 40, 50]
            val table1 = table_from_dict(data)

            val table2 = table_where(table1, fn(row): row["x"] > 2)
            expect(table2.num_rows).to_equal(3)

        it "chains multiple filters", fn():
            var data = {}
            data["x"] = [1, 2, 3, 4, 5]
            data["y"] = [10, 20, 30, 40, 50]
            val table1 = table_from_dict(data)

            val table2 = table_where(table1, fn(row): row["x"] > 2)
            val table3 = table_where(table2, fn(row): row["y"] < 50)
            expect(table3.num_rows).to_equal(2)

describe "Selection":
    """
    Selecting and dropping columns.
    """

    context "select":
        it "selects specific columns", fn():
            var data = {}
            data["a"] = [1, 2, 3]
            data["b"] = [4, 5, 6]
            data["c"] = [7, 8, 9]
            val table1 = table_from_dict(data)

            val table2 = table_select(table1, ["a", "c"])
            expect(table2.column_names.len()).to_equal(2)

    context "drop":
        it "drops specific columns", fn():
            var data = {}
            data["a"] = [1, 2, 3]
            data["b"] = [4, 5, 6]
            data["c"] = [7, 8, 9]
            val table1 = table_from_dict(data)

            val table2 = table_drop(table1, ["b"])
            expect(table2.column_names.len()).to_equal(2)

describe "Sorting":
    """
    Sorting table rows.
    """

    context "sort_by":
        it "sorts ascending by column", fn():
            var data = {}
            data["x"] = [3, 1, 2]
            data["y"] = [30, 10, 20]
            val table1 = table_from_dict(data)

            val table2 = table_sort_by(table1, "x", true)
            val x_col = table_get(table2, "x")
            # Can't easily check values, just verify it ran
            expect(x_col.?).to_equal(true)

        it "sorts descending", fn():
            var data = {}
            data["x"] = [1, 2, 3]
            data["y"] = [10, 20, 30]
            val table1 = table_from_dict(data)

            val table2 = table_sort_by(table1, "x", false)
            val x_col = table_get(table2, "x")
            expect(x_col.?).to_equal(true)

describe "Grouping and Aggregation":
    """
    Grouping rows and computing aggregates.
    """

    context "group_by":
        it "groups by single column", fn():
            var data = {}
            data["category"] = ["A", "B", "A", "B"]
            data["value"] = [10, 20, 30, 40]
            val table1 = table_from_dict(data)

            val table2 = table_group_by(table1, "category", "value", "sum")
            expect(table2.num_rows).to_equal(2)

        it "computes sum per group", fn():
            var data = {}
            data["category"] = ["A", "A", "B"]
            data["value"] = [10, 20, 30]
            val table1 = table_from_dict(data)

            val table2 = table_group_by(table1, "category", "value", "sum")
            expect(table2.num_rows).to_equal(2)

    context "aggregation functions":
        it "supports multiple aggregations", fn():
            var data = {}
            data["x"] = ["A", "A"]
            data["y"] = [5, 10]
            val table1 = table_from_dict(data)

            val sum_table = table_group_by(table1, "x", "y", "sum")
            val mean_table = table_group_by(table1, "x", "y", "mean")
            expect(sum_table.num_rows).to_equal(1)
            expect(mean_table.num_rows).to_equal(1)

describe "Joins":
    """
    Joining tables together.
    """

    context "inner join":
        it "joins on common column", fn():
            var left_data = {}
            left_data["id"] = [1, 2, 3]
            left_data["name"] = ["Alice", "Bob", "Carol"]
            val left_table = table_from_dict(left_data)

            var right_data = {}
            right_data["id"] = [1, 2]
            right_data["score"] = [95, 87]
            val right_table = table_from_dict(right_data)

            val joined = table_inner_join(left_table, right_table, "id")
            expect(joined.num_rows).to_equal(2)

describe "Computed Columns":
    """
    Adding computed columns.
    """

    context "with_column":
        it "adds new column", fn():
            var data = {}
            data["x"] = [1, 2, 3]
            val table1 = table_from_dict(data)

            val table2 = table_with_column(table1, "y", [10, 20, 30])
            expect(table2.column_names.len()).to_equal(2)

    context "with_computed":
        it "adds column from computation", fn():
            var data = {}
            data["x"] = [1, 2, 3]
            val table1 = table_from_dict(data)

            val table2 = table_with_computed(table1, "x2", fn(row): row["x"] * 2)
            expect(table2.column_names.len()).to_equal(2)

describe "Chained Operations":
    """
    Fluent interface with method chaining.
    """

    it "chains filter, select, and aggregate", fn():
        var data = {}
        data["x"] = [1, 2, 3, 4, 5]
        data["y"] = [10, 20, 30, 40, 50]
        val table1 = table_from_dict(data)

        val table2 = table_where(table1, fn(row): row["x"] > 2)
        val table3 = table_select(table2, ["x"])
        expect(table3.num_rows).to_equal(3)
        expect(table3.column_names.len()).to_equal(1)

    it "computes department statistics", fn():
        var data = {}
        data["dept"] = ["A", "B", "A", "B"]
        data["salary"] = [50000, 60000, 55000, 65000]
        val table1 = table_from_dict(data)

        val table2 = table_group_by(table1, "dept", "salary", "mean")
        expect(table2.num_rows).to_equal(2)

describe "Column Utilities":
    """
    Column-level operations.
    """

    context "unique":
        it "gets unique values", fn():
            val col = Column(name: "x", data: [1, 2, 2, 3, 3, 3])
            val uniq = column_unique(col)
            expect(uniq.len()).to_equal(3)

    context "value_counts":
        it "counts value occurrences", fn():
            val col = Column(name: "x", data: [1, 2, 2, 3, 3, 3])
            val counts = column_value_counts(col)
            expect(counts.len()).to_equal(3)
