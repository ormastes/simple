# @pending
"""
# Trailing Blocks Specification

**Feature IDs:** #450
**Category:** Syntax
**Difficulty:** 3/5
**Status:** Implemented

## Overview

Trailing blocks (also called "trailing lambdas") provide Ruby-style syntax for passing
lambda functions as the last argument to a function or method. They use a backslash (`\`)
to introduce parameters, making functional-style code more readable and enabling DSL-like
syntax patterns.

## Syntax

### Basic Trailing Block

```simple
# Traditional lambda syntax
items.map(\x: x * 2)

# Trailing block syntax (cleaner)
items.map \x: x * 2
```

### With Multiple Parameters

```simple
items.reduce(0) \acc, x: acc + x
```

### Block Bodies

```simple
items.each \item:
    print(item)
    process(item)
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| Trailing Lambda | Lambda passed as last argument using `\` syntax |
| Backslash Syntax | `\params: body` introduces a trailing block |
| Method Chaining | Trailing blocks work naturally with method chains |
| DSL Support | Enable Ruby-style domain-specific languages |

## Behavior

- **Trailing blocks** are parsed as the last argument to a function/method call
- **Backslash syntax** (`\`) immediately signals a lambda, enabling LL(1) parsing
- **Inline expressions** can be used for simple one-liners: `\x: x * 2`
- **Block bodies** with indentation allow multi-statement blocks
- **Multiple parameters** are comma-separated: `\x, y, z: body`
- **Zero parameters** use empty parameter list: `\: body`
- Works with both **parenthesized** and **no-parentheses** calls

## Related Specifications

- [Lambdas/Closures](../lambdas_closures/lambdas_closures_spec.md) - Lambda syntax and closure semantics
- [No-Parentheses Calls](../no_paren_calls/no_paren_calls_spec.md) - Calling functions without parens
- [Functional Update](../functional_update/functional_update_spec.md) - Functional transformation patterns

## Implementation Notes

**Parser:** `src/parser/src/expressions/postfix.rs`
- `parse_trailing_lambda()` (lines 345-372): Parses trailing block syntax
- `parse_lambda_params()` (lines 377-396): Parses parameter lists

**Integration Points:**
- Function calls with parentheses (line 328-333)
- Method calls with parentheses (line 158-164)
- Method calls without parentheses (line 170-180)
- No-parentheses function calls

**Performance:** Trailing blocks are syntactic sugar - no runtime overhead compared to
traditional lambda syntax. They parse in O(1) time after detecting the backslash token.

## Examples

```simple
# Functional operations
val doubled = [1, 2, 3].map \x: x * 2
val positives = numbers.filter \x: x > 0

# DSL-style router
router.get "/hello" \: "Hello World"
router.post "/user" \request: process(request)

# Method chaining
items.filter \x: x > 0
     .map \x: x * 2
     .each \x: print(x)
```
"""



# ============================================================================
# Basic Trailing Block Syntax
# ============================================================================

describe "Trailing Blocks - Basic Syntax":
    """
    ## Basic Trailing Block Syntax

    Trailing blocks use backslash (`\`) to introduce lambda parameters,
    allowing cleaner syntax when passing functions as arguments.
    """

    context "with single parameter":
        """
        ### Scenario: Single Parameter Trailing Block

        A trailing block with one parameter uses `\param: expr` syntax.

        ```simple
        val doubled = map([1, 2, 3]) \x: x * 2
        ```
        """

        it "passes trailing block to function":
            fn apply(x, f):
                f(x)

            val result = apply(5) \n: n * 2
            expect(result).to_equal(10)

        it "works with method-style calls":
            fn double_each(arr, f):
                var result = []
                var i = 0
                while i < arr.len():
                    result.push(f(arr[i]))
                    i = i + 1
                result

            val nums = [1, 2, 3]
            val doubled = double_each(nums) \x: x * 2
            expect(doubled[0]).to_equal(2)
            expect(doubled[1]).to_equal(4)
            expect(doubled[2]).to_equal(6)

    context "with multiple parameters":
        """
        ### Scenario: Multiple Parameters

        Trailing blocks support multiple comma-separated parameters.

        ```simple
        reduce(items, 0) \acc, x: acc + x
        ```
        """

        it "accepts multiple parameters":
            fn fold(arr, init, f):
                var acc = init
                var i = 0
                while i < arr.len():
                    acc = f(acc, arr[i])
                    i = i + 1
                acc

            val nums = [1, 2, 3, 4]
            val sum = fold(nums, 0) \acc, x: acc + x
            expect(sum).to_equal(10)

        it "works with three parameters":
            fn fold3(arr, init, f):
                var acc = init
                var i = 0
                while i < arr.len():
                    acc = f(acc, arr[i], i)
                    i = i + 1
                acc

            val letters = ["a", "b", "c"]
            val result = fold3(letters, "") \acc, item, idx: acc + item
            expect(result).to_equal("abc")

    context "with zero parameters":
        """
        ### Scenario: Zero Parameters

        Trailing blocks can have no parameters using `\:` syntax.

        ```simple
        router.get "/health" \: "ok"
        ```
        """

        it "allows zero-parameter blocks":
            fn call_block(block):
                block()

            val result = call_block \: 42
            expect(result).to_equal(42)

        it "useful for constant responses":
            fn get_handler(path, handler):
                handler()

            val response = get_handler("/health") \: "ok"
            expect(response).to_equal("ok")


# ============================================================================
# Inline Expressions vs Block Bodies
# ============================================================================

describe "Trailing Blocks - Expression Forms":
    """
    ## Inline Expressions vs Block Bodies

    Trailing blocks support both inline expressions (single-line) and
    indented block bodies (multi-statement).
    """

    context "with inline expressions":
        """
        ### Scenario: Inline Expressions

        Simple expressions can be written inline after the colon.

        ```simple
        items.map \x: x * 2
        ```
        """

        it "evaluates inline expression":
            fn transform(x, f):
                f(x)

            val result = transform(10) \n: n + 5
            expect(result).to_equal(15)

        it "supports arithmetic expressions":
            fn compute(a, b, op):
                op(a, b)

            val sum = compute(3, 4) \x, y: x + y
            expect(sum).to_equal(7)

            val product = compute(3, 4) \x, y: x * y
            expect(product).to_equal(12)

    context "with block bodies":
        """
        ### Scenario: Block Bodies

        Multi-statement blocks use indentation like regular blocks.

        ```simple
        items.each \item:
            print(item)
            process(item)
        ```
        """

        it "can use traditional lambdas for multi-statement logic":
            fn run_block(block):
                block()

            var result = run_block(\: 42)

            expect(result).to_equal(42)

        it "can compute complex expressions inline":
            fn process(x, handler):
                handler(x)

            val result = process(5) \n: (n * 2) + 3

            expect(result).to_equal(13)


# ============================================================================
# Function Call Contexts
# ============================================================================

describe "Trailing Blocks - Call Contexts":
    """
    ## Trailing Blocks in Different Call Contexts

    Trailing blocks work with various function and method call styles.
    """

    context "with parenthesized calls":
        """
        ### Scenario: Parenthesized Function Calls

        Trailing blocks work after parenthesized argument lists.

        ```simple
        func(arg1, arg2) \x: x * 2
        ```
        """

        it "works with regular function calls":
            fn apply_twice(x, f):
                f(f(x))

            val result = apply_twice(3, \n: n + 2)
            expect(result).to_equal(7)

        it "combines regular args with trailing block":
            fn apply_with_base(base, x, f):
                base + f(x)

            val result = apply_with_base(10, 5) \n: n * 2
            expect(result).to_equal(20)

    context "with no-parentheses calls":
        """
        ### Scenario: No-Parentheses Calls

        Trailing blocks work naturally with no-paren call syntax.

        ```simple
        map items \x: x * 2
        ```
        """

        it "works without parentheses":
            fn double(x, f):
                f(x)

            val result = double 7 \n: n * 2
            expect(result).to_equal(14)


# ============================================================================
# Method Chaining
# ============================================================================

describe "Trailing Blocks - Method Chaining":
    """
    ## Method Chaining with Trailing Blocks

    Trailing blocks integrate seamlessly with method chaining patterns,
    enabling fluent functional-style APIs.
    """

    context "with sequential operations":
        """
        ### Scenario: Sequential Method Chains

        Trailing blocks can be chained for sequential transformations.

        ```simple
        items.filter \x: x > 0
             .map \x: x * 2
        ```
        """

        it "chains filter and map operations":
            fn filter_list(arr, pred):
                var result = []
                var i = 0
                while i < arr.len():
                    if pred(arr[i]):
                        result.push(arr[i])
                    i = i + 1
                result

            fn map_list(arr, f):
                var result = []
                var i = 0
                while i < arr.len():
                    result.push(f(arr[i]))
                    i = i + 1
                result

            val nums = [1, -2, 3, -4, 5]
            val filtered = filter_list(nums) \x: x > 0
            val doubled = map_list(filtered) \x: x * 2

            expect(doubled[0]).to_equal(2)
            expect(doubled[1]).to_equal(6)
            expect(doubled[2]).to_equal(10)


# ============================================================================
# DSL-Style Usage
# ============================================================================

describe "Trailing Blocks - DSL Patterns":
    """
    ## DSL-Style Patterns

    Trailing blocks enable domain-specific language patterns similar to Ruby.
    """

    context "with builder patterns":
        """
        ### Scenario: Builder Pattern

        Trailing blocks work well with builder/fluent APIs.

        ```simple
        router.get "/hello" \: "Hello World"
        router.post "/user" \req: process(req)
        ```
        """

        it "enables DSL-style APIs with trailing blocks":
            fn create_handler(response, handler):
                val result = handler()
                expect(result).to_equal(response)

            create_handler("ok") \: "ok"
            create_handler("hello") \: "hello"


# ============================================================================
# Edge Cases
# ============================================================================

describe "Trailing Blocks - Edge Cases":
    """
    ## Edge Case Handling

    Tests for unusual trailing block scenarios.
    """

    context "with nested trailing blocks":
        """
        ### Scenario: Nested Trailing Blocks

        Trailing blocks can be nested when function returns another function.
        """

        it "handles nested trailing blocks":
            fn outer(f):
                fn inner(x):
                    f(x)
                inner

            val result = outer \x: x * 2
            val final = result(5)
            expect(final).to_equal(10)

    context "with closures":
        """
        ### Scenario: Closure Captures

        Trailing blocks can capture variables from outer scope.
        """

        it "captures outer variables":
            fn make_adder(base):
                fn add(x, f):
                    f(x)
                add

            val add10 = make_adder(10)
            var captured = 10
            val result = add10(5) \x: x + captured
            expect(result).to_equal(15)


# ============================================================================
# Helper Functions
# ============================================================================

fn map_numbers(arr, f):
    var result = []
    var i = 0
    while i < arr.len():
        result.push(f(arr[i]))
        i = i + 1
    result

fn filter_numbers(arr, pred):
    var result = []
    var i = 0
    while i < arr.len():
        if pred(arr[i]):
            result.push(arr[i])
        i = i + 1
    result
