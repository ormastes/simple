# @pending
# @skip
"""
# Registry Index Specification


**Feature IDs:** #956-958
**Category:** Tooling
**Difficulty:** 2/5
**Status:** In Progress

## Overview
Tests for the sparse package index: parsing SDN entries,
computing index paths, and searching.

## Key Concepts
- SDN index entry parsing
- Sparse directory path computation
- Package listing and search
"""

import std.spec
use std.string.{NL}
use std.string.{NL}

describe "Index Path Computation":
    """
    ## Sparse Index Paths
    Tests for computing the file path for a package in the sparse index.
    """

    it "computes path for 4+ char names":
        val path = index_path_for("http")
        expect(path).to_equal("ht/tp/http.sdn")

    it "computes path for long names":
        val path = index_path_for("collections")
        expect(path).to_equal("co/ll/collections.sdn")

    it "computes path for 3 char names":
        val path = index_path_for("url")
        expect(path).to_equal("ur/l/url.sdn")

    it "computes path for 2 char names":
        val path = index_path_for("io")
        expect(path).to_equal("i/o/io.sdn")

    it "computes path for 1 char names":
        val path = index_path_for("x")
        expect(path).to_equal("_/x/x.sdn")

describe "Index Entry Parsing":
    """
    ## SDN Index Entry Parser
    Tests for parsing package index entries from SDN format.
    """

    it "parses package name":
        val entry = parse_index_entry(sample_entry())
        expect(entry.package.name).to_equal("http")

    it "parses package description":
        val entry = parse_index_entry(sample_entry())
        expect(entry.package.description).to_equal("HTTP client library")

    it "parses version entries":
        val entry = parse_index_entry(sample_entry())
        expect(entry.versions.len()).to_equal(2)

    it "parses version checksum":
        val entry = parse_index_entry(sample_entry())
        expect(entry.versions[0].checksum).to_equal("sha256:abc123")

    it "parses yanked flag":
        val entry = parse_index_entry(sample_entry())
        expect(entry.versions[0].yanked).to_equal(false)

    it "parses dependencies":
        val entry = parse_index_entry(sample_entry())
        expect(entry.dependencies.len()).to_equal(2)

    it "parses dependency constraint":
        val entry = parse_index_entry(sample_entry())
        expect(entry.dependencies[0].constraint).to_equal("^1.0")

describe "Index Queries":
    """
    ## Index Query Functions
    """

    it "finds latest non-yanked version":
        val entry = parse_index_entry(sample_entry())
        val latest = latest_version(entry)
        expect(latest).to_equal("1.1.0")

    it "finds dependencies for a version":
        val entry = parse_index_entry(sample_entry())
        val deps = deps_for_version(entry, "1.1.0")
        expect(deps.len()).to_equal(1)

    it "finds specific version entry":
        val entry = parse_index_entry(sample_entry())
        val ver = find_version(entry, "1.0.0")
        expect(ver.version).to_equal("1.0.0")

    it "returns empty for missing version":
        val entry = parse_index_entry(sample_entry())
        val ver = find_version(entry, "9.9.9")
        expect(ver.version).to_equal("")

# Helpers

fn sample_entry() -> text:
    "package:{NL}  name: http{NL}  description: HTTP client library{NL}  homepage: https://example.com{NL}  license: MIT{NL}  repository: https://github.com/simple-lang/http{NL}{NL}versions |version, checksum, oci_ref, yanked|{NL}  1.0.0, sha256:abc123, ghcr.io/simple-lang/http:1.0.0, false{NL}  1.1.0, sha256:def456, ghcr.io/simple-lang/http:1.1.0, false{NL}{NL}dependencies |version, name, constraint|{NL}  1.0.0, json, ^1.0{NL}  1.1.0, json, ^1.2{NL}"

fn index_path_for(name: text) -> text:
    val len = name.len()
    if len == 1:
        "_/{name}/{name}.sdn"
    elif len == 2:
        "{name[0:1]}/{name[1:2]}/{name}.sdn"
    elif len == 3:
        "{name[0:2]}/{name[2:3]}/{name}.sdn"
    else:
        "{name[0:2]}/{name[2:4]}/{name}.sdn"

fn parse_index_entry(content: text) -> IndexEntry:
    val lines = content.split("{NL}")
    var name = ""
    var description = ""
    var homepage = ""
    var license = ""
    var repository = ""
    var versions = []
    var deps = []
    var section = ""

    for line in lines:
        val trimmed = line.trim()
        if trimmed == "" or trimmed.starts_with("#"):
            pass
        elif trimmed.starts_with("package:"):
            section = "package"
        elif trimmed.starts_with("versions "):
            section = "versions"
        elif trimmed.starts_with("dependencies "):
            section = "dependencies"
        elif section == "package":
            if trimmed.starts_with("name:"):
                name = trimmed[5:].trim()
            elif trimmed.starts_with("description:"):
                description = trimmed[12:].trim()
            elif trimmed.starts_with("homepage:"):
                homepage = trimmed[9:].trim()
            elif trimmed.starts_with("license:"):
                license = trimmed[8:].trim()
            elif trimmed.starts_with("repository:"):
                repository = trimmed[11:].trim()
        elif section == "versions" and trimmed.contains(","):
            val parts = trimmed.split(",")
            if parts.len() >= 4:
                versions.push(VersionEntry(
                    version: parts[0].trim(),
                    checksum: parts[1].trim(),
                    oci_ref: parts[2].trim(),
                    yanked: parts[3].trim() == "true",
                    published_at: ""
                ))
        elif section == "dependencies" and trimmed.contains(","):
            val parts = trimmed.split(",")
            if parts.len() >= 3:
                deps.push(VersionDependency(
                    version: parts[0].trim(),
                    name: parts[1].trim(),
                    constraint: parts[2].trim()
                ))

    IndexEntry(
        package: PackageInfo(name: name, description: description, homepage: homepage, license: license, repository: repository),
        versions: versions,
        dependencies: deps
    )

fn latest_version(entry: IndexEntry) -> text:
    var latest = ""
    for ver in entry.versions:
        if not ver.yanked:
            latest = ver.version
    latest

fn deps_for_version(entry: IndexEntry, version: text) -> [VersionDependency]:
    var result = []
    for dep in entry.dependencies:
        if dep.version == version:
            result.push(dep)
    result

fn find_version(entry: IndexEntry, version: text) -> VersionEntry:
    for ver in entry.versions:
        if ver.version == version:
            return ver
    VersionEntry(version: "", checksum: "", oci_ref: "", yanked: false, published_at: "")

struct PackageInfo:
    name: text
    description: text
    homepage: text
    license: text
    repository: text

struct VersionEntry:
    version: text
    checksum: text
    oci_ref: text
    yanked: bool
    published_at: text

struct VersionDependency:
    version: text
    name: text
    constraint: text

struct IndexEntry:
    package: PackageInfo
    versions: [VersionEntry]
    dependencies: [VersionDependency]
