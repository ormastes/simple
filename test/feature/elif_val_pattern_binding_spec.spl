"""
# Elif Val/Var Pattern Binding Specification


use std.string.{NL}
**Feature IDs:** #1001
**Category:** Language
**Status:** Implemented

## Overview

Tests for `elif val`/`elif var` pattern binding in conditional branches.
Verifies that pattern matching works correctly in elif positions,
matching the existing `if val` support.

## Syntax

```simple
if val Some(x) = expr1:
    use(x)
elif val Some(y) = expr2:
    use(y)
elif condition:
    fallback()
else:
    default()
```
"""


describe "Elif Val Pattern Binding":
    """
    Tests for elif val/var pattern matching in conditional branches.
    """

    context "basic elif val matching":
        """
        ### Scenario: Basic pattern binding in elif

        Tests that elif val correctly matches patterns and binds variables.
        """

        it "matches elif val when if condition is false":
            val x = Some(42)
            var result = ""
            if false:
                result = "if"
            elif val Some(n) = x:
                result = "elif={n}"
            expect result == "elif=42"

        it "skips elif val when pattern does not match":
            var result = "default"
            if false:
                result = "if"
            elif val Some(n) = None:
                result = "elif={n}"
            expect result == "default"

        it "binds variable from elif val pattern":
            val data = Some("hello")
            var captured = ""
            if false:
                pass
            elif val Some(s) = data:
                captured = s
            expect captured == "hello"

    context "elif val with else fallback":
        """
        ### Scenario: Pattern binding with else

        Tests elif val falling through to else when no pattern matches.
        """

        it "falls to else when elif val does not match":
            var result = ""
            if false:
                result = "if"
            elif val Some(n) = None:
                result = "elif"
            else:
                result = "else"
            expect result == "else"

        it "does not reach else when elif val matches":
            var result = ""
            if false:
                result = "if"
            elif val Some(n) = Some(99):
                result = "elif={n}"
            else:
                result = "else"
            expect result == "elif=99"

    context "multiple elif val branches":
        """
        ### Scenario: Chained pattern bindings

        Tests multiple elif val branches evaluated in order.
        """

        it "matches first elif val pattern":
            val a = Some(1)
            val b = Some(2)
            var result = ""
            if false:
                result = "if"
            elif val Some(n) = a:
                result = "first={n}"
            elif val Some(n) = b:
                result = "second={n}"
            expect result == "first=1"

        it "matches second elif val when first does not match":
            val b = Some(2)
            var result = ""
            if false:
                result = "if"
            elif val Some(n) = None:
                result = "first={n}"
            elif val Some(n) = b:
                result = "second={n}"
            expect result == "second=2"

        it "falls through all elif val when none match":
            var result = "none"
            if false:
                result = "if"
            elif val Some(n) = None:
                result = "first"
            elif val Some(n) = None:
                result = "second"
            expect result == "none"

    context "mixed elif and elif val":
        """
        ### Scenario: Regular elif mixed with pattern elif

        Tests combining regular boolean elif with elif val pattern binding.
        """

        it "matches regular elif before elif val":
            var result = ""
            if false:
                result = "if"
            elif true:
                result = "elif-bool"
            elif val Some(n) = Some(42):
                result = "elif-val"
            expect result == "elif-bool"

        it "matches elif val after failed regular elif":
            val x = Some(10)
            var result = ""
            if false:
                result = "if"
            elif false:
                result = "elif-bool"
            elif val Some(n) = x:
                result = "elif-val={n}"
            expect result == "elif-val=10"

        it "matches regular elif after failed elif val":
            var result = ""
            if false:
                result = "if"
            elif val Some(n) = None:
                result = "elif-val"
            elif true:
                result = "elif-bool"
            expect result == "elif-bool"

        it "reaches else after mixed elif failures":
            var result = ""
            if false:
                result = "if"
            elif false:
                result = "elif-bool"
            elif val Some(n) = None:
                result = "elif-val"
            else:
                result = "else"
            expect result == "else"

    context "if val combined with elif val":
        """
        ### Scenario: Pattern binding in both if and elif

        Tests if val at the top combined with elif val.
        """

        it "matches if val and skips elif val":
            var result = ""
            if val Some(n) = Some(1):
                result = "if={n}"
            elif val Some(n) = Some(2):
                result = "elif={n}"
            expect result == "if=1"

        it "skips if val and matches elif val":
            var result = ""
            if val Some(n) = None:
                result = "if"
            elif val Some(n) = Some(2):
                result = "elif={n}"
            expect result == "elif=2"

        it "skips both if val and elif val to else":
            var result = ""
            if val Some(n) = None:
                result = "if"
            elif val Some(n) = None:
                result = "elif"
            else:
                result = "else"
            expect result == "else"

    context "nested option patterns":
        """
        ### Scenario: Various Option patterns in elif val

        Tests nested and varied Option patterns in elif val.
        """

        it "matches nested Some in elif val":
            val inner = Some(Some(99))
            var result = ""
            if val Some(Some(n)) = None:
                result = "none"
            elif val Some(Some(n)) = inner:
                result = "nested={n}"
            expect result == "nested=99"

        it "chains multiple Some patterns":
            val a = None
            val b = None
            val c = Some(7)
            var result = ""
            if val Some(x) = a:
                result = "a={x}"
            elif val Some(x) = b:
                result = "b={x}"
            elif val Some(x) = c:
                result = "c={x}"
            else:
                result = "none"
            expect result == "c=7"

    context "elif val as implicit return":
        """
        ### Scenario: Elif val in expression position

        Tests elif val when the if-elif-else is the last expression in a function.
        """

        it "returns from elif val branch":
            fn classify(opt):
                if val Some(n) = None:
                    "none-matched"
                elif val Some(n) = opt:
                    "got={n}"
                else:
                    "nothing"

            expect classify(Some(7)) == "got=7"
            expect classify(None) == "nothing"

    context "elif val scope isolation":
        """
        ### Scenario: Variable scope in elif val bindings

        Tests that bindings from elif val are properly scoped.
        """

        it "bindings do not leak to outer scope":
            var outer = "unchanged"
            if val Some(n) = None:
                pass
            elif val Some(n) = Some(42):
                outer = "n={n}"
            # n should not be accessible here
            expect outer == "n=42"

    context "elif val with nil/no-match returns nil":
        """
        ### Scenario: No branch matches returns nil

        Tests that when no if/elif/else matches, the result is nil.
        """

        it "returns nil when no branch matches":
            var result = "before"
            if false:
                result = "if"
            elif val Some(n) = None:
                result = "elif"
            # No else - should just continue
            expect result == "before"
