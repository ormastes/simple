# Cross-Platform Support Tests
#
# **Feature ID:** #PLATFORM-001
# **Category:** Platform
# **Status:** In Progress
#
# Tests platform detection, path handling, and process management across Linux, macOS,
# Windows, and FreeBSD. Validates OS detection predicates, platform-specific separators,
# path joining and normalization, absolute path detection, shell command execution,
# and linker auto-detection.

use std.spec
use src.std.platform (is_windows, is_unix, is_linux, is_macos, dir_sep, path_sep, exe_ext, lib_ext)
use std.platform.linker.{auto_detect_linker, get_linker_info}

fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")

# Local path helpers (not in platform module)
fn join_path(base: text, child: text) -> text:
    val sep = dir_sep()
    base + sep + child

fn normalize_path(path: text) -> text:
    var normalized = ""
    for i in 0..path.len():
        val c = path[i:i + 1]
        if c == "\\":
            normalized = normalized + "/"
        else:
            normalized = normalized + c
    normalized

fn is_absolute_path(path: text) -> bool:
    if path.len() == 0:
        return false
    if path.starts_with("/"):
        return true
    false

# ===========================================================================
# Platform Detection Tests
# ===========================================================================

describe "Platform Detection":
    it "detects current operating system":
        val detected = is_windows() or is_unix() or is_linux() or is_macos()
        check(detected)

    it "is_unix returns true on Unix-like systems":
        if is_linux() or is_macos():
            check(is_unix())
        else:
            check(not is_unix() or is_unix())

    it "is_windows and is_unix are mutually exclusive":
        val both = is_windows() and is_unix()
        check(not both)

# ===========================================================================
# Path Separator Tests
# ===========================================================================

describe "Path Separators":
    it "dir_sep returns platform-specific directory separator":
        val sep = dir_sep()
        val valid = sep == "/" or sep == "\\"
        check(valid)

    it "path_sep returns platform-specific PATH separator":
        val sep = path_sep()
        val valid = sep == ":" or sep == ";"
        check(valid)

    it "exe_ext returns correct executable extension":
        val ext = exe_ext()
        val valid = ext == ".exe" or ext == ""
        check(valid)

    it "lib_ext returns correct library extension":
        val ext = lib_ext()
        val valid = ext == ".dll" or ext == ".so" or ext == ".dylib"
        check(valid)

# ===========================================================================
# Path Handling Tests
# ===========================================================================

describe "Path Handling":
    it "join_path combines path components":
        val joined = join_path("foo", "bar")
        val has_foo = joined.contains("foo")
        val has_bar = joined.contains("bar")
        check(has_foo and has_bar)

    it "normalize_path handles forward slashes":
        val normalized = normalize_path("foo/bar")
        check(normalized.len() > 0)

    it "is_absolute_path detects absolute paths":
        val unix_abs = is_absolute_path("/usr/bin")
        val relative = is_absolute_path("foo/bar")
        if not is_windows():
            check(unix_abs)
            check(not relative)
        else:
            check(true)

# ===========================================================================
# Process Management Tests
# ===========================================================================

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn test_shell(command: text) -> (text, text, i64):
    rt_process_run("/bin/sh", ["-c", command])

describe "Process Management":
    it "shell executes simple commands":
        val (out, err, code) = test_shell("echo hello")
        expect(code).to_equal(0)
        expect(out.contains("hello")).to_equal(true)

# ===========================================================================
# Linker Auto-Detection Tests
# ===========================================================================

# Module-level helpers for linker tests (single it block pattern for interpreter compatibility)
fn test_auto_detect_linker() -> bool:
    val linker = auto_detect_linker()
    val name = linker.name()
    name.len() > 0

fn test_get_linker_info() -> bool:
    val info = get_linker_info()
    info.len() > 0

describe "Linker Auto-Detection":
    it "detects system linker and provides info":
        check(test_auto_detect_linker())
        check(test_get_linker_info())
