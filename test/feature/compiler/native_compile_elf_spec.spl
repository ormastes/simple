# # Native Compile ELF Specification
#
# **Feature IDs:** #TBD
# **Category:** Compiler
# **Status:** In Progress
#
# ## Overview
#
# Tests generating a native binary from hand-crafted x86_64 instructions
# through the ELF writer pipeline: instructions → ELF → link → run.

use std.spec
use backend.native.elf_writer.*
use backend.native.mach_inst.*


extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn shell(command: text) -> (text, text, i64):
    rt_process_run("sh", ["-c", command])

fn byte_to_hex(b: i64) -> text:
    val digits = "0123456789abcdef"
    val hi = b / 16
    val lo = b % 16
    val h = digits[hi]
    val l = digits[lo]
    "{h}{l}"


fn skip_on_interpreter(name: text, block: fn()):
    print "    it {name} ... skipped (interpreter mode)"

describe "Native Compile ELF":
    it "generates a valid ELF binary from x86_64 machine code":
        skip_on_interpreter "requires native ELF writer":
            # main: push rbp; mov rbp,rsp; xor eax,eax; pop rbp; ret
            val code = [0x55, 0x48, 0x89, 0xe5, 0x31, 0xc0, 0x5d, 0xc3]
            var writer = elf_writer_x86_64()
            var text_section = new_text_section(code)
            writer = elf_add_section(writer, text_section)
            writer = elf_add_symbol(writer, new_func_symbol("main", 1, 0, code.len()))
            val elf_bytes = write_elf64(writer)
            expect(elf_bytes.len() > 0).to_equal(true)

    it "produces a linkable and runnable binary with exit 0":
        skip_on_interpreter "requires native backend and linker":
            val code = [0x55, 0x48, 0x89, 0xe5, 0x31, 0xc0, 0x5d, 0xc3]
            var writer = elf_writer_x86_64()
            var text_section = new_text_section(code)
            writer = elf_add_section(writer, text_section)
            writer = elf_add_symbol(writer, new_func_symbol("main", 1, 0, code.len()))
            val elf_bytes = write_elf64(writer)

            var offset = 0
            while offset < elf_bytes.len():
                var chunk = ""
                var end_idx = offset + 800
                if end_idx > elf_bytes.len():
                    end_idx = elf_bytes.len()
                var j = offset
                while j < end_idx:
                    chunk = chunk + byte_to_hex(elf_bytes[j])
                    j = j + 1
                if offset == 0:
                    shell("echo -n '{chunk}' > /tmp/elf_spec.hex")
                else:
                    shell("echo -n '{chunk}' >> /tmp/elf_spec.hex")
                offset = end_idx

            shell("xxd -r -p /tmp/elf_spec.hex /tmp/elf_spec.o")
            shell("rm -f /tmp/elf_spec.hex")
            val link_r = rt_process_run("cc", ["-o", "/tmp/elf_spec", "/tmp/elf_spec.o", "-no-pie"])
            expect(link_r[2]).to_equal(0)
