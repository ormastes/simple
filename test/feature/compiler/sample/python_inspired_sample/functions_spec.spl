# # Functions Specification (Python-Inspired)
#
#
# **Feature IDs:** #PYTHON-COMPAT-FUNC
# **Category:** Functions
# **Status:** Planned
#
# This specification tests function definition and calling patterns that
# Python developers will find familiar. Simple supports implicit returns,
# default arguments, and named parameters similar to Python.
#
# ## Covered Features
#
# - Function definition with `fn` keyword
# - Implicit return (last expression)
# - Explicit return statements
# - Default parameter values
# - Named arguments at call site
# - Higher-order functions (functions as values)
import std.spec

describe "Functions":
    # ## Python-Inspired Function Syntax
    #
    # Tests for function definitions, parameters, and calling conventions.
    # Simple's function syntax is designed to feel natural to Python developers
    # while providing optional type annotations.
    #
    # Key areas tested:
    # - Basic function definition and calling
    # - Implicit returns (last expression returned)
    # - Parameters with default values
    # - Named arguments for clarity
    # - Closures and higher-order functions

    context "basic functions":
        it "defines and calls simple function":
            fn add(a: i64, b: i64) -> i64:
                a + b
            expect add(2, 3) == 5

        it "uses implicit return":
            fn square(x: i64) -> i64:
                x * x
            expect square(4) == 16

        it "uses explicit return":
            fn early_return(x: i64) -> i64:
                if x < 0:
                    return 0
                x * 2
            expect early_return(-5) == 0
            expect early_return(5) == 10

    context "default parameters":
        it "uses default when argument omitted":
            fn greet(name: text, greeting: text = "Hello") -> text:
                "{greeting}, {name}!"
            expect greet("Alice") == "Hello, Alice!"

        it "overrides default with explicit value":
            fn greet(name: text, greeting: text = "Hello") -> text:
                "{greeting}, {name}!"
            expect greet("Bob", "Hi") == "Hi, Bob!"

    context "named arguments":
        it "passes arguments by name":
            fn describe(name: text, age: i64) -> text:
                "{name} is {age} years old"
            expect describe(name: "Alice", age: 30) == "Alice is 30 years old"

        it "reorders with named arguments":
            fn describe(name: text, age: i64) -> text:
                "{name} is {age} years old"
            expect describe(age: 25, name: "Bob") == "Bob is 25 years old"

    context "higher-order functions":
        it "passes function as argument":
            fn apply(f: fn(i64) -> i64, x: i64) -> i64:
                f(x)
            fn double(n: i64) -> i64:
                n * 2
            expect apply(double, 5) == 10

        it "uses lambda expression":
            val numbers = [1, 2, 3, 4]
            val doubled = numbers.map(\x: x * 2)
            expect doubled[0] == 2
            expect doubled[3] == 8
