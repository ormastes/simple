# Direct ELF Writing Tests (Phase 2.1)
#
# Tests for direct ELF binary writing functionality without assembler intermediary.

use std.spec
use compiler.linker.linker_wrapper.{write_elf_bytes_to_file, verify_elf_file, should_use_direct_elf_writing, Result}

# Need to create symlink for io functions
use app.io.{file_exists, file_delete, file_read_bytes}

# External FFI for direct byte writing (test bypass)
extern fn rt_file_write_bytes(path: text, data: [u8]) -> bool

describe "Phase 2.1: Direct ELF Writing":
    context "Helper Functions":
        it "detects direct ELF writing should be enabled by default":
            val result = should_use_direct_elf_writing()
            expect(result).to_equal(true)

        it "verifies valid ELF file":
            val test_path = "/tmp/test_elf_valid.o"

            # Create minimal valid ELF file (magic number only for this test)
            val elf_magic: [u8] = [127, 69, 76, 70]  # 0x7F 'E' 'L' 'F'
            val padding: [u8] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            val minimal_elf = elf_magic + padding

            val write_result = write_elf_bytes_to_file(test_path, minimal_elf)
            expect(write_result.is_ok()).to_equal(true)

            val verify_result = verify_elf_file(test_path)
            expect(verify_result).to_equal(true)

            file_delete(test_path)

        it "rejects invalid ELF magic number":
            val test_path = "/tmp/test_elf_invalid.o"

            # Wrong magic bytes
            val bad_magic: [u8] = [1, 2, 3, 4, 0, 0, 0, 0]

            val write_result = write_elf_bytes_to_file(test_path, bad_magic)
            expect(write_result.is_err()).to_equal(true)

        it "rejects too-small file":
            val test_path = "/tmp/test_elf_small.o"

            # Only 2 bytes (need at least 4 for magic)
            val tiny_file: [u8] = [127, 69]

            val write_result = write_elf_bytes_to_file(test_path, tiny_file)
            expect(write_result.is_err()).to_equal(true)

    context "ELF Magic Number Verification":
        it "accepts correct ELF magic: 0x7F 'E' 'L' 'F'":
            val elf_bytes: [u8] = [127, 69, 76, 70, 1, 1, 1, 0]  # ELF header start
            val test_path = "/tmp/test_magic_ok.o"

            val result = write_elf_bytes_to_file(test_path, elf_bytes)
            expect(result.is_ok()).to_equal(true)

            # Verify the file was created
            expect(file_exists(test_path)).to_equal(true)

            # Verify the magic number in the file
            val read_bytes = file_read_bytes(test_path)
            expect(read_bytes[0]).to_equal(127)
            expect(read_bytes[1]).to_equal(69)
            expect(read_bytes[2]).to_equal(76)
            expect(read_bytes[3]).to_equal(70)

            file_delete(test_path)

        it "rejects wrong first byte":
            val bad_bytes: [u8] = [128, 69, 76, 70, 0, 0, 0, 0]
            val result = write_elf_bytes_to_file("/tmp/bad1.o", bad_bytes)
            expect(result.is_err()).to_equal(true)

        it "rejects wrong second byte":
            val bad_bytes: [u8] = [127, 70, 76, 70, 0, 0, 0, 0]
            val result = write_elf_bytes_to_file("/tmp/bad2.o", bad_bytes)
            expect(result.is_err()).to_equal(true)

        it "rejects wrong third byte":
            val bad_bytes: [u8] = [127, 69, 77, 70, 0, 0, 0, 0]
            val result = write_elf_bytes_to_file("/tmp/bad3.o", bad_bytes)
            expect(result.is_err()).to_equal(true)

        it "rejects wrong fourth byte":
            val bad_bytes: [u8] = [127, 69, 76, 71, 0, 0, 0, 0]
            val result = write_elf_bytes_to_file("/tmp/bad4.o", bad_bytes)
            expect(result.is_err()).to_equal(true)

    context "File Operations":
        it "creates file with correct permissions":
            val elf_bytes: [u8] = [127, 69, 76, 70, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            val test_path = "/tmp/test_permissions.o"

            val result = write_elf_bytes_to_file(test_path, elf_bytes)
            expect(result.is_ok()).to_equal(true)
            expect(file_exists(test_path)).to_equal(true)

            file_delete(test_path)

        it "overwrites existing file":
            val test_path = "/tmp/test_overwrite.o"

            # Write first version
            val elf_v1: [u8] = [127, 69, 76, 70, 1, 0, 0, 0]
            val r1 = write_elf_bytes_to_file(test_path, elf_v1)
            expect(r1.is_ok()).to_equal(true)

            # Overwrite with second version
            val elf_v2: [u8] = [127, 69, 76, 70, 2, 0, 0, 0, 0, 0, 0, 0]
            val r2 = write_elf_bytes_to_file(test_path, elf_v2)
            expect(r2.is_ok()).to_equal(true)

            # Verify second version is present
            val read = file_read_bytes(test_path)
            expect(read[4]).to_equal(2)

            file_delete(test_path)

        it "handles empty path gracefully":
            val elf_bytes: [u8] = [127, 69, 76, 70, 0, 0, 0, 0]
            val result = write_elf_bytes_to_file("", elf_bytes)
            expect(result.is_err()).to_equal(true)

    context "Integration with verify_elf_file":
        it "verify returns false for non-existent file":
            val result = verify_elf_file("/tmp/nonexistent_file_xyz.o")
            expect(result).to_equal(false)

        it "verify returns false for non-ELF file":
            val test_path = "/tmp/test_not_elf.txt"
            val non_elf: [u8] = [80, 75, 3, 4, 0, 0, 0, 0]  # ZIP magic

            # Write directly (bypass validation)
            extern fn rt_file_write_bytes(path: text, data: [u8]) -> bool
            rt_file_write_bytes(test_path, non_elf)

            val result = verify_elf_file(test_path)
            expect(result).to_equal(false)

            file_delete(test_path)

        it "verify returns true for valid ELF":
            val test_path = "/tmp/test_verify_valid.o"
            val elf_bytes: [u8] = [127, 69, 76, 70, 2, 1, 1, 0]

            val write_result = write_elf_bytes_to_file(test_path, elf_bytes)
            expect(write_result.is_ok()).to_equal(true)

            val verify_result = verify_elf_file(test_path)
            expect(verify_result).to_equal(true)

            file_delete(test_path)
