"""
# MIR Complex Specification

**Feature IDs:** #TBD
**Category:** Compiler
**Status:** In Progress

## Overview

Tests arithmetic, control flow (if/else), and multiple function calls
through the ISel → RegAlloc → Encode → ELF pipeline using manually
constructed MIR.
"""

use std.spec
use compiler.mir_data.*
use compiler.backend.native.isel_x86_64.{isel_module}
use compiler.backend.native.regalloc.{regalloc_module}
use compiler.backend.native.encode_x86_64.{encode_module}
use compiler.backend.native.mach_inst.{MachModule, EncodedFunction}
use compiler.backend.native.elf_writer.{ElfWriter, ElfReloc, ElfRelocType, ElfSymbol, ElfSymbolBind, ElfSymbolType, elf_writer_x86_64, elf_add_section, elf_add_symbol, new_text_section, new_rodata_section, section_add_reloc, new_func_symbol, new_extern_symbol, write_elf64}


extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn shell(command: text) -> (text, text, i64):
    rt_process_run("sh", ["-c", command])

fn byte_to_hex(b: i64) -> text:
    val digits = "0123456789abcdef"
    "{digits[b / 16]}{digits[b % 16]}"

fn emit_elf_complex(encoded: [EncodedFunction], mach_mod: MachModule) -> [i64]:
    var writer = elf_writer_x86_64()
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [ElfReloc] = []
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    var rodata_off = 0
    var data_label_off: Dict<text, i64> = {}
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx.contains(entry.name):
                val idx = sym_names.len()
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_off[entry.name] = rodata_off
            rodata_off = rodata_off + entry.data.len()

    for ext_sym in mach_mod.extern_symbols:
        if not sym_name_to_idx.contains(ext_sym):
            val idx = sym_names.len()
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    for func in encoded:
        if not sym_name_to_idx.contains(func.name):
            val idx = sym_names.len()
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    var num_cs = 1
    var has_ro = false
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            has_ro = true
    if has_ro:
        num_cs = num_cs + 1
    val sym_base = 1 + num_cs

    for func in encoded:
        var padding = all_code.len() % 16
        if padding != 0:
            padding = 16 - padding
        var pi = 0
        while pi < padding:
            all_code = all_code + [0xcc]
            pi = pi + 1
        func_offsets[func.name] = all_code.len()
        val code_start = all_code.len()
        all_code = all_code + func.code
        for reloc in func.relocations:
            var reloc_type = ElfRelocType.X86_64_PLT32
            if reloc.reloc_type == 2:
                reloc_type = ElfRelocType.X86_64_PC32
            elif reloc.reloc_type == 1:
                reloc_type = ElfRelocType.X86_64_64
            var sym_idx = 0
            if sym_name_to_idx.contains(reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]
            all_relocs = all_relocs + [ElfReloc(
                offset: code_start + reloc.offset,
                reloc_type: reloc_type,
                symbol_index: sym_base + sym_idx,
                addend: reloc.addend
            )]

    var text_section = new_text_section(all_code)
    for reloc in all_relocs:
        text_section = section_add_reloc(text_section, reloc)
    writer = elf_add_section(writer, text_section)

    var rodata_bytes: [i64] = []
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            rodata_bytes = rodata_bytes + entry.data
    if rodata_bytes.len() > 0:
        writer = elf_add_section(writer, new_rodata_section(rodata_bytes))

    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            if data_label_off.contains(entry.name):
                writer = elf_add_symbol(writer, ElfSymbol(
                    name: entry.name,
                    sym_bind: ElfSymbolBind.Local,
                    sym_type: ElfSymbolType.Object,
                    section_index: 2,
                    value: data_label_off[entry.name],
                    size: entry.data.len()
                ))

    for ext_sym in mach_mod.extern_symbols:
        writer = elf_add_symbol(writer, new_extern_symbol(ext_sym))
    for func in encoded:
        var fo = 0
        if func_offsets.contains(func.name):
            fo = func_offsets[func.name]
        writer = elf_add_symbol(writer, new_func_symbol(func.name, 1, fo, func.code.len()))
    write_elf64(writer)

fn build_complex_module() -> MirModule:
    val i64_type = MirType(kind: MirTypeKind.I64)
    val bool_type = MirType(kind: MirTypeKind.Bool)
    val main_sig = MirSignature(params: [], return_type: i64_type, is_variadic: false)
    val locals = [
        MirLocal(id: LocalId(id: 0), name: Some("_return"), type_: i64_type, kind: LocalKind.Return),
        MirLocal(id: LocalId(id: 1), name: Some("a"), type_: i64_type, kind: LocalKind.Temp),
        MirLocal(id: LocalId(id: 2), name: Some("b"), type_: i64_type, kind: LocalKind.Temp),
        MirLocal(id: LocalId(id: 3), name: Some("c"), type_: i64_type, kind: LocalKind.Temp),
        MirLocal(id: LocalId(id: 4), name: Some("cond"), type_: bool_type, kind: LocalKind.Temp),
        MirLocal(id: LocalId(id: 5), name: Some("str_ptr"), type_: i64_type, kind: LocalKind.Temp),
        MirLocal(id: LocalId(id: 6), name: Some("ret_val"), type_: i64_type, kind: LocalKind.Temp)
    ]
    val entry_block = MirBlock(
        id: BlockId.new(0), label: Some("entry"),
        instructions: [
            MirInst(kind: MirInstKind.Const(LocalId(id: 1), MirConstValue.Int(10), i64_type), span: nil),
            MirInst(kind: MirInstKind.Const(LocalId(id: 2), MirConstValue.Int(32), i64_type), span: nil),
            MirInst(kind: MirInstKind.BinOp(LocalId(id: 3), MirBinOp.Add, MirOperand(kind: MirOperandKind.Copy(LocalId(id: 1))), MirOperand(kind: MirOperandKind.Copy(LocalId(id: 2)))), span: nil),
            MirInst(kind: MirInstKind.BinOp(LocalId(id: 4), MirBinOp.Eq, MirOperand(kind: MirOperandKind.Copy(LocalId(id: 3))), MirOperand(kind: MirOperandKind.Const(MirConstValue.Int(42), i64_type))), span: nil)
        ],
        terminator: MirTerminator.If(MirOperand(kind: MirOperandKind.Copy(LocalId(id: 4))), BlockId.new(1), BlockId.new(2))
    )
    val then_block = MirBlock(id: BlockId.new(1), label: Some("then"),
        instructions: [MirInst(kind: MirInstKind.Const(LocalId(id: 5), MirConstValue.Str("42"), i64_type), span: nil), MirInst(kind: MirInstKind.Call(nil, MirOperand(kind: MirOperandKind.Const(MirConstValue.Str("puts"), i64_type)), [MirOperand(kind: MirOperandKind.Copy(LocalId(id: 5)))]), span: nil)],
        terminator: MirTerminator.Goto(BlockId.new(3)))
    val else_block = MirBlock(id: BlockId.new(2), label: Some("else"),
        instructions: [MirInst(kind: MirInstKind.Const(LocalId(id: 5), MirConstValue.Str("wrong"), i64_type), span: nil), MirInst(kind: MirInstKind.Call(nil, MirOperand(kind: MirOperandKind.Const(MirConstValue.Str("puts"), i64_type)), [MirOperand(kind: MirOperandKind.Copy(LocalId(id: 5)))]), span: nil)],
        terminator: MirTerminator.Goto(BlockId.new(3)))
    val exit_block = MirBlock(id: BlockId.new(3), label: Some("exit"),
        instructions: [MirInst(kind: MirInstKind.Const(LocalId(id: 6), MirConstValue.Int(0), i64_type), span: nil)],
        terminator: MirTerminator.Return(Some(MirOperand(kind: MirOperandKind.Copy(LocalId(id: 6))))))
    val dummy_span = Span(start: 0, end: 0, line: 0, col: 0)
    val main_func = MirFunction(symbol: SymbolId.new(0), name: "main", signature: main_sig, locals: locals, blocks: [entry_block, then_block, else_block, exit_block], entry_block: BlockId.new(0), span: dummy_span, generic_params: [], is_generic_template: false, specialization_of: nil, type_bindings: {})
    var functions: Dict<SymbolId, MirFunction> = {}
    functions[SymbolId.new(0)] = main_func
    MirModule(name: "complex_test", functions: functions, statics: {}, constants: {}, types: {})


describe "MIR Complex":
    it "compiles arithmetic and if/else MIR and outputs '42'":
        skip_on_interpreter "requires native backend and linker":
            val module = build_complex_module()
            val mach_module = isel_module(module)
            val allocated = regalloc_module(mach_module)
            val encoded_funcs = encode_module(allocated)
            val elf_bytes = emit_elf_complex(encoded_funcs, allocated)

            var offset = 0
            while offset < elf_bytes.len():
                var chunk = ""
                var end_idx = offset + 800
                if end_idx > elf_bytes.len():
                    end_idx = elf_bytes.len()
                var j = offset
                while j < end_idx:
                    chunk = chunk + byte_to_hex(elf_bytes[j])
                    j = j + 1
                if offset == 0:
                    shell("echo -n '{chunk}' > /tmp/mir_complex_spec.hex")
                else:
                    shell("echo -n '{chunk}' >> /tmp/mir_complex_spec.hex")
                offset = end_idx

            shell("xxd -r -p /tmp/mir_complex_spec.hex /tmp/mir_complex_spec.o")
            shell("rm -f /tmp/mir_complex_spec.hex")
            val link_r = rt_process_run("cc", ["-o", "/tmp/mir_complex_spec", "/tmp/mir_complex_spec.o", "-no-pie"])
            expect(link_r[2]).to_equal(0)

            val run_r = rt_process_run("/tmp/mir_complex_spec", [])
            expect(run_r[0].trim()).to_equal("42")
