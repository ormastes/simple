# @pending
"""
# Class Invariant Specification

**Feature IDs:** #CONTRACT-INV-001 to #CONTRACT-INV-018
**Category:** Type System | Contracts
**Status:** Implemented

Tests that class invariants are properly checked:
- After constructor execution (even if constructor is private)
- Before/after public method execution
- NOT checked for private methods

## Syntax

```simple
class Counter:
    value: i64

    invariant:
        self.value >= 0

    static fn new() -> Counter:
        Counter(value: 0)

    me increment():
        self.value = self.value + 1
```
"""



# ============================================================================
# Test Group 1: Constructor Invariant Checks
# ============================================================================

describe "Constructor Invariant Checks":
    """
    ## Constructor Exit Invariants

    Tests that constructors check class invariants on exit.
    """

    it "checks invariant after constructor":
        class Counter:
            value: i64

            invariant:
                self.value >= 0

            static fn new(initial: i64) -> Counter:
                Counter(value: initial)

        val c = Counter__new(10)
        expect c.value == 10

    it "checks multiple invariants after constructor":
        class BoundedCounter:
            value: i64
            max: i64

            invariant:
                self.value >= 0
                self.value <= self.max
                self.max > 0

            static fn new(initial: i64, maximum: i64) -> BoundedCounter:
                BoundedCounter(value: initial, max: maximum)

        val bc = BoundedCounter__new(5, 100)
        expect bc.value == 5

    it "private constructor gets invariant check":
        class Account:
            balance: i64

            invariant:
                self.balance >= 0

            static fn new(initial_balance: i64) -> Account:
                Account(balance: initial_balance)

            static fn create_with_deposit(amount: i64) -> Account:
                Account__new(amount)

        val acc = Account__create_with_deposit(100)
        expect acc.balance == 100

    it "constructor with precondition and invariant":
        class PositiveValue:
            value: i64

            invariant:
                self.value > 0

            static fn new(x: i64) -> PositiveValue:
                in:
                    x > 0
                PositiveValue(value: x)

        val pv = PositiveValue__new(42)
        expect pv.value == 42


# ============================================================================
# Test Group 2: Public Method Invariant Checks
# ============================================================================

describe "Public Method Invariant Checks":
    """
    ## Method Entry/Exit Invariants

    Tests that public methods check invariants at entry and exit.
    """

    it "public method checks invariants":
        class Counter:
            value: i64

            invariant:
                self.value >= 0

            static fn new() -> Counter:
                Counter(value: 0)

            me increment():
                self.value = self.value + 1

            me decrement():
                in:
                    self.value > 0
                self.value = self.value - 1

        var c = Counter__new()
        c.increment()
        expect c.value == 1
        c.decrement()
        expect c.value == 0

    it "private method skips invariants":
        class Counter:
            value: i64

            invariant:
                self.value >= 0

            static fn new() -> Counter:
                Counter(value: 0)

            me internal_set(new_value: i64):
                self.value = new_value

            me safe_set(new_value: i64):
                if new_value >= 0:
                    self.internal_set(new_value)

        var c = Counter__new()
        c.safe_set(42)
        expect c.value == 42

    it "complex invariant with field comparison":
        class Range:
            min: i64
            max: i64

            invariant:
                self.min <= self.max
                self.max >= 0

            static fn new(a: i64, b: i64) -> Range:
                Range(min: a, max: b)

            me expand(delta: i64):
                self.max = self.max + delta

        var r = Range__new(0, 10)
        r.expand(5)
        expect r.max == 15


# ============================================================================
# Test Group 3: Multiple Classes with Invariants
# ============================================================================

describe "Multiple Classes with Invariants":
    """
    ## Class Separation

    Tests that each class has its own invariants.
    """

    it "separate invariants per class":
        class Account:
            balance: i64

            invariant:
                self.balance >= 0

            static fn new(initial: i64) -> Account:
                Account(balance: initial)

        class Transaction:
            amount: i64
            timestamp: i64

            invariant:
                self.amount > 0
                self.timestamp >= 0

            static fn new(amt: i64, ts: i64) -> Transaction:
                Transaction(amount: amt, timestamp: ts)

        val acc = Account__new(100)
        val tx = Transaction__new(50, 1234567890)
        expect acc.balance == 100
        expect tx.amount == 50


# ============================================================================
# Test Group 4: Inheritance and Invariants
# ============================================================================

describe "Inheritance and Invariants":
    """
    ## Inherited Invariants

    Tests that child classes maintain parent invariants.
    """

    it "child maintains parent invariant", tag: ["skip"]:
        # Skip: Inheritance with parent fields not fully supported in block-scope
        class Vehicle:
            speed: i64

            invariant:
                self.speed >= 0

        class Car extends Vehicle:
            fuel: i64

            invariant:
                self.fuel >= 0
                self.fuel <= 100

            static fn new(initial_fuel: i64) -> Car:
                Car(speed: 0, fuel: initial_fuel)

        val car = Car__new(50)
        expect car.speed == 0
        expect car.fuel == 50


# ============================================================================
# Test Group 5: Edge Cases
# ============================================================================

describe "Class Invariant Edge Cases":
    """
    ## Special Cases

    Tests edge cases for class invariants.
    """

    it "class without invariant works":
        class Simple:
            value: i64

            static fn new(value: i64) -> Simple:
                Simple(value: value)

            pub fn get_value() -> i64:
                self.value

        val s = Simple__new(42)
        expect s.get_value() == 42

    it "invariant can reference pure methods":
        class ValueHolder:
            value: i64

            fn is_positive() -> bool:
                self.value > 0

            invariant:
                self.is_positive()

            static fn new(v: i64) -> ValueHolder:
                ValueHolder(value: v)

        val vh = ValueHolder__new(42)
        expect vh.value == 42


# ============================================================================
# Test Group 6: Constructor Visibility Tests
# ============================================================================

describe "Constructor Visibility":
    """
    ## Constructor Detection

    Tests invariants with different constructor visibilities.
    """

    it "explicitly public constructor gets invariants":
        class Public:
            value: i64

            invariant:
                self.value >= 0

            static fn new(value: i64) -> Public:
                Public(value: value)

        val p = Public__new(42)
        expect p.value == 42

    it "constructor detected by name":
        class Counter:
            count: i64

            invariant:
                self.count >= 0

            static fn new() -> Counter:
                Counter(count: 0)

            static fn from_value(value: i64) -> Counter:
                Counter(count: value)

        val c1 = Counter__new()
        val c2 = Counter__from_value(42)
        expect c1.count == 0
        expect c2.count == 42


# ============================================================================
# Test Group 7: Complete Integration
# ============================================================================

describe "Complete Class Contract Integration":
    """
    ## Full Contract Specification

    Tests complete class with all contract types.
    """

    it "bank account with full contracts":
        class BankAccount:
            balance: i64
            owner: str

            invariant:
                self.balance >= 0

            static fn new(owner_name: str) -> BankAccount:
                in:
                    owner_name.len() > 0
                BankAccount(balance: 0, owner: owner_name)

            static fn from_balance(owner_name: str, initial: i64) -> BankAccount:
                in:
                    owner_name.len() > 0
                    initial >= 0
                BankAccount(balance: initial, owner: owner_name)

            me deposit(amount: i64):
                in:
                    amount > 0
                out():
                    self.balance == old(self.balance) + amount
                self.balance = self.balance + amount

            me withdraw(amount: i64) -> bool:
                in:
                    amount > 0
                if self.balance >= amount:
                    self.balance = self.balance - amount
                    true
                else:
                    false

            pub fn get_balance() -> i64:
                self.balance

        var acc = BankAccount__from_balance("Alice", 100)
        acc.deposit(50)
        expect acc.get_balance() == 150
        val success = acc.withdraw(30)
        expect success
        expect acc.get_balance() == 120


# ============================================================================
# Test Group 8: Factory Methods
# ============================================================================

describe "Factory Method Invariants":
    """
    ## Factory Methods

    Tests factory methods get invariant checks.
    """

    it "factory methods get invariants":
        class Config:
            timeout: i64
            retries: i64

            invariant:
                self.timeout > 0
                self.retries >= 0
                self.retries <= 10

            static fn create_default() -> Config:
                Config(timeout: 30, retries: 3)

            static fn from_timeout(t: i64) -> Config:
                Config(timeout: t, retries: 3)

            static fn with_retries(r: i64) -> Config:
                Config(timeout: 30, retries: r)

            static fn from_values(t: i64, r: i64) -> Config:
                Config(timeout: t, retries: r)

        val c1 = Config__create_default()
        val c2 = Config__from_timeout(60)
        val c3 = Config__with_retries(5)
        expect c1.timeout == 30
        expect c2.timeout == 60
        expect c3.retries == 5


# ============================================================================
# Test Group 9: Struct with Invariants
# ============================================================================

describe "Struct Invariants":
    """
    ## Struct Contracts

    Tests structs work the same as classes.
    """

    it "struct has invariant checks", tag: ["skip"]:
        # Skip: Struct static methods not supported in block-scope
        struct Point:
            x: i64
            y: i64

            invariant:
                self.x >= 0
                self.y >= 0

            static fn new(x_val: i64, y_val: i64) -> Point:
                Point(x: x_val, y: y_val)

            static fn origin() -> Point:
                Point(x: 0, y: 0)

            fn distance_squared(self) -> i64:
                self.x * self.x + self.y * self.y

        val p = Point__new(3, 4)
        expect p.distance_squared() == 25

