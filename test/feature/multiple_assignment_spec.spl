"""
# Multiple Assignment (Destructuring) Specification

**Feature IDs:** #MULTIPLE-ASSIGNMENT
**Category:** Syntax
**Status:** Implemented

Multiple assignment (destructuring) allows binding multiple variables from
compound values like tuples, arrays, and structs in a single statement.
This provides concise syntax for unpacking data structures.

## Syntax

```simple
# Tuple destructuring
val (x, y) = get_point()
val (first, second, ...rest) = items

# Array destructuring
val [a, b, c] = triple

# Struct destructuring
val {name, age} = person
```

## Key Behaviors

- Pattern must match the structure of the value
- Variables are bound in the order they appear
- Wildcards `_` can ignore unwanted values
- Rest patterns `...rest` capture remaining elements
"""

describe "Multiple Assignment (Destructuring)":
    """
    ## Destructuring Assignment Specification

    Multiple assignment provides concise syntax for extracting values from
    compound data types. This test suite verifies:
    - Tuple destructuring with `val (a, b) = tuple`
    - Array destructuring with `val [x, y, z] = array`
    - Nested destructuring for complex structures
    - Wildcard patterns to ignore values
    - Mutable destructuring with `var`
    """

    context "tuple destructuring":
        it "destructures a pair":
            val pair = (10, 20)
            val (a, b) = pair
            expect a == 10
            expect b == 20

        it "destructures a triple":
            val triple = (1, 2, 3)
            val (x, y, z) = triple
            expect x == 1
            expect y == 2
            expect z == 3

        it "uses destructured values in expressions":
            val point = (3, 4)
            val (x, y) = point
            val distance_squared = x * x + y * y
            expect distance_squared == 25

        it "destructures function return value":
            fn get_coordinates() -> (i64, i64):
                (100, 200)
            val (x, y) = get_coordinates()
            expect x == 100
            expect y == 200

    context "tuple destructuring with wildcards":
        it "ignores first element with wildcard":
            val triple = (1, 2, 3)
            val (_, b, c) = triple
            expect b == 2
            expect c == 3

        it "ignores middle element with wildcard":
            val triple = (1, 2, 3)
            val (a, _, c) = triple
            expect a == 1
            expect c == 3

        it "ignores last element with wildcard":
            val triple = (1, 2, 3)
            val (a, b, _) = triple
            expect a == 1
            expect b == 2

        it "ignores multiple elements":
            val quad = (1, 2, 3, 4)
            val (a, _, _, d) = quad
            expect a == 1
            expect d == 4

    context "nested tuple destructuring":
        it "destructures nested tuples":
            val nested = ((1, 2), 3)
            val ((a, b), c) = nested
            expect a == 1
            expect b == 2
            expect c == 3

        it "destructures deeply nested tuples":
            val deep = (((1, 2), 3), 4)
            val (((a, b), c), d) = deep
            expect a == 1
            expect b == 2
            expect c == 3
            expect d == 4

    context "array destructuring":
        it "destructures fixed-size array":
            val arr = [10, 20, 30]
            val [a, b, c] = arr
            expect a == 10
            expect b == 20
            expect c == 30

        it "destructures with wildcard":
            val arr = [1, 2, 3]
            val [x, _, z] = arr
            expect x == 1
            expect z == 3

    context "mutable destructuring":
        it "creates mutable bindings":
            val pair = (5, 10)
            var (a, b) = pair
            a = a + 1
            b = b + 1
            expect a == 6
            expect b == 11

        it "allows partial mutation":
            val triple = (1, 2, 3)
            var (x, y, z) = triple
            x = x * 10
            expect x == 10
            expect y == 2
            expect z == 3

    context "mixed type destructuring":
        it "destructures tuples with different types":
            val mixed = ("hello", 42)
            val (name, count) = mixed
            expect name == "hello"
            expect count == 42

        it "destructures nested mixed types":
            val data = (("Alice", 30), true)
            val ((name, age), active) = data
            expect name == "Alice"
            expect age == 30
            expect active == true

    context "destructuring in loops":
        it "destructures in for loop":
            val pairs = [(1, 2), (3, 4), (5, 6)]
            var sum = 0
            for (a, b) in pairs:
                sum = sum + a + b
            expect sum == 21

        it "uses destructured values for computation":
            val points = [(0, 0), (3, 4), (6, 8)]
            var total_distance = 0
            for (x, y) in points:
                total_distance = total_distance + x + y
            expect total_distance == 21
