# # Interpreter Runtime Error Stack Trace
#
# **Feature ID:** #RUNTIME-002
# **Category:** Runtime
# **Status:** Active
#
# ## Overview
#
# System test that runs the interpreter CLI against a sample script to verify that runtime errors
# include a full call stack section. Validates that when calling nested functions that trigger an
# undefined function error, the output includes the "Runtime error" header, the specific error
# message, a "Call stack:" section, and frame entries for each function in the call chain
# (level1, level2, level3).
#
# ## Syntax
#
# ```simple
# val result = run_interpreter(["src/app/interpreter/main.spl", script])
# expect result.exit_code != 0
# expect result.stderr.contains("Call stack:")
# expect result.stderr.contains("level1")
# ```
# Interpreter Runtime Error Stack Trace - System Test
#
# Runs the interpreter CLI against a sample script to verify
# that runtime errors include a call stack section.

use std.spec

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

struct ProcResult:
    stdout: text
    stderr: text
    exit_code: i64

fn run_interpreter(args: [text]) -> ProcResult:
    val (stdout, stderr, code) = rt_process_run("bin/release/simple", args)
    ProcResult(stdout: stdout, stderr: stderr, exit_code: code)

describe "Interpreter Runtime Error Stack Trace":
    it "includes call stack for nested functions":
        val script = "test/system/interpreter/sample/runtime_error_stack.spl"
        val result = run_interpreter(["src/app/interpreter/main.spl", script])
        expect result.exit_code != 0
        expect result.stderr.contains("Runtime error")
        expect result.stderr.contains("undefined function 'missing_fn'")
        expect result.stderr.contains("Call stack:")
        expect result.stderr.contains("level1")
        expect result.stderr.contains("level2")
        expect result.stderr.contains("level3")
