# Inline Assembly Integration Tests
#
# End-to-end tests for inline assembly in bare-metal contexts.
# Tests actual hardware operations and system integration.

use std.spec.{check, check_msg}

describe "x86 Port I/O Operations":
use std.spec.{check, check_msg}

    it "implements outb for serial port":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn serial_write_byte(byte: u8):
use std.spec.{check, check_msg}

            val COM1_PORT: u16 = 0x3F8
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "out dx, al",
use std.spec.{check, check_msg}

                    in("dx") COM1_PORT,
use std.spec.{check, check_msg}

                    in("al") byte
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("out dx, al"))
use std.spec.{check, check_msg}

        check(code.contains("COM1_PORT"))

use std.spec.{check, check_msg}

    it "implements inb for serial port status":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn serial_can_write() -> bool:
use std.spec.{check, check_msg}

            val COM1_STATUS: u16 = 0x3FD
use std.spec.{check, check_msg}

            var status: u8
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "in al, dx",
use std.spec.{check, check_msg}

                    out("al") status,
use std.spec.{check, check_msg}

                    in("dx") COM1_STATUS
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

            (status & 0x20) != 0
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("in al, dx"))

use std.spec.{check, check_msg}

    it "implements outw for 16-bit I/O":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn pci_write_config(addr: u32, value: u16):
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                # Write address to config address port
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "out dx, eax",
use std.spec.{check, check_msg}

                    in("dx") 0xCF8 as u16,
use std.spec.{check, check_msg}

                    in("eax") addr
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

                # Write data to config data port
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "out dx, ax",
use std.spec.{check, check_msg}

                    in("dx") 0xCFC as u16,
use std.spec.{check, check_msg}

                    in("ax") value
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("out dx, eax"))
use std.spec.{check, check_msg}

        check(code.contains("out dx, ax"))

use std.spec.{check, check_msg}

describe "x86 CPU Control":
use std.spec.{check, check_msg}

    it "implements CLI to disable interrupts":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn disable_interrupts():
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile("cli")
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("cli"))

use std.spec.{check, check_msg}

    it "implements STI to enable interrupts":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn enable_interrupts():
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile("sti")
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("sti"))

use std.spec.{check, check_msg}

    it "implements HLT to halt CPU":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn halt():
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile("hlt")
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("hlt"))

use std.spec.{check, check_msg}

    it "implements LGDT to load GDT":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn load_gdt(gdt_ptr: u64):
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "lgdt [{ptr}]",
use std.spec.{check, check_msg}

                    ptr = in(reg) gdt_ptr
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("lgdt"))

use std.spec.{check, check_msg}

    it "implements LIDT to load IDT":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn load_idt(idt_ptr: u64):
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "lidt [{ptr}]",
use std.spec.{check, check_msg}

                    ptr = in(reg) idt_ptr
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("lidt"))

use std.spec.{check, check_msg}

describe "x86 Control Registers":
use std.spec.{check, check_msg}

    it "reads CR0 control register":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn read_cr0() -> u32:
use std.spec.{check, check_msg}

            var value: u32
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm(
use std.spec.{check, check_msg}

                    "mov {val}, cr0",
use std.spec.{check, check_msg}

                    val = out(reg) value
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

            value
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("mov"))
use std.spec.{check, check_msg}

        check(code.contains("cr0"))

use std.spec.{check, check_msg}

    it "writes CR3 page directory":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn load_page_directory(addr: u32):
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "mov cr3, {addr}",
use std.spec.{check, check_msg}

                    addr = in(reg) addr
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("cr3"))

use std.spec.{check, check_msg}

describe "ARM Bare-Metal Operations":
use std.spec.{check, check_msg}

    it "implements ARM semihosting call":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn arm_semihost(op: u32, params: u64) -> i64:
use std.spec.{check, check_msg}

            var result: i64
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "mov r0, {op}",
use std.spec.{check, check_msg}

                    "mov r1, {params}",
use std.spec.{check, check_msg}

                    "bkpt #0xAB",
use std.spec.{check, check_msg}

                    "mov {result}, r0",
use std.spec.{check, check_msg}

                    op = in(reg) op,
use std.spec.{check, check_msg}

                    params = in(reg) params,
use std.spec.{check, check_msg}

                    result = lateout(reg) result,
use std.spec.{check, check_msg}

                    clobber_abi("C")
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

            result
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("bkpt #0xAB"))
use std.spec.{check, check_msg}

        check(code.contains("mov r0"))

use std.spec.{check, check_msg}

    it "implements ARM WFI (wait for interrupt)":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn wait_for_interrupt():
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile("wfi")
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("wfi"))

use std.spec.{check, check_msg}

    it "implements ARM data barrier":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn data_memory_barrier():
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile("dmb")
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("dmb"))

use std.spec.{check, check_msg}

    it "implements ARM instruction barrier":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn instruction_sync_barrier():
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile("isb")
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("isb"))

use std.spec.{check, check_msg}

describe "RISC-V Bare-Metal Operations":
use std.spec.{check, check_msg}

    it "implements RISC-V semihosting":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn riscv_semihost(op: u32, params: u64) -> i64:
use std.spec.{check, check_msg}

            var result: i64
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "mv a0, {op}",
use std.spec.{check, check_msg}

                    "mv a1, {params}",
use std.spec.{check, check_msg}

                    "ebreak",
use std.spec.{check, check_msg}

                    "mv {result}, a0",
use std.spec.{check, check_msg}

                    op = in(reg) op,
use std.spec.{check, check_msg}

                    params = in(reg) params,
use std.spec.{check, check_msg}

                    result = lateout(reg) result
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

            result
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("ebreak"))

use std.spec.{check, check_msg}

    it "implements RISC-V WFI":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn wait_for_interrupt():
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile("wfi")
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("wfi"))

use std.spec.{check, check_msg}

    it "implements RISC-V fence":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn memory_fence():
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile("fence")
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("fence"))

use std.spec.{check, check_msg}

describe "MMIO Register Access":
use std.spec.{check, check_msg}

    it "reads MMIO register":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn mmio_read(addr: u64) -> u32:
use std.spec.{check, check_msg}

            var value: u32
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "ldr {val}, [{addr}]",
use std.spec.{check, check_msg}

                    val = out(reg) value,
use std.spec.{check, check_msg}

                    addr = in(reg) addr
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

            value
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("ldr"))

use std.spec.{check, check_msg}

    it "writes MMIO register":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn mmio_write(addr: u64, value: u32):
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "str {val}, [{addr}]",
use std.spec.{check, check_msg}

                    addr = in(reg) addr,
use std.spec.{check, check_msg}

                    val = in(reg) value
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("str"))

use std.spec.{check, check_msg}

    it "atomic MMIO update":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn mmio_set_bits(addr: u64, mask: u32):
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "ldr r0, [{addr}]",
use std.spec.{check, check_msg}

                    "orr r0, r0, {mask}",
use std.spec.{check, check_msg}

                    "str r0, [{addr}]",
use std.spec.{check, check_msg}

                    addr = in(reg) addr,
use std.spec.{check, check_msg}

                    mask = in(reg) mask,
use std.spec.{check, check_msg}

                    out("r0") _
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("orr"))

use std.spec.{check, check_msg}

describe "Spinlock Implementation":
use std.spec.{check, check_msg}

    it "implements test-and-set spinlock":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn spinlock_acquire(lock: *mut u32):
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm(
use std.spec.{check, check_msg}

                    "1:",
use std.spec.{check, check_msg}

                    "mov eax, 1",
use std.spec.{check, check_msg}

                    "xchg eax, [{lock}]",
use std.spec.{check, check_msg}

                    "test eax, eax",
use std.spec.{check, check_msg}

                    "jnz 1b",
use std.spec.{check, check_msg}

                    lock = in(reg) lock,
use std.spec.{check, check_msg}

                    out("eax") _
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("xchg"))
use std.spec.{check, check_msg}

        check(code.contains("test"))

use std.spec.{check, check_msg}

    it "implements spinlock release":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn spinlock_release(lock: *mut u32):
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "mov dword ptr [{lock}], 0",
use std.spec.{check, check_msg}

                    lock = in(reg) lock
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("mov dword ptr"))

use std.spec.{check, check_msg}

describe "Cache Operations":
use std.spec.{check, check_msg}

    it "implements cache flush (x86)":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn flush_cache_line(addr: u64):
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "clflush [{addr}]",
use std.spec.{check, check_msg}

                    addr = in(reg) addr
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("clflush"))

use std.spec.{check, check_msg}

    it "implements write-back and invalidate":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn cache_wbinvd():
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile("wbinvd")
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("wbinvd"))

use std.spec.{check, check_msg}

describe "Atomic Operations":
use std.spec.{check, check_msg}

    it "implements compare-and-swap":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn atomic_cas(ptr: *mut u32, expected: u32, desired: u32) -> bool:
use std.spec.{check, check_msg}

            var old: u32
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "lock cmpxchg [{ptr}], {desired}",
use std.spec.{check, check_msg}

                    ptr = in(reg) ptr,
use std.spec.{check, check_msg}

                    desired = in(reg) desired,
use std.spec.{check, check_msg}

                    inout("eax") expected => old
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

            old == expected
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("lock cmpxchg"))

use std.spec.{check, check_msg}

    it "implements atomic increment":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn atomic_inc(ptr: *mut u32):
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile(
use std.spec.{check, check_msg}

                    "lock inc dword ptr [{ptr}]",
use std.spec.{check, check_msg}

                    ptr = in(reg) ptr
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("lock inc"))

use std.spec.{check, check_msg}

    it "implements atomic exchange":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn atomic_swap(ptr: *mut u32, new_val: u32) -> u32:
use std.spec.{check, check_msg}

            var old: u32
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm(
use std.spec.{check, check_msg}

                    "xchg [{ptr}], {val}",
use std.spec.{check, check_msg}

                    ptr = in(reg) ptr,
use std.spec.{check, check_msg}

                    val = inout(reg) new_val => old
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

            old
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("xchg"))

use std.spec.{check, check_msg}

describe "Context Switching":
use std.spec.{check, check_msg}

    it "saves registers for context switch":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn save_context(ctx: *mut Context):
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm(
use std.spec.{check, check_msg}

                    "mov [rdi + 0], rax",
use std.spec.{check, check_msg}

                    "mov [rdi + 8], rbx",
use std.spec.{check, check_msg}

                    "mov [rdi + 16], rcx",
use std.spec.{check, check_msg}

                    in("rdi") ctx,
use std.spec.{check, check_msg}

                    out("rax") _,
use std.spec.{check, check_msg}

                    out("rbx") _,
use std.spec.{check, check_msg}

                    out("rcx") _
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("mov [rdi"))

use std.spec.{check, check_msg}

    it "restores registers for context switch":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn restore_context(ctx: *Context):
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm(
use std.spec.{check, check_msg}

                    "mov rax, [rdi + 0]",
use std.spec.{check, check_msg}

                    "mov rbx, [rdi + 8]",
use std.spec.{check, check_msg}

                    "mov rcx, [rdi + 16]",
use std.spec.{check, check_msg}

                    in("rdi") ctx,
use std.spec.{check, check_msg}

                    out("rax") _,
use std.spec.{check, check_msg}

                    out("rbx") _,
use std.spec.{check, check_msg}

                    out("rcx") _
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("mov rax, [rdi"))

use std.spec.{check, check_msg}

describe "Timer Operations":
use std.spec.{check, check_msg}

    it "reads TSC timestamp counter":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn read_tsc() -> u64:
use std.spec.{check, check_msg}

            var low: u32
use std.spec.{check, check_msg}

            var high: u32
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm(
use std.spec.{check, check_msg}

                    "rdtsc",
use std.spec.{check, check_msg}

                    low = out("eax") low,
use std.spec.{check, check_msg}

                    high = out("edx") high
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

            ((high as u64) << 32) | (low as u64)
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("rdtsc"))

use std.spec.{check, check_msg}

    it "reads RDTSCP with core ID":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        fn read_tscp() -> (u64, u32):
use std.spec.{check, check_msg}

            var low: u32
use std.spec.{check, check_msg}

            var high: u32
use std.spec.{check, check_msg}

            var core: u32
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm(
use std.spec.{check, check_msg}

                    "rdtscp",
use std.spec.{check, check_msg}

                    low = out("eax") low,
use std.spec.{check, check_msg}

                    high = out("edx") high,
use std.spec.{check, check_msg}

                    core = out("ecx") core
use std.spec.{check, check_msg}

                )
use std.spec.{check, check_msg}

            (((high as u64) << 32) | (low as u64), core)
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("rdtscp"))
