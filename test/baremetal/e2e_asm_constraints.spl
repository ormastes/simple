# Inline Assembly Constraints Test
#
# Tests various constraint types:
# - in: input registers
# - out: output registers
# - inout: bidirectional registers
#
# Build: simple build --target=baremetal-x86 test/baremetal/e2e_asm_constraints.spl
# Run: qemu-system-i386 -kernel build/baremetal/kernel.elf -serial stdio -display none

fn outb(port: u16, value: u8):
    unsafe:
        asm volatile("out dx, al", in("dx") port, in("al") value)

fn inb(port: u16) -> u8:
    var result: u8
    unsafe:
        asm volatile("in al, dx", out("al") result, in("dx") port)
    result

# Test arithmetic using inline asm
fn add_asm(a: i32, b: i32) -> i32:
    var result: i32 = a
    unsafe:
        asm("add eax, ebx", inout("eax") result, in("ebx") b)
    result

# Test bitwise OR
fn or_asm(a: i32, b: i32) -> i32:
    var result: i32 = a
    unsafe:
        asm("or eax, ebx", inout("eax") result, in("ebx") b)
    result

# COM1 serial
val COM1: u16 = 0x3F8
val COM1_LSR: u16 = 0x3FD

fn putc(ch: u8):
    # Wait for transmit ready (bit 5 of LSR)
    while (inb(COM1_LSR) & 0x20) == 0:
        pass
    outb(COM1, ch)

fn print_ok():
    putc(0x4F)  # 'O'
    putc(0x4B)  # 'K'
    putc(0x0A)  # '\n'

fn print_fail():
    putc(0x46)  # 'F'
    putc(0x41)  # 'A'
    putc(0x49)  # 'I'
    putc(0x4C)  # 'L'
    putc(0x0A)  # '\n'

fn _start():
    # Test 1: Addition via inline asm
    val sum = add_asm(5, 7)
    if sum == 12:
        print_ok()
    else:
        print_fail()

    # Test 2: Bitwise OR via inline asm
    val or_result = or_asm(0x0F, 0xF0)
    if or_result == 0xFF:
        print_ok()
    else:
        print_fail()

    # Test 3: Port I/O (read LSR register)
    val lsr = inb(COM1_LSR)
    if lsr != 0:  # LSR should have some bits set
        print_ok()
    else:
        print_fail()

    # Exit QEMU
    outb(0xF4, 0)
    loop: pass
