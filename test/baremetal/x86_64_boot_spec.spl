# x86_64 Bare-Metal Boot Tests
#
# Tests x86_64 bare-metal boot functionality:
# - 64-bit multiboot header
# - Long mode setup
# - Stack alignment (16-byte)
# - Jump to kernel_main
#
# These tests verify the x86_64 boot infrastructure works correctly.

use std.spec
use src.baremetal.x86_64.test_support.{
    Multiboot2Header, multiboot2_header, validate_multiboot2,
    get_stack_pointer, check_stack_alignment, STACK_SIZE,
    is_pae_enabled, is_long_mode_enabled, is_paging_enabled,
    CR4_PAE, EFER_LME, CR0_PG
}

# ===========================================================================
# Boot Code Tests
# ===========================================================================

describe "x86_64 Boot Code":
    it "generates valid 64-bit multiboot header":
        val header = multiboot2_header()

        # Multiboot2 magic: 0xE85250D6
        expect(header.magic).to_equal(0xE85250D6)

        # Architecture should be i386 (0)
        expect(header.architecture).to_equal(0)

        # Checksum validation: magic + arch + length + checksum = 0
        val sum = header.magic + header.architecture + header.header_length + header.checksum
        expect(sum).to_equal(0)

    it "validates multiboot2 header successfully":
        val header = multiboot2_header()
        val is_valid = validate_multiboot2(header)
        expect(is_valid).to_be(true)

    it "sets up long mode correctly":
        # Simulate control register values for long mode
        val cr4_with_pae = CR4_PAE | 0x00000010  # PAE + other bits
        val efer_with_lme = EFER_LME | 0x00000001  # LME + SCE
        val cr0_with_pg = CR0_PG | 0x00000001  # PG + PE

        # Test that PAE is enabled in CR4
        expect(is_pae_enabled(cr4_with_pae)).to_be(true)
        expect(is_pae_enabled(0x00000000)).to_be(false)

        # Test that Long Mode is enabled in EFER
        expect(is_long_mode_enabled(efer_with_lme)).to_be(true)
        expect(is_long_mode_enabled(0x0000000000000000)).to_be(false)

        # Test that paging is enabled in CR0
        expect(is_paging_enabled(cr0_with_pg)).to_be(true)
        expect(is_paging_enabled(0x00000000)).to_be(false)

    it "maintains 16-byte stack alignment":
        val sp = get_stack_pointer()

        # Stack pointer must be 16-byte aligned for x86_64 ABI
        expect(check_stack_alignment(sp)).to_be(true)
        expect(sp % 16).to_equal(0)

        # Stack size should be reasonable (at least 16KB)
        expect(STACK_SIZE >= 16384).to_be(true)

        # Stack size should be 16-byte aligned
        expect(STACK_SIZE % 16).to_equal(0)

# ===========================================================================
# QEMU Boot Tests
# ===========================================================================

use src.lib.qemu.boot_runner.{run_boot_test, BootTestConfig}
use src.lib.qemu.mod.{QemuArch}

@slow
describe "x86_64 QEMU Boot":
    slow_it "boots successfully in QEMU":
        # Test with a minimal x86_64 kernel
        # Note: Would need examples/baremetal/hello_x86_64.elf
        val kernel_path = "examples/baremetal/hello_x86_64.elf"

        # Create config for x86_64
        var config = BootTestConfig.new(QemuArch.X86_64, kernel_path)
        config.expect_output("Hello")
        config.set_timeout(5000)

        # TODO: Build example kernel first
        # For now, skip if kernel doesn't exist
        pass

    slow_it "handles 64-bit interrupts":
        # TODO: Test IDT in long mode
        # - 64-bit interrupt gates
        # - IST support
        # Requires test kernel with IDT setup and interrupt triggering
        pass
