# Debug Boot Test Specification
#
# **Feature ID:** #BM-011
# **Category:** Bare-Metal / Debug
# **Status:** Ready (blocked by attribute syntax)
#
# Tests debug-enabled boot testing with GDB integration.
# These tests verify automatic crash analysis and debugging features.

use lib.qemu.debug_boot_runner.{run_debug_boot_test, DebugBootConfig, DebugBootRunner, format_debug_info}
use lib.qemu.{QemuArch, is_qemu_available, is_gdb_available}

describe "Debug Boot Testing":
    """Tests for GDB-integrated boot testing."""

    # ===========================================================================
    # Basic Debug Features
    # ===========================================================================

    context "Debug Connection":
        """Test GDB connection and basic debugging."""

        before_context:
            if not is_qemu_available(QemuArch.RiscV32):
                skip_context("QEMU RISC-V not available")
            if not is_gdb_available(QemuArch.RiscV32):
                skip_context("GDB not available")

        slow_it "connects GDB to QEMU":
            """Verify GDB can connect to QEMU stub."""
            var config = DebugBootConfig.new(
                QemuArch.RiscV32,
                "test/fixtures/boot/rv32_minimal.elf"
            )
            config.enable_debug()
            config.set_gdb_port(1234)

            val runner = DebugBootRunner.new(config)
            val (result, debug_info) = runner.run()

            # Should connect successfully
            expect(result.success).to(be_true())

        slow_it "sets breakpoint at entry point":
            """Verify breakpoints can be set."""
            var config = DebugBootConfig.new(
                QemuArch.RiscV32,
                "test/fixtures/boot/rv32_minimal.elf"
            )
            config.enable_debug()
            config.add_breakpoint(0x80000000)  # Entry point

            val runner = DebugBootRunner.new(config)
            val (result, debug_info) = runner.run()

            # Should hit breakpoint
            expect(result.output).to_contain("Breakpoint")

        slow_it "reads registers on stop":
            """Verify registers can be read when stopped."""
            var config = DebugBootConfig.new(
                QemuArch.RiscV32,
                "test/fixtures/boot/rv32_minimal.elf"
            )
            config.enable_debug()
            config.add_breakpoint(0x80000000)

            val runner = DebugBootRunner.new(config)
            val (result, debug_info) = runner.run()

            # Should have register values
            expect(debug_info.available).to(be_true())
            expect(debug_info.registers.keys().len()).to_be_greater_than(0)

    # ===========================================================================
    # Crash Analysis
    # ===========================================================================

    context "Crash Analysis":
        """Test automatic crash analysis features."""

        before_context:
            if not is_qemu_available(QemuArch.RiscV32):
                skip_context("QEMU RISC-V not available")
            if not is_gdb_available(QemuArch.RiscV32):
                skip_context("GDB not available")

        slow_it "detects null pointer dereference":
            """Test crash analysis for null pointer."""
            val (result, debug_info) = run_debug_boot_test(
                QemuArch.RiscV32,
                "test/fixtures/boot/rv32_nullptr_crash.elf",
                ""
            )

            # Should detect crash
            expect(result.success).to(be_false())

            # Should have debug info
            expect(debug_info.available).to(be_true())
            expect(debug_info.fault_address).to(eq(0))

        slow_it "extracts stack trace on crash":
            """Verify stack trace is captured."""
            val (result, debug_info) = run_debug_boot_test(
                QemuArch.RiscV32,
                "test/fixtures/boot/rv32_stack_crash.elf",
                ""
            )

            # Should have stack trace
            expect(debug_info.available).to(be_true())
            expect(debug_info.stack_trace.len()).to_be_greater_than(0)

        slow_it "shows register state on crash":
            """Verify all registers are captured."""
            val (result, debug_info) = run_debug_boot_test(
                QemuArch.RiscV32,
                "test/fixtures/boot/rv32_crash.elf",
                ""
            )

            # Should have all registers
            expect(debug_info.registers.len()).to_be_greater_than(20)
            # RISC-V has 32 general-purpose registers
            expect(debug_info.registers.contains_key("pc")).to(be_true())
            expect(debug_info.registers.contains_key("sp")).to(be_true())

    # ===========================================================================
    # Debug Output Formatting
    # ===========================================================================

    context "Debug Output":
        """Test debug information formatting."""

        it "formats debug info":
            """Verify debug info formatting."""
            var registers: Dict<text, u64> = {}
            registers["pc"] = 0x80000100
            registers["sp"] = 0x80010000
            registers["ra"] = 0x80000050

            var frames = [
                StackFrame(frame_num: 0, address: 0x80000100, function: "main", file: "main.spl", line: 42),
                StackFrame(frame_num: 1, address: 0x80000050, function: "_start", file: "startup.spl", line: 10)
            ]

            val debug_info = DebugInfo.from_gdb(
                registers,
                frames,
                0x80000100,
                "Segmentation fault"
            )

            val formatted = format_debug_info(debug_info)

            expect(formatted).to_contain("Fault Address:")
            expect(formatted).to_contain("0x80000100")
            expect(formatted).to_contain("Registers:")
            expect(formatted).to_contain("pc: ")
            expect(formatted).to_contain("Stack Trace:")
            expect(formatted).to_contain("main")

    # ===========================================================================
    # Multi-Architecture Debug
    # ===========================================================================

    context "Multi-Architecture Debug":
        """Test debugging across different architectures."""

        slow_it "debugs x86 kernel":
            """Debug x86 boot with GDB."""
            if not is_qemu_available(QemuArch.X86):
                skip("QEMU x86 not available")
            if not is_gdb_available(QemuArch.X86):
                skip("GDB for x86 not available")

            val (result, debug_info) = run_debug_boot_test(
                QemuArch.X86,
                "test/fixtures/boot/x86_minimal.elf",
                "Hello x86!"
            )

            expect(result.success).to(be_true())

        slow_it "debugs ARM kernel":
            """Debug ARM boot with GDB."""
            if not is_qemu_available(QemuArch.ARM32):
                skip("QEMU ARM not available")
            if not is_gdb_available(QemuArch.ARM32):
                skip("GDB for ARM not available")

            val (result, debug_info) = run_debug_boot_test(
                QemuArch.ARM32,
                "test/fixtures/boot/arm_minimal.elf",
                "ARM started"
            )

            expect(result.success).to(be_true())

        slow_it "debugs RISC-V kernel":
            """Debug RISC-V boot with GDB."""
            if not is_qemu_available(QemuArch.RiscV32):
                skip("QEMU RISC-V not available")
            if not is_gdb_available(QemuArch.RiscV32):
                skip("GDB for RISC-V not available")

            val (result, debug_info) = run_debug_boot_test(
                QemuArch.RiscV32,
                "test/fixtures/boot/rv32_minimal.elf",
                "RISC-V started"
            )

            expect(result.success).to(be_true())

    # ===========================================================================
    # Breakpoint Management
    # ===========================================================================

    context "Breakpoint Management":
        """Test breakpoint setting and handling."""

        before_context:
            if not is_qemu_available(QemuArch.RiscV32):
                skip_context("QEMU RISC-V not available")
            if not is_gdb_available(QemuArch.RiscV32):
                skip_context("GDB not available")

        slow_it "sets multiple breakpoints":
            """Verify multiple breakpoints can be set."""
            var config = DebugBootConfig.new(
                QemuArch.RiscV32,
                "test/fixtures/boot/rv32_minimal.elf"
            )
            config.enable_debug()
            config.add_breakpoint(0x80000000)  # Entry
            config.add_breakpoint(0x80000100)  # Main
            config.add_breakpoint(0x80000200)  # Function

            val runner = DebugBootRunner.new(config)
            val (result, debug_info) = runner.run()

            # Should hit first breakpoint
            expect(result.success).to(be_true())

        slow_it "continues after breakpoint":
            """Verify execution continues after breakpoint."""
            var config = DebugBootConfig.new(
                QemuArch.RiscV32,
                "test/fixtures/boot/rv32_minimal.elf"
            )
            config.enable_debug()
            config.add_breakpoint(0x80000000)

            val runner = DebugBootRunner.new(config)
            val (result, debug_info) = runner.run()

            # Should complete successfully
            expect(result.success).to(be_true())

    # ===========================================================================
    # Single-Step Debugging
    # ===========================================================================

    context "Single-Step Debugging":
        """Test single-step execution."""

        before_context:
            if not is_qemu_available(QemuArch.RiscV32):
                skip_context("QEMU RISC-V not available")
            if not is_gdb_available(QemuArch.RiscV32):
                skip_context("GDB not available")

        slow_it "single-steps through code":
            """Verify single-step execution."""
            var config = DebugBootConfig.new(
                QemuArch.RiscV32,
                "test/fixtures/boot/rv32_minimal.elf"
            )
            config.enable_debug()
            config.enable_single_step()
            config.add_breakpoint(0x80000000)

            val runner = DebugBootRunner.new(config)
            val (result, debug_info) = runner.run()

            # Should stop at breakpoint
            expect(debug_info.available).to(be_true())

# ===========================================================================
# Test Fixtures
# ===========================================================================

# Note: These would be actual crash test kernels

# Null pointer dereference test
fn build_nullptr_crash_kernel() -> text:
    """Build kernel that dereferences null pointer."""
    # TODO: Build from test/fixtures/boot/rv32_nullptr_crash.spl
    "test/fixtures/boot/rv32_nullptr_crash.elf"

# Stack overflow test
fn build_stack_crash_kernel() -> text:
    """Build kernel with stack overflow."""
    # TODO: Build from test/fixtures/boot/rv32_stack_crash.spl
    "test/fixtures/boot/rv32_stack_crash.elf"

# Generic crash test
fn build_crash_kernel() -> text:
    """Build kernel that crashes."""
    # TODO: Build from test/fixtures/boot/rv32_crash.spl
    "test/fixtures/boot/rv32_crash.elf"
