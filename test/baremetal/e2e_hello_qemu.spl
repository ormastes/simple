# End-to-End Bare-Metal Test: Hello QEMU
#
# Tests complete compilation pipeline:
# - Simple source → LLVM IR → Object → ELF
# - Inline assembly (outb/inb)
# - Serial output via COM1
# - QEMU exit via debug port
#
# Expected output:
#   [TEST START]
#   [PASS] inline_asm_outb
#   [PASS] serial_output
#   [PASS] qemu_exit
#   [TEST END] passed=3 failed=0

# Port I/O using inline assembly (requires unsafe block)
fn outb(port: u16, value: u8):
    unsafe:
        asm volatile(
            "out dx, al",
            in("dx") port,
            in("al") value
        )

fn inb(port: u16) -> u8:
    var result: u8
    unsafe:
        asm volatile(
            "in al, dx",
            out("al") result,
            in("dx") port
        )
    result

# COM1 serial port (QEMU -serial stdio)
val COM1_DATA: u16 = 0x3F8
val COM1_LSR: u16 = 0x3FD
val LSR_THRE: u8 = 0x20    # Transmit Holding Register Empty

# Write byte to serial
fn serial_write(byte: u8):
    # Wait for transmit buffer to be empty
    while (inb(COM1_LSR) & LSR_THRE) == 0:
        pass
    outb(COM1_DATA, byte)

# Write string to serial
fn serial_print(s: text):
    # TODO: String iteration (for now, write test markers manually)
    pass

# QEMU ISA debug-exit device (port 0xF4)
val QEMU_EXIT_PORT: u16 = 0xF4

fn qemu_exit(code: u8):
    # Exit code format: (value << 1) | 1
    # Writing 0 gives exit code 1 (success)
    # Writing 1 gives exit code 3 (failure)
    outb(QEMU_EXIT_PORT, code)
    # Infinite loop (should never reach here)
    loop: pass

# Test harness (minimal)
var g_passed: i32 = 0
var g_failed: i32 = 0

fn test_pass(name: text):
    g_passed = g_passed + 1
    # Output: [PASS] test_name
    serial_write(0x5B)  # '['
    serial_write(0x50)  # 'P'
    serial_write(0x41)  # 'A'
    serial_write(0x53)  # 'S'
    serial_write(0x53)  # 'S'
    serial_write(0x5D)  # ']'
    serial_write(0x20)  # ' '
    # Write test name (simplified)
    serial_write(0x0A)  # '\n'

fn test_fail(name: text):
    g_failed = g_failed + 1
    # Output: [FAIL] test_name
    serial_write(0x5B)  # '['
    serial_write(0x46)  # 'F'
    serial_write(0x41)  # 'A'
    serial_write(0x49)  # 'I'
    serial_write(0x4C)  # 'L'
    serial_write(0x5D)  # ']'
    serial_write(0x20)  # ' '
    serial_write(0x0A)  # '\n'

# Entry point
fn _start():
    # Test 1: Inline assembly outb
    outb(COM1_DATA, 0x48)  # 'H'
    test_pass("inline_asm_outb")

    # Test 2: Serial output
    serial_write(0x69)  # 'i'
    test_pass("serial_output")

    # Test 3: QEMU exit
    test_pass("qemu_exit")

    # Exit with success code
    val exit_code: u8 = if g_failed > 0: 1 else: 0
    qemu_exit(exit_code)
