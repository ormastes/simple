# x86 Bare-Metal Boot Tests
#
# Tests x86 bare-metal boot functionality:
# - Multiboot header generation
# - Boot code assembly
# - Stack setup
# - Jump to kernel_main
#
# These tests verify the x86 boot infrastructure works correctly.

use std.spec
use src.baremetal.x86.test_support.{MultibootHeader, multiboot_header, validate_multiboot, get_stack_pointer, STACK_SIZE}

# ===========================================================================
# Multiboot Header Tests
# ===========================================================================

describe "x86 Multiboot Header":
    it "has correct magic number":
        val header = multiboot_header()

        # Multiboot magic: 0x1BADB002
        expect(header.magic).to_equal(0x1BADB002)

    it "has valid checksum":
        val header = multiboot_header()

        # Checksum: -(magic + flags) mod 2^32
        val sum = header.magic + header.flags + header.checksum
        val expected = 0  # Should sum to 0

        expect(sum).to_equal(expected)

    it "has correct flags":
        val header = multiboot_header()

        # Flags: 0 for basic multiboot
        # Bit 0: page alignment
        # Bit 1: memory info
        # Bit 16: graphics mode

        expect(header.flags & 0x00000001).to_equal(0)  # No page alignment requirement
        expect(header.flags & 0x00000002).to_equal(0)  # No memory info required

    it "validates successfully":
        val header = multiboot_header()
        val is_valid = validate_multiboot(header)

        expect(is_valid).to_be(true)

# ===========================================================================
# Boot Code Tests
# ===========================================================================

describe "x86 Boot Code":
    it "allocates 16KB stack":
        use std.baremetal.x86.{STACK_SIZE}

        # Standard stack size for x86
        expect(STACK_SIZE).to_equal(16384)

    it "maintains 16-byte stack alignment":
        use std.baremetal.x86.{STACK_SIZE}

        # Stack size must be 16-byte aligned
        expect(STACK_SIZE % 16).to_equal(0)

    it "sets up stack pointer correctly":
        use std.baremetal.x86.{get_stack_pointer}

        # Stack grows downward, SP should point to top
        val sp = get_stack_pointer()

        # SP should be 16-byte aligned
        expect(sp % 16).to_equal(0)

# ===========================================================================
# Linker Script Tests
# ===========================================================================

describe "x86 Linker Script":
    it "places multiboot header at correct address":
        # TODO: Test section placement
        # - .multiboot section at start
        # - Load address 1MB (0x00100000)
        pass

    it "sets correct entry point":
        # TODO: Test entry point
        # - _start symbol
        # - Located in .text section
        pass

# ===========================================================================
# QEMU Boot Tests
# ===========================================================================

use src.lib.qemu.boot_runner.{run_x86_boot_test}

@slow
describe "x86 QEMU Boot":
    slow_it "boots successfully in QEMU":
        # Test with hello_x86.spl example
        val kernel_path = "examples/baremetal/hello_x86.elf"

        # Run boot test expecting VGA output
        val result = run_x86_boot_test(kernel_path, "Hello, x86!")

        expect(result.success).to_be(true)
        expect(result.output.contains("Hello, x86!")).to_be(true)
        expect(result.exit_code).to_equal(1)  # Debug-exit returns 1 for success

    slow_it "handles interrupts correctly":
        # TODO: Test interrupt delivery
        # - Enable interrupts
        # - Trigger test interrupt
        # - Verify handler called
        # This requires a test kernel that sets up IDT and triggers interrupts
        pass
