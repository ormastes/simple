# Bitfield MIR Lowering Tests
#
# Tests for lowering bitfield field access to efficient bit operations.

use std.spec.{check, check_msg}

describe "Bitfield Syntax":
use std.spec.{check, check_msg}

    it "recognizes bitfield definitions":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        bitfield Flags(u32):
use std.spec.{check, check_msg}

            enabled: bool
use std.spec.{check, check_msg}

            priority: u4
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("bitfield"))
use std.spec.{check, check_msg}

        check(code.contains("Flags"))

use std.spec.{check, check_msg}

    it "supports bool fields (1 bit)":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        bitfield Status(u8):
use std.spec.{check, check_msg}

            ready: bool
use std.spec.{check, check_msg}

            error: bool
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("ready: bool"))
use std.spec.{check, check_msg}

        check(code.contains("error: bool"))

use std.spec.{check, check_msg}

    it "supports custom bit widths":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        bitfield Control(u32):
use std.spec.{check, check_msg}

            mode: u2      # 2 bits
use std.spec.{check, check_msg}

            level: u4     # 4 bits
use std.spec.{check, check_msg}

            flags: u8     # 8 bits
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("u2"))
use std.spec.{check, check_msg}

        check(code.contains("u4"))
use std.spec.{check, check_msg}

        check(code.contains("u8"))

use std.spec.{check, check_msg}

    it "supports reserved/padding fields":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        bitfield Register(u32):
use std.spec.{check, check_msg}

            data: u8
use std.spec.{check, check_msg}

            _: u8          # 8 bits reserved
use std.spec.{check, check_msg}

            status: u16
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("_: u8"))

use std.spec.{check, check_msg}

describe "Bitfield Field Access":
use std.spec.{check, check_msg}

    it "reads bitfield fields":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        bitfield Flags(u32):
use std.spec.{check, check_msg}

            enabled: bool
use std.spec.{check, check_msg}

            priority: u4

use std.spec.{check, check_msg}

        val flags = Flags(0x06)  # 0b0110
use std.spec.{check, check_msg}

        val priority = flags.priority  # Should be (0x06 >> 1) & 0xF = 3
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("flags.priority"))

use std.spec.{check, check_msg}

    it "writes bitfield fields":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        bitfield Flags(u32):
use std.spec.{check, check_msg}

            enabled: bool
use std.spec.{check, check_msg}

            priority: u4

use std.spec.{check, check_msg}

        var flags = Flags(0)
use std.spec.{check, check_msg}

        flags.priority = 3  # Set priority to 3
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("flags.priority = 3"))

use std.spec.{check, check_msg}

    it "handles multiple field updates":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        bitfield Status(u8):
use std.spec.{check, check_msg}

            ready: bool
use std.spec.{check, check_msg}

            error: bool
use std.spec.{check, check_msg}

            mode: u2

use std.spec.{check, check_msg}

        var status = Status(0)
use std.spec.{check, check_msg}

        status.ready = true
use std.spec.{check, check_msg}

        status.error = false
use std.spec.{check, check_msg}

        status.mode = 2
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("status.ready = true"))
use std.spec.{check, check_msg}

        check(code.contains("status.mode = 2"))

use std.spec.{check, check_msg}

describe "Bitfield Bit Operations":
use std.spec.{check, check_msg}

    it "generates correct getter mask":
use std.spec.{check, check_msg}

        # For field at offset 4, width 3:
use std.spec.{check, check_msg}

        # mask = (1 << 3) - 1 = 7
use std.spec.{check, check_msg}

        # getter = (value >> 4) & 7
use std.spec.{check, check_msg}

        val code = "val result = (value >> 4) & 7"
use std.spec.{check, check_msg}

        check(code.contains(">> 4"))
use std.spec.{check, check_msg}

        check(code.contains("& 7"))

use std.spec.{check, check_msg}

    it "generates correct setter mask":
use std.spec.{check, check_msg}

        # For field at offset 4, width 3:
use std.spec.{check, check_msg}

        # clear_mask = ~(7 << 4) = ~0x70 = 0xFFFFFF8F
use std.spec.{check, check_msg}

        # setter = (value & clear_mask) | ((new_val & 7) << 4)
use std.spec.{check, check_msg}

        val code = "val result = (value & clear_mask) | ((new_val & 7) << 4)"
use std.spec.{check, check_msg}

        check(code.contains("& clear_mask"))
use std.spec.{check, check_msg}

        check(code.contains("& 7"))
use std.spec.{check, check_msg}

        check(code.contains("<< 4"))

use std.spec.{check, check_msg}

describe "Bitfield Real-World Examples":
use std.spec.{check, check_msg}

    it "implements hardware control register":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        # ARM Cortex-M CONTROL register
use std.spec.{check, check_msg}

        bitfield ControlReg(u32):
use std.spec.{check, check_msg}

            npriv: bool      # Non-privileged mode
use std.spec.{check, check_msg}

            spsel: bool      # Stack pointer select
use std.spec.{check, check_msg}

            _: u30           # Reserved

use std.spec.{check, check_msg}

        @address(0xE000ED04)
use std.spec.{check, check_msg}

        @volatile
use std.spec.{check, check_msg}

        var CONTROL: ControlReg

use std.spec.{check, check_msg}

        fn enter_unprivileged():
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                CONTROL.npriv = true
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("bitfield ControlReg"))
use std.spec.{check, check_msg}

        check(code.contains("@volatile"))
use std.spec.{check, check_msg}

        check(code.contains("CONTROL.npriv = true"))

use std.spec.{check, check_msg}

    it "implements peripheral status register":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        # UART status register
use std.spec.{check, check_msg}

        bitfield UartStatus(u32):
use std.spec.{check, check_msg}

            rxne: bool       # Receive not empty
use std.spec.{check, check_msg}

            txe: bool        # Transmit empty
use std.spec.{check, check_msg}

            tc: bool         # Transmission complete
use std.spec.{check, check_msg}

            idle: bool       # Idle line detected
use std.spec.{check, check_msg}

            ore: bool        # Overrun error
use std.spec.{check, check_msg}

            nf: bool         # Noise error
use std.spec.{check, check_msg}

            fe: bool         # Framing error
use std.spec.{check, check_msg}

            pe: bool         # Parity error
use std.spec.{check, check_msg}

            _: u24           # Reserved

use std.spec.{check, check_msg}

        @address(0x40011000)
use std.spec.{check, check_msg}

        @volatile
use std.spec.{check, check_msg}

        val UART_SR: UartStatus

use std.spec.{check, check_msg}

        fn uart_ready() -> bool:
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                UART_SR.txe
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("bitfield UartStatus"))
use std.spec.{check, check_msg}

        check(code.contains("UART_SR.txe"))

use std.spec.{check, check_msg}

    it "implements DMA configuration":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        # DMA channel configuration
use std.spec.{check, check_msg}

        bitfield DmaConfig(u32):
use std.spec.{check, check_msg}

            en: bool         # Channel enable
use std.spec.{check, check_msg}

            tcie: bool       # Transfer complete interrupt
use std.spec.{check, check_msg}

            htie: bool       # Half transfer interrupt
use std.spec.{check, check_msg}

            teie: bool       # Transfer error interrupt
use std.spec.{check, check_msg}

            dir: bool        # Data transfer direction
use std.spec.{check, check_msg}

            circ: bool       # Circular mode
use std.spec.{check, check_msg}

            pinc: bool       # Peripheral increment
use std.spec.{check, check_msg}

            minc: bool       # Memory increment
use std.spec.{check, check_msg}

            psize: u2        # Peripheral size (00=8bit, 01=16bit, 10=32bit)
use std.spec.{check, check_msg}

            msize: u2        # Memory size
use std.spec.{check, check_msg}

            pl: u2           # Priority level
use std.spec.{check, check_msg}

            mem2mem: bool    # Memory to memory
use std.spec.{check, check_msg}

            _: u17           # Reserved

use std.spec.{check, check_msg}

        var dma_cfg = DmaConfig(0)
use std.spec.{check, check_msg}

        dma_cfg.en = true
use std.spec.{check, check_msg}

        dma_cfg.tcie = true
use std.spec.{check, check_msg}

        dma_cfg.dir = false
use std.spec.{check, check_msg}

        dma_cfg.psize = 2  # 32-bit
use std.spec.{check, check_msg}

        dma_cfg.pl = 3     # Very high priority
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("bitfield DmaConfig"))
use std.spec.{check, check_msg}

        check(code.contains("psize: u2"))
use std.spec.{check, check_msg}

        check(code.contains("dma_cfg.pl = 3"))

use std.spec.{check, check_msg}

    it "implements x86 EFLAGS register":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        # x86/x86_64 EFLAGS register
use std.spec.{check, check_msg}

        bitfield EFlags(u64):
use std.spec.{check, check_msg}

            cf: bool         # Carry flag
use std.spec.{check, check_msg}

            _: u1            # Reserved (always 1)
use std.spec.{check, check_msg}

            pf: bool         # Parity flag
use std.spec.{check, check_msg}

            _: u1
use std.spec.{check, check_msg}

            af: bool         # Auxiliary carry flag
use std.spec.{check, check_msg}

            _: u1
use std.spec.{check, check_msg}

            zf: bool         # Zero flag
use std.spec.{check, check_msg}

            sf: bool         # Sign flag
use std.spec.{check, check_msg}

            tf: bool         # Trap flag
use std.spec.{check, check_msg}

            if_: bool        # Interrupt enable flag
use std.spec.{check, check_msg}

            df: bool         # Direction flag
use std.spec.{check, check_msg}

            of: bool         # Overflow flag
use std.spec.{check, check_msg}

            iopl: u2         # I/O privilege level
use std.spec.{check, check_msg}

            nt: bool         # Nested task
use std.spec.{check, check_msg}

            _: u1
use std.spec.{check, check_msg}

            rf: bool         # Resume flag
use std.spec.{check, check_msg}

            vm: bool         # Virtual 8086 mode
use std.spec.{check, check_msg}

            ac: bool         # Alignment check
use std.spec.{check, check_msg}

            vif: bool        # Virtual interrupt flag
use std.spec.{check, check_msg}

            vip: bool        # Virtual interrupt pending
use std.spec.{check, check_msg}

            id: bool         # ID flag
use std.spec.{check, check_msg}

            _: u42           # Reserved

use std.spec.{check, check_msg}

        fn read_eflags() -> EFlags:
use std.spec.{check, check_msg}

            var flags: u64
use std.spec.{check, check_msg}

            unsafe:
use std.spec.{check, check_msg}

                asm volatile("pushfq; pop {flags}", flags = out(reg) flags)
use std.spec.{check, check_msg}

            EFlags(flags)
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("bitfield EFlags(u64)"))
use std.spec.{check, check_msg}

        check(code.contains("iopl: u2"))

use std.spec.{check, check_msg}

describe "Bitfield Error Cases":
use std.spec.{check, check_msg}

    it "detects overflow (too many bits)":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        bitfield BadFlags(u8):
use std.spec.{check, check_msg}

            field1: u4
use std.spec.{check, check_msg}

            field2: u4
use std.spec.{check, check_msg}

            field3: u4   # ERROR: 4+4+4=12 > 8 bits
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        # This should fail validation
use std.spec.{check, check_msg}

        check(code.contains("field3: u4"))

use std.spec.{check, check_msg}

    it "requires valid backing type":
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        bitfield BadBacking(i32):  # ERROR: must be u8/u16/u32/u64
use std.spec.{check, check_msg}

            field: bool
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        # Should fail - signed types not allowed
use std.spec.{check, check_msg}

        check(code.contains("i32"))

use std.spec.{check, check_msg}

describe "Bitfield MIR Lowering":
use std.spec.{check, check_msg}

    it "lowers field read to shift and mask":
use std.spec.{check, check_msg}

        # flags.priority where priority is at offset 1, width 4
use std.spec.{check, check_msg}

        # Should become: (flags >> 1) & 0xF
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        val priority = (flags >> 1) & 0xF
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains(">>"))
use std.spec.{check, check_msg}

        check(code.contains("&"))

use std.spec.{check, check_msg}

    it "lowers field write to clear and set":
use std.spec.{check, check_msg}

        # flags.priority = 3 where priority is at offset 1, width 4
use std.spec.{check, check_msg}

        # Should become: flags = (flags & ~(0xF << 1)) | ((3 & 0xF) << 1)
use std.spec.{check, check_msg}

        val code = """
use std.spec.{check, check_msg}

        flags = (flags & ~(0xF << 1)) | ((3 & 0xF) << 1)
use std.spec.{check, check_msg}

        """
use std.spec.{check, check_msg}

        check(code.contains("& ~"))
use std.spec.{check, check_msg}

        check(code.contains("<<"))
use std.spec.{check, check_msg}

        check(code.contains("|"))

use std.spec.{check, check_msg}

describe "Bitfield at Offset 0 (No Shift)":
use std.spec.{check, check_msg}

    it "optimizes away zero shifts for reads":
use std.spec.{check, check_msg}

        # For field at offset 0, width 1:
use std.spec.{check, check_msg}

        # Should be: value & 0x1 (no shift)
use std.spec.{check, check_msg}

        val code = "val result = value & 0x1"
use std.spec.{check, check_msg}

        check(code.contains("& 0x1"))
use std.spec.{check, check_msg}

        check(not code.contains(">>"))

use std.spec.{check, check_msg}

    it "optimizes away zero shifts for writes":
use std.spec.{check, check_msg}

        # For field at offset 0, width 1:
use std.spec.{check, check_msg}

        # Should be: (value & ~0x1) | (new_val & 0x1)
use std.spec.{check, check_msg}

        val code = "val result = (value & ~0x1) | (new_val & 0x1)"
use std.spec.{check, check_msg}

        check(code.contains("& ~0x1"))
use std.spec.{check, check_msg}

        check(not code.contains("<<"))
