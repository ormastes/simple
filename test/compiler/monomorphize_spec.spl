# Monomorphization Test Specification
#
# Tests for the monomorphization engine that creates specialized versions
# of generic functions, structs, and classes by substituting concrete types.
#
# NOTE: Full testing requires compiled mode due to interpreter limitations:
# - Import system has limited support for enum variants and functions
# - Static method calls (ClassName.create()) not supported
# - Class instance methods not properly available
#
# The implementation has been verified to parse correctly.
# Files implemented:
# - src/compiler/monomorphize/type_subst.spl (450 LOC)
# - src/compiler/monomorphize/engine.spl (230 LOC)
# - src/compiler/monomorphize/analyzer.spl (53 LOC)
# - src/compiler/monomorphize/rewriter.spl (75 LOC)
# - src/compiler/monomorphize/binding_specializer.spl (56 LOC)
# - src/compiler/monomorphize/cache.spl (134 LOC)
# Total: 6 files, ~1000 LOC

# @skip - Uses unsupported keyword: with
use std.test.*
use compiler.hir_types.SymbolId

# ============================================================================
# Documentation Tests
# ============================================================================

describe "Monomorphization Implementation":
    describe "Module Structure":
        it "type_subst.spl provides type substitution":
            # TypeSubstitution class: Maps type parameter names to HirTypes
            # substitute_type(): Recursively replaces TypeParam in types
            # substitute_expr(): Replaces types in all expression kinds
            # substitute_function(): Creates specialized function with mangled name
            pass

        it "engine.spl provides core monomorphization engine":
            # ConcreteType enum: Int, Float, Bool, String, Nil, Named, Array, Tuple, Dict, Function, Optional, Specialized
            # SpecializationKey struct: name + type_args with mangled_name() method
            # MonomorphizationTable class: Tracks pending/completed specializations
            # Monomorphizer class: Main engine that processes generic functions
            pass

        it "analyzer.spl finds call sites to generic functions":
            # CallSite struct: function_name + type_args
            # CallSiteAnalyzer class: Collects call sites and infers type arguments
            pass

        it "rewriter.spl rewrites module to use specialized functions":
            # CallRewrite struct: original_name, type_args, mangled_name
            # ModuleRewriter class: Rewrites call sites to mangled names
            # monomorphize_module(): Full pipeline function
            pass

        it "binding_specializer.spl handles interface bindings":
            # InterfaceBinding struct: interface_name + impl_type_name
            # BindingSpecializer class: Resolves trait methods to concrete implementations
            pass

        it "cache.spl provides caching for specialized functions":
            # MonoCacheConfig struct: max_entries, validate_timestamps, persist_to_disk
            # MonoCacheStats struct: hits, misses, evictions, invalidations
            # CacheEntry struct: key, value, last_access, content_hash
            # MonoCache class: LRU cache with optional disk persistence
            pass

    describe "Key Algorithms":
        it "Name Mangling creates unique names":
            # identity<Int> -> identity$Int
            # map<Int, String> -> map$Int_String
            # process<Array<Int>> -> process$Array_Int
            pass

        it "Type Substitution handles all HIR types":
            # Primitives: Int, Float, Bool, Char, Str, Unit
            # Composites: Tuple, Array, Slice, Dict
            # References: Ref, Ptr, Optional, Result
            # User-defined: Named (with type args substituted)
            # Functions: params and return type substituted
            # TypeParam: replaced with concrete type from mapping
            pass

        it "Iterative Processing handles transitive specializations":
            # When specializing fn<T> that calls g<T>:
            # 1. Request fn<Int>
            # 2. While processing fn<Int>, discover call to g<Int>
            # 3. Request g<Int>
            # 4. Process until no pending specializations
            pass

    describe "Integration Points":
        it "Works with HIR definitions":
            # Uses HirFunction, HirTypeParam, HirParam, HirType
            # Uses HirExpr with all expression kinds
            # Uses HirPattern, HirStmt, HirBlock
            pass

        it "Uses HIR type system":
            # HirTypeKind for type kinds
            # SymbolId for type references
            # Span for source locations
            pass

    describe "Performance Considerations":
        it "Caches specializations to avoid re-work":
            # MonoCache prevents duplicate specialization
            # LRU eviction when cache is full
            # Optional disk persistence for incremental compilation
            pass

        it "Tracks statistics for optimization":
            # Cache hit ratio
            # Number of specializations created
            # Eviction and invalidation counts
            pass
