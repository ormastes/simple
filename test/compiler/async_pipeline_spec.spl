#!/usr/bin/env simple
# Async Pipeline Integration Tests
#
# Tests the complete async/await pipeline from source to validated HIR:
# 1. Source code parsing
# 2. Desugaring (state machine generation)
# 3. HIR lowering
# 4. Async validation
# 5. Error reporting
#
# These are end-to-end tests that verify the entire async implementation.

use std.spec.{describe, it, expect}
use compiler.parser.{parse_module}
use compiler.hir_lowering.{HirLowering}
use compiler.lexer.{lex}

describe "Async Pipeline - Valid Async Functions":
    it "accepts async function returning Future<text>":
        val source = """
async fn fetch_data() -> Future<text>:
    val result = await http_get("url")
    result
"""

        # Parse and lex
        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        # Check parsing succeeded
        expect(module.?).to_equal(true)

        # Lower to HIR
        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        # Should have one function
        expect(hir_module.functions.len()).to_equal(1)

        # Function should be marked as async
        val func = hir_module.functions.values()[0]
        expect(func.is_async).to_equal(true)
        expect(func.name).to_equal("fetch_data")

    it "accepts async function returning Future<i64>":
        val source = """
async fn compute() -> Future<i64>:
    val x = await get_number()
    x * 2
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        val func = hir_module.functions.values()[0]
        expect(func.is_async).to_equal(true)
        expect(func.name).to_equal("compute")

    it "accepts async function with multiple await points":
        val source = """
async fn multi_await() -> Future<text>:
    val x = await step1()
    val y = await step2(x)
    val z = await step3(y)
    z
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        val func = hir_module.functions.values()[0]
        expect(func.is_async).to_equal(true)
        expect(func.name).to_equal("multi_await")

describe "Async Pipeline - Error Detection":
    it "detects async function without Future return type":
        val source = """
async fn bad_fetch() -> text:
    "result"
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()

        # Lower should succeed but produce validation errors
        val hir_module = lowering.lower_module(module)

        # Check that lowering produced errors
        expect(lowering.has_errors()).to_equal(true)

    it "detects non-async function using await":
        val source = """
fn bad_sync() -> text:
    val x = await fetch()
    x
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()

        # Should detect await in non-async function
        val hir_module = lowering.lower_module(module)

        # This should produce an error (await outside async)
        # Note: This will be caught during expression lowering, not async validation
        expect(lowering.has_errors()).to_equal(true)

describe "Async Pipeline - Regular Functions":
    it "accepts non-async function":
        val source = """
fn regular_function(x: i64) -> i64:
    x * 2
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        val func = hir_module.functions.values()[0]
        expect(func.is_async).to_equal(false)
        expect(func.name).to_equal("regular_function")

    it "accepts function returning Future without async":
        # This is valid - manual Future construction
        val source = """
fn manual_future() -> Future<text>:
    Future.new("result")
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        val func = hir_module.functions.values()[0]
        expect(func.is_async).to_equal(false)
        expect(func.name).to_equal("manual_future")

describe "Async Pipeline - Complex Cases":
    it "handles async function with parameters":
        val source = """
async fn fetch_user(id: i64, cache: bool) -> Future<text>:
    if cache:
        val cached = await check_cache(id)
        if cached.?:
            return cached
    await fetch_from_db(id)
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        val func = hir_module.functions.values()[0]
        expect(func.is_async).to_equal(true)
        expect(func.params.len()).to_equal(2)

    it "handles async function with type parameters":
        val source = """
async fn fetch_generic<T>(url: text) -> Future<T>:
    val response = await http_get(url)
    parse<T>(response)
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        val func = hir_module.functions.values()[0]
        expect(func.is_async).to_equal(true)
        expect(func.type_params.len()).to_equal(1)

    it "handles async method in class":
        val source = """
class HttpClient:
    base_url: text

    async fn fetch(path: text) -> Future<text>:
        val url = self.base_url + path
        await http_get(url)
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        val class_ = hir_module.classes.values()[0]
        expect(class_.name).to_equal("HttpClient")
        expect(class_.methods.len()).to_equal(1)

describe "Async Pipeline - Nested Async":
    it "handles await in nested block":
        val source = """
async fn nested_await() -> Future<i64>:
    var sum = 0
    for i in 0..10:
        val value = await compute(i)
        sum = sum + value
    sum
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        val func = hir_module.functions.values()[0]
        expect(func.is_async).to_equal(true)

    it "handles await in match expression":
        val source = """
async fn match_await(opt: Option<text>) -> Future<text>:
    match opt:
        Some(key):
            await fetch(key)
        None:
            "default"
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        val func = hir_module.functions.values()[0]
        expect(func.is_async).to_equal(true)

    it "handles await in if expression":
        val source = """
async fn if_await(condition: bool) -> Future<text>:
    if condition:
        await fetch_true()
    else:
        await fetch_false()
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        val func = hir_module.functions.values()[0]
        expect(func.is_async).to_equal(true)

describe "Async Pipeline - Error Recovery":
    it "continues processing after async validation error":
        val source = """
async fn bad_async() -> text:
    "should be Future<text>"

fn good_function() -> i64:
    42
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        # Should have both functions despite error in first
        expect(hir_module.functions.len()).to_equal(2)

        # First has error
        expect(lowering.has_errors()).to_equal(true)

    it "reports multiple async errors in same module":
        val source = """
async fn bad1() -> text:
    "error 1"

async fn bad2() -> i64:
    42

async fn good() -> Future<text>:
    "correct"
"""

        val tokens = lex(source, "test.spl")
        val module = parse_module(tokens)

        expect(module.?).to_equal(true)

        var lowering = HirLowering.new()
        val hir_module = lowering.lower_module(module)

        # Should have all three functions
        expect(hir_module.functions.len()).to_equal(3)

        # Should have multiple errors (bad1 and bad2)
        expect(lowering.has_errors()).to_equal(true)
        expect(lowering.error_count()).to_be_greater_than(1)
