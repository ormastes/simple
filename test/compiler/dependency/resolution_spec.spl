# @pending
# @skip - Uses unsupported keyword: with
"""
Feature: Module Resolution
Category: Dependency Tracker
Status: In Progress
"""

# Tests for module path resolution algorithm
#
# These tests validate the 4 Lean theorems from:
# verification/module_resolution/src/ModuleResolution.lean
#
# Theorems:
# 1. wellformed_not_ambiguous: Well-formed filesystems don't have ambiguous resolutions
# 2. unique_path_form: Unique resolutions have expected path forms
# 3. unique_implies_exists: Unique result implies file exists
# 4. notfound_means_neither: Not found means neither file nor directory exists

use sspec.{describe, it, expect}
use compiler.dependency.resolution.{
    Segment, ModPath, FileKind, ResolutionResult,
    FileSystem, to_file_path, to_dir_path, resolve, is_well_formed
}

describe "Segment":
    """
    Non-empty string identifier for module path segments.
    """
    context "construction":
        it "creates segment from non-empty string":
            match Segment.new("foo"):
                case Some(seg):
                    expect seg.name() == "foo"
                case nil:
                    fail("Expected Some(segment)")

        it "returns None for empty string":
            match Segment.new(""):
                case Some(_):
                    fail("Expected None for empty string")
                case nil:
                    pass

    context "equality":
        it "segments with same name are equal":
            val seg1 = Segment.new("foo").unwrap()
            val seg2 = Segment.new("foo").unwrap()

            expect seg1.equals(seg2)

        it "segments with different names are not equal":
            val seg1 = Segment.new("foo").unwrap()
            val seg2 = Segment.new("bar").unwrap()

            expect not seg1.equals(seg2)

describe "ModPath":
    """
    Non-empty list of segments representing a module path.
    """
    context "construction":
        it "creates path from non-empty segments":
            val segs = [
                Segment.new("crate").unwrap(),
                Segment.new("sys").unwrap(),
                Segment.new("http").unwrap()
            ]

            match ModPath.new(segs):
                case Some(mp):
                    expect mp.to_string() == "crate.sys.http"
                case nil:
                    fail("Expected Some(ModPath)")

        it "returns None for empty segments list":
            val empty: List<Segment> = []

            match ModPath.new(empty):
                case Some(_):
                    fail("Expected None for empty segments")
                case nil:
                    pass

    context "parsing":
        it "parses dot-separated path":
            match ModPath.parse("crate.sys.http"):
                case Some(mp):
                    expect mp.to_string() == "crate.sys.http"
                    expect mp.segments().len() == 3
                case nil:
                    fail("Expected valid ModPath")

        it "parses single segment":
            match ModPath.parse("main"):
                case Some(mp):
                    expect mp.to_string() == "main"
                    expect mp.segments().len() == 1
                case nil:
                    fail("Expected valid ModPath")

        it "handles trailing dots by filtering":
            match ModPath.parse("crate.sys."):
                case Some(mp):
                    # Should filter out empty trailing segment
                    expect mp.to_string() == "crate.sys"
                case nil:
                    fail("Expected valid ModPath")

    context "absolute paths":
        it "identifies absolute paths starting with crate":
            val mp = ModPath.parse("crate.sys.http").unwrap()

            expect mp.is_absolute()

        it "identifies relative paths not starting with crate":
            val mp = ModPath.parse("sys.http").unwrap()

            expect not mp.is_absolute()

    context "crate prefix removal":
        it "removes crate prefix from absolute path":
            val mp = ModPath.parse("crate.sys.http").unwrap()

            match mp.without_crate_prefix():
                case Some(rel):
                    expect rel.to_string() == "sys.http"
                case nil:
                    fail("Expected relative path")

        it "returns clone for relative path":
            val mp = ModPath.parse("sys.http").unwrap()

            match mp.without_crate_prefix():
                case Some(rel):
                    expect rel.to_string() == "sys.http"
                case nil:
                    fail("Expected same path")

        it "returns None for bare crate":
            val mp = ModPath.parse("crate").unwrap()

            match mp.without_crate_prefix():
                case Some(_):
                    fail("Expected None for bare crate")
                case nil:
                    pass

describe "FileKind":
    """
    Enum for file vs directory modules.
    """
    context "variants":
        it "has File variant":
            val kind = FileKind.File

            expect kind.to_string() == "File"

        it "has Directory variant":
            val kind = FileKind.Directory

            expect kind.to_string() == "Directory"

describe "FileSystem":
    """
    Tracks which files exist for resolution.
    """
    context "construction":
        it "creates empty filesystem":
            val fs = FileSystem.new()

            expect fs.files.len() == 0

        it "creates filesystem from file list":
            val files = ["foo.spl", "bar/__init__.spl"]
            val fs = FileSystem.from_files(files)

            expect fs.files.len() == 2

    context "file existence":
        it "finds existing file":
            val fs = FileSystem.from_files(["src/main.spl"])

            expect fs.has_file("src/main.spl")

        it "returns false for non-existent file":
            val fs = FileSystem.from_files(["src/main.spl"])

            expect not fs.has_file("src/other.spl")

describe "Path Conversion":
    """
    Convert module paths to filesystem paths.
    """
    context "file paths":
        it "converts simple path to file path":
            val mp = ModPath.parse("main").unwrap()
            val path = to_file_path("src", mp)

            expect path == "src/main.spl"

        it "converts nested path to file path":
            val mp = ModPath.parse("sys.http").unwrap()
            val path = to_file_path("src", mp)

            expect path == "src/sys/http.spl"

    context "directory paths":
        it "converts simple path to directory path":
            val mp = ModPath.parse("main").unwrap()
            val path = to_dir_path("src", mp)

            expect path == "src/main/__init__.spl"

        it "converts nested path to directory path":
            val mp = ModPath.parse("sys.http").unwrap()
            val path = to_dir_path("src", mp)

            expect path == "src/sys/http/__init__.spl"

describe "Resolution Algorithm":
    """
    Core module resolution with Lean theorem validation.
    """
    context "unique file resolution":
        it "resolves to file when only file exists":
            val fs = FileSystem.from_files(["src/main.spl"])
            val mp = ModPath.parse("main").unwrap()

            match resolve(fs, "src", mp):
                case ResolutionResult.Unique(kind, path):
                    expect kind == FileKind.File
                    expect path == "src/main.spl"
                case _:
                    fail("Expected Unique resolution")

    context "unique directory resolution":
        it "resolves to directory when only __init__.spl exists":
            val fs = FileSystem.from_files(["src/main/__init__.spl"])
            val mp = ModPath.parse("main").unwrap()

            match resolve(fs, "src", mp):
                case ResolutionResult.Unique(kind, path):
                    expect kind == FileKind.Directory
                    expect path == "src/main/__init__.spl"
                case _:
                    fail("Expected Unique resolution")

    context "ambiguous resolution":
        it "returns ambiguous when both file and directory exist":
            val fs = FileSystem.from_files([
                "src/main.spl",
                "src/main/__init__.spl"
            ])
            val mp = ModPath.parse("main").unwrap()

            match resolve(fs, "src", mp):
                case ResolutionResult.Ambiguous(fp, dp):
                    expect fp == "src/main.spl"
                    expect dp == "src/main/__init__.spl"
                case _:
                    fail("Expected Ambiguous resolution")

    context "not found":
        it "returns not found when neither exists":
            val fs = FileSystem.new()
            val mp = ModPath.parse("main").unwrap()

            match resolve(fs, "src", mp):
                case ResolutionResult.NotFound:
                    pass
                case _:
                    fail("Expected NotFound")

describe "Well-Formedness":
    """
    Filesystem well-formedness checking.
    """
    context "well-formed filesystems":
        it "accepts filesystem with no conflicts":
            val fs = FileSystem.from_files([
                "src/main.spl",
                "src/sys/http.spl",
                "src/util/__init__.spl"
            ])

            expect is_well_formed(fs, "src")

    context "malformed filesystems":
        it "rejects filesystem with file-directory conflict":
            val fs = FileSystem.from_files([
                "src/main.spl",
                "src/main/__init__.spl"
            ])

            expect not is_well_formed(fs, "src")

describe "Lean Theorem 1: wellformed_not_ambiguous":
    """
    In a well-formed filesystem, resolution never returns ambiguous.
    """
    it "well-formed filesystem produces no ambiguous resolutions":
        val fs = FileSystem.from_files([
            "src/main.spl",
            "src/util/__init__.spl"
        ])

        # Verify well-formed
        expect is_well_formed(fs, "src")

        # Test main (file only)
        val mp1 = ModPath.parse("main").unwrap()
        val result1 = resolve(fs, "src", mp1)
        expect not result1.is_ambiguous()

        # Test util (directory only)
        val mp2 = ModPath.parse("util").unwrap()
        val result2 = resolve(fs, "src", mp2)
        expect not result2.is_ambiguous()

describe "Lean Theorem 2: unique_path_form":
    """
    Unique resolution returns one of the two expected path forms.
    """
    it "file resolution produces correct file path":
        val fs = FileSystem.from_files(["src/main.spl"])
        val mp = ModPath.parse("main").unwrap()

        match resolve(fs, "src", mp):
            case ResolutionResult.Unique(kind, path):
                expect kind == FileKind.File
                expect path == to_file_path("src", mp)
            case _:
                fail("Expected Unique")

    it "directory resolution produces correct dir path":
        val fs = FileSystem.from_files(["src/main/__init__.spl"])
        val mp = ModPath.parse("main").unwrap()

        match resolve(fs, "src", mp):
            case ResolutionResult.Unique(kind, path):
                expect kind == FileKind.Directory
                expect path == to_dir_path("src", mp)
            case _:
                fail("Expected Unique")

describe "Lean Theorem 3: unique_implies_exists":
    """
    Unique resolution implies the file exists.
    """
    it "unique result guarantees file exists":
        val fs = FileSystem.from_files(["src/main.spl"])
        val mp = ModPath.parse("main").unwrap()

        match resolve(fs, "src", mp):
            case ResolutionResult.Unique(_, path):
                expect fs.has_file(path)
            case _:
                fail("Expected Unique")

describe "Lean Theorem 4: notfound_means_neither":
    """
    Not found means neither file nor directory exists.
    """
    it "not found guarantees neither path exists":
        val fs = FileSystem.from_files(["src/other.spl"])
        val mp = ModPath.parse("main").unwrap()

        match resolve(fs, "src", mp):
            case ResolutionResult.NotFound:
                val fp = to_file_path("src", mp)
                val dp = to_dir_path("src", mp)
                expect not fs.has_file(fp)
                expect not fs.has_file(dp)
            case _:
                fail("Expected NotFound")
