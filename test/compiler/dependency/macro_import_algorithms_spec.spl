# Algorithm tests for macro auto-import

# @skip - Uses unsupported keyword: with
use sspec.{describe, it, expect}
use compiler.dependency.macro_import.{
    SymKind, MacroSymbol, AutoImport, MacroExports, MacroDirManifest,
    is_auto_imported, auto_imported_macros, glob_import, explicit_import, combine_exports
}

# Helper to create standard exports
fn make_exports() -> MacroExports:
    var exports = MacroExports.new()
    exports.add_non_macro(MacroSymbol.value_sym("mod", "foo"))
    exports.add_non_macro(MacroSymbol.value_sym("mod", "bar"))
    exports.add_macro(MacroSymbol.macro_sym("mod", "my_macro"))
    exports.add_macro(MacroSymbol.macro_sym("mod", "other_macro"))
    exports

describe "is_auto_imported":
    context "basic functionality":
        it "finds macro in list":
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "my_macro"))

            val sym = MacroSymbol.macro_sym("mod", "my_macro")
            expect is_auto_imported(manifest, sym)

        it "not found returns false":
            val manifest = MacroDirManifest.new("test")
            val sym = MacroSymbol.macro_sym("mod", "my_macro")
            expect not is_auto_imported(manifest, sym)

        it "wrong module returns false":
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod1", "my_macro"))

            val sym = MacroSymbol.macro_sym("mod2", "my_macro")
            expect not is_auto_imported(manifest, sym)

        it "wrong name returns false":
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "macro1"))

            val sym = MacroSymbol.macro_sym("mod", "macro2")
            expect not is_auto_imported(manifest, sym)

    context "kind checking":
        it "non-macro always returns false":
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "foo"))

            val sym = MacroSymbol.value_sym("mod", "foo")
            expect not is_auto_imported(manifest, sym)

        it "value type with macro name in list":
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "my_name"))

            val sym = MacroSymbol.value_sym("mod", "my_name")
            expect not is_auto_imported(manifest, sym)

    context "multiple imports":
        it "finds first in list":
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "macro1"))
            manifest.add_auto_import(AutoImport.new("mod", "macro2"))

            val sym = MacroSymbol.macro_sym("mod", "macro1")
            expect is_auto_imported(manifest, sym)

        it "finds last in list":
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "macro1"))
            manifest.add_auto_import(AutoImport.new("mod", "macro2"))

            val sym = MacroSymbol.macro_sym("mod", "macro2")
            expect is_auto_imported(manifest, sym)

        it "finds middle in list":
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "macro1"))
            manifest.add_auto_import(AutoImport.new("mod", "macro2"))
            manifest.add_auto_import(AutoImport.new("mod", "macro3"))

            val sym = MacroSymbol.macro_sym("mod", "macro2")
            expect is_auto_imported(manifest, sym)

describe "auto_imported_macros":
    context "empty cases":
        it "empty exports":
            val exports = MacroExports.new()
            val manifest = MacroDirManifest.new("test")

            val result = auto_imported_macros(manifest, exports)
            expect result.len() == 0

        it "empty auto-imports":
            val exports = make_exports()
            val manifest = MacroDirManifest.new("test")

            val result = auto_imported_macros(manifest, exports)
            expect result.len() == 0

        it "no macros in exports":
            var exports = MacroExports.new()
            exports.add_non_macro(MacroSymbol.value_sym("mod", "foo"))

            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "foo"))

            val result = auto_imported_macros(manifest, exports)
            expect result.len() == 0

    context "filtering":
        it "returns single auto-imported macro":
            val exports = make_exports()
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "my_macro"))

            val result = auto_imported_macros(manifest, exports)
            expect result.len() == 1

            if result.len() > 0:
                val first_sym = result[0]
                val first_name = first_sym.get_name()
                expect first_name == "my_macro"

        it "returns multiple auto-imported macros":
            val exports = make_exports()
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "my_macro"))
            manifest.add_auto_import(AutoImport.new("mod", "other_macro"))

            val result = auto_imported_macros(manifest, exports)
            expect result.len() == 2

        it "filters out non-auto-imported":
            val exports = make_exports()
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "my_macro"))

            val result = auto_imported_macros(manifest, exports)

            # Should not include other_macro
            var found_other = false
            for sym in result:
                val sym_name = sym.get_name()
                if sym_name == "other_macro":
                    found_other = true

            expect not found_other

describe "glob_import":
    context "includes non-macros":
        it "all non-macros present":
            val exports = make_exports()
            val manifest = MacroDirManifest.new("test")

            val result = glob_import(manifest, exports)

            var found_foo = false
            var found_bar = false
            for sym in result:
                val sym_name = sym.get_name()
                if sym_name == "foo":
                    found_foo = true
                if sym_name == "bar":
                    found_bar = true

            expect found_foo
            expect found_bar

        it "counts non-macros correctly":
            val exports = make_exports()
            val manifest = MacroDirManifest.new("test")

            val result = glob_import(manifest, exports)

            var non_macro_count = 0
            for sym in result:
                val sym_kind = sym.get_kind()
                if not sym_kind.is_macro():
                    non_macro_count = non_macro_count + 1

            expect non_macro_count == 2

    context "includes auto-imported macros":
        it "includes single auto-imported":
            val exports = make_exports()
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "my_macro"))

            val result = glob_import(manifest, exports)

            var found = false
            for sym in result:
                val sym_name = sym.get_name()
                if sym_name == "my_macro":
                    found = true

            expect found

        it "includes all auto-imported":
            val exports = make_exports()
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "my_macro"))
            manifest.add_auto_import(AutoImport.new("mod", "other_macro"))

            val result = glob_import(manifest, exports)

            var found_my = false
            var found_other = false
            for sym in result:
                val sym_name = sym.get_name()
                if sym_name == "my_macro":
                    found_my = true
                if sym_name == "other_macro":
                    found_other = true

            expect found_my
            expect found_other

    context "excludes non-auto-imported macros":
        it "excludes when none auto-imported":
            val exports = make_exports()
            val manifest = MacroDirManifest.new("test")

            val result = glob_import(manifest, exports)

            var found_any_macro = false
            for sym in result:
                val sym_kind = sym.get_kind()
                if sym_kind.is_macro():
                    found_any_macro = true

            expect not found_any_macro

        it "excludes specific non-auto-imported":
            val exports = make_exports()
            var manifest = MacroDirManifest.new("test")
            manifest.add_auto_import(AutoImport.new("mod", "my_macro"))

            val result = glob_import(manifest, exports)

            var found_other = false
            for sym in result:
                val sym_name = sym.get_name()
                if sym_name == "other_macro":
                    found_other = true

            expect not found_other

describe "explicit_import":
    context "finding symbols":
        it "finds non-macro":
            val exports = make_exports()
            match explicit_import(exports, "foo"):
                case Some(sym):
                    val sym_name = sym.get_name()
                    expect sym_name == "foo"
                case nil:
                    fail("Expected Some(symbol)")

        it "finds macro":
            val exports = make_exports()
            match explicit_import(exports, "my_macro"):
                case Some(sym):
                    val sym_name = sym.get_name()
                    val sym_kind = sym.get_kind()
                    expect sym_name == "my_macro"
                    expect sym_kind.is_macro()
                case nil:
                    fail("Expected Some(symbol)")

        it "finds all non-macros":
            val exports = make_exports()
            match explicit_import(exports, "bar"):
                case Some(sym):
                    val sym_name = sym.get_name()
                    expect sym_name == "bar"
                case nil:
                    fail("Expected Some(symbol)")

        it "finds all macros":
            val exports = make_exports()
            match explicit_import(exports, "other_macro"):
                case Some(sym):
                    val sym_name = sym.get_name()
                    expect sym_name == "other_macro"
                case nil:
                    fail("Expected Some(symbol)")

    context "not found":
        it "returns None for non-existent":
            val exports = make_exports()
            match explicit_import(exports, "nonexistent"):
                case Some(_):
                    fail("Expected None")
                case nil:
                    pass

        it "returns None for empty exports":
            val exports = MacroExports.new()
            match explicit_import(exports, "anything"):
                case Some(_):
                    fail("Expected None")
                case nil:
                    pass

describe "combine_exports":
    context "empty combinations":
        it "both empty":
            val e1 = MacroExports.new()
            val e2 = MacroExports.new()

            val combined = combine_exports(e1, e2)
            expect combined.non_macros.len() == 0
            expect combined.macros.len() == 0

        it "first empty":
            val e1 = MacroExports.new()
            var e2 = MacroExports.new()
            e2.add_non_macro(MacroSymbol.value_sym("mod", "foo"))

            val combined = combine_exports(e1, e2)
            expect combined.non_macros.len() == 1

        it "second empty":
            var e1 = MacroExports.new()
            e1.add_non_macro(MacroSymbol.value_sym("mod", "foo"))
            val e2 = MacroExports.new()

            val combined = combine_exports(e1, e2)
            expect combined.non_macros.len() == 1

    context "combining non-macros":
        it "combines from both":
            var e1 = MacroExports.new()
            e1.add_non_macro(MacroSymbol.value_sym("mod1", "foo"))

            var e2 = MacroExports.new()
            e2.add_non_macro(MacroSymbol.value_sym("mod2", "bar"))

            val combined = combine_exports(e1, e2)
            expect combined.non_macros.len() == 2

        it "preserves all non-macros":
            var e1 = MacroExports.new()
            e1.add_non_macro(MacroSymbol.value_sym("mod1", "foo"))
            e1.add_non_macro(MacroSymbol.value_sym("mod1", "bar"))

            var e2 = MacroExports.new()
            e2.add_non_macro(MacroSymbol.value_sym("mod2", "baz"))

            val combined = combine_exports(e1, e2)
            expect combined.non_macros.len() == 3

    context "combining macros":
        it "combines from both":
            var e1 = MacroExports.new()
            e1.add_macro(MacroSymbol.macro_sym("mod1", "macro1"))

            var e2 = MacroExports.new()
            e2.add_macro(MacroSymbol.macro_sym("mod2", "macro2"))

            val combined = combine_exports(e1, e2)
            expect combined.macros.len() == 2

        it "preserves all macros":
            var e1 = MacroExports.new()
            e1.add_macro(MacroSymbol.macro_sym("mod1", "m1"))
            e1.add_macro(MacroSymbol.macro_sym("mod1", "m2"))

            var e2 = MacroExports.new()
            e2.add_macro(MacroSymbol.macro_sym("mod2", "m3"))

            val combined = combine_exports(e1, e2)
            expect combined.macros.len() == 3

    context "mixed combinations":
        it "combines non-macros and macros":
            var e1 = MacroExports.new()
            e1.add_non_macro(MacroSymbol.value_sym("mod1", "foo"))
            e1.add_macro(MacroSymbol.macro_sym("mod1", "m1"))

            var e2 = MacroExports.new()
            e2.add_non_macro(MacroSymbol.value_sym("mod2", "bar"))
            e2.add_macro(MacroSymbol.macro_sym("mod2", "m2"))

            val combined = combine_exports(e1, e2)
            expect combined.non_macros.len() == 2
            expect combined.macros.len() == 2
