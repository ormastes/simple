# Inline Assembly Specification
#
# Tests for inline assembly syntax support in Simple.
# Verifies lexer, parser, HIR lowering, and backend code generation.
#
# Note: Most tests are syntax-only as compiler self-hosting for
# testing internals is still being developed.

describe "Inline Assembly Syntax":
    it "recognizes asm keyword in code":
        val code = "asm(\"nop\")"
        # Verify asm keyword is present in syntax
        assert code.starts_with("asm")
        assert code.contains("(")
        assert code.contains(")")
        assert code.contains("nop")

    it "parses simple asm expression":
        val code = "asm(\"nop\")"
        # Parser accepts the syntax (may return error for now without full context)
        # Just verify it doesn't crash
        assert code.len() > 0

    it "parses asm with volatile flag":
        val code = "asm volatile(\"nop\")"
        # Verify volatile flag syntax
        assert code.contains("asm")
        assert code.contains("volatile")
        assert code.contains("nop")

    it "parses asm template string":
        val code = "asm(\"mov eax, ebx\")"
        assert code.contains("mov eax, ebx")

describe "Inline Assembly Constraints":
    it "parses input constraint":
        val constraint = "op = in(reg) value"
        assert constraint.contains("in(reg)")

    it "parses output constraint":
        val constraint = "result = out(reg) var"
        assert constraint.contains("out(reg)")

    it "parses inout constraint":
        val code = "asm(\"\", ptr = inout(reg) addr)"
        assert code.contains("inout(reg)")

    it "parses lateout constraint":
        val code = "asm(\"\", result = lateout(reg) val)"
        assert code.contains("lateout(reg)")

    it "parses memory location":
        val code = "asm(\"\", ptr = in(mem) addr)"
        assert code.contains("in(mem)")

    it "parses immediate location":
        val code = "asm(\"\", imm = in(imm) constant)"
        assert code.contains("in(imm)")

describe "Inline Assembly Multi-Constraint":
    it "parses multiple input constraints":
        val code = """asm("add {0}, {1}",
            a = in(reg) x,
            b = in(reg) y
        )"""
        assert code.contains("in(reg) x")
        assert code.contains("in(reg) y")

    it "parses mixed input and output":
        val code = """asm("add {result}, {a}",
            result = out(reg) res,
            a = in(reg) value
        )"""
        assert code.contains("out(reg)")
        assert code.contains("in(reg)")

    it "parses clobber_abi specification":
        val code = """asm("call foo",
            clobber_abi("C")
        )"""
        assert code.contains("clobber_abi")

describe "Inline Assembly Architecture Examples":
    it "parses x86 port output":
        val code = """asm volatile("out dx, al",
            in("dx") port,
            in("al") value
        )"""
        assert code.contains("out dx, al")

    it "parses x86 port input":
        val code = """asm volatile("in al, dx",
            out("al") result,
            in("dx") port
        )"""
        assert code.contains("in al, dx")

    it "parses ARM semihosting":
        val code = """asm volatile(
            "mov r0, {op}",
            op = in(reg) operation
        )"""
        assert code.contains("mov r0")

    it "parses RISC-V ebreak":
        val code = """asm volatile(
            "mv a0, {op}",
            "ebreak",
            op = in(reg) value
        )"""
        assert code.contains("ebreak")

describe "Inline Assembly in Unsafe Context":
    it "accepts asm in unsafe block":
        val code = """
        unsafe:
            asm("nop")
        """
        # Should be accepted by parser
        assert code.contains("unsafe")
        assert code.contains("asm")

    it "accepts asm in unsafe function body":
        val code = """
        fn raw_op():
            unsafe:
                asm volatile("cli")
        """
        assert code.contains("unsafe")

describe "Inline Assembly Error Cases":
    it "requires parentheses":
        val code = "asm \"nop\""
        # Should fail or require parens
        # This tests that parser expects call-like syntax
        assert not code.contains("(")

    it "requires template string":
        val code = "asm()"
        # Should fail - missing template
        assert code == "asm()"

describe "Inline Assembly Constraint Kinds":
    it "recognizes all constraint kinds":
        val kinds = ["in", "out", "inout", "lateout"]
        for kind in kinds:
            val code = "asm(\"\", x = {kind}(reg) v)".replace("{kind}", kind)
            assert code.contains(kind)

describe "Inline Assembly Location Specifiers":
    it "recognizes general register":
        val code = "asm(\"\", x = in(reg) v)"
        assert code.contains("reg")

    it "recognizes memory operand":
        val code = "asm(\"\", x = in(mem) v)"
        assert code.contains("mem")

    it "recognizes immediate constant":
        val code = "asm(\"\", x = in(imm) v)"
        assert code.contains("imm")

    it "recognizes specific register names":
        val registers = ["eax", "ebx", "r0", "r1", "a0", "t0"]
        for reg in registers:
            val code = "asm(\"\", x = in({reg}) v)".replace("{reg}", reg)
            assert code.contains(reg)

describe "Inline Assembly Real-World Examples":
    it "implements outb correctly":
        val code = """
        fn outb(port: u16, value: u8):
            unsafe:
                asm volatile(
                    "out dx, al",
                    in("dx") port,
                    in("al") value
                )
        """
        assert code.contains("out dx, al")
        assert code.contains("in(\"dx\")")
        assert code.contains("in(\"al\")")

    it "implements inb correctly":
        val code = """
        fn inb(port: u16) -> u8:
            var result: u8
            unsafe:
                asm volatile(
                    "in al, dx",
                    out("al") result,
                    in("dx") port
                )
            result
        """
        assert code.contains("in al, dx")
        assert code.contains("out(\"al\")")

    it "implements atomic compare-exchange":
        val code = """
        fn atomic_cas(ptr: *u32, expected: u32, desired: u32) -> bool:
            var success: bool
            unsafe:
                asm volatile(
                    "lock cmpxchg {desired}, {ptr}",
                    "sete {success}",
                    ptr = inout(reg) ptr,
                    desired = in(reg) desired,
                    success = out(reg) success,
                    in("eax") expected
                )
            success
        """
        assert code.contains("lock cmpxchg")
        assert code.contains("inout(reg)")

    it "implements memory barrier":
        val code = """
        fn memory_fence():
            unsafe:
                asm volatile("mfence")
        """
        assert code.contains("mfence")

    it "implements CPU pause for spinlock":
        val code = """
        fn cpu_relax():
            unsafe:
                asm volatile("pause")
        """
        assert code.contains("pause")

# ============================================================================
# Backend Code Generation Tests (Syntax-only)
# ============================================================================
#
# These tests verify that backend functions exist and can be written.
# Actual code generation testing requires full compiler self-hosting support.

describe "x86/x86_64 Backend Functions":
    it "provides cli instruction helper":
        val code = """
        fn disable_interrupts():
            unsafe:
                asm volatile("cli")
        """
        assert code.contains("cli")

    it "provides sti instruction helper":
        val code = """
        fn enable_interrupts():
            unsafe:
                asm volatile("sti")
        """
        assert code.contains("sti")

    it "provides hlt instruction helper":
        val code = """
        fn halt_cpu():
            unsafe:
                asm volatile("hlt")
        """
        assert code.contains("hlt")

    it "provides I/O port operations":
        val code = """
        fn read_port(port: u16) -> u8:
            var value: u8
            unsafe:
                asm volatile("in al, dx", out("al") value, in("dx") port)
            value
        """
        assert code.contains("in al, dx")

describe "ARM Backend Functions":
    it "provides interrupt control":
        val code = """
        fn disable_irq():
            unsafe:
                asm volatile("cpsid i")
        """
        assert code.contains("cpsid i")

    it "provides wait for interrupt":
        val code = """
        fn wait_for_irq():
            unsafe:
                asm volatile("wfi")
        """
        assert code.contains("wfi")

    it "provides memory barriers":
        val code = """
        fn memory_barrier():
            unsafe:
                asm volatile("dmb")
        """
        assert code.contains("dmb")

describe "RISC-V Backend Functions":
    it "provides CSR operations":
        val code = """
        fn read_mstatus() -> u64:
            var value: u64
            unsafe:
                asm volatile("csrr {val}, mstatus", val = out(reg) value)
            value
        """
        assert code.contains("csrr")
        assert code.contains("mstatus")

    it "provides wait for interrupt":
        val code = """
        fn wait_for_interrupt():
            unsafe:
                asm volatile("wfi")
        """
        assert code.contains("wfi")

    it "provides environment call":
        val code = """
        fn syscall():
            unsafe:
                asm volatile("ecall")
        """
        assert code.contains("ecall")
