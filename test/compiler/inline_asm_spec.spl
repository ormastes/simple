# Inline Assembly Specification
#
# Tests for inline assembly syntax support in Simple.
# Verifies lexer, parser, HIR lowering, and backend code generation.
#
# Note: Most tests are syntax-only as compiler self-hosting for
# testing internals is still being developed.

use std.spec.{check, check_msg}

describe "Inline Assembly Syntax":

    it "recognizes asm keyword in code":

        val code = "asm(\"nop\")"

        # Verify asm keyword is present in syntax

        check(code.starts_with("asm"))

        check(code.contains("("))

        check(code.contains(")"))

        check(code.contains("nop"))


    it "parses simple asm expression":

        val code = "asm(\"nop\")"

        # Parser accepts the syntax (may return error for now without full context)

        # Just verify it doesn't crash

        check(code.len() > 0)


    it "parses asm with volatile flag":

        val code = "asm volatile(\"nop\")"

        # Verify volatile flag syntax

        check(code.contains("asm"))

        check(code.contains("volatile"))

        check(code.contains("nop"))


    it "parses asm template string":

        val code = "asm(\"mov eax, ebx\")"

        check(code.contains("mov eax, ebx"))


describe "Inline Assembly Constraints":

    it "parses input constraint":

        val constraint = "op = in(reg) value"

        check(constraint.contains("in(reg)"))


    it "parses output constraint":

        val constraint = "result = out(reg) var"

        check(constraint.contains("out(reg)"))


    it "parses inout constraint":

        val code = "asm(\"\", ptr = inout(reg) addr)"

        check(code.contains("inout(reg)"))


    it "parses lateout constraint":

        val code = "asm(\"\", result = lateout(reg) val)"

        check(code.contains("lateout(reg)"))


    it "parses memory location":

        val code = "asm(\"\", ptr = in(mem) addr)"

        check(code.contains("in(mem)"))


    it "parses immediate location":

        val code = "asm(\"\", imm = in(imm) constant)"

        check(code.contains("in(imm)"))


describe "Inline Assembly Multi-Constraint":

    it "parses multiple input constraints":

        val code = """asm("add {0}, {1}",

            a = in(reg) x,

            b = in(reg) y

        )"""

        check(code.contains("in(reg) x"))

        check(code.contains("in(reg) y"))


    it "parses mixed input and output":

        val code = """asm("add {result}, {a}",

            result = out(reg) res,

            a = in(reg) value

        )"""

        check(code.contains("out(reg)"))

        check(code.contains("in(reg)"))


    it "parses clobber_abi specification":

        val code = """asm("call foo",

            clobber_abi("C")

        )"""

        check(code.contains("clobber_abi"))


describe "Inline Assembly Architecture Examples":

    it "parses x86 port output":

        val code = """asm volatile("out dx, al",

            in("dx") port,

            in("al") value

        )"""

        check(code.contains("out dx, al"))


    it "parses x86 port input":

        val code = """asm volatile("in al, dx",

            out("al") result,

            in("dx") port

        )"""

        check(code.contains("in al, dx"))


    it "parses ARM semihosting":

        val code = """asm volatile(

            "mov r0, {op}",

            op = in(reg) operation

        )"""

        check(code.contains("mov r0"))


    it "parses RISC-V ebreak":

        val code = """asm volatile(

            "mv a0, {op}",

            "ebreak",

            op = in(reg) value

        )"""

        check(code.contains("ebreak"))


describe "Inline Assembly in Unsafe Context":

    it "accepts asm in unsafe block":

        val code = """

        unsafe:

            asm("nop")

        """

        # Should be accepted by parser

        check(code.contains("unsafe"))

        check(code.contains("asm"))


    it "accepts asm in unsafe function body":

        val code = """

        fn raw_op():

            unsafe:

                asm volatile("cli")

        """

        check(code.contains("unsafe"))


describe "Inline Assembly Error Cases":

    it "requires parentheses":

        val code = "asm \"nop\""

        # Should fail or require parens

        # This tests that parser expects call-like syntax

        check(not code.contains("("))


    it "requires template string":

        val code = "asm()"

        # Should fail - missing template

        check(code == "asm()")


describe "Inline Assembly Constraint Kinds":

    it "recognizes all constraint kinds":

        val kinds = ["in", "out", "inout", "lateout"]

        for kind in kinds:

            val code = "asm(\"\", x = {kind}(reg) v)".replace("{kind}", kind)

            check(code.contains(kind))


describe "Inline Assembly Location Specifiers":

    it "recognizes general register":

        val code = "asm(\"\", x = in(reg) v)"

        check(code.contains("reg"))


    it "recognizes memory operand":

        val code = "asm(\"\", x = in(mem) v)"

        check(code.contains("mem"))


    it "recognizes immediate constant":

        val code = "asm(\"\", x = in(imm) v)"

        check(code.contains("imm"))


    it "recognizes specific register names":

        val registers = ["eax", "ebx", "r0", "r1", "a0", "t0"]

        for reg in registers:

            val code = "asm(\"\", x = in({reg}) v)".replace("{reg}", reg)

            check(code.contains(reg))


describe "Inline Assembly Real-World Examples":

    it "implements outb correctly":

        val code = """

        fn outb(port: u16, value: u8):

            unsafe:

                asm volatile(

                    "out dx, al",

                    in("dx") port,

                    in("al") value

                )

        """

        check(code.contains("out dx, al"))

        check(code.contains("in(\"dx\")"))

        check(code.contains("in(\"al\")"))


    it "implements inb correctly":

        val code = """

        fn inb(port: u16) -> u8:

            var result: u8

            unsafe:

                asm volatile(

                    "in al, dx",

                    out("al") result,

                    in("dx") port

                )

            result

        """

        check(code.contains("in al, dx"))

        check(code.contains("out(\"al\")"))


    it "implements atomic compare-exchange":

        val code = """

        fn atomic_cas(ptr: *u32, expected: u32, desired: u32) -> bool:

            var success: bool

            unsafe:

                asm volatile(

                    "lock cmpxchg {desired}, {ptr}",

                    "sete {success}",

                    ptr = inout(reg) ptr,

                    desired = in(reg) desired,

                    success = out(reg) success,

                    in("eax") expected

                )

            success

        """

        check(code.contains("lock cmpxchg"))

        check(code.contains("inout(reg)"))


    it "implements memory barrier":

        val code = """

        fn memory_fence():

            unsafe:

                asm volatile("mfence")

        """

        check(code.contains("mfence"))


    it "implements CPU pause for spinlock":

        val code = """

        fn cpu_relax():

            unsafe:

                asm volatile("pause")

        """

        check(code.contains("pause"))

# ============================================================================
# Backend Code Generation Tests (Syntax-only)
# ============================================================================
#
# These tests verify that backend functions exist and can be written.
# Actual code generation testing requires full compiler self-hosting support.


describe "x86/x86_64 Backend Functions":

    it "provides cli instruction helper":

        val code = """

        fn disable_interrupts():

            unsafe:

                asm volatile("cli")

        """

        check(code.contains("cli"))


    it "provides sti instruction helper":

        val code = """

        fn enable_interrupts():

            unsafe:

                asm volatile("sti")

        """

        check(code.contains("sti"))


    it "provides hlt instruction helper":

        val code = """

        fn halt_cpu():

            unsafe:

                asm volatile("hlt")

        """

        check(code.contains("hlt"))


    it "provides I/O port operations":

        val code = """

        fn read_port(port: u16) -> u8:

            var value: u8

            unsafe:

                asm volatile("in al, dx", out("al") value, in("dx") port)

            value

        """

        check(code.contains("in al, dx"))


describe "ARM Backend Functions":

    it "provides interrupt control":

        val code = """

        fn disable_irq():

            unsafe:

                asm volatile("cpsid i")

        """

        check(code.contains("cpsid i"))


    it "provides wait for interrupt":

        val code = """

        fn wait_for_irq():

            unsafe:

                asm volatile("wfi")

        """

        check(code.contains("wfi"))


    it "provides memory barriers":

        val code = """

        fn memory_barrier():

            unsafe:

                asm volatile("dmb")

        """

        check(code.contains("dmb"))


describe "RISC-V Backend Functions":

    it "provides CSR operations":

        val code = """

        fn read_mstatus() -> u64:

            var value: u64

            unsafe:

                asm volatile("csrr {val}, mstatus", val = out(reg) value)

            value

        """

        check(code.contains("csrr"))

        check(code.contains("mstatus"))


    it "provides wait for interrupt":

        val code = """

        fn wait_for_interrupt():

            unsafe:

                asm volatile("wfi")

        """

        check(code.contains("wfi"))


    it "provides environment call":

        val code = """

        fn syscall():

            unsafe:

                asm volatile("ecall")

        """

        check(code.contains("ecall"))
