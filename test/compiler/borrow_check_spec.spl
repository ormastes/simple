# Borrow Checking Tests
#
# Tests for the borrow checking system including
# lifetimes, borrow graph, and NLL analysis.

use std.spec.{check, check_msg}
use testing.*
use compiler.borrow_check.*

# ============================================================================
# Lifetime Tests
# ============================================================================

describe "Lifetime":
    it "creates named lifetime":
        val lt = Lifetime.Named("a")
        check(lt.to_text() == "'a")

    it "creates anonymous lifetime":
        val lt = Lifetime.Anonymous(0)
        check(lt.to_text() == "'_0")

    it "creates static lifetime":
        check(Lifetime.Static.to_text() == "'static")

    it "checks static lifetime":
        check(Lifetime.Static.is_static() == true)
        check(Lifetime.Named("a").is_static() == false)
        check(Lifetime.Anonymous(0).is_static() == false)

    it "compares lifetimes for equality":
        check(Lifetime.Named("a").equals(Lifetime.Named("a")) == true)
        check(Lifetime.Named("a").equals(Lifetime.Named("b")) == false)
        check(Lifetime.Anonymous(0).equals(Lifetime.Anonymous(0)) == true)
        check(Lifetime.Static.equals(Lifetime.Static) == true)

describe "Region":
    it "creates region with lifetime":
        val region = Region.create(0, Lifetime.Named("a"))
        check(region.lifetime.to_text() == "'a")
        check(region.id == 0)

    it "checks point containment":
        var region = Region.create(0, Lifetime.Named("a"))
        region.start_point = 10
        region.end_point = 20
        check(region.contains_point(15) == true)
        check(region.contains_point(10) == true)
        check(region.contains_point(20) == true)
        check(region.contains_point(5) == false)
        check(region.contains_point(25) == false)

    it "extends to include point":
        var region = Region.create(0, Lifetime.Named("a"))
        region.start_point = 10
        region.end_point = 20
        region.extend_to(25)
        check(region.end_point == 25)
        region.extend_to(5)
        check(region.start_point == 5)

describe "LifetimeConstraint":
    it "creates outlives constraint":
        val c = LifetimeConstraint.outlives(Lifetime.Named("a"), Lifetime.Named("b"), "test reason")
        check(c.to_text() == "'a: 'b")
        check(c.reason == "test reason")

    it "creates equals constraint":
        val c = LifetimeConstraint.equals(Lifetime.Named("a"), Lifetime.Named("b"), "equality")
        check(c.to_text() == "'a = 'b")

describe "LifetimeEnv":
    it "creates fresh lifetimes":
        var env = LifetimeEnv.create()
        val lt1 = env.fresh_lifetime()
        val lt2 = env.fresh_lifetime()
        check(lt1.to_text() == "'_0")
        check(lt2.to_text() == "'_1")

    it "binds named lifetimes":
        var env = LifetimeEnv.create()
        val lt = Lifetime.Named("a")
        env.bind("a", lt)
        val lookup = env.lookup("a")
        check(lookup.? == true)
        check(lookup.unwrap().to_text() == "'a")

    it "collects constraints":
        var env = LifetimeEnv.create()
        env.add_outlives(Lifetime.Named("a"), Lifetime.Named("b"), "test")
        check(env.constraints.len() == 1)

describe "LifetimeInference":
    it "solves simple outlives":
        var infer = LifetimeInference.create()
        val lt_a = infer.env.fresh_lifetime()
        val lt_b = infer.env.fresh_lifetime()

        # Create regions
        var region_a = infer.env.fresh_region(lt_a)
        var region_b = infer.env.fresh_region(lt_b)

        # Set region_b to [10..20]
        region_b.start_point = 10
        region_b.end_point = 20
        infer.env.regions[region_b.id] = region_b

        # Add 'a: 'b constraint
        infer.env.add_outlives(lt_a, lt_b, "test")

        # Run inference
        val ok = infer.infer()
        check(ok == true)

# ============================================================================
# Place Tests
# ============================================================================

describe "Place":
    it "creates local place":
        val p = Place.local(0)
        check(p.to_text() == "_l0")

    it "adds dereference":
        val p = Place.local(0).deref()
        check(p.to_text() == "*_l0")

    it "adds field access":
        val p = Place.local(0).field(1)
        check(p.to_text() == "_l0.1")

    it "checks prefix relationship":
        val x = Place.local(0)
        val x_f = Place.local(0).field(0)
        check(x.is_prefix_of(x_f) == true)
        check(x.is_prefix_of(x) == true)

    it "detects conflicts":
        val x = Place.local(0)
        val x_f = Place.local(0).field(0)
        val y = Place.local(1)
        check(x.conflicts_with(x_f) == true)
        check(x.conflicts_with(y) == false)

# ============================================================================
# Borrow Tests
# ============================================================================

describe "BorrowKind":
    it "identifies mutable borrows":
        check(BorrowKind.Mutable.is_mutable() == true)
        check(BorrowKind.Shared.is_mutable() == false)
        check(BorrowKind.Unique.is_mutable() == true)

    it "detects conflicts":
        # Shared + Shared = no conflict
        check(BorrowKind.Shared.conflicts_with(BorrowKind.Shared) == false)
        # Shared + Mutable = conflict
        check(BorrowKind.Shared.conflicts_with(BorrowKind.Mutable) == true)
        # Mutable + Mutable = conflict
        check(BorrowKind.Mutable.conflicts_with(BorrowKind.Mutable) == true)

describe "Borrow":
    it "creates regular borrow":
        val p = Place.local(0)
        val lt = Lifetime.Named("a")
        val borrow = Borrow(id: 1, place: p, kind: BorrowKind.Shared, lifetime: lt, borrow_point: 10, activated: true)
        check(borrow.id == 1)
        check(borrow.activated == true)
        check(borrow.borrow_point == 10)

    it "creates two-phase borrow":
        val p = Place.local(0)
        val lt = Lifetime.Named("a")
        val borrow = Borrow.two_phase(1, p, BorrowKind.Mutable, lt, 10)
        check(borrow.activated == false)

    it "detects borrow conflicts":
        val p = Place.local(0)
        val lt = Lifetime.Named("a")
        val b1 = Borrow(id: 1, place: p, kind: BorrowKind.Shared, lifetime: lt, borrow_point: 10, activated: true)
        val b2 = Borrow(id: 2, place: p, kind: BorrowKind.Mutable, lifetime: lt, borrow_point: 15, activated: true)
        check(b1.conflicts_with(b2) == true)

describe "BorrowSet":
    it "adds borrows":
        var set = BorrowSet.create()
        val p = Place.local(0)
        val lt = Lifetime.Named("a")
        set.add_borrow(p, BorrowKind.Shared, lt, 10)
        check(set.active_borrows().len() == 1)

    it "removes borrows":
        var set = BorrowSet.create()
        val p = Place.local(0)
        val lt = Lifetime.Named("a")
        val borrow = set.add_borrow(p, BorrowKind.Shared, lt, 10)
        set.remove_borrow(borrow.id)
        check(set.active_borrows().len() == 0)

    it "finds conflicting borrows":
        var set = BorrowSet.create()
        val p = Place.local(0)
        val lt = Lifetime.Named("a")
        set.add_borrow(p, BorrowKind.Shared, lt, 10)
        val conflict = set.has_conflicting_borrow(p, BorrowKind.Mutable)
        check(conflict.? == true)

describe "BorrowGraph":
    it "records borrows":
        var graph = BorrowGraph.create()
        val p = Place.local(0)
        val borrow = graph.record_borrow(0, p, BorrowKind.Shared)
        check(borrow.? == true)

    it "detects borrow conflicts":
        var graph = BorrowGraph.create()
        val p = Place.local(0)

        # First: record shared borrow
        val b1 = graph.record_borrow(0, p, BorrowKind.Shared)
        check(b1.? == true)

        # Propagate borrow to next point
        graph.propagate_borrows(0, 1)

        # Second: record mutable borrow at same point
        val b2 = graph.record_borrow(1, p, BorrowKind.Mutable)
        # Should fail and produce error
        check(b2.? == false)
        check(graph.has_errors() == true)

    it "tracks moves":
        var graph = BorrowGraph.create()
        val p = Place.local(0)

        # Move the place
        graph.record_move(0, p)
        graph.propagate_borrows(0, 1)

        # Use after move should produce error
        graph.record_use(1, p)
        check(graph.has_errors() == true)

    it "propagates borrows":
        var graph = BorrowGraph.create()
        val p = Place.local(0)

        # Record borrow at point 0
        graph.record_borrow(0, p, BorrowKind.Shared)

        # Propagate to point 1
        graph.propagate_borrows(0, 1)

        # Check borrow exists at point 1
        val borrows_at_1 = graph.get_or_create_borrows(1)
        check(borrows_at_1.active_borrows().len() == 1)

# ============================================================================
# NLL Tests
# ============================================================================

describe "ControlFlowGraph":
    it "creates basic blocks":
        var cfg = ControlFlowGraph.create()
        var block = BasicBlock.create(0)
        cfg.add_block(block)
        val fetched = cfg.get_block(0)
        check(fetched.? == true)

    it "computes predecessors":
        var cfg = ControlFlowGraph.create()

        # Block A (0) -> Block B (1)
        var block_a = BasicBlock.create(0)
        block_a.set_terminator(Terminator.Goto(1))
        cfg.add_block(block_a)

        var block_b = BasicBlock.create(1)
        block_b.set_terminator(Terminator.Return)
        cfg.add_block(block_b)

        cfg.set_entry(0)
        cfg.compute_predecessors()

        val b = cfg.get_block(1).unwrap()
        check(b.predecessors.len() == 1)
        check(b.predecessors[0] == 0)

    it "computes reverse postorder":
        var cfg = ControlFlowGraph.create()

        var block0 = BasicBlock.create(0)
        block0.set_terminator(Terminator.Goto(1))
        cfg.add_block(block0)

        var block1 = BasicBlock.create(1)
        block1.set_terminator(Terminator.Return)
        cfg.add_block(block1)

        cfg.set_entry(0)

        val order = cfg.reverse_postorder()
        check(order.len() == 2)
        check(order[0] == 0 ) # Entry first)

describe "LivenessAnalysis":
    it "computes live variables":
        var cfg = ControlFlowGraph.create()

        var block = BasicBlock.create(0)
        block.set_terminator(Terminator.Return)
        cfg.add_block(block)
        cfg.set_entry(0)

        var liveness = LivenessAnalysis.create(cfg)
        liveness.record_use(0, 42)  # Variable 42 used in block 0

        val result = liveness.compute()
        val live_in = result.live_in.get(0) ?? []
        check(live_in.contains(42) == true)

describe "NLLChecker":
    it "checks function with no errors":
        var cfg = ControlFlowGraph.create()
        var block = BasicBlock.create(0)
        block.set_terminator(Terminator.Return)
        cfg.add_block(block)
        cfg.set_entry(0)

        var checker = NLLChecker.create(cfg)
        val ok = checker.check()
        check(ok == true)
        check(checker.get_errors().len() == 0)

    it "detects overlapping borrows":
        var cfg = ControlFlowGraph.create()
        var block = BasicBlock.create(0)
        block.set_terminator(Terminator.Return)
        cfg.add_block(block)
        cfg.set_entry(0)

        var checker = NLLChecker.create(cfg)

        val p = Place.local(0)

        # First borrow (shared)
        checker.record_borrow(0, p, BorrowKind.Shared)

        # Second borrow (mutable) - should conflict
        val ok = checker.record_borrow(1, p, BorrowKind.Mutable)

        # Check produces errors (through borrow graph)
        checker.check()
        check(checker.borrow_graph.has_errors() == true)

    it "allows non-overlapping borrows":
        var cfg = ControlFlowGraph.create()
        var block = BasicBlock.create(0)
        block.set_terminator(Terminator.Return)
        cfg.add_block(block)
        cfg.set_entry(0)

        var checker = NLLChecker.create(cfg)

        # Borrow different places
        val p1 = Place.local(0)
        val p2 = Place.local(1)

        checker.record_borrow(0, p1, BorrowKind.Mutable)
        checker.record_borrow(1, p2, BorrowKind.Mutable)

        val ok = checker.check()
        check(ok == true)

    it "formats errors helpfully":
        val err = NLLError.borrow_conflict(
            Borrow(id: 1, place: Place.local(0), kind: BorrowKind.Shared, lifetime: Lifetime.Named("a"), borrow_point: 10, activated: true),
            Borrow(id: 2, place: Place.local(0), kind: BorrowKind.Mutable, lifetime: Lifetime.Named("b"), borrow_point: 5, activated: true)
        )
        check(err.message.contains("cannot borrow") == true)
        check(err.help.? == true)

# ============================================================================
# Integration Tests
# ============================================================================

describe "BorrowChecker":
    it "checks empty function":
        var checker = BorrowChecker(errors: [], checked_functions: [])
        # Create minimal MIR body
        use compiler.mir_data.*

        val body = MirBody(
            name: "test_fn",
            blocks: [],
            locals: [],
            arg_count: 0,
            return_ty: MirType.unit()
        )

        val result = checker.check_function(body)
        check(result.is_ok() == true)

    it "collects checked functions":
        var checker = BorrowChecker(errors: [], checked_functions: [])
        use compiler.mir_data.*

        val body = MirBody(
            name: "test_fn",
            blocks: [],
            locals: [],
            arg_count: 0,
            return_ty: MirType.unit()
        )

        checker.check_function(body)
        check(checker.checked_functions.len() == 1)
        check(checker.checked_functions[0] == "test_fn")

# ============================================================================
# Error Message Tests
# ============================================================================

describe "error messages":
    it "explains borrow conflicts":
        val b1 = Borrow(id: 1, place: Place.local(0), kind: BorrowKind.Mutable, lifetime: Lifetime.Named("a"), borrow_point: 10, activated: true)
        val b2 = Borrow(id: 2, place: Place.local(0), kind: BorrowKind.Shared, lifetime: Lifetime.Named("b"), borrow_point: 5, activated: true)
        val err = NLLError.borrow_conflict(b1, b2)
        check(err.message.contains("cannot borrow") == true)
        check(err.message.contains("&mut") == true)

    it "shows borrow locations":
        val b1 = Borrow(id: 1, place: Place.local(0), kind: BorrowKind.Mutable, lifetime: Lifetime.Named("a"), borrow_point: 10, activated: true)
        val b2 = Borrow(id: 2, place: Place.local(0), kind: BorrowKind.Shared, lifetime: Lifetime.Named("b"), borrow_point: 5, activated: true)
        val err = NLLError.borrow_conflict(b1, b2)
        check(err.primary_span.? == true)
        check(err.secondary_spans.len() > 0)

    it "provides help suggestions":
        val b1 = Borrow(id: 1, place: Place.local(0), kind: BorrowKind.Mutable, lifetime: Lifetime.Named("a"), borrow_point: 10, activated: true)
        val b2 = Borrow(id: 2, place: Place.local(0), kind: BorrowKind.Shared, lifetime: Lifetime.Named("b"), borrow_point: 5, activated: true)
        val err = NLLError.borrow_conflict(b1, b2)
        check(err.help.? == true)
        check(err.help.unwrap().contains("consider") == true)

# ============================================================================
# Exports
# ============================================================================

export describe
