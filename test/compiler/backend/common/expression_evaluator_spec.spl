# Expression Evaluator Specification
#
# Tests for the shared ExpressionEvaluator base class.
# Ensures consistent expression evaluation patterns across backends.

# @skip - Uses unsupported keyword: with
"""
# Expression Evaluator Specification

**Feature ID**: #backend-expression-eval
**Category**: Backend
**Status**: In Progress

The ExpressionEvaluator base class provides template methods for expression
evaluation, reducing duplication and ensuring consistent semantics across
all backends that extend it.

## Related Files
- `src/compiler/backend/common/expression_evaluator.spl` - Base class
- `src/compiler/backend/interpreter.spl` - InterpreterBackend extends it
"""

use compiler.backend.common.expression_evaluator.*
use compiler.backend.common.literal_converter.*
use compiler.backend_types.*
use compiler.hir.*
use testing.helpers.*

describe "ExpressionEvaluator Base Class":
    """
    Tests for the abstract base class providing common evaluation logic.
    """

    context "literal evaluation (shared logic)":
        it "evaluates integer literal":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.int_lit(42)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_int()
            expect result.as_int() == 42

        it "evaluates string literal":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.string_lit("hello")
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_string()
            expect result.as_string() == "hello"

        it "evaluates float literal":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.float_lit(3.14)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_float()
            expect (result.as_float() - 3.14).abs() < 0.001

        it "evaluates boolean literal":
            val evaluator = TestExpressionEvaluator.create()
            val expr_true = HirExpr.bool_lit(true)
            val expr_false = HirExpr.bool_lit(false)
            val ctx = EvalContext.create()

            val result_true = evaluator.eval_expr(expr_true, ctx)?
            val result_false = evaluator.eval_expr(expr_false, ctx)?

            expect result_true.as_bool() == true
            expect result_false.as_bool() == false

        it "evaluates nil literal":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.nil_lit()
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_nil()

    context "array literal evaluation (shared logic)":
        it "evaluates empty array":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.array_lit([])
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_array()
            expect result.as_array().length == 0

        it "evaluates array of literals":
            val evaluator = TestExpressionEvaluator.create()
            val elements = [
                HirExpr.int_lit(1),
                HirExpr.int_lit(2),
                HirExpr.int_lit(3)
            ]
            val expr = HirExpr.array_lit(elements)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_array()
            val arr = result.as_array()
            expect arr.length == 3
            expect arr[0].as_int() == 1
            expect arr[1].as_int() == 2
            expect arr[2].as_int() == 3

        it "evaluates nested arrays":
            val evaluator = TestExpressionEvaluator.create()
            val inner = HirExpr.array_lit([HirExpr.int_lit(1)])
            val outer = HirExpr.array_lit([inner])
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(outer, ctx)?

            expect result.is_array()
            expect result.as_array().length == 1
            expect result.as_array()[0].is_array()

        it "evaluates array with mixed types":
            val evaluator = TestExpressionEvaluator.create()
            val elements = [
                HirExpr.int_lit(42),
                HirExpr.string_lit("test"),
                HirExpr.bool_lit(true)
            ]
            val expr = HirExpr.array_lit(elements)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_array()
            val arr = result.as_array()
            expect arr[0].is_int()
            expect arr[1].is_string()
            expect arr[2].is_bool()

    context "tuple literal evaluation (shared logic)":
        it "evaluates empty tuple":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.tuple_lit([])
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_tuple()
            expect result.as_tuple().length == 0

        it "evaluates pair tuple":
            val evaluator = TestExpressionEvaluator.create()
            val elements = [
                HirExpr.int_lit(1),
                HirExpr.string_lit("one")
            ]
            val expr = HirExpr.tuple_lit(elements)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_tuple()
            val tup = result.as_tuple()
            expect tup.length == 2
            expect tup[0].as_int() == 1
            expect tup[1].as_string() == "one"

        it "evaluates triple tuple":
            val evaluator = TestExpressionEvaluator.create()
            val elements = [
                HirExpr.int_lit(10),
                HirExpr.float_lit(3.14),
                HirExpr.bool_lit(false)
            ]
            val expr = HirExpr.tuple_lit(elements)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_tuple()
            expect result.as_tuple().length == 3

    context "dict literal evaluation (shared logic)":
        it "evaluates empty dict":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.dict_lit([])
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_dict()
            expect result.as_dict().size() == 0

        it "evaluates dict with string keys":
            val evaluator = TestExpressionEvaluator.create()
            val pairs = [
                (HirExpr.string_lit("name"), HirExpr.string_lit("Alice")),
                (HirExpr.string_lit("age"), HirExpr.int_lit(30))
            ]
            val expr = HirExpr.dict_lit(pairs)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_dict()
            val dict = result.as_dict()
            expect dict.size() == 2

            val name_key = LiteralConverter.convert_string("name")
            expect dict[name_key].as_string() == "Alice"

        it "evaluates dict with int keys":
            val evaluator = TestExpressionEvaluator.create()
            val pairs = [
                (HirExpr.int_lit(1), HirExpr.string_lit("one")),
                (HirExpr.int_lit(2), HirExpr.string_lit("two"))
            ]
            val expr = HirExpr.dict_lit(pairs)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.is_dict()
            expect result.as_dict().size() == 2

    context "binary operation delegation":
        it "delegates binary ops to backend":
            val evaluator = TestExpressionEvaluator.create()
            val left = HirExpr.int_lit(5)
            val right = HirExpr.int_lit(3)
            val expr = HirExpr.binary_op(BinaryOp.Add, left, right)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            # TestExpressionEvaluator implements default add
            expect result.as_int() == 8

        it "evaluates nested binary ops":
            val evaluator = TestExpressionEvaluator.create()
            # (5 + 3) * 2
            val inner = HirExpr.binary_op(
                BinaryOp.Add,
                HirExpr.int_lit(5),
                HirExpr.int_lit(3)
            )
            val outer = HirExpr.binary_op(
                BinaryOp.Mul,
                inner,
                HirExpr.int_lit(2)
            )
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(outer, ctx)?

            expect result.as_int() == 16

    context "unary operation delegation":
        it "delegates unary ops to backend":
            val evaluator = TestExpressionEvaluator.create()
            val operand = HirExpr.int_lit(5)
            val expr = HirExpr.unary_op(UnaryOp.Neg, operand)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.as_int() == -5

        it "evaluates boolean not":
            val evaluator = TestExpressionEvaluator.create()
            val operand = HirExpr.bool_lit(true)
            val expr = HirExpr.unary_op(UnaryOp.Not, operand)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.as_bool() == false

    context "template method pattern":
        it "calls literal handlers before delegation":
            val evaluator = CountingEvaluator.create()
            val expr = HirExpr.int_lit(42)
            val ctx = EvalContext.create()

            val _ = evaluator.eval_expr(expr, ctx)?

            # Literal should be handled by base class, not delegated
            expect evaluator.delegation_count == 0

        it "delegates non-literals to backend":
            val evaluator = CountingEvaluator.create()
            val expr = HirExpr.var_ref("x")
            val ctx = EvalContext.create()
            ctx.env.define("x", LiteralConverter.convert_int(42, nil))

            val _ = evaluator.eval_expr(expr, ctx)?

            # Variable reference should be delegated
            expect evaluator.delegation_count == 1

    context "error propagation":
        it "propagates errors from element evaluation":
            val evaluator = ErrorThrowingEvaluator.create()
            val bad_expr = HirExpr.var_ref("undefined")
            val elements = [HirExpr.int_lit(1), bad_expr]
            val expr = HirExpr.array_lit(elements)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)

            expect result.is_err()

        it "provides helpful error context":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.var_ref("undefined")
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)

            expect result.is_err()
            val error = result.err()
            expect error.message.contains("undefined")

describe "Default Binary Operation Implementations":
    """
    Tests for the default binary op implementations in base class.
    """

    context "arithmetic operations":
        it "implements default add":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.binary_op(
                BinaryOp.Add,
                HirExpr.int_lit(10),
                HirExpr.int_lit(5)
            )
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.as_int() == 15

        it "implements default sub":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.binary_op(
                BinaryOp.Sub,
                HirExpr.int_lit(10),
                HirExpr.int_lit(5)
            )
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.as_int() == 5

        it "implements default mul":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.binary_op(
                BinaryOp.Mul,
                HirExpr.int_lit(10),
                HirExpr.int_lit(5)
            )
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.as_int() == 50

        it "implements default div":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.binary_op(
                BinaryOp.Div,
                HirExpr.int_lit(10),
                HirExpr.int_lit(5)
            )
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.as_int() == 2

    context "comparison operations":
        it "implements default equality":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.binary_op(
                BinaryOp.Eq,
                HirExpr.int_lit(5),
                HirExpr.int_lit(5)
            )
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.as_bool() == true

        it "implements default less-than":
            val evaluator = TestExpressionEvaluator.create()
            val expr = HirExpr.binary_op(
                BinaryOp.Lt,
                HirExpr.int_lit(3),
                HirExpr.int_lit(5)
            )
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.as_bool() == true

describe "Backend Extension Points":
    """
    Tests for how backends can extend/override evaluation.
    """

    context "overriding eval_expr_impl":
        it "allows backend to handle custom cases":
            val evaluator = CustomBackendEvaluator.create()
            val expr = HirExpr.custom("special")
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            # Custom backend handles this special case
            expect result.is_string()
            expect result.as_string() == "custom_handled"

        it "backend can call super for shared logic":
            val evaluator = CustomBackendEvaluator.create()
            val expr = HirExpr.int_lit(42)
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            # Falls back to base class literal handling
            expect result.as_int() == 42

    context "overriding binary operation":
        it "allows backend-specific optimization":
            val evaluator = OptimizingEvaluator.create()
            # 0 * x should be optimized to 0 without evaluating x
            val expr = HirExpr.binary_op(
                BinaryOp.Mul,
                HirExpr.int_lit(0),
                HirExpr.expensive_computation()
            )
            val ctx = EvalContext.create()

            val result = evaluator.eval_expr(expr, ctx)?

            expect result.as_int() == 0
            expect evaluator.expensive_computation_called == false

describe "ExpressionEvaluator Performance":
    """
    Performance characteristics of shared evaluation logic.
    """

    slow_it "evaluates 10k literals efficiently":
        val evaluator = TestExpressionEvaluator.create()
        val ctx = EvalContext.create()

        val start = time_now()
        for i in 0..10000:
            val expr = HirExpr.int_lit(i)
            val _ = evaluator.eval_expr(expr, ctx)?
        val elapsed = time_elapsed(start)

        # Should be fast (< 200ms for 10k literals)
        expect elapsed < 200

    slow_it "evaluates nested expressions efficiently":
        val evaluator = TestExpressionEvaluator.create()
        val ctx = EvalContext.create()

        # Create deeply nested expression: ((((1 + 2) + 3) + 4) + ...)
        var expr = HirExpr.int_lit(1)
        for i in 2..100:
            expr = HirExpr.binary_op(
                BinaryOp.Add,
                expr,
                HirExpr.int_lit(i)
            )

        val start = time_now()
        val result = evaluator.eval_expr(expr, ctx)?
        val elapsed = time_elapsed(start)

        # Should be fast (< 10ms)
        expect elapsed < 10
        expect result.as_int() == 5050  # Sum of 1..100

# ============================================================================
# Test Helper Classes
# ============================================================================

class TestExpressionEvaluator extends ExpressionEvaluator:
    """Test implementation with default behavior."""

impl TestExpressionEvaluator:
    static fn create() -> TestExpressionEvaluator:
        TestExpressionEvaluator()

    me eval_expr_impl(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        # Simple implementation for testing
        match expr.kind:
            case VarRef(name, _):
                ctx.env.lookup(name)
            case _:
                Err(BackendError.NotImplemented("expr type not handled"))

class CountingEvaluator extends ExpressionEvaluator:
    """Counts how many times delegation occurs."""
    delegation_count: i64

impl CountingEvaluator:
    static fn create() -> CountingEvaluator:
        CountingEvaluator(delegation_count: 0)

    me eval_expr_impl(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        self.delegation_count = self.delegation_count + 1
        TestExpressionEvaluator.create().eval_expr_impl(expr, ctx)

class ErrorThrowingEvaluator extends ExpressionEvaluator:
    """Always errors on undefined variables."""

impl ErrorThrowingEvaluator:
    static fn create() -> ErrorThrowingEvaluator:
        ErrorThrowingEvaluator()

    me eval_expr_impl(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        Err(BackendError.RuntimeError("undefined variable", expr.span))

class CustomBackendEvaluator extends ExpressionEvaluator:
    """Custom backend with special handling."""

impl CustomBackendEvaluator:
    static fn create() -> CustomBackendEvaluator:
        CustomBackendEvaluator()

    me eval_expr_impl(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        match expr.kind:
            case Custom(tag):
                Ok(LiteralConverter.convert_string("custom_handled"))
            case _:
                # Delegate to default
                TestExpressionEvaluator.create().eval_expr_impl(expr, ctx)

class OptimizingEvaluator extends ExpressionEvaluator:
    """Backend with optimizations."""
    expensive_computation_called: bool

impl OptimizingEvaluator:
    static fn create() -> OptimizingEvaluator:
        OptimizingEvaluator(expensive_computation_called: false)

    me eval_binary_op(op: BinaryOp, left: HirExpr, right: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        # Optimize: 0 * x = 0
        if op == BinaryOp.Mul:
            if val IntLit(0, _) = left.kind:
                return Ok(LiteralConverter.convert_int(0, nil))

        # Fallback to default
        ExpressionEvaluator.eval_binary_op(op, left, right, ctx)
