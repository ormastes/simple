# Differential Backend Consistency Specification
#
# Tests that ensure Cranelift and LLVM backends produce equivalent results
# for the same input programs. This is critical for correctness.

"""
# Differential Backend Consistency Specification

**Feature ID**: #backend-differential-testing
**Category**: Backend
**Status**: In Progress

Differential testing validates that different backends (Cranelift, LLVM,
Interpreter) produce equivalent results for the same input. This catches
subtle semantic differences and ensures correctness.

## Test Strategy
1. **Semantic Equivalence**: Same input â†’ same output across backends
2. **Numeric Consistency**: Floating-point ops produce consistent results
3. **Memory Consistency**: Same memory layout and access patterns
4. **Error Consistency**: Same errors at same locations

## Related Files
- `src/compiler/backend/llvm_backend.spl` - LLVM backend
- `src/compiler/backend/cranelift_backend.spl` - Cranelift backend
- `src/compiler/backend/interpreter.spl` - Interpreter backend
"""

use compiler.backend.llvm_backend.*
use compiler.backend.cranelift_backend.*
use compiler.backend.interpreter.*
use compiler.backend.backend_factory.*
use compiler.mir_data.*
use testing.helpers.*

describe "Backend Differential Testing":
    """
    Cross-backend consistency validation.
    """

    context "arithmetic operations":
        it "all backends agree on integer addition":
            val program = """
                fn main() -> i64:
                    val a = 10
                    val b = 5
                    a + b
            """

            val cranelift_result = compile_and_run(program, BackendKind.Cranelift)
            val llvm_result = compile_and_run(program, BackendKind.Llvm)
            val interp_result = compile_and_run(program, BackendKind.Interpreter)

            expect cranelift_result == 15
            expect llvm_result == 15
            expect interp_result == 15

        it "all backends agree on integer subtraction":
            val program = """
                fn main() -> i64:
                    val a = 10
                    val b = 3
                    a - b
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 7)

        it "all backends agree on integer multiplication":
            val program = """
                fn main() -> i64:
                    val a = 7
                    val b = 6
                    a * b
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 42)

        it "all backends agree on integer division":
            val program = """
                fn main() -> i64:
                    val a = 20
                    val b = 4
                    a / b
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 5)

        it "all backends agree on modulo":
            val program = """
                fn main() -> i64:
                    val a = 17
                    val b = 5
                    a % b
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 2)

        it "all backends agree on negative numbers":
            val program = """
                fn main() -> i64:
                    val a = -10
                    val b = 3
                    a + b
            """

            val results = run_all_backends(program)
            expect_all_equal(results, -7)

    context "floating-point operations":
        it "all backends agree on float addition (within epsilon)":
            val program = """
                fn main() -> f64:
                    val a = 3.14
                    val b = 2.71
                    a + b
            """

            val results = run_all_backends(program)
            expect_all_float_equal(results, 5.85, epsilon: 0.0001)

        it "all backends agree on float multiplication":
            val program = """
                fn main() -> f64:
                    val a = 2.5
                    val b = 4.0
                    a * b
            """

            val results = run_all_backends(program)
            expect_all_float_equal(results, 10.0, epsilon: 0.0001)

        it "all backends handle infinity consistently":
            val program = """
                fn main() -> f64:
                    val a = 1.0 / 0.0  # Positive infinity
                    a
            """

            val cranelift_result = compile_and_run(program, BackendKind.Cranelift)
            val llvm_result = compile_and_run(program, BackendKind.Llvm)

            expect cranelift_result.is_infinite()
            expect llvm_result.is_infinite()

        it "all backends handle NaN consistently":
            val program = """
                fn main() -> f64:
                    val a = 0.0 / 0.0  # NaN
                    a
            """

            val cranelift_result = compile_and_run(program, BackendKind.Cranelift)
            val llvm_result = compile_and_run(program, BackendKind.Llvm)

            expect cranelift_result.is_nan()
            expect llvm_result.is_nan()

    context "comparison operations":
        it "all backends agree on integer equality":
            val program = """
                fn main() -> bool:
                    val a = 5
                    val b = 5
                    a == b
            """

            val results = run_all_backends(program)
            expect_all_equal(results, true)

        it "all backends agree on integer inequality":
            val program = """
                fn main() -> bool:
                    val a = 5
                    val b = 3
                    a != b
            """

            val results = run_all_backends(program)
            expect_all_equal(results, true)

        it "all backends agree on less-than":
            val program = """
                fn main() -> bool:
                    val a = 3
                    val b = 5
                    a < b
            """

            val results = run_all_backends(program)
            expect_all_equal(results, true)

        it "all backends agree on greater-than":
            val program = """
                fn main() -> bool:
                    val a = 7
                    val b = 3
                    a > b
            """

            val results = run_all_backends(program)
            expect_all_equal(results, true)

    context "control flow":
        it "all backends agree on if-else":
            val program = """
                fn main() -> i64:
                    val x = 10
                    if x > 5:
                        x * 2
                    else:
                        x + 5
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 20)

        it "all backends agree on nested if-else":
            val program = """
                fn main() -> i64:
                    val x = 15
                    if x > 20:
                        100
                    elif x > 10:
                        50
                    elif x > 5:
                        25
                    else:
                        0
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 50)

        it "all backends agree on while loop":
            val program = """
                fn main() -> i64:
                    var sum = 0
                    var i = 1
                    while i <= 10:
                        sum = sum + i
                        i = i + 1
                    sum
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 55)  # Sum of 1..10

        it "all backends agree on for loop":
            val program = """
                fn main() -> i64:
                    var sum = 0
                    for i in 0..10:
                        sum = sum + i
                    sum
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 45)  # Sum of 0..9

    context "function calls":
        it "all backends agree on simple function call":
            val program = """
                fn double(x: i64) -> i64:
                    x * 2

                fn main() -> i64:
                    double(21)
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 42)

        it "all backends agree on recursive function":
            val program = """
                fn factorial(n: i64) -> i64:
                    if n <= 1:
                        1
                    else:
                        n * factorial(n - 1)

                fn main() -> i64:
                    factorial(5)
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 120)

        it "all backends agree on multiple parameters":
            val program = """
                fn add(a: i64, b: i64, c: i64) -> i64:
                    a + b + c

                fn main() -> i64:
                    add(10, 20, 30)
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 60)

    context "data structures":
        it "all backends agree on array creation and access":
            val program = """
                fn main() -> i64:
                    val arr = [1, 2, 3, 4, 5]
                    arr[2]
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 3)

        it "all backends agree on array length":
            val program = """
                fn main() -> i64:
                    val arr = [10, 20, 30]
                    arr.length
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 3)

        it "all backends agree on tuple access":
            val program = """
                fn main() -> i64:
                    val tup = (10, 20, 30)
                    tup.1
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 20)

        it "all backends agree on dict operations":
            val program = """
                fn main() -> i64:
                    val dict = {"a": 10, "b": 20}
                    dict["a"]
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 10)

    context "pattern matching":
        it "all backends agree on simple match":
            val program = """
                fn main() -> i64:
                    val x = 2
                    match x:
                        case 1: 10
                        case 2: 20
                        case _: 30
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 20)

        it "all backends agree on match with guard":
            val program = """
                fn main() -> i64:
                    val x = 15
                    match x:
                        case n if n < 10: 1
                        case n if n < 20: 2
                        case _: 3
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 2)

    context "closures and captures":
        it "all backends agree on simple closure":
            val program = """
                fn main() -> i64:
                    val x = 10
                    val f = \y: x + y
                    f(5)
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 15)

        it "all backends agree on closure with mutable capture":
            val program = """
                fn main() -> i64:
                    var counter = 0
                    val inc = \:
                        counter = counter + 1
                        counter
                    inc()
                    inc()
                    inc()
            """

            val results = run_all_backends(program)
            expect_all_equal(results, 3)

    context "error handling":
        it "all backends agree on division by zero error":
            val program = """
                fn main() -> i64:
                    val a = 10
                    val b = 0
                    a / b
            """

            val cranelift_result = try_compile_and_run(program, BackendKind.Cranelift)
            val llvm_result = try_compile_and_run(program, BackendKind.Llvm)
            val interp_result = try_compile_and_run(program, BackendKind.Interpreter)

            expect cranelift_result.is_err()
            expect llvm_result.is_err()
            expect interp_result.is_err()

            # All should report division by zero
            expect cranelift_result.err().contains("division by zero")
            expect llvm_result.err().contains("division by zero")
            expect interp_result.err().contains("division by zero")

        it "all backends agree on array index out of bounds":
            val program = """
                fn main() -> i64:
                    val arr = [1, 2, 3]
                    arr[10]
            """

            val results = try_all_backends(program)
            expect_all_error(results, "out of bounds")

    context "complex expressions":
        it "all backends agree on complex arithmetic":
            val program = """
                fn main() -> i64:
                    val a = 10
                    val b = 5
                    val c = 3
                    (a + b) * c - (a / b) + (b % c)
            """

            val results = run_all_backends(program)
            # (10+5)*3 - (10/5) + (5%3) = 45 - 2 + 2 = 45
            expect_all_equal(results, 45)

        it "all backends agree on nested function calls":
            val program = """
                fn add(a: i64, b: i64) -> i64:
                    a + b

                fn mul(a: i64, b: i64) -> i64:
                    a * b

                fn main() -> i64:
                    mul(add(2, 3), add(4, 5))
            """

            val results = run_all_backends(program)
            # mul(add(2,3), add(4,5)) = mul(5, 9) = 45
            expect_all_equal(results, 45)

describe "Backend Performance Comparison":
    """
    Compare performance characteristics across backends.
    """

    slow_it "Cranelift compiles faster than LLVM":
        val program = """
            fn main() -> i64:
                var sum = 0
                for i in 0..100:
                    sum = sum + i
                sum
        """

        val cranelift_time = measure_compile_time(program, BackendKind.Cranelift)
        val llvm_time = measure_compile_time(program, BackendKind.LLVM)

        # Cranelift should be faster (2-3x)
        expect cranelift_time < llvm_time

    slow_it "LLVM generates faster code than Cranelift":
        val program = """
            fn main() -> i64:
                var sum = 0
                for i in 0..100000:
                    sum = sum + i
                sum
        """

        val cranelift_exec_time = measure_execution_time(program, BackendKind.Cranelift)
        val llvm_exec_time = measure_execution_time(program, BackendKind.Llvm)

        # LLVM code should be faster (10-30%)
        expect llvm_exec_time < cranelift_exec_time

describe "Backend Feature Parity":
    """
    Ensure all backends support same features.
    """

    context "type support":
        it "all backends support all primitive types":
            val types = [
                "i64", "i32", "i16", "i8",
                "f64", "f32",
                "bool", "text"
            ]

            for ty in types:
                val program = "fn main() -> {ty}: default()"
                val results = try_all_backends(program)
                expect_all_succeed(results)

    context "operation support":
        it "all backends support all binary operations":
            val ops = ["+", "-", "*", "/", "%", "==", "!=", "<", "<=", ">", ">="]

            for op in ops:
                val program = """
                    fn main() -> bool:
                        val a = 10
                        val b = 5
                        (a {op} b).?
                """
                val results = try_all_backends(program)
                expect_all_succeed(results)

# ============================================================================
# Test Helper Functions
# ============================================================================

fn run_all_backends(program: text) -> Dict<BackendKind, Value>:
    """Run program on all backends and collect results."""
    val backends = [
        BackendKind.Cranelift,
        BackendKind.Llvm,
        BackendKind.Interpreter
    ]

    var results: Dict<BackendKind, Value> = {}
    for backend in backends:
        val result = compile_and_run(program, backend)
        results[backend] = result

    results

fn try_all_backends(program: text) -> Dict<BackendKind, Result<Value, Error>>:
    """Try running program on all backends, capturing errors."""
    val backends = [
        BackendKind.Cranelift,
        BackendKind.Llvm,
        BackendKind.Interpreter
    ]

    var results: Dict<BackendKind, Result<Value, Error>> = {}
    for backend in backends:
        val result = try_compile_and_run(program, backend)
        results[backend] = result

    results

fn expect_all_equal(results: Dict<BackendKind, Value>, expected: Value):
    """Assert all backend results equal expected value."""
    for backend, result in results:
        val msg = "Backend {backend} produced {result}, expected {expected}"
        expect(result == expected, msg)

fn expect_all_float_equal(results: Dict<BackendKind, f64>, expected: f64, epsilon: f64):
    """Assert all backend float results within epsilon of expected."""
    for backend, result in results:
        val diff = (result - expected).abs()
        val msg = "Backend {backend} produced {result}, expected {expected} (epsilon {epsilon})"
        expect(diff < epsilon, msg)

fn expect_all_error(results: Dict<BackendKind, Result<Value, Error>>, message_contains: text):
    """Assert all backends produced errors containing message."""
    for backend, result in results:
        val msg1 = "Backend {backend} should have errored but succeeded"
        expect(result.is_err(), msg1)
        val msg2 = "Backend {backend} error message should contain '{message_contains}'"
        expect(result.err().message.contains(message_contains), msg2)

fn expect_all_succeed(results: Dict<BackendKind, Result<Value, Error>>):
    """Assert all backends succeeded."""
    for backend, result in results:
        val msg = "Backend {backend} should succeed but errored: {result.err()}"
        expect(result.is_ok(), msg)

fn measure_compile_time(program: text, backend: BackendKind) -> i64:
    """Measure compilation time in milliseconds."""
    val start = time_now()
    val _ = compile(program, backend)
    time_elapsed(start)

fn measure_execution_time(program: text, backend: BackendKind) -> i64:
    """Measure execution time in milliseconds."""
    val compiled = compile(program, backend)

    val start = time_now()
    val _ = run(compiled)
    time_elapsed(start)
