"""
# Backend Orchestration FFI Connection Test

Quick test to verify Simple orchestration modules connect properly to Rust FFI.
"""

use sspec.{describe, it, expect}
use compiler.backend.backend_selector.{
    BackendOptions,
    BackendSelector,
    TargetArch,
    BackendKind,
    OptimizationLevel
}
use compiler.backend.optimization_passes.{
    PassRegistry
}
use compiler.backend.codegen_errors.{
    CodegenError,
    CodegenErrorKind
}

describe "Backend Orchestration FFI"
    """Test FFI connections work correctly."""

    it "creates backend options with PIC setting"
        val opts = BackendOptions.aot("output.o")
        expect opts.is_pic == true

    it "detects host target via FFI"
        val opts = BackendOptions.jit()
        val selector = BackendSelector.new(opts)
        val code = selector.target_code()

        # Should return valid target code
        expect code >= 0
        expect code <= 2

    it "returns correct optimization level strings"
        val speed_opts = BackendOptions.jit()
        val speed_selector = BackendSelector.new(speed_opts)
        expect speed_selector.optimization_level_string() == "speed"

    it "enables passes and returns success"
        var registry = PassRegistry.for_level(OptimizationLevel.Speed)
        val result = registry.enable_pass("constant_folding")
        expect result == true

    it "returns false for nonexistent pass"
        var registry = PassRegistry.for_level(OptimizationLevel.Speed)
        val result = registry.enable_pass("nonexistent")
        expect result == false

    it "creates codegen errors with context"
        val err = CodegenError.function_compile("main", "failed")
        expect err.kind == CodegenErrorKind.FunctionCompileFailed
        expect err.function_name.? == true

    it "formats errors correctly"
        val err = CodegenError.module_init("init failed")
        val formatted = err.format()
        expect formatted.contains("Codegen Error")
        expect formatted.contains("init failed")
