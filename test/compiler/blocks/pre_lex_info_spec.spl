"""
Feature: PreLexInfo Data Types and Helper Methods
Feature ID: #1090
Category: Compiler
Status: In Progress
Priority: P0

## Overview

PreLexInfo holds pre-scanning information (strings, comments, escapes, brace pairs)
collected by the main lexer during Tier 1/2 brace tracking. This data is shared with
block handlers so they can correctly parse DSL payloads without re-scanning for
strings and comments.

## Concepts

- **TextSpan**: Byte range (start, end) within a payload
- **PreLexInfo**: Aggregation of string spans, comment spans, escape positions, brace pairs
- **is_protected()**: Unified check for string/comment/escape regions
"""

import std.spec
use blocks.modes.{TextSpan, PreLexInfo}

# ============================================================================
# TextSpan Tests
# ============================================================================

describe "TextSpan":
    context "construction":
        it "creates span with direct construction":
            val span = TextSpan(start: 5, end: 12)
            expect(span.start).to(eq(5))
            expect(span.end).to(eq(12))

        it "creates span with factory method":
            val span = TextSpan.new(0, 100)
            expect(span.start).to(eq(0))
            expect(span.end).to(eq(100))

        it "creates zero-length span":
            val span = TextSpan(start: 5, end: 5)
            expect(span.len()).to(eq(0))

    context "len()":
        it "returns correct length for non-empty span":
            val span = TextSpan(start: 3, end: 10)
            expect(span.len()).to(eq(7))

        it "returns zero for empty span":
            val span = TextSpan(start: 0, end: 0)
            expect(span.len()).to(eq(0))

        it "returns 1 for single-char span":
            val span = TextSpan(start: 5, end: 6)
            expect(span.len()).to(eq(1))

        it "handles large spans":
            val span = TextSpan(start: 0, end: 100000)
            expect(span.len()).to(eq(100000))

    context "contains()":
        it "returns true for position at start":
            val span = TextSpan(start: 5, end: 10)
            expect(span.contains(5)).to(be_true())

        it "returns false for position at end (exclusive)":
            val span = TextSpan(start: 5, end: 10)
            expect(span.contains(10)).to(be_false())

        it "returns true for position in middle":
            val span = TextSpan(start: 5, end: 10)
            expect(span.contains(7)).to(be_true())

        it "returns false for position before start":
            val span = TextSpan(start: 5, end: 10)
            expect(span.contains(4)).to(be_false())

        it "returns false for position well after end":
            val span = TextSpan(start: 5, end: 10)
            expect(span.contains(100)).to(be_false())

        it "returns false for zero-length span":
            val span = TextSpan(start: 5, end: 5)
            expect(span.contains(5)).to(be_false())

        it "returns true for single-char span at start":
            val span = TextSpan(start: 5, end: 6)
            expect(span.contains(5)).to(be_true())

        it "returns false for negative position":
            val span = TextSpan(start: 0, end: 10)
            expect(span.contains(-1)).to(be_false())

# ============================================================================
# PreLexInfo Construction Tests
# ============================================================================

describe "PreLexInfo":
    context "empty()":
        it "creates info with no spans":
            val info = PreLexInfo.empty()
            expect(info.string_spans.len()).to(eq(0))
            expect(info.comment_spans.len()).to(eq(0))
            expect(info.escape_positions.len()).to(eq(0))
            expect(info.brace_pairs.len()).to(eq(0))

    context "direct construction":
        it "creates info with string spans":
            val info = PreLexInfo(
                string_spans: [TextSpan(start: 5, end: 12)],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.string_spans.len()).to(eq(1))
            expect(info.string_spans[0].start).to(eq(5))

        it "creates info with multiple string spans":
            val info = PreLexInfo(
                string_spans: [
                    TextSpan(start: 0, end: 5),
                    TextSpan(start: 10, end: 15),
                    TextSpan(start: 20, end: 30)
                ],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.string_spans.len()).to(eq(3))

        it "creates info with comment spans":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan(start: 10, end: 25)],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.comment_spans.len()).to(eq(1))

        it "creates info with escape positions":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [3, 7, 15],
                brace_pairs: []
            )
            expect(info.escape_positions.len()).to(eq(3))

        it "creates info with brace pairs":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: [(0, 10), (2, 5)]
            )
            expect(info.brace_pairs.len()).to(eq(2))

        it "creates info with all fields populated":
            val info = PreLexInfo(
                string_spans: [TextSpan(start: 5, end: 12)],
                comment_spans: [TextSpan(start: 20, end: 30)],
                escape_positions: [4],
                brace_pairs: [(0, 35)]
            )
            expect(info.string_spans.len()).to(eq(1))
            expect(info.comment_spans.len()).to(eq(1))
            expect(info.escape_positions.len()).to(eq(1))
            expect(info.brace_pairs.len()).to(eq(1))

# ============================================================================
# PreLexInfo.is_in_string() Tests
# ============================================================================

describe "PreLexInfo.is_in_string()":
    context "with no string spans":
        it "returns false for any position":
            val info = PreLexInfo.empty()
            expect(info.is_in_string(0)).to(be_false())
            expect(info.is_in_string(5)).to(be_false())
            expect(info.is_in_string(100)).to(be_false())

    context "with one string span":
        it "returns true for position inside span":
            val info = PreLexInfo(
                string_spans: [TextSpan(start: 5, end: 12)],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(5)).to(be_true())
            expect(info.is_in_string(7)).to(be_true())
            expect(info.is_in_string(11)).to(be_true())

        it "returns false for position at end boundary":
            val info = PreLexInfo(
                string_spans: [TextSpan(start: 5, end: 12)],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(12)).to(be_false())

        it "returns false for position before span":
            val info = PreLexInfo(
                string_spans: [TextSpan(start: 5, end: 12)],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(4)).to(be_false())
            expect(info.is_in_string(0)).to(be_false())

        it "returns false for position after span":
            val info = PreLexInfo(
                string_spans: [TextSpan(start: 5, end: 12)],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(13)).to(be_false())
            expect(info.is_in_string(100)).to(be_false())

    context "with multiple non-overlapping string spans":
        it "returns true for positions in any span":
            val info = PreLexInfo(
                string_spans: [
                    TextSpan(start: 0, end: 3),
                    TextSpan(start: 10, end: 15),
                    TextSpan(start: 20, end: 25)
                ],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(1)).to(be_true())
            expect(info.is_in_string(12)).to(be_true())
            expect(info.is_in_string(22)).to(be_true())

        it "returns false for gaps between spans":
            val info = PreLexInfo(
                string_spans: [
                    TextSpan(start: 0, end: 3),
                    TextSpan(start: 10, end: 15)
                ],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(5)).to(be_false())
            expect(info.is_in_string(8)).to(be_false())

    context "with adjacent string spans":
        it "handles spans that touch at boundaries":
            # "abc""def" -> spans [0,5) and [5,10)
            val info = PreLexInfo(
                string_spans: [
                    TextSpan(start: 0, end: 5),
                    TextSpan(start: 5, end: 10)
                ],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_string(4)).to(be_true())
            expect(info.is_in_string(5)).to(be_true())
            expect(info.is_in_string(9)).to(be_true())
            expect(info.is_in_string(10)).to(be_false())

# ============================================================================
# PreLexInfo.is_in_comment() Tests
# ============================================================================

describe "PreLexInfo.is_in_comment()":
    context "with no comment spans":
        it "returns false for any position":
            val info = PreLexInfo.empty()
            expect(info.is_in_comment(0)).to(be_false())
            expect(info.is_in_comment(50)).to(be_false())

    context "with line comment span":
        it "returns true for position inside comment":
            # "x = 1 # comment\n" -> comment at [6, 16)
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan(start: 6, end: 16)],
                escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_comment(6)).to(be_true())
            expect(info.is_in_comment(10)).to(be_true())
            expect(info.is_in_comment(15)).to(be_true())

        it "returns false outside comment":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan(start: 6, end: 16)],
                escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_comment(0)).to(be_false())
            expect(info.is_in_comment(5)).to(be_false())
            expect(info.is_in_comment(16)).to(be_false())

    context "with block comment span":
        it "returns true for positions inside block comment":
            # "x /* comment */ y" -> comment at [2, 15)
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan(start: 2, end: 15)],
                escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_comment(2)).to(be_true())
            expect(info.is_in_comment(5)).to(be_true())
            expect(info.is_in_comment(14)).to(be_true())

    context "with multiple comments":
        it "returns true for any comment region":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [
                    TextSpan(start: 6, end: 16),
                    TextSpan(start: 20, end: 35)
                ],
                escape_positions: [], brace_pairs: []
            )
            expect(info.is_in_comment(10)).to(be_true())
            expect(info.is_in_comment(25)).to(be_true())
            expect(info.is_in_comment(18)).to(be_false())

# ============================================================================
# PreLexInfo.is_escaped() Tests
# ============================================================================

describe "PreLexInfo.is_escaped()":
    context "with no escapes":
        it "returns false for any position":
            val info = PreLexInfo.empty()
            expect(info.is_escaped(0)).to(be_false())
            expect(info.is_escaped(5)).to(be_false())

    context "with escape positions":
        it "returns true when preceded by backslash":
            # Backslash at position 3, so position 4 is escaped
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [3],
                brace_pairs: []
            )
            expect(info.is_escaped(4)).to(be_true())

        it "returns false for the backslash position itself":
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [3],
                brace_pairs: []
            )
            # Position 3 is the backslash, not escaped
            expect(info.is_escaped(3)).to(be_false())

        it "returns false for position not preceded by backslash":
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [3],
                brace_pairs: []
            )
            expect(info.is_escaped(6)).to(be_false())

        it "returns false for position 0 (nothing before it)":
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [0],
                brace_pairs: []
            )
            expect(info.is_escaped(0)).to(be_false())

        it "handles multiple escape positions":
            # \{ \} \n -> backslashes at 0, 3, 6
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [0, 3, 6],
                brace_pairs: []
            )
            expect(info.is_escaped(1)).to(be_true())
            expect(info.is_escaped(4)).to(be_true())
            expect(info.is_escaped(7)).to(be_true())
            expect(info.is_escaped(2)).to(be_false())
            expect(info.is_escaped(5)).to(be_false())

        it "handles consecutive escapes":
            # \\\n -> backslashes at 0, 1  (\\  then \n)
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [0, 2],
                brace_pairs: []
            )
            expect(info.is_escaped(1)).to(be_true())
            expect(info.is_escaped(3)).to(be_true())

# ============================================================================
# PreLexInfo.is_protected() Tests
# ============================================================================

describe "PreLexInfo.is_protected()":
    context "with empty info":
        it "returns false for any position":
            val info = PreLexInfo.empty()
            expect(info.is_protected(0)).to(be_false())
            expect(info.is_protected(50)).to(be_false())

    context "position in string":
        it "returns true":
            val info = PreLexInfo(
                string_spans: [TextSpan(start: 5, end: 12)],
                comment_spans: [], escape_positions: [], brace_pairs: []
            )
            expect(info.is_protected(7)).to(be_true())

    context "position in comment":
        it "returns true":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan(start: 10, end: 20)],
                escape_positions: [], brace_pairs: []
            )
            expect(info.is_protected(15)).to(be_true())

    context "position after escape":
        it "returns true":
            val info = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [5],
                brace_pairs: []
            )
            expect(info.is_protected(6)).to(be_true())

    context "position outside all protected regions":
        it "returns false":
            val info = PreLexInfo(
                string_spans: [TextSpan(start: 5, end: 10)],
                comment_spans: [TextSpan(start: 20, end: 30)],
                escape_positions: [15],
                brace_pairs: []
            )
            expect(info.is_protected(0)).to(be_false())
            expect(info.is_protected(12)).to(be_false())
            expect(info.is_protected(35)).to(be_false())

    context "mixed protected regions":
        it "correctly identifies all region types":
            val info = PreLexInfo(
                string_spans: [TextSpan(start: 0, end: 5)],
                comment_spans: [TextSpan(start: 10, end: 20)],
                escape_positions: [25],
                brace_pairs: [(30, 40)]
            )
            # In string
            expect(info.is_protected(2)).to(be_true())
            # Between string and comment
            expect(info.is_protected(7)).to(be_false())
            # In comment
            expect(info.is_protected(15)).to(be_true())
            # After escape
            expect(info.is_protected(26)).to(be_true())
            # After everything
            expect(info.is_protected(50)).to(be_false())

    context "overlapping string and comment (edge case)":
        it "returns true when in either region":
            val info = PreLexInfo(
                string_spans: [TextSpan(start: 5, end: 15)],
                comment_spans: [TextSpan(start: 10, end: 20)],
                escape_positions: [], brace_pairs: []
            )
            # Only in string
            expect(info.is_protected(7)).to(be_true())
            # In both string and comment
            expect(info.is_protected(12)).to(be_true())
            # Only in comment
            expect(info.is_protected(17)).to(be_true())
            # Outside both
            expect(info.is_protected(3)).to(be_false())
            expect(info.is_protected(22)).to(be_false())
