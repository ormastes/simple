# Utils API Tests - Pre-built Utilities
#
# Tests for compiler.blocks.utils module
# Pre-built parsers, validators, and helpers

use std.test
use compiler.blocks.utils.{
    parse_json, parse_yaml, parse_toml, parse_xml, parse_csv,
    validate_json, validate_regex, validate_sql,
    highlight_keywords, highlight_strings, highlight_comments, highlight_numbers,
    error_at, error_span, errors_from_strings,
    interpolate_variables, strip_indent, normalize_newlines
}
use compiler.blocks.value.{BlockValue}
use compiler.blocks.context.{BlockContext}
use compiler.blocks.modes.{Span}

describe "Utils - Pre-built Parsers":

    it "parses JSON":
        val result = parse_json('{"name": "Alice", "age": 30}')

        assert result.ok.?
        val value = result.unwrap()
        assert value.is_json()

    it "handles invalid JSON":
        val result = parse_json("{invalid json}")

        assert result.err.?
        val error = result.unwrap_err()
        assert error.contains("parse error")

    it "parses YAML":
        val result = parse_yaml("name: Alice\nage: 30")

        assert result.ok.?
        match result.unwrap():
            case Custom("YAML", _):
                pass  # Expected
            case _:
                assert false

    it "parses TOML":
        val result = parse_toml("[section]\nkey = 'value'")

        assert result.ok.?

    it "parses XML":
        val result = parse_xml("<root><item>value</item></root>")

        assert result.ok.?

    it "parses CSV":
        val csv_text = """
name,age,city
Alice,30,NYC
Bob,25,SF
        """.trim()

        val result = parse_csv(csv_text)

        assert result.ok.?
        match result.unwrap():
            case Custom("CSV", _):
                pass  # Expected
            case _:
                assert false

describe "Utils - Pre-built Validators":

    it "validates JSON structure":
        val valid = BlockValue.Json(JsonValue(kind: JsonKind.Null))
        val errors = validate_json(valid)

        assert errors.len() == 0

    it "rejects non-JSON values":
        val invalid = BlockValue.Raw("not json")
        val errors = validate_json(invalid)

        assert errors.len() > 0
        assert errors[0].contains("Expected JSON")

    it "validates regex patterns":
        val valid = BlockValue.Regex(RegexPattern(raw: "^[a-z]+$", _handle: 0))
        val errors = validate_regex(valid)

        assert errors.len() == 0

    it "validates SQL with dialect":
        val query = BlockValue.Sql(SqlQuery(
            raw: "SELECT * FROM users",
            kind: SqlKind.Select,
            tables: ["users"],
            columns: [],
            params: []
        ))

        val ansi_errors = validate_sql(query, dialect: "ansi")
        assert ansi_errors.len() == 0

        val pg_errors = validate_sql(query, dialect: "postgres")
        assert pg_errors.len() == 0

describe "Utils - Syntax Highlighting":

    it "highlights keywords":
        val text = "SELECT name FROM users WHERE age > 21"
        val keywords = ["SELECT", "FROM", "WHERE"]

        val tokens = highlight_keywords(text, keywords)

        assert tokens.len() >= 3
        assert tokens[0].kind == HighlightKind.Keyword

    it "handles case sensitivity in keywords":
        val text = "select FROM where"
        val keywords = ["SELECT", "FROM", "WHERE"]

        val tokens = highlight_keywords(text, keywords)

        # Should find FROM (exact match) but not select/where
        val found_keywords = tokens.filter(\t: t.kind == HighlightKind.Keyword)
        assert found_keywords.len() >= 1

    it "highlights strings":
        val text = 'name = "Alice" and city = "NYC"'

        val tokens = highlight_strings(text)

        val strings = tokens.filter(\t: t.kind == HighlightKind.String)
        assert strings.len() == 2

    it "handles escaped quotes in strings":
        val text = 'text = "She said \\"Hello\\""'

        val tokens = highlight_strings(text)

        val strings = tokens.filter(\t: t.kind == HighlightKind.String)
        assert strings.len() == 1

    it "highlights line comments":
        val text = "code(); // This is a comment\nmore_code();"

        val tokens = highlight_comments(text, line_comment: "//")

        val comments = tokens.filter(\t: t.kind == HighlightKind.Comment)
        assert comments.len() >= 1

    it "highlights block comments":
        val text = "code(); /* This is\na block comment */ more();"

        val tokens = highlight_comments(text,
            line_comment: "//",
            block_comment: ("/*", "*/")
        )

        val comments = tokens.filter(\t: t.kind == HighlightKind.Comment)
        assert comments.len() >= 1

    it "highlights both line and block comments":
        val text = """
// Line comment
code();
/* Block
   comment */
more(); // Another line
        """

        val tokens = highlight_comments(text,
            line_comment: "//",
            block_comment: ("/*", "*/")
        )

        val comments = tokens.filter(\t: t.kind == HighlightKind.Comment)
        assert comments.len() >= 3

    it "highlights numbers":
        val text = "x = 42 + 3.14 - 0x1F"

        val tokens = highlight_numbers(text)

        val numbers = tokens.filter(\t: t.kind == HighlightKind.Number)
        assert numbers.len() == 3

    it "highlights hex numbers":
        val text = "value = 0xFF00AB"

        val tokens = highlight_numbers(text)

        val numbers = tokens.filter(\t: t.kind == HighlightKind.Number)
        assert numbers.len() == 1

    it "highlights floats with exponents":
        val text = "sci = 1.23e-4"

        val tokens = highlight_numbers(text)

        val numbers = tokens.filter(\t: t.kind == HighlightKind.Number)
        assert numbers.len() == 1

describe "Utils - Error Helpers":

    it "creates error at offset":
        val ctx = BlockContext(
            payload: "SELECT * FROM users",
            payload_span: Span(start: 100, end: 119, line: 5, col: 10),
            block_span: Span(start: 95, end: 124, line: 5, col: 5),
            file_path: nil,
            module_name: nil,
            pre_lex_info: nil,
            is_top_level: false,
            parent_block: nil
        )

        val error = error_at(ctx, "Missing semicolon", offset: 19)

        assert error.message == "Missing semicolon"
        assert error.span.?
        assert error.span.unwrap().start == 119  # 100 + 19

    it "creates error for span":
        val ctx = BlockContext.test("SELECT * FROM users")

        val error = error_span(ctx, "Invalid table name", span: (14, 19))

        assert error.message == "Invalid table name"
        assert error.span.?

    it "converts string errors to BlockErrors":
        val ctx = BlockContext.test("test")
        val messages = ["Error 1", "Error 2", "Error 3"]

        val errors = errors_from_strings(ctx, messages)

        assert errors.len() == 3
        assert errors[0].message == "Error 1"
        assert errors[1].message == "Error 2"
        assert errors[2].message == "Error 3"

    it "handles empty error list":
        val ctx = BlockContext.test("test")
        val errors = errors_from_strings(ctx, [])

        assert errors.len() == 0

describe "Utils - Text Transformations":

    it "interpolates variables":
        val template = "Hello {name}, you are {age} years old"
        val vars = {
            "name": "Alice",
            "age": "30"
        }

        val result = interpolate_variables(template, vars)

        assert result == "Hello Alice, you are 30 years old"

    it "handles missing variables":
        val template = "Hello {name}, your {title}"
        val vars = {"name": "Alice"}

        val result = interpolate_variables(template, vars)

        # Missing {title} remains unchanged
        assert result.contains("Alice")
        assert result.contains("{title}")

    it "handles empty variable dict":
        val template = "No variables"
        val vars = {}

        val result = interpolate_variables(template, vars)

        assert result == "No variables"

    it "strips common indent":
        val text = """
            Line 1
            Line 2
                Indented
        """

        val result = strip_indent(text)

        # Common indent should be removed
        assert not result.starts_with(" ")
        assert result.contains("Line 1")

    it "preserves relative indentation":
        val text = """
            Normal
                Indented
            Normal
        """

        val result = strip_indent(text)

        val lines = result.split("\n")
        # Second line should still be indented relative to first
        # (This test assumes strip_indent preserves relative indentation)

    it "handles text with no indent":
        val text = "Line 1\nLine 2"

        val result = strip_indent(text)

        assert result == text

    it "normalizes newlines from Windows":
        val windows = "Line 1\r\nLine 2\r\nLine 3"

        val result = normalize_newlines(windows)

        assert result == "Line 1\nLine 2\nLine 3"
        assert not result.contains("\r")

    it "normalizes newlines from old Mac":
        val old_mac = "Line 1\rLine 2\rLine 3"

        val result = normalize_newlines(old_mac)

        assert result == "Line 1\nLine 2\nLine 3"

    it "handles mixed line endings":
        val mixed = "Line 1\r\nLine 2\rLine 3\nLine 4"

        val result = normalize_newlines(mixed)

        assert result == "Line 1\nLine 2\nLine 3\nLine 4"

describe "Utils - Integration":

    it "combines highlighting functions":
        val code = """
SELECT * FROM users -- Get all users
WHERE age > 30
/* Filter by age */
        """

        val all_tokens = []
            .concat(highlight_keywords(code, ["SELECT", "FROM", "WHERE"]))
            .concat(highlight_comments(code, line_comment: "--", block_comment: ("/*", "*/")))
            .concat(highlight_numbers(code))

        assert all_tokens.len() > 0

    it "combines text transformations":
        val template = """
            Query: {query}
                Result: {result}
        """

        val normalized = normalize_newlines(template)
        val stripped = strip_indent(normalized)
        val interpolated = interpolate_variables(stripped, {
            "query": "SELECT *",
            "result": "42 rows"
        })

        assert interpolated.contains("SELECT *")
        assert interpolated.contains("42 rows")

    it "creates detailed errors with context":
        val payload = "SELECT * FROM users WHERE age > 21"
        val ctx = BlockContext.test(payload)

        # Find "users" position
        val users_pos = payload.index_of("users").unwrap()

        val error = error_span(ctx, "Table 'users' not found", span: (users_pos, users_pos + 5))

        assert error.message.contains("not found")

describe "Utils - Edge Cases":

    it "handles empty strings":
        assert interpolate_variables("", {}) == ""
        assert strip_indent("") == ""
        assert normalize_newlines("") == ""

    it "handles unicode in text":
        val unicode = "Hello ä¸–ç•Œ ğŸŒ"

        val normalized = normalize_newlines(unicode)
        assert normalized.contains("ä¸–ç•Œ")
        assert normalized.contains("ğŸŒ")

    it "handles very long strings":
        val long_text = "x" * 10000

        val normalized = normalize_newlines(long_text)
        assert normalized.len() == 10000

    it "handles special characters in interpolation":
        val template = "Use {var} here"
        val vars = {"var": "Special: {}, [], ()"}

        val result = interpolate_variables(template, vars)

        assert result.contains("Special:")

# ============================================================================
# Feature Tags
# ============================================================================

tags: [compiler, blocks, utils, helpers]
priority: high
status: complete
