# Builder API Tests - Fluent Block Building
#
# Tests for compiler.blocks.builder module
# Tier 2 API: BlockBuilder with fluent interface

# @skip - Uses unsupported keyword: with
use std.test
use compiler.blocks.builder.{BlockBuilder}
use compiler.blocks.value.{BlockValue}
use compiler.blocks.modes.{LexerMode, SyntaxFeatures}
use compiler.blocks.context.{BlockContext}
use compiler.blocks.registry.{with_block}
use compiler.blocks.definition.{ConstValue}
use std.spec.{check, check_msg}

describe "BlockBuilder - Construction":

    it "creates builder with new()":
        val builder = BlockBuilder.new("testblock")

        # Should have defaults
        check(builder._kind == "testblock")
        check(builder._mode.is_raw())  # Default mode
        check(not builder._parser.?) # Parser not set yet

    it "requires parser to be set":
        val builder = BlockBuilder.new("noparser")

        # Should return error when building without parser
        # NOTE: Builder should return Result<BlockDef, text> instead of panicking
        # For now, skip this test until Result pattern is implemented
        check(true)  # Placeholder until builder.build() returns Result

    it "builds successfully with parser":
        val block_def = BlockBuilder.new("simple")
            .simple_parser(\text: Ok(BlockValue.Raw(text)))
            .build()

        check(block_def.kind() == "simple")

describe "BlockBuilder - Lexer Modes":

    it "supports raw_text() shortcut":
        val block_def = BlockBuilder.new("raw")
            .raw_text()
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        check(block_def.lexer_mode().is_raw())

    it "supports math_mode() shortcut":
        val block_def = BlockBuilder.new("math")
            .math_mode()
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        check(block_def.lexer_mode().is_math())

    it "supports normal_mode() shortcut":
        val block_def = BlockBuilder.new("normal")
            .normal_mode()
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        check(block_def.lexer_mode().is_normal())

    it "supports explicit lexer_mode()":
        val block_def = BlockBuilder.new("explicit")
            .lexer_mode(LexerMode.Math)
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        check(block_def.lexer_mode().is_math())

describe "BlockBuilder - Feature Control":

    it "enables individual features":
        val block_def = BlockBuilder.new("feature")
            .enable_feature("power_caret")
            .enable_feature("matrix_mul")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        val features = block_def.syntax_features()
        check(features.power_caret)
        check(features.matrix_mul)
        check(not features.transpose_quote) # Not enabled

    it "disables features":
        val block_def = BlockBuilder.new("disable")
            .enable_all_math()  # Enable all
            .disable_feature("power_caret")  # Then disable one
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        val features = block_def.syntax_features()
        check(not features.power_caret) # Disabled
        check(features.transpose_quote) # Still enabled
        check(features.matrix_mul) # Still enabled

    it "enables all math features with preset":
        val block_def = BlockBuilder.new("allmath")
            .enable_all_math()
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        val features = block_def.syntax_features()
        check(features.power_caret)
        check(features.transpose_quote)
        check(features.implicit_multiplication)
        check(features.broadcast_ops)
        check(features.matrix_mul)

    it "enables pipeline features with preset":
        val block_def = BlockBuilder.new("pipeline")
            .enable_pipelines()
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        val features = block_def.syntax_features()
        check(features.pipe_forward)
        check(features.composition)

    it "enables deep learning features":
        val block_def = BlockBuilder.new("dl")
            .enable_deep_learning()
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        val features = block_def.syntax_features()
        check(features.auto_backward)

describe "BlockBuilder - Parser Configuration":

    it "supports simple_parser with simple signature":
        val block_def = BlockBuilder.new("simple")
            .simple_parser(\text:
                if text.?:
                    Ok(BlockValue.Raw(text))
                else:
                    Err("Empty text")
            )
            .build()

        val ctx = BlockContext.test("hello")
        val result = block_def.parse_payload("hello", ctx)
        check(result.ok.?)

        val ctx2 = BlockContext.test("")
        val result2 = block_def.parse_payload("", ctx2)
        check(result2.err.?)

    it "supports parser with full signature":
        val block_def = BlockBuilder.new("full")
            .parser(\payload, ctx:
                # Can access context
                if ctx.is_top_level:
                    Ok(BlockValue.Custom("TopLevel", payload))
                else:
                    Ok(BlockValue.Custom("Nested", payload))
            )
            .build()

        val ctx = BlockContext.test("test").at_top_level()
        val result = block_def.parse_payload("test", ctx)

        check(result.ok.?)
        match result.unwrap():
            case Custom("TopLevel", _):
                pass  # Expected
            case _:
                check(false)

describe "BlockBuilder - Validation":

    it "supports simple_validator":
        val block_def = BlockBuilder.new("validated")
            .simple_parser(\text:
                val len = text.len()
                Ok(BlockValue.Custom("Text", len))
            )
            .simple_validator(\value:
                match value:
                    case Custom("Text", len):
                        if len < 5:
                            ["Text too short (min 5 chars)"]
                        elif len > 100:
                            ["Text too long (max 100 chars)"]
                        else:
                            []
                    case _:
                        ["Wrong type"]
            )
            .build()

        val ctx = BlockContext.test("")

        # Valid
        val valid = BlockValue.Custom("Text", 10)
        check(block_def.validate(valid, ctx).len() == 0)

        # Too short
        val short = BlockValue.Custom("Text", 3)
        check(block_def.validate(short, ctx).len() == 1)

        # Too long
        val long = BlockValue.Custom("Text", 150)
        check(block_def.validate(long, ctx).len() == 1)

    it "supports validator with full signature":
        val block_def = BlockBuilder.new("fullval")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .validator(\value, ctx:
                # Can use context in validation
                var errors = []
                if ctx.is_top_level and not value.is_raw():
                    errors = errors.push(BlockError.validation("Top-level must be raw"))
                errors
            )
            .build()

        val ctx = BlockContext.test("").at_top_level()
        val errors = block_def.validate(BlockValue.Raw("ok"), ctx)
        check(errors.len() == 0)

    it "has no validation by default":
        val block_def = BlockBuilder.new("noval")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        val ctx = BlockContext.test("")
        val errors = block_def.validate(BlockValue.Raw("test"), ctx)
        check(errors.len() == 0)

describe "BlockBuilder - Compile-Time Evaluation":

    it "supports const_eval":
        val block_def = BlockBuilder.new("const")
            .simple_parser(\t: Ok(BlockValue.Custom("Const", t)))
            .const_eval(\value:
                match value:
                    case Custom("Const", "42"):
                        Some(ConstValue.Int(42))
                    case Custom("Const", "true"):
                        Some(ConstValue.Bool(true))
                    case _:
                        nil
            )
            .build()

        # Evaluates to const
        val const_val = block_def.eval_const(BlockValue.Custom("Const", "42"))
        check(const_val.?)

        # Returns nil for non-const
        val non_const = block_def.eval_const(BlockValue.Custom("Const", "variable"))
        check(not non_const.?)

    it "has no const_eval by default":
        val block_def = BlockBuilder.new("noconst")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        val result = block_def.eval_const(BlockValue.Raw("test"))
        check(not result.?)

describe "BlockBuilder - IDE Support":

    it "supports highlighter":
        val block_def = BlockBuilder.new("highlight")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .highlighter(\text:
                # Simple highlighter - find "keyword"
                if text.contains("keyword"):
                    [HighlightToken(start: 0, end: 7, kind: HighlightKind.Keyword)]
                else:
                    []
            )
            .build()

        val tokens = block_def.highlight("keyword found")
        check(tokens.len() == 1)

    it "supports completer":
        val block_def = BlockBuilder.new("complete")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .completer(\text, cursor:
                # Simple completer
                [
                    Completion(
                        label: "complete",
                        kind: CompletionKind.Keyword,
                        detail: nil,
                        insert_text: nil,
                        documentation: nil
                    )
                ]
            )
            .build()

        val completions = block_def.completions("com", 3)
        check(completions.len() == 1)
        check(completions[0].label == "complete")

    it "supports hover_provider":
        val block_def = BlockBuilder.new("hover")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .hover_provider(\text, cursor:
                Some(HoverInfo(
                    contents: "Hover information",
                    range: Some((cursor, cursor + 5))
                ))
            )
            .build()

        val hover = block_def.hover("text", 0)
        check(hover.?)
        check(hover.unwrap().contents == "Hover information")

    it "has no IDE support by default":
        val block_def = BlockBuilder.new("noide")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        check(block_def.highlight("test").len() == 0)
        check(block_def.completions("test", 0).len() == 0)
        check(not block_def.hover("test", 0).?)

describe "BlockBuilder - Documentation":

    it "supports doc() for description":
        val block_def = BlockBuilder.new("documented")
            .doc("This is a documented block")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        check(block_def.description() == "This is a documented block")

    it "supports example() for examples":
        val block_def = BlockBuilder.new("examples")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .example("code1", "Example 1")
            .example("code2", "Example 2", output: "output2")
            .build()

        val examples = block_def.examples()
        check(examples.len() == 2)
        check(examples[0].code == "code1")
        check(examples[1].output.? and examples[1].output.unwrap() == "output2")

    it "has default description if not set":
        val block_def = BlockBuilder.new("default")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        val desc = block_def.description()
        check(desc.contains("default"))

describe "BlockBuilder - Method Chaining":

    it "chains multiple configuration methods":
        val block_def = BlockBuilder.new("chained")
            .raw_text()
            .enable_feature("power_caret")
            .enable_feature("matrix_mul")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .simple_validator(\v: [])
            .const_eval(\v: nil)
            .doc("Chained configuration")
            .example("test", "Test example")
            .build()

        check(block_def.kind() == "chained")
        check(block_def.lexer_mode().is_raw())
        check(block_def.syntax_features().power_caret)
        check(block_def.description() == "Chained configuration")
        check(block_def.examples().len() == 1)

    it "preserves order of operations":
        val block_def = BlockBuilder.new("order")
            .enable_all_math()  # Enable all
            .disable_feature("power_caret")  # Disable one
            .enable_feature("power_caret")  # Re-enable
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        check(block_def.syntax_features().power_caret)  # Should be enabled

describe "BlockBuilder - Integration":

    it "works with scoped registration":
        val block_def = BlockBuilder.new("scoped")
            .raw_text()
            .simple_parser(\t: Ok(BlockValue.Custom("Scoped", t)))
            .build()

        with_block(block_def, \:
            check(is_block_registered("scoped"))

            val ctx = BlockContext.test("test")
            val result = block_def.parse_payload("test", ctx)
            check(result.ok.?)
        )

        check(not is_block_registered("scoped"))

    it "produces working block definition":
        val sql = BlockBuilder.new("sql")
            .raw_text()
            .simple_parser(\text:
                # Simulated SQL parser
                Ok(BlockValue.Custom("SQL", text.trim()))
            )
            .simple_validator(\value:
                match value:
                    case Custom("SQL", query):
                        if not query.starts_with("SELECT"):
                            ["Query must start with SELECT"]
                        else:
                            []
                    case _:
                        ["Expected SQL query"]
            )
            .build()

        val ctx = BlockContext.test("")

        # Valid SQL
        val valid = BlockValue.Custom("SQL", "SELECT * FROM users")
        check(sql.validate(valid, ctx).len() == 0)

        # Invalid SQL
        val invalid = BlockValue.Custom("SQL", "DELETE FROM users")
        check(sql.validate(invalid, ctx).len() == 1)

describe "BlockBuilder - Edge Cases":

    it "handles empty configuration":
        val minimal = BlockBuilder.new("minimal")
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        # Should have all defaults
        check(minimal.lexer_mode().is_raw())
        check(not minimal.syntax_features().power_caret)
        check(minimal.validate(BlockValue.Raw(""), BlockContext.test("")).len() == 0)

    it "handles feature enable/disable patterns":
        val toggle = BlockBuilder.new("toggle")
            .enable_feature("power_caret")
            .enable_feature("power_caret")  # Enable twice
            .disable_feature("power_caret")  # Then disable
            .enable_feature("power_caret")  # Then enable again
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        check(toggle.syntax_features().power_caret)  # Should end up enabled

    it "handles unknown features gracefully":
        val unknown = BlockBuilder.new("unknown")
            .enable_feature("nonexistent_feature")  # Should not error
            .simple_parser(\t: Ok(BlockValue.Raw(t)))
            .build()

        # Should still build successfully
        check(unknown.kind() == "unknown")

# ============================================================================
# Feature Tags
# ============================================================================

# tags: [compiler, blocks, builder-api, tier2]
# priority: high
# status: complete
