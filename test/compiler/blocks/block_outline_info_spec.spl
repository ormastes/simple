import std.spec

describe "BlockOutlineInfo - Math":
    it "extracts variable identifiers":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val info = block.treesitter_outline("x^2 + 2*x*y + y^2", pre_lex)
        expect(info.identifiers).to(contain("x"))
        expect(info.identifiers).to(contain("y"))

    it "extracts function names":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val info = block.treesitter_outline("sin(x) + cos(y)", pre_lex)
        expect(info.identifiers).to(contain("sin"))
        expect(info.identifiers).to(contain("cos"))

    it "does not duplicate identifiers":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val info = block.treesitter_outline("x + x + x", pre_lex)
        expect(info.identifiers.len()).to(eq(1))
        expect(info.identifiers[0]).to(eq("x"))

    it "reports structure_kind as expression":
        val block = MathBlockDef()
        val pre_lex = PreLexInfo.empty()
        val info = block.treesitter_outline("x + y", pre_lex)
        expect(info.structure_kind).to(eq(Some("expression")))

describe "BlockOutlineInfo - Opaque fallback":
    it "returns opaque for blocks without outline impl":
        val block = MarkdownBlockDef()
        val pre_lex = PreLexInfo.empty()
        val info = block.treesitter_outline("# Heading", pre_lex)
        expect(info.is_opaque).to(be_true())

    it "returns opaque for shell blocks":
        val block = ShellBlockDef()
        val pre_lex = PreLexInfo.empty()
        val info = block.treesitter_outline("ls -la | grep pattern", pre_lex)
        expect(info.is_opaque).to(be_true())
        expect(info.kind).to(eq("sh"))

    it "returns opaque for json blocks":
        val block = JsonBlockDef()
        val pre_lex = PreLexInfo.empty()
        val info = block.treesitter_outline("{\"key\": \"value\"}", pre_lex)
        expect(info.is_opaque).to(be_true())
        expect(info.kind).to(eq("json"))
