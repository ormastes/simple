"""
Feature: BlockOutlineInfo Extraction per Block Type
Feature ID: #1092-outline
Category: Compiler/Blocks
Status: In Progress
Priority: P1

## Overview

BlockOutlineInfo provides fast structural extraction for IDE features without
full parsing. Each block type produces outline info via treesitter_outline():
- **MathBlockDef**: Extracts variable identifiers, function names; non-opaque
- **ShellBlockDef**: Returns opaque outline (default)
- **SqlBlockDef**: Returns opaque outline (default)
- **JsonBlockDef**: Returns opaque outline (default)
- **MarkdownBlockDef**: Returns opaque outline (default)

The math block is the reference implementation showing identifier extraction,
deduplication, and structure_kind reporting. Other blocks use the default
opaque fallback.

## Concepts

- **Opaque outline**: No structural info extracted; just kind + is_opaque=true
- **Non-opaque outline**: Has identifiers, external_refs, structure_kind
- **treesitter_outline()**: Method on BlockDefinition trait
- **PreLexInfo**: Pre-scanning info passed to treesitter_outline for filtering
"""
use std.spec.*
use compiler.blocks.modes.{PreLexInfo, TextSpan, BlockOutlineInfo}
use compiler.blocks.builtin_blocks_defs.{MathBlockDef, ShellBlockDef, SqlBlockDef, JsonBlockDef, MarkdownBlockDef}

# ============================================================================
# Math block outline extraction
# ============================================================================

describe "BlockOutlineInfo - MathBlockDef":
    context "variable identifier extraction":
        it "extracts single variable":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x", pre_lex)
            expect(info.identifiers.len()).to_equal(1)
            expect(info.identifiers[0]).to_equal("x")
            expect(info.is_opaque).to_be_false()

        it "extracts two variables from addition":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x + y", pre_lex)
            expect(info.identifiers).to_contain("x")
            expect(info.identifiers).to_contain("y")

        it "extracts variables from polynomial":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x^2 + 2*x*y + y^2", pre_lex)
            expect(info.identifiers).to_contain("x")
            expect(info.identifiers).to_contain("y")

        it "extracts multi-character variable names":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("alpha + beta * gamma", pre_lex)
            expect(info.identifiers).to_contain("alpha")
            expect(info.identifiers).to_contain("beta")
            expect(info.identifiers).to_contain("gamma")

        it "extracts variables with underscores":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x_1 + x_2", pre_lex)
            expect(info.identifiers).to_contain("x_1")
            expect(info.identifiers).to_contain("x_2")

    context "deduplication":
        it "does not duplicate when same variable appears multiple times":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x + x + x", pre_lex)
            expect(info.identifiers.len()).to_equal(1)
            expect(info.identifiers[0]).to_equal("x")

        it "deduplicates across complex expression":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x*y + y*x + x*x + y*y", pre_lex)
            expect(info.identifiers.len()).to_equal(2)
            expect(info.identifiers).to_contain("x")
            expect(info.identifiers).to_contain("y")

    context "function name extraction":
        it "extracts trig function names":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("sin(x) + cos(y)", pre_lex)
            expect(info.identifiers).to_contain("sin")
            expect(info.identifiers).to_contain("cos")
            expect(info.identifiers).to_contain("x")
            expect(info.identifiers).to_contain("y")

        it "extracts nested function calls":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("sqrt(abs(x))", pre_lex)
            expect(info.identifiers).to_contain("sqrt")
            expect(info.identifiers).to_contain("abs")
            expect(info.identifiers).to_contain("x")

        it "extracts log and exp":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("log(exp(x))", pre_lex)
            expect(info.identifiers).to_contain("log")
            expect(info.identifiers).to_contain("exp")
            expect(info.identifiers).to_contain("x")

    context "structure_kind":
        it "reports expression for simple expression":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x + y", pre_lex)
            expect(info.structure_kind).to_equal(Some("expression"))

        it "reports expression for complex expression":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("sin(x)^2 + cos(x)^2", pre_lex)
            expect(info.structure_kind).to_equal(Some("expression"))

    context "kind field":
        it "reports kind as m":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x", pre_lex)
            expect(info.kind).to_equal("m")

    context "empty payload":
        it "returns empty identifiers for empty payload":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("", pre_lex)
            expect(info.identifiers.len()).to_equal(0)
            expect(info.is_opaque).to_be_false()
            expect(info.kind).to_equal("m")

    context "numbers not treated as identifiers":
        it "does not extract pure numbers":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("42 + 3.14", pre_lex)
            expect(info.identifiers.len()).to_equal(0)

        it "extracts only identifiers from mixed expression":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("2*x + 3*y + 1", pre_lex)
            expect(info.identifiers).to_contain("x")
            expect(info.identifiers).to_contain("y")
            expect(info.identifiers.len()).to_equal(2)

    context "pre_lex filtering":
        it "skips identifiers inside string spans":
            val block = MathBlockDef()
            # Positions 0..8 are in a string span, covering "hidden_x"
            val pre_lex = PreLexInfo(
                string_spans: [TextSpan.new(0, 8)],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            val info = block.treesitter_outline("hidden_x + visible_y", pre_lex)
            expect(info.identifiers).not_to_contain("hidden_x")
            expect(info.identifiers).to_contain("visible_y")

        it "skips identifiers inside comment spans":
            val block = MathBlockDef()
            # Positions 4..15 are in a comment, covering "# commented"
            val pre_lex = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan.new(4, 15)],
                escape_positions: [],
                brace_pairs: []
            )
            val info = block.treesitter_outline("x + commented_out", pre_lex)
            # "x" at position 0 is not in comment
            expect(info.identifiers).to_contain("x")

# ============================================================================
# Shell block outline (opaque fallback)
# ============================================================================

describe "BlockOutlineInfo - ShellBlockDef":
    it "returns opaque outline":
        val block = ShellBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("ls -la | grep pattern", pre_lex)
        expect(info.is_opaque).to_be_true()

    it "reports kind as sh":
        val block = ShellBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("echo hello", pre_lex)
        expect(info.kind).to_equal("sh")

    it "has empty identifiers":
        val block = ShellBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("ls -la", pre_lex)
        expect(info.identifiers.len()).to_equal(0)

    it "has empty external_refs":
        val block = ShellBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("ls -la", pre_lex)
        expect(info.external_refs.len()).to_equal(0)

    it "returns opaque for empty payload":
        val block = ShellBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("", pre_lex)
        expect(info.is_opaque).to_be_true()
        expect(info.kind).to_equal("sh")

# ============================================================================
# SQL block outline (opaque fallback)
# ============================================================================

describe "BlockOutlineInfo - SqlBlockDef":
    it "returns opaque outline":
        val block = SqlBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("SELECT name FROM users", pre_lex)
        expect(info.is_opaque).to_be_true()

    it "reports kind as sql":
        val block = SqlBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("SELECT 1", pre_lex)
        expect(info.kind).to_equal("sql")

    it "has empty identifiers for default outline":
        val block = SqlBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("SELECT * FROM t", pre_lex)
        expect(info.identifiers.len()).to_equal(0)

# ============================================================================
# JSON block outline (opaque fallback)
# ============================================================================

describe "BlockOutlineInfo - JsonBlockDef":
    it "returns opaque outline":
        val block = JsonBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("{\"key\": \"value\"}", pre_lex)
        expect(info.is_opaque).to_be_true()

    it "reports kind as json":
        val block = JsonBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("{}", pre_lex)
        expect(info.kind).to_equal("json")

    it "returns opaque for nested JSON":
        val block = JsonBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("{\"a\": {\"b\": {\"c\": 1}}}", pre_lex)
        expect(info.is_opaque).to_be_true()

    it "returns opaque for JSON array":
        val block = JsonBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("[1, 2, 3]", pre_lex)
        expect(info.is_opaque).to_be_true()

# ============================================================================
# Markdown block outline (opaque fallback)
# ============================================================================

describe "BlockOutlineInfo - MarkdownBlockDef":
    it "returns opaque outline":
        val block = MarkdownBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("# Heading\nParagraph text", pre_lex)
        expect(info.is_opaque).to_be_true()

    it "reports kind as md":
        val block = MarkdownBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("# Title", pre_lex)
        expect(info.kind).to_equal("md")

    it "returns opaque for empty markdown":
        val block = MarkdownBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("", pre_lex)
        expect(info.is_opaque).to_be_true()

# ============================================================================
# BlockOutlineInfo struct construction
# ============================================================================

describe "BlockOutlineInfo construction":
    it "opaque factory sets is_opaque and kind":
        val info = BlockOutlineInfo(
            kind: "test",
            identifiers: [],
            external_refs: [],
            structure_kind: nil,
            is_opaque: true
        )
        expect(info.is_opaque).to_be_true()
        expect(info.kind).to_equal("test")
        expect(info.identifiers.len()).to_equal(0)
        expect(info.external_refs.len()).to_equal(0)

    it "non-opaque with identifiers":
        val info = BlockOutlineInfo(
            kind: "m",
            identifiers: ["x", "y", "z"],
            external_refs: [],
            structure_kind: Some("expression"),
            is_opaque: false
        )
        expect(info.is_opaque).to_be_false()
        expect(info.identifiers.len()).to_equal(3)
        expect(info.identifiers[0]).to_equal("x")
        expect(info.identifiers[1]).to_equal("y")
        expect(info.identifiers[2]).to_equal("z")
        expect(info.structure_kind).to_equal(Some("expression"))

    it "with external_refs":
        val info = BlockOutlineInfo(
            kind: "sql",
            identifiers: ["name", "age"],
            external_refs: ["users", "orders"],
            structure_kind: Some("query"),
            is_opaque: false
        )
        expect(info.external_refs.len()).to_equal(2)
        expect(info.external_refs).to_contain("users")
        expect(info.external_refs).to_contain("orders")

    it "nil structure_kind":
        val info = BlockOutlineInfo(
            kind: "sh",
            identifiers: [],
            external_refs: [],
            structure_kind: nil,
            is_opaque: true
        )
        expect(info.structure_kind).to_equal(nil)
