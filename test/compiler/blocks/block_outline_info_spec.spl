"""
Feature: BlockOutlineInfo Extraction per Block Type
Feature ID: #1092-outline
Category: Compiler/Blocks
Status: In Progress
Priority: P1

## Overview

BlockOutlineInfo provides fast structural extraction for IDE features without
full parsing. Each block type produces outline info via treesitter_outline():
- **MathBlockDef**: Extracts variable identifiers, function names; non-opaque
- **ShellBlockDef**: Returns opaque outline (default)
- **SqlBlockDef**: Returns opaque outline (default)
- **JsonBlockDef**: Returns opaque outline (default)
- **MarkdownBlockDef**: Returns opaque outline (default)

The math block is the reference implementation showing identifier extraction,
deduplication, and structure_kind reporting. Other blocks use the default
opaque fallback.

## Concepts

- **Opaque outline**: No structural info extracted; just kind + is_opaque=true
- **Non-opaque outline**: Has identifiers, external_refs, structure_kind
- **treesitter_outline()**: Method on BlockDefinition trait
- **PreLexInfo**: Pre-scanning info passed to treesitter_outline for filtering
"""

import std.spec
use blocks.modes.{PreLexInfo, TextSpan, BlockOutlineInfo}
use blocks.builtin_blocks_defs.{MathBlockDef, ShellBlockDef, SqlBlockDef, JsonBlockDef, MarkdownBlockDef}

# ============================================================================
# Math block outline extraction
# ============================================================================

describe "BlockOutlineInfo - MathBlockDef":
    context "variable identifier extraction":
        it "extracts single variable":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x", pre_lex)
            expect(info.identifiers.len()).to(eq(1))
            expect(info.identifiers[0]).to(eq("x"))
            expect(info.is_opaque).to(be_false())

        it "extracts two variables from addition":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x + y", pre_lex)
            expect(info.identifiers).to(include("x"))
            expect(info.identifiers).to(include("y"))

        it "extracts variables from polynomial":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x^2 + 2*x*y + y^2", pre_lex)
            expect(info.identifiers).to(include("x"))
            expect(info.identifiers).to(include("y"))

        it "extracts multi-character variable names":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("alpha + beta * gamma", pre_lex)
            expect(info.identifiers).to(include("alpha"))
            expect(info.identifiers).to(include("beta"))
            expect(info.identifiers).to(include("gamma"))

        it "extracts variables with underscores":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x_1 + x_2", pre_lex)
            expect(info.identifiers).to(include("x_1"))
            expect(info.identifiers).to(include("x_2"))

    context "deduplication":
        it "does not duplicate when same variable appears multiple times":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x + x + x", pre_lex)
            expect(info.identifiers.len()).to(eq(1))
            expect(info.identifiers[0]).to(eq("x"))

        it "deduplicates across complex expression":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x*y + y*x + x*x + y*y", pre_lex)
            expect(info.identifiers.len()).to(eq(2))
            expect(info.identifiers).to(include("x"))
            expect(info.identifiers).to(include("y"))

    context "function name extraction":
        it "extracts trig function names":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("sin(x) + cos(y)", pre_lex)
            expect(info.identifiers).to(include("sin"))
            expect(info.identifiers).to(include("cos"))
            expect(info.identifiers).to(include("x"))
            expect(info.identifiers).to(include("y"))

        it "extracts nested function calls":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("sqrt(abs(x))", pre_lex)
            expect(info.identifiers).to(include("sqrt"))
            expect(info.identifiers).to(include("abs"))
            expect(info.identifiers).to(include("x"))

        it "extracts log and exp":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("log(exp(x))", pre_lex)
            expect(info.identifiers).to(include("log"))
            expect(info.identifiers).to(include("exp"))
            expect(info.identifiers).to(include("x"))

    context "structure_kind":
        it "reports expression for simple expression":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x + y", pre_lex)
            expect(info.structure_kind).to(eq(Some("expression")))

        it "reports expression for complex expression":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("sin(x)^2 + cos(x)^2", pre_lex)
            expect(info.structure_kind).to(eq(Some("expression")))

    context "kind field":
        it "reports kind as m":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("x", pre_lex)
            expect(info.kind).to(eq("m"))

    context "empty payload":
        it "returns empty identifiers for empty payload":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("", pre_lex)
            expect(info.identifiers.len()).to(eq(0))
            expect(info.is_opaque).to(be_false())
            expect(info.kind).to(eq("m"))

    context "numbers not treated as identifiers":
        it "does not extract pure numbers":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("42 + 3.14", pre_lex)
            expect(info.identifiers.len()).to(eq(0))

        it "extracts only identifiers from mixed expression":
            val block = MathBlockDef()
            val pre_lex = PreLexInfo(
                string_spans: [], comment_spans: [],
                escape_positions: [], brace_pairs: []
            )
            val info = block.treesitter_outline("2*x + 3*y + 1", pre_lex)
            expect(info.identifiers).to(include("x"))
            expect(info.identifiers).to(include("y"))
            expect(info.identifiers.len()).to(eq(2))

    context "pre_lex filtering":
        it "skips identifiers inside string spans":
            val block = MathBlockDef()
            # Positions 0..8 are in a string span, covering "hidden_x"
            val pre_lex = PreLexInfo(
                string_spans: [TextSpan(start: 0, end: 8)],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            val info = block.treesitter_outline("hidden_x + visible_y", pre_lex)
            expect(info.identifiers).not_to(include("hidden_x"))
            expect(info.identifiers).to(include("visible_y"))

        it "skips identifiers inside comment spans":
            val block = MathBlockDef()
            # Positions 4..15 are in a comment, covering "# commented"
            val pre_lex = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan(start: 4, end: 15)],
                escape_positions: [],
                brace_pairs: []
            )
            val info = block.treesitter_outline("x + commented_out", pre_lex)
            # "x" at position 0 is not in comment
            expect(info.identifiers).to(include("x"))

# ============================================================================
# Shell block outline (opaque fallback)
# ============================================================================

describe "BlockOutlineInfo - ShellBlockDef":
    it "returns opaque outline":
        val block = ShellBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("ls -la | grep pattern", pre_lex)
        expect(info.is_opaque).to(be_true())

    it "reports kind as sh":
        val block = ShellBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("echo hello", pre_lex)
        expect(info.kind).to(eq("sh"))

    it "has empty identifiers":
        val block = ShellBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("ls -la", pre_lex)
        expect(info.identifiers.len()).to(eq(0))

    it "has empty external_refs":
        val block = ShellBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("ls -la", pre_lex)
        expect(info.external_refs.len()).to(eq(0))

    it "returns opaque for empty payload":
        val block = ShellBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("", pre_lex)
        expect(info.is_opaque).to(be_true())
        expect(info.kind).to(eq("sh"))

# ============================================================================
# SQL block outline (opaque fallback)
# ============================================================================

describe "BlockOutlineInfo - SqlBlockDef":
    it "returns opaque outline":
        val block = SqlBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("SELECT name FROM users", pre_lex)
        expect(info.is_opaque).to(be_true())

    it "reports kind as sql":
        val block = SqlBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("SELECT 1", pre_lex)
        expect(info.kind).to(eq("sql"))

    it "has empty identifiers for default outline":
        val block = SqlBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("SELECT * FROM t", pre_lex)
        expect(info.identifiers.len()).to(eq(0))

# ============================================================================
# JSON block outline (opaque fallback)
# ============================================================================

describe "BlockOutlineInfo - JsonBlockDef":
    it "returns opaque outline":
        val block = JsonBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("{\"key\": \"value\"}", pre_lex)
        expect(info.is_opaque).to(be_true())

    it "reports kind as json":
        val block = JsonBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("{}", pre_lex)
        expect(info.kind).to(eq("json"))

    it "returns opaque for nested JSON":
        val block = JsonBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("{\"a\": {\"b\": {\"c\": 1}}}", pre_lex)
        expect(info.is_opaque).to(be_true())

    it "returns opaque for JSON array":
        val block = JsonBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("[1, 2, 3]", pre_lex)
        expect(info.is_opaque).to(be_true())

# ============================================================================
# Markdown block outline (opaque fallback)
# ============================================================================

describe "BlockOutlineInfo - MarkdownBlockDef":
    it "returns opaque outline":
        val block = MarkdownBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("# Heading\nParagraph text", pre_lex)
        expect(info.is_opaque).to(be_true())

    it "reports kind as md":
        val block = MarkdownBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("# Title", pre_lex)
        expect(info.kind).to(eq("md"))

    it "returns opaque for empty markdown":
        val block = MarkdownBlockDef()
        val pre_lex = PreLexInfo(
            string_spans: [], comment_spans: [],
            escape_positions: [], brace_pairs: []
        )
        val info = block.treesitter_outline("", pre_lex)
        expect(info.is_opaque).to(be_true())

# ============================================================================
# BlockOutlineInfo struct construction
# ============================================================================

describe "BlockOutlineInfo construction":
    it "opaque factory sets is_opaque and kind":
        val info = BlockOutlineInfo(
            kind: "test",
            identifiers: [],
            external_refs: [],
            structure_kind: nil,
            is_opaque: true
        )
        expect(info.is_opaque).to(be_true())
        expect(info.kind).to(eq("test"))
        expect(info.identifiers.len()).to(eq(0))
        expect(info.external_refs.len()).to(eq(0))

    it "non-opaque with identifiers":
        val info = BlockOutlineInfo(
            kind: "m",
            identifiers: ["x", "y", "z"],
            external_refs: [],
            structure_kind: Some("expression"),
            is_opaque: false
        )
        expect(info.is_opaque).to(be_false())
        expect(info.identifiers.len()).to(eq(3))
        expect(info.identifiers[0]).to(eq("x"))
        expect(info.identifiers[1]).to(eq("y"))
        expect(info.identifiers[2]).to(eq("z"))
        expect(info.structure_kind).to(eq(Some("expression")))

    it "with external_refs":
        val info = BlockOutlineInfo(
            kind: "sql",
            identifiers: ["name", "age"],
            external_refs: ["users", "orders"],
            structure_kind: Some("query"),
            is_opaque: false
        )
        expect(info.external_refs.len()).to(eq(2))
        expect(info.external_refs).to(include("users"))
        expect(info.external_refs).to(include("orders"))

    it "nil structure_kind":
        val info = BlockOutlineInfo(
            kind: "sh",
            identifiers: [],
            external_refs: [],
            structure_kind: nil,
            is_opaque: true
        )
        expect(info.structure_kind).to(be_nil())
