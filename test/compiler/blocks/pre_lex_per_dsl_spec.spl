# @skip - Uses unsupported keyword: with
"""
Feature: PreLexInfo Per-DSL Conflict Scenarios
Feature ID: #1092-dsl
Category: Compiler/Blocks
Status: In Progress
Priority: P1

## Overview

Each DSL (shell, SQL, regex, JSON, math, markdown) has unique syntax that
can conflict with the host lexer's brace-counting logic. The `}` character
appears legitimately inside strings, comments, regex quantifiers, and nested
JSON objects. Tier 1+2 pre-scanning must correctly identify these protected
regions so the host lexer does not prematurely end the block payload.

This spec verifies that PreLexInfo correctly models the protected regions
for each DSL, and that the protection predicates (is_in_string, is_in_comment,
is_escaped, is_protected) work correctly for DSL-specific conflict patterns.

## Concepts

- **Protected region**: A position inside a string, comment, or escape that
  should NOT be treated as a brace delimiter by the host lexer
- **Tier 1**: String and escape tracking (universal across DSLs)
- **Tier 2**: Comment tracking (DSL-specific comment syntax)
- **Brace conflict**: A `}` character that appears inside a protected region
"""

use std.spec.*
use compiler.blocks.modes.{PreLexInfo, TextSpan, BlockSkipPolicy, BlockOutlineInfo}
use compiler.blocks.modes.{BlockToken, BlockTokenKind}

# ============================================================================
# Shell DSL conflicts
# ============================================================================

describe "PreLexInfo Shell DSL conflicts":
    context "} inside double-quoted strings":
        it "marks } position as protected when inside string span":
            # Payload: echo "}" done
            #          0123456789...
            # String span covers positions 5..8 (the "}" part)
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 8)],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            # The } at position 6 is inside the string
            expect(info.is_in_string(6)).to_equal(true)
            expect(info.is_protected(6)).to_equal(true)
            # Position outside string is not protected
            expect(info.is_in_string(9)).to_equal(false)
            expect(info.is_protected(9)).to_equal(false)

        it "handles multiple } inside one string":
            # Payload: echo "}}}" done
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 10)],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.is_in_string(6)).to_equal(true)
            expect(info.is_in_string(7)).to_equal(true)
            expect(info.is_in_string(8)).to_equal(true)

    context "} inside single-quoted strings":
        it "marks } as protected in single-quoted shell string":
            # Payload: echo '}' done
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 8)],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.is_in_string(6)).to_equal(true)
            expect(info.is_protected(6)).to_equal(true)

    context "} inside # line comment":
        it "marks } as protected in shell comment":
            # Payload: echo hello # close }
            #          0123456789012345678901
            # Comment from 11 to end
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan.new(11, 21)],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.is_in_comment(19)).to_equal(true)
            expect(info.is_protected(19)).to_equal(true)

        it "handles multiline with comment on first line":
            # Payload: echo hello # }\necho world
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan.new(11, 15)],
                escape_positions: [],
                brace_pairs: []
            )
            # } at position 13 is in comment
            expect(info.is_in_comment(13)).to_equal(true)
            # Position on next line is not in comment
            expect(info.is_in_comment(16)).to_equal(false)

    context "variable expansion dollar-brace VAR":
        it "does not protect } in dollar-brace-VAR since braces are balanced":
            # Payload: echo ${VAR:-default}
            # The {} in ${VAR:-default} are balanced, brace_pairs tracks them
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: [(5, 20)]
            )
            # Brace pairs don't make positions "protected" in the string/comment sense
            # They just track nesting depth for the host lexer
            expect(info.is_in_string(20)).to_equal(false)
            expect(info.is_in_comment(20)).to_equal(false)

    context "escaped } in shell":
        it "marks escaped } as protected":
            # Payload: echo \} rest
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [5],
                brace_pairs: []
            )
            # Position 6 (the }) is after escape at 5
            expect(info.is_escaped(6)).to_equal(true)
            expect(info.is_protected(6)).to_equal(true)

    context "combined string + comment":
        it "handles string then comment with } in both":
            # Payload: echo "}" # also }
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 8)],
                comment_spans: [TextSpan.new(9, 18)],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.is_in_string(6)).to_equal(true)
            expect(info.is_in_comment(16)).to_equal(true)
            expect(info.is_protected(6)).to_equal(true)
            expect(info.is_protected(16)).to_equal(true)

# ============================================================================
# SQL DSL conflicts
# ============================================================================

describe "PreLexInfo SQL DSL conflicts":
    context "} inside single-quoted SQL string":
        it "marks } as protected in SQL string literal":
            # Payload: SELECT * FROM t WHERE col = '}'
            #          0         1         2         3
            val info = PreLexInfo(
                string_spans: [TextSpan.new(28, 31)],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.is_in_string(29)).to_equal(true)
            expect(info.is_protected(29)).to_equal(true)

    context "} inside -- SQL comment":
        it "marks } as protected in SQL line comment":
            # Payload: SELECT * -- filter }\nFROM t
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan.new(9, 21)],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.is_in_comment(19)).to_equal(true)
            expect(info.is_protected(19)).to_equal(true)
            # Position on next line is not in comment
            expect(info.is_in_comment(22)).to_equal(false)

    context "} inside /* */ SQL block comment":
        it "marks } as protected in block comment":
            # Payload: SELECT /* } */ FROM t
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [TextSpan.new(7, 14)],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.is_in_comment(10)).to_equal(true)
            expect(info.is_protected(10)).to_equal(true)

    context "multiple SQL strings with }":
        it "handles multiple string literals each containing }":
            # Payload: SELECT '}' || '}' FROM t
            val info = PreLexInfo(
                string_spans: [
                    TextSpan.new(7, 10),
                    TextSpan.new(14, 17)
                ],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.is_in_string(8)).to_equal(true)
            expect(info.is_in_string(15)).to_equal(true)
            expect(info.is_in_string(11)).to_equal(false)

# ============================================================================
# Regex DSL conflicts
# ============================================================================

describe "PreLexInfo Regex DSL conflicts":
    context "quantifier braces":
        it "tracks balanced quantifier braces as brace pairs":
            # Payload: \d{3}
            # The {3} is a quantifier — balanced braces tracked as pair
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [0],
                brace_pairs: [(2, 4)]
            )
            # The } at position 4 is part of a balanced pair
            expect(info.brace_pairs.len()).to_equal(1)
            expect(info.brace_pairs[0]).to_equal((2, 4))

        it "tracks range quantifier":
            # Payload: [a-z]{2,5}
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: [(5, 9)]
            )
            expect(info.brace_pairs.len()).to_equal(1)

    context "} inside character class":
        it "} in character class is not in string or comment":
            # Payload: [}]
            # Character classes are not strings or comments in pre-lex sense
            # The regex handler itself understands character classes
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            # Bare } not protected by pre-lex — regex handler deals with it
            expect(info.is_protected(1)).to_equal(false)

    context "escaped brace in regex":
        it "marks escaped } as protected":
            # Payload: match \}
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [6],
                brace_pairs: []
            )
            expect(info.is_escaped(7)).to_equal(true)
            expect(info.is_protected(7)).to_equal(true)

# ============================================================================
# JSON DSL conflicts
# ============================================================================

describe "PreLexInfo JSON DSL conflicts":
    context "nested JSON objects":
        it "tracks nested brace pairs for JSON objects":
            # Payload: {"a": {"b": 1}}
            #          0123456789012345
            val info = PreLexInfo(
                string_spans: [
                    TextSpan.new(1, 4),   # "a"
                    TextSpan.new(7, 10)    # "b"
                ],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: [(0, 14), (6, 13)]
            )
            expect(info.brace_pairs.len()).to_equal(2)
            # Inner } at 13 is part of inner pair
            # Outer } at 14 is part of outer pair

        it "handles deeply nested objects":
            # Payload: {"a":{"b":{"c":1}}}
            val info = PreLexInfo(
                string_spans: [
                    TextSpan.new(1, 4),
                    TextSpan.new(6, 9),
                    TextSpan.new(11, 14)
                ],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: [(0, 18), (5, 17), (10, 16)]
            )
            expect(info.brace_pairs.len()).to_equal(3)

    context "} inside JSON string values":
        it "marks } inside JSON string value as protected":
            # Payload: {"key": "value}"}
            val info = PreLexInfo(
                string_spans: [
                    TextSpan.new(1, 6),    # "key"
                    TextSpan.new(8, 16)     # "value}"
                ],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: [(0, 16)]
            )
            # The } at position 14 is inside the string value
            expect(info.is_in_string(14)).to_equal(true)
            expect(info.is_protected(14)).to_equal(true)

        it "handles escaped quote inside JSON string":
            # Payload: {"k": "say \"hi\""}
            val info = PreLexInfo(
                string_spans: [
                    TextSpan.new(1, 4),
                    TextSpan.new(6, 17)
                ],
                comment_spans: [],
                escape_positions: [10, 14],
                brace_pairs: [(0, 17)]
            )
            expect(info.escape_positions.len()).to_equal(2)

    context "empty JSON object":
        it "handles {} with just brace pair":
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: [(0, 1)]
            )
            expect(info.brace_pairs.len()).to_equal(1)

    context "JSON array with objects":
        it "handles array of objects":
            # Payload: [{"a":1},{"b":2}]
            val info = PreLexInfo(
                string_spans: [
                    TextSpan.new(2, 5),
                    TextSpan.new(9, 12)
                ],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: [(1, 6), (8, 13)]
            )
            expect(info.brace_pairs.len()).to_equal(2)

# ============================================================================
# Math DSL conflicts
# ============================================================================

describe "PreLexInfo Math DSL conflicts":
    context "set notation {1,2,3}":
        it "tracks set braces as brace pair":
            # Payload: S = {1,2,3}
            #          0123456789
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: [(4, 10)]
            )
            expect(info.brace_pairs.len()).to_equal(1)

    context "nested set notation":
        it "tracks nested set braces":
            # Payload: A = {{1,2}, {3,4}}
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: [(4, 17), (5, 9), (12, 16)]
            )
            expect(info.brace_pairs.len()).to_equal(3)

    context "math with no conflicts":
        it "simple expression has no protected regions":
            # Payload: x^2 + y^2
            val info = PreLexInfo(
                string_spans: [],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.string_spans.len()).to_equal(0)
            expect(info.comment_spans.len()).to_equal(0)
            expect(info.escape_positions.len()).to_equal(0)
            expect(info.brace_pairs.len()).to_equal(0)

# ============================================================================
# Markdown DSL conflicts
# ============================================================================

describe "PreLexInfo Markdown DSL conflicts":
    context "code fences with }":
        it "} inside inline code is in string span":
            # Payload: text `code }` more
            val info = PreLexInfo(
                string_spans: [TextSpan.new(5, 13)],
                comment_spans: [],
                escape_positions: [],
                brace_pairs: []
            )
            expect(info.is_in_string(11)).to_equal(true)
            expect(info.is_protected(11)).to_equal(true)

# ============================================================================
# Cross-DSL protection predicate exhaustive tests
# ============================================================================

describe "PreLexInfo protection predicates across DSLs":
    it "is_protected covers string, comment, and escape":
        val info = PreLexInfo(
            string_spans: [TextSpan.new(0, 5)],
            comment_spans: [TextSpan.new(10, 15)],
            escape_positions: [20],
            brace_pairs: []
        )
        # In string → protected
        expect(info.is_protected(3)).to_equal(true)
        # In comment → protected
        expect(info.is_protected(12)).to_equal(true)
        # After escape → protected
        expect(info.is_protected(21)).to_equal(true)
        # None of the above → not protected
        expect(info.is_protected(7)).to_equal(false)
        expect(info.is_protected(17)).to_equal(false)
        expect(info.is_protected(25)).to_equal(false)

    it "position at span boundary (start inclusive, end exclusive)":
        val info = PreLexInfo(
            string_spans: [TextSpan.new(5, 10)],
            comment_spans: [],
            escape_positions: [],
            brace_pairs: []
        )
        # start is inclusive
        expect(info.is_in_string(5)).to_equal(true)
        # end is exclusive
        expect(info.is_in_string(10)).to_equal(false)
        # one before end
        expect(info.is_in_string(9)).to_equal(true)

    it "empty PreLexInfo protects nothing":
        val info = PreLexInfo(
            string_spans: [],
            comment_spans: [],
            escape_positions: [],
            brace_pairs: []
        )
        expect(info.is_protected(0)).to_equal(false)
        expect(info.is_protected(100)).to_equal(false)
        expect(info.is_protected(999)).to_equal(false)

    it "overlapping string and comment spans both protect":
        # Edge case: same region marked as both string and comment
        val info = PreLexInfo(
            string_spans: [TextSpan.new(5, 15)],
            comment_spans: [TextSpan.new(10, 20)],
            escape_positions: [],
            brace_pairs: []
        )
        # In string only
        expect(info.is_in_string(7)).to_equal(true)
        expect(info.is_in_comment(7)).to_equal(false)
        # In both
        expect(info.is_in_string(12)).to_equal(true)
        expect(info.is_in_comment(12)).to_equal(true)
        expect(info.is_protected(12)).to_equal(true)
        # In comment only
        expect(info.is_in_string(17)).to_equal(false)
        expect(info.is_in_comment(17)).to_equal(true)

    it "multiple escape positions":
        val info = PreLexInfo(
            string_spans: [],
            comment_spans: [],
            escape_positions: [0, 5, 10, 15],
            brace_pairs: []
        )
        expect(info.is_escaped(1)).to_equal(true)
        expect(info.is_escaped(6)).to_equal(true)
        expect(info.is_escaped(11)).to_equal(true)
        expect(info.is_escaped(16)).to_equal(true)
        # Not after any escape
        expect(info.is_escaped(3)).to_equal(false)
        expect(info.is_escaped(8)).to_equal(false)

    it "consecutive escapes protect alternating positions":
        # Payload: \\\} — escape at 0 protects 1, escape at 2 protects 3
        val info = PreLexInfo(
            string_spans: [],
            comment_spans: [],
            escape_positions: [0, 2],
            brace_pairs: []
        )
        expect(info.is_escaped(1)).to_equal(true)
        expect(info.is_escaped(3)).to_equal(true)
        expect(info.is_escaped(2)).to_equal(false)
