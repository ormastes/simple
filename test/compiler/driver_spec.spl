# Compiler Driver Tests
#
# Tests for the compiler driver module, focusing on branch coverage
# for CompileMode, CompileOptions, and CompileResult.

# @skip
use std.spec.*
use compiler.driver.*

# ============================================================================
# Test Group 1: CompileMode Conversion
# ============================================================================

describe "CompileMode to_text":
    """
    Tests string conversion for all compilation modes.
    """

    it "converts Interpret mode to text":
        val mode = CompileMode.Interpret
        expect mode.to_text() == "interpret"

    it "converts Jit mode to text":
        val mode = CompileMode.Jit
        expect mode.to_text() == "jit"

    it "converts Aot mode to text":
        val mode = CompileMode.Aot
        expect mode.to_text() == "aot"

    it "converts Check mode to text":
        val mode = CompileMode.Check
        expect mode.to_text() == "check"

    it "converts Sdn mode to text":
        val mode = CompileMode.Sdn
        expect mode.to_text() == "sdn"


describe "CompileMode from_text":
    """
    Tests parsing compilation modes from strings.
    Covers all branch paths in from_text().
    """

    it "parses 'interpret' to Interpret mode":
        val result = CompileMode.from_text("interpret")
        expect result.is_some()
        expect result.unwrap() == CompileMode.Interpret

    it "parses 'i' to Interpret mode":
        val result = CompileMode.from_text("i")
        expect result.is_some()

    it "parses 'jit' to Jit mode":
        val result = CompileMode.from_text("jit")
        expect result.is_some()
        expect result.unwrap() == CompileMode.Jit

    it "parses 'j' to Jit mode":
        val result = CompileMode.from_text("j")
        expect result.is_some()

    it "parses 'aot' to Aot mode":
        val result = CompileMode.from_text("aot")
        expect result.is_some()
        expect result.unwrap() == CompileMode.Aot

    it "parses 'a' to Aot mode":
        val result = CompileMode.from_text("a")
        expect result.is_some()

    it "parses 'compile' to Aot mode":
        val result = CompileMode.from_text("compile")
        expect result.is_some()

    it "parses 'c' to Aot mode":
        val result = CompileMode.from_text("c")
        expect result.is_some()

    it "parses 'check' to Check mode":
        val result = CompileMode.from_text("check")
        expect result.is_some()
        expect result.unwrap() == CompileMode.Check

    it "parses 'k' to Check mode":
        val result = CompileMode.from_text("k")
        expect result.is_some()

    it "parses 'sdn' to Sdn mode":
        val result = CompileMode.from_text("sdn")
        expect result.is_some()
        expect result.unwrap() == CompileMode.Sdn

    it "parses 's' to Sdn mode":
        val result = CompileMode.from_text("s")
        expect result.is_some()

    it "parses 'data' to Sdn mode":
        val result = CompileMode.from_text("data")
        expect result.is_some()

    it "returns None for unknown mode":
        val result = CompileMode.from_text("unknown")
        expect result.is_none()

    it "returns None for empty string":
        val result = CompileMode.from_text("")
        expect result.is_none()

    it "returns None for invalid input":
        val result = CompileMode.from_text("xyz")
        expect result.is_none()


# ============================================================================
# Test Group 2: CompileOptions
# ============================================================================

describe "CompileOptions default":
    """
    Tests default compilation options.
    """

    it "creates default options with Interpret mode":
        val opts = CompileOptions.default()
        expect opts.mode == CompileMode.Interpret

    it "creates default options with empty input files":
        val opts = CompileOptions.default()
        expect opts.input_files.len() == 0

    it "creates default options with no output file":
        val opts = CompileOptions.default()
        expect opts.output_file.is_none()

    it "creates default options without optimization":
        val opts = CompileOptions.default()
        expect not opts.optimize

    it "creates default options with debug info":
        val opts = CompileOptions.default()
        expect opts.debug_info

    it "creates default options without verbose":
        val opts = CompileOptions.default()
        expect not opts.verbose

    it "creates default options with info log level":
        val opts = CompileOptions.default()
        expect opts.log_level == 4

    it "creates default options with dev profile":
        val opts = CompileOptions.default()
        expect opts.profile == "dev"


# ============================================================================
# Test Group 3: CompileResult - Success Case
# ============================================================================

describe "CompileResult Success":
    """
    Tests CompileResult.Success variant methods.
    """

    it "is_success returns true for Success":
        val result = CompileResult.Success(42)
        expect result.is_success()

    it "get_value returns value for Success":
        val result = CompileResult.Success(42)
        val value = result.get_value()
        expect value.is_some()
        expect value.unwrap() == 42

    it "get_value returns None for Success with None":
        val result = CompileResult.Success(nil)
        val value = result.get_value()
        expect value.is_none()

    it "get_errors returns empty list for Success":
        val result = CompileResult.Success(42)
        val errors = result.get_errors()
        expect errors.len() == 0


# ============================================================================
# Test Group 4: CompileResult - Error Cases
# ============================================================================

describe "CompileResult TypeError":
    """
    Tests CompileResult.TypeError variant methods.
    """

    it "is_success returns false for TypeError":
        val result = CompileResult.TypeError(["type error"])
        expect not result.is_success()

    it "get_value returns None for TypeError":
        val result = CompileResult.TypeError(["type error"])
        expect result.get_value().is_none()

    it "get_errors returns error list for TypeError":
        val result = CompileResult.TypeError(["error1", "error2"])
        val errors = result.get_errors()
        expect errors.len() == 2


describe "CompileResult ParseError":
    """
    Tests CompileResult.ParseError variant methods.
    """

    it "is_success returns false for ParseError":
        val result = CompileResult.ParseError(["parse error"])
        expect not result.is_success()

    it "get_value returns None for ParseError":
        val result = CompileResult.ParseError(["parse error"])
        expect result.get_value().is_none()

    it "get_errors returns error list for ParseError":
        val result = CompileResult.ParseError(["syntax error"])
        val errors = result.get_errors()
        expect errors.len() == 1


describe "CompileResult BlockError":
    """
    Tests CompileResult.BlockError variant methods.
    """

    it "is_success returns false for BlockError":
        val result = CompileResult.BlockError(["block error"])
        expect not result.is_success()

    it "get_value returns None for BlockError":
        val result = CompileResult.BlockError(["block error"])
        expect result.get_value().is_none()

    it "get_errors returns error list for BlockError":
        val result = CompileResult.BlockError(["resolution error"])
        val errors = result.get_errors()
        expect errors.len() == 1


describe "CompileResult ResolveError":
    """
    Tests CompileResult.ResolveError variant methods.
    """

    it "is_success returns false for ResolveError":
        val result = CompileResult.ResolveError(["resolve error"])
        expect not result.is_success()

    it "get_value returns None for ResolveError":
        val result = CompileResult.ResolveError(["resolve error"])
        expect result.get_value().is_none()

    it "get_errors returns error list for ResolveError":
        val result = CompileResult.ResolveError(["symbol not found"])
        val errors = result.get_errors()
        expect errors.len() == 1


describe "CompileResult CodegenError":
    """
    Tests CompileResult.CodegenError variant methods.
    """

    it "is_success returns false for CodegenError":
        val result = CompileResult.CodegenError("codegen failed")
        expect not result.is_success()

    it "get_value returns None for CodegenError":
        val result = CompileResult.CodegenError("codegen failed")
        expect result.get_value().is_none()

    it "get_errors returns single error for CodegenError":
        val result = CompileResult.CodegenError("code generation failed")
        val errors = result.get_errors()
        expect errors.len() == 1
        expect errors[0] == "code generation failed"


describe "CompileResult RuntimeError":
    """
    Tests CompileResult.RuntimeError variant methods.
    """

    it "is_success returns false for RuntimeError":
        val result = CompileResult.RuntimeError("runtime failed")
        expect not result.is_success()

    it "get_value returns None for RuntimeError":
        val result = CompileResult.RuntimeError("runtime failed")
        expect result.get_value().is_none()

    it "get_errors returns single error for RuntimeError":
        val result = CompileResult.RuntimeError("execution failed")
        val errors = result.get_errors()
        expect errors.len() == 1
        expect errors[0] == "execution failed"


# ============================================================================
# Test Group 5: Edge Cases
# ============================================================================

describe "CompileMode edge cases":
    """
    Edge cases for mode parsing and conversion.
    """

    it "handles case-sensitive mode parsing":
        val result = CompileMode.from_text("INTERPRET")
        expect result.is_none()

    it "handles whitespace in mode string":
        val result = CompileMode.from_text(" interpret ")
        expect result.is_none()

    it "handles numeric input":
        val result = CompileMode.from_text("123")
        expect result.is_none()


describe "CompileResult edge cases":
    """
    Edge cases for compilation results.
    """

    it "handles Success with zero value":
        val result = CompileResult.Success(0)
        expect result.is_success()
        expect result.get_value().unwrap() == 0

    it "handles TypeError with empty error list":
        val result = CompileResult.TypeError([])
        expect not result.is_success()
        expect result.get_errors().len() == 0

    it "handles very long error message":
        val long_msg = "error" * 100
        val result = CompileResult.CodegenError(long_msg)
        val errors = result.get_errors()
        expect errors[0].len() > 400
