# Type Inference - Intensive Correctness Tests
# Verifies Hindley-Milner type inference correctness

use compiler.type_infer.*
use compiler.hir.*
use sspec.*

describe "Type inference correctness":
    describe "Basic type inference":
        it "infers identity function type":
            val src = "fn id(x): x"
            val ty = infer_type(src)

            # Should be: forall a. a -> a
            assert ty.is_polymorphic()
            assert ty.param_count() == 1
            assert ty.return_type_equals_param(0)

        it "infers constant function":
            val src = "fn const_five(): 5"
            val ty = infer_type(src)

            # Should be: () -> i64
            assert ty.param_count() == 0
            assert ty.return_type().is_int()

        it "infers addition":
            val src = "fn add(x, y): x + y"
            val ty = infer_type(src)

            # Should be: i64 -> i64 -> i64
            # (assuming integer literals default to i64)
            assert ty.param_count() == 2

    describe "Let polymorphism":
        it "generalizes let-bound functions":
            val src = """
            fn test():
                val id = \x: x
                val a = id(5)
                val b = id("hello")
                a
            """
            val ty = infer_type(src)

            # id should be generalized and usable at multiple types
            # This should not error
            assert ty.is_ok()

        it "doesn't generalize mutable variables":
            val src = """
            fn test():
                var x = 5
                x = "hello"  # Should fail - x has type i64
            """
            val result = infer_type(src)

            assert result.is_err()

    describe "Unification":
        it "unifies same types":
            val src = """
            fn test(x: i64, y: i64):
                x == y
            """
            val ty = infer_type(src)
            assert ty.is_ok()

        it "fails to unify different types":
            val src = """
            fn test():
                val x: i64 = "string"
            """
            val result = infer_type(src)
            assert result.is_err()

        it "unifies generic types":
            val src = """
            fn apply<T, U>(f: fn(T) -> U, x: T) -> U:
                f(x)
            """
            val ty = infer_type(src)
            assert ty.is_ok()

    describe "Occurs check":
        it "detects infinite types":
            val src = """
            fn omega(x):
                x(x)
            """
            val result = infer_type(src)

            # Should fail with occurs check error
            # (x would need type: a -> b where a = a -> b)
            assert result.is_err()

    describe "Function composition":
        it "infers compose type":
            val src = """
            fn compose(f, g, x):
                f(g(x))
            """
            val ty = infer_type(src)

            # Should be: forall a b c. (b -> c) -> (a -> b) -> a -> c
            assert ty.is_ok()
            assert ty.is_polymorphic()
            assert ty.type_var_count() >= 3

    describe "Tuple types":
        it "infers tuple creation":
            val src = "fn make_pair(x, y): (x, y)"
            val ty = infer_type(src)

            # Should be: forall a b. a -> b -> (a, b)
            assert ty.is_ok()

        it "infers tuple projection":
            val src = "fn first(t): t.0"
            val ty = infer_type(src)

            # Should be: forall a b. (a, b) -> a
            assert ty.is_ok()

    describe "Array types":
        it "infers array creation":
            val src = "fn make_array(): [1, 2, 3]"
            val ty = infer_type(src)

            # Should be: () -> [i64]
            assert ty.return_type().is_array()

        it "infers array element type":
            val src = """
            fn first_elem(arr):
                arr[0]
            """
            val ty = infer_type(src)

            # Should be: forall a. [a] -> a?
            assert ty.is_ok()

    describe "Option types":
        it "infers Some construction":
            val src = "fn wrap(x): Some(x)"
            val ty = infer_type(src)

            # Should be: forall a. a -> a?
            assert ty.is_ok()

        it "infers None":
            val src = "fn nothing(): None"
            val ty = infer_type(src)

            # Should be: forall a. () -> a?
            assert ty.is_ok()

    describe "Recursive functions":
        it "infers factorial type":
            val src = """
            fn factorial(n):
                if n <= 1:
                    1
                else:
                    n * factorial(n - 1)
            """
            val ty = infer_type(src)

            # Should be: i64 -> i64
            assert ty.is_ok()

        it "infers list length type":
            val src = """
            fn length(list):
                match list:
                    case []: 0
                    case [head, ...tail]: 1 + length(tail)
            """
            val ty = infer_type(src)

            # Should be: forall a. [a] -> i64
            assert ty.is_ok()

    describe "Type annotations":
        it "respects explicit type annotations":
            val src = """
            fn add_ints(x: i64, y: i64) -> i64:
                x + y
            """
            val ty = infer_type(src)

            assert ty.is_ok()
            assert ty.param_types()[0].is_i64()
            assert ty.param_types()[1].is_i64()
            assert ty.return_type().is_i64()

        it "checks annotation compatibility":
            val src = """
            fn wrong(x: i64) -> text:
                x  # Error: i64 is not text
            """
            val result = infer_type(src)
            assert result.is_err()

    describe "Complex nested structures":
        it "infers map function type":
            val src = """
            fn map(f, list):
                match list:
                    case []: []
                    case [head, ...tail]:
                        [f(head), ...map(f, tail)]
            """
            val ty = infer_type(src)

            # Should be: forall a b. (a -> b) -> [a] -> [b]
            assert ty.is_ok()

        it "infers filter function type":
            val src = """
            fn filter(pred, list):
                match list:
                    case []: []
                    case [head, ...tail]:
                        if pred(head):
                            [head, ...filter(pred, tail)]
                        else:
                            filter(pred, tail)
            """
            val ty = infer_type(src)

            # Should be: forall a. (a -> bool) -> [a] -> [a]
            assert ty.is_ok()

    describe "Performance regression tests":
        it "handles deeply nested expressions":
            # Create expression: f(f(f(...f(x)...)))
            var src = "fn deep(f, x): "
            for _ in 0..100:
                src = src + "f("
            src = src + "x"
            for _ in 0..100:
                src = src + ")"

            val start = time.now()
            val ty = infer_type(src)
            val elapsed = time.now() - start

            assert ty.is_ok()
            # Should complete in < 100ms
            assert elapsed < 100.ms

        it "handles many variables":
            # Create function with many independent variables
            var src = "fn many_vars("
            for i in 0..100:
                src = src + "x{i}, "
            src = src + "x100): x0"

            val start = time.now()
            val ty = infer_type(src)
            val elapsed = time.now() - start

            assert ty.is_ok()
            # Should complete in < 50ms
            assert elapsed < 50.ms

        it "handles complex generic constraints":
            val src = """
            fn complex<T, U, V>(
                f: fn(T) -> U,
                g: fn(U) -> V,
                h: fn(V) -> T,
                x: T
            ) -> V:
                g(f(x))
            """

            val start = time.now()
            val ty = infer_type(src)
            val elapsed = time.now() - start

            assert ty.is_ok()
            assert elapsed < 10.ms

    describe "Substitution correctness":
        it "applies substitutions correctly":
            # Test that substitution chains are resolved
            val ctx = HmInferContext.new()

            val t1 = ctx.fresh_var()
            val t2 = ctx.fresh_var()
            val t3 = ctx.fresh_var()

            # Create chain: t1 -> t2 -> t3 -> i64
            ctx.unify(t1, t2)
            ctx.unify(t2, t3)
            ctx.unify(t3, HirType.i64())

            # Resolve t1 should give i64
            val resolved = ctx.resolve(t1)
            assert resolved.is_i64()

    describe "Level-based generalization":
        it "respects generalization levels":
            val src = """
            fn test():
                val outer = \x: x
                fn inner():
                    val inner_var = outer(5)
                    inner_var
                inner()
            """

            val ty = infer_type(src)
            assert ty.is_ok()

    describe "Error messages":
        it "provides clear unification errors":
            val src = """
            fn bad():
                val x: i64 = "string"
            """

            val result = infer_type(src)
            assert result.is_err()

            val err = result.unwrap_err()
            assert err.contains("type mismatch")
            assert err.contains("i64")
            assert err.contains("text")

# Helper functions
fn infer_type(source: text) -> TypeResult:
    val ast = parse(source)
    val hir = lower_to_hir(ast)
    type_infer_hir(hir)
