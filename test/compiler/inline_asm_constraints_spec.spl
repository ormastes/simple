# Inline Assembly Constraints Specification
#
# Detailed tests for inline assembly constraint parsing and semantics.
# Tests constraint combinations, edge cases, and validation.

describe "Constraint Kind Semantics":
    it "in constraint is read-only":
        val code = """
        unsafe:
            asm("mov eax, {val}", val = in(reg) input_value)
        """
        # Input constraint: value is read from input_value
        assert code.contains("in(reg)")

    it "out constraint is write-only":
        val code = """
        var result: u32
        unsafe:
            asm("mov {res}, eax", res = out(reg) result)
        """
        # Output constraint: value is written to result
        assert code.contains("out(reg)")

    it "inout constraint is read-write":
        val code = """
        var value: u32 = 5
        unsafe:
            asm("add {val}, 1", val = inout(reg) value)
        """
        # InOut: reads initial value, writes back modified
        assert code.contains("inout(reg)")

    it "lateout constraint prevents early clobber":
        val code = """
        var result: u32
        unsafe:
            asm(
                "operation {res}, {in}",
                res = lateout(reg) result,
                in = in(reg) input
            )
        """
        # LateOut: output register not clobbered until after inputs read
        assert code.contains("lateout(reg)")

describe "Location Specifier Semantics":
    it "reg allows any general-purpose register":
        val code = """
        unsafe:
            asm("", x = in(reg) value)
        """
        # Compiler chooses any available register
        assert code.contains("in(reg)")

    it "specific register constrains allocation":
        val code = """
        unsafe:
            asm("", x = in("eax") value)
        """
        # Must use eax register specifically
        assert code.contains("in(\"eax\")")

    it "mem allows memory operand":
        val code = """
        unsafe:
            asm("lock add {ptr}, 1", ptr = in(mem) address)
        """
        # Can use memory location directly
        assert code.contains("in(mem)")

    it "imm requires compile-time constant":
        val code = """
        unsafe:
            asm("shl eax, {shift}", shift = in(imm) 5)
        """
        # Immediate value (constant)
        assert code.contains("in(imm)")

describe "Multiple Constraints":
    it "supports multiple inputs":
        val code = """
        unsafe:
            asm(
                "add {a}, {b}",
                a = inout(reg) x,
                b = in(reg) y
            )
        """
        assert code.contains("inout(reg)")
        assert code.contains("in(reg)")

    it "supports multiple outputs":
        val code = """
        var quotient: u32
        var remainder: u32
        unsafe:
            asm(
                "div {divisor}",
                quot = out("eax") quotient,
                rem = out("edx") remainder,
                divisor = in(reg) divisor,
                in("eax") dividend
            )
        """
        assert code.contains("out(\"eax\")")
        assert code.contains("out(\"edx\")")

    it "supports mixed constraint kinds":
        val code = """
        var result: u32
        unsafe:
            asm(
                "operation",
                result = lateout(reg) result,
                input1 = in(reg) a,
                input2 = in(reg) b,
                temp = inout(reg) scratch
            )
        """
        # Mix of lateout, in, and inout
        assert code.contains("lateout(reg)")

describe "Constraint Placeholders":
    it "uses named placeholders in template":
        val code = """
        unsafe:
            asm("mov {dest}, {src}", dest = out(reg) d, src = in(reg) s)
        """
        # {dest} and {src} reference constraint names
        assert code.contains("{dest}")
        assert code.contains("{src}")

    it "supports numbered placeholders":
        val code = """
        unsafe:
            asm("add {0}, {1}", a = inout(reg) x, b = in(reg) y)
        """
        # {0} = first operand, {1} = second operand
        assert code.contains("{0}")
        assert code.contains("{1}")

describe "Clobber Specifications":
    it "specifies clobber_abi for ABI preservation":
        val code = """
        unsafe:
            asm("call external_func", clobber_abi("C"))
        """
        # Clobbers all caller-saved registers per C ABI
        assert code.contains("clobber_abi(\"C\")")

    it "allows multiple clobber specifications":
        val code = """
        unsafe:
            asm(
                "complex operation",
                out = out(reg) result,
                clobber_abi("C")
            )
        """
        assert code.contains("clobber_abi")

describe "Volatile Flag":
    it "prevents optimization with volatile":
        val code = """
        unsafe:
            asm volatile("nop")
        """
        # Compiler must not remove or reorder this instruction
        assert code.contains("volatile")

    it "omits volatile for pure operations":
        val code = """
        var result: u32
        unsafe:
            asm("bswap {val}", val = inout(reg) result)
        """
        # Non-volatile: can be optimized if result unused
        assert not code.contains("volatile")

    it "requires volatile for side effects":
        val code = """
        unsafe:
            asm volatile("out dx, al", in("dx") port, in("al") value)
        """
        # I/O operations must be volatile
        assert code.contains("volatile")

describe "Architecture-Specific Constraints":
    it "uses x86 register names":
        val regs = ["eax", "ebx", "ecx", "edx", "esi", "edi", "ebp", "esp"]
        for reg in regs:
            val code = "asm(\"\", x = in(\"{reg}\") v)".replace("{reg}", reg)
            assert code.contains(reg)

    it "uses x86-64 extended registers":
        val regs = ["rax", "rbx", "r8", "r9", "r10", "r15"]
        for reg in regs:
            val code = "asm(\"\", x = in(\"{reg}\") v)".replace("{reg}", reg)
            assert code.contains(reg)

    it "uses ARM register names":
        val regs = ["r0", "r1", "r7", "r12", "lr", "sp"]
        for reg in regs:
            val code = "asm(\"\", x = in(\"{reg}\") v)".replace("{reg}", reg)
            assert code.contains(reg)

    it "uses RISC-V register names":
        val regs = ["a0", "a1", "t0", "t1", "s0", "ra", "sp"]
        for reg in regs:
            val code = "asm(\"\", x = in(\"{reg}\") v)".replace("{reg}", reg)
            assert code.contains(reg)

describe "Complex Real-World Examples":
    it "implements system call (x86-64)":
        val code = """
        fn syscall(num: u64, arg1: u64, arg2: u64) -> u64:
            var result: u64
            unsafe:
                asm volatile(
                    "syscall",
                    result = lateout("rax") result,
                    in("rax") num,
                    in("rdi") arg1,
                    in("rsi") arg2,
                    clobber_abi("C")
                )
            result
        """
        assert code.contains("syscall")
        assert code.contains("lateout(\"rax\")")

    it "implements CPUID instruction":
        val code = """
        fn cpuid(leaf: u32) -> (u32, u32, u32, u32):
            var eax: u32
            var ebx: u32
            var ecx: u32
            var edx: u32
            unsafe:
                asm(
                    "cpuid",
                    out_eax = lateout("eax") eax,
                    out_ebx = lateout("ebx") ebx,
                    out_ecx = lateout("ecx") ecx,
                    out_edx = lateout("edx") edx,
                    in("eax") leaf,
                    in("ecx") 0
                )
            (eax, ebx, ecx, edx)
        """
        assert code.contains("cpuid")

    it "implements RDTSC timestamp counter":
        val code = """
        fn rdtsc() -> u64:
            var low: u32
            var high: u32
            unsafe:
                asm(
                    "rdtsc",
                    low = out("eax") low,
                    high = out("edx") high
                )
            (high as u64) << 32 | (low as u64)
        """
        assert code.contains("rdtsc")

    it "implements atomic exchange":
        val code = """
        fn atomic_swap(ptr: *mut u32, new_val: u32) -> u32:
            var old: u32
            unsafe:
                asm(
                    "xchg {new}, {ptr}",
                    ptr = in(reg) ptr,
                    new = inout(reg) new_val => old
                )
            old
        """
        assert code.contains("xchg")

describe "Edge Cases":
    it "handles empty template":
        val code = """
        unsafe:
            asm("", clobber_abi("C"))
        """
        # Empty asm with only clobbers
        assert code.contains("\"\"")

    it "handles template with special characters":
        val code = """
        unsafe:
            asm("test $0x80, %al")
        """
        # AT&T syntax with $ and %
        assert code.contains("$0x80")

    it "handles multiline template":
        val code = """
        unsafe:
            asm(
                "push ebx",
                "mov ebx, {val}",
                "pop ebx",
                val = in(reg) value
            )
        """
        # Each line is separate argument
        assert code.contains("push ebx")

    it "handles constraint without operand name":
        val code = """
        unsafe:
            asm("nop", in("eax") value)
        """
        # Anonymous constraint (uses register directly)
        assert code.contains("in(\"eax\")")
