# Direct unit test for compiler_ffi module
# Tests the Pure Simple implementation without dependencies

# Import just what we need
use compiler.loader.compiler_ffi.*

fn test_all():
    test_raw_functions()
    test_wrapper_api()
    print "All tests passed!"

fn test_raw_functions():
    # Test 1: Create context
    val handle = compiler_create_context()
    assert handle > 0, "Context handle should be positive"

    # Test 2: Infer types
    val template_json = '{"name":"id","type_params":["T"]}'
    val hints_json = '[{"source":"call_site","ty":{"kind":"int","bits":64}}]'
    val types = compiler_infer_types(handle, template_json, hints_json)
    assert types.contains("int"), "Should infer int type"

    # Test 3: Instantiate template
    val types_json = '[{"kind":"int","bits":64}]'
    val result = compiler_instantiate_template(handle, template_json, types_json)
    assert result.contains('"success":true'), "Should succeed"
    assert result.contains('"code"'), "Should have code"

    # Test 4: Get stats
    val stats = compiler_get_stats(handle)
    assert stats.contains("type_inferences"), "Should have stats"

    # Test 5: Destroy context
    compiler_destroy_context(handle)

fn test_wrapper_api():
    # Test CompilerContext wrapper
    val ctx = CompilerContext.create()
    assert ctx.handle > 0, "Wrapper handle should be positive"

    val template_json = '{"name":"test","type_params":["T"]}'
    val hints_json = '[{"source":"call_site","ty":{"kind":"float","bits":64}}]'
    val types = ctx.infer_types_json(template_json, hints_json)
    assert types.contains("float"), "Should infer float type"

    ctx.destroy()

fn assert(condition: bool, message: text):
    if not condition:
        error "Assertion failed: {message}"

# Run tests
test_all()
