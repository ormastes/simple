# @platform: all
# Contract Testing Framework Tests
# Tests for Pact-style consumer-driven contract testing
# Implementation: src/lib/common/contract.spl (use std.common.contract)

use lib.common.contract.{create_contract_builder, create_matcher_like, create_matcher_term, create_matcher_each_like, create_mock_server, create_contract_verifier, create_pact_broker}

describe "Contract Testing":
    context "ContractBuilder (Consumer side)":
        it "creates contract for consumer and provider":
            val builder = create_contract_builder("web-app", "user-api")
            expect(builder.consumer).to_equal("web-app")
            expect(builder.provider).to_equal("user-api")

        it "defines provider state":
            val builder = create_contract_builder("web-app", "user-api")
            val with_state = builder.given("user 123 exists")
            expect(with_state.current_state.is_some()).to_equal(true)

        it "defines interaction":
            val contract = create_contract_builder("web-app", "user-api")
                .given("user 123 exists")
                .upon_receiving("request for user 123")
                .with_request(method="GET", path="/users/123")
                .will_respond_with()
                .status(200)
                .build()
            expect(contract.interactions.len()).to_equal(1)

    context "Request building":
        it "builds GET request":
            val contract = create_contract_builder("app", "api")
                .given("data exists")
                .upon_receiving("get request")
                .with_request(method="GET", path="/data")
                .will_respond_with()
                .status(200)
                .build()
            expect(contract.interactions.len()).to_equal(1)

        it "builds POST request with body":
            val contract = create_contract_builder("app", "api")
                .given("ready to create")
                .upon_receiving("create request")
                .with_request(method="POST", path="/users")
                .with_body("name=Alice")
                .will_respond_with()
                .status(201)
                .build()
            expect(contract.interactions.len()).to_equal(1)

        it "adds request headers":
            val contract = create_contract_builder("app", "api")
                .given("authenticated")
                .upon_receiving("authorized request")
                .with_request(method="GET", path="/protected")
                .with_header(key="Authorization", value="Bearer token123")
                .will_respond_with()
                .status(200)
                .build()
            expect(contract.interactions.len()).to_equal(1)

    context "Response building":
        it "builds response with status":
            val contract = create_contract_builder("app", "api")
                .given("exists")
                .upon_receiving("request")
                .with_request(method="GET", path="/resource")
                .will_respond_with()
                .status(200)
                .build()
            expect(contract.consumer).to_equal("app")

        it "builds response with body":
            val contract = create_contract_builder("app", "api")
                .given("user exists")
                .upon_receiving("get user")
                .with_request(method="GET", path="/users/1")
                .will_respond_with()
                .status(200)
                .with_response_body("id=1, name=Alice")
                .build()
            expect(contract.provider).to_equal("api")

        it "adds response headers":
            val contract = create_contract_builder("app", "api")
                .given("exists")
                .upon_receiving("request")
                .with_request(method="GET", path="/data")
                .will_respond_with()
                .status(200)
                .with_response_header(key="Content-Type", value="application/json")
                .build()
            expect(contract.interactions.len()).to_equal(1)

    context "Matchers (flexible matching)":
        it "like() matches type not value":
            val matcher = create_matcher_like("Alice")
            expect(matcher.match_type).to_equal("like")
            expect(matcher.example).to_equal("Alice")

        it "term() matches regex pattern":
            val matcher = create_matcher_term("\\d{3}", "123")
            expect(matcher.match_type).to_equal("term")
            expect(matcher.regex.is_some()).to_equal(true)

        it "each_like() matches array structure":
            val json_str = "id=1, name=Example"
            val matcher = create_matcher_each_like(json_str)
            expect(matcher.match_type).to_equal("each_like")
            expect(matcher.example).to_equal(json_str)

    context "Contract persistence":
        it "saves contract to JSON file":
            val contract = create_contract_builder("web-app", "user-api")
                .given("user exists")
                .upon_receiving("get user")
                .with_request(method="GET", path="/users/1")
                .will_respond_with()
                .status(200)
                .build()
            val result = contract.save("/tmp/test-contract.json")
            expect(result.is_ok()).to_equal(true)

        it "generates Pact-compatible JSON":
            val contract = create_contract_builder("consumer", "provider")
                .given("state")
                .upon_receiving("request")
                .with_request(method="GET", path="/api")
                .will_respond_with()
                .status(200)
                .build()
            val json = contract.to_pact_json()
            expect(json.contains("consumer")).to_equal(true)
            expect(json.contains("provider")).to_equal(true)

    context "Mock server":
        it "creates mock server from contract":
            val contract = create_contract_builder("app", "api")
                .given("ready")
                .upon_receiving("request")
                .with_request(method="GET", path="/test")
                .will_respond_with()
                .status(200)
                .with_response_body("result=ok")
                .build()
            val mock_server = create_mock_server(contract)
            expect(mock_server.get_url()).to_equal("http://mock.local:0")

        it "mock server responds to requests":
            val contract = create_contract_builder("app", "api")
                .given("ready")
                .upon_receiving("request")
                .with_request(method="GET", path="/data")
                .will_respond_with()
                .status(200)
                .with_response_body("data=value")
                .build()
            val mock_srv = create_mock_server(contract)
            val resp = mock_srv.simulate_request(method="GET", path="/data")
            expect(resp.status).to_equal(200)

        it "verifies all interactions matched":
            val contract = create_contract_builder("app", "api")
                .given("ready")
                .upon_receiving("must call this")
                .with_request(method="GET", path="/required")
                .will_respond_with()
                .status(200)
                .build()
            val mock_srv = create_mock_server(contract)
            mock_srv.simulate_request(method="GET", path="/required")
            expect(mock_srv.verify()).to_equal(true)

    context "Provider verification":
        it "verifies provider against contract":
            val verifier = create_contract_verifier()
                .with_provider("user-api")
                .with_contract_file("pacts/web-app-user-api.json")
                .with_provider_base_url("http://localhost:8080")
            val result = verifier.verify()
            expect(result).to_equal(true)

        it "sets up provider states":
            val verifier = create_contract_verifier()
                .with_provider("user-api")
                .with_contract_file("pacts/web-app-user-api.json")
                .with_provider_base_url("http://localhost:8080")
            val result = verifier.verify()
            expect(result).to_equal(true)

    context "Pact Broker integration":
        it "publishes contract to broker":
            val contract = create_contract_builder("app", "api")
                .given("ready")
                .upon_receiving("request")
                .with_request(method="GET", path="/api")
                .will_respond_with()
                .status(200)
                .build()
            val broker = create_pact_broker("https://broker.example.com")
            val result = broker.publish(contract, "1.0.0")
            expect(result.is_ok()).to_equal(true)

        it "fetches contracts from broker":
            val broker = create_pact_broker("https://broker.example.com")
            val contract = create_contract_builder("app", "api")
                .given("ready")
                .upon_receiving("request")
                .with_request(method="GET", path="/api")
                .will_respond_with()
                .status(200)
                .build()
            broker.publish(contract, "1.0.0")
            val contracts = broker.fetch_for_provider("api")
            expect(contracts.len()).to_equal(1)

        it "counts contracts in broker":
            val broker = create_pact_broker("https://broker.example.com")
            val contract = create_contract_builder("app", "api")
                .given("ready")
                .upon_receiving("request")
                .with_request(method="GET", path="/api")
                .will_respond_with()
                .status(200)
                .build()
            broker.publish(contract, "1.0.0")
            expect(broker.count()).to_equal(1)
