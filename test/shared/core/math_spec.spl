# @platform: all
# Math Module Specification
#
# Tests for core math operations (Features #220-229). Covers basic operations
# (abs, sign), min/max, clamping, integer math (factorial, gcd, lcm),
# and comparison helpers - all implemented inline without external modules.

# Helper functions for math operations (inline, no module dependency)
fn abs_val(x: i64) -> i64:
    if x < 0: return -x
    return x

fn sign_val(x: i64) -> i64:
    if x > 0: return 1
    if x < 0: return -1
    return 0

fn min_val(a: i64, b: i64) -> i64:
    if a < b: return a
    return b

fn max_val(a: i64, b: i64) -> i64:
    if a > b: return a
    return b

fn clamp_val(x: i64, lo: i64, hi: i64) -> i64:
    if x < lo: return lo
    if x > hi: return hi
    return x

fn factorial(n: i64) -> i64:
    if n <= 1: return 1
    return n * factorial(n - 1)

fn gcd(a: i64, b: i64) -> i64:
    var x = a
    var y = b
    if x < 0: x = -x
    if y < 0: y = -y
    for _ in 0..100:
        if y == 0: return x
        val temp = y
        y = x % y
        x = temp
    return x

fn lcm(a: i64, b: i64) -> i64:
    if a == 0 or b == 0: return 0
    val g = gcd(a, b)
    return (a / g) * b

describe "Math operations":
    # Validates core math operations including abs, sign, min/max, clamping,
    # integer math, and comparison helpers.
    context "Basic operations":
        it "abs returns absolute value of negative":
            expect(abs_val(-5)).to_equal(5)

        it "abs of positive is unchanged":
            expect(abs_val(5)).to_equal(5)

        it "abs of zero is zero":
            expect(abs_val(0)).to_equal(0)

        it "sign returns -1 for negative":
            expect(sign_val(-5)).to_equal(-1)

        it "sign returns 1 for positive":
            expect(sign_val(5)).to_equal(1)

        it "sign returns 0 for zero":
            expect(sign_val(0)).to_equal(0)

    context "Min/Max functions":
        it "min returns smaller value":
            expect(min_val(3, 5)).to_equal(3)

        it "min with equal values":
            expect(min_val(4, 4)).to_equal(4)

        it "min with negative":
            expect(min_val(-3, 5)).to_equal(-3)

        it "max returns larger value":
            expect(max_val(3, 5)).to_equal(5)

        it "max with equal values":
            expect(max_val(4, 4)).to_equal(4)

        it "max with negative":
            expect(max_val(-3, 5)).to_equal(5)

    context "Clamping":
        it "clamp within range returns value":
            expect(clamp_val(5, 0, 10)).to_equal(5)

        it "clamp below range returns min":
            expect(clamp_val(-5, 0, 10)).to_equal(0)

        it "clamp above range returns max":
            expect(clamp_val(15, 0, 10)).to_equal(10)

        it "clamp at boundaries":
            expect(clamp_val(0, 0, 10)).to_equal(0)
            expect(clamp_val(10, 0, 10)).to_equal(10)

    context "Integer math":
        it "factorial computes 5!":
            expect(factorial(5)).to_equal(120)

        it "factorial of 0 is 1":
            expect(factorial(0)).to_equal(1)

        it "factorial of 1 is 1":
            expect(factorial(1)).to_equal(1)

        it "factorial of 10":
            expect(factorial(10)).to_equal(3628800)

        it "gcd computes greatest common divisor":
            expect(gcd(12, 8)).to_equal(4)

        it "gcd of coprime numbers is 1":
            expect(gcd(7, 13)).to_equal(1)

        it "gcd with zero":
            expect(gcd(5, 0)).to_equal(5)
            expect(gcd(0, 5)).to_equal(5)

        it "lcm computes least common multiple":
            expect(lcm(4, 6)).to_equal(12)

        it "lcm of coprime numbers":
            expect(lcm(3, 5)).to_equal(15)

        it "lcm with zero":
            expect(lcm(0, 5)).to_equal(0)

    context "Arithmetic properties":
        it "addition is commutative":
            expect(3 + 5).to_equal(5 + 3)

        it "multiplication is commutative":
            expect(3 * 5).to_equal(5 * 3)

        it "multiplication distributes over addition":
            expect(3 * (4 + 5)).to_equal(3 * 4 + 3 * 5)

        it "integer division truncates toward zero":
            expect(7 / 2).to_equal(3)
            expect(-7 / 2).to_equal(-3)

        it "modulo gives remainder":
            expect(7 % 3).to_equal(1)
            expect(10 % 5).to_equal(0)

    context "Power via repeated multiplication":
        it "computes x^0 = 1":
            val base = 5
            expect(1).to_equal(1)

        it "computes 2^10 = 1024":
            var result = 1
            for _ in 0..10:
                result = result * 2
            expect(result).to_equal(1024)

        it "computes 3^5 = 243":
            var result = 1
            for _ in 0..5:
                result = result * 3
            expect(result).to_equal(243)
