# Database Core Components Tests
#
# Tests low-level database components: StringInterner, SdnRow, SdnTable, SdnDatabase

use lib.database.core.{StringInterner, SdnTable, SdnRow, SdnDatabase}

extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_file_write_text(path: text, content: text) -> bool
fn file_exists(path: text) -> bool:
    rt_file_exists(path)
fn file_delete(path: text) -> bool:
    rt_file_delete(path)
fn file_write(path: text, content: text) -> bool:
    rt_file_write_text(path, content)

describe "StringInterner":
    it "interns same string to same ID":
        var interner = StringInterner.empty()

        val id1 = interner.intern("test")
        val id2 = interner.intern("test")

        assert id1 == id2

    it "interns different strings to different IDs":
        var interner = StringInterner.empty()

        val id1 = interner.intern("first")
        val id2 = interner.intern("second")

        assert id1 != id2

    it "lookups strings by ID":
        var interner = StringInterner.empty()

        val id = interner.intern("lookup_test")
        val result = interner.lookup(id)

        assert result.?
        assert result? == "lookup_test"

    it "lookups IDs by string":
        var interner = StringInterner.empty()

        val id = interner.intern("reverse_lookup")
        val result = interner.get_id("reverse_lookup")

        assert result.?
        assert result? == id

    it "returns None for unknown ID":
        val interner = StringInterner.empty()

        val result = interner.lookup(999)
        assert not result.?

    it "returns None for unknown string":
        val interner = StringInterner.empty()

        val result = interner.get_id("nonexistent")
        assert not result.?

    it "handles empty strings":
        var interner = StringInterner.empty()

        val id = interner.intern("")
        val result = interner.lookup(id)

        assert result.?
        assert result? == ""

    it "handles unicode strings":
        var interner = StringInterner.empty()

        val id = interner.intern("Hello ‰∏ñÁïå üåç")
        val result = interner.lookup(id)

        assert result.?
        assert result?.contains("‰∏ñÁïå")

    it "increments ID counter":
        var interner = StringInterner.empty()

        assert interner.next_id == 0

        interner.intern("first")
        assert interner.next_id == 1

        interner.intern("second")
        assert interner.next_id == 2

        # Interning same string doesn't increment
        interner.intern("first")
        assert interner.next_id == 2

describe "SdnRow":
    it "creates empty row":
        val row = SdnRow.empty()
        assert row.fields.len() == 0

    it "sets and gets field values":
        var row = SdnRow.empty()

        row.set("name", "Alice")
        row.set("age", "30")

        assert row.get("name")? == "Alice"
        assert row.get("age")? == "30"

    it "returns None for missing field":
        val row = SdnRow.empty()
        val result = row.get("nonexistent")

        assert not result.?

    it "gets field as i64":
        var row = SdnRow.empty()
        row.set("count", "42")

        val result = row.get_i64("count")
        assert result.?
        assert result? == 42

    it "gets field as bool":
        var row = SdnRow.empty()
        row.set("flag", "true")
        row.set("other", "false")

        assert row.get_bool("flag")?
        assert not row.get_bool("other")?

    it "handles large field values":
        var row = SdnRow.empty()

        val large_text = "x".repeat(10000)
        row.set("large", large_text)

        val result = row.get("large")?
        assert result.len() == 10000

    it "overwrites existing field":
        var row = SdnRow.empty()

        row.set("key", "old_value")
        row.set("key", "new_value")

        assert row.get("key")? == "new_value"

describe "SdnTable":
    it "creates table with schema":
        val table = SdnTable.new("users", ["id", "name", "email"])

        assert table.name == "users"
        assert table.columns.len() == 3
        assert table.rows.len() == 0

    it "adds row to table":
        var table = SdnTable.new("items", ["id", "value"])

        var row = SdnRow.empty()
        row.set("id", "1")
        row.set("value", "test")

        table.add_row(row)
        assert table.rows.len() == 1

    it "adds multiple rows":
        var table = SdnTable.new("data", ["key", "value"])

        for i in 0..5:
            var row = SdnRow.empty()
            row.set("key", "key_{i}")
            row.set("value", "value_{i}")
            table.add_row(row)

        assert table.rows.len() == 5

    it "gets row by ID":
        var table = SdnTable.new("records", ["id", "data"])

        var row = SdnRow.empty()
        row.set("id", "record_123")
        row.set("data", "test_data")
        table.add_row(row)

        val result = table.get_row("record_123")
        assert result.?
        assert result?.get("data")? == "test_data"

    it "returns None for missing row ID":
        val table = SdnTable.new("empty", ["id"])
        val result = table.get_row("nonexistent")

        assert not result.?

    it "marks row as deleted":
        var table = SdnTable.new("soft_delete", ["id", "value", "valid"])

        var row = SdnRow.empty()
        row.set("id", "delete_me")
        row.set("value", "data")
        row.set("valid", "true")
        table.add_row(row)

        # Mark as deleted
        table.mark_deleted("delete_me")

        # Row still exists but marked invalid
        val result = table.get_row("delete_me")
        assert result.?
        assert result?.get("valid")? == "false"

    it "filters valid rows only":
        var table = SdnTable.new("mixed", ["id", "valid"])

        # Add some valid and invalid rows
        for i in 0..5:
            var row = SdnRow.empty()
            row.set("id", "row_{i}")
            val valid_str = if i % 2 == 0: "true" else: "false"
            row.set("valid", valid_str)
            table.add_row(row)

        val valid_rows = table.valid_rows()
        assert valid_rows.len() == 3  # Rows 0, 2, 4

    it "handles empty table":
        val table = SdnTable.new("empty", ["id"])

        assert table.rows.len() == 0
        assert table.valid_rows().len() == 0

        val result = table.get_row("any_id")
        assert not result.?

describe "SdnDatabase":
    it "creates new database":
        val db = SdnDatabase.new("/tmp/test_new_db.sdn")

        assert db.tables.len() == 0

    it "adds table to database":
        var db = SdnDatabase.new("/tmp/test_add_table.sdn")

        val table = SdnTable.new("test_table", ["id", "value"])
        db.set_table("test_table", table)

        assert db.tables.len() == 1
        assert db.tables.contains_key("test_table")

    it "gets table from database":
        var db = SdnDatabase.new("/tmp/test_get_table.sdn")

        val table = SdnTable.new("my_table", ["col1", "col2"])
        db.set_table("my_table", table)

        val result = db.get_table("my_table")
        assert result.?
        assert result?.name == "my_table"

    it "gets mutable table":
        var db = SdnDatabase.new("/tmp/test_mut_table.sdn")

        val table = SdnTable.new("mut_table", ["id"])
        db.set_table("mut_table", table)

        var table_opt = db.get_table_mut("mut_table")
        assert table_opt.?

        var mut_table = table_opt?
        var row = SdnRow.empty()
        row.set("id", "test")
        mut_table.add_row(row)

        # Must put back for changes to persist
        db.set_table("mut_table", mut_table)

        # Verify change persisted
        val final_table = db.get_table("mut_table")?
        assert final_table.rows.len() == 1

    it "returns None for missing table":
        val db = SdnDatabase.new("/tmp/test_missing.sdn")

        val result = db.get_table("nonexistent")
        assert not result.?

    it "replaces existing table":
        var db = SdnDatabase.new("/tmp/test_replace.sdn")

        # Add initial table
        val table1 = SdnTable.new("replaceable", ["old_col"])
        db.set_table("replaceable", table1)

        # Replace with new table
        val table2 = SdnTable.new("replaceable", ["new_col"])
        db.set_table("replaceable", table2)

        # Verify replacement
        val result = db.get_table("replaceable")?
        assert result.columns.len() == 1
        assert result.columns[0] == "new_col"

    it "saves and loads database":
        val db_path = "/tmp/test_save_load.sdn"

        # Clean up if exists
        if file_exists(db_path):
            file_delete(db_path)

        # Create and populate database
        var db1 = SdnDatabase.new(db_path)
        var table = SdnTable.new("test", ["id", "value"])

        var row = SdnRow.empty()
        row.set("id", "save_001")
        row.set("value", "test_value")
        table.add_row(row)

        db1.set_table("test", table)
        db1.save()

        # Load database
        val db2_opt = SdnDatabase.load(db_path)
        assert db2_opt.?

        val db2 = db2_opt?
        val loaded_table = db2.get_table("test")?
        assert loaded_table.rows.len() == 1

        val loaded_row = loaded_table.get_row("save_001")?
        assert loaded_row.get("value")? == "test_value"

        # Cleanup
        file_delete(db_path)

    it "handles multiple tables":
        var db = SdnDatabase.new("/tmp/test_multi_tables.sdn")

        # Add multiple tables
        for i in 0..5:
            val table = SdnTable.new("table_{i}", ["col_{i}"])
            db.set_table("table_{i}", table)

        assert db.tables.len() == 5

        # Verify all tables accessible
        for i in 0..5:
            val table_opt = db.get_table("table_{i}")
            assert table_opt.?

    it "preserves table order":
        var db = SdnDatabase.new("/tmp/test_table_order.sdn")

        val names = ["first", "second", "third"]
        for name in names:
            val table = SdnTable.new(name, ["id"])
            db.set_table(name, table)

        # Tables should be accessible in any order
        assert db.get_table("first").?
        assert db.get_table("second").?
        assert db.get_table("third").?

describe "Database Integration":
    it "combines interner with database":
        var db = SdnDatabase.new("/tmp/test_interner_db.sdn")
        var interner = StringInterner.empty()

        # Intern column names
        val col_id = interner.intern("id")
        val col_name = interner.intern("name")

        # Create table with interned names
        var table = SdnTable.new("users", ["id", "name"])

        # Add row
        var row = SdnRow.empty()
        row.set(interner.lookup(col_id)?, "user_1")
        row.set(interner.lookup(col_name)?, "Alice")
        table.add_row(row)

        db.set_table("users", table)

        # Verify
        val saved_table = db.get_table("users")?
        assert saved_table.rows.len() == 1

    it "handles large number of rows efficiently":
        var db = SdnDatabase.new("/tmp/test_large_db.sdn")
        var table = SdnTable.new("large", ["id", "data"])

        # Add 1000 rows
        for i in 0..1000:
            var row = SdnRow.empty()
            row.set("id", "row_{i}")
            row.set("data", "data_{i}")
            table.add_row(row)

        db.set_table("large", table)

        # Verify
        val result = db.get_table("large")?
        assert result.rows.len() == 1000

        # Spot check
        val row_500 = result.get_row("row_500")?
        assert row_500.get("data")? == "data_500"
