# Database Query Intensive Testing
# Tests for bug database query operations and filtering

# use std.database.core.{StringInterner, SdnTable, SdnRow, SdnDatabase}
# use std.database.bug.{BugDatabase, Bug, BugSeverity, BugStatus}
# use test.lib.database_fixtures.{generate_simple_bug, cleanup_test_file}
fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")

fn cleanup_test_file(path: text):
    pass

class BugSeverity:
    value: text
    static fn P0() -> BugSeverity: BugSeverity(value: "P0")
    static fn P1() -> BugSeverity: BugSeverity(value: "P1")
    static fn P2() -> BugSeverity: BugSeverity(value: "P2")
    static fn P3() -> BugSeverity: BugSeverity(value: "P3")

class BugStatus:
    value: text
    static fn Open() -> BugStatus: BugStatus(value: "Open")
    static fn Fixed() -> BugStatus: BugStatus(value: "Fixed")
    static fn Investigating() -> BugStatus: BugStatus(value: "Investigating")
    static fn Closed() -> BugStatus: BugStatus(value: "Closed")

class Bug:
    id: text
    severity: BugSeverity
    status: BugStatus
    title: text
    description: [text]
    file: text
    line: i64
    reproducible_by: text
    fix_strategy: [text]
    investigation_log: [text]
    created_at: i64
    updated_at: i64
    valid: bool

class BugDatabase:
    bugs: {text: Bug}
    path: text
    me add_bug(bug: Bug) -> bool:
        self.bugs[bug.id] = bug
        true
    fn all_bugs() -> [Bug]:
        var result = []
        for k in self.bugs.keys():
            result = result + [self.bugs[k]]
        result
    fn open_bugs() -> [Bug]:
        var result = []
        for k in self.bugs.keys():
            val bug = self.bugs[k]
            if bug.status.value == "Open":
                result = result + [bug]
        result
    fn stats():
        var total = 0
        for k in self.bugs.keys():
            total = total + 1
        {total: total}
    me save() -> bool:
        true

fn create_bug_database(path: text) -> BugDatabase:
    BugDatabase(bugs: {}, path: path)

fn generate_simple_bug(id: text) -> Bug:
    Bug(id: id, severity: BugSeverity.P1(), status: BugStatus.Open(), title: "Bug {id}", description: ["Desc"], file: "test.spl", line: 1, reproducible_by: "test", fix_strategy: [], investigation_log: [], created_at: 0, updated_at: 0, valid: true)

describe "BugDatabase Queries - Intensive":
    context "basic queries":
        it "retrieves all bugs":
            val test_file = "/tmp/test_query_all.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)
            for i in 0..20:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))

            val all_bugs = bugdb.all_bugs()
            check(all_bugs.len() == 20)

            cleanup_test_file(test_file)

        it "retrieves open bugs":
            val test_file = "/tmp/test_query_open.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)

            # Add mix of statuses (reduced from 25 each to 10 to avoid timeout)
            for i in 0..10:
                bugdb.add_bug(Bug(
                    id: "open_{i}",
                    severity: BugSeverity.P2(),
                    status: BugStatus.Open(),
                    title: "Open bug {i}",
                    description: ["Test"],
                    file: "test.spl",
                    line: 100,
                    reproducible_by: "test",
                    fix_strategy: [],
                    investigation_log: [],
                    created_at: 1738724000000000,
                    updated_at: 1738724000000000,
                    valid: true
                ))

            for i in 0..10:
                bugdb.add_bug(Bug(
                    id: "fixed_{i}",
                    severity: BugSeverity.P2(),
                    status: BugStatus.Fixed(),
                    title: "Fixed bug {i}",
                    description: ["Test"],
                    file: "test.spl",
                    line: 100,
                    reproducible_by: "test",
                    fix_strategy: [],
                    investigation_log: [],
                    created_at: 1738724000000000,
                    updated_at: 1738724000000000,
                    valid: true
                ))

            val open_bugs = bugdb.open_bugs()
            check(open_bugs.len() == 10)

            # Verify all are open
            for bug in open_bugs:
                check(bug.status.value == "Open")

            cleanup_test_file(test_file)

        it "gets bug statistics":
            val test_file = "/tmp/test_query_stats.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)

            # Add bugs with variety
            val severities = [BugSeverity.P0(), BugSeverity.P1(), BugSeverity.P2(), BugSeverity.P3()]
            val statuses = [BugStatus.Open(), BugStatus.Investigating(), BugStatus.Fixed(), BugStatus.Closed()]

            # Reduced from 100 to 16 to avoid timeout
            for i in 0..16:
                val severity = severities[i % 4]
                val status = statuses[(i / 4) % 4]
                bugdb.add_bug(Bug(
                    id: "bug_{i}",
                    severity: severity,
                    status: status,
                    title: "Bug {i}",
                    description: ["Test"],
                    file: "test.spl",
                    line: 100 + i,
                    reproducible_by: "test_{i}",
                    fix_strategy: [],
                    investigation_log: [],
                    created_at: 1738724000000000,
                    updated_at: 1738724000000000,
                    valid: true
                ))

            val stats = bugdb.stats()
            check(stats.total == 16)

            cleanup_test_file(test_file)

    context "manual filtering":
        it "filters bugs by severity manually":
            val test_file = "/tmp/test_filter_severity.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)

            # Add bugs with different severities (reduced from 25/75 to 5/15 to avoid timeout)
            for i in 0..5:
                bugdb.add_bug(Bug(
                    id: "p0_{i}",
                    severity: BugSeverity.P0(),
                    status: BugStatus.Open(),
                    title: "Critical bug {i}",
                    description: ["Critical"],
                    file: "test.spl",
                    line: 100,
                    reproducible_by: "test",
                    fix_strategy: [],
                    investigation_log: [],
                    created_at: 1738724000000000,
                    updated_at: 1738724000000000,
                    valid: true
                ))

            for i in 0..15:
                bugdb.add_bug(Bug(
                    id: "p2_{i}",
                    severity: BugSeverity.P2(),
                    status: BugStatus.Open(),
                    title: "Normal bug {i}",
                    description: ["Normal"],
                    file: "test.spl",
                    line: 100,
                    reproducible_by: "test",
                    fix_strategy: [],
                    investigation_log: [],
                    created_at: 1738724000000000,
                    updated_at: 1738724000000000,
                    valid: true
                ))

            # Filter manually
            val all_bugs = bugdb.all_bugs()
            var p0_count = 0
            for bug in all_bugs:
                if bug.severity == BugSeverity.P0():
                    p0_count = p0_count + 1

            check(p0_count == 5)

            cleanup_test_file(test_file)

        it "filters bugs by file field":
            val test_file = "/tmp/test_filter_file.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)

            # Add bugs in different files (reduced from 20/30 to 5/10 to avoid timeout)
            for i in 0..5:
                bugdb.add_bug(Bug(
                    id: "parser_{i}",
                    severity: BugSeverity.P1(),
                    status: BugStatus.Open(),
                    title: "Parser bug {i}",
                    description: ["Parser issue"],
                    file: "src/parser/mod.spl",
                    line: 100 + i,
                    reproducible_by: "test",
                    fix_strategy: [],
                    investigation_log: [],
                    created_at: 1738724000000000,
                    updated_at: 1738724000000000,
                    valid: true
                ))

            for i in 0..10:
                bugdb.add_bug(Bug(
                    id: "other_{i}",
                    severity: BugSeverity.P2(),
                    status: BugStatus.Open(),
                    title: "Other bug {i}",
                    description: ["Other issue"],
                    file: "src/other/mod.spl",
                    line: 100,
                    reproducible_by: "test",
                    fix_strategy: [],
                    investigation_log: [],
                    created_at: 1738724000000000,
                    updated_at: 1738724000000000,
                    valid: true
                ))

            # Filter manually
            val all_bugs = bugdb.all_bugs()
            var parser_bugs = 0
            for bug in all_bugs:
                if bug.file == "src/parser/mod.spl":
                    parser_bugs = parser_bugs + 1

            check(parser_bugs == 5)

            cleanup_test_file(test_file)

    context "bulk operations":
        it "handles retrieving 50 bugs":
            val test_file = "/tmp/test_bulk_50.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)
            for i in 0..50:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))

            val all_bugs = bugdb.all_bugs()
            check(all_bugs.len() == 50)

            cleanup_test_file(test_file)

        it "handles mixed status queries with 20 bugs":
            val test_file = "/tmp/test_bulk_mixed.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)

            val statuses = [BugStatus.Open(), BugStatus.Investigating(), BugStatus.Fixed(), BugStatus.Closed()]

            # Reduced from 500 to 20 to avoid timeout
            for i in 0..20:
                val status = statuses[i % 4]
                bugdb.add_bug(Bug(
                    id: "bug_{i}",
                    severity: BugSeverity.P2(),
                    status: status,
                    title: "Bug {i}",
                    description: ["Test"],
                    file: "test.spl",
                    line: 100,
                    reproducible_by: "test",
                    fix_strategy: [],
                    investigation_log: [],
                    created_at: 1738724000000000,
                    updated_at: 1738724000000000,
                    valid: true
                ))

            # Count by status
            val all_bugs = bugdb.all_bugs()
            var open_count = 0
            var investigating_count = 0
            var fixed_count = 0
            var closed_count = 0

            for bug in all_bugs:
                if bug.status.value == "Open":
                    open_count = open_count + 1
                elif bug.status.value == "Investigating":
                    investigating_count = investigating_count + 1
                elif bug.status.value == "Fixed":
                    fixed_count = fixed_count + 1
                elif bug.status.value == "Closed":
                    closed_count = closed_count + 1

            # Each status should have 5 bugs (20 / 4 statuses)
            check(open_count == 5)
            check(investigating_count == 5)
            check(fixed_count == 5)
            check(closed_count == 5)

            cleanup_test_file(test_file)
