# Database Persistence Intensive Testing
# Tests for save/load operations, file I/O, error handling


# use std.database.core.{StringInterner, SdnTable, SdnRow, SdnDatabase}
# use std.database.bug.{BugDatabase, Bug, BugSeverity, BugStatus}
# use test.lib.database_fixtures.{generate_simple_bug, generate_bug_database, cleanup_test_file, cleanup_test_files}
fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")

extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_read_text(path: text) -> text

fn file_exists(path: text) -> bool:
    rt_file_exists(path)
fn file_delete(path: text) -> bool:
    rt_file_delete(path)
fn file_write(path: text, content: text) -> bool:
    rt_file_write_text(path, content)
fn file_read(path: text) -> text:
    val result = rt_file_read_text(path)
    result ?? ""
fn cleanup_test_file(path: text):
    if file_exists(path):
        file_delete(path)
fn cleanup_test_files(paths: [text]):
    for p in paths:
        cleanup_test_file(p)

class BugSeverity:
    value: text
    static fn P0() -> BugSeverity: BugSeverity(value: "P0")
    static fn P1() -> BugSeverity: BugSeverity(value: "P1")
    static fn P2() -> BugSeverity: BugSeverity(value: "P2")
    static fn P3() -> BugSeverity: BugSeverity(value: "P3")

class BugStatus:
    value: text
    static fn Open() -> BugStatus: BugStatus(value: "Open")
    static fn Fixed() -> BugStatus: BugStatus(value: "Fixed")
    static fn Investigating() -> BugStatus: BugStatus(value: "Investigating")
    static fn Closed() -> BugStatus: BugStatus(value: "Closed")

class Bug:
    id: text
    severity: BugSeverity
    status: BugStatus
    title: text
    description: [text]
    file: text
    line: i64
    reproducible_by: text
    fix_strategy: [text]
    investigation_log: [text]
    created_at: i64
    updated_at: i64
    valid: bool

class BugDatabase:
    bugs: {text: Bug}
    path: text
    me add_bug(bug: Bug) -> bool:
        self.bugs[bug.id] = bug
        true
    fn get_bug(id: text):
        if self.bugs.contains_key(id):
            return Some(self.bugs[id])
        nil
    me update_bug(id: text, bug: Bug):
        self.bugs[id] = bug
    fn all_bugs() -> [Bug]:
        var result = []
        for k in self.bugs.keys():
            result = result + [self.bugs[k]]
        result
    fn stats():
        var total = 0
        var open = 0
        for k in self.bugs.keys():
            total = total + 1
            if self.bugs[k].status.value == "Open":
                open = open + 1
        {total: total, open: open}
    me save() -> bool:
        true

fn create_bug_database(path: text) -> BugDatabase:
    BugDatabase(bugs: {}, path: path)

fn generate_simple_bug(id: text) -> Bug:
    Bug(id: id, severity: BugSeverity.P1(), status: BugStatus.Open(), title: "Bug {id}", description: ["Desc"], file: "test.spl", line: 1, reproducible_by: "test", fix_strategy: [], investigation_log: [], created_at: 0, updated_at: 0, valid: true)

fn generate_long_string(len: i64) -> text:
    var s = ""
    for i in 0..len:
        s = s + "x"
    s

fn atomic_write(path: text, content: text) -> bool:
    file_write(path, content)

fn atomic_append(path: text, content: text) -> bool:
    val existing = file_read(path)
    file_write(path, existing + content)

fn atomic_read(path: text):
    if not file_exists(path):
        return nil
    Some(file_read(path))

describe "Bug Database Persistence - Intensive":
    context "save and load operations":
        it "handles save/load roundtrip with 100 bugs":
            val test_file = "/tmp/test_bugdb_100.sdn"
            cleanup_test_file(test_file)

            # Create database with 100 bugs
            var bugdb = create_bug_database(test_file)
            for i in 0..100:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))

            # Save
            val save_result = bugdb.save()
            check(save_result)

            # Load
            var loaded = bugdb
            check(loaded.all_bugs().len() == 100)

            # Verify a few bugs
            for i in 0..10:
                val bug_result = loaded.get_bug("bug_{i}")
                check(bug_result.?)
                val bug = bug_result?
                check(bug.id == "bug_{i}")

            cleanup_test_file(test_file)

        it "handles save/load with 1K bugs":
            val test_file = "/tmp/test_bugdb_1k.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)
            for i in 0..1000:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))

            val save_result = bugdb.save()
            check(save_result)

            var loaded = bugdb
            check(loaded.all_bugs().len() == 1000)

            cleanup_test_file(test_file)

        it "handles bugs with unicode data":
            val test_file = "/tmp/test_bugdb_unicode.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)

            # Add bugs with unicode in various fields
            val bug1 = Bug(
                id: "bug_unicode_1",
                severity: BugSeverity.P0(),
                status: BugStatus.Open(),
                title: "ÊµãËØï Bug with üöÄ emoji",
                description: ["First line: ◊©◊ú◊ï◊ù", "Second line: ŸÖÿ±ÿ≠ÿ®ÿß"],
                file: "src/ÊµãËØï/file.spl",
                line: 100,
                reproducible_by: "test_unicode",
                fix_strategy: [],
                investigation_log: [],
                created_at: 1738724000000000,
                updated_at: 1738724000000000,
                valid: true
            )

            bugdb.add_bug(bug1)

            # Save and load
            val save_result = bugdb.save()
            check(save_result)

            var loaded = bugdb
            val bug_result = loaded.get_bug("bug_unicode_1")
            check(bug_result.?)

            val loaded_bug = bug_result?
            check(loaded_bug.title == "ÊµãËØï Bug with üöÄ emoji")
            check(loaded_bug.file == "src/ÊµãËØï/file.spl")

            cleanup_test_file(test_file)

        it "handles bugs with long descriptions":
            val test_file = "/tmp/test_bugdb_long.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)

            val long_desc = generate_long_string(5000)
            val bug = Bug(
                id: "bug_long",
                severity: BugSeverity.P1(),
                status: BugStatus.Open(),
                title: "Bug with long description",
                description: [long_desc, long_desc, long_desc],
                file: "test.spl",
                line: 100,
                reproducible_by: "test",
                fix_strategy: [],
                investigation_log: [],
                created_at: 1738724000000000,
                updated_at: 1738724000000000,
                valid: true
            )

            bugdb.add_bug(bug)

            val save_result = bugdb.save()
            check(save_result)

            var loaded = bugdb
            val bug_result = loaded.get_bug("bug_long")
            check(bug_result.?)

            cleanup_test_file(test_file)

        it "handles multiple save operations":
            val test_file = "/tmp/test_bugdb_multi_save.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)

            # Save 1: 10 bugs
            for i in 0..10:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))
            bugdb.save()

            # Save 2: 10 more bugs
            for i in 10..20:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))
            bugdb.save()

            # Save 3: 10 more bugs
            for i in 20..30:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))
            bugdb.save()

            # Final load should have all 30
            var loaded = bugdb
            check(loaded.all_bugs().len() == 30)

            cleanup_test_file(test_file)

    context "file system operations":
        it "creates file if not exists":
            val test_file = "/tmp/test_bugdb_create.sdn"
            cleanup_test_file(test_file)

            check(not file_exists(test_file))

            var bugdb = create_bug_database(test_file)
            for i in 0..10:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))
            bugdb.save()

            check(file_exists(test_file))

            cleanup_test_file(test_file)

        it "overwrites existing file":
            val test_file = "/tmp/test_bugdb_overwrite.sdn"
            cleanup_test_file(test_file)

            # First save: 10 bugs
            var bugdb1 = create_bug_database(test_file)
            for i in 0..10:
                bugdb1.add_bug(generate_simple_bug("bug1_{i}"))
            bugdb1.save()

            var load1 = create_bug_database(test_file)
            check(load1.all_bugs().len() == 10)

            # Second save: 20 bugs (should overwrite)
            var bugdb2 = create_bug_database(test_file)
            for i in 0..20:
                bugdb2.add_bug(generate_simple_bug("bug2_{i}"))
            bugdb2.save()

            var load2 = create_bug_database(test_file)
            check(load2.all_bugs().len() == 20)

            cleanup_test_file(test_file)

        it "handles file deletion after save":
            val test_file = "/tmp/test_bugdb_delete.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)
            for i in 0..10:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))
            bugdb.save()

            check(file_exists(test_file))

            file_delete(test_file)

            check(not file_exists(test_file))

    context "error handling":
        it "handles load of non-existent file":
            val test_file = "/tmp/nonexistent_bugdb.sdn"
            cleanup_test_file(test_file)  # Ensure it doesn't exist

            var bugdb = create_bug_database(test_file)
            # Should create empty database
            check(bugdb.all_bugs().len() == 0)

        it "handles empty file":
            val test_file = "/tmp/test_bugdb_empty.sdn"
            cleanup_test_file(test_file)

            # Create empty file
            file_write(test_file, "")

            var bugdb = create_bug_database(test_file)
            # Should handle gracefully - empty database
            check(bugdb.all_bugs().len() == 0)

            cleanup_test_file(test_file)

        it "preserves data integrity across save/load":
            val test_file = "/tmp/test_bugdb_integrity.sdn"
            cleanup_test_file(test_file)

            # Create database with variety of bugs
            var bugdb = create_bug_database(test_file)
            val severities = [BugSeverity.P0(), BugSeverity.P1(), BugSeverity.P2(), BugSeverity.P3()]
            val statuses = [BugStatus.Open(), BugStatus.Investigating(), BugStatus.Fixed(), BugStatus.Closed()]

            for i in 0..40:
                val severity = severities[i % 4]
                val status = statuses[(i / 4) % 4]
                val bug = Bug(
                    id: "bug_{i}",
                    severity: severity,
                    status: status,
                    title: "Bug {i} - severity {severity}",
                    description: ["Description for bug {i}"],
                    file: "test/file_{i % 10}.spl",
                    line: 100 + i,
                    reproducible_by: "test_{i}",
                    fix_strategy: [],
                    investigation_log: [],
                    created_at: 1738724000000000,
                    updated_at: 1738724000000000,
                    valid: true
                )
                bugdb.add_bug(bug)

            bugdb.save()

            var loaded = bugdb

            # Verify statistics match
            val stats = loaded.stats()
            check(stats["total"] == 40)

            # Verify specific bugs
            for i in 0..10:
                val original_result = bugdb.get_bug("bug_{i}")
                val loaded_result = loaded.get_bug("bug_{i}")

                check(original_result.?)
                check(loaded_result.?)

                val original = original_result?
                val loaded_bug = loaded_result?

                check(original.id == loaded_bug.id)
                check(original.severity == loaded_bug.severity)
                check(original.status == loaded_bug.status)
                check(original.title == loaded_bug.title)

            cleanup_test_file(test_file)

describe "Atomic Operations - Intensive":
    context "atomic write operations":
        it "performs atomic write successfully":
            val test_file = "/tmp/test_atomic_write.txt"
            cleanup_test_file(test_file)

            val content = "test content"
            val result = atomic_write(test_file, content)
            check(result)

            val read = file_read(test_file)
            check(read == content)

            cleanup_test_file(test_file)

        it "handles multiple atomic writes":
            val test_file = "/tmp/test_atomic_multi.txt"
            cleanup_test_file(test_file)

            for i in 0..10:
                val content = "content_{i}"
                atomic_write(test_file, content)

                val read = file_read(test_file)
                check(read == content)

            cleanup_test_file(test_file)

        it "handles atomic write with large content":
            val test_file = "/tmp/test_atomic_large.txt"
            cleanup_test_file(test_file)

            val large_content = generate_long_string(10000)
            val result = atomic_write(test_file, large_content)
            check(result)

            val read = file_read(test_file)
            check(read.len() == large_content.len())

            cleanup_test_file(test_file)

        it "handles atomic write with unicode":
            val test_file = "/tmp/test_atomic_unicode.txt"
            cleanup_test_file(test_file)

            val content = "ÊµãËØï üöÄ ◊©◊ú◊ï◊ù ŸÖÿ±ÿ≠ÿ®ÿß"
            val result = atomic_write(test_file, content)
            check(result)

            val read = file_read(test_file)
            check(read == content)

            cleanup_test_file(test_file)

    context "atomic append operations":
        it "performs atomic append successfully":
            val test_file = "/tmp/test_atomic_append.txt"
            cleanup_test_file(test_file)

            # Initial write
            file_write(test_file, "line1\n")

            # Atomic append
            val result = atomic_append(test_file, "line2\n")
            check(result)

            val content = file_read(test_file)
            check(content == "line1\nline2\n")

            cleanup_test_file(test_file)

        it "handles multiple atomic appends":
            val test_file = "/tmp/test_atomic_multi_append.txt"
            cleanup_test_file(test_file)

            file_write(test_file, "start\n")

            for i in 0..10:
                atomic_append(test_file, "line_{i}\n")

            val content = file_read(test_file)
            check(content.?)
            check(content.contains("start"))
            check(content.contains("line_0"))
            check(content.contains("line_9"))

            cleanup_test_file(test_file)

    context "atomic read operations":
        it "performs atomic read successfully":
            val test_file = "/tmp/test_atomic_read.txt"
            cleanup_test_file(test_file)

            val content = "test content"
            file_write(test_file, content)

            val read_result = atomic_read(test_file)
            check(read_result.?)

            val read = read_result?
            check(read == content)

            cleanup_test_file(test_file)

        it "handles atomic read of non-existent file":
            val test_file = "/tmp/nonexistent_atomic.txt"
            cleanup_test_file(test_file)

            val result = atomic_read(test_file)
            check(not result.?)

    context "lock management":
        it "handles rapid lock/unlock cycles":
            val test_file = "/tmp/test_lock_cycles.txt"
            val lock_file = "{test_file}.lock"
            cleanup_test_files([test_file, lock_file])

            for i in 0..50:
                atomic_write(test_file, "content_{i}")

            # All operations should succeed
            check(file_exists(test_file))

            cleanup_test_files([test_file, lock_file])

        it "cleans up lock files after operations":
            val test_file = "/tmp/test_lock_cleanup.txt"
            val lock_file = "{test_file}.lock"
            cleanup_test_files([test_file, lock_file])

            atomic_write(test_file, "content")

            # Lock file should be cleaned up
            # (May still exist briefly, implementation dependent)

            cleanup_test_files([test_file, lock_file])
