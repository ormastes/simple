# Core Interpreter â€” Integration Intensive Tests

use core.interpreter.mod.{core_interpret, core_interpret_expr}
use core.interpreter.eval.{eval_has_error, eval_get_error}
use core.interpreter.value.{val_get_int, val_get_text, val_get_bool, val_get_kind, VAL_INT, VAL_TEXT}

use std.string.{NL}
use std.string.{NL}

fn run_ok(src: text) -> i64:
    val result = core_interpret(src, "test.spl")
    expect(eval_has_error()).to_equal(false)
    result

fn run_expr_ok(src: text) -> i64:
    val result = core_interpret_expr(src)
    expect(eval_has_error()).to_equal(false)
    result

fn run_err(src: text) -> text:
    val result = core_interpret(src, "test.spl")
    expect(eval_has_error()).to_equal(true)
    eval_get_error()


describe "core.interpreter (integration intensive)":
    it "evaluates expressions and main":
        val v = run_expr_ok("1 + 2 * 3")
        expect(val_get_int(v)).to_equal(7)

        val prog = "fn main():{NL}" +
            "    return 2 + 3{NL}"
        val r = run_ok(prog)
        expect(val_get_int(r)).to_equal(5)

    it "handles control flow and loops":
        val prog = "fn main():{NL}" +
            "    var sum = 0{NL}" +
            "    for i in [1, 2, 3]:{NL}" +
            "        if i == 2:{NL}" +
            "            continue{NL}" +
            "        sum = sum + i{NL}" +
            "    var n = 0{NL}" +
            "    while n < 2:{NL}" +
            "        sum = sum + n{NL}" +
            "        n = n + 1{NL}" +
            "    return sum{NL}"
        val r = run_ok(prog)
        expect(val_get_int(r)).to_equal(5)

    it "handles match and arrays":
        val prog = "fn main():{NL}" +
            "    val x = 2{NL}" +
            "    match x:{NL}" +
            "        case 1:{NL}" +
            "            return 10{NL}" +
            "        case 2:{NL}" +
            "            return 20{NL}" +
            "    return 0{NL}"
        val r = run_ok(prog)
        expect(val_get_int(r)).to_equal(20)

        val prog2 = "fn main():{NL}" +
            "    val a = [10, 20, 30]{NL}" +
            "    return a[1]{NL}"
        val r2 = run_ok(prog2)
        expect(val_get_int(r2)).to_equal(20)

    it "handles array/text methods and errors":
        val prog = "fn main():{NL}" +
            "    val a = [1, 2]{NL}" +
            "    val b = a.push(3){NL}" +
            "    if b.contains(2):{NL}" +
            "        return b.len(){NL}" +
            "    return 0{NL}"
        val r = run_ok(prog)
        expect(val_get_int(r)).to_equal(3)

        val prog2 = "fn main():{NL}" +
            "    val s = \"abc\"{NL}" +
            "    if s.contains(\"b\"):{NL}" +
            "        return s.len(){NL}" +
            "    return 0{NL}"
        val r2 = run_ok(prog2)
        expect(val_get_int(r2)).to_equal(3)

        val err = run_err("fn main():{NL}    val a = [1]{NL}    val x = a.foo(){NL}    return x{NL}")
        expect(err.contains("no method")).to_equal(true)

    it "handles struct fields and assignment":
        val prog = "struct Point:{NL}" +
            "    x: i64{NL}" +
            "    y: i64{NL}" +
            "fn main():{NL}" +
            "    var p = Point(1, 2){NL}" +
            "    p.x = 5{NL}" +
            "    return p.x{NL}"
        val r = run_ok(prog)
        expect(val_get_int(r)).to_equal(5)

        val err = run_err("struct Point:{NL}    x: i64{NL}fn main():{NL}    val p = Point(1){NL}    return p.z{NL}")
        expect(err.contains("no field")).to_equal(true)

    it "reports common runtime errors":
        val err1 = run_err("fn main():{NL}    return unknown{NL}")
        expect(err1.contains("undefined variable")).to_equal(true)

        val err2 = run_err("fn main():{NL}    val a = [1]{NL}    val x = a[2]{NL}    return x{NL}")
        expect(err2.contains("array index out of bounds")).to_equal(true)

        val err3 = run_err("fn main():{NL}    val s = \"hi\"{NL}    val x = s[2]{NL}    return x{NL}")
        expect(err3.contains("string index out of bounds")).to_equal(true)

        val err4 = run_err("fn main():{NL}    val x = 1{NL}    val y = x[0]{NL}    return y{NL}")
        expect(err4.contains("cannot index")).to_equal(true)

        val err5 = run_err("fn main():{NL}    1 = 2{NL}")
        expect(err5.contains("invalid assignment")).to_equal(true)
