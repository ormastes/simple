// Test file for mixin type inference verification
// This will be used to generate Lean verification code

// Basic mixin with fields
mixin Timestamp {
    created_at: i64
    updated_at: i64
    
    fn update_timestamp() {
        self.updated_at = current_time()
    }
}

// Generic mixin with type parameter
mixin Cache<T> {
    cache: HashMap<String, T>
    
    fn get_cached(key: String) -> Option<T> {
        self.cache.get(key)
    }
    
    fn set_cache(key: String, value: T) {
        self.cache.insert(key, value)
    }
}

// Mixin with trait requirements
mixin Serializable where Self: Serialize + Deserialize {
    fn to_json() -> String {
        serialize(self)
    }
    
    fn from_json(json: String) -> Result<Self, Error> {
        deserialize(json)
    }
}

// Mixin with required methods
mixin Repository<T, E> {
    connection: DbConnection
    
    // Required method that must be provided by the target
    fn table_name() -> String;
    
    fn find_by_id(id: i64) -> Result<T, E> {
        val query = format!("SELECT * FROM {} WHERE id = ?", self.table_name())
        self.connection.query(query, [id])
    }
    
    fn save(entity: T) -> Result<(), E> {
        val table = self.table_name()
        self.connection.insert(table, entity)
    }
}

// Base class to apply mixins to
class User {
    id: i64
    name: String
    email: String
}

// Apply multiple mixins to a class
class UserService with Timestamp, Cache<User>, Serializable {
    users: List<User>
    
    fn get_user(id: i64) -> Option<User> {
        // Can use mixin methods
        if val Some(cached) = self.get_cached(id.to_string()) {
            return Some(cached)
        }
        
        // Search in users list
        for user in self.users {
            if user.id == id {
                self.set_cache(id.to_string(), user)
                return Some(user)
            }
        }
        None
    }
    
    fn load_user(id: i64) -> Option<User> {
        self.get_user(id)
    }
}

// Test type inference with mixin field access
fn test_mixin_field_access(service: UserService) -> i64 {
    // Type inference: created_at is i64 from Timestamp mixin
    service.created_at
}

// Test type inference with mixin method call
fn test_mixin_method_call(service: UserService, key: String) -> Option<User> {
    // Type inference: get_cached returns Option<User> from Cache<User> mixin
    service.get_cached(key)
}

// Test generic type parameter unification
fn test_generic_unification(service: UserService) {
    val user = User { id: 1, name: "Alice", email: "alice@example.com" }
    // Type T in Cache<T> should unify with User
    service.set_cache("1", user)
    // Return type should be Option<User>
    val cached: Option<User> = service.get_cached("1")
}

// Test mixin with required method
class UserRepository with Repository<User, DbError> {
    // Must implement required method
    fn table_name() -> String {
        "users"
    }
}

fn test_required_method(repo: UserRepository) -> Result<User, DbError> {
    // Can call mixin method that uses required method
    repo.find_by_id(1)
}

// Test multiple mixin composition
class AuditableUser with Timestamp, Serializable {
    id: i64
    name: String
}

fn test_multiple_mixins(user: AuditableUser) -> String {
    // Can access fields from Timestamp mixin
    val created = user.created_at
    // Can call methods from Serializable mixin
    user.to_json()
}

// Test mixin with mixin dependencies
mixin Audit with Timestamp {
    modified_by: String
    
    fn record_audit(user: String) {
        self.modified_by = user
        self.update_timestamp()  // Can call Timestamp mixin method
    }
}

// Helper types for the examples
struct DbConnection {}
struct DbError {}
struct HashMap<K, V> {}

fn current_time() -> i64 { 0 }
fn serialize<T>(value: T) -> String { "" }
fn deserialize<T>(json: String) -> Result<T, Error> { Err(Error {}) }

trait Serialize {}
trait Deserialize {}
struct Error {}
