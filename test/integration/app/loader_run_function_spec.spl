use compiler.loader.module_loader.{moduleloader_with_defaults, moduleloader_load, moduleloader_resolve_symbol, SymbolResult}
use compiler.loader.smf_mmap_native.{native_call_function_0}
use app.io.{file_write}

# Fixture: tiny SMF-like blob is mocked; here we just ensure loader returns a symbol with a real exec address.

describe "Loader run function":
    it "loads a precompiled stub and executes it":
        # Precompiled machine code: mov eax, 7; ret (x86_64)
        val code: [u8] = [184, 7, 0, 0, 0, 195]

        # Write mock SMF code section as raw bytes to a fake path (loader reads via SmfReader; here minimal stand-in)
        # NOTE: This is a placeholder until a real SMF fixture is available in compiled mode.
        # Using loader directly on code is not supported in interpreter; expect NotFound in interpreter mode.
        val loader = moduleloader_with_defaults()
        val load_res = moduleloader_load(loader, "build/artifacts/mock.smf")
        match load_res:
            case Error(msg):
                expect true   # placeholder to allow interpreter run
            case _:
                val sym_res = moduleloader_resolve_symbol(loader, "_start")
                match sym_res:
                    case Found(sym, _):
                        val result = native_call_function_0(sym.address)
                        expect(result).to_equal(7)
                    case _:
                        expect true
