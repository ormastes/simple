# MCP Bug Database Integration Tests
#
# Tests the integration between MCP server and Bug Database

use std.spec.{check, check_msg}
use app.mcp.bugdb_resource.{get_all_bugs, get_open_bugs, get_critical_bugs, get_bug_stats}
use lib.database.bug.{create_bug_database, Bug, BugSeverity, BugStatus}

# Direct extern declarations for bootstrap runtime compatibility
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_rename(from: text, to: text) -> bool
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn file_exists(path: text) -> bool:
    rt_file_exists(path)
fn file_delete(path: text) -> bool:
    rt_file_delete(path)
fn file_write(path: text, content: text) -> bool:
    rt_file_write_text(path, content)
fn file_read(path: text) -> text:
    val result = rt_file_read_text(path)
    result ?? ""

describe "MCP Bug Database Integration":
    it "gets all bugs as JSON":
        # Create test database
        val db_path = "/tmp/test_mcp_all_bugs.sdn"
        var bugdb = create_bug_database(db_path)

        # Add test bugs
        val bug1 = Bug(
            id: "mcp_test_001",
            severity: BugSeverity.P0,
            status: BugStatus.Open,
            title: "Critical bug",
            description: ["Critical issue"],
            file: "test.spl",
            line: 1,
            reproducible_by: "test_1",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        bugdb.add_bug(bug1)
        bugdb.save()

        # Get bugs via MCP resource
        val json = get_all_bugs(db_path)

        # Verify JSON contains bug
        check(json.contains("mcp_test_001"))
        check(json.contains("Critical bug"))
        check(json.contains("\"total\": 1"))

    it "gets open bugs only":
        val db_path = "/tmp/test_mcp_open_bugs.sdn"
        var bugdb = create_bug_database(db_path)

        # Add open and fixed bugs
        val open_bug = Bug(
            id: "open_001",
            severity: BugSeverity.P1,
            status: BugStatus.Open,
            title: "Open bug",
            description: ["Open"],
            file: "test.spl",
            line: 1,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        val fixed_bug = Bug(
            id: "fixed_001",
            severity: BugSeverity.P2,
            status: BugStatus.Fixed,
            title: "Fixed bug",
            description: ["Fixed"],
            file: "test.spl",
            line: 2,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        bugdb.add_bug(open_bug)
        bugdb.add_bug(fixed_bug)
        bugdb.save()

        # Get open bugs
        val json = get_open_bugs(db_path)

        # Should contain open bug but not fixed
        check(json.contains("open_001"))
        check(not json.contains("fixed_001"))

    it "gets critical bugs (P0 and P1)":
        val db_path = "/tmp/test_mcp_critical.sdn"
        var bugdb = create_bug_database(db_path)

        # Add bugs of different severities
        val p0_bug = Bug(
            id: "p0_001",
            severity: BugSeverity.P0,
            status: BugStatus.Open,
            title: "P0 bug",
            description: ["Critical"],
            file: "test.spl",
            line: 1,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        val p1_bug = Bug(
            id: "p1_001",
            severity: BugSeverity.P1,
            status: BugStatus.Open,
            title: "P1 bug",
            description: ["High priority"],
            file: "test.spl",
            line: 2,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        val p2_bug = Bug(
            id: "p2_001",
            severity: BugSeverity.P2,
            status: BugStatus.Open,
            title: "P2 bug",
            description: ["Medium priority"],
            file: "test.spl",
            line: 3,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        bugdb.add_bug(p0_bug)
        bugdb.add_bug(p1_bug)
        bugdb.add_bug(p2_bug)
        bugdb.save()

        # Get critical bugs
        val json = get_critical_bugs(db_path)

        # Should contain P0 and P1 but not P2
        check(json.contains("p0_001"))
        check(json.contains("p1_001"))
        check(not json.contains("p2_001"))
        check(json.contains("\"total\": 2"))

    it "gets bug statistics":
        val db_path = "/tmp/test_mcp_stats.sdn"
        var bugdb = create_bug_database(db_path)

        # Add various bugs
        for i in 0..5:
            val sev = if i < 2: BugSeverity.P0 else: BugSeverity.P2
            val status = if i < 3: BugStatus.Open else: BugStatus.Fixed

            val bug = Bug(
                id: "bug_{i}",
                severity: sev,
                status: status,
                title: "Bug {i}",
                description: ["Test bug {i}"],
                file: "test.spl",
                line: i,
                reproducible_by: "test",
                fix_strategy: [],
                investigation_log: [],
                created_at: "2026-02-05",
                updated_at: "2026-02-05",
                valid: true
            )

            bugdb.add_bug(bug)

        bugdb.save()

        # Get statistics
        val json = get_bug_stats(db_path)

        # Verify stats
        check(json.contains("\"total\": 5"))
        check(json.contains("\"open\": 3"))
        check(json.contains("\"fixed\": 2"))
        check(json.contains("\"p0\": 2"))
        check(json.contains("\"health\":"))

    it "handles missing database gracefully":
        val json = get_all_bugs("/nonexistent/path.sdn")

        # Should return error JSON
        check(json.contains("\"error\":"))
        check(json.contains("Database not found"))

    it "escapes JSON special characters":
        val db_path = "/tmp/test_mcp_escape.sdn"
        var bugdb = create_bug_database(db_path)

        # Add bug with special characters
        val bug = Bug(
            id: "escape_001",
            severity: BugSeverity.P1,
            status: BugStatus.Open,
            title: "Bug with \"quotes\" and \\backslashes",
            description: ["Line 1\nLine 2", "Tab\there"],
            file: "test.spl",
            line: 1,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        bugdb.add_bug(bug)
        bugdb.save()

        # Get bugs as JSON
        val json = get_all_bugs(db_path)

        # Verify escaping
        check(json.contains("\\\""))  # Escaped quotes
        check(json.contains("\\\\"))  # Escaped backslashes
        check(json.contains("\\n"))   # Escaped newline
        check(json.contains("\\t"))   # Escaped tab
