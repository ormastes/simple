# LLVM Backend End-to-End Integration Tests
#
# Tests complete compilation pipeline from MIR to object code.

use std.spec
use compiler.backend.llvm_backend.{LlvmBackend, find_llc, llc_available, generate_runtime_declarations}
use compiler.backend.backend_types.{CodegenTarget, OptimizationLevel}

# ============================================================================
# Environment Tests
# ============================================================================

describe "LLVM Backend E2E - Environment":
    context "llc detection":
        it "finds llc binary":
            val llc_cmd = find_llc()
            # Skip test if llc not installed
            if not llc_cmd.?:
                expect(true).to_equal(true)  # Skip
            else:
                expect(llc_cmd.?).to_equal(true)
                # Should be one of: llc-18, llc-17, llc-16, llc
                val cmd = llc_cmd.unwrap()
                expect(cmd).to_start_with("llc")

        it "checks llc availability":
            val available = llc_available()
            # This may be false in CI without LLVM installed
            # Just verify the function returns a boolean
            expect(available == true or available == false).to_equal(true)

# ============================================================================
# Runtime Declarations Tests
# ============================================================================

describe "LLVM Backend E2E - Runtime Declarations":
    context "declaration generation":
        it "generates runtime declarations":
            val decls = generate_runtime_declarations()
            expect(decls.len()).to_be_greater_than(0)

        it "includes file I/O declarations":
            val decls = generate_runtime_declarations()
            expect(decls).to_contain("@rt_file_open")
            expect(decls).to_contain("@rt_file_read_text")
            expect(decls).to_contain("@rt_file_write")

        it "includes memory declarations":
            val decls = generate_runtime_declarations()
            expect(decls).to_contain("@rt_alloc")
            expect(decls).to_contain("@rt_free")
            expect(decls).to_contain("@rt_memcpy")

        it "includes string declarations":
            val decls = generate_runtime_declarations()
            expect(decls).to_contain("@rt_strlen")
            expect(decls).to_contain("@rt_strcat")

        it "includes I/O declarations":
            val decls = generate_runtime_declarations()
            expect(decls).to_contain("@rt_print")
            expect(decls).to_contain("@rt_println")

        it "includes LLVM intrinsics":
            val decls = generate_runtime_declarations()
            expect(decls).to_contain("@llvm.memcpy")
            expect(decls).to_contain("@llvm.memset")

# ============================================================================
# Backend Creation Tests
# ============================================================================

describe "LLVM Backend E2E - Backend Creation":
    context "default backend":
        it "creates backend for x86_64":
            val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Debug)
            expect(backend.target).to_equal(CodegenTarget.X86_64)
            expect(backend.opt_level).to_equal(OptimizationLevel.Debug)

        it "creates backend for Speed optimization":
            val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Speed)
            expect(backend.opt_level).to_equal(OptimizationLevel.Speed)

    context "compatibility backend":
        it "creates compatibility backend":
            val backend = LlvmBackend.compatibility_build(CodegenTarget.X86_64, OptimizationLevel.Speed)
            expect(backend.cpu_override.?).to_equal(true)
            expect(backend.cpu_override.unwrap()).to_equal("x86-64")

    context "bare-metal backend":
        it "creates bare-metal backend":
            val backend = LlvmBackend.create_baremetal(CodegenTarget.X86_64, OptimizationLevel.Size)
            expect(backend.bare_metal).to_equal(true)
            expect(backend.debug_info).to_equal(true)

# ============================================================================
# Backend Configuration Tests
# ============================================================================

describe "LLVM Backend E2E - Configuration":
    context "builder methods":
        it "configures CPU override":
            val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Debug)
                .with_cpu_override("skylake")
            expect(backend.cpu_override.?).to_equal(true)
            expect(backend.cpu_override.unwrap()).to_equal("skylake")

        it "enables LLVM IR output":
            val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Debug)
                .with_llvm_ir()
            expect(backend.emit_llvm_ir).to_equal(true)

        it "enables assembly output":
            val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Debug)
                .with_assembly()
            expect(backend.emit_assembly).to_equal(true)

        it "enables debug info":
            val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Debug)
                .with_debug_info()
            expect(backend.debug_info).to_equal(true)

# ============================================================================
# Target Configuration Tests
# ============================================================================

describe "LLVM Backend E2E - Target Configuration":
    context "target config":
        it "gets target configuration":
            val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Speed)
            val config = backend.get_target_config()
            expect(config.triple.to_text()).to_contain("x86_64")

# ============================================================================
# Compilation Tests (Skipped if llc not available)
# ============================================================================

describe "LLVM Backend E2E - Compilation":
    context "simple IR compilation":
        it "compiles minimal LLVM IR to object code":
            if not llc_available():
                # Skip if llc not installed
                expect(true).to_equal(true)
            else:
                # NOTE: Create minimal MirModule and compile
                # For now just verify backend creation works
                val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Debug)
                expect(backend.target).to_equal(CodegenTarget.X86_64)

# ============================================================================
# Error Handling Tests
# ============================================================================

describe "LLVM Backend E2E - Error Handling":
    context "missing llc":
        it "provides helpful error message":
            # This test verifies error message format
            # Actual llc availability may vary
            val llc_cmd = find_llc()
            if not llc_cmd.?:
                # Error message would be shown during compile_ir_to_object
                expect(true).to_equal(true)
            else:
                # llc is available
                expect(llc_cmd.?).to_equal(true)

# ============================================================================
# Multi-Target Tests
# ============================================================================

describe "LLVM Backend E2E - Multiple Targets":
    context "x86_64 target":
        it "creates backend for x86_64":
            val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Speed)
            val config = backend.get_target_config()
            expect(config.triple.to_text()).to_contain("x86_64")

    context "aarch64 target":
        it "creates backend for aarch64":
            val backend = LlvmBackend.create(CodegenTarget.AArch64, OptimizationLevel.Speed)
            val config = backend.get_target_config()
            expect(config.triple.to_text()).to_contain("aarch64")

    context "32-bit targets":
        it "creates backend for i686":
            val backend = LlvmBackend.create(CodegenTarget.X86, OptimizationLevel.Speed)
            val config = backend.get_target_config()
            expect(config.triple.to_text()).to_contain("i686")

# ============================================================================
# Optimization Level Tests
# ============================================================================

describe "LLVM Backend E2E - Optimization Levels":
    context "optimization flags":
        it "supports Debug optimization":
            val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Debug)
            expect(backend.opt_level).to_equal(OptimizationLevel.Debug)

        it "supports Size optimization":
            val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Size)
            expect(backend.opt_level).to_equal(OptimizationLevel.Size)

        it "supports Speed optimization":
            val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Speed)
            expect(backend.opt_level).to_equal(OptimizationLevel.Speed)

        it "supports Aggressive optimization":
            val backend = LlvmBackend.create(CodegenTarget.X86_64, OptimizationLevel.Aggressive)
            expect(backend.opt_level).to_equal(OptimizationLevel.Aggressive)
