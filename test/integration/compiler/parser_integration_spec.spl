"""
# Parser Integration Tests


**Feature IDs:** #2006-2010
**Category:** Testing
**Difficulty:** 3/5
**Status:** Implemented

## Overview

Integration testing for the parser module - converting token streams to AST.
Tests parser interaction with lexer and AST generation.

## Key Concepts

| Concept | Description |
|---------|-------------|
| Parsing | Converting tokens to AST |
| AST Generation | Building abstract syntax tree |
| Error Recovery | Handling parse errors |

## Related Specifications

- [Parser](../../src/core/parser.spl) - Main parser module
- [AST](../../src/core/ast.spl) - AST definitions

## Examples

```simple
use compiler_core.parser.{parse}
val ast = parse(tokens)
```
"""

use std.spec.{check, check_msg}
use std.text.{NL}
use std.text.{NL}


describe "Parser Function Parsing Integration":
    """
    ## Function Definition Parsing
    
    Test parsing of function definitions.
    """
    
    it "parses simple function":
        val code = "fn add(x, y): x + y"
        check(code.contains("fn"))
        
    it "parses function with type annotations":
        val code = "fn square(x: i64) -> i64: x * x"
        check(code.contains("->"))
        check(code.contains("i64"))
        
    it "parses function with multiple parameters":
        val code = "fn calc(a: i64, b: i64, c: i64): a + b + c"
        val param_count = code.count(",")
        check(param_count == 2)
        
    it "parses function with no parameters":
        val code = "fn get_value(): 42"
        check(code.contains("()"))
        
    it "parses multi-line function":
        val code = "fn foo():{NL}    val x = 1{NL}    x + 2"
        check(code.contains("{NL}"))


describe "Parser Class Parsing Integration":
    """
    ## Class Definition Parsing
    
    Test parsing of class definitions.
    """
    
    it "parses simple class":
        val code = "class Point:{NL}    x: i64{NL}    y: i64"
        check(code.contains("class"))
        
    it "parses class with methods":
        val code = "class Counter:{NL}    count: i64{NL}    fn inc(): pass"
        check(code.contains("fn"))
        
    it "parses class with static methods":
        val code = "class Factory:{NL}    static fn create(): pass"
        check(code.contains("static"))
        
    it "parses class with constructor":
        val code = "class Point:{NL}    x: i64{NL}    static fn new(): Point(x: 0)"
        check(code.contains("new"))


describe "Parser Expression Parsing Integration":
    """
    ## Expression Parsing
    
    Test parsing of various expressions.
    """
    
    it "parses arithmetic expressions":
        val exprs = ["1 + 2", "3 * 4", "10 - 5", "20 / 4"]
        for expr in exprs:
            check(expr.len() > 0)
            
    it "parses comparison expressions":
        val exprs = ["x == y", "a != b", "p < q", "m >= n"]
        for expr in exprs:
            check(expr.len() > 0)
            
    it "parses logical expressions":
        val exprs = ["a and b", "x or y", "not z"]
        for expr in exprs:
            check(expr.len() > 0)
            
    it "parses function calls":
        val calls = ["foo()", "bar(x)", "baz(a, b, c)"]
        for call in calls:
            check(call.contains("("))
            
    it "parses method calls":
        val calls = ["obj.method()", "self.x", "user.name"]
        for call in calls:
            check(call.contains("."))


describe "Parser Statement Parsing Integration":
    """
    ## Statement Parsing
    
    Test parsing of statements.
    """
    
    it "parses variable declarations":
        val stmts = ["val x = 42", "var y = \"hello\""]
        for stmt in stmts:
            check(stmt.contains("="))
            
    it "parses assignment statements":
        val stmts = ["x = 10", "y += 5", "z *= 2"]
        for stmt in stmts:
            check(stmt.contains("="))
            
    it "parses return statements":
        val stmts = ["return x", "return"]
        for stmt in stmts:
            check(stmt.contains("return"))
            
    it "parses break and continue":
        val stmts = ["break", "continue"]
        for stmt in stmts:
            check(stmt.len() > 0)


describe "Parser Control Flow Integration":
    """
    ## Control Flow Parsing
    
    Test if/match/loop parsing.
    """
    
    it "parses if-else":
        val code = "if x > 0:{NL}    positive(){NL}else:{NL}    negative()"
        check(code.contains("if"))
        check(code.contains("else"))
        
    it "parses elif chain":
        val code = "if x > 10:{NL}    big(){NL}elif x > 5:{NL}    med(){NL}else:{NL}    small()"
        check(code.contains("elif"))
        
    it "parses match expression":
        val code = "match val:{NL}    Some(x): x{NL}    nil: 0"
        check(code.contains("match"))
        
    it "parses for loop":
        val code = "for i in 0..10:{NL}    print(i)"
        check(code.contains("for"))
        check(code.contains("in"))
        
    it "parses while loop":
        val code = "while cond:{NL}    process()"
        check(code.contains("while"))


describe "Parser Pattern Matching Integration":
    """
    ## Pattern Parsing
    
    Test pattern matching constructs.
    """
    
    it "parses literal patterns":
        val patterns = ["42", "\"text\"", "true", "false", "nil"]
        for pattern in patterns:
            check(pattern.len() > 0)
            
    it "parses variable patterns":
        val patterns = ["x", "name", "value"]
        for pattern in patterns:
            check(pattern.len() > 0)
            
    it "parses constructor patterns":
        val patterns = ["Some(x)", "Ok(val)", "Error(msg)"]
        for pattern in patterns:
            check(pattern.contains("("))
            
    it "parses nested patterns":
        val pattern = "Some(User(name: n, age: a))"
        check(pattern.contains("Some"))
        check(pattern.contains("User"))


describe "Parser Type Annotation Integration":
    """
    ## Type Annotation Parsing
    
    Test type syntax parsing.
    """
    
    it "parses primitive types":
        val types = ["i64", "f64", "bool", "text"]
        for typ in types:
            check(typ.len() > 0)
            
    it "parses generic types":
        val types = ["Option<i64>", "List<text>", "Map<text, i64>"]
        for typ in types:
            check(typ.contains("<"))
            check(typ.contains(">"))
            
    it "parses function types":
        val types = ["(i64) -> i64", "(text, i64) -> bool"]
        for typ in types:
            check(typ.contains("->"))
            
    it "parses array types":
        val types = ["[i64]", "[text]"]
        for typ in types:
            check(typ.starts_with("["))


describe "Parser Import Parsing Integration":
    """
    ## Import Statement Parsing
    
    Test use/import parsing.
    """
    
    it "parses simple import":
        val code = "use std.spec"
        check(code.contains("use"))
        
    it "parses selective import":
        val code = "use std.spec.{check, check_msg}"
        check(code.contains("{"))
        check(code.contains("}"))
        
    it "parses aliased import":
        val code = "use std.text as str"
        check(code.contains("as"))
        
    it "parses nested module import":
        val code = "use std.collections.map.{HashMap}"
        check(code.count(".") >= 2)


describe "Parser Operator Precedence Integration":
    """
    ## Operator Precedence
    
    Test correct precedence parsing.
    """
    
    it "handles arithmetic precedence":
        val code = "1 + 2 * 3"
        check(code.contains("+"))
        check(code.contains("*"))
        
    it "handles comparison precedence":
        val code = "x + 1 < y * 2"
        check(code.contains("<"))
        
    it "handles logical precedence":
        val code = "a or b and c"
        check(code.contains("or"))
        check(code.contains("and"))
        
    it "handles parentheses":
        val code = "(a + b) * c"
        check(code.starts_with("("))


describe "Parser Error Recovery Integration":
    """
    ## Error Handling
    
    Test error recovery during parsing.
    """
    
    it "handles missing parenthesis":
        val invalid = "fn foo(:"
        check(invalid.contains("fn"))
        
    it "handles incomplete expression":
        val invalid = "val x = "
        check(invalid.contains("val"))
        
    it "continues after error":
        val code = "val x = {NL}val y = 42"
        check(code.contains("val y"))


describe "Parser Performance Integration":
    """
    ## Performance Testing
    
    Test parser with complex inputs.
    """
    
    it "parses 50 function definitions":
        var code = ""
        for i in 0..50:
            code = code + "fn f{i}(): pass{NL}"
        
        check(code.contains("fn"))
        
    it "parses deeply nested expressions":
        val code = "((((1 + 2) * 3) - 4) / 5)"
        check(code.count("(") == 4)
        
    it "parses large class definition":
        var code = "class Large:{NL}"
        for i in 0..30:
            code = code + "    field{i}: i64{NL}"
        
        check(code.contains("class"))
