# Core Interpreter â€” Integration Intensive Tests

use compiler.core.interpreter.mod.{core_interpret, core_interpret_expr}
use compiler.core.interpreter.eval.{eval_has_error, eval_get_error}
use compiler.core.interpreter.value.{val_get_int, val_get_text, val_get_bool, val_get_kind, VAL_INT, VAL_TEXT}


fn run_ok(src: text) -> i64:
    val result = core_interpret(src, "test.spl")
    expect(eval_has_error()).to_equal(false)
    result

fn run_expr_ok(src: text) -> i64:
    val result = core_interpret_expr(src)
    expect(eval_has_error()).to_equal(false)
    result

fn run_err(src: text) -> text:
    val result = core_interpret(src, "test.spl")
    expect(eval_has_error()).to_equal(true)
    eval_get_error()


describe "core.interpreter (integration intensive)":
    it "evaluates expressions and main":
        val v = run_expr_ok("1 + 2 * 3")
        expect(val_get_int(v)).to_equal(7)

        val prog = "fn main():\n" +
            "    return 2 + 3\n"
        val r = run_ok(prog)
        expect(val_get_int(r)).to_equal(5)

    it "handles control flow and loops":
        val prog = "fn main():\n" +
            "    var sum = 0\n" +
            "    for i in [1, 2, 3]:\n" +
            "        if i == 2:\n" +
            "            continue\n" +
            "        sum = sum + i\n" +
            "    var n = 0\n" +
            "    while n < 2:\n" +
            "        sum = sum + n\n" +
            "        n = n + 1\n" +
            "    return sum\n"
        val r = run_ok(prog)
        expect(val_get_int(r)).to_equal(5)

    it "handles match and arrays":
        val prog = "fn main():\n" +
            "    val x = 2\n" +
            "    match x:\n" +
            "        case 1:\n" +
            "            return 10\n" +
            "        case 2:\n" +
            "            return 20\n" +
            "    return 0\n"
        val r = run_ok(prog)
        expect(val_get_int(r)).to_equal(20)

        val prog2 = "fn main():\n" +
            "    var a = [10, 20, 30]\n" +
            "    return a[1]\n"
        val r2 = run_ok(prog2)
        expect(val_get_int(r2)).to_equal(20)

    it "handles array/text methods and errors":
        val prog = "fn main():\n" +
            "    var a = [1, 2]\n" +
            "    val b = a.push(3)\n" +
            "    if b.contains(2):\n" +
            "        return b.len()\n" +
            "    return 0\n"
        val r = run_ok(prog)
        expect(val_get_int(r)).to_equal(3)

        val prog2 = "fn main():\n" +
            "    val s = \"abc\"\n" +
            "    if s.contains(\"b\"):\n" +
            "        return s.len()\n" +
            "    return 0\n"
        val r2 = run_ok(prog2)
        expect(val_get_int(r2)).to_equal(3)

        val err = run_err("fn main():\n    var a = [1]\n    val x = a.foo()\n    return x\n")
        expect(err.contains("no method")).to_equal(true)

    it "handles struct fields and assignment":
        val prog = "struct Point:\n" +
            "    x: i64\n" +
            "    y: i64\n" +
            "fn main():\n" +
            "    var p = Point(1, 2)\n" +
            "    p.x = 5\n" +
            "    return p.x\n"
        val r = run_ok(prog)
        expect(val_get_int(r)).to_equal(5)

        val err = run_err("struct Point:\n    x: i64\nfn main():\n    val p = Point(1)\n    return p.z\n")
        expect(err.contains("no field")).to_equal(true)

    it "reports common runtime errors":
        val err1 = run_err("fn main():\n    return unknown\n")
        expect(err1.contains("undefined variable")).to_equal(true)

        val err2 = run_err("fn main():\n    var a = [1]\n    val x = a[2]\n    return x\n")
        expect(err2.contains("array index out of bounds")).to_equal(true)

        val err3 = run_err("fn main():\n    val s = \"hi\"\n    val x = s[2]\n    return x\n")
        expect(err3.contains("string index out of bounds")).to_equal(true)

        val err4 = run_err("fn main():\n    val x = 1\n    val y = x[0]\n    return y\n")
        expect(err4.contains("cannot index")).to_equal(true)

        val err5 = run_err("fn main():\n    1 = 2\n")
        expect(err5.contains("invalid assignment")).to_equal(true)
