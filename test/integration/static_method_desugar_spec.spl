# Static Method Desugaring - Integration Tests
#
# Tests the source-level desugaring of static methods.
# Verifies that:
# 1. Static fn definitions in impl blocks are hoisted to module level
# 2. Type.method() calls are rewritten to Type__method() calls
# 3. Instance methods are preserved in impl blocks
# 4. Chained and nested calls work correctly


use std.spec

use app.desugar.static_methods (desugar_static_methods)
use app.desugar.rewriter (rewrite_static_calls)
use app.desugar.mod (desugar_source)
use std.text.{NL}

describe "Static Method Desugaring":

    context "desugar_static_methods":

        it "hoists a simple static fn to module level":
            val input = "struct Point:{NL}    x: i64{NL}    y: i64{NL}{NL}impl Point:{NL}    static fn origin() -> Point:{NL}        Point(x: 0, y: 0){NL}"
            val output = desugar_static_methods(input)
            # Should contain the hoisted function
            expect(output).to_contain("fn Point__origin() -> Point:")
            expect(output).to_contain("Point(x: 0, y: 0)")

        it "preserves instance methods in impl block":
            val input = "impl Point:{NL}    static fn origin() -> Point:{NL}        Point(x: 0, y: 0){NL}    fn distance() -> f64:{NL}        (self.x ** 2 + self.y ** 2).sqrt(){NL}"
            val output = desugar_static_methods(input)
            # Instance method should remain in impl block
            expect(output).to_contain("impl Point:")
            expect(output).to_contain("fn distance() -> f64:")

        it "handles multiple static methods":
            val input = "impl Builder:{NL}    static fn create() -> Builder:{NL}        Builder(items: []){NL}    static fn from_list(items: [text]) -> Builder:{NL}        Builder(items: items){NL}"
            val output = desugar_static_methods(input)
            expect(output).to_contain("fn Builder__create() -> Builder:")
            expect(output).to_contain("fn Builder__from_list(items: [text]) -> Builder:")

        it "drops empty impl block when all methods are static":
            val input = "impl Config:{NL}    static fn defaults() -> Config:{NL}        Config(value: 0){NL}"
            val output = desugar_static_methods(input)
            expect(output).to_contain("fn Config__defaults() -> Config:")
            # The impl block should be dropped since it would be empty

    context "rewrite_static_calls":

        it "rewrites Type.method() to Type__method()":
            val input = "val p = Point.origin(){NL}"
            val output = rewrite_static_calls(input)
            expect(output).to_contain("Point__origin()")

        it "rewrites calls with arguments":
            val input = "val p = Point.from_pair(1, 2){NL}"
            val output = rewrite_static_calls(input)
            expect(output).to_contain("Point__from_pair(1, 2)")

        it "does not rewrite instance method calls":
            val input = "val d = point.distance(){NL}"
            val output = rewrite_static_calls(input)
            # lowercase receiver should not be rewritten
            expect(output).to_contain("point.distance()")

        it "does not rewrite field access":
            val input = "val x = point.x{NL}"
            val output = rewrite_static_calls(input)
            expect(output).to_contain("point.x")

        it "handles nested static calls":
            val input = "val r = Type.method(Other.factory()){NL}"
            val output = rewrite_static_calls(input)
            expect(output).to_contain("Type__method(Other__factory())")

    context "desugar_source (full pipeline)":

        it "transforms static method definition and call":
            val input = "struct Point:{NL}    x: i64{NL}    y: i64{NL}{NL}impl Point:{NL}    static fn origin() -> Point:{NL}        Point(x: 0, y: 0){NL}{NL}val p = Point.origin(){NL}print p.x{NL}"
            val output = desugar_source(input)
            # Hoisted function
            expect(output).to_contain("fn Point__origin() -> Point:")
            # Rewritten call
            expect(output).to_contain("Point__origin()")
            # Original struct preserved
            expect(output).to_contain("struct Point:")

        it "handles chained calls: Type.method().instance_method()":
            val input = "val result = Builder.create().build(){NL}"
            val output = desugar_source(input)
            # Only the static part should be rewritten
            expect(output).to_contain("Builder__create().build()")

        it "preserves comments and strings":
            val input = "# Point.origin() in a comment{NL}val s = \"Point.origin()\"{NL}val p = Point.origin(){NL}"
            val output = desugar_source(input)
            # Comment should be preserved
            expect(output).to_contain("# Point.origin() in a comment")
            # String should be preserved
            expect(output).to_contain("\"Point.origin()\"")
            # Only the actual call should be rewritten
            expect(output).to_contain("val p = Point__origin()")

# Built-in runtime prints summary automatically
