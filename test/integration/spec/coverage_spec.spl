# Integration tests for Coverage System
# Tests coverage tracking, calculation, and reporting

import spec.{describe, context, it, expect, before_each}
import spec.matchers.{eq, gt, lt, gte, lte, be_true, be_false, include_string, be_empty}
import spec.coverage.calculator.{CoverageCalculator, CoverageStats, CoverageTarget, CoverageLevel, function_coverage, method_coverage, line_coverage}
import spec.coverage.reporter.{TerminalReporter, CompactReporter}
import spec.coverage.html.{HtmlReporter}
import spec.coverage.json.{JsonCoverageReporter, CodecovReporter, CoverallsReporter}

describe "Coverage System Integration":
    context "CoverageCalculator - Function Level":
        it "tracks function coverage":
            val calculator = function_coverage()

            calculator.add_function("add", "math", "public")
            calculator.add_function("subtract", "math", "public")
            calculator.add_function("multiply", "math", "public")

            # Mark some functions as touched
            calculator.mark_function_touched("add", "math", "test_addition")
            calculator.mark_function_touched("subtract", "math", "test_subtraction")

            val stats = calculator.calculate_stats()

            expect(stats.total_count).to eq(3)
            expect(stats.touched_count).to eq(2)
            expect(stats.untouched_count).to eq(1)
            expect(stats.coverage_percentage).to gt(66.0)
            expect(stats.coverage_percentage).to lt(67.0)

        it "tracks multiple touches of same function":
            val calculator = function_coverage()

            calculator.add_function("add", "math", "public")
            calculator.mark_function_touched("add", "math", "test1")
            calculator.mark_function_touched("add", "math", "test2")
            calculator.mark_function_touched("add", "math", "test3")

            val touched = calculator.get_touched()
            expect(touched.len()).to eq(1)
            expect(touched[0].touch_count).to eq(3)
            expect(touched[0].touched_by.len()).to eq(3)

        it "filters by public visibility":
            val calculator = function_coverage()

            calculator.add_function("public_fn", "mod", "public")
            calculator.add_function("private_fn", "mod", "private")

            calculator.mark_function_touched("public_fn", "mod", "test")
            calculator.mark_function_touched("private_fn", "mod", "test")

            val stats = calculator.calculate_stats()

            # Only public function counted
            expect(stats.total_count).to eq(1)
            expect(stats.touched_count).to eq(1)

        it "can include private functions":
            val calculator = function_coverage().include_private()

            calculator.add_function("public_fn", "mod", "public")
            calculator.add_function("private_fn", "mod", "private")

            calculator.mark_function_touched("public_fn", "mod", "test")

            val stats = calculator.calculate_stats()

            # Both functions counted
            expect(stats.total_count).to eq(2)
            expect(stats.touched_count).to eq(1)

    context "CoverageCalculator - Method Level":
        it "tracks method coverage":
            val calculator = method_coverage()

            calculator.add_method("add", "Calculator", "math", "public")
            calculator.add_method("subtract", "Calculator", "math", "public")
            calculator.add_method("new", "Calculator", "math", "public")

            calculator.mark_method_touched("add", "Calculator", "math", "test_add")
            calculator.mark_method_touched("new", "Calculator", "math", "test_add")

            val stats = calculator.calculate_stats()

            expect(stats.total_count).to eq(3)
            expect(stats.touched_count).to eq(2)

        it "distinguishes methods with same name in different structs":
            val calculator = method_coverage()

            calculator.add_method("new", "Calculator", "math", "public")
            calculator.add_method("new", "Parser", "parse", "public")

            calculator.mark_method_touched("new", "Calculator", "math", "test")

            val stats = calculator.calculate_stats()

            expect(stats.touched_count).to eq(1)
            expect(stats.untouched_count).to eq(1)

    context "CoverageCalculator - Line Level":
        it "tracks line coverage":
            val calculator = line_coverage()

            calculator.add_line("file.spl", 10)
            calculator.add_line("file.spl", 15)
            calculator.add_line("file.spl", 20)

            calculator.mark_line_touched("file.spl", 10, "test1")
            calculator.mark_line_touched("file.spl", 15, "test1")

            val stats = calculator.calculate_stats()

            expect(stats.total_count).to eq(3)
            expect(stats.touched_count).to eq(2)

    context "CoverageStats":
        it "calculates coverage percentage correctly":
            val stats = CoverageStats.new(10, 7)

            expect(stats.total_count).to eq(10)
            expect(stats.touched_count).to eq(7)
            expect(stats.untouched_count).to eq(3)
            expect(stats.coverage_percentage).to eq(70.0)

        it "handles 100% coverage":
            val stats = CoverageStats.new(5, 5)

            expect(stats.is_complete()).to be_true()
            expect(stats.coverage_percentage).to eq(100.0)

        it "handles 0% coverage":
            val stats = CoverageStats.new(5, 0)

            expect(stats.is_complete()).to be_false()
            expect(stats.coverage_percentage).to eq(0.0)

        it "handles empty target list":
            val stats = CoverageStats.new(0, 0)

            expect(stats.coverage_percentage).to eq(100.0)
            expect(stats.is_complete()).to be_true()

        it "checks threshold acceptance":
            val stats = CoverageStats.new(10, 8)

            expect(stats.is_acceptable(80.0)).to be_true()
            expect(stats.is_acceptable(85.0)).to be_false()

        it "generates summary string":
            val stats = CoverageStats.new(10, 7)

            val summary = stats.summary()
            expect(summary).to include_string("7/10")
            expect(summary).to include_string("70.00%")

    context "Per-Module Coverage":
        it "calculates module-specific coverage":
            val calculator = function_coverage()

            calculator.add_function("add", "math", "public")
            calculator.add_function("parse", "parser", "public")
            calculator.add_function("format", "formatter", "public")

            calculator.mark_function_touched("add", "math", "test")
            calculator.mark_function_touched("format", "formatter", "test")

            val math_stats = calculator.calculate_module_stats("math")
            expect(math_stats.total_count).to eq(1)
            expect(math_stats.touched_count).to eq(1)

            val parser_stats = calculator.calculate_module_stats("parser")
            expect(parser_stats.total_count).to eq(1)
            expect(parser_stats.touched_count).to eq(0)

        it "lists all modules":
            val calculator = function_coverage()

            calculator.add_function("f1", "mod1", "public")
            calculator.add_function("f2", "mod2", "public")
            calculator.add_function("f3", "mod1", "public")

            val modules = calculator.get_modules()
            expect(modules.len()).to eq(2)
            expect(modules.contains("mod1")).to be_true()
            expect(modules.contains("mod2")).to be_true()

        it "gets entries by module":
            val calculator = function_coverage()

            calculator.add_function("f1", "mod1", "public")
            calculator.add_function("f2", "mod2", "public")
            calculator.add_function("f3", "mod1", "public")

            val mod1_entries = calculator.get_by_module("mod1")
            expect(mod1_entries.len()).to eq(2)

            val mod2_entries = calculator.get_by_module("mod2")
            expect(mod2_entries.len()).to eq(1)

    context "Coverage Queries":
        it "gets untouched targets":
            val calculator = function_coverage()

            calculator.add_function("f1", "mod", "public")
            calculator.add_function("f2", "mod", "public")
            calculator.add_function("f3", "mod", "public")

            calculator.mark_function_touched("f1", "mod", "test")

            val untouched = calculator.get_untouched()
            expect(untouched.len()).to eq(2)

        it "gets touched targets":
            val calculator = function_coverage()

            calculator.add_function("f1", "mod", "public")
            calculator.add_function("f2", "mod", "public")

            calculator.mark_function_touched("f1", "mod", "test")

            val touched = calculator.get_touched()
            expect(touched.len()).to eq(1)
            expect(touched[0].touched).to be_true()

    context "TerminalReporter":
        it "generates coverage summary":
            val calculator = function_coverage()

            calculator.add_function("f1", "mod", "public")
            calculator.add_function("f2", "mod", "public")
            calculator.add_function("f3", "mod", "public")

            calculator.mark_function_touched("f1", "mod", "test")
            calculator.mark_function_touched("f2", "mod", "test")

            val reporter = TerminalReporter.new().without_colors()

            # Just verify it doesn't crash
            # In real usage, would capture output
            reporter.print_report(calculator)

        it "can disable colors":
            val reporter = TerminalReporter.new().without_colors()
            expect(reporter.show_colors).to be_false()

        it "can show/hide sections":
            val reporter = TerminalReporter.new()
                .without_untouched()
                .with_touched()
                .without_per_module()

            expect(reporter.show_untouched).to be_false()
            expect(reporter.show_touched).to be_true()
            expect(reporter.show_per_module).to be_false()

        it "can set threshold":
            val reporter = TerminalReporter.new().with_threshold(90.0)
            expect(reporter.threshold).to eq(90.0)

    context "CompactReporter":
        it "generates compact summary":
            val calculator = function_coverage()

            calculator.add_function("f1", "mod", "public")
            calculator.add_function("f2", "mod", "public")

            calculator.mark_function_touched("f1", "mod", "test")

            val reporter = CompactReporter.new().without_colors()

            # Verify it doesn't crash
            reporter.print_report(calculator)

    context "HtmlReporter":
        it "generates HTML report":
            val calculator = function_coverage()

            calculator.add_function("add", "math", "public")
            calculator.add_function("subtract", "math", "public")

            calculator.mark_function_touched("add", "math", "test")

            val reporter = HtmlReporter.new()
            val html = reporter.generate_html(calculator)

            expect(html).to include_string("<!DOCTYPE html>")
            expect(html).to include_string("Coverage Summary")
            expect(html).to include_string("50.00%")
            expect(html).to include_string("math")

        it "can set custom title":
            val reporter = HtmlReporter.new().with_title("My Coverage Report")
            expect(reporter.title).to eq("My Coverage Report")

        it "can include source":
            val reporter = HtmlReporter.new().with_source()
            expect(reporter.include_source).to be_true()

    context "JsonCoverageReporter":
        it "generates JSON coverage report":
            val calculator = function_coverage()

            calculator.add_function("add", "math", "public")
            calculator.add_function("subtract", "math", "public")

            calculator.mark_function_touched("add", "math", "test")

            val reporter = JsonCoverageReporter.new()
            val json_str = reporter.to_json(calculator)

            expect(json_str).to include_string("summary")
            expect(json_str).to include_string("modules")
            expect(json_str).to include_string("metadata")
            expect(json_str).to include_string("50")  # 50% coverage

        it "can pretty-print JSON":
            val calculator = function_coverage()
            calculator.add_function("f1", "mod", "public")

            val reporter = JsonCoverageReporter.new().with_pretty_print()
            val json_str = reporter.to_json(calculator)

            expect(json_str).to include_string("\n")  # Newlines indicate pretty print

        it "can exclude targets":
            val reporter = JsonCoverageReporter.new().without_targets()
            expect(reporter.include_targets).to be_false()

        it "can include touched_by info":
            val reporter = JsonCoverageReporter.new().with_touched_by()
            expect(reporter.include_touched_by).to be_true()

    context "CodecovReporter":
        it "generates Codecov-compatible JSON":
            val calculator = function_coverage()

            calculator.add_function("f1", "module1", "public")
            calculator.add_function("f2", "module1", "public")

            calculator.mark_function_touched("f1", "module1", "test")

            val reporter = CodecovReporter.new()
            val json_str = reporter.to_json(calculator)

            expect(json_str).to include_string("coverage")
            expect(json_str).to include_string("files")

    context "CoverallsReporter":
        it "generates Coveralls-compatible JSON":
            val calculator = function_coverage()

            calculator.add_function("f1", "module1", "public")
            calculator.add_function("f2", "module1", "public")

            calculator.mark_function_touched("f1", "module1", "test")

            val reporter = CoverallsReporter.new()
            val json_str = reporter.to_json(calculator)

            expect(json_str).to include_string("service_name")
            expect(json_str).to include_string("source_files")

    context "End-to-End Coverage Workflow":
        it "tracks coverage from test execution":
            # Simulate a test suite
            val calculator = function_coverage()

            # Register functions from a hypothetical module
            calculator.add_function("add", "calculator", "public")
            calculator.add_function("subtract", "calculator", "public")
            calculator.add_function("multiply", "calculator", "public")
            calculator.add_function("divide", "calculator", "public")

            # Simulate test execution touching functions
            calculator.mark_function_touched("add", "calculator", "test_addition")
            calculator.mark_function_touched("subtract", "calculator", "test_subtraction")
            calculator.mark_function_touched("multiply", "calculator", "test_multiplication")

            # Calculate coverage
            val stats = calculator.calculate_stats()

            expect(stats.total_count).to eq(4)
            expect(stats.touched_count).to eq(3)
            expect(stats.coverage_percentage).to eq(75.0)

            # Verify we can identify untouched
            val untouched = calculator.get_untouched()
            expect(untouched.len()).to eq(1)

            # Generate reports (verify they don't crash)
            val terminal = TerminalReporter.new().without_colors()
            terminal.print_report(calculator)

            val html = HtmlReporter.new().generate_html(calculator)
            expect(html).to include_string("75.00%")

            val json = JsonCoverageReporter.new().to_json(calculator)
            expect(json).to include_string("\"coverage_percentage\":75")

