# Integration tests for Test Runner
# Tests the complete test execution pipeline

import spec.{describe, context, it, expect, before_each, after_each}
import spec.matchers.{eq, be_empty, gt, be_true, be_false}
import spec.runner.executor.{TestExecutor, ExecutionResults, TestStatus, run_tests}
import spec.runner.filter.{TestFilter}
import spec.registry.{reset_registry, ExampleGroup, Example}

describe "Test Runner Integration":
    before_each:
        reset_registry()

    context "TestExecutor":
        it "runs a simple passing test":
            describe "Sample":
                it "passes":
                    expect(1 + 1).to eq(2)

            val executor = TestExecutor.new()
            val results = executor.run()

            expect(results.total_count()).to eq(1)
            expect(results.passed_count()).to eq(1)
            expect(results.failed_count()).to eq(0)

        it "captures test failures":
            var test_failed = false

            describe "Sample":
                it "fails":
                    test_failed = true
                    expect(1 + 1).to eq(3)  # This will fail

            val executor = TestExecutor.new()
            val results = executor.run()

            expect(test_failed).to be_true()
            expect(results.total_count()).to eq(1)
            expect(results.failed_count()).to eq(1)

        it "tracks pending tests":
            describe "Sample":
                skip "not implemented":
                    pass

            val executor = TestExecutor.new()
            val results = executor.run()

            expect(results.total_count()).to eq(1)
            expect(results.pending_count()).to eq(1)

        it "runs multiple tests":
            describe "Calculator":
                it "adds":
                    expect(2 + 3).to eq(5)
                it "subtracts":
                    expect(5 - 2).to eq(3)
                it "multiplies":
                    expect(3 * 4).to eq(12)

            val executor = TestExecutor.new()
            val results = executor.run()

            expect(results.total_count()).to eq(3)
            expect(results.passed_count()).to eq(3)

        it "runs tests in nested contexts":
            describe "Calculator":
                context "addition":
                    it "adds positive numbers":
                        expect(2 + 3).to eq(5)
                    it "adds negative numbers":
                        expect(-2 + -3).to eq(-5)

                context "subtraction":
                    it "subtracts numbers":
                        expect(5 - 2).to eq(3)

            val executor = TestExecutor.new()
            val results = executor.run()

            expect(results.total_count()).to eq(3)
            expect(results.passed_count()).to eq(3)

    context "Hook execution":
        it "executes before_each hooks":
            var setup_count = 0

            describe "Sample":
                before_each:
                    setup_count = setup_count + 1

                it "test 1":
                    expect(setup_count).to eq(1)
                it "test 2":
                    expect(setup_count).to eq(2)

            val executor = TestExecutor.new()
            val results = executor.run()

            expect(setup_count).to eq(2)
            expect(results.passed_count()).to eq(2)

        it "executes after_each hooks":
            var cleanup_count = 0

            describe "Sample":
                after_each:
                    cleanup_count = cleanup_count + 1

                it "test 1":
                    pass
                it "test 2":
                    pass

            val executor = TestExecutor.new()
            val results = executor.run()

            expect(cleanup_count).to eq(2)

        it "executes before_all and after_all hooks":
            var before_all_count = 0
            var after_all_count = 0

            describe "Sample":
                before_all:
                    before_all_count = before_all_count + 1

                after_all:
                    after_all_count = after_all_count + 1

                it "test 1":
                    expect(before_all_count).to eq(1)
                it "test 2":
                    expect(before_all_count).to eq(1)

            val executor = TestExecutor.new()
            val results = executor.run()

            expect(before_all_count).to eq(1)
            expect(after_all_count).to eq(1)

        it "executes hooks in correct order (parent then child)":
            var hook_order: List<text> = []

            describe "Parent":
                before_each:
                    hook_order.push("parent_before")

                after_each:
                    hook_order.push("parent_after")

                context "Child":
                    before_each:
                        hook_order.push("child_before")

                    after_each:
                        hook_order.push("child_after")

                    it "test":
                        hook_order.push("test")

            val executor = TestExecutor.new()
            val results = executor.run()

            # Expected order: parent_before, child_before, test, child_after, parent_after
            expect(hook_order[0]).to eq("parent_before")
            expect(hook_order[1]).to eq("child_before")
            expect(hook_order[2]).to eq("test")
            expect(hook_order[3]).to eq("child_after")
            expect(hook_order[4]).to eq("parent_after")

    context "Filtering":
        it "filters by tag":
            describe "Sample":
                it "test 1":
                    pass
                it "test 2":
                    pass.with_tag("slow")

            val executor = TestExecutor.new()
            # TODO: Apply tag filter when executor supports it
            val results = executor.run()

            # Without filter, both run
            expect(results.total_count()).to eq(2)

        it "skips slow tests by default":
            describe "Sample":
                it "fast test":
                    pass
                slow_it "slow test":
                    pass

            val executor = TestExecutor.new()
            val results = executor.run()

            # slow_it tests are skipped unless RUN_SLOW_TESTS=1
            expect(results.skipped_count()).to gt(0)

        it "runs slow tests when enabled":
            describe "Sample":
                it "fast test":
                    pass
                slow_it "slow test":
                    pass

            val executor = TestExecutor.new().with_slow_tests(true)
            val results = executor.run()

            expect(results.total_count()).to eq(2)
            expect(results.skipped_count()).to eq(0)

    context "ExecutionResults":
        it "calculates success rate":
            describe "Sample":
                it "pass 1":
                    expect(true).to be_true()
                it "pass 2":
                    expect(true).to be_true()
                it "fail 1":
                    expect(true).to be_false()  # Will fail

            val executor = TestExecutor.new()
            val results = executor.run()

            val rate = results.success_rate()
            expect(rate).to gt(0.6)  # 2/3 = 0.666...
            expect(rate).to lt(0.7)

        it "identifies when all tests passed":
            describe "Sample":
                it "test 1":
                    pass
                it "test 2":
                    pass

            val executor = TestExecutor.new()
            val results = executor.run()

            expect(results.all_passed()).to be_true()

        it "identifies when tests failed":
            describe "Sample":
                it "pass":
                    pass
                it "fail":
                    expect(true).to be_false()

            val executor = TestExecutor.new()
            val results = executor.run()

            expect(results.all_passed()).to be_false()
            expect(results.has_failures()).to be_true()

        it "tracks test duration":
            describe "Sample":
                it "quick test":
                    pass

            val executor = TestExecutor.new()
            val results = executor.run()

            expect(results.total_duration_ms).to gt(0.0)

    context "run_tests convenience function":
        it "runs all registered tests":
            describe "Sample":
                it "test 1":
                    pass
                it "test 2":
                    pass

            val results = run_tests()

            expect(results.total_count()).to eq(2)
            expect(results.passed_count()).to eq(2)
