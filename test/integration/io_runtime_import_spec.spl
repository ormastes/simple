use std.io_runtime.{ShellResult, shell, shell_output, shell_bool, file_exists, file_read, file_write, file_delete, env_get, env_set, cwd, host_os, host_arch}

describe "std.io_runtime imports":
    it "shell returns ShellResult":
        val result = shell("echo hello")
        expect(result.exit_code).to_equal(0)
        expect(result.stdout.trim()).to_equal("hello")

    it "shell_output returns trimmed stdout":
        val out = shell_output("echo world")
        expect(out).to_equal("world")

    it "shell_bool returns bool":
        expect(shell_bool("true")).to_equal(true)
        expect(shell_bool("false")).to_equal(false)

    it "file_write and file_read round-trip":
        val path = "/tmp/io_runtime_test_{cwd().len()}.txt"
        file_write(path, "hello io_runtime")
        val content = file_read(path)
        expect(content.trim()).to_equal("hello io_runtime")
        file_delete(path)

    it "file_exists works":
        expect(file_exists("/tmp")).to_equal(true)
        expect(file_exists("/tmp/nonexistent_io_runtime_test_xyz")).to_equal(false)

    it "env_get and env_set work":
        env_set("IO_RUNTIME_TEST_VAR", "test_value")
        val v = env_get("IO_RUNTIME_TEST_VAR")
        expect(v).to_equal("test_value")

    it "cwd returns non-empty":
        val dir = cwd()
        val has_content = dir.len() > 0
        expect(has_content).to_equal(true)

    it "host_os returns known value":
        val os = host_os()
        val is_known = os == "linux" or os == "macos" or os == "freebsd"
        expect(is_known).to_equal(true)

    it "host_arch returns known value":
        val arch = host_arch()
        val is_known = arch == "x86_64" or arch == "aarch64"
        expect(is_known).to_equal(true)
