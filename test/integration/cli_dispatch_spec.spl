# CLI Dispatch Integration Tests
#
# Verifies that the command dispatch system routes commands correctly
# and falls back to Rust when needed.
#
# Tests Phase 1B implementation: FFI bridge + dispatch integration

use app.cli.dispatch.{find_command, get_all_commands, command_count, simple_impl_count, coverage_percentage}
use app.io.mod (env_set, env_get)

extern fn rt_time_now_unix_micros() -> i64
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

describe "CLI Command Dispatch System":
    """
    ## Phase 1B: FFI Bridge and Integration

    Tests the command table and dispatch logic for routing CLI commands.

    **Status:** Phase 1B Implementation
    **Coverage:** 48 commands, 98% Simple implementations
    """

    # =========================================================================
    # Test Group 1: Command Table Structure
    # =========================================================================

    describe "Command Table":
        it "has 48 total commands":
            val count = command_count()
            expect count == 48

        it "has 47 Simple implementations":
            val simple_count = simple_impl_count()
            expect simple_count >= 47  # At least 47 (test might be Rust-only)

        it "has 98% coverage":
            val coverage = coverage_percentage()
            expect coverage >= 97.0  # At least 97%

    # =========================================================================
    # Test Group 2: Command Lookup
    # =========================================================================

    describe "Command Lookup":
        it "finds compile command":
            match find_command("compile"):
                case Some(entry):
                    expect entry.name == "compile"
                    expect entry.app_path == "src/app/compile/main.spl"
                case None:
                    fail "compile command not found"

        it "finds build command":
            match find_command("build"):
                case Some(entry):
                    expect entry.name == "build"
                    expect entry.app_path == "src/app/build/main.spl"
                case None:
                    fail "build command not found"

        it "returns None for invalid command":
            val result = find_command("invalid-command-xyz")
            expect not result.?

    # =========================================================================
    # Test Group 3: Environment Override Detection
    # =========================================================================

    describe "Environment Overrides":
        it "detects SIMPLE_COMPILE_RUST override":
            env_set("SIMPLE_COMPILE_RUST", "1")
            val entry = find_command("compile").unwrap()
            val should_rust = entry.should_use_rust(["compile", "test.spl"])
            expect should_rust

        it "does not override when env var is unset":
            env_set("SIMPLE_COMPILE_RUST", "")
            val entry = find_command("compile").unwrap()
            val should_rust = entry.should_use_rust(["compile", "test.spl"])
            expect not should_rust

    # =========================================================================
    # Test Group 4: Special Flag Detection
    # =========================================================================

    describe "Special Flags":
        it "detects --json flag for lint":
            val entry = find_command("lint").unwrap()
            val should_rust = entry.should_use_rust(["lint", "--json", "file.spl"])
            expect should_rust

        it "detects --fix flag for lint":
            val entry = find_command("lint").unwrap()
            val should_rust = entry.should_use_rust(["lint", "--fix", "file.spl"])
            expect should_rust

        it "does not trigger on regular args":
            val entry = find_command("lint").unwrap()
            val should_rust = entry.should_use_rust(["lint", "file.spl"])
            expect not should_rust

    # =========================================================================
    # Test Group 5: Simple Implementation Detection
    # =========================================================================

    describe "Simple Implementation Detection":
        it "reports Simple impl exists for compile":
            val entry = find_command("compile").unwrap()
            expect entry.has_simple_impl()

        it "reports Simple impl exists for build":
            val entry = find_command("build").unwrap()
            expect entry.has_simple_impl()

        it "reports no Simple impl for test":
            val entry = find_command("test").unwrap()
            expect not entry.has_simple_impl()  # Rust-only (cargo integration)

    # =========================================================================
    # Test Group 6: Command Categories
    # =========================================================================

    describe "Command Categories":
        it "has all compilation commands":
            val commands = ["compile", "targets", "linkers", "check"]
            for cmd in commands:
                val entry = find_command(cmd)
                expect entry.?

        it "has all code quality commands":
            val commands = ["lint", "fix", "fmt"]
            for cmd in commands:
                val entry = find_command(cmd)
                expect entry.?

        it "has all build system commands":
            val commands = ["build", "run", "clean"]
            for cmd in commands:
                val entry = find_command(cmd)
                expect entry.?

        it "has all package management commands":
            val commands = ["init", "install", "add", "remove", "list", "tree"]
            for cmd in commands:
                val entry = find_command(cmd)
                expect entry.?

        it "has all documentation commands":
            val commands = ["feature-gen", "spec-gen", "todo-scan", "brief"]
            for cmd in commands:
                val entry = find_command(cmd)
                expect entry.?

# =============================================================================
# Performance Tests (DISABLED - run separately with benchmarking)
# =============================================================================

describe "CLI Dispatch Performance":
    """
    ## Performance Verification

    These tests verify that dispatch overhead is <10ms.
    Run separately with benchmarking tools.

    **Target:** <10ms dispatch overhead vs direct Rust handler
    **Measurement:** time simple compile --help (should be <25ms total)
    """

    describe "Dispatch Performance":
        it "dispatches in under 10ms overhead":
            # Target: <10ms dispatch overhead; generous limit (50ms) for CI variability
            val start = rt_time_now_unix_micros()
            val (stdout, stderr, code) = rt_process_run("bin/release/simple", ["compile", "--help"])
            val end = rt_time_now_unix_micros()
            val elapsed_ms = (end - start) / 1000
            expect elapsed_ms < 50

        it "startup completes in under 25ms":
            # Target: <25ms startup; generous limit (100ms) for CI variability
            val start = rt_time_now_unix_micros()
            val (stdout, stderr, code) = rt_process_run("bin/release/simple", ["--version"])
            val end = rt_time_now_unix_micros()
            val elapsed_ms = (end - start) / 1000
            expect elapsed_ms < 100

# =============================================================================
# Robustness Tests
# =============================================================================

describe "CLI Dispatch Robustness":
    """
    ## Robustness Verification

    Tests error handling and edge cases in command dispatch.
    """

    describe "Error Handling":
        it "handles missing command gracefully":
            val result = find_command("nonexistent-cmd")
            expect not result.?

        it "handles empty command name":
            val result = find_command("")
            expect not result.?

    describe "Edge Cases":
        it "handles command with no Simple impl":
            val entry = find_command("test").unwrap()
            expect not entry.has_simple_impl()
            # Should fallback to Rust without crashing

        it "handles command with empty app_path":
            val entry = find_command("test").unwrap()
            expect entry.app_path == ""
            expect not entry.has_simple_impl()
