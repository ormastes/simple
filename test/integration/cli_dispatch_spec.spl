# CLI Dispatch Integration Tests
#
# Verifies that the command dispatch system routes commands correctly
# and falls back to Rust when needed.
#
# Tests Phase 1B implementation: FFI bridge + dispatch integration

# @skip - Uses unsupported keyword: with
use std.spec
# Skipped: COMMAND_TABLE and related functions not exported from app.cli.dispatch module
# use app.cli.dispatch (find_command, dispatch_command, COMMAND_TABLE, command_count, simple_impl_count, coverage_percentage)
# use app.io (env_set, env_get)

describe "CLI Command Dispatch System":
    """
    ## Phase 1B: FFI Bridge and Integration

    Tests the command table and dispatch logic for routing CLI commands.

    **Status:** Phase 1B Implementation
    **Coverage:** 48 commands, 98% Simple implementations
    """

    # =========================================================================
    # Test Group 1: Command Table Structure
    # =========================================================================

    describe "Command Table":
        skip_it "has 48 total commands":
            val count = command_count()
            expect count == 48

        skip_it "has 47 Simple implementations":
            val simple_count = simple_impl_count()
            expect simple_count >= 47  # At least 47 (test might be Rust-only)

        skip_it "has 98% coverage":
            val coverage = coverage_percentage()
            expect coverage >= 97.0  # At least 97%

    # =========================================================================
    # Test Group 2: Command Lookup
    # =========================================================================

    describe "Command Lookup":
        skip_it "finds compile command":
            match find_command("compile"):
                case Some(entry):
                    expect entry.name == "compile"
                    expect entry.app_path == "src/app/compile/main.spl"
                case None:
                    fail "compile command not found"

        skip_it "finds build command":
            match find_command("build"):
                case Some(entry):
                    expect entry.name == "build"
                    expect entry.app_path == "src/app/build/main.spl"
                case None:
                    fail "build command not found"

        skip_it "returns None for invalid command":
            val result = find_command("invalid-command-xyz")
            expect not result.?

    # =========================================================================
    # Test Group 3: Environment Override Detection
    # =========================================================================

    describe "Environment Overrides":
        skip_it "detects SIMPLE_COMPILE_RUST override":
            env_set("SIMPLE_COMPILE_RUST", "1")
            val entry = find_command("compile").unwrap()
            val should_rust = entry.should_use_rust(["compile", "test.spl"])
            expect should_rust

        skip_it "does not override when env var is unset":
            env_set("SIMPLE_COMPILE_RUST", "")
            val entry = find_command("compile").unwrap()
            val should_rust = entry.should_use_rust(["compile", "test.spl"])
            expect not should_rust

    # =========================================================================
    # Test Group 4: Special Flag Detection
    # =========================================================================

    describe "Special Flags":
        skip_it "detects --json flag for lint":
            val entry = find_command("lint").unwrap()
            val should_rust = entry.should_use_rust(["lint", "--json", "file.spl"])
            expect should_rust

        skip_it "detects --fix flag for lint":
            val entry = find_command("lint").unwrap()
            val should_rust = entry.should_use_rust(["lint", "--fix", "file.spl"])
            expect should_rust

        skip_it "does not trigger on regular args":
            val entry = find_command("lint").unwrap()
            val should_rust = entry.should_use_rust(["lint", "file.spl"])
            expect not should_rust

    # =========================================================================
    # Test Group 5: Simple Implementation Detection
    # =========================================================================

    describe "Simple Implementation Detection":
        skip_it "reports Simple impl exists for compile":
            val entry = find_command("compile").unwrap()
            expect entry.has_simple_impl()

        skip_it "reports Simple impl exists for build":
            val entry = find_command("build").unwrap()
            expect entry.has_simple_impl()

        skip_it "reports no Simple impl for test":
            val entry = find_command("test").unwrap()
            expect not entry.has_simple_impl()  # Rust-only (cargo integration)

    # =========================================================================
    # Test Group 6: Command Categories
    # =========================================================================

    describe "Command Categories":
        skip_it "has all compilation commands":
            val commands = ["compile", "targets", "linkers", "check"]
            for cmd in commands:
                val entry = find_command(cmd)
                expect entry.?

        skip_it "has all code quality commands":
            val commands = ["lint", "fix", "fmt"]
            for cmd in commands:
                val entry = find_command(cmd)
                expect entry.?

        skip_it "has all build system commands":
            val commands = ["build", "run", "clean"]
            for cmd in commands:
                val entry = find_command(cmd)
                expect entry.?

        skip_it "has all package management commands":
            val commands = ["init", "install", "add", "remove", "list", "tree"]
            for cmd in commands:
                val entry = find_command(cmd)
                expect entry.?

        skip_it "has all documentation commands":
            val commands = ["feature-gen", "spec-gen", "todo-scan", "brief"]
            for cmd in commands:
                val entry = find_command(cmd)
                expect entry.?

# =============================================================================
# Performance Tests (DISABLED - run separately with benchmarking)
# =============================================================================

# These tests are disabled by default because they measure timing
# Run with: simple test --tag=perf test/integration/cli_dispatch_spec.spl

describe "CLI Dispatch Performance":  # skip:
    """
    ## Performance Verification

    These tests verify that dispatch overhead is <10ms.
    Run separately with benchmarking tools.

    **Target:** <10ms dispatch overhead vs direct Rust handler
    **Measurement:** time simple compile --help (should be <25ms total)
    """

    describe "Dispatch Performance":
        # TODO: Implement when benchmark infrastructure is ready
        skip_it "dispatches in under 10ms overhead":
            skip "Benchmark infrastructure not yet implemented"

        skip_it "startup completes in under 25ms":
            skip "Benchmark infrastructure not yet implemented"

# =============================================================================
# Robustness Tests
# =============================================================================

describe "CLI Dispatch Robustness":
    """
    ## Robustness Verification

    Tests error handling and edge cases in command dispatch.
    """

    describe "Error Handling":
        skip_it "handles missing command gracefully":
            val result = find_command("nonexistent-cmd")
            expect not result.?

        skip_it "handles empty command name":
            val result = find_command("")
            expect not result.?

    describe "Edge Cases":
        skip_it "handles command with no Simple impl":
            val entry = find_command("test").unwrap()
            expect not entry.has_simple_impl()
            # Should fallback to Rust without crashing

        skip_it "handles command with empty app_path":
            val entry = find_command("test").unwrap()
            expect entry.app_path == ""
            expect not entry.has_simple_impl()
