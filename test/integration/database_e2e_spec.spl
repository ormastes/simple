# Database End-to-End System Tests
#
# Tests complete workflows from database creation through querying and persistence


use std.spec.{check, check_msg}
use lib.database.core.{SdnDatabase, SdnTable, SdnRow, StringInterner}
use lib.database.bug.{create_bug_database, load_bug_database, Bug, BugSeverity, BugStatus}
use lib.database.atomic.{atomic_read, atomic_write}
use std.string.{NL}

extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_rename(from: text, to: text) -> bool
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn file_exists(path: text) -> bool:
    rt_file_exists(path)
fn file_delete(path: text) -> bool:
    rt_file_delete(path)
fn file_write(path: text, content: text) -> bool:
    rt_file_write_text(path, content)
fn file_read(path: text) -> text:
    val result = rt_file_read_text(path)
    result ?? ""

describe "End-to-End Bug Database Workflow":
    it "creates, populates, saves, and reloads database":
        val db_path = "/tmp/test_e2e_bugdb.sdn"

        # Clean up if exists
        if file_exists(db_path):
            file_delete(db_path)

        # Step 1: Create new database
        var bugdb = create_bug_database(db_path)
        check(not file_exists(db_path))  # Not saved yet

        # Step 2: Add bugs
        val bug1 = Bug(
            id: "e2e_001",
            severity: BugSeverity.P0,
            status: BugStatus.Open,
            title: "Critical bug",
            description: ["This is critical", "Needs immediate fix"],
            file: "main.spl",
            line: 42,
            reproducible_by: "test_e2e_critical",
            fix_strategy: ["Step 1", "Step 2"],
            investigation_log: ["Log entry 1"],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        val bug2 = Bug(
            id: "e2e_002",
            severity: BugSeverity.P1,
            status: BugStatus.Investigating,
            title: "High priority bug",
            description: ["Under investigation"],
            file: "lib.spl",
            line: 100,
            reproducible_by: "test_e2e_high",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        bugdb.add_bug(bug1)
        bugdb.add_bug(bug2)

        # Step 3: Save database
        val saved = bugdb.save()
        check(saved)
        check(file_exists(db_path))

        # Step 4: Load database in new instance
        val loaded_opt = load_bug_database(db_path)
        expect(loaded_opt.?).to_equal(true)

        val loaded_db = loaded_opt?

        # Step 5: Verify loaded data
        val all_bugs = loaded_db.all_bugs()
        check(all_bugs.len() == 2)

        val bug1_loaded = loaded_db.get_bug("e2e_001")
        expect(bug1_loaded.?).to_equal(true)
        expect(bug1_loaded?.title).to_equal("Critical bug")
        expect(bug1_loaded?.severity).to_equal(BugSeverity.P0)
        check(bug1_loaded?.description.len() == 2)

        # Cleanup
        file_delete(db_path)

    it "updates bug and persists changes":
        val db_path = "/tmp/test_e2e_update.sdn"

        # Create and save initial bug
        var bugdb = create_bug_database(db_path)

        val original_bug = Bug(
            id: "update_001",
            severity: BugSeverity.P1,
            status: BugStatus.Open,
            title: "Original title",
            description: ["Original description"],
            file: "test.spl",
            line: 1,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        bugdb.add_bug(original_bug)
        bugdb.save()

        # Load, update, and save again
        var loaded_db = load_bug_database(db_path)?

        val updated_bug = Bug(
            id: "update_001",
            severity: BugSeverity.P0,  # Changed
            status: BugStatus.Fixed,   # Changed
            title: "Updated title",    # Changed
            description: ["New description", "With more details"],  # Changed
            file: "test.spl",
            line: 1,
            reproducible_by: "test",
            fix_strategy: ["Applied fix"],  # Changed
            investigation_log: ["Fixed the issue"],  # Changed
            created_at: "2026-02-05",
            updated_at: "2026-02-06",  # Changed
            valid: true
        )

        loaded_db.update_bug("update_001", updated_bug)
        loaded_db.save()

        # Load again and verify changes
        var final_db = load_bug_database(db_path)?
        val final_bug = final_db.get_bug("update_001")?

        match final_bug.severity:
            BugSeverity.P0: assert true
            _: fail("Expected P0 severity")
        match final_bug.status:
            BugStatus.Fixed: assert true
            _: fail("Expected Fixed status")
        expect(final_bug.title).to_equal("Updated title")
        check(final_bug.description.len() == 2)
        check(final_bug.fix_strategy.len() == 1)
        expect(final_bug.updated_at).to_equal("2026-02-06")

        # Cleanup
        file_delete(db_path)

    it "handles concurrent database access":
        val db_path = "/tmp/test_e2e_concurrent.sdn"

        # Create initial database
        var bugdb1 = create_bug_database(db_path)
        bugdb1.add_bug(Bug(
            id: "concurrent_001",
            severity: BugSeverity.P2,
            status: BugStatus.Open,
            title: "Bug 1",
            description: ["First bug"],
            file: "test.spl",
            line: 1,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )
        )
        bugdb1.save()

        # Load in two separate instances
        var bugdb2 = load_bug_database(db_path)?
        var bugdb3 = load_bug_database(db_path)?

        # Add bugs in different instances
        bugdb2.add_bug(Bug(
            id: "concurrent_002",
            severity: BugSeverity.P2,
            status: BugStatus.Open,
            title: "Bug 2",
            description: ["Second bug"],
            file: "test.spl",
            line: 2,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        ))

        bugdb3.add_bug(Bug(
            id: "concurrent_003",
            severity: BugSeverity.P2,
            status: BugStatus.Open,
            title: "Bug 3",
            description: ["Third bug"],
            file: "test.spl",
            line: 3,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        ))

        # Save both (last write wins)
        bugdb2.save()
        bugdb3.save()

        # Load and verify
        var final_db = load_bug_database(db_path)?
        val all_bugs = final_db.all_bugs()

        # Should have bugs from last save
        check(all_bugs.len() > 0)

        # Cleanup
        file_delete(db_path)

    it "queries bugs across multiple criteria":
        val db_path = "/tmp/test_e2e_query.sdn"
        var bugdb = create_bug_database(db_path)

        # Add diverse set of bugs
        val bug_data = [
            ("query_001", BugSeverity.P0, BugStatus.Open, "Critical open bug"),
            ("query_002", BugSeverity.P0, BugStatus.Fixed, "Critical fixed bug"),
            ("query_003", BugSeverity.P1, BugStatus.Open, "High priority open"),
            ("query_004", BugSeverity.P1, BugStatus.Investigating, "High priority investigating"),
            ("query_005", BugSeverity.P2, BugStatus.Open, "Medium priority open"),
            ("query_006", BugSeverity.P2, BugStatus.Fixed, "Medium priority fixed"),
            ("query_007", BugSeverity.P3, BugStatus.Closed, "Low priority closed"),
        ]

        for data in bug_data:
            val bug = Bug(
                id: data.0,
                severity: data.1,
                status: data.2,
                title: data.3,
                description: [data.3],
                file: "test.spl",
                line: 1,
                reproducible_by: "test",
                fix_strategy: [],
                investigation_log: [],
                created_at: "2026-02-05",
                updated_at: "2026-02-05",
                valid: true
            )
            bugdb.add_bug(bug)

        bugdb.save()

        # Load and query
        var loaded_db = load_bug_database(db_path)?

        # Test: All bugs
        val all = loaded_db.all_bugs()
        check(all.len() == 7)

        # Test: Open bugs (Open + Investigating + Confirmed)
        val open = loaded_db.open_bugs()
        check(open.len() == 4)  # query_001, 003, 004, 005

        # Test: Critical bugs (P0 + P1)
        val critical = loaded_db.critical_bugs()
        check(critical.len() == 4)  # query_001, 002, 003, 004

        # Test: Bugs by severity
        val p0_bugs = loaded_db.bugs_by_severity(BugSeverity.P0)
        check(p0_bugs.len() == 2)

        # Test: Bugs by status
        val fixed_bugs = loaded_db.bugs_by_status(BugStatus.Fixed)
        check(fixed_bugs.len() == 2)

        # Test: Statistics
        val stats = loaded_db.stats()
        expect(stats.total).to_equal(7)
        expect(stats.open).to_equal(4)
        expect(stats.fixed).to_equal(2)
        expect(stats.p0).to_equal(2)
        expect(stats.health).to_equal("critical") # Has P0 bugs

        # Cleanup
        file_delete(db_path)

    it "validates bug data integrity":
        val db_path = "/tmp/test_e2e_validate.sdn"
        var bugdb = create_bug_database(db_path)

        # Add bug without test link
        val bug_no_test = Bug(
            id: "validate_001",
            severity: BugSeverity.P0,
            status: BugStatus.Open,
            title: "Bug without test",
            description: ["No test case"],
            file: "test.spl",
            line: 1,
            reproducible_by: "",  # Empty test link
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        # Add critical bug without fix strategy
        val bug_no_fix = Bug(
            id: "validate_002",
            severity: BugSeverity.P1,
            status: BugStatus.Open,
            title: "Critical without fix",
            description: ["No fix strategy"],
            file: "test.spl",
            line: 2,
            reproducible_by: "test_link",
            fix_strategy: [],  # Empty fix strategy
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        bugdb.add_bug(bug_no_test)
        bugdb.add_bug(bug_no_fix)
        bugdb.save()

        # Load and validate
        var loaded_db = load_bug_database(db_path)?

        # Validate test links
        val test_errors = loaded_db.validate_test_links()
        check(test_errors.len() > 0)
        check(test_errors[0].contains("validate_001"))

        # Validate fix strategies
        val fix_errors = loaded_db.validate_fix_strategy()
        check(fix_errors.len() > 0)
        check(fix_errors[0].contains("validate_002"))

        # Cleanup
        file_delete(db_path)

describe "Database File Format":
    it "saves in SDN format":
        val db_path = "/tmp/test_e2e_format.sdn"
        var bugdb = create_bug_database(db_path)

        bugdb.add_bug(Bug(
            id: "format_001",
            severity: BugSeverity.P1,
            status: BugStatus.Open,
            title: "Format test",
            description: ["Testing SDN format"],
            file: "test.spl",
            line: 1,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        ))

        bugdb.save()

        # Read raw file
        val content = atomic_read(db_path) ?? ""

        # Should be in SDN format
        check(content.contains("bugs |"))
        check(content.contains("format_001"))
        check(content.contains("Format test"))

        # Cleanup
        file_delete(db_path)

    it "handles special characters in data":
        val db_path = "/tmp/test_e2e_special.sdn"
        var bugdb = create_bug_database(db_path)

        val bug = Bug(
            id: "special_001",
            severity: BugSeverity.P1,
            status: BugStatus.Open,
            title: "Bug with \"quotes\" and 'apostrophes'",
            description: ["Line 1{NL}Line 2", "Tab\there", "Special: | , []"],
            file: "test.spl",
            line: 1,
            reproducible_by: "test_special_chars",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        bugdb.add_bug(bug)
        bugdb.save()

        # Load and verify
        var loaded_db = load_bug_database(db_path)?
        val loaded_bug = loaded_db.get_bug("special_001")?

        check(loaded_bug.title.contains("quotes"))
        check(loaded_bug.title.contains("apostrophes"))
        check(loaded_bug.description.len() == 3)

        # Cleanup
        file_delete(db_path)
