"""
# STDLIB Module Comprehensive Test


**Feature IDs:** #STDLIB
**Category:** Standard Library
**Status:** Implemented
"""

use std.spec.{check}
use std.text.{NL}

describe "STDLIB Module Complete Test":
    it "basic operation 1":
        check(1 + 1 == 2)
        
    it "basic operation 2":
        val x = "test"
        check(x.len() == 4)
        
    it "basic operation 3":
        val arr = [1, 2, 3]
        check(arr.len() == 3)
        
    it "type conversion 1":
        val s = "42"
        check(s.len() == 2)
        
    it "type conversion 2":
        val num = 42
        check(num > 0)
        
    it "collection operations 1":
        val arr = [1, 2, 3, 4, 5]
        var sum = 0
        for x in arr:
            sum = sum + x
        check(sum == 15)
        
    it "collection operations 2":
        val arr = [1, 2, 3]
        val result = arr.append(4)
        check(result.len() == 4)
        
    it "collection operations 3":
        val arr = [1, 2, 3, 4, 5]
        var evens = []
        for x in arr:
            if x % 2 == 0:
                evens = evens.append(x)
        check(evens.len() == 2)
        
    it "string operations 1":
        val s = "hello"
        check(s.starts_with("hel"))
        
    it "string operations 2":
        val s = "world"
        check(s.ends_with("rld"))
        
    it "string operations 3":
        val s = "test string"
        check(s.contains("str"))
        
    it "option handling 1":
        val opt = Some(42)
        check(opt.?)
        check(opt? == 42)
        
    it "option handling 2":
        val opt = nil
        check(not opt.?)
        
    it "option handling 3":
        val opt = Some(100)
        val result = opt ?? 0
        check(result == 100)
        
    it "option handling 4":
        val opt = nil
        val result = opt ?? 99
        check(result == 99)
        
    it "error path 1":
        val opt = nil
        if opt.?:
            check(false)
        else:
            check(true)
            
    it "error path 2":
        val arr = []
        check(arr.len() == 0)
        
    it "error path 3":
        var error = nil
        check(error == nil)
        
    it "edge case 1 - empty":
        val s = ""
        check(s.len() == 0)
        
    it "edge case 2 - zero":
        check(0 == 0)
        check(not (0 > 0))
        
    it "edge case 3 - negative":
        check(-1 < 0)
        
    it "edge case 4 - large":
        check(999999 > 0)
        
    it "edge case 5 - single element":
        val arr = [1]
        check(arr.len() == 1)
        check(arr[0] == 1)
        
    it "boundary 1 - min":
        val arr = [1, 2, 3]
        check(arr[0] == 1)
        
    it "boundary 2 - max":
        val arr = [1, 2, 3]
        check(arr[-1] == 3)
        
    it "conditional 1":
        if true:
            check(true)
        else:
            check(false)
            
    it "conditional 2":
        val x = 10
        if x > 5:
            check(true)
        else:
            check(false)
            
    it "conditional 3":
        val x = 3
        if x > 10:
            check(false)
        elif x > 5:
            check(false)
        else:
            check(true)
            
    it "loop 1 - for":
        var count = 0
        for i in 0..10:
            count = count + 1
        check(count == 10)
        
    it "loop 2 - while":
        var count = 0
        while count < 5:
            count = count + 1
        check(count == 5)
        
    it "loop 3 - break":
        var count = 0
        for i in 0..100:
            count = count + 1
            if count == 5:
                break
        check(count == 5)
        
    it "loop 4 - continue":
        var executed = 0
        for i in 0..10:
            if i % 2 == 0:
                continue
            executed = executed + 1
        check(executed == 5)
        
    it "match 1":
        val opt = Some(1)
        match opt:
            Some(x): check(x == 1)
            nil: check(false)
            
    it "match 2":
        val opt = nil
        match opt:
            Some(x): check(false)
            nil: check(true)
            
    it "match 3":
        val value = 2
        val result = match value:
            1: "one"
            2: "two"
            3: "three"
            _: "other"
        check(result == "two")
        
    it "nested 1":
        if true:
            if true:
                check(true)
            else:
                check(false)
        else:
            check(false)
            
    it "nested 2":
        for i in 0..3:
            for j in 0..3:
                check(i >= 0 and j >= 0)
                
    it "complex 1":
        val arr = [1, 2, 3, 4, 5]
        var result = []
        for x in arr:
            if x % 2 == 0:
                result = result.append(x * 2)
        check(result.len() == 2)
        
    it "complex 2":
        val dict = {"a": 1, "b": 2, "c": 3}
        var total = 0
        val keys = dict_keys(dict)
        for key in keys:
            total = total + dict[key]
        check(total == 6)
        
    it "integration 1":
        val data = [1, 2, 3]
        var processed = []
        for x in data:
            processed = processed.append(x * 2)
        var sum = 0
        for x in processed:
            sum = sum + x
        check(sum == 12)
        
    it "integration 2":
        val input = "test"
        val stage1 = input + "_1"
        val stage2 = stage1 + "_2"
        val stage3 = stage2 + "_3"
        check(stage3 == "test_1_2_3")
