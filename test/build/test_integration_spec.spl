# Test Integration - SSpec Tests
# Comprehensive BDD tests for Phase 2 (Test Integration)

use app.build.test (
    TestConfig,
    TestResult,
    TestResults,
    TestOrchestrator,
    default_test_config
)

describe "Build System Phase 2: Test Integration":

    describe "TestConfig":
        slow_it "should create default config":
            val config = default_test_config()
            expect config.filter == ""
            expect config.level == ""
            expect config.tag == ""
            expect config.fail_fast == false
            expect config.timeout == 300
            expect config.parallel == false

        slow_it "should support custom filter":
            val config = TestConfig(
                filter: "integration",
                level: "",
                tag: "",
                fail_fast: false,
                timeout: 300,
                parallel: false,
                rust_only: false,
                doc_only: false,
                simple_only: false
            )
            expect config.filter == "integration"

        slow_it "should support fail-fast mode":
            val config = TestConfig(
                filter: "",
                level: "",
                tag: "",
                fail_fast: true,
                timeout: 300,
                parallel: false,
                rust_only: false,
                doc_only: false,
                simple_only: false
            )
            expect config.fail_fast == true

        slow_it "should support custom timeout":
            val config = TestConfig(
                filter: "",
                level: "",
                tag: "",
                fail_fast: false,
                timeout: 600,
                parallel: false,
                rust_only: false,
                doc_only: false,
                simple_only: false
            )
            expect config.timeout == 600

        slow_it "should support parallel execution":
            val config = TestConfig(
                filter: "",
                level: "",
                tag: "",
                fail_fast: false,
                timeout: 300,
                parallel: true,
                rust_only: false,
                doc_only: false,
                simple_only: false
            )
            expect config.parallel == true

        slow_it "should support rust-only mode":
            val config = TestConfig(
                filter: "",
                level: "",
                tag: "",
                fail_fast: false,
                timeout: 300,
                parallel: false,
                rust_only: true,
                doc_only: false,
                simple_only: false
            )
            expect config.rust_only == true

        slow_it "should support doc-only mode":
            val config = TestConfig(
                filter: "",
                level: "",
                tag: "",
                fail_fast: false,
                timeout: 300,
                parallel: false,
                rust_only: false,
                doc_only: true,
                simple_only: false
            )
            expect config.doc_only == true

        slow_it "should support simple-only mode":
            val config = TestConfig(
                filter: "",
                level: "",
                tag: "",
                fail_fast: false,
                timeout: 300,
                parallel: false,
                rust_only: false,
                doc_only: false,
                simple_only: true
            )
            expect config.simple_only == true

        slow_it "should support level filtering":
            val config = TestConfig(
                filter: "",
                level: "unit",
                tag: "",
                fail_fast: false,
                timeout: 300,
                parallel: false,
                rust_only: false,
                doc_only: false,
                simple_only: false
            )
            expect config.level == "unit"

        slow_it "should support tag filtering":
            val config = TestConfig(
                filter: "",
                level: "",
                tag: "slow",
                fail_fast: false,
                timeout: 300,
                parallel: false,
                rust_only: false,
                doc_only: false,
                simple_only: false
            )
            expect config.tag == "slow"

    describe "TestResult":
        slow_it "should represent successful test run":
            val result = TestResult(
                success: true,
                exit_code: 0,
                stdout: "test result: ok",
                stderr: "",
                tests_run: 100,
                tests_passed: 100,
                tests_failed: 0
            )
            expect result.success == true
            expect result.tests_passed == 100

        slow_it "should represent failed test run":
            val result = TestResult(
                success: false,
                exit_code: 1,
                stdout: "",
                stderr: "test result: FAILED",
                tests_run: 100,
                tests_passed: 95,
                tests_failed: 5
            )
            expect result.success == false
            expect result.tests_failed == 5

        slow_it "should track all test counts":
            val result = TestResult(
                success: true,
                exit_code: 0,
                stdout: "",
                stderr: "",
                tests_run: 150,
                tests_passed: 145,
                tests_failed: 5
            )
            expect result.tests_run == 150
            expect result.tests_passed == 145
            expect result.tests_failed == 5

    describe "TestResults":
        slow_it "should aggregate multiple test results":
            val rust_result = TestResult(
                success: true, exit_code: 0, stdout: "", stderr: "",
                tests_run: 50, tests_passed: 50, tests_failed: 0
            )
            val doc_result = TestResult(
                success: true, exit_code: 0, stdout: "", stderr: "",
                tests_run: 30, tests_passed: 30, tests_failed: 0
            )
            val simple_result = TestResult(
                success: true, exit_code: 0, stdout: "", stderr: "",
                tests_run: 20, tests_passed: 20, tests_failed: 0
            )

            val results = TestResults(
                rust: rust_result,
                doc: doc_result,
                simple: simple_result,
                total_duration_ms: 10000
            )

            expect results.total_duration_ms == 10000

        slow_it "should detect all passed":
            val rust_result = TestResult(
                success: true, exit_code: 0, stdout: "", stderr: "",
                tests_run: 50, tests_passed: 50, tests_failed: 0
            )
            val doc_result = TestResult(
                success: true, exit_code: 0, stdout: "", stderr: "",
                tests_run: 30, tests_passed: 30, tests_failed: 0
            )
            val simple_result = TestResult(
                success: true, exit_code: 0, stdout: "", stderr: "",
                tests_run: 20, tests_passed: 20, tests_failed: 0
            )

            val results = TestResults(
                rust: rust_result,
                doc: doc_result,
                simple: simple_result,
                total_duration_ms: 10000
            )

            expect results.all_passed() == true

        slow_it "should detect failures":
            val rust_result = TestResult(
                success: false, exit_code: 1, stdout: "", stderr: "",
                tests_run: 50, tests_passed: 45, tests_failed: 5
            )
            val doc_result = TestResult(
                success: true, exit_code: 0, stdout: "", stderr: "",
                tests_run: 30, tests_passed: 30, tests_failed: 0
            )
            val simple_result = TestResult(
                success: true, exit_code: 0, stdout: "", stderr: "",
                tests_run: 20, tests_passed: 20, tests_failed: 0
            )

            val results = TestResults(
                rust: rust_result,
                doc: doc_result,
                simple: simple_result,
                total_duration_ms: 10000
            )

            expect results.all_passed() == false

        slow_it "should calculate total tests":
            val rust_result = TestResult(
                success: true, exit_code: 0, stdout: "", stderr: "",
                tests_run: 50, tests_passed: 50, tests_failed: 0
            )
            val doc_result = TestResult(
                success: true, exit_code: 0, stdout: "", stderr: "",
                tests_run: 30, tests_passed: 30, tests_failed: 0
            )
            val simple_result = TestResult(
                success: true, exit_code: 0, stdout: "", stderr: "",
                tests_run: 20, tests_passed: 20, tests_failed: 0
            )

            val results = TestResults(
                rust: rust_result,
                doc: doc_result,
                simple: simple_result,
                total_duration_ms: 10000
            )

            expect results.total_tests() == 100

describe "Test Orchestration":

    describe "TestOrchestrator.run":
        slow_it "should execute with default config" skip:
            val config = default_test_config()
            val results = TestOrchestrator.run(config)
            expect results.?
            expect results.total_duration_ms > 0

        slow_it "should run in serial mode" skip:
            var config = default_test_config()
            config.parallel = false
            val results = TestOrchestrator.run(config)
            expect results.?

        slow_it "should run in parallel mode" skip:
            var config = default_test_config()
            config.parallel = true
            val results = TestOrchestrator.run(config)
            expect results.?

        slow_it "should filter by level" skip:
            var config = default_test_config()
            config.level = "unit"
            val results = TestOrchestrator.run(config)
            expect results.?

        slow_it "should filter by tag" skip:
            var config = default_test_config()
            config.tag = "integration"
            val results = TestOrchestrator.run(config)
            expect results.?

        slow_it "should run rust-only tests" skip:
            var config = default_test_config()
            config.rust_only = true
            val results = TestOrchestrator.run(config)
            expect results.doc.tests_run == 0
            expect results.simple.tests_run == 0

        slow_it "should run doc-only tests" skip:
            var config = default_test_config()
            config.doc_only = true
            val results = TestOrchestrator.run(config)
            expect results.rust.tests_run == 0
            expect results.simple.tests_run == 0

        slow_it "should run simple-only tests" skip:
            var config = default_test_config()
            config.simple_only = true
            val results = TestOrchestrator.run(config)
            expect results.rust.tests_run == 0
            expect results.doc.tests_run == 0

describe "Test Filtering":

    describe "Filter patterns":
        slow_it "should filter by pattern" skip:
            var config = default_test_config()
            config.filter = "test_name"
            val results = TestOrchestrator.run(config)
            expect results.?

        slow_it "should filter by level: unit" skip:
            var config = default_test_config()
            config.level = "unit"
            val results = TestOrchestrator.run(config)
            expect results.?

        slow_it "should filter by level: integration" skip:
            var config = default_test_config()
            config.level = "integration"
            val results = TestOrchestrator.run(config)
            expect results.?

        slow_it "should filter by level: system" skip:
            var config = default_test_config()
            config.level = "system"
            val results = TestOrchestrator.run(config)
            expect results.?

describe "Test Error Handling":

    describe "Fail-fast mode":
        slow_it "should stop on first failure when enabled" skip:
            var config = default_test_config()
            config.fail_fast = true
            val results = TestOrchestrator.run(config)
            expect results.?

        slow_it "should continue on failures when disabled" skip:
            var config = default_test_config()
            config.fail_fast = false
            val results = TestOrchestrator.run(config)
            expect results.?

    describe "Timeout handling":
        slow_it "should respect timeout" skip:
            var config = default_test_config()
            config.timeout = 10
            val results = TestOrchestrator.run(config)
            expect results.?

describe "Parallel Execution":

    describe "Parallel vs Serial":
        slow_it "should complete faster with parallel execution" slow skip:
            # Run serial
            var serial_config = default_test_config()
            serial_config.parallel = false
            val serial_results = TestOrchestrator.run(serial_config)
            val serial_duration = serial_results.total_duration_ms

            # Run parallel
            var parallel_config = default_test_config()
            parallel_config.parallel = true
            val parallel_results = TestOrchestrator.run(parallel_config)
            val parallel_duration = parallel_results.total_duration_ms

            # Parallel should be faster (or at least not slower)
            expect parallel_duration <= serial_duration

        slow_it "should produce same results regardless of execution mode" slow skip:
            # Run serial
            var serial_config = default_test_config()
            serial_config.parallel = false
            val serial_results = TestOrchestrator.run(serial_config)

            # Run parallel
            var parallel_config = default_test_config()
            parallel_config.parallel = true
            val parallel_results = TestOrchestrator.run(parallel_config)

            # Same test counts
            expect parallel_results.total_tests() == serial_results.total_tests()
