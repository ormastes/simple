"""
# Driver Native Specification

**Feature IDs:** #TBD
**Category:** Compiler
**Status:** In Progress

## Overview

Tests compiling a simple program through the full compiler driver pipeline
using the native backend (Parse → HIR → MIR → ISel → RegAlloc → Encode → ELF).
"""

use std.spec
use compiler.driver.{CompilerDriver}
use compiler.driver_types.{CompileOptions, CompileMode, OutputFormat, CompileResult}


extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_file_write_text(path: text, content: text) -> bool


describe "Driver Native":
    it "compiles a simple function via driver and exits 0":
        skip_on_interpreter "requires native backend":
            val source = "fn main() -> i64:\n    0\n"
            rt_file_write_text("/tmp/driver_native_input.spl", source)
            var options = CompileOptions(
                mode: CompileMode.Aot,
                input_files: ["/tmp/driver_native_input.spl"],
                output_file: Some("/tmp/driver_native_output"),
                output_format: OutputFormat.Native,
                optimize: false,
                opt_level: nil,
                release: false,
                debug_info: false,
                verbose: false,
                log_level: 0,
                profile: "dev",
                no_borrow_check: true,
                backend: "native",
                interpreter_mode: "optimized",
                gc_off: false
            )
            var driver = CompilerDriver.create(options)
            val result = driver.compile()
            match result:
                case Success(path):
                    if path != nil:
                        val run_r = rt_process_run(path, [])
                        expect(run_r[2]).to_equal(0)
                    else:
                        expect(false).to_equal(true)
                case _:
                    expect(false).to_equal(true)
