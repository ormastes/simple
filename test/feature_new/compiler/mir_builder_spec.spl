"""
# MIR Builder Specification

**Feature IDs:** #TBD
**Category:** Compiler
**Status:** In Progress

## Overview

Tests the MirBuilder API produces correct MIR that the native backend
can compile: builds a function using the builder API and runs it.
"""

use std.spec
use compiler.mir_data.*
use compiler.backend.native.isel_x86_64.{isel_module}
use compiler.backend.native.regalloc.{regalloc_module}
use compiler.backend.native.encode_x86_64.{encode_module}
use compiler.backend.native.mach_inst.{MachModule, EncodedFunction}
use compiler.backend.native.elf_writer.{ElfWriter, ElfReloc, ElfRelocType, ElfSymbol, ElfSymbolBind, ElfSymbolType, elf_writer_x86_64, elf_add_section, elf_add_symbol, new_text_section, new_rodata_section, section_add_reloc, new_func_symbol, new_extern_symbol, write_elf64}


extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn shell(command: text) -> (text, text, i64):
    rt_process_run("sh", ["-c", command])

fn byte_to_hex(b: i64) -> text:
    val digits = "0123456789abcdef"
    "{digits[b / 16]}{digits[b % 16]}"

fn emit_elf_builder(encoded: [EncodedFunction], mach_mod: MachModule) -> [i64]:
    var writer = elf_writer_x86_64()
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [ElfReloc] = []
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    var rodata_off = 0
    var data_label_off: Dict<text, i64> = {}
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx.contains(entry.name):
                val idx = sym_names.len()
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_off[entry.name] = rodata_off
            rodata_off = rodata_off + entry.data.len()

    for ext_sym in mach_mod.extern_symbols:
        if not sym_name_to_idx.contains(ext_sym):
            val idx = sym_names.len()
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    for func in encoded:
        if not sym_name_to_idx.contains(func.name):
            val idx = sym_names.len()
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    var num_cs = 1
    var has_ro = false
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            has_ro = true
    if has_ro:
        num_cs = num_cs + 1
    val sym_base = 1 + num_cs

    for func in encoded:
        var padding = all_code.len() % 16
        if padding != 0:
            padding = 16 - padding
        var pi = 0
        while pi < padding:
            all_code = all_code + [0xcc]
            pi = pi + 1
        func_offsets[func.name] = all_code.len()
        val code_start = all_code.len()
        all_code = all_code + func.code
        for reloc in func.relocations:
            var reloc_type = ElfRelocType.X86_64_PLT32
            if reloc.reloc_type == 2:
                reloc_type = ElfRelocType.X86_64_PC32
            elif reloc.reloc_type == 1:
                reloc_type = ElfRelocType.X86_64_64
            var sym_idx = 0
            if sym_name_to_idx.contains(reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]
            all_relocs = all_relocs + [ElfReloc(
                offset: code_start + reloc.offset,
                reloc_type: reloc_type,
                symbol_index: sym_base + sym_idx,
                addend: reloc.addend
            )]

    var text_section = new_text_section(all_code)
    for reloc in all_relocs:
        text_section = section_add_reloc(text_section, reloc)
    writer = elf_add_section(writer, text_section)

    var rodata_bytes: [i64] = []
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            rodata_bytes = rodata_bytes + entry.data
    if rodata_bytes.len() > 0:
        writer = elf_add_section(writer, new_rodata_section(rodata_bytes))

    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            if data_label_off.contains(entry.name):
                writer = elf_add_symbol(writer, ElfSymbol(
                    name: entry.name,
                    sym_bind: ElfSymbolBind.Local,
                    sym_type: ElfSymbolType.Object,
                    section_index: 2,
                    value: data_label_off[entry.name],
                    size: entry.data.len()
                ))

    for ext_sym in mach_mod.extern_symbols:
        writer = elf_add_symbol(writer, new_extern_symbol(ext_sym))
    for func in encoded:
        var fo = 0
        if func_offsets.contains(func.name):
            fo = func_offsets[func.name]
        writer = elf_add_symbol(writer, new_func_symbol(func.name, 1, fo, func.code.len()))
    write_elf64(writer)

fn build_30_module() -> MirModule:
    val i64_type = MirType(kind: MirTypeKind.I64)
    val bool_type = MirType(kind: MirTypeKind.Bool)
    val unit_type = MirType(kind: MirTypeKind.Unit)
    val main_sig = MirSignature(params: [], return_type: i64_type, is_variadic: false)
    val dummy_span = Span(start: 0, end: 0, line: 0, col: 0)

    var builder = MirBuilder.new()
    builder.begin_function(SymbolId.new(0), "main", main_sig, dummy_span)

    val then_block = builder.new_block(Some("then"))
    val else_block = builder.new_block(Some("else"))
    val exit_block = builder.new_block(Some("exit"))

    val x_local = builder.new_temp(i64_type)
    builder.emit_const(x_local, MirConstValue.Int(10), i64_type)
    val y_local = builder.new_temp(i64_type)
    builder.emit_const(y_local, MirConstValue.Int(20), i64_type)
    val z_local = builder.emit_binop(MirBinOp.Add, MirOperand(kind: MirOperandKind.Copy(x_local)), MirOperand(kind: MirOperandKind.Copy(y_local)), i64_type)
    val cond_local = builder.emit_binop(MirBinOp.Eq, MirOperand(kind: MirOperandKind.Copy(z_local)), MirOperand(kind: MirOperandKind.Const(MirConstValue.Int(30), i64_type)), bool_type)
    builder.terminate_if(MirOperand(kind: MirOperandKind.Copy(cond_local)), then_block, else_block)

    builder.switch_to_block(then_block)
    val str_then = builder.new_temp(i64_type)
    builder.emit_const(str_then, MirConstValue.Str("30"), i64_type)
    builder.emit_call(MirOperand(kind: MirOperandKind.Const(MirConstValue.Str("puts"), i64_type)), [MirOperand(kind: MirOperandKind.Copy(str_then))], unit_type)
    builder.terminate_goto(exit_block)

    builder.switch_to_block(else_block)
    val str_else = builder.new_temp(i64_type)
    builder.emit_const(str_else, MirConstValue.Str("fail"), i64_type)
    builder.emit_call(MirOperand(kind: MirOperandKind.Const(MirConstValue.Str("puts"), i64_type)), [MirOperand(kind: MirOperandKind.Copy(str_else))], unit_type)
    builder.terminate_goto(exit_block)

    builder.switch_to_block(exit_block)
    val ret_local = builder.new_temp(i64_type)
    builder.emit_const(ret_local, MirConstValue.Int(0), i64_type)
    builder.terminate_return(Some(MirOperand(kind: MirOperandKind.Copy(ret_local))))

    val main_func = builder.end_function()
    builder.add_function(main_func)

    var module_out = builder.module
    module_out.name = "builder_test"
    module_out


describe "MIR Builder":
    it "builds a function module with MirBuilder API":
        skip_on_interpreter "requires native backend":
            val module = build_30_module()
            expect(module.functions.keys().len()).to_equal(1)

    it "compiles MirBuilder module and outputs '30'":
        skip_on_interpreter "requires native backend and linker":
            val module = build_30_module()
            val mach_module = isel_module(module)
            val allocated = regalloc_module(mach_module)
            val encoded_funcs = encode_module(allocated)
            val elf_bytes = emit_elf_builder(encoded_funcs, allocated)

            var offset = 0
            while offset < elf_bytes.len():
                var chunk = ""
                var end_idx = offset + 800
                if end_idx > elf_bytes.len():
                    end_idx = elf_bytes.len()
                var j = offset
                while j < end_idx:
                    chunk = chunk + byte_to_hex(elf_bytes[j])
                    j = j + 1
                if offset == 0:
                    shell("echo -n '{chunk}' > /tmp/mir_builder_spec.hex")
                else:
                    shell("echo -n '{chunk}' >> /tmp/mir_builder_spec.hex")
                offset = end_idx

            shell("xxd -r -p /tmp/mir_builder_spec.hex /tmp/mir_builder_spec.o")
            shell("rm -f /tmp/mir_builder_spec.hex")
            val link_r = rt_process_run("cc", ["-o", "/tmp/mir_builder_spec", "/tmp/mir_builder_spec.o", "-no-pie"])
            expect(link_r[2]).to_equal(0)

            val run_r = rt_process_run("/tmp/mir_builder_spec", [])
            expect(run_r[0].trim()).to_equal("30")
