# DI Extensions System Spec
#
# System test: Feature 5 (DI Extension Container) + Feature 9 (DI Lock)
# working together.
#
# Demonstrates the full lifecycle:
#   - CompileContext.extensions as a DiContainer for plugins
#   - Register plugins before lock
#   - Lock the container
#   - Resolve plugins during compilation
#
# @di_test â€” allows DI modifications in system test environment

use compiler.di.{DiContainer, di_is_system_test_locked}

extern fn rt_env_set(key: text, value: text)

fn make_extensions() -> DiContainer:
    DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)

# ============================================================================
# System Test: F5 + F9 working together
# ============================================================================

describe "DI System: Extensions + Lock integration":

    it "CompileContext extensions starts empty and unlocked":
        # Simulates the extensions field created by CompileContext.create
        val extensions = make_extensions()
        expect(extensions.has("AnyPlugin")).to_equal(false)
        expect(extensions.is_locked()).to_equal(false)

    it "register plugins before lock (setup phase)":
        val extensions = make_extensions()
        extensions.bind_instance("Profiler", "profiler-impl")
        extensions.bind_instance("Formatter", "fmt-impl")
        extensions.bind_instance("Linter", "lint-impl")
        expect(extensions.has("Profiler")).to_equal(true)
        expect(extensions.has("Formatter")).to_equal(true)
        expect(extensions.has("Linter")).to_equal(true)

    it "lock the container after setup":
        val extensions = make_extensions()
        extensions.bind_instance("Plugin", "plugin-v1")
        extensions.lock()
        expect(extensions.is_locked()).to_equal(true)

    it "resolve plugins during compilation (locked)":
        val extensions = make_extensions()
        extensions.bind_instance("Profiler", "profiler-impl")
        extensions.bind_instance("Formatter", "fmt-impl")
        extensions.lock()
        val profiler = extensions.resolve("Profiler")
        val formatter = extensions.resolve("Formatter")
        expect(profiler).to_equal("profiler-impl")
        expect(formatter).to_equal("fmt-impl")

    it "locked extensions rejects new plugin registration":
        val extensions = make_extensions()
        extensions.bind_instance("Plugin", "plugin-v1")
        extensions.lock()
        extensions.bind_instance("NewPlugin", "new-v1")
        expect(extensions.has("NewPlugin")).to_equal(false)

    it "extensions is separate from typed backend":
        # The typed backend is in CompileContext.backend (BackendPort)
        # Extensions only holds plugins explicitly registered
        val extensions = make_extensions()
        val backend_result = extensions.resolve_or("Backend", nil)
        expect(backend_result).to_be_nil()

    it "factory-bound plugin resolves correctly when locked":
        val extensions = make_extensions()
        extensions.bind("AnalysisPlugin", fn(): "analysis-result")
        extensions.lock()
        val result = extensions.resolve("AnalysisPlugin")
        expect(result).to_equal("analysis-result")

    it "full compilation plugin lifecycle":
        # Full lifecycle: setup -> lock -> use -> unlock -> teardown
        val extensions = make_extensions()

        # Setup phase: register plugins
        extensions.bind_instance("TypeChecker", "type-checker-v2")
        extensions.bind_instance("Optimizer", "optimizer-v1")
        extensions.bind("CodeGen", fn(): "codegen-impl")

        # Lock before compilation
        extensions.lock()
        expect(extensions.is_locked()).to_equal(true)

        # Compilation phase: resolve plugins (read-only)
        val checker = extensions.resolve("TypeChecker")
        val optimizer = extensions.resolve("Optimizer")
        val codegen = extensions.resolve("CodeGen")
        expect(checker).to_equal("type-checker-v2")
        expect(optimizer).to_equal("optimizer-v1")
        expect(codegen).to_equal("codegen-impl")

        # Locked: no new bindings during compilation
        extensions.bind_instance("RuntimePlugin", "should-not-register")
        expect(extensions.has("RuntimePlugin")).to_equal(false)

        # Teardown / reconfiguration: unlock
        extensions.unlock()
        expect(extensions.is_locked()).to_equal(false)

        # Can add new plugins after unlock
        extensions.bind_instance("PostPlugin", "post-v1")
        expect(extensions.has("PostPlugin")).to_equal(true)

    it "di_is_system_test_locked returns false in non-system-test env":
        rt_env_set("SIMPLE_SYSTEM_TEST", "0")
        rt_env_set("SIMPLE_DI_TEST", "0")
        val result = di_is_system_test_locked()
        expect(result).to_equal(false)

    it "multiple independent extension containers do not interfere":
        val ext1 = make_extensions()
        val ext2 = make_extensions()
        ext1.bind_instance("Plugin", "from-ext1")
        val result = ext2.resolve_or("Plugin", nil)
        expect(result).to_be_nil()
        val ext1_result = ext1.resolve("Plugin")
        expect(ext1_result).to_equal("from-ext1")
