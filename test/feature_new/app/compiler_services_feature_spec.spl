# CompilerServices Feature Test - Pipeline Stage Ports
#
# Feature-level tests for Feature 2: Pipeline Stage Ports (CompilerServices).
# Covers all four phases end-to-end, one describe block per phase.
#
# Feature: Pipeline Stage Ports (Feature 2)
# Design: doc/report/compiler_mdsoc_impl_plan.md Phase 2
# Source: src/compiler/compiler_services.spl

use compiler.compiler_services.{
    create_default_services,
    LexerPort,
    ParserPort,
    DesugarPort,
    TypeCheckPort,
    HirLowerPort,
    MirLowerPort,
    LoggerPort,
    ModuleLoaderPort,
    CompilerServices
}

# ============================================================================
# Phase 1 - All 9 ports are present with correct names
# ============================================================================

describe "CompilerServices Feature: Phase 1 - All ports present":

    it "lexer port is present":
        val svc = create_default_services()
        expect(svc.lexer.name).to_equal("noop-lexer")

    it "parser port is present":
        val svc = create_default_services()
        expect(svc.parser.name).to_equal("noop-parser")

    it "desugarer port is present":
        val svc = create_default_services()
        expect(svc.desugarer.name).to_equal("noop-desugarer")

    it "type checker port is present":
        val svc = create_default_services()
        expect(svc.type_checker.name).to_equal("noop-type-checker")

    it "HIR lowerer port is present":
        val svc = create_default_services()
        expect(svc.hir_lowerer.name).to_equal("noop-hir-lowerer")

    it "MIR lowerer port is present":
        val svc = create_default_services()
        expect(svc.mir_lowerer.name).to_equal("noop-mir-lowerer")

    it "backend port is present":
        val svc = create_default_services()
        expect(svc.backend.name).to_equal("noop-backend")

    it "logger port is present":
        val svc = create_default_services()
        expect(svc.logger.name).to_equal("noop-logger")

    it "module loader port is present":
        val svc = create_default_services()
        expect(svc.module_loader.name).to_equal("noop-module-loader")

    it "all 9 ports exist in a single services container":
        val svc = create_default_services()
        val names = [
            svc.lexer.name,
            svc.parser.name,
            svc.desugarer.name,
            svc.type_checker.name,
            svc.hir_lowerer.name,
            svc.mir_lowerer.name,
            svc.backend.name,
            svc.logger.name,
            svc.module_loader.name
        ]
        expect(names.len()).to_equal(9)

# ============================================================================
# Phase 2 - Each port fn-field is callable
# ============================================================================

describe "CompilerServices Feature: Phase 2 - Each port callable":

    it "lexer port tokenize_fn is callable":
        val svc = create_default_services()
        val f = svc.lexer.tokenize_fn
        val result = f("source code")
        expect(result.len()).to_equal(0)

    it "lexer port tokenize_fn handles empty string":
        val svc = create_default_services()
        val f = svc.lexer.tokenize_fn
        val result = f("")
        expect(result.len()).to_equal(0)

    it "parser port parse_fn is callable":
        val svc = create_default_services()
        val f = svc.parser.parse_fn
        val errors = f([], "source")
        expect(errors.len()).to_equal(0)

    it "parser port parse_fn accepts non-empty token list":
        val svc = create_default_services()
        val f = svc.parser.parse_fn
        val tokens = ["val", "x", "=", "1"]
        val errors = f(tokens, "val x = 1")
        expect(errors.len()).to_equal(0)

    it "desugarer port desugar_fn is callable":
        val svc = create_default_services()
        val f = svc.desugarer.desugar_fn
        val result = f("val x = 1")
        expect(result).to_equal("val x = 1")

    it "desugarer port desugar_fn passes through empty source":
        val svc = create_default_services()
        val f = svc.desugarer.desugar_fn
        val result = f("")
        expect(result).to_equal("")

    it "type checker port check_fn is callable":
        val svc = create_default_services()
        val f = svc.type_checker.check_fn
        val errors = f("main")
        expect(errors.len()).to_equal(0)

    it "hir lowerer port lower_fn is callable":
        val svc = create_default_services()
        val f = svc.hir_lowerer.lower_fn
        val errors = f("main")
        expect(errors.len()).to_equal(0)

    it "mir lowerer port lower_fn is callable":
        val svc = create_default_services()
        val f = svc.mir_lowerer.lower_fn
        val errors = f("main")
        expect(errors.len()).to_equal(0)

    it "backend port supports_jit_fn is callable":
        val svc = create_default_services()
        val f = svc.backend.supports_jit_fn
        val result = f()
        expect(result).to_equal(false)

    it "backend port target_triple_fn is callable":
        val svc = create_default_services()
        val f = svc.backend.target_triple_fn
        val result = f()
        expect(result).to_equal("noop")

    it "logger port debug_fn is callable":
        val svc = create_default_services()
        val f = svc.logger.debug_fn
        f("debug message")
        expect(svc.logger.name).to_equal("noop-logger")

    it "logger port info_fn is callable":
        val svc = create_default_services()
        val f = svc.logger.info_fn
        f("info message")
        expect(svc.logger.name).to_equal("noop-logger")

    it "logger port warn_fn is callable":
        val svc = create_default_services()
        val f = svc.logger.warn_fn
        f("warn message")
        expect(svc.logger.name).to_equal("noop-logger")

    it "logger port error_fn is callable":
        val svc = create_default_services()
        val f = svc.logger.error_fn
        f("error message")
        expect(svc.logger.name).to_equal("noop-logger")

    it "module loader port load_fn is callable":
        val svc = create_default_services()
        val f = svc.module_loader.load_fn
        val result = f("some/path.spl")
        expect(result).to_equal("")

    it "module loader port resolve_fn is callable":
        val svc = create_default_services()
        val f = svc.module_loader.resolve_fn
        val result = f("/src/main.spl", "std.string")
        expect(result).to_equal("std.string")

# ============================================================================
# Phase 3 - Port replacement: one port can be swapped without affecting others
# ============================================================================

describe "CompilerServices Feature: Phase 3 - Port replacement":

    it "calling create_default_services twice gives independent containers":
        val svc1 = create_default_services()
        val svc2 = create_default_services()
        expect(svc1.lexer.name).to_equal(svc2.lexer.name)
        expect(svc1.parser.name).to_equal(svc2.parser.name)

    it "all ports in two independent containers share the same names":
        val svc1 = create_default_services()
        val svc2 = create_default_services()
        expect(svc1.backend.name).to_equal(svc2.backend.name)
        expect(svc1.logger.name).to_equal(svc2.logger.name)
        expect(svc1.module_loader.name).to_equal(svc2.module_loader.name)

    it "replacing lexer port does not affect parser port name":
        val svc = create_default_services()
        # Verify both ports exist and are independent
        val lexer_name = svc.lexer.name
        val parser_name = svc.parser.name
        expect(lexer_name).to_equal("noop-lexer")
        expect(parser_name).to_equal("noop-parser")

    it "accessing one port does not change another port":
        val svc = create_default_services()
        val lex_f = svc.lexer.tokenize_fn
        val lex_result = lex_f("some source")
        # parser is unaffected
        expect(svc.parser.name).to_equal("noop-parser")
        expect(svc.desugarer.name).to_equal("noop-desugarer")

    it "accessing backend port does not affect logger port":
        val svc = create_default_services()
        val bf = svc.backend.supports_jit_fn
        val jit = bf()
        expect(jit).to_equal(false)
        # logger unaffected
        expect(svc.logger.name).to_equal("noop-logger")

    it "accessing module loader does not affect hir or mir lowerers":
        val svc = create_default_services()
        val lf = svc.module_loader.load_fn
        val loaded = lf("/path/to/module.spl")
        expect(loaded).to_equal("")
        # hir and mir lowerers unchanged
        expect(svc.hir_lowerer.name).to_equal("noop-hir-lowerer")
        expect(svc.mir_lowerer.name).to_equal("noop-mir-lowerer")

# ============================================================================
# Phase 4 - Full pipeline simulation: all 9 stages run sequentially
# ============================================================================

describe "CompilerServices Feature: Phase 4 - Full pipeline simulation":

    it "tokenize stage returns empty token list for noop lexer":
        val svc = create_default_services()
        val src = "fn main(): print 1"
        val lf = svc.lexer.tokenize_fn
        val tokens = lf(src)
        expect(tokens.len()).to_equal(0)

    it "parse stage returns no errors for noop parser":
        val svc = create_default_services()
        val lf = svc.lexer.tokenize_fn
        val tokens = lf("fn main(): print 1")
        val pf = svc.parser.parse_fn
        val parse_errors = pf(tokens, "fn main(): print 1")
        expect(parse_errors.len()).to_equal(0)

    it "desugar stage returns source for noop desugarer":
        val svc = create_default_services()
        val src = "fn main(): print 1"
        val df = svc.desugarer.desugar_fn
        val desugared = df(src)
        expect(desugared).to_equal(src)

    it "type check stage returns no errors for noop checker":
        val svc = create_default_services()
        val cf = svc.type_checker.check_fn
        val type_errors = cf("main")
        expect(type_errors.len()).to_equal(0)

    it "HIR lowering stage returns no errors for noop lowerer":
        val svc = create_default_services()
        val hf = svc.hir_lowerer.lower_fn
        val hir_errors = hf("main")
        expect(hir_errors.len()).to_equal(0)

    it "MIR lowering stage returns no errors for noop lowerer":
        val svc = create_default_services()
        val mf = svc.mir_lowerer.lower_fn
        val mir_errors = mf("main")
        expect(mir_errors.len()).to_equal(0)

    it "backend stage reports no JIT support for noop backend":
        val svc = create_default_services()
        val jit_fn = svc.backend.supports_jit_fn
        val jit_supported = jit_fn()
        expect(jit_supported).to_equal(false)

    it "backend stage reports noop target triple":
        val svc = create_default_services()
        val triple_fn = svc.backend.target_triple_fn
        val triple = triple_fn()
        expect(triple).to_equal("noop")

    it "running through all 9 stages sequentially produces no errors":
        val svc = create_default_services()
        val src = "fn main(): print 1"
        val module_name = "main"

        val lf = svc.lexer.tokenize_fn
        val tokens = lf(src)
        expect(tokens.len()).to_equal(0)

        val pf = svc.parser.parse_fn
        val parse_errs = pf(tokens, src)
        expect(parse_errs.len()).to_equal(0)

        val df = svc.desugarer.desugar_fn
        val desugared = df(src)
        expect(desugared).to_equal(src)

        val cf = svc.type_checker.check_fn
        val type_errs = cf(module_name)
        expect(type_errs.len()).to_equal(0)

        val hf = svc.hir_lowerer.lower_fn
        val hir_errs = hf(module_name)
        expect(hir_errs.len()).to_equal(0)

        val mf = svc.mir_lowerer.lower_fn
        val mir_errs = mf(module_name)
        expect(mir_errs.len()).to_equal(0)

        val jit_fn = svc.backend.supports_jit_fn
        val jit_ok = jit_fn()
        expect(jit_ok).to_equal(false)

        val triple_fn = svc.backend.target_triple_fn
        val triple = triple_fn()
        expect(triple).to_equal("noop")

        val log_f = svc.logger.info_fn
        log_f("pipeline complete")
        expect(svc.logger.name).to_equal("noop-logger")

    it "module loader can resolve and load during pipeline":
        val svc = create_default_services()
        val resolve_fn = svc.module_loader.resolve_fn
        val resolved = resolve_fn("/src/main.spl", "std.math")
        expect(resolved).to_equal("std.math")

        val load_fn = svc.module_loader.load_fn
        val content = load_fn(resolved)
        expect(content).to_equal("")
