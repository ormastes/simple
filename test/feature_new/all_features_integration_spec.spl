# All 9 Features Integration Test
#
# Demonstrates all 9 implemented features interoperating in a realistic
# "compile a file" scenario. Each describe block exercises one feature,
# and a final "Full Pipeline" block shows them working together.
#
# Feature Map:
#   Feature 1: BackendPort        - typed fn-field struct for backend interface
#   Feature 2: CompilerServices   - 9 typed port structs container
#   Feature 3: Default Fields     - field: Type = default (placeholder - in progress)
#   Feature 4: trait keyword      - desugars trait to struct-with-fn-fields
#   Feature 5: DI Extensions      - CompileContext.extensions: DiContainer plugin point
#   Feature 6: Structural Subtyping - compatible struct fields accepted (placeholder - in progress)
#   Feature 7: Implicit Context   - context val / with_context (placeholder - in progress)
#   Feature 8: Architecture Check - arch rule validation across modules
#   Feature 9: DI Lock            - DiContainer.lock() prevents modification

use compiler.compiler_services.{
    create_default_services,
    CompilerServices,
    LexerPort,
    ParserPort,
    DesugarPort,
    TypeCheckPort,
    HirLowerPort,
    MirLowerPort,
    LoggerPort,
    ModuleLoaderPort
}
use compiler.backend_port.{BackendPort}
use app.desugar.trait_desugar (desugar_traits)
use app.cli.arch_check (
    scan_arch_rules, check_arch, ArchRule, ArchViolation,
    _match_pattern, _is_import_allowed
)
use app.io.mod (shell, cwd)
use std.text.{NL}

extern fn rt_env_set(key: text, value: text)

# ============================================================================
# Feature 1: BackendPort - Typed fn-field struct for backend interface
# ============================================================================

describe "Integration Feature 1: BackendPort typed fn-field interface":

    context "BackendPort struct shape":
        it "has name field identifying the backend":
            val services = create_default_services()
            val backend = services.backend
            expect(backend.name).to_equal("noop-backend")

        it "has supports_jit_fn field callable as fn-field":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.supports_jit_fn
            val result = f()
            expect(result).to_equal(false)

        it "has target_triple_fn field callable as fn-field":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.target_triple_fn
            val result = f()
            expect(result).to_equal("noop")

        it "fn-fields are extracted before calling (chained method workaround)":
            # Runtime limitation: chained calls break, must use intermediate var
            val services = create_default_services()
            val backend = services.backend
            val name = backend.name
            expect(name).to_start_with("noop")

# ============================================================================
# Feature 2: CompilerServices - 9 typed port structs container
# ============================================================================

describe "Integration Feature 2: CompilerServices pipeline container":

    context "all 9 ports accessible via create_default_services":
        it "creates services container without error":
            val services = create_default_services()
            expect(services.lexer.name).to_equal("noop-lexer")

        it "has all 9 pipeline stage ports":
            val services = create_default_services()
            val lexer_name = services.lexer.name
            val parser_name = services.parser.name
            val desugar_name = services.desugarer.name
            val checker_name = services.type_checker.name
            val hir_name = services.hir_lowerer.name
            val mir_name = services.mir_lowerer.name
            val backend_name = services.backend.name
            val logger_name = services.logger.name
            val loader_name = services.module_loader.name
            expect(lexer_name).to_equal("noop-lexer")
            expect(parser_name).to_equal("noop-parser")
            expect(desugar_name).to_equal("noop-desugarer")
            expect(checker_name).to_equal("noop-type-checker")
            expect(hir_name).to_equal("noop-hir-lowerer")
            expect(mir_name).to_equal("noop-mir-lowerer")
            expect(backend_name).to_equal("noop-backend")
            expect(logger_name).to_equal("noop-logger")
            expect(loader_name).to_equal("noop-module-loader")

    context "port fn-fields execute noop pipeline steps":
        it "lexer tokenize_fn returns empty list for noop":
            val services = create_default_services()
            val lexer = services.lexer
            val f = lexer.tokenize_fn
            val tokens = f("val x = 1")
            expect(tokens.len()).to_equal(0)

        it "desugarer desugar_fn returns source unchanged for noop":
            val services = create_default_services()
            val desugarer = services.desugarer
            val src = "val x = 1"
            val f = desugarer.desugar_fn
            val result = f(src)
            expect(result).to_equal(src)

        it "type checker check_fn returns empty errors for noop":
            val services = create_default_services()
            val checker = services.type_checker
            val f = checker.check_fn
            val errors = f("main.spl")
            expect(errors.len()).to_equal(0)

        it "module loader resolve_fn returns import name unchanged for noop":
            val services = create_default_services()
            val loader = services.module_loader
            val f = loader.resolve_fn
            val resolved = f("/src/main.spl", "std.string")
            expect(resolved).to_equal("std.string")

# ============================================================================
# Feature 3: Default Field Values (in progress - trivial placeholder)
# ============================================================================

describe "Integration Feature 3: Default Field Values (in progress)":

    context "placeholder - feature not yet fully implemented in runtime":
        it "struct construction works with explicitly provided values":
            # Default field values (field: Type = default) are in progress.
            # For now, all fields must be provided explicitly.
            # This test verifies the current expected behavior.
            val rule = ArchRule(
                init_file: "src/__init__.spl",
                module_path: "src",
                allow_patterns: [],
                deny_patterns: []
            )
            expect(rule.module_path).to_equal("src")

        it "typed port structs are used with explicit field initialization":
            # Once default field values land, ports could use:
            #   name: text = "noop"  instead of requiring explicit name
            # For now, noop factory functions handle defaults.
            val services = create_default_services()
            val name = services.lexer.name
            expect(name).to_equal("noop-lexer")

# ============================================================================
# Feature 4: trait keyword - desugars to struct-with-fn-fields
# ============================================================================

describe "Integration Feature 4: trait keyword desugaring":

    context "trait converts to struct with fn-fields":
        it "basic trait header desugars to struct header":
            var src = "trait Backend:" + NL
            src = src + "    fn run(module: text) -> bool" + NL
            val out = desugar_traits(src)
            expect(out).to_contain("struct Backend:")

        it "fn method desugars to fn-field type":
            var src = "trait Backend:" + NL
            src = src + "    fn run(module: text) -> bool" + NL
            val out = desugar_traits(src)
            expect(out).to_contain("run_fn: fn(text) -> bool")

        it "me method desugars to fn-field (mutability stripped)":
            var src = "trait Lexer:" + NL
            src = src + "    me tokenize(src: text) -> [text]" + NL
            val out = desugar_traits(src)
            expect(out).to_contain("tokenize_fn: fn(text) -> [text]")

        it "trait with multiple methods desugars all to fn-fields":
            var src = "trait PipelineStage:" + NL
            src = src + "    fn process(input: text) -> text" + NL
            src = src + "    fn reset()" + NL
            val out = desugar_traits(src)
            expect(out).to_contain("process_fn: fn(text) -> text")
            expect(out).to_contain("reset_fn: fn()")

    context "impl-for generates factory functions":
        it "impl-for generates a factory function name":
            var src = "impl Logger for console:" + NL
            src = src + "    fn log(msg: text): print(msg)" + NL
            val out = desugar_traits(src)
            expect(out).to_contain("fn console_as_Logger")

        it "generated factory returns the trait type":
            var src = "impl Logger for console:" + NL
            src = src + "    fn log(msg: text): print(msg)" + NL
            val out = desugar_traits(src)
            expect(out).to_contain("-> Logger:")

        it "non-trait source passes through unchanged":
            val src = "val x = 1"
            val out = desugar_traits(src)
            expect(out).to_equal("val x = 1")

# ============================================================================
# Feature 5: DI Extension Container as plugin point
# ============================================================================

describe "Integration Feature 5: DI Extensions as plugin point":

    context "DiContainer as dynamic service registry":
        it "can register and resolve a plugin service":
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.bind_instance("plugin_name", "my_plugin_impl")
            val plugin = di.resolve("plugin_name")
            expect(plugin).to_equal("my_plugin_impl")

        it "can register multiple services":
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.bind_instance("lexer_plugin", "custom-lexer")
            di.bind_instance("parser_plugin", "custom-parser")
            expect(di.has("lexer_plugin")).to_equal(true)
            expect(di.has("parser_plugin")).to_equal(true)

        it "resolve_or returns default when service not registered":
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            val result = di.resolve_or("missing_plugin", "default_impl")
            expect(result).to_equal("default_impl")

        it "has returns false for unregistered service":
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            expect(di.has("not_registered")).to_equal(false)

    context "extensions support factory-based bindings":
        it "bind registers a factory callable":
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.bind("backend_factory", fn(): "factory_result")
            expect(di.has("backend_factory")).to_equal(true)

        it "resolve calls the factory and returns result":
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.bind("version", fn(): "v1.0.0")
            val version = di.resolve("version")
            expect(version).to_equal("v1.0.0")

# ============================================================================
# Feature 6: Structural Subtyping (in progress - placeholder)
# ============================================================================

describe "Integration Feature 6: Structural Subtyping (in progress)":

    context "placeholder - feature not yet fully implemented":
        it "structs with same field names are compatible (placeholder)":
            # Structural subtyping allows a struct with compatible fields
            # to be accepted where another struct type is expected.
            # Currently any struct is accepted for Any-typed fields in DI.
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            val rule = ArchRule(
                init_file: "src/__init__.spl",
                module_path: "src",
                allow_patterns: [],
                deny_patterns: []
            )
            # Store and retrieve a typed struct via DI (Any-typed)
            di.bind_instance("arch_rule", rule)
            expect(di.has("arch_rule")).to_equal(true)

        it "typed port structs demonstrate composition over inheritance":
            # BackendPort and LexerPort are separate structs with fn-fields.
            # Both share the 'name' field - structural compatibility principle.
            val services = create_default_services()
            val backend_name = services.backend.name
            val lexer_name = services.lexer.name
            expect(backend_name.len() > 0).to_equal(true)
            expect(lexer_name.len() > 0).to_equal(true)

# ============================================================================
# Feature 7: Implicit Context Parameters (in progress - placeholder)
# ============================================================================

describe "Integration Feature 7: Implicit Context Parameters (in progress)":

    context "placeholder - context val / with_context not yet implemented":
        it "explicit context passing works as current workaround":
            # Until implicit context params land, services are passed explicitly.
            # This demonstrates the intended usage pattern:
            #   context val services: CompilerServices  -- future syntax
            #   services.lexer.tokenize_fn("input")     -- implicit use
            # Current workaround: pass services as explicit parameter.
            val services = create_default_services()
            val f = services.lexer.tokenize_fn
            val result = f("val x = 1")
            expect(result.len()).to_equal(0)

        it "DI container provides context-like dependency resolution":
            # DiContainer serves as explicit context registry until
            # implicit context parameters are implemented.
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.bind_instance("context_version", "1.0")
            val version = di.resolve("context_version")
            expect(version).to_equal("1.0")

# ============================================================================
# Feature 8: Architecture Validation
# ============================================================================

describe "Integration Feature 8: Architecture validation":

    context "arch rule pattern matching":
        it "matches exact module path":
            val matched = _match_pattern("core/ast", "core/ast")
            expect(matched).to_equal(true)

        it "glob /** matches sub-paths":
            val matched = _match_pattern("compiler/backend/jit", "compiler/**")
            expect(matched).to_equal(true)

        it "denies import matching deny pattern":
            val rule = ArchRule(
                init_file: "src/__init__.spl",
                module_path: "src",
                allow_patterns: [],
                deny_patterns: ["compiler/**"]
            )
            val allowed = _is_import_allowed("compiler/backend", rule)
            expect(allowed).to_equal(false)

        it "allows import not matching deny pattern":
            val rule = ArchRule(
                init_file: "src/__init__.spl",
                module_path: "src",
                allow_patterns: [],
                deny_patterns: ["compiler/**"]
            )
            val allowed = _is_import_allowed("core/ast", rule)
            expect(allowed).to_equal(true)

        it "allows import matching allow pattern":
            val rule = ArchRule(
                init_file: "src/__init__.spl",
                module_path: "src",
                allow_patterns: ["core/**", "std/**"],
                deny_patterns: []
            )
            val allowed = _is_import_allowed("core/ast", rule)
            expect(allowed).to_equal(true)

    context "arch check runs on project":
        it "project source directory is accessible":
            val result = shell("test -d src && echo yes")
            val trimmed = result.stdout.trim()
            expect(trimmed).to_equal("yes")

        it "arch_check source file exists":
            val result = shell("test -f src/app/cli/arch_check.spl && echo yes")
            val trimmed = result.stdout.trim()
            expect(trimmed).to_equal("yes")

        it "check-arch command is wired into main CLI":
            val result = shell("grep -c 'check-arch' src/app/cli/main.spl")
            val count = int(result.stdout.trim())
            expect(count > 0).to_equal(true)

# ============================================================================
# Feature 9: DI Lock - prevents modification after setup
# ============================================================================

describe "Integration Feature 9: DI Lock":

    context "explicit lock prevents modifications":
        it "is_locked returns false before locking":
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            expect(di.is_locked()).to_equal(false)

        it "is_locked returns true after lock()":
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.lock()
            expect(di.is_locked()).to_equal(true)

        it "locked container rejects bind_instance":
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.lock()
            di.bind_instance("new_key", "new_val")
            expect(di.has("new_key")).to_equal(false)

        it "locked container rejects bind factory":
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.lock()
            di.bind("blocked_key", fn(): "blocked")
            expect(di.has("blocked_key")).to_equal(false)

        it "resolve still works when locked":
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.bind_instance("pre_lock_svc", "production-value")
            di.lock()
            val result = di.resolve("pre_lock_svc")
            expect(result).to_equal("production-value")

        it "unlock allows new bindings after lock":
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.lock()
            di.bind_instance("blocked", "x")
            expect(di.has("blocked")).to_equal(false)
            di.unlock()
            di.bind_instance("allowed", "y")
            expect(di.has("allowed")).to_equal(true)

    context "env-var lock (system test protection)":
        it "SIMPLE_SYSTEM_TEST=1 blocks bind operations":
            rt_env_set("SIMPLE_SYSTEM_TEST", "1")
            rt_env_set("SIMPLE_DI_TEST", "0")
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.bind_instance("mock_svc", "mock")
            expect(di.has("mock_svc")).to_equal(false)
            # Cleanup
            rt_env_set("SIMPLE_SYSTEM_TEST", "0")

        it "SIMPLE_DI_TEST=1 bypasses env-var lock":
            rt_env_set("SIMPLE_SYSTEM_TEST", "1")
            rt_env_set("SIMPLE_DI_TEST", "1")
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.bind_instance("test_svc", "test_val")
            expect(di.has("test_svc")).to_equal(true)
            # Cleanup
            rt_env_set("SIMPLE_SYSTEM_TEST", "0")
            rt_env_set("SIMPLE_DI_TEST", "0")

# ============================================================================
# Full Pipeline Integration: All 9 Features Together
# ============================================================================

describe "Integration: Full mini-compiler pipeline (all 9 features)":

    context "simulated compile-a-file scenario":
        it "Step 1+2: create typed service container (Features 1+2)":
            # Feature 2: CompilerServices groups all 9 pipeline ports
            # Feature 1: BackendPort is one of those typed ports
            val services = create_default_services()
            expect(services.backend.name).to_equal("noop-backend")
            expect(services.lexer.name).to_equal("noop-lexer")

        it "Step 4: desugar trait to struct before parse (Feature 4)":
            # Feature 4: trait keyword desugars to struct with fn-fields
            var source = "trait Transformer:" + NL
            source = source + "    fn transform(input: text) -> text" + NL
            val desugared = desugar_traits(source)
            expect(desugared).to_contain("struct Transformer:")
            expect(desugared).to_contain("transform_fn: fn(text) -> text")

        it "Step 4+2: desugared struct matches port pattern (Features 4+2)":
            # A trait-desugared struct has the same shape as compiler port structs:
            # both are structs with fn-fields. This is the core design pattern.
            var source = "trait LexerPlugin:" + NL
            source = source + "    fn tokenize(src: text) -> [text]" + NL
            val desugared = desugar_traits(source)
            # Same fn-field pattern as LexerPort.tokenize_fn
            expect(desugared).to_contain("tokenize_fn: fn(text) -> [text]")

        it "Step 5: register plugin via DI extensions (Feature 5)":
            # Feature 5: extensions DiContainer is the plugin point
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.bind_instance("custom_lexer", "regex-lexer-plugin")
            di.bind_instance("custom_formatter", "pretty-printer-plugin")
            expect(di.has("custom_lexer")).to_equal(true)
            expect(di.has("custom_formatter")).to_equal(true)

        it "Step 5+2: run noop pipeline stages from CompilerServices (Features 5+2)":
            # Simulate running source through the pipeline stages
            val services = create_default_services()
            val source = "val x = 42"

            # Stage 1: Tokenize
            val lex_fn = services.lexer.tokenize_fn
            val tokens = lex_fn(source)

            # Stage 2: Parse
            val parse_fn = services.parser.parse_fn
            val ast_errors = parse_fn(tokens, source)

            # Stage 3: Type check
            val check_fn = services.type_checker.check_fn
            val type_errors = check_fn("main")

            expect(tokens.len()).to_equal(0)
            expect(ast_errors.len()).to_equal(0)
            expect(type_errors.len()).to_equal(0)

        it "Step 9: lock DI after setup (Feature 9)":
            # Feature 9: lock the container after wiring up all services
            val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [], locked: false)
            di.bind_instance("backend", "interpreter-backend")
            di.bind_instance("logger", "file-logger")
            di.lock()

            # Services are accessible
            expect(di.resolve("backend")).to_equal("interpreter-backend")
            expect(di.resolve("logger")).to_equal("file-logger")

            # But no new services can be injected after lock
            di.bind_instance("attack_service", "malicious-mock")
            expect(di.has("attack_service")).to_equal(false)

        it "Step 8: verify architecture rules via check_arch (Feature 8)":
            # Feature 8: arch check validates module dependency rules
            val rule_no_deny = ArchRule(
                init_file: "test/__init__.spl",
                module_path: "test",
                allow_patterns: [],
                deny_patterns: []
            )
            # With no deny rules, any import is allowed
            val ok = _is_import_allowed("compiler/backend", rule_no_deny)
            expect(ok).to_equal(true)

        it "Pipeline: all port names follow naming convention (Features 1+2)":
            # All noop port names start with "noop-" by convention
            val services = create_default_services()
            expect(services.lexer.name).to_start_with("noop")
            expect(services.parser.name).to_start_with("noop")
            expect(services.desugarer.name).to_start_with("noop")
            expect(services.type_checker.name).to_start_with("noop")
            expect(services.hir_lowerer.name).to_start_with("noop")
            expect(services.mir_lowerer.name).to_start_with("noop")
            expect(services.backend.name).to_start_with("noop")
            expect(services.logger.name).to_start_with("noop")
            expect(services.module_loader.name).to_start_with("noop")
