# Backend System Tests
#
# System-level tests for the native compilation backend.
# Verifies end-to-end native compilation scenarios at a system level.

use std.text.{NL}

extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn file_write(path: text, content: text) -> bool:
    rt_file_write_text(path, content)

fn write_source(path: text, content: text) -> bool:
    val cmd = "cat > " + path + " << 'SIMPLE_WRITE_EOF'" + NL + content + NL + "SIMPLE_WRITE_EOF"
    val (out, err, code) = rt_process_run("/bin/sh", ["-c", cmd])
    code == 0

fn interp_print(varname: text) -> text:
    "print \"" + "{" + varname + "}" + "\""

fn file_exists(path: text) -> bool:
    rt_file_exists(path)

fn file_delete(path: text) -> bool:
    rt_file_delete(path)

fn process_run(cmd: text, args: [text]) -> (text, text, i64):
    rt_process_run(cmd, args)

struct ShellResult:
    stdout: text
    stderr: text
    exit_code: i64

fn shell(command: text) -> ShellResult:
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", command])
    ShellResult(stdout: stdout, stderr: stderr, exit_code: code)

describe "Backend System - Compilation Outcomes":
    it "native binary produces correct exit code zero":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_bsys_exit.spl"
        val out_path = "/tmp/sml_bsys_exit_out"
        file_write(src_path, "print \"ok\"")

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_equal(0)
        expect(file_exists(out_path)).to_equal(true)

        val (stdout, stderr, code) = process_run(out_path, [])
        expect(code).to_equal(0)

        file_delete(src_path)
        file_delete(out_path)

    it "compiled binary output matches expected string exactly":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_bsys_exact.spl"
        val out_path = "/tmp/sml_bsys_exact_out"
        file_write(src_path, "print \"exact output test\"")

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_equal(0)

        val (stdout, stderr, code) = process_run(out_path, [])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("exact output test")

        file_delete(src_path)
        file_delete(out_path)

    it "compiled binary handles integer arithmetic":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_bsys_arith.spl"
        val out_path = "/tmp/sml_bsys_arith_out"
        val src = "fn main():" + NL + "    val x = 6" + NL + "    val y = 7" + NL + "    val result = x * y" + NL + "    " + interp_print("result")
        write_source(src_path, src)

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_equal(0)

        val (stdout, stderr, code) = process_run(out_path, [])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("42")

        file_delete(src_path)
        file_delete(out_path)

    it "compiled binary handles string concatenation":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_bsys_strcat.spl"
        val out_path = "/tmp/sml_bsys_strcat_out"
        file_write(src_path, "print \"hello\" + \" \" + \"world\"")

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_equal(0)

        val (stdout, stderr, code) = process_run(out_path, [])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("hello world")

        file_delete(src_path)
        file_delete(out_path)

describe "Backend System - Multi-Line Programs":
    it "compiles program with multiple print statements":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_bsys_multi.spl"
        val out_path = "/tmp/sml_bsys_multi_out"
        val src = "print \"line one\"" + NL + "print \"line two\"" + NL + "print \"line three\""
        write_source(src_path, src)

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_equal(0)

        val (stdout, stderr, code) = process_run(out_path, [])
        expect(code).to_equal(0)
        expect(stdout).to_contain("line one")
        expect(stdout).to_contain("line two")
        expect(stdout).to_contain("line three")

        file_delete(src_path)
        file_delete(out_path)

    it "compiles for loop summing range":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_bsys_forsum.spl"
        val out_path = "/tmp/sml_bsys_forsum_out"
        val src = "fn main():" + NL + "    var total = 0" + NL + "    for i in range(1, 11):" + NL + "        total += i" + NL + "    " + interp_print("total")
        write_source(src_path, src)

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_equal(0)

        val (stdout, stderr, code) = process_run(out_path, [])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("55")

        file_delete(src_path)
        file_delete(out_path)
