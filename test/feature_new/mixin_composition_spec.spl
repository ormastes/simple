"""
# Mixin Composition and Ordering

**Feature IDs:** #TBD
**Category:** Language
**Difficulty:** 3/5
**Status:** Partial (basic composition implemented, advanced resolution planned)

## Overview

Composing multiple mixins with proper field and method resolution.
Tests application order, field shadowing, and method overriding.

## Behavior

- Mixins are applied in declaration order
- Later mixins can shadow fields from earlier ones
- Class methods always override mixin methods
- Diamond composition deduplicates shared mixins
"""


describe "Mixin Composition":
    """
    ## Composition Behavior

    Tests mixin composition including ordering and method resolution.
    """

    context "Basic composition order":
        it "fields from multiple mixins are accessible":
            mixin First:
                a: i64

            mixin Second:
                b: i64

            class Combined:
                use First
                use Second
                c: i64

            val obj = Combined(a: 1, b: 2, c: 3)
            expect obj.a == 1
            expect obj.b == 2
            expect obj.c == 3

        it "methods from multiple mixins resolve":
            mixin Alpha:
                x: i64

                fn get_x() -> i64:
                    return self.x

            mixin Beta:
                y: i64

                fn get_y() -> i64:
                    return self.y

            class Pair:
                use Alpha
                use Beta

            val p = Pair(x: 10, y: 20)
            expect p.get_x() == 10
            expect p.get_y() == 20

        it "three mixins compose correctly":
            mixin MA:
                a: i64
                fn get_a() -> i64:
                    return self.a

            mixin MB:
                b: i64
                fn get_b() -> i64:
                    return self.b

            mixin MC:
                c: i64
                fn get_c() -> i64:
                    return self.c

            class Triple:
                use MA
                use MB
                use MC

            val t = Triple(a: 1, b: 2, c: 3)
            expect t.get_a() == 1
            expect t.get_b() == 2
            expect t.get_c() == 3

    context "Method resolution order":
        it "first mixin method wins when names conflict":
            mixin M1:
                x: i64
                fn value() -> i64:
                    return self.x

            mixin M2:
                y: i64
                fn value() -> i64:
                    return self.y

            class Both:
                use M1
                use M2

            val b = Both(x: 10, y: 20)
            expect b.value() == 10

        it "class method beats mixin method":
            mixin Base:
                n: i64

                fn value() -> i64:
                    return self.n

            class Override:
                use Base

                fn value() -> i64:
                    return self.n * 100

            val o = Override(n: 3)
            expect o.value() == 300

        it "class method overrides even with multiple mixins":
            mixin P:
                p: i64
                fn result() -> i64:
                    return self.p

            mixin Q:
                q: i64
                fn result() -> i64:
                    return self.q

            class PQ:
                use P
                use Q

                fn result() -> i64:
                    return self.p + self.q

            val pq = PQ(p: 3, q: 7)
            expect pq.result() == 10

    context "Cross-mixin method calls":
        it "mixin method can call methods from other mixins on same class":
            mixin HasX:
                x: i64
                fn get_x() -> i64:
                    return self.x

            mixin HasY:
                y: i64
                fn get_y() -> i64:
                    return self.y

            mixin HasSum:
                fn compute_sum() -> i64:
                    return self.get_x() + self.get_y()

            class XYSum:
                use HasX
                use HasY
                use HasSum

            val s = XYSum(x: 10, y: 20)
            expect s.compute_sum() == 30

    context "Mixin reuse across classes":
        it "same mixin applied to multiple classes":
            mixin Taggable:
                tag: text

                fn get_tag() -> text:
                    return self.tag

            class Doc:
                use Taggable
                content: text

            class Image:
                use Taggable
                width: i64

            val d = Doc(tag: "important", content: "hello")
            val i = Image(tag: "photo", width: 800)
            expect d.get_tag() == "important"
            expect i.get_tag() == "photo"

    context "Diamond composition":
        it "handles diamond mixin hierarchy":
            mixin Shared:
                id: i64

                fn get_id() -> i64:
                    return self.id

            mixin Left:
                use Shared
                left_val: i64

            mixin Right:
                use Shared
                right_val: i64

            class Diamond:
                use Left
                use Right

            val d = Diamond(id: 1, left_val: 2, right_val: 3)
            expect d.id == 1
            expect d.left_val == 2
            expect d.right_val == 3

        it "shared mixin applied once":
            mixin Base:
                base: i64

                fn get_base() -> i64:
                    return self.base

            mixin A:
                use Base
                a: i64

            mixin B:
                use Base
                b: i64

            class AB:
                use A
                use B

            val obj = AB(base: 10, a: 20, b: 30)
            expect obj.get_base() == 10
            expect obj.a == 20
            expect obj.b == 30

    context "Deep composition":
        it "supports nested mixin composition":
            mixin Level1:
                x: i64

                fn get_x() -> i64:
                    return self.x

            mixin Level2:
                use Level1
                y: i64

                fn get_y() -> i64:
                    return self.y

            class Deep:
                use Level2

            val d = Deep(x: 1, y: 2)
            expect d.get_x() == 1
            expect d.get_y() == 2

        it "resolves all fields correctly":
            mixin A:
                a: i64

            mixin B:
                use A
                b: i64

            mixin C:
                use B
                c: i64

            class Chain:
                use C

            val obj = Chain(a: 1, b: 2, c: 3)
            expect obj.a == 1
            expect obj.b == 2
            expect obj.c == 3
