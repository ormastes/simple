# Compiler Interpret Pipeline - End-to-End Tests
#
# System-level tests verifying the full shared frontend → interpreter backend pipeline:
# Source → Source Desugar → Preprocessor → Lexer → TreeSitter outline →
# Block Resolver → Parser → AST Desugar → Type Check → HIR →
# Monomorphize → InterpreterBackendImpl → result
#
# Tests write temporary .spl files to /tmp/, invoke interpret_file(path),
# and verify CompileResult.is_success().

use std.text.{NL}
use compiler.driver.{interpret_file, CompileResult}

extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_delete(path: text) -> bool

fn write_spl(path: text, content: text) -> bool:
    rt_file_write_text(path, content)

fn delete_spl(path: text) -> bool:
    rt_file_delete(path)

describe "Compiler Interpret Pipeline - Basic Execution":

    it "basic arithmetic fn main succeeds":
        val src_path = "/tmp/sml_cip_arith.spl"
        write_spl(src_path, "fn main(): 6 * 7")
        val result = interpret_file(src_path)
        expect(result.is_success()).to_equal(true)
        delete_spl(src_path)

    it "variable binding in fn main succeeds":
        val src_path = "/tmp/sml_cip_vars.spl"
        val src = "fn main():" + NL +
            "    val x = 10" + NL +
            "    val y = 20" + NL +
            "    x + y"
        write_spl(src_path, src)
        val result = interpret_file(src_path)
        expect(result.is_success()).to_equal(true)
        delete_spl(src_path)

    it "string print in fn main succeeds":
        val src_path = "/tmp/sml_cip_print.spl"
        write_spl(src_path, "fn main(): print \"hello\"")
        val result = interpret_file(src_path)
        expect(result.is_success()).to_equal(true)
        delete_spl(src_path)

    it "if else expression in fn main succeeds":
        val src_path = "/tmp/sml_cip_ifelse.spl"
        write_spl(src_path, "fn main(): if true: 1 else: 0")
        val result = interpret_file(src_path)
        expect(result.is_success()).to_equal(true)
        delete_spl(src_path)

    it "function call across two fns succeeds":
        val src_path = "/tmp/sml_cip_call.spl"
        val src = "fn add(a, b): a + b" + NL + "fn main(): add(3, 4)"
        write_spl(src_path, src)
        val result = interpret_file(src_path)
        expect(result.is_success()).to_equal(true)
        delete_spl(src_path)

    it "source without fn main returns success":
        val src_path = "/tmp/sml_cip_noname.spl"
        write_spl(src_path, "val x = 42")
        val result = interpret_file(src_path)
        expect(result.is_success()).to_equal(true)
        delete_spl(src_path)
