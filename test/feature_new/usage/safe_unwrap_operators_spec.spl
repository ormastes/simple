"""
# Safe Unwrap Operators Specification

**Feature IDs:** #OPERATORS-SAFE-UNWRAP
**Category:** Syntax
**Status:** Implemented

Safe unwrap operators provide ergonomic ways to extract values from Option<T>
and Result<T, E> types with default fallbacks or error handling. They eliminate
the need for manual pattern matching in common cases while remaining type-safe.

## Syntax

```simple
opt unwrap or: default_value              # Use default if None
opt unwrap else: \: lazy_default_expr     # Lazy evaluation of default
result unwrap or_return: default_on_err   # Early return with default
```

## Key Behaviors

- `unwrap or:` evaluates the default value immediately (eager)
- `unwrap else:` takes a closure for lazy evaluation (only called if needed)
- `unwrap or_return:` returns from the function with a default value on error
- Works with both Option<T> and Result<T, E> types
- Provides inline alternatives to verbose pattern matching
- Type-safe: never causes runtime panics
"""



describe "Safe Unwrap Operators":
    """
    Verifies that safe unwrap operators provide ergonomic value extraction
    from Option and Result types. Tests cover eager evaluation (`unwrap or:`),
    lazy evaluation (`unwrap else:`), and early return (`unwrap or_return:`).
    """

    context "unwrap or: with eager evaluation":
        it "returns value when Option is Some":
            val opt: Option<i64> = Some(42)
            val result = opt unwrap or: 0
            expect result == 42

        it "returns default when Option is None":
            val opt: Option<i64> = None
            val result = opt unwrap or: 0
            expect result == 0

        it "works with Result Ok":
            val res: Result<i64, text> = Ok(42)
            val result = res unwrap or: 0
            expect result == 42

        it "returns default for Result Err":
            val res: Result<i64, text> = Err("error")
            val result = res unwrap or: -1
            expect result == -1

        it "evaluates default expression":
            val opt: Option<i64> = None
            val result = opt unwrap or: 10 + 5
            expect result == 15

        it "handles complex default expressions":
            val opt: Option<text> = None
            val result = opt unwrap or: "default".upper()
            expect result == "DEFAULT"

        it "works with string defaults":
            val opt: Option<text> = None
            val result = opt unwrap or: "fallback"
            expect result == "fallback"

        it "preserves value type through unwrap":
            val opt: Option<i64> = Some(100)
            val result = opt unwrap or: 0
            # Type is still i64
            expect result == 100

    context "unwrap else: with lazy evaluation":
        it "returns value when Option is Some without calling closure":
            val opt: Option<i64> = Some(42)
            var called = false
            val result = opt unwrap else: \:
                called = true
                99
            expect result == 42
            expect called == false

        it "calls closure only when Option is None":
            val opt: Option<i64> = None
            var called = false
            val result = opt unwrap else: \:
                called = true
                99
            expect result == 99
            expect called == true

        it "works with Result Ok without evaluating closure":
            val res: Result<i64, text> = Ok(42)
            var called = false
            val result = res unwrap else: \:
                called = true
                -1
            expect result == 42
            expect called == false

        it "evaluates closure for Result Err":
            val res: Result<i64, text> = Err("failed")
            var called = false
            val result = res unwrap else: \:
                called = true
                -1
            expect result == -1
            expect called == true

        it "closure can perform side effects":
            var side_effect = 0
            val opt: Option<i64> = None
            val result = opt unwrap else: \:
                side_effect = 100
                42
            expect result == 42
            expect side_effect == 100

        it "lazy evaluation skips expensive computation when value exists":
            val opt: Option<i64> = Some(1)
            var expensive_called = false
            val result = opt unwrap else: \:
                expensive_called = true
                999
            expect result == 1
            expect expensive_called == false

    context "unwrap or_return: with early return":
        it "returns value when present":
            fn get_value_or_early() -> i64:
                val opt: Option<i64> = Some(42)
                val value = opt unwrap or_return: 0
                value + 1
            expect get_value_or_early() == 43

        it "returns default when None":
            fn get_value_or_early() -> i64:
                val opt: Option<i64> = None
                val value = opt unwrap or_return: 0
                value + 1  # This code never executes
            expect get_value_or_early() == 0

        it "works with Result":
            fn parse_number_or_early() -> i64:
                val res: Result<i64, text> = Ok(42)
                val value = res unwrap or_return: -1
                value * 2
            expect parse_number_or_early() == 84

        it "returns default for Result Err":
            fn parse_number_or_early() -> i64:
                val res: Result<i64, text> = Err("parse error")
                val value = res unwrap or_return: -1
                value * 2
            expect parse_number_or_early() == -1

    context "chaining and composition":
        it "can chain multiple unwrap operations":
            fn chain_result(opt1, opt2):
                val v1 = opt1 unwrap or: 0
                val v2 = opt2 unwrap or: 0
                v1 + v2
            expect chain_result(Some(10), Some(20)) == 30
            expect chain_result(Some(10), None) == 10
            expect chain_result(None, Some(20)) == 20
            expect chain_result(None, None) == 0

        it "works in nested expressions":
            val opt: Option<i64> = Some(5)
            val result = (opt unwrap or: 0) * 2 + 10
            expect result == 20

    context "type safety":
        it "preserves Option type semantics":
            val maybe_value: Option<text> = Some("hello")
            val text_result = maybe_value unwrap or: "world"
            expect text_result == "hello"

        it "handles nested Option types":
            val nested: Option<Option<i64>> = Some(Some(42))
            # Unwraps outer layer
            val inner = nested unwrap or: Some(0)
            expect inner == Some(42)

        it "preserves Result error information":
            val result: Result<i64, text> = Err("error message")
            val recovered = result unwrap or: 0
            expect recovered == 0
