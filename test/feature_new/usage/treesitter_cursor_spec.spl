"""
# TreeSitter Heuristic Mode Specification

**Feature IDs:** #TS-CURSOR-001 to #TS-CURSOR-015
**Category:** Infrastructure | Parser
**Status:** Implemented

Tests heuristic (line-based) parsing mode of the TreeSitter parser.
Heuristic mode uses simple line scanning instead of full tokenization,
providing error-tolerant results even with malformed input.

## API

```simple
use compiler.treesitter.*
use compiler_core.lexer.*

# Create heuristic-mode parser
var ts = TreeSitter(
    lexer: lexer_new(source),
    current: token_eof(0, 1),
    previous: token_eof(0, 1),
    errors: [],
    doc_comment: nil,
    inline_blocks: [],
    current_context: nil,
    fast_mode: false,
    heuristic_mode: true,
    registry: nil
)
val outline = ts.parse_outline()
```
"""

use compiler.treesitter.*
use compiler_core.lexer.*
use std.text.{NL}


# Helper to create a heuristic-mode TreeSitter
fn make_heuristic_ts(source: text) -> TreeSitter:
    TreeSitter(
        lexer: lexer_new(source),
        current: token_eof(0, 1),
        previous: token_eof(0, 1),
        errors: [],
        doc_comment: nil,
        inline_blocks: [],
        current_context: nil,
        fast_mode: false,
        heuristic_mode: true,
        registry: nil
    )


# ============================================================================
# Test Group 1: Heuristic Function Parsing
# ============================================================================

describe "Heuristic Function Parsing":
    """
    Tests parsing function declarations in heuristic mode.
    """

    it "parses fn declaration":
        val source = "fn hello():{NL}    42"
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 1

    it "parses multiple functions":
        val source = "fn foo():{NL}    1{NL}fn bar():{NL}    2"
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 2


# ============================================================================
# Test Group 2: Heuristic Class Parsing
# ============================================================================

describe "Heuristic Class Parsing":
    """
    Tests parsing class declarations in heuristic mode.
    """

    it "parses class declaration":
        val source = "class Point:{NL}    x: i64{NL}    y: i64"
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        expect outline.classes.len() to_equal 1


# ============================================================================
# Test Group 3: Heuristic Struct Parsing
# ============================================================================

describe "Heuristic Struct Parsing":
    """
    Tests parsing struct declarations in heuristic mode.
    """

    it "parses struct declaration":
        val source = "struct Vec2:{NL}    x: f64{NL}    y: f64"
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        expect outline.structs.len() to_equal 1


# ============================================================================
# Test Group 4: Heuristic Enum Parsing
# ============================================================================

describe "Heuristic Enum Parsing":
    """
    Tests parsing enum declarations in heuristic mode.
    """

    it "parses enum declaration":
        val source = "enum Color:{NL}    Red{NL}    Green{NL}    Blue"
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        expect outline.enums.len() to_equal 1


# ============================================================================
# Test Group 5: Heuristic Trait Parsing
# ============================================================================

describe "Heuristic Trait Parsing":
    """
    Tests parsing trait declarations in heuristic mode.
    """

    it "parses trait declaration":
        val source = "trait Drawable:{NL}    fn draw():{NL}        pass"
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        expect outline.traits.len() to_equal 1


# ============================================================================
# Test Group 6: Heuristic Impl Parsing
# ============================================================================

describe "Heuristic Impl Parsing":
    """
    Tests parsing impl blocks with nested methods in heuristic mode.
    """

    it "parses impl block":
        val source = "impl Point:{NL}    fn get_x() -> i64:{NL}        self.x"
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        expect outline.impls.len() to_equal 1

    it "parses impl with multiple members":
        val source = "impl Point:{NL}    fn get_x() -> i64:{NL}        self.x{NL}    fn get_y() -> i64:{NL}        self.y"
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        expect outline.impls.len() to_equal 1
        # Methods inside impl are collected separately as functions
        expect outline.functions.len() >= 2


# ============================================================================
# Test Group 7: Heuristic Visibility Detection
# ============================================================================

describe "Heuristic Visibility Detection":
    """
    Tests parsing pub visibility in heuristic mode.
    """

    it "detects pub function":
        val source = "pub fn hello():{NL}    42"
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 1

    it "detects pub struct":
        val source = "pub struct Point:{NL}    x: i64"
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        expect outline.structs.len() to_equal 1


# ============================================================================
# Test Group 8: Heuristic Error Tolerance
# ============================================================================

describe "Heuristic Error Tolerance":
    """
    Tests that heuristic mode handles malformed input gracefully.
    """

    it "handles empty source":
        val source = ""
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 0

    it "skips unrecognized lines":
        val source = "some random text{NL}fn valid():{NL}    42"
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        # Should still find the valid function
        expect outline.functions.len() to_equal 1

    it "parses mixed valid and invalid":
        val source = "fn first():{NL}    1{NL}??? invalid ???{NL}fn second():{NL}    2"
        var ts = make_heuristic_ts(source)
        val outline = ts.parse_outline()
        expect outline.functions.len() to_equal 2
