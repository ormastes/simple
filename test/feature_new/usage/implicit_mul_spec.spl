"""
# Implicit Multiplication Specification


use std.text.{NL}
**Feature IDs:** #2240-2245
**Category:** Syntax
**Status:** Implemented

Implicit multiplication in m{} math blocks:
- `2x` → `2 * x`
- `2(x+1)` → `2 * (x+1)`
- `(a)(b)` → `(a) * (b)`
- `(x+1)y` → `(x+1) * y`
"""

describe "Implicit Multiplication in m{}":
    """
    Implicit multiplication allows writing mathematical expressions
    without explicit * operator in m{} blocks only.
    """

    context "number followed by identifier":
        it "treats 2x as 2*x":
            val x = 5
            val result = m{ 2x }
            expect result == 10

        it "treats 3y as 3*y":
            val y = 7
            val result = m{ 3y }
            expect result == 21

        it "works with floats":
            val x = 4.0
            val result = m{ 2.5x }
            expect result == 10.0

    context "number followed by parentheses":
        it "treats 2(x+1) as 2*(x+1)":
            val x = 3
            val result = m{ 2(x + 1) }
            expect result == 8

        it "works in complex expressions":
            val x = 2
            val result = m{ 3(x + 1)^2 }
            expect result == 27  # 3 * (3)^2 = 3 * 9

    context "parentheses followed by parentheses":
        it "treats (a)(b) as (a)*(b)":
            val a = 2
            val b = 3
            val result = m{ (a + 1)(b - 1) }
            expect result == 6  # (3) * (2)

        it "chains multiple groups":
            val a = 2
            val result = m{ (a)(a)(a) }
            expect result == 8  # 2 * 2 * 2

    context "parentheses followed by identifier":
        it "treats (x+1)y as (x+1)*y":
            val x = 2
            val y = 4
            val result = m{ (x + 1)y }
            expect result == 12  # (3) * 4

    context "complex expressions":
        it "computes quadratic with implicit mul":
            val x = 3
            val result = m{ 2x^2 + 3x + 1 }
            expect result == 28  # 2*9 + 3*3 + 1

        it "computes polynomial":
            val x = 2
            val result = m{ x^3 + 2x^2 + 3x + 4 }
            expect result == 26  # 8 + 8 + 6 + 4

        it "mixes explicit and implicit mul":
            val x = 3
            val result = m{ 2x * 3 }
            expect result == 18  # (2*3) * 3

        it "handles scientific notation style":
            val pi = 3.14159
            val r = 2
            val area = m{ pi r^2 }
            expect area.approx(12.566, epsilon: 0.01)

    context "matrix expressions":
        it "multiplies coefficient and matrix":
            val A = [[1, 2], [3, 4]]
            val result = m{ 2A }
            expect result == [[2, 4], [6, 8]]

        it "works in linear algebra":
            val A = [[1, 0], [0, 1]]
            val x = [1, 2]
            val b = [3, 4]
            # 2Ax + b
            val result = m{ 2(A @ x) + b }
            expect result == [5, 8]

    context "precedence":
        it "implicit mul has same precedence as explicit":
            val x = 2
            val y = 3
            # 2x + 3y should be (2*x) + (3*y)
            val result = m{ 2x + 3y }
            expect result == 13  # 4 + 9

        it "power binds tighter":
            val x = 2
            # 2x^3 should be 2*(x^3) not (2*x)^3
            val result = m{ 2x^3 }
            expect result == 16  # 2 * 8

    context "outside m{} blocks":
        it "does NOT allow implicit mul outside m{}":
            # This should not compile or should require explicit *
            val x = 5
            # val result = 2x  # ERROR: would not work
            val result = 2 * x  # Must use explicit *
            expect result == 10

describe "Implicit Multiplication Edge Cases":
    """
    Edge cases and potential ambiguities.
    """

    context "function calls are NOT implicit mul":
        it "preserves function call syntax":
            fn double(x: i64) -> i64:
                x * 2

            val x = 5
            # x(5) would be invalid, not x * 5
            # In m{}, we need to be careful
            val result = double(x)
            expect result == 10

    context "negative numbers":
        it "handles negative coefficient":
            val x = 3
            val result = m{ -2x }
            expect result == -6

        it "handles subtraction vs negative":
            val x = 3
            val y = 2
            # -x y should be (-x) * y
            val result = m{ -x y }
            expect result == -6

    context "whitespace":
        it "works without spaces":
            val x = 5
            val result = m{ 2x+3 }
            expect result == 13

        it "works with spaces":
            val x = 5
            val result = m{ 2 x + 3 }
            expect result == 13
