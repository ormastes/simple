# Native Backend E2E System Tests
#
# System-level tests for the native compilation pipeline.
# Focuses on features not covered in test/unit/compiler/native_compile_spec.spl:
# structs, match expressions, while loops, error handling.
#
# Pattern from test/unit/compiler/native_compile_spec.spl

use std.text.{NL}

extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn file_write(path: text, content: text) -> bool:
    rt_file_write_text(path, content)

fn write_source(path: text, content: text) -> bool:
    val cmd = "cat > " + path + " << 'SIMPLE_WRITE_EOF'" + NL + content + NL + "SIMPLE_WRITE_EOF"
    val (out, err, code) = rt_process_run("/bin/sh", ["-c", cmd])
    code == 0

fn interp_print(varname: text) -> text:
    "print \"" + "{" + varname + "}" + "\""

fn file_exists(path: text) -> bool:
    rt_file_exists(path)

fn file_delete(path: text) -> bool:
    rt_file_delete(path)

fn process_run(cmd: text, args: [text]) -> (text, text, i64):
    rt_process_run(cmd, args)

struct ShellResult:
    stdout: text
    stderr: text
    exit_code: i64

fn shell(command: text) -> ShellResult:
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", command])
    ShellResult(stdout: stdout, stderr: stderr, exit_code: code)

describe "Native Backend E2E - Control Flow":
    it "compiles while loop with counter":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_sys_while.spl"
        val out_path = "/tmp/sml_sys_while_out"
        val src = "fn main():" + NL + "    var i = 0" + NL + "    while i < 5:" + NL + "        i = i + 1" + NL + "    " + interp_print("i")
        write_source(src_path, src)

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_equal(0)

        val (stdout, stderr, code) = process_run(out_path, [])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("5")

        file_delete(src_path)
        file_delete(out_path)

    it "compiles while loop with break":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_sys_break.spl"
        val out_path = "/tmp/sml_sys_break_out"
        val src = "fn main():" + NL + "    var i = 0" + NL + "    while true:" + NL + "        i = i + 1" + NL + "        if i >= 3:" + NL + "            break" + NL + "    " + interp_print("i")
        write_source(src_path, src)

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_equal(0)

        val (stdout, stderr, code) = process_run(out_path, [])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("3")

        file_delete(src_path)
        file_delete(out_path)

    it "compiles nested if-else chain":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_sys_ifelse.spl"
        val out_path = "/tmp/sml_sys_ifelse_out"
        val src = "fn classify(x: i64) -> text:" + NL + "    if x < 0:" + NL + "        return \"negative\"" + NL + "    if x == 0:" + NL + "        return \"zero\"" + NL + "    return \"positive\"" + NL + NL + "fn main():" + NL + "    print classify(-1)" + NL + "    print classify(0)" + NL + "    print classify(1)"
        write_source(src_path, src)

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_equal(0)

        val (stdout, stderr, code) = process_run(out_path, [])
        expect(code).to_equal(0)
        expect(stdout).to_contain("negative")
        expect(stdout).to_contain("zero")
        expect(stdout).to_contain("positive")

        file_delete(src_path)
        file_delete(out_path)

describe "Native Backend E2E - Functions":
    it "compiles mutually recursive functions":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_sys_mutual.spl"
        val out_path = "/tmp/sml_sys_mutual_out"
        val src = "fn is_even(n: i64) -> bool:" + NL + "    if n == 0:" + NL + "        return true" + NL + "    return is_odd(n - 1)" + NL + NL + "fn is_odd(n: i64) -> bool:" + NL + "    if n == 0:" + NL + "        return false" + NL + "    return is_even(n - 1)" + NL + NL + "fn main():" + NL + "    val r1 = is_even(4)" + NL + "    val r2 = is_odd(3)" + NL + interp_print("r1") + NL + interp_print("r2")
        write_source(src_path, src)

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_equal(0)

        val (stdout, stderr, code) = process_run(out_path, [])
        expect(code).to_equal(0)
        expect(stdout).to_contain("true")

        file_delete(src_path)
        file_delete(out_path)

    it "compiles fibonacci iteratively":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_sys_fib.spl"
        val out_path = "/tmp/sml_sys_fib_out"
        val src = "fn fib(n: i64) -> i64:" + NL + "    var a = 0" + NL + "    var b = 1" + NL + "    var i = 0" + NL + "    while i < n:" + NL + "        val tmp = a + b" + NL + "        a = b" + NL + "        b = tmp" + NL + "        i = i + 1" + NL + "    return a" + NL + NL + "fn main():" + NL + "    val result = fib(10)" + NL + interp_print("result")
        write_source(src_path, src)

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_equal(0)

        val (stdout, stderr, code) = process_run(out_path, [])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("55")

        file_delete(src_path)
        file_delete(out_path)

describe "Native Backend E2E - Error Handling":
    it "reports non-zero exit code for missing source file":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_sys_missing_does_not_exist_xyz.spl"
        val out_path = "/tmp/sml_sys_missing_out"

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_be_greater_than(0)

    it "reports non-zero exit code for syntax error in source":
        val gcc_check = shell("command -v gcc >/dev/null 2>&1")
        if gcc_check.exit_code != 0:
            print "  (skipped: gcc not found)"
            return

        val src_path = "/tmp/sml_sys_syntax_err.spl"
        val out_path = "/tmp/sml_sys_syntax_err_out"
        file_write(src_path, "fn broken(: bad syntax here @@@@")

        val (comp_out, comp_err, comp_code) = process_run("bin/release/simple", ["src/app/compile/native.spl", src_path, out_path])
        expect(comp_code).to_be_greater_than(0)

        file_delete(src_path)
