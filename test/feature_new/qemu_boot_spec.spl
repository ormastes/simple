# QEMU Debug Boot Runner Tests
#
# Tests for Phase 3: QEMU/GDB Debug Completion.
# Tests DebugInfo, StopInfo, StackFrame, hex parsing, and DebugBootConfig.

use std.qemu.{QemuArch}
use std.qemu.boot_runner.{BootTestConfig}
use std.qemu.debug_boot_runner.{
use std.text.{NL}
    DebugBootConfig, DebugInfo, StackFrame, StopInfo,
    format_debug_info, analyze_crash, parse_hex_value_u64
}

describe "QEMU Debug Boot Runner":

    # ========================================================================
    # DebugInfo creation and formatting
    # ========================================================================

    describe "DebugInfo":
        it "creates unavailable debug info":
            val info = DebugInfo__unavailable()
            expect(info.available).to_equal(false)
            expect(info.fault_reason).to_equal("Debug info not available")
            expect(info.fault_address).to_equal(0)
            expect(info.registers.len()).to_equal(0)
            expect(info.stack_trace.len()).to_equal(0)

        it "creates debug info from GDB data":
            var regs: Dict<text, u64> = {}
            regs["pc"] = 0x80000000
            regs["x1"] = 0x1234

            val trace: [StackFrame] = []

            val info = DebugInfo__from_gdb(regs, trace, 0x80000000, "Breakpoint hit")
            expect(info.available).to_equal(true)
            expect(info.fault_address).to_equal(0x80000000)
            expect(info.fault_reason).to_equal("Breakpoint hit")
            expect(info.registers.len()).to_equal(2)

        it "formats unavailable debug info":
            val info = DebugInfo__unavailable()
            val text_output = format_debug_info(info)
            expect(text_output).to_equal("Debug information not available")

        it "formats available debug info with registers":
            var regs: Dict<text, u64> = {}
            regs["pc"] = 0x1000

            val trace: [StackFrame] = []
            val info = DebugInfo__from_gdb(regs, trace, 0x1000, "Crash")
            val text_output = format_debug_info(info)

            expect(text_output).to_contain("Fault Address:")
            expect(text_output).to_contain("Fault Reason: Crash")
            expect(text_output).to_contain("Registers:")
            expect(text_output).to_contain("pc:")

        it "formats debug info with stack trace":
            var regs: Dict<text, u64> = {}
            regs["pc"] = 0x2000

            var trace: [StackFrame] = []
            trace.push(StackFrame(
                frame_num: 0,
                address: 0x2000,
                function: "main",
                file: "main.spl",
                line: 10
            ))

            val info = DebugInfo__from_gdb(regs, trace, 0x2000, "Stopped")
            val text_output = format_debug_info(info)

            expect(text_output).to_contain("Stack Trace:")
            expect(text_output).to_contain("main")

    # ========================================================================
    # StopInfo field access
    # ========================================================================

    describe "StopInfo":
        it "creates stop info with reason":
            val info = StopInfo(reason: "breakpoint-hit", address: 0x80000000, signal: "")
            expect(info.reason).to_equal("breakpoint-hit")
            expect(info.address).to_equal(0x80000000)
            expect(info.signal).to_equal("")

        it "creates stop info with signal":
            val info = StopInfo(reason: "signal-received", address: 0x1000, signal: "SIGSEGV")
            expect(info.reason).to_equal("signal-received")
            expect(info.signal).to_equal("SIGSEGV")

        it "creates stop info for normal exit":
            val info = StopInfo(reason: "exited-normally", address: 0, signal: "")
            expect(info.reason).to_equal("exited-normally")
            expect(info.address).to_equal(0)

        it "creates stop info with unknown reason":
            val info = StopInfo(reason: "unknown", address: 0, signal: "")
            expect(info.reason).to_equal("unknown")

    # ========================================================================
    # StackFrame formatting
    # ========================================================================

    describe "StackFrame":
        it "formats frame with file info":
            val frame = StackFrame(
                frame_num: 0,
                address: 0x80000100,
                function: "kernel_main",
                file: "kernel.spl",
                line: 42
            )
            val s = frame.to_string()
            expect(s).to_contain("#0")
            expect(s).to_contain("kernel_main")
            expect(s).to_contain("kernel.spl")
            expect(s).to_contain("42")

        it "formats frame without file info":
            val frame = StackFrame(
                frame_num: 1,
                address: 0x80000200,
                function: "_start",
                file: "",
                line: 0
            )
            val s = frame.to_string()
            expect(s).to_contain("#1")
            expect(s).to_contain("_start")
            expect(s).not.to_contain("at")

        it "formats nested frames with different levels":
            val frame0 = StackFrame(
                frame_num: 0,
                address: 0x1000,
                function: "inner",
                file: "a.spl",
                line: 5
            )
            val frame1 = StackFrame(
                frame_num: 1,
                address: 0x2000,
                function: "outer",
                file: "b.spl",
                line: 10
            )
            val s0 = frame0.to_string()
            val s1 = frame1.to_string()
            expect(s0).to_contain("#0")
            expect(s1).to_contain("#1")
            expect(s0).to_contain("inner")
            expect(s1).to_contain("outer")

    # ========================================================================
    # Hex parsing
    # ========================================================================

    describe "parse_hex_value_u64":
        it "parses hex with 0x prefix":
            val result = parse_hex_value_u64("0x1234")
            expect(result).to_equal(0x1234)

        it "parses hex with 0X prefix":
            val result = parse_hex_value_u64("0X1234")
            expect(result).to_equal(0x1234)

        it "parses hex without prefix":
            val result = parse_hex_value_u64("ff")
            expect(result).to_equal(255)

        it "parses zero":
            val result = parse_hex_value_u64("0x0")
            expect(result).to_equal(0)

        it "parses uppercase hex digits":
            val result = parse_hex_value_u64("0xABCDEF")
            expect(result).to_equal(0xABCDEF)

        it "parses lowercase hex digits":
            val result = parse_hex_value_u64("0xabcdef")
            expect(result).to_equal(0xABCDEF)

        it "parses mixed case hex digits":
            val result = parse_hex_value_u64("0xAbCd")
            expect(result).to_equal(0xABCD)

        it "parses large address":
            val result = parse_hex_value_u64("0x80000000")
            expect(result).to_equal(0x80000000)

    # ========================================================================
    # DebugBootConfig defaults
    # ========================================================================

    describe "DebugBootConfig":
        it "creates config with default values":
            val config = DebugBootConfig__new(QemuArch.RiscV32, "test.elf")
            expect(config.gdb_enabled).to_equal(false)
            expect(config.gdb_port).to_equal(1234)
            expect(config.auto_attach_on_crash).to_equal(true)
            expect(config.single_step).to_equal(false)
            expect(config.breakpoints.len()).to_equal(0)

        it "enables debug mode":
            var config = DebugBootConfig__new(QemuArch.X86, "kernel.elf")
            config.enable_debug()
            expect(config.gdb_enabled).to_equal(true)

        it "sets GDB port":
            var config = DebugBootConfig__new(QemuArch.ARM32, "firmware.elf")
            config.set_gdb_port(5555)
            expect(config.gdb_port).to_equal(5555)

        it "adds breakpoints":
            var config = DebugBootConfig__new(QemuArch.RiscV64, "test.elf")
            config.add_breakpoint(0x80000000)
            config.add_breakpoint(0x80000100)
            expect(config.breakpoints.len()).to_equal(2)

        it "enables single step":
            var config = DebugBootConfig__new(QemuArch.X86_64, "test.elf")
            config.enable_single_step()
            expect(config.single_step).to_equal(true)

        it "disables auto attach":
            var config = DebugBootConfig__new(QemuArch.ARM64, "test.elf")
            config.disable_auto_attach()
            expect(config.auto_attach_on_crash).to_equal(false)

        it "preserves base config architecture":
            val config = DebugBootConfig__new(QemuArch.RiscV32, "my_kernel.elf")
            expect(config.base_config.arch).to_equal(QemuArch.RiscV32)
            expect(config.base_config.kernel_path).to_equal("my_kernel.elf")

    # ========================================================================
    # Crash Analysis
    # ========================================================================

    describe "analyze_crash":
        it "returns unavailable message when no debug info":
            val info = DebugInfo__unavailable()
            val analysis = analyze_crash(info)
            expect(analysis).to_contain("Cannot analyze")

        it "detects null pointer dereference":
            var regs: Dict<text, u64> = {}
            val trace: [StackFrame] = []
            val info = DebugInfo__from_gdb(regs, trace, 0x0004, "Crash")
            val analysis = analyze_crash(info)
            expect(analysis).to_contain("null pointer")

        it "detects unaligned access":
            var regs: Dict<text, u64> = {}
            val trace: [StackFrame] = []
            val info = DebugInfo__from_gdb(regs, trace, 0x80000001, "Crash")
            val analysis = analyze_crash(info)
            expect(analysis).to_contain("unaligned")

        it "returns no suggestions for normal address":
            var regs: Dict<text, u64> = {}
            val trace: [StackFrame] = []
            val info = DebugInfo__from_gdb(regs, trace, 0x80000000, "Stopped")
            val analysis = analyze_crash(info)
            expect(analysis).to_contain("No specific suggestions")
