# BackendPort System Spec - End-to-End Backend Selection
#
# System-level tests for Feature 1: BackendPort Typed Composition Root.
# These tests verify realistic end-to-end scenarios where BackendPort
# replaces string-keyed DI for selecting compiler backends.
#
# The key shift: old code did `di.resolve("Backend") -> Any` (untyped).
# New code accesses `services.backend` (typed BackendPort on CompilerServices).
#
# Design: doc/research/di_composition_root_design.md Option A
# Source: src/compiler/backend_port.spl

use compiler.compiler_services.{
    create_default_services
}

# ============================================================================
# System: end-to-end backend selection
# ============================================================================

describe "BackendPort System: end-to-end backend selection":

    context "interpreter backend services":
        it "interpreter backend services work":
            val services = create_default_services()
            val backend = services.backend
            val f_jit = backend.supports_jit_fn
            val f_triple = backend.target_triple_fn
            val jit = f_jit()
            val triple = f_triple()
            expect(backend.name).to_equal("noop-backend")
            expect(jit).to_equal(false)
            expect(triple).to_equal("noop")

        it "backend port is immediately accessible from services":
            val services = create_default_services()
            val name = services.backend.name
            expect(name).to_equal("noop-backend")

        it "backend port fn-fields are independently invocable":
            val services = create_default_services()
            val backend = services.backend
            val jit_fn = backend.supports_jit_fn
            val triple_fn = backend.target_triple_fn
            val jit_result = jit_fn()
            val triple_result = triple_fn()
            expect(jit_result).to_equal(false)
            expect(triple_result).to_equal("noop")

    context "typed access vs string-keyed DI":
        it "backend port replaces string-keyed di lookup":
            # Old pattern (di.resolve("Backend") -> Any, no type safety):
            #   val backend_any = di.resolve("Backend")  # returns Any
            #   # Caller must know the shape; no compiler check
            #
            # New pattern (typed BackendPort on CompilerServices):
            val services = create_default_services()
            val backend = services.backend          # typed field access
            val name = backend.name                 # statically known field
            expect(name).to_equal("noop-backend")

        it "named field access catches wrong field at load time":
            # With string-keyed DI, a typo like "Backned" silently returns nil.
            # With typed BackendPort, the field is a named struct field.
            val services = create_default_services()
            val backend = services.backend
            expect(backend.name).to_equal("noop-backend")

        it "supports_jit reflects backend capability without string lookup":
            # Old: (di.resolve("Backend") as BackendImpl).supports_jit()
            # New:
            val services = create_default_services()
            val backend = services.backend
            val f = backend.supports_jit_fn
            val supported = f()
            expect(supported).to_equal(false)

        it "target_triple reflects backend target without string lookup":
            # Old: (di.resolve("Backend") as BackendImpl).target_triple()
            # New:
            val services = create_default_services()
            val backend = services.backend
            val f = backend.target_triple_fn
            val triple = f()
            expect(triple).to_equal("noop")

# ============================================================================
# System: noop pipeline completes
# ============================================================================

describe "BackendPort System: Phase - noop pipeline completes":

    context "noop backend processes input without error":
        it "noop backend run_fn accepts module input":
            val services = create_default_services()
            val backend = services.backend
            val f = backend.run_fn
            val result = f(nil)
            expect(true).to_equal(true)

        it "noop backend pipeline executes all fn-fields":
            val services = create_default_services()
            val backend = services.backend
            val jit_fn = backend.supports_jit_fn
            val triple_fn = backend.target_triple_fn
            val run_fn = backend.run_fn
            val jit = jit_fn()
            val triple = triple_fn()
            val run = run_fn(nil)
            expect(jit).to_equal(false)
            expect(triple).to_equal("noop")
            expect(true).to_equal(true)

        it "noop pipeline is repeatable across service instances":
            val s1 = create_default_services()
            val s2 = create_default_services()
            val f1 = s1.backend.target_triple_fn
            val f2 = s2.backend.target_triple_fn
            val t1 = f1()
            val t2 = f2()
            expect(t1).to_equal(t2)

    context "backend works alongside other pipeline ports":
        it "backend port and lexer port are both accessible":
            val services = create_default_services()
            val lexer_name = services.lexer.name
            val backend_name = services.backend.name
            expect(lexer_name).to_equal("noop-lexer")
            expect(backend_name).to_equal("noop-backend")

        it "backend port and module_loader port are both accessible":
            val services = create_default_services()
            val loader_name = services.module_loader.name
            val backend_name = services.backend.name
            expect(loader_name).to_equal("noop-module-loader")
            expect(backend_name).to_equal("noop-backend")

        it "all pipeline stages have distinct names":
            val services = create_default_services()
            val lexer_name = services.lexer.name
            val parser_name = services.parser.name
            val backend_name = services.backend.name
            expect(lexer_name).to_equal("noop-lexer")
            expect(parser_name).to_equal("noop-parser")
            expect(backend_name).to_equal("noop-backend")

    context "backend name identifies the implementation":
        it "noop backend is identifiable by name prefix":
            val services = create_default_services()
            val backend = services.backend
            expect(backend.name).to_start_with("noop")

        it "noop backend target triple is noop sentinel":
            val services = create_default_services()
            val f = services.backend.target_triple_fn
            val triple = f()
            expect(triple).to_equal("noop")

        it "noop backend does not claim jit support":
            val services = create_default_services()
            val f = services.backend.supports_jit_fn
            val jit = f()
            expect(jit).to_equal(false)
