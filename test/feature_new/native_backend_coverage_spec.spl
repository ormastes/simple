# @deployment_coverage
# Native Backend Coverage Verification
#
# Verifies that native backend source files are exercised when system tests run.
# The test runner executes this spec in 2 phases:
#   Phase 1 (load): registers this file as a coverage monitor
#   Phase 2 (verify): runs the it-blocks below with collected coverage data

use std.coverage.{check_coverage, CoverageResult}

describe "Native Backend Coverage":
    it "check_coverage API returns valid result for native compile line coverage":
        val result = check_coverage("line", "src/app/compile/native.spl", minimum: 0.0)
        expect(result.coverage_type).to_equal("line")
        print "  native.spl line coverage: {result.actual}%  files_matched={result.files_matched}"

    it "check_coverage API returns valid result for native compile branch coverage":
        val result = check_coverage("branch", "src/app/compile/native.spl", minimum: 0.0)
        expect(result.coverage_type).to_equal("branch")
        print "  native.spl branch coverage: {result.actual}%  files_matched={result.files_matched}"

    it "check_coverage API returns valid result for llvm direct line coverage":
        val result = check_coverage("line", "src/app/compile/llvm_direct.spl", minimum: 0.0)
        expect(result.coverage_type).to_equal("line")
        print "  llvm_direct.spl line coverage: {result.actual}%  files_matched={result.files_matched}"

    it "check_coverage API returns valid result for wildcard compile pattern":
        val result = check_coverage("line", "src/app/compile/**", minimum: 0.0)
        expect(result.coverage_type).to_equal("line")
        print "  src/app/compile/** line coverage: {result.actual}%  files_matched={result.files_matched}"

    it "coverage_type and pattern are preserved on result":
        val result = check_coverage("function", "src/app/compile/native.spl", minimum: 0.0)
        expect(result.coverage_type).to_equal("function")
        expect(result.pattern).to_equal("src/app/compile/native.spl")
