# Module Loader E2E System Tests
#
# Verifies that the interpreter module loader correctly resolves and
# executes use imports via subprocess invocation.
#
# Pattern from test/unit/compiler/native_compile_spec.spl

use std.text.{NL}

extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn file_write(path: text, content: text) -> bool:
    rt_file_write_text(path, content)

# Write source to file. Uses heredoc to avoid Simple's own interpolation
# consuming {varname} patterns in the source code being written.
fn write_source(path: text, content: text) -> bool:
    val cmd = "cat > " + path + " << 'SIMPLE_WRITE_EOF'" + NL + content + NL + "SIMPLE_WRITE_EOF"
    val (out, err, code) = rt_process_run("/bin/sh", ["-c", cmd])
    code == 0

# Build a print statement with interpolation: print "{varname}"
# Uses concatenation to avoid Simple's own interpolation.
fn interp_print(varname: text) -> text:
    "print \"" + "{" + varname + "}" + "\""

fn file_exists(path: text) -> bool:
    rt_file_exists(path)

fn file_delete(path: text) -> bool:
    rt_file_delete(path)

fn process_run(cmd: text, args: [text]) -> (text, text, i64):
    rt_process_run(cmd, args)

struct ShellResult:
    stdout: text
    stderr: text
    exit_code: i64

fn shell(command: text) -> ShellResult:
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", command])
    ShellResult(stdout: stdout, stderr: stderr, exit_code: code)

describe "Module Loader E2E - Basic Import":
    it "loads a module via use and calls its function":
        val mod_path = "/tmp/sml_e2e_hello_mod.spl"
        val main_path = "/tmp/sml_e2e_hello_main.spl"

        val mod_src = "fn say_hello():" + NL + "    print \"hello from module\""
        write_source(mod_path, mod_src)

        val main_src = "use sml_e2e_hello_mod." + "{" + "say_hello" + "}" + NL + NL + "say_hello()"
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("hello from module")

        file_delete(mod_path)
        file_delete(main_path)

    it "imports a function that returns a numeric value":
        val mod_path = "/tmp/sml_e2e_val_mod.spl"
        val main_path = "/tmp/sml_e2e_val_main.spl"

        val mod_src = "fn get_answer() -> i64:" + NL + "    42"
        write_source(mod_path, mod_src)

        val main_src = "use sml_e2e_val_mod." + "{" + "get_answer" + "}" + NL + NL + "val result = get_answer()" + NL + interp_print("result")
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("42")

        file_delete(mod_path)
        file_delete(main_path)

    it "imports multiple functions from the same module":
        val mod_path = "/tmp/sml_e2e_multi_mod.spl"
        val main_path = "/tmp/sml_e2e_multi_main.spl"

        val mod_src = "fn add(a: i64, b: i64) -> i64:" + NL + "    a + b" + NL + NL + "fn mul(a: i64, b: i64) -> i64:" + NL + "    a * b"
        write_source(mod_path, mod_src)

        val main_src = "use sml_e2e_multi_mod." + "{" + "add, mul" + "}" + NL + NL + "val s = add(3, 4)" + NL + "val p = mul(3, 4)" + NL + interp_print("s") + NL + interp_print("p")
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout).to_contain("7")
        expect(stdout).to_contain("12")

        file_delete(mod_path)
        file_delete(main_path)

    it "module function takes and returns text":
        val mod_path = "/tmp/sml_e2e_text_mod.spl"
        val main_path = "/tmp/sml_e2e_text_main.spl"

        val mod_src = "fn greet(name: text) -> text:" + NL + "    \"Hello, \" + name + \"!\""
        write_source(mod_path, mod_src)

        val main_src = "use sml_e2e_text_mod." + "{" + "greet" + "}" + NL + NL + "print greet(\"World\")"
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("Hello, World!")

        file_delete(mod_path)
        file_delete(main_path)

describe "Module Loader E2E - Transitive Dependencies":
    it "loads transitive dependencies A uses B uses C":
        val base_path = "/tmp/sml_e2e_base.spl"
        val mid_path = "/tmp/sml_e2e_mid.spl"
        val main_path = "/tmp/sml_e2e_trans_main.spl"

        val base_src = "fn double(x: i64) -> i64:" + NL + "    x * 2"
        write_source(base_path, base_src)

        val mid_src = "use sml_e2e_base." + "{" + "double" + "}" + NL + NL + "fn quad(x: i64) -> i64:" + NL + "    double(double(x))"
        write_source(mid_path, mid_src)

        val main_src = "use sml_e2e_mid." + "{" + "quad" + "}" + NL + NL + "val result = quad(5)" + NL + interp_print("result")
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("20")

        file_delete(base_path)
        file_delete(mid_path)
        file_delete(main_path)

    it "double import of same module works (caching)":
        val mod_path = "/tmp/sml_e2e_cached_mod.spl"
        val helper_path = "/tmp/sml_e2e_cached_helper.spl"
        val main_path = "/tmp/sml_e2e_cached_main.spl"

        val mod_src = "fn value() -> i64:" + NL + "    100"
        write_source(mod_path, mod_src)

        val helper_src = "use sml_e2e_cached_mod." + "{" + "value" + "}" + NL + NL + "fn doubled() -> i64:" + NL + "    value() * 2"
        write_source(helper_path, helper_src)

        val main_src = "use sml_e2e_cached_mod." + "{" + "value" + "}" + NL + "use sml_e2e_cached_helper." + "{" + "doubled" + "}" + NL + NL + "val a = value()" + NL + "val b = doubled()" + NL + interp_print("a") + NL + interp_print("b")
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout).to_contain("100")
        expect(stdout).to_contain("200")

        file_delete(mod_path)
        file_delete(helper_path)
        file_delete(main_path)

describe "Module Loader E2E - Arithmetic Modules":
    it "module with factorial computes correctly":
        val mod_path = "/tmp/sml_e2e_fact_mod.spl"
        val main_path = "/tmp/sml_e2e_fact_main.spl"

        val mod_src = "fn factorial(n: i64) -> i64:" + NL + "    if n <= 1:" + NL + "        return 1" + NL + "    return n * factorial(n - 1)"
        write_source(mod_path, mod_src)

        val main_src = "use sml_e2e_fact_mod." + "{" + "factorial" + "}" + NL + NL + "val result = factorial(5)" + NL + interp_print("result")
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("120")

        file_delete(mod_path)
        file_delete(main_path)
