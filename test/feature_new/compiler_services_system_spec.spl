# CompilerServices System Test
#
# System-level tests for Feature 2: Pipeline Stage Ports (CompilerServices).
# Demonstrates CompilerServices in a realistic compilation scenario:
# creating services, running through all pipeline stages, and verifying
# outputs at each stage boundary.
#
# Feature: Pipeline Stage Ports (Feature 2)
# Design: doc/report/compiler_mdsoc_impl_plan.md Phase 2
# Source: src/compiler/compiler_services.spl

use compiler.compiler_services.{
    create_default_services,
    LexerPort,
    ParserPort,
    DesugarPort,
    TypeCheckPort,
    HirLowerPort,
    MirLowerPort,
    LoggerPort,
    ModuleLoaderPort,
    CompilerServices
}

# ============================================================================
# System Test 1: Service container construction
# ============================================================================

describe "CompilerServices System: Service container construction":

    it "create_default_services produces a fully wired container":
        val svc = create_default_services()
        expect(svc.lexer.name).to_equal("noop-lexer")
        expect(svc.parser.name).to_equal("noop-parser")
        expect(svc.desugarer.name).to_equal("noop-desugarer")
        expect(svc.type_checker.name).to_equal("noop-type-checker")
        expect(svc.hir_lowerer.name).to_equal("noop-hir-lowerer")
        expect(svc.mir_lowerer.name).to_equal("noop-mir-lowerer")
        expect(svc.backend.name).to_equal("noop-backend")
        expect(svc.logger.name).to_equal("noop-logger")
        expect(svc.module_loader.name).to_equal("noop-module-loader")

    it "service container can be created and immediately queried":
        val svc = create_default_services()
        val lexer_name = svc.lexer.name
        expect(lexer_name).to_start_with("noop")

    it "all port names follow the noop- naming convention":
        val svc = create_default_services()
        expect(svc.lexer.name).to_start_with("noop")
        expect(svc.parser.name).to_start_with("noop")
        expect(svc.desugarer.name).to_start_with("noop")
        expect(svc.type_checker.name).to_start_with("noop")
        expect(svc.hir_lowerer.name).to_start_with("noop")
        expect(svc.mir_lowerer.name).to_start_with("noop")
        expect(svc.backend.name).to_start_with("noop")
        expect(svc.logger.name).to_start_with("noop")
        expect(svc.module_loader.name).to_start_with("noop")

# ============================================================================
# System Test 2: Real compilation scenario - lexer and parser stages
# ============================================================================

describe "CompilerServices System: Lexer and parser stages":

    it "lexer tokenizes a simple function declaration":
        val svc = create_default_services()
        val source = "fn add(a: i64, b: i64) -> i64: a + b"
        val tokenize = svc.lexer.tokenize_fn
        val tokens = tokenize(source)
        # noop returns empty - verifies stage boundary contract
        expect(tokens.len()).to_equal(0)

    it "parser receives token stream from lexer and returns no errors":
        val svc = create_default_services()
        val source = "fn add(a: i64, b: i64) -> i64: a + b"
        val tokenize = svc.lexer.tokenize_fn
        val tokens = tokenize(source)
        val parse = svc.parser.parse_fn
        val errors = parse(tokens, source)
        expect(errors.len()).to_equal(0)

    it "lexer handles multiline source without error":
        val svc = create_default_services()
        val source = "fn foo():\n    val x = 1\n    x + 1"
        val tokenize = svc.lexer.tokenize_fn
        val tokens = tokenize(source)
        expect(tokens.len()).to_equal(0)

    it "parser returns empty error list for noop implementation":
        val svc = create_default_services()
        val parse = svc.parser.parse_fn
        val tokens = ["fn", "main", "(", ")", ":"]
        val errors = parse(tokens, "fn main():")
        expect(errors.len()).to_equal(0)

# ============================================================================
# System Test 3: Real compilation scenario - desugaring and type checking
# ============================================================================

describe "CompilerServices System: Desugaring and type checking stages":

    it "desugarer receives source and returns transformed output":
        val svc = create_default_services()
        val source = "fn main(): print 1"
        val desugar = svc.desugarer.desugar_fn
        val transformed = desugar(source)
        # noop returns source unchanged
        expect(transformed).to_equal(source)

    it "desugarer preserves source structure for noop":
        val svc = create_default_services()
        val source = "class Point:\n    x: i64\n    y: i64"
        val desugar = svc.desugarer.desugar_fn
        val result = desugar(source)
        expect(result).to_equal(source)

    it "type checker validates module by name":
        val svc = create_default_services()
        val check = svc.type_checker.check_fn
        val errors = check("my_module")
        expect(errors.len()).to_equal(0)

    it "type checker returns empty error list for unknown module in noop":
        val svc = create_default_services()
        val check = svc.type_checker.check_fn
        val errors = check("nonexistent_module")
        expect(errors.len()).to_equal(0)

# ============================================================================
# System Test 4: Real compilation scenario - HIR and MIR lowering
# ============================================================================

describe "CompilerServices System: HIR and MIR lowering stages":

    it "HIR lowerer lowers a module by name":
        val svc = create_default_services()
        val lower = svc.hir_lowerer.lower_fn
        val errors = lower("main")
        expect(errors.len()).to_equal(0)

    it "MIR lowerer lowers a module by name":
        val svc = create_default_services()
        val lower = svc.mir_lowerer.lower_fn
        val errors = lower("main")
        expect(errors.len()).to_equal(0)

    it "HIR and MIR lowering stages both succeed for same module":
        val svc = create_default_services()
        val hir_lower = svc.hir_lowerer.lower_fn
        val mir_lower = svc.mir_lowerer.lower_fn
        val hir_errors = hir_lower("main")
        val mir_errors = mir_lower("main")
        expect(hir_errors.len()).to_equal(0)
        expect(mir_errors.len()).to_equal(0)

    it "HIR lowerer handles multiple module names":
        val svc = create_default_services()
        val lower = svc.hir_lowerer.lower_fn
        val e1 = lower("module_a")
        val e2 = lower("module_b")
        expect(e1.len()).to_equal(0)
        expect(e2.len()).to_equal(0)

# ============================================================================
# System Test 5: Real compilation scenario - backend execution
# ============================================================================

describe "CompilerServices System: Backend stage":

    it "backend reports its capabilities via supports_jit_fn":
        val svc = create_default_services()
        val jit_fn = svc.backend.supports_jit_fn
        val supports = jit_fn()
        expect(supports).to_equal(false)

    it "backend reports its target architecture via target_triple_fn":
        val svc = create_default_services()
        val triple_fn = svc.backend.target_triple_fn
        val triple = triple_fn()
        expect(triple).to_equal("noop")

    it "backend triple is consistent across multiple calls":
        val svc = create_default_services()
        val triple_fn = svc.backend.target_triple_fn
        val t1 = triple_fn()
        val t2 = triple_fn()
        expect(t1).to_equal(t2)

    it "backend JIT support is consistent across multiple calls":
        val svc = create_default_services()
        val jit_fn = svc.backend.supports_jit_fn
        val j1 = jit_fn()
        val j2 = jit_fn()
        expect(j1).to_equal(j2)

# ============================================================================
# System Test 6: Logger integration during compilation
# ============================================================================

describe "CompilerServices System: Logger integration":

    it "logger can emit debug messages during compilation":
        val svc = create_default_services()
        val debug = svc.logger.debug_fn
        debug("starting compilation of main.spl")
        expect(svc.logger.name).to_equal("noop-logger")

    it "logger can emit info messages at each pipeline stage":
        val svc = create_default_services()
        val info = svc.logger.info_fn
        info("lexer stage complete")
        info("parser stage complete")
        info("desugarer stage complete")
        info("type checker stage complete")
        expect(svc.logger.name).to_equal("noop-logger")

    it "logger can emit warning messages during compilation":
        val svc = create_default_services()
        val warn = svc.logger.warn_fn
        warn("unused variable 'x' in module main")
        expect(svc.logger.name).to_equal("noop-logger")

    it "logger can emit error messages on compilation failure":
        val svc = create_default_services()
        val error = svc.logger.error_fn
        error("type mismatch: expected i64, found text")
        expect(svc.logger.name).to_equal("noop-logger")

    it "all 4 logger levels are callable in sequence":
        val svc = create_default_services()
        val debug_fn = svc.logger.debug_fn
        val info_fn = svc.logger.info_fn
        val warn_fn = svc.logger.warn_fn
        val error_fn = svc.logger.error_fn
        debug_fn("debug")
        info_fn("info")
        warn_fn("warn")
        error_fn("error")
        expect(svc.logger.name).to_equal("noop-logger")

# ============================================================================
# System Test 7: Module loader integration
# ============================================================================

describe "CompilerServices System: Module loader integration":

    it "module loader resolves import paths":
        val svc = create_default_services()
        val resolve = svc.module_loader.resolve_fn
        val path = resolve("/src/main.spl", "std.math")
        expect(path).to_equal("std.math")

    it "module loader loads resolved module content":
        val svc = create_default_services()
        val resolve = svc.module_loader.resolve_fn
        val load = svc.module_loader.load_fn
        val resolved = resolve("/src/main.spl", "std.array")
        val content = load(resolved)
        # noop returns empty string
        expect(content).to_equal("")

    it "module loader returns import name unchanged for noop resolver":
        val svc = create_default_services()
        val resolve = svc.module_loader.resolve_fn
        val r1 = resolve("/a/b/c.spl", "compiler.driver")
        val r2 = resolve("/x/y/z.spl", "compiler.driver")
        expect(r1).to_equal("compiler.driver")
        expect(r2).to_equal("compiler.driver")

    it "module loader returns empty content for any path in noop":
        val svc = create_default_services()
        val load = svc.module_loader.load_fn
        val c1 = load("src/compiler/driver.spl")
        val c2 = load("src/std/math.spl")
        expect(c1).to_equal("")
        expect(c2).to_equal("")

# ============================================================================
# System Test 8: Full end-to-end compilation pipeline
# ============================================================================

describe "CompilerServices System: Full end-to-end pipeline":

    it "simulates a complete compilation run through all 9 stages":
        val svc = create_default_services()
        val src = "fn greet(msg: text): print msg"
        val module_name = "greet"

        # Stage 1: Lex
        val lex = svc.lexer.tokenize_fn
        val tokens = lex(src)
        expect(tokens.len()).to_equal(0)

        # Stage 2: Parse
        val parse = svc.parser.parse_fn
        val parse_errs = parse(tokens, src)
        expect(parse_errs.len()).to_equal(0)

        # Stage 3: Desugar
        val desugar = svc.desugarer.desugar_fn
        val desugared = desugar(src)
        expect(desugared).to_equal(src)

        # Stage 4: Type check
        val check = svc.type_checker.check_fn
        val type_errs = check(module_name)
        expect(type_errs.len()).to_equal(0)

        # Stage 5: HIR lower
        val hir_lower = svc.hir_lowerer.lower_fn
        val hir_errs = hir_lower(module_name)
        expect(hir_errs.len()).to_equal(0)

        # Stage 6: MIR lower
        val mir_lower = svc.mir_lowerer.lower_fn
        val mir_errs = mir_lower(module_name)
        expect(mir_errs.len()).to_equal(0)

        # Stage 7: Backend capabilities check
        val jit_fn = svc.backend.supports_jit_fn
        val jit_ok = jit_fn()
        expect(jit_ok).to_equal(false)

        # Stage 8: Backend target
        val triple_fn = svc.backend.target_triple_fn
        val triple = triple_fn()
        expect(triple).to_equal("noop")

        # Stage 9: Log completion
        val log = svc.logger.info_fn
        log("compilation complete")
        expect(svc.logger.name).to_equal("noop-logger")

    it "pipeline can be run for multiple modules":
        val svc = create_default_services()

        val lex = svc.lexer.tokenize_fn
        val parse = svc.parser.parse_fn
        val desugar = svc.desugarer.desugar_fn
        val check = svc.type_checker.check_fn
        val hir_lower = svc.hir_lowerer.lower_fn
        val mir_lower = svc.mir_lowerer.lower_fn

        val src_a = "fn foo(): 1"
        val tokens_a = lex(src_a)
        val parse_errs_a = parse(tokens_a, src_a)
        val desugared_a = desugar(src_a)
        val type_errs_a = check("module_a")
        val hir_errs_a = hir_lower("module_a")
        val mir_errs_a = mir_lower("module_a")

        val src_b = "fn bar(): 2"
        val tokens_b = lex(src_b)
        val parse_errs_b = parse(tokens_b, src_b)
        val desugared_b = desugar(src_b)
        val type_errs_b = check("module_b")
        val hir_errs_b = hir_lower("module_b")
        val mir_errs_b = mir_lower("module_b")

        expect(parse_errs_a.len()).to_equal(0)
        expect(parse_errs_b.len()).to_equal(0)
        expect(desugared_a).to_equal(src_a)
        expect(desugared_b).to_equal(src_b)
        expect(type_errs_a.len()).to_equal(0)
        expect(type_errs_b.len()).to_equal(0)
        expect(hir_errs_a.len()).to_equal(0)
        expect(hir_errs_b.len()).to_equal(0)
        expect(mir_errs_a.len()).to_equal(0)
        expect(mir_errs_b.len()).to_equal(0)

    it "module loader participates in full pipeline as module source provider":
        val svc = create_default_services()
        val resolve = svc.module_loader.resolve_fn
        val load = svc.module_loader.load_fn

        # Resolve module path
        val resolved = resolve("/project/src/main.spl", "std.string")
        expect(resolved).to_equal("std.string")

        # Load module content
        val content = load(resolved)
        expect(content).to_equal("")

        # Continue pipeline with loaded content
        val lex = svc.lexer.tokenize_fn
        val tokens = lex(content)
        expect(tokens.len()).to_equal(0)

        val parse = svc.parser.parse_fn
        val errors = parse(tokens, content)
        expect(errors.len()).to_equal(0)
