# E1027: Unconstrained Type Parameter

Feature: E1027 - Unconstrained Type Parameter
  As a Simple compiler
  I want to detect type parameters that are not constrained
  So that generic types are properly constrained

  Background:
    Given I have the Simple compiler

  Scenario: Type parameter not used in signature
    When I compile:
      '''
      fn unused<T>() -> i32:  # Error: T is unconstrained
        42
      '''
    Then I should see error E1027 at line 1
    And the error message should be "type parameter `{name}` is not constrained"
    And the label should indicate "unconstrained type parameter"
    And the help should suggest "add trait bounds or use the type parameter in function signature"

  Scenario: Type parameter only in function body
    When I compile:
      '''
      fn test<T>() -> i32:
        val x: T = default()  # Error: T not in signature
        0
      '''
    Then I should see error E1027

  Scenario: Valid constrained type parameter in signature
    When I compile:
      '''
      fn identity<T>(x: T) -> T:  # OK: T in signature
        x
      '''
    Then compilation should succeed

  Scenario: Valid type parameter with trait bound
    When I compile:
      '''
      fn process<T: Display>(value: T):  # OK: constrained by trait
        print(value.show())
      '''
    Then compilation should succeed

  Scenario: Multiple type parameters, one unconstrained
    When I compile:
      '''
      fn partial<T, U>(x: T) -> T:  # Error: U unconstrained
        x
      '''
    Then I should see error E1027

  Scenario: Korean language error
    Given I set compiler language to "ko"
    When I compile:
      '''
      fn test<T>() -> i32:
        42
      '''
    Then I should see error E1027
    And the error message should contain "제약되지 않은 타입 매개변수"
