# FFI Generator - End-to-End Build Test
#
# Generates a real Rust FFI wrapper crate and compiles it with cargo.
# This validates the full pipeline: parse → codegen → cargo build.
#
# Run: simple test/ffi_gen/e2e_build_test.spl
# Requires: cargo installed and in PATH

use app.ffi_gen.parser (parse_lib_externs)
use app.ffi_gen.rust_codegen (generate)
use app.ffi_gen.cargo_gen (generate)

extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_dir_create(path: text, recursive: bool) -> bool
extern fn rt_dir_remove(path: text, recursive: bool) -> bool
extern fn rt_env_cwd() -> text
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn main() -> i64:
    val cwd = rt_env_cwd()
    val test_dir = "{cwd}/build/rust/ffi_gen_test"

    # Clean previous test run
    if rt_file_exists(test_dir):
        rt_dir_remove(test_dir, true)

    # Create output dirs
    rt_dir_create(test_dir, true)
    rt_dir_create("{test_dir}/src", true)

    # Parse a real @Lib annotation
    val source = "@Lib(lang: \"rust\", name: \"regex\", version: \"1.10\")\nextern class Regex:\n    static fn new(pattern: text) -> Regex\n    fn is_match(input: text) -> bool\n"

    val specs = parse_lib_externs(source, "test.spl")
    assert specs.len() == 1, "Should parse 1 spec"

    # Generate Rust code
    val rust_code = rust_codegen.generate(specs)
    val cargo_toml = cargo_gen.generate(specs, "2021")

    # Write files
    assert rt_file_write_text("{test_dir}/Cargo.toml", cargo_toml), "Should write Cargo.toml"
    assert rt_file_write_text("{test_dir}/src/lib.rs", rust_code), "Should write lib.rs"

    print "Generated crate at {test_dir}"
    print ""
    print "=== Cargo.toml ==="
    print cargo_toml
    print ""
    print "=== src/lib.rs ==="
    print rust_code

    # Build with cargo
    print ""
    print "Building with cargo..."
    val result = rt_process_run("cargo", ["build", "--release", "--manifest-path", "{test_dir}/Cargo.toml"])
    val stdout = result.0
    val stderr = result.1
    val exit_code = result.2

    if stdout != "":
        print stdout
    if stderr != "":
        print stderr

    if exit_code != 0:
        print "FAIL: cargo build failed with exit code {exit_code}"
        return 1

    # Verify .so was produced
    val so_path = "{test_dir}/target/release/libsimple_ffi_wrapper.so"
    val dylib_path = "{test_dir}/target/release/libsimple_ffi_wrapper.dylib"
    if rt_file_exists(so_path) or rt_file_exists(dylib_path):
        print ""
        print "PASS: End-to-end build succeeded - shared library produced"
    else:
        print ""
        print "FAIL: Build succeeded but shared library not found"
        return 1

    # Clean up test artifacts (keep build/rust/ for caching)
    rt_dir_remove(test_dir, true)

    0
