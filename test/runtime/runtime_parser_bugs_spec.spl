# @skip - Uses unsupported keyword: with
"""
# Runtime Parser Bugs Reproduction Specification

**Feature IDs:** #BUG-RT-001 through #BUG-RT-009
**Category:** Runtime
**Difficulty:** 2/5
**Status:** In Progress

## Overview

Reproduction tests for 9 runtime parser/interpreter bugs discovered
during Remote RISC-V 32 debug module implementation (2026-02-06).

These tests document known limitations of the bootstrap runtime parser
and verify that workarounds function correctly.

## Key Concepts

| Concept | Description |
|---------|-------------|
| Slice syntax | `s[start:end]` string/array slicing |
| Dict.get() | Dictionary key lookup method |
| Reserved words | Identifiers the parser treats as keywords |
| Function fields | Class fields with function types |

## Behavior

- Bug tests marked `skip` will fail on bootstrap runtime (expected)
- Workaround tests should always pass
- When a bug is fixed in the runtime, remove the `skip` tag

## Related Specifications

- [Runtime Parser Bugs Report](../../doc/report/runtime_parser_bugs_2026-02-06.md)
"""

use std.spec.*


# ============================================================================
# Helper Types (must be defined before describe blocks)
# ============================================================================

# Bug 2 helper: Registry using nil check pattern
class BugTestRegistry:
    data: Dict<text, text>

    static fn empty() -> BugTestRegistry:
        BugTestRegistry(data: {})

impl BugTestRegistry:
    me add(key: text, value: text):
        self.data[key] = value

    fn lookup(key: text) -> bool:
        val got = self.data.get(key)
        if got != nil:
            true
        else:
            false

# Bug 3 helper: Class with 'feat' field (not 'feature')
class BugTestHandler:
    feat: text
    rank: i32

    static fn of(feat: text, rank: i32) -> BugTestHandler:
        BugTestHandler(feat: feat, rank: rank)

fn bug_test_lookup_feat(feat: text) -> text:
    "found: {feat}"

# Bug 4 helper: Enum with 'cls' field (not 'class')
enum BugTestRecord:
    Info(cls: text, msg: text)
    Empty

# Bug 5 helper: Constants as static fn
class BugTestConstants:
    static fn NATIVE() -> i32:
        0
    static fn BRIDGE() -> i32:
        1
    static fn EMULATED() -> i32:
        4

# Bug 6 helper: Factory method for defaults
class BugTestTarget:
    names: [text]

    static fn create() -> BugTestTarget:
        BugTestTarget(names: ["zero", "ra", "sp"])

# Bug 7 helper: Class with dummy field
class BugTestEmptyClass:
    _unused: i32

impl BugTestEmptyClass:
    fn do_work() -> text:
        "works"

# Bug 8 + 9 helper: Class with fn field (unnamed params)
class BugTestFnHolder:
    callback: fn([text]) -> text

    static fn of(callback: fn([text]) -> text) -> BugTestFnHolder:
        BugTestFnHolder(callback: callback)

class BugTestResultHolder:
    handler: fn([text]) -> Result<text, text>

    static fn of(handler: fn([text]) -> Result<text, text>) -> BugTestResultHolder:
        BugTestResultHolder(handler: handler)


# ============================================================================
# Test Group 1: Bug 1 - Slice Syntax [:variable] Treated as Symbol
# ============================================================================

describe "BUG-RT-001: Slice syntax [:variable]":
    """
    ## Slice Syntax Bug

    `s[:variable]` is interpreted as `s` indexed by symbol `:variable`
    instead of slice-from-start syntax. Using `s[0:variable]` works.

    **Error:** `cannot index string with type 'symbol'`
    """

    context "workaround: explicit 0 start":
        it "slices string with s[0:end]":
            val s = "hello world"
            val end = 5
            val result = s[0:end]
            expect(result).to_equal("hello"))

        it "slices with expression s[0:s.len()-1]":
            val s = "hello"
            val slen = s.len()
            val result = s[0:slen - 1]
            expect(result).to_equal("hell"))

        it "trims trailing char with explicit 0":
            var s = "quoted\""
            val slen = s.len()
            s = s[0:slen - 1]
            expect(s).to_equal("quoted"))

    context "literal end works":
        it "slices with literal s[:3]":
            val s = "hello"
            val result = s[:3]
            expect(result).to_equal("hel"))

    context "omitted end works":
        it "slices with s[1:]":
            val s = "hello"
            val result = s[1:]
            expect(result).to_equal("ello"))


# ============================================================================
# Test Group 2: Bug 2 - Dict.get() Returns Raw Value Not Option
# ============================================================================

describe "BUG-RT-002: Dict.get() return type":
    """
    ## Dict.get() Return Type Bug

    `Dict.get(key)` returns the raw value (or nil for missing),
    NOT wrapped in `Some(value)` / `None`. Matching on `Some/None`
    silently fails.

    **Error:** Silent - match falls through to default arm.
    """

    context "workaround: nil check":
        it "finds existing key with nil check":
            var d: Dict<text, text> = {}
            d["key"] = "value"
            val got = d.get("key")
            if got != nil:
                expect(got).to_equal("value"))
            else:
                fail("should have found key")

        it "returns nil for missing key":
            var d: Dict<text, text> = {}
            d["key"] = "value"
            val got = d.get("missing")
            expect(got == nil).to_equal(true))

        it "works with null coalescing operator":
            var d: Dict<text, text> = {}
            d["key"] = "value"
            expect(d.get("key") ?? "default").to_equal("value"))
            expect(d.get("missing") ?? "default").to_equal("default"))

    context "workaround: Dict with array values":
        it "stores and retrieves arrays with nil check":
            var d: Dict<text, [text]> = {}
            d["items"] = ["a", "b", "c"]
            val got = d.get("items")
            if got != nil:
                expect(got.len()).to_equal(3))
                expect(got[0]).to_equal("a"))
            else:
                fail("should have found items")

    context "workaround: contains_key":
        it "checks key existence":
            var d: Dict<text, text> = {}
            d["key"] = "value"
            expect(d.contains_key("key")).to_equal(true))
            expect(d.contains_key("missing")).to_equal(false))

    context "workaround: in operator":
        it "checks membership":
            var d: Dict<text, text> = {}
            d["key"] = "value"
            if "key" in d:
                pass
            else:
                fail("'key' should be in d")

    context "workaround: mutable class method with nil check":
        it "registers and looks up handlers":
            var reg = BugTestRegistry.empty()
            reg.add("halt", "gdb_handler")
            expect(reg.lookup("halt")).to_equal(true))
            expect(reg.lookup("missing")).to_equal(false))


# ============================================================================
# Test Group 3: Bug 3 - 'feature' is Reserved Word
# ============================================================================

describe "BUG-RT-003: 'feature' reserved word":
    """
    ## Reserved Word Bug

    The identifier `feature` is treated as a keyword in parameter
    and field name contexts, causing parse errors.

    **Error:** `expected Comma, found Colon`
    """

    context "workaround: rename to feat":
        it "uses feat as field name":
            val h = BugTestHandler.of("halt", 0)
            expect(h.feat).to_equal("halt"))

        it "uses feat as parameter name":
            val result = bug_test_lookup_feat("halt")
            expect(result).to_equal("found: halt"))


# ============================================================================
# Test Group 4: Bug 4 - 'class' is Reserved Word
# ============================================================================

describe "BUG-RT-004: 'class' reserved word":
    """
    ## Reserved Word Bug

    The identifier `class` cannot be used as a variable name
    in match patterns or local variables.

    **Error:** `expected pattern, found Class`
    """

    context "workaround: rename to cls":
        it "uses cls in match pattern":
            val record = BugTestRecord.Info(cls: "done", msg: "ok")
            match record:
                BugTestRecord.Info(cls, msg):
                    expect(cls).to_equal("done"))
                    expect(msg).to_equal("ok"))
                _:
                    fail("wrong match")


# ============================================================================
# Test Group 5: Bug 5 - static val Not Supported
# ============================================================================

describe "BUG-RT-005: static val not supported":
    """
    ## Parser Limitation

    `static val` in class bodies fails with `expected Fn, found Val`.

    **Error:** `expected Fn, found Val`
    """

    context "workaround: static fn getter":
        it "uses static fn instead of static val":
            expect(BugTestConstants.NATIVE()).to_equal(0))
            expect(BugTestConstants.BRIDGE()).to_equal(1))
            expect(BugTestConstants.EMULATED()).to_equal(4))


# ============================================================================
# Test Group 6: Bug 6 - val Field Defaults Not Supported
# ============================================================================

describe "BUG-RT-006: val field defaults":
    """
    ## Parser Limitation

    `val field: Type = default` in class bodies fails.

    **Error:** `expected identifier, found Val`
    """

    context "workaround: factory method":
        it "uses static fn create with default values":
            val t = BugTestTarget.create()
            expect(t.names.len()).to_equal(3))
            expect(t.names[0]).to_equal("zero"))
            expect(t.names[1]).to_equal("ra"))
            expect(t.names[2]).to_equal("sp"))


# ============================================================================
# Test Group 7: Bug 7 - Empty Class Body
# ============================================================================

describe "BUG-RT-007: empty class body":
    """
    ## Parser Limitation

    Empty class body before `impl` block fails.

    **Error:** `expected Indent, found Impl`
    """

    context "workaround: dummy field":
        it "uses _unused field for empty class":
            val p = BugTestEmptyClass(_unused: 0)
            expect(p.do_work()).to_equal("works"))


# ============================================================================
# Test Group 8: Bug 8 - Named Params in Function Types
# ============================================================================

describe "BUG-RT-008: named params in fn types":
    """
    ## Parser Limitation

    `fn(args: [text])` with named parameter fails.

    **Error:** `expected Comma, found Colon`
    """

    context "workaround: unnamed params":
        it "uses fn([text]) without param names":
            val h = BugTestFnHolder.of(\items: "got {items.len()} items")
            val cb = h.callback
            val result = cb(["a", "b"])
            expect(result).to_equal("got 2 items"))


# ============================================================================
# Test Group 9: Bug 9 - Cannot Call Function Fields Directly
# ============================================================================

describe "BUG-RT-009: fn field direct call":
    """
    ## Interpreter Limitation

    Calling `obj.fn_field(args)` is interpreted as method call,
    not field-access + function-call.

    **Error:** `method 'fn_field' not found`
    """

    context "workaround: extract to local variable":
        it "extracts fn field then calls it":
            val h = BugTestFnHolder.of(\items: "processed {items.len()}")
            # Extract to local first
            val cb = h.callback
            val result = cb(["x", "y", "z"])
            expect(result).to_equal("processed 3"))

        it "works with Result-returning fn fields":
            val h = BugTestResultHolder.of(\items: Ok("ok: {items.len()}"))
            val handler = h.handler
            val result = handler(["a"])
            expect(result.ok.?).to_equal(true))
