# Helper types for runtime parser bug reproduction tests

# Bug 2 helper: Registry using nil check pattern
class BugTestRegistry:
    data: Dict<text, text>

    static fn empty() -> BugTestRegistry:
        BugTestRegistry(data: {})

impl BugTestRegistry:
    me add(key: text, value: text):
        self.data[key] = value

    fn lookup(key: text) -> bool:
        val got = self.data.get(key)
        if got != nil:
            true
        else:
            false

# Bug 3 helper: Class with 'feat' field (not 'feature')
class BugTestHandler:
    feat: text
    rank: i32

    static fn of(feat: text, rank: i32) -> BugTestHandler:
        BugTestHandler(feat: feat, rank: rank)

fn bug_test_lookup_feat(feat: text) -> text:
    "found: {feat}"

# Bug 4 helper: Enum with 'cls' field (not 'class')
enum BugTestRecord:
    Info(cls: text, msg: text)
    Empty

# Bug 5 helper: Constants as static fn
class BugTestConstants:
    static fn NATIVE() -> i32:
        0
    static fn BRIDGE() -> i32:
        1
    static fn EMULATED() -> i32:
        4

# Bug 6 helper: Factory method for defaults
class BugTestTarget:
    names: [text]

    static fn create() -> BugTestTarget:
        BugTestTarget(names: ["zero", "ra", "sp"])

# Bug 7 helper: Class with dummy field
class BugTestEmptyClass:
    _unused: i32

impl BugTestEmptyClass:
    fn do_work() -> text:
        "works"

# Bug 8 + 9 helper: Class with fn field (unnamed params)
class BugTestFnHolder:
    callback: fn([text]) -> text

    static fn of(callback: fn([text]) -> text) -> BugTestFnHolder:
        BugTestFnHolder(callback: callback)

class BugTestResultHolder:
    handler: fn([text]) -> Result<text, text>

    static fn of(handler: fn([text]) -> Result<text, text>) -> BugTestResultHolder:
        BugTestResultHolder(handler: handler)
