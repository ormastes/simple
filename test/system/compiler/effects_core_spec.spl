# SSpec: Effect Tracking Core (Lean-Aligned)
#
# Comprehensive tests mirroring Lean theorems from verification/
# Tests async safety and GC allocation tracking

import sspec
import std_lib.tooling.compiler.effects_core

Feature "AsyncEffect - is_async predicate":

    Scenario "Compute is async":
        Given "a Compute effect"
        val e = AsyncEffect.Compute
        When "checking if async"
        val result = e.is_async()
        Then "it should return true"
        sspec.expect(result).to_be_true()

    Scenario "Io is async":
        Given "an Io effect"
        val e = AsyncEffect.Io
        When "checking if async"
        val result = e.is_async()
        Then "it should return true"
        sspec.expect(result).to_be_true()

    Scenario "Wait is not async":
        Given "a Wait effect"
        val e = AsyncEffect.Wait
        When "checking if async"
        val result = e.is_async()
        Then "it should return false"
        sspec.expect(result).to_be_false()

Feature "AsyncEffect - pipeline_safe predicate":

    Scenario "Empty list is pipeline safe":
        Given "an empty effect list"
        val effects = []
        When "checking pipeline safety"
        val safe = pipeline_safe(effects)
        Then "it should be safe"
        sspec.expect(safe).to_be_true()

    Scenario "List with only Compute is safe":
        Given "a list with only Compute effects"
        val effects = [AsyncEffect.Compute, AsyncEffect.Compute]
        When "checking pipeline safety"
        val safe = pipeline_safe(effects)
        Then "it should be safe"
        sspec.expect(safe).to_be_true()

    Scenario "List with Compute and Io is safe":
        Given "a list with Compute and Io"
        val effects = [AsyncEffect.Compute, AsyncEffect.Io, AsyncEffect.Compute]
        When "checking pipeline safety"
        val safe = pipeline_safe(effects)
        Then "it should be safe"
        sspec.expect(safe).to_be_true()

    Scenario "List with Wait is not safe":
        Given "a list containing Wait"
        val effects = [AsyncEffect.Compute, AsyncEffect.Wait, AsyncEffect.Io]
        When "checking pipeline safety"
        val safe = pipeline_safe(effects)
        Then "it should not be safe"
        sspec.expect(safe).to_be_false()

    Scenario "Singleton Wait list is not safe":
        Given "a singleton list with Wait"
        val effects = [AsyncEffect.Wait]
        When "checking pipeline safety"
        val safe = pipeline_safe(effects)
        Then "it should not be safe"
        sspec.expect(safe).to_be_false()

Feature "AsyncEffect - append_safe theorem":

    Scenario "Append two safe lists":
        Given "two pipeline-safe lists"
        val a = [AsyncEffect.Compute, AsyncEffect.Io]
        val b = [AsyncEffect.Compute, AsyncEffect.Compute]
        When "appending with append_safe"
        val result = append_safe(a, b)
        Then "result should be pipeline safe"
        sspec.expect(pipeline_safe(result)).to_be_true()
        And "result should have length 4"
        sspec.expect(result.length()).to_equal(4)

    Scenario "Append preserves order":
        Given "two safe lists with distinct effects"
        val a = [AsyncEffect.Compute]
        val b = [AsyncEffect.Io]
        When "appending"
        val result = append_safe(a, b)
        Then "order should be preserved"
        sspec.expect(result[0] == AsyncEffect.Compute).to_be_true()
        sspec.expect(result[1] == AsyncEffect.Io).to_be_true()

    Scenario "Append empty lists":
        Given "two empty safe lists"
        val a = []
        val b = []
        When "appending"
        val result = append_safe(a, b)
        Then "result should be empty and safe"
        sspec.expect(result.length()).to_equal(0)
        sspec.expect(pipeline_safe(result)).to_be_true()

Feature "AsyncEffect - wait_detected theorem":

    Scenario "Wait detected in unsafe singleton":
        Given "a Wait effect"
        val e = AsyncEffect.Wait
        When "checking wait_detected"
        val result = wait_detected(e)
        Then "it should return true (vacuously)"
        sspec.expect(result).to_be_true()

    Scenario "No wait in safe Compute singleton":
        Given "a Compute effect"
        val e = AsyncEffect.Compute
        When "checking wait_detected"
        val result = wait_detected(e)
        Then "it should confirm no wait"
        sspec.expect(result).to_be_true()

    Scenario "No wait in safe Io singleton":
        Given "an Io effect"
        val e = AsyncEffect.Io
        When "checking wait_detected"
        val result = wait_detected(e)
        Then "it should confirm no wait"
        sspec.expect(result).to_be_true()

Feature "AsyncEffect - blocking detection":

    Scenario "No blocking in pure compute":
        Given "a list of Compute effects"
        val effects = [AsyncEffect.Compute, AsyncEffect.Compute]
        When "checking for blocking"
        val has_blocking = has_blocking_effects(effects)
        Then "it should return false"
        sspec.expect(has_blocking).to_be_false()

    Scenario "Blocking detected with Wait":
        Given "a list with Wait"
        val effects = [AsyncEffect.Compute, AsyncEffect.Wait]
        When "checking for blocking"
        val has_blocking = has_blocking_effects(effects)
        Then "it should return true"
        sspec.expect(has_blocking).to_be_true()

    Scenario "Count blocking effects":
        Given "a list with multiple Wait effects"
        val effects = [AsyncEffect.Wait, AsyncEffect.Compute, AsyncEffect.Wait, AsyncEffect.Io]
        When "counting blocking effects"
        val count = count_blocking(effects)
        Then "it should return 2"
        sspec.expect(count).to_equal(2)

    Scenario "Filter async effects":
        Given "a mixed list"
        val effects = [AsyncEffect.Wait, AsyncEffect.Compute, AsyncEffect.Wait, AsyncEffect.Io]
        When "filtering to async only"
        val filtered = filter_async(effects)
        Then "it should remove Wait effects"
        sspec.expect(filtered.length()).to_equal(2)
        sspec.expect(pipeline_safe(filtered)).to_be_true()

Feature "NogcInstr - predicate methods":

    Scenario "GcAlloc is GC allocation":
        Given "a GcAlloc instruction"
        val instr = NogcInstr.GcAlloc
        When "checking if GC alloc"
        val is_gc = instr.is_gc_alloc()
        Then "it should return true"
        sspec.expect(is_gc).to_be_true()

    Scenario "Const is not GC allocation":
        Given "a Const instruction"
        val instr = NogcInstr.Const(42)
        When "checking if GC alloc"
        val is_gc = instr.is_gc_alloc()
        Then "it should return false"
        sspec.expect(is_gc).to_be_false()

    Scenario "Add is nogc":
        Given "an Add instruction"
        val instr = NogcInstr.Add
        When "checking if nogc"
        val is_nogc = instr.is_nogc()
        Then "it should return true"
        sspec.expect(is_nogc).to_be_true()

Feature "NogcInstr - nogc predicate":

    Scenario "Empty list is nogc":
        Given "an empty instruction list"
        val instrs = []
        When "checking nogc"
        val result = nogc(instrs)
        Then "it should be nogc"
        sspec.expect(result).to_be_true()

    Scenario "List with only Const and Add is nogc":
        Given "a list without GC allocations"
        val instrs = [NogcInstr.Const(1), NogcInstr.Add, NogcInstr.Const(2)]
        When "checking nogc"
        val result = nogc(instrs)
        Then "it should be nogc"
        sspec.expect(result).to_be_true()

    Scenario "List with GcAlloc is not nogc":
        Given "a list containing GcAlloc"
        val instrs = [NogcInstr.Const(1), NogcInstr.GcAlloc, NogcInstr.Add]
        When "checking nogc"
        val result = nogc(instrs)
        Then "it should not be nogc"
        sspec.expect(result).to_be_false()

Feature "NogcInstr - nogc_append theorem":

    Scenario "Append two nogc lists":
        Given "two nogc instruction lists"
        val a = [NogcInstr.Const(1), NogcInstr.Add]
        val b = [NogcInstr.Const(2), NogcInstr.Add]
        When "appending with nogc_append"
        val result = nogc_append(a, b)
        Then "result should be nogc"
        sspec.expect(nogc(result)).to_be_true()
        And "result should have length 4"
        sspec.expect(result.length()).to_equal(4)

    Scenario "Append preserves instruction order":
        Given "two nogc lists"
        val a = [NogcInstr.Const(1)]
        val b = [NogcInstr.Add]
        When "appending"
        val result = nogc_append(a, b)
        Then "order should be preserved"
        match result[0]:
            NogcInstr.Const(n) -> sspec.expect(n).to_equal(1)
            _ -> sspec.fail("Expected Const(1)")
        sspec.expect(result[1] == NogcInstr.Add).to_be_true()

Feature "NogcInstr - nogc_singleton theorem":

    Scenario "Singleton Const is nogc":
        Given "a Const instruction"
        val instr = NogcInstr.Const(42)
        When "checking singleton nogc"
        val result = nogc_singleton(instr)
        Then "it should be nogc"
        sspec.expect(result).to_be_true()

    Scenario "Singleton Add is nogc":
        Given "an Add instruction"
        val instr = NogcInstr.Add
        When "checking singleton nogc"
        val result = nogc_singleton(instr)
        Then "it should be nogc"
        sspec.expect(result).to_be_true()

    Scenario "Singleton GcAlloc is not nogc":
        Given "a GcAlloc instruction"
        val instr = NogcInstr.GcAlloc
        When "checking singleton nogc"
        val result = nogc_singleton(instr)
        Then "it should not be nogc"
        sspec.expect(result).to_be_false()

Feature "NogcInstr - GC allocation tracking":

    Scenario "Count GC allocations":
        Given "a list with multiple GcAlloc"
        val instrs = [NogcInstr.GcAlloc, NogcInstr.Const(1), NogcInstr.GcAlloc, NogcInstr.Add]
        When "counting GC allocations"
        val count = count_gc_allocs(instrs)
        Then "it should return 2"
        sspec.expect(count).to_equal(2)

    Scenario "Filter nogc instructions":
        Given "a mixed instruction list"
        val instrs = [NogcInstr.GcAlloc, NogcInstr.Const(1), NogcInstr.GcAlloc, NogcInstr.Add]
        When "filtering to nogc only"
        val filtered = filter_nogc(instrs)
        Then "it should remove GcAlloc"
        sspec.expect(filtered.length()).to_equal(2)
        sspec.expect(nogc(filtered)).to_be_true()

Feature "Combined Effect Properties":

    Scenario "Create properties from async effects":
        Given "a pipeline-safe effect list"
        val effects = [AsyncEffect.Compute, AsyncEffect.Io]
        When "creating properties"
        val props = EffectProperties.from_async(effects)
        Then "it should be pipeline safe"
        sspec.expect(props.is_pipeline_safe).to_be_true()
        And "blocking count should be 0"
        sspec.expect(props.blocking_count).to_equal(0)

    Scenario "Create properties from async with blocking":
        Given "an effect list with Wait"
        val effects = [AsyncEffect.Wait, AsyncEffect.Compute]
        When "creating properties"
        val props = EffectProperties.from_async(effects)
        Then "it should not be pipeline safe"
        sspec.expect(props.is_pipeline_safe).to_be_false()
        And "blocking count should be 1"
        sspec.expect(props.blocking_count).to_equal(1)

    Scenario "Create properties from nogc instructions":
        Given "a nogc instruction list"
        val instrs = [NogcInstr.Const(1), NogcInstr.Add]
        When "creating properties"
        val props = EffectProperties.from_nogc(instrs)
        Then "it should be nogc"
        sspec.expect(props.is_nogc).to_be_true()
        And "GC alloc count should be 0"
        sspec.expect(props.gc_alloc_count).to_equal(0)

    Scenario "Create properties from instructions with GC":
        Given "an instruction list with GcAlloc"
        val instrs = [NogcInstr.GcAlloc, NogcInstr.Const(1)]
        When "creating properties"
        val props = EffectProperties.from_nogc(instrs)
        Then "it should not be nogc"
        sspec.expect(props.is_nogc).to_be_false()
        And "GC alloc count should be 1"
        sspec.expect(props.gc_alloc_count).to_equal(1)

    Scenario "Check optimizability":
        Given "properties that are safe and nogc"
        val props = EffectProperties(
            is_pipeline_safe: true,
            is_nogc: true,
            blocking_count: 0,
            gc_alloc_count: 0
        )
        When "checking optimizability"
        val opt = props.is_optimizable()
        Then "it should be optimizable"
        sspec.expect(opt).to_be_true()

    Scenario "Not optimizable with blocking":
        Given "properties with blocking"
        val props = EffectProperties(
            is_pipeline_safe: false,
            is_nogc: true,
            blocking_count: 1,
            gc_alloc_count: 0
        )
        When "checking optimizability"
        val opt = props.is_optimizable()
        Then "it should not be optimizable"
        sspec.expect(opt).to_be_false()

    Scenario "Calculate effect severity":
        Given "properties with mixed effects"
        val props = EffectProperties(
            is_pipeline_safe: false,
            is_nogc: false,
            blocking_count: 2,
            gc_alloc_count: 3
        )
        When "calculating severity"
        val sev = props.severity()
        Then "it should be the sum of counts"
        sspec.expect(sev).to_equal(5)
