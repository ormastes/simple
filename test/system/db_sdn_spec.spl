"""
# Database SDN Table Import/Export

## Overview


Simple DB supports reading and writing table data as SDN named tables.
The SDN file is human-readable and uses the table's column names as fields.

## SDN Format
```sdn
users |id, name, active|
    1, "Alice", true
    2, "Bob", false
```
"""

use std.spec
use std.spec.{check, check_msg}
use std.string.{NL}

# Inline type definitions (avoid module import issues in bootstrap)
struct SdnRow:
    fields: Dict<text, text>

    static fn empty() -> SdnRow:
        SdnRow(fields: {})

    fn get(column: text) -> text?:
        if self.fields.contains_key(column):
            Some(self.fields[column])
        else:
            nil

    me set(column: text, value: text):
        self.fields[column] = value

    fn has(column: text) -> bool:
        self.fields.contains_key(column)

class SdnTable:
    name: text
    columns: [text]
    rows: [SdnRow]
    index: Dict<text, i64>

    static fn new(name: text, columns: [text]) -> SdnTable:
        SdnTable(name: name, columns: columns, rows: [], index: {})

    static fn parse(content: text) -> SdnTable?:
        val lines = content.split("{NL}")
        if not lines.?:
            return nil

        var header_idx = -1
        var table_name = ""
        var columns = []

        for (i, line) in lines.enumerate():
            val trimmed = line.trim()
            if trimmed.contains("|") and not trimmed.starts_with("#"):
                val parts = trimmed.split("|")
                if parts.len() >= 3:
                    table_name = parts[0].trim()
                    val col_part = parts[1].trim()
                    val raw_cols = col_part.split(",")
                    columns = raw_cols.map(\c: c.trim())
                    header_idx = i
                    break

        if header_idx == -1:
            return nil

        val table = SdnTable(name: table_name, columns: columns, rows: [], index: {})
        for i in (header_idx + 1)..lines.len():
            val line = lines[i].trim()
            if not line.? or line.starts_with("#"):
                continue

            val parts = split_sdn_row(line)
            if parts.len() != columns.len():
                continue

            val row = SdnRow(fields: {})
            for (j, col) in columns.enumerate():
                val value = parts[j].trim()
                val unquoted = strip_quotes(value)
                row.set(col, unquoted)

            table.add_row(row)

        Some(table)

    fn to_sdn() -> text:
        var result = "{self.name} |"
        result = result + self.columns.join(", ")
        result = result + "|{NL}"

        for row in self.rows:
            result = result + "    "
            var values = []
            for col in self.columns:
                val value = row.get(col) ?? ""
                val formatted = quote_if_needed(value)
                values.push(formatted)
            result = result + values.join(", ")
            result = result + "{NL}"

        result

    me add_row(row: SdnRow) -> bool:
        if row.has("id"):
            val id = row.get("id")?
            self.index[id] = self.rows.len()
        self.rows.push(row)
        true

    fn get_row(key: text) -> SdnRow?:
        if not self.index.contains_key(key):
            return nil
        val idx = self.index[key]
        Some(self.rows[idx])

fn split_sdn_row(line: text) -> [text]:
    var parts = []
    var current = ""
    var in_quotes = false
    var i = 0

    while i < line.len():
        val ch = line[i]
        if ch == '"':
            in_quotes = not in_quotes
            current = current + ch
        elif ch == ',' and not in_quotes:
            parts = parts + [current]
            current = ""
        else:
            current = current + ch
        i = i + 1

    if current.? or parts.len() > 0:
        parts = parts + [current]

    parts

fn strip_quotes(value: text) -> text:
    if value.len() >= 2 and value.starts_with('"') and value.ends_with('"'):
        return value[1..(value.len() - 1)]
    value

fn quote_if_needed(value: text) -> text:
    if value.contains(","):
        return '"' + value + '"'
    value

# ============================================================================
# Tests
# ============================================================================

describe "Database SDN table export":
    it "exports table with simple values to SDN":
        val table = SdnTable.new("users", ["id", "name", "active"])
        val row1 = SdnRow.empty()
        row1.set("id", "1")
        row1.set("name", "Alice")
        row1.set("active", "true")
        table.add_row(row1)

        val row2 = SdnRow.empty()
        row2.set("id", "2")
        row2.set("name", "Bob")
        row2.set("active", "false")
        table.add_row(row2)

        val exported = table.to_sdn()
        expect(exported).to_contain("users |id, name, active|")
        expect(exported).to_contain("Alice")
        expect(exported).to_contain("Bob")

    it "exports table with quoted values containing commas":
        val table = SdnTable.new("data", ["id", "description"])
        val row = SdnRow.empty()
        row.set("id", "1")
        row.set("description", "hello, world")
        table.add_row(row)

        val exported = table.to_sdn()
        expect(exported).to_contain('"hello, world"')

describe "Database SDN table import":
    it "imports table from SDN text":
        val sdn_text = "users |id, name, active|{NL}    1, Alice, true{NL}    2, Bob, false"
        val table = SdnTable.parse(sdn_text)
        expect(table != nil).to_equal(true)

        val t = table.unwrap()
        expect(t.name).to_equal("users")
        expect(t.columns.len()).to_equal(3)
        expect(t.rows.len()).to_equal(2)

    it "imports and reads row values":
        val sdn_text = "users |id, name|{NL}    1, Alice{NL}    2, Bob"
        val table = SdnTable.parse(sdn_text)
        val t = table.unwrap()
        val first_row = t.rows[0]
        expect(first_row.get("id")).to_equal(Some("1"))
        expect(first_row.get("name")).to_equal(Some("Alice"))

describe "Database SDN round-trip":
    it "round-trips simple table through export and import":
        # Create table
        val table = SdnTable.new("projects", ["id", "name", "status"])
        val row = SdnRow.empty()
        row.set("id", "1")
        row.set("name", "Simple")
        row.set("status", "active")
        table.add_row(row)

        # Export then re-import
        val exported = table.to_sdn()
        val reimported = SdnTable.parse(exported)
        expect(reimported != nil).to_equal(true)

        val t = reimported.unwrap()
        expect(t.name).to_equal("projects")
        expect(t.rows.len()).to_equal(1)
        val r = t.rows[0]
        expect(r.get("name")).to_equal(Some("Simple"))
        expect(r.get("status")).to_equal(Some("active"))

    it "round-trips quoted values with commas":
        val table = SdnTable.new("notes", ["id", "text"])
        val row = SdnRow.empty()
        row.set("id", "1")
        row.set("text", "first, second, third")
        table.add_row(row)

        val exported = table.to_sdn()
        val reimported = SdnTable.parse(exported)
        val t = reimported.unwrap()
        val r = t.rows[0]
        expect(r.get("text")).to_equal(Some("first, second, third"))
