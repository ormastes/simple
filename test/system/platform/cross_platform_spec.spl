# Cross-Platform Support Tests
#
# Tests platform detection, path handling, and process management
# across Linux, macOS, Windows, and FreeBSD.
#
# These tests run on ALL platforms and verify platform-specific behavior.

use std.spec
use src.std.platform (is_windows, is_unix, is_linux, is_macos, dir_sep, path_sep, exe_ext, lib_ext)
use std.spec.{check, check_msg}

# ===========================================================================
# Platform Detection Tests
# ===========================================================================

describe "Platform Detection":
    it "detects current operating system":
        # At least one should be true
        val detected = is_windows() or is_unix() or is_linux() or is_macos()
        check(detected)

    it "is_unix returns true on Unix-like systems":
        # Unix includes Linux, macOS, BSD
        if is_linux() or is_macos():
            check(is_unix())
        else:
            # On Windows, is_unix should be false
            check(not is_unix() or is_unix())  # Always passes, just testing it doesn't crash

    it "is_windows and is_unix are mutually exclusive":
        # Can't be both Windows and Unix
        val both = is_windows() and is_unix()
        check(not both)

# ===========================================================================
# Path Separator Tests
# ===========================================================================

describe "Path Separators":
    it "dir_sep returns platform-specific directory separator":
        val sep = dir_sep()
        # Should be either / or \
        val valid = sep == "/" or sep == "\\"
        check(valid)

    it "path_sep returns platform-specific PATH separator":
        val sep = path_sep()
        # Should be either : or ;
        val valid = sep == ":" or sep == ";"
        check(valid)

    it "exe_ext returns correct executable extension":
        val ext = exe_ext()
        # Should be either .exe or empty
        val valid = ext == ".exe" or ext == ""
        check(valid)

    it "lib_ext returns correct library extension":
        val ext = lib_ext()
        # Should be .dll, .so, or .dylib
        val valid = ext == ".dll" or ext == ".so" or ext == ".dylib"
        check(valid)

# ===========================================================================
# Path Handling Tests - Using platform module functions
# ===========================================================================

describe "Path Handling":
    it "join_path combines path components":
        use src.std.platform (join_path)
        val joined = join_path("foo", "bar")
        # Should contain both parts and a separator
        val has_foo = joined.contains("foo")
        val has_bar = joined.contains("bar")
        check(has_foo and has_bar)

    it "normalize_path handles forward slashes":
        use src.std.platform (normalize_path)
        val normalized = normalize_path("foo/bar")
        # Should return a valid path (doesn't crash)
        check(normalized.len() > 0)

    it "is_absolute_path detects absolute paths":
        use src.std.platform (is_absolute_path)
use std.string.{NL}
        # Test Unix absolute path
        val unix_abs = is_absolute_path("/usr/bin")
        # Test relative path
        val relative = is_absolute_path("foo/bar")
        # Unix absolute should be true, relative should be false
        if not is_windows():
            check(unix_abs)
            check(not relative)
        else:
            # Just check it doesn't crash on Windows
            check(true)

# ===========================================================================
# Process Management Tests
# ===========================================================================

# Local helper to avoid circular import with app.io
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn test_shell(command: text) -> (text, text, i64):
    rt_process_run("/bin/sh", ["-c", command])

describe "Process Management":
    it "shell executes simple commands":
        val (out, err, code) = test_shell("echo hello")
        expect(code).to_equal(0)
        expect(out.contains("hello")).to_equal(true)

# ===========================================================================
# Linker Auto-Detection Tests - Skipped (needs SystemLinker enum)
# ===========================================================================

describe "Linker Auto-Detection":
    skip_it "auto_detect_linker returns valid linker":
        # Requires SystemLinker enum which has parser issues
        check(true)

    skip_it "get_linker_info returns non-empty string":
        # Requires linker detection module
        check(true)
