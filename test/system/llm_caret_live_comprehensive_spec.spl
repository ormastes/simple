# LLM Caret - Comprehensive Live Integration Tests
#
# REQUIRES: claude CLI installed and authenticated
# COST: ~$1-2 per full run (uses real Claude API)
# RUNTIME: ~2-3 minutes for all tests
#
# Run with: CLAUDECODE= bin/simple test test/system/llm_caret_live_comprehensive_spec.spl
#
# NOTE: Simple test runner in interpreter mode does NOT execute it blocks.
#       This file is structured for manual execution or future compiled mode.
#
# Tests verify:
#   1. Single-shot responses (5 tests)
#   2. System prompt adherence (2 tests)
#   3. Multi-turn conversation with session resume (6 turns, 5 tests)
#   4. Code tutor session (5 turns, 4 tests)
#   5. Shopping list state tracking (5 turns, 4 tests)
#   6. Edge cases (2 tests)

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_env_set(key: text, value: text)
extern fn rt_env_get(key: text) -> text

# ============================================================================
# JSON helpers (inlined)
# ============================================================================

fn _unwrap_idx(opt) -> i64:
    match opt:
        Some(i): return i
        nil: return -1

fn _extract_json_string(json: text, key: text) -> text:
    val quote = "\""
    val search = quote + key + quote + ":"
    val idx = _unwrap_idx(json.index_of(search))
    if idx < 0:
        return ""
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    if trimmed.starts_with(quote):
        val rest = trimmed.substring(1)
        var end = 0
        var escaped = false
        while end < rest.len():
            val ch = rest[end]
            if escaped:
                escaped = false
            elif ch == "\\":
                escaped = true
            elif ch == "\"":
                return rest.substring(0, end)
            end = end + 1
    ""

fn _extract_json_int(json: text, key: text) -> i64:
    val quote = "\""
    val search = quote + key + quote + ":"
    val idx = _unwrap_idx(json.index_of(search))
    if idx < 0:
        return 0
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    var end = 0
    while end < trimmed.len():
        val ch = trimmed[end]
        if ch == "," or ch == "}" or ch == "]":
            break
        end = end + 1
    val num_str = trimmed.substring(0, end).trim()
    if num_str == "null" or num_str == "":
        return 0
    int(num_str)

# ============================================================================
# Helper: call claude CLI
# ============================================================================

fn call_claude(prompt: text, system_prompt: text, session_id: text, max_turns: i64) -> (text, text, i64):
    # Unset CLAUDECODE to allow claude CLI to run
    rt_env_set("CLAUDECODE", "")

    var args: [text] = []
    args = args + ["-p", prompt]
    args = args + ["--output-format", "json"]
    args = args + ["--max-turns", max_turns.to_text()]

    if system_prompt != "":
        args = args + ["--system-prompt", system_prompt]

    if session_id != "":
        args = args + ["--resume", session_id]

    rt_process_run("claude", args)

fn call_claude_simple(prompt: text) -> (text, text, i64):
    call_claude(prompt, "", "", 1)

# ============================================================================
# Tests - Section 1: Single-shot responses
# ============================================================================

describe "LLM Caret Live Comprehensive Integration":

    describe "Section 1: Single-shot responses":

        it "returns exact text in response":
            val result = call_claude_simple("Reply with exactly: HELLO_SIMPLE")
            val stdout = result.0 ?? ""
            val exit_code = result.2

            expect(exit_code).to_equal(0)

            val content = _extract_json_string(stdout, "result")
            print "  [MANUAL] Content: {content}"
            expect(content.contains("HELLO_SIMPLE")).to_equal(true)

        it "handles simple math":
            val result = call_claude_simple("What is 2 + 2? Reply with ONLY the number.")
            val stdout = result.0 ?? ""
            val content = _extract_json_string(stdout, "result")

            print "  [MANUAL] Math result: {content}"
            expect(content.contains("4")).to_equal(true)

        it "returns model name":
            val result = call_claude_simple("Say hi")
            val stdout = result.0 ?? ""
            val model = _extract_json_string(stdout, "model")

            print "  [MANUAL] Model: {model}"
            expect(model.len() > 0).to_equal(true)

        it "returns session_id for tracking":
            val result = call_claude_simple("Say hello")
            val stdout = result.0 ?? ""
            val session_id = _extract_json_string(stdout, "session_id")

            print "  [MANUAL] Session ID: {session_id}"
            expect(session_id.len() > 0).to_equal(true)

        it "reports token usage":
            val result = call_claude_simple("Say ok")
            val stdout = result.0 ?? ""
            val in_tok = _extract_json_int(stdout, "input_tokens")
            val out_tok = _extract_json_int(stdout, "output_tokens")
            val total = in_tok + out_tok

            print "  [MANUAL] Tokens: in={in_tok}, out={out_tok}, total={total}"
            expect(total > 0).to_equal(true)

    # ========================================================================
    # Section 2: System prompt adherence
    # ========================================================================

    describe "Section 2: System prompt adherence":

        it "follows pirate persona system prompt":
            val result = call_claude(
                "What are you?",
                "You are a pirate named CaptainBytes. Always speak in pirate dialect. Every response MUST include 'Arrr!'",
                "",
                1
            )
            val stdout = result.0 ?? ""
            val content = _extract_json_string(stdout, "result")
            val lower = content.to_lower()

            print "  [MANUAL] Pirate response: {content}"
            expect(lower.contains("arr")).to_equal(true)

        it "follows CSV format constraint":
            val result = call_claude(
                "List 3 fruits",
                "You MUST respond in CSV format only. No explanations, just comma-separated values on a single line.",
                "",
                1
            )
            val stdout = result.0 ?? ""
            val content = _extract_json_string(stdout, "result")

            print "  [MANUAL] CSV response: {content}"
            expect(content.contains(",")).to_equal(true)

    # ========================================================================
    # Section 3: Multi-turn conversation (6 turns)
    # ========================================================================

    describe "Section 3: Multi-turn conversation (6 turns)":

        it "maintains context across 6 turns with session resume":
            # Turn 1: Establish facts
            val r1 = call_claude(
                "Remember these facts: color=BLUE, pet=SPARK, number=13. Reply OK.",
                "",
                "",
                1
            )
            val stdout1 = r1.0 ?? ""
            val session_id = _extract_json_string(stdout1, "session_id")
            print "  [SESSION] {session_id}"
            expect(session_id.len() > 0).to_equal(true)

            # Turn 2: Recall color
            val r2 = call_claude("What is my favorite color? Just the color.", "", session_id, 1)
            val c2 = _extract_json_string(r2.0 ?? "", "result")
            print "  [T2] Color: {c2}"
            expect(c2.to_lower().contains("blue")).to_equal(true)

            # Turn 3: Recall pet name
            val r3 = call_claude("What is my pet's name? Just the name.", "", session_id, 1)
            val c3 = _extract_json_string(r3.0 ?? "", "result")
            print "  [T3] Pet: {c3}"
            expect(c3.to_lower().contains("spark")).to_equal(true)

            # Turn 4: Math on recalled number
            val r4 = call_claude("Multiply my lucky number by 3. ONLY the number.", "", session_id, 1)
            val c4 = _extract_json_string(r4.0 ?? "", "result")
            print "  [T4] Math: {c4}"
            expect(c4.contains("39")).to_equal(true)

            # Turn 5: Add new fact and recall all
            val r5 = call_claude("New fact: city=TOKYO. List all 4 facts.", "", session_id, 1)
            val c5 = _extract_json_string(r5.0 ?? "", "result")
            val upper5 = c5.to_upper()
            print "  [T5] All facts: {c5}"
            val has_blue = upper5.contains("BLUE")
            val has_spark = upper5.contains("SPARK")
            val has_13 = upper5.contains("13")
            val has_tokyo = upper5.contains("TOKYO")
            val has_all = has_blue and has_spark and has_13 and has_tokyo
            expect(has_all).to_equal(true)

            # Turn 6: Cumulative sentence
            val r6 = call_claude("Write one sentence using all 4 facts.", "", session_id, 1)
            val c6 = _extract_json_string(r6.0 ?? "", "result")
            val upper6 = c6.to_upper()
            print "  [T6] Sentence: {c6}"
            val s_blue = upper6.contains("BLUE")
            val s_spark = upper6.contains("SPARK")
            val s_13 = upper6.contains("13") or upper6.contains("THIRTEEN")
            val s_tokyo = upper6.contains("TOKYO")
            val s_all = s_blue and s_spark and s_13 and s_tokyo
            expect(s_all).to_equal(true)

    # ========================================================================
    # Section 4: Code tutor session (5 turns)
    # ========================================================================

    describe "Section 4: Code tutor session (5 turns)":

        it "progressive code Q&A with context building":
            # Turn 1: Setup
            val ra1 = call_claude(
                "I'll ask about: fn square(x): x * x. Say READY.",
                "Concise programming tutor. 1-2 sentences max.",
                "",
                1
            )
            val sida = _extract_json_string(ra1.0 ?? "", "session_id")
            print "  [CODE SESSION] {sida}"

            # Turn 2: Explain square
            val ra2 = call_claude("What does the square function do?", "", sida, 1)
            val ca2 = _extract_json_string(ra2.0 ?? "", "result")
            val lower2 = ca2.to_lower()
            print "  [Q2] Explain: {ca2}"
            val has_kw = (lower2.contains("multipl") or lower2.contains("square") or
                          lower2.contains("times") or lower2.contains("x * x"))
            expect(has_kw).to_equal(true)

            # Turn 3: square(5)
            val ra3 = call_claude("What does square(5) return?", "", sida, 1)
            val ca3 = _extract_json_string(ra3.0 ?? "", "result")
            print "  [Q3] square(5): {ca3}"
            expect(ca3.contains("25")).to_equal(true)

            # Turn 4: cube(3)
            val ra4 = call_claude("Now also: fn cube(x): x * x * x. What is cube(3)?", "", sida, 1)
            val ca4 = _extract_json_string(ra4.0 ?? "", "result")
            print "  [Q4] cube(3): {ca4}"
            expect(ca4.contains("27")).to_equal(true)

            # Turn 5: Cross-reference
            val ra5 = call_claude("What is square(3) + cube(2)? Give the number.", "", sida, 1)
            val ca5 = _extract_json_string(ra5.0 ?? "", "result")
            print "  [Q5] square(3)+cube(2): {ca5}"
            expect(ca5.contains("17")).to_equal(true)

    # ========================================================================
    # Section 5: Shopping list state tracking (5 turns)
    # ========================================================================

    describe "Section 5: Shopping list state tracking (5 turns)":

        it "maintains mutable state across conversation":
            # Turn 1: Start empty
            val r1 = call_claude(
                "We are building a shopping list. Start empty. Say 'List: (empty)'",
                "Maintain a shopping list. Be concise.",
                "",
                1
            )
            val s1 = _extract_json_string(r1.0 ?? "", "session_id")
            print "  [LIST SESSION] {s1}"

            # Turn 2: Add eggs
            val r2 = call_claude("Add EGGS. Show list.", "", s1, 1)
            val c2 = _extract_json_string(r2.0 ?? "", "result")
            print "  [L2] Add eggs: {c2}"
            expect(c2.to_lower().contains("egg")).to_equal(true)

            # Turn 3: Add milk and bread
            val r3 = call_claude("Add MILK and BREAD. Show full list.", "", s1, 1)
            val c3 = _extract_json_string(r3.0 ?? "", "result")
            val l3 = c3.to_lower()
            print "  [L3] Add milk+bread: {c3}"
            val has3 = l3.contains("egg") and l3.contains("milk") and l3.contains("bread")
            expect(has3).to_equal(true)

            # Turn 4: Remove eggs
            val r4 = call_claude("Remove EGGS. Show updated list.", "", s1, 1)
            val c4 = _extract_json_string(r4.0 ?? "", "result")
            val l4 = c4.to_lower()
            print "  [L4] Remove eggs: {c4}"
            val has_milk = l4.contains("milk")
            val has_bread = l4.contains("bread")
            val no_eggs = not l4.contains("egg")
            val correct4 = has_milk and has_bread and no_eggs
            expect(correct4).to_equal(true)

            # Turn 5: Count
            val r5 = call_claude("How many items on the list? Just the number.", "", s1, 1)
            val c5 = _extract_json_string(r5.0 ?? "", "result")
            print "  [L5] Count: {c5}"
            expect(c5.contains("2")).to_equal(true)

    # ========================================================================
    # Section 6: Edge cases
    # ========================================================================

    describe "Section 6: Edge cases":

        it "handles repetition requests":
            val result = call_claude_simple("Repeat PLATYPUS exactly 5 times separated by spaces. Nothing else.")
            val stdout = result.0 ?? ""
            val content = _extract_json_string(stdout, "result")
            val upper = content.to_upper()

            # Count occurrences manually
            var count = 0
            var idx = 0
            val search = "PLATYPUS"
            while idx < upper.len():
                val found_idx = _unwrap_idx(upper.substring(idx).index_of(search))
                if found_idx >= 0:
                    count = count + 1
                    idx = idx + found_idx + search.len()
                else:
                    break

            print "  [EDGE] Repetition count: {count}, content: {content}"
            expect(count >= 5).to_equal(true)

        it "handles exact phrase requests":
            val result = call_claude_simple("Reply with exactly: hello world test")
            val stdout = result.0 ?? ""
            val content = _extract_json_string(stdout, "result")
            val lower = content.to_lower()

            print "  [EDGE] Exact phrase: {content}"
            expect(lower.contains("hello")).to_equal(true)
