# Module Loader Coverage Verification
#
# Uses std.coverage.check_coverage() to verify that module loader
# source files are exercised when system tests run.
#
# Coverage data is read from SIMPLE_COVERAGE_DATA env var or
# build/coverage/coverage.json (populated by --coverage test flag).

use std.coverage.{check_coverage, enable_coverage_tag, disable_coverage_tag, CoverageResult}

describe "Module Loader Coverage":
    it "check_coverage API returns valid result for loader line coverage":
        enable_coverage_tag()
        val result = check_coverage("line", "src/core/interpreter/module_loader.spl", minimum: 0.0)
        expect(result.coverage_type).to_equal("line")
        print "  module_loader.spl line coverage: {result.actual}%  files_matched={result.files_matched}"
        disable_coverage_tag()

    it "check_coverage API returns valid result for loader branch coverage":
        enable_coverage_tag()
        val result = check_coverage("branch", "src/core/interpreter/module_loader.spl", minimum: 0.0)
        expect(result.coverage_type).to_equal("branch")
        print "  module_loader.spl branch coverage: {result.actual}%  files_matched={result.files_matched}"
        disable_coverage_tag()

    it "check_coverage API returns valid result for loader function coverage":
        enable_coverage_tag()
        val result = check_coverage("function", "src/core/interpreter/module_loader.spl", minimum: 0.0)
        expect(result.coverage_type).to_equal("function")
        print "  module_loader.spl function coverage: {result.actual}%  files_matched={result.files_matched}"
        disable_coverage_tag()

    it "check_coverage API returns valid result for wildcard loader pattern":
        enable_coverage_tag()
        val result = check_coverage("line", "src/core/interpreter/**", minimum: 0.0)
        expect(result.coverage_type).to_equal("line")
        print "  src/core/interpreter/** line coverage: {result.actual}%  files_matched={result.files_matched}"
        disable_coverage_tag()

    it "coverage_type field is preserved on error result":
        enable_coverage_tag()
        val result = check_coverage("branch", "src/core/interpreter/module_loader.spl", minimum: 0.0)
        # coverage_type is always set even when no coverage data is available
        expect(result.coverage_type).to_equal("branch")
        expect(result.pattern).to_equal("src/core/interpreter/module_loader.spl")
        disable_coverage_tag()

    it "minimum_check field is set correctly":
        enable_coverage_tag()
        val result = check_coverage("line", "src/core/interpreter/module_loader.spl", minimum: 0.0, minimum_check: true)
        expect(result.minimum_check).to_equal(true)
        disable_coverage_tag()
