# DAP: Step Modes
"""
**Category:** System/DAP
**Status:** Passing
**Priority:** P0

Tests step mode functionality (Continue, StepOver, StepIn, StepOut).

## Features Tested

- Continue mode (mode 0)
- Step Over mode (mode 1) - same or lower depth
- Step Into mode (mode 2) - any depth
- Step Out mode (mode 3) - lower depth only
- Step mode state transitions
- Depth tracking

## Step Mode Values

- 0: Continue - no stepping, break only on breakpoints
- 1: StepOver - break at next line at same or lower depth
- 2: StepIn - break at next line at any depth
- 3: StepOut - break when depth becomes lower than start

## Implementation

Uses FFI functions:
- debug_set_step_mode(mode)
- debug_get_step_mode()
- debug_set_step_start_depth(depth)
- debug_get_step_start_depth()
- debug_stack_depth()
- debug_should_break()
"""

from ffi.debug import {
    debug_set_active, debug_set_step_mode, debug_get_step_mode,
    debug_set_step_start_depth, debug_get_step_start_depth,
    debug_stack_depth, debug_should_break, debug_set_current_location,
    debug_push_frame, debug_pop_frame
}

describe "Step Modes":
    """Tests for stepping through code execution."""

    describe "Mode 0: Continue":
        """Continue execution without stepping."""

        it "sets continue mode":
            debug_set_active(true)
            debug_set_step_mode(0)

            val mode = debug_get_step_mode()
            expect(mode).to_equal(0))

        it "does not break without breakpoint":
            debug_set_active(true)
            debug_set_step_mode(0)
            debug_set_current_location("test.spl", 10, 0)

            val should_break = debug_should_break()
            expect(should_break).to_be_false()

    describe "Mode 1: Step Over":
        """Step over function calls - break at same or lower depth."""

        it "sets step over mode":
            debug_set_active(true)
            debug_set_step_mode(1)

            val mode = debug_get_step_mode()
            expect(mode).to_equal(1))

        it "breaks at same depth":
            debug_set_active(true)
            debug_set_step_mode(1)
            debug_set_step_start_depth(5)

            # Simulate being at depth 5
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)

            debug_set_current_location("test.spl", 11, 0)
            val should_break = debug_should_break()
            expect(should_break).to_be_true()

        it "breaks at lower depth":
            debug_set_active(true)
            debug_set_step_mode(1)
            debug_set_step_start_depth(5)

            # Simulate being at depth 3 (returned from function)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)

            debug_set_current_location("test.spl", 15, 0)
            val should_break = debug_should_break()
            expect(should_break).to_be_true()

        it "does not break at higher depth":
            debug_set_active(true)
            debug_set_step_mode(1)
            debug_set_step_start_depth(3)

            # Simulate being at depth 5 (inside function call)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)

            debug_set_current_location("test.spl", 12, 0)
            val should_break = debug_should_break()
            expect(should_break).to_be_false()

    describe "Mode 2: Step Into":
        """Step into function calls - break at any depth."""

        it "sets step into mode":
            debug_set_active(true)
            debug_set_step_mode(2)

            val mode = debug_get_step_mode()
            expect(mode).to_equal(2))

        it "breaks at any depth - same level":
            debug_set_active(true)
            debug_set_step_mode(2)
            debug_set_current_location("test.spl", 10, 0)

            val should_break = debug_should_break()
            expect(should_break).to_be_true()

        it "breaks at any depth - deeper":
            debug_set_active(true)
            debug_set_step_mode(2)

            debug_push_frame("func", "test.spl", 20, 0)
            debug_set_current_location("test.spl", 21, 0)

            val should_break = debug_should_break()
            expect(should_break).to_be_true()

        it "breaks at any depth - shallower":
            debug_set_active(true)
            debug_set_step_mode(2)
            debug_push_frame("func", "test.spl", 20, 0)
            debug_pop_frame()  # Return from function

            debug_set_current_location("test.spl", 11, 0)
            val should_break = debug_should_break()
            expect(should_break).to_be_true()

    describe "Mode 3: Step Out":
        """Step out of current function - break at lower depth only."""

        it "sets step out mode":
            debug_set_active(true)
            debug_set_step_mode(3)

            val mode = debug_get_step_mode()
            expect(mode).to_equal(3))

        it "breaks at lower depth":
            debug_set_active(true)
            debug_set_step_mode(3)
            debug_set_step_start_depth(5)

            # Simulate at depth 3 (returned)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)

            debug_set_current_location("test.spl", 50, 0)
            val should_break = debug_should_break()
            expect(should_break).to_be_true()

        it "does not break at same depth":
            debug_set_active(true)
            debug_set_step_mode(3)
            debug_set_step_start_depth(5)

            # Simulate at depth 5 (same level)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)

            debug_set_current_location("test.spl", 51, 0)
            val should_break = debug_should_break()
            expect(should_break).to_be_false()

        it "does not break at higher depth":
            debug_set_active(true)
            debug_set_step_mode(3)
            debug_set_step_start_depth(3)

            # Simulate at depth 5 (deeper)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)

            debug_set_current_location("test.spl", 52, 0)
            val should_break = debug_should_break()
            expect(should_break).to_be_false()

    describe "Step mode transitions":
        """Test changing between step modes."""

        it "transitions from Continue to StepOver":
            debug_set_active(true)
            debug_set_step_mode(0)
            expect(debug_get_step_mode()).to_equal(0))

            debug_set_step_mode(1)
            expect(debug_get_step_mode()).to_equal(1))

        it "transitions from StepOver to StepInto":
            debug_set_active(true)
            debug_set_step_mode(1)
            debug_set_step_mode(2)
            expect(debug_get_step_mode()).to_equal(2))

        it "transitions from StepInto to StepOut":
            debug_set_active(true)
            debug_set_step_mode(2)
            debug_set_step_mode(3)
            expect(debug_get_step_mode()).to_equal(3))

        it "returns to Continue after step completes":
            debug_set_active(true)
            debug_set_step_mode(1)
            # After step completes, mode should reset to 0
            debug_set_step_mode(0)
            expect(debug_get_step_mode()).to_equal(0))

    describe "Depth tracking":
        """Test stack depth management."""

        it "tracks depth correctly":
            debug_set_active(true)
            expect(debug_stack_depth()).to_equal(0))

            debug_push_frame("func1", "test.spl", 10, 0)
            expect(debug_stack_depth()).to_equal(1))

            debug_push_frame("func2", "test.spl", 20, 0)
            expect(debug_stack_depth()).to_equal(2))

            debug_pop_frame()
            expect(debug_stack_depth()).to_equal(1))

            debug_pop_frame()
            expect(debug_stack_depth()).to_equal(0))

        it "stores and retrieves start depth":
            debug_set_active(true)
            debug_set_step_start_depth(42)
            expect(debug_get_step_start_depth()).to_equal(42))

    describe "Interaction with breakpoints":
        """Test step modes with breakpoints."""

        it "breakpoints override continue mode":
            debug_set_active(true)
            debug_set_step_mode(0)  # Continue
            debug_add_breakpoint("test.spl", 10, 1)
            debug_set_current_location("test.spl", 10, 0)

            val should_break = debug_should_break()
            expect(should_break).to_be_true()

        it "breakpoints work with step modes":
            debug_set_active(true)
            debug_set_step_mode(1)  # StepOver
            debug_set_step_start_depth(5)
            debug_add_breakpoint("test.spl", 15, 1)

            # At depth 3, on breakpoint line
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_push_frame("test", "test.spl", 10, 0)
            debug_set_current_location("test.spl", 15, 0)

            val should_break = debug_should_break()
            expect(should_break).to_be_true()
