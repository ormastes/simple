# DAP: Debug State Management
# @skip - Uses unsupported keyword: with
"""
**Category:** System/DAP
**Status:** Passing
**Priority:** P0

Tests debug state activation, pause/continue, and location tracking.

## Features Tested

- Debug mode activation/deactivation
- Pause and continue operations
- Current location tracking
- State persistence
- Zero overhead when inactive

## Implementation

Uses FFI functions:
- debug_is_active() / debug_set_active()
- debug_pause() / debug_continue() / debug_is_paused()
- debug_set_current_location() / debug_current_file() / debug_current_line()
"""

use ffi.debug.{
    debug_is_active, debug_set_active,
    debug_pause, debug_continue, debug_is_paused, debug_wait_for_continue,
    debug_set_current_location, debug_current_file, debug_current_line
}

describe "Debug Activation":
    """Tests for enabling/disabling debug mode."""

    it "starts inactive by default":
        # Debug should be off by default for performance
        val active = debug_is_active()
        expect(active).to_equal(false)

    it "activates debug mode":
        debug_set_active(true)
        expect(debug_is_active()).to_equal(true)

    it "deactivates debug mode":
        debug_set_active(true)
        debug_set_active(false)
        expect(debug_is_active()).to_equal(false)

    it "toggles debug mode":
        debug_set_active(true)
        expect(debug_is_active()).to_equal(true)

        debug_set_active(false)
        expect(debug_is_active()).to_equal(false)

        debug_set_active(true)
        expect(debug_is_active()).to_equal(true)

describe "Pause and Continue":
    """Tests for pausing and resuming execution."""

    describe "Pause operations":
        """Test pausing execution."""

        it "starts not paused":
            debug_set_active(true)
            val paused = debug_is_paused()
            expect(paused).to_equal(false)

        it "pauses execution":
            debug_set_active(true)
            debug_pause()
            expect(debug_is_paused()).to_equal(true)

        it "can pause multiple times":
            debug_set_active(true)
            debug_pause()
            debug_pause()  # Should be idempotent
            expect(debug_is_paused()).to_equal(true)

    describe "Continue operations":
        """Test resuming execution."""

        it "continues from paused state":
            debug_set_active(true)
            debug_pause()
            expect(debug_is_paused()).to_equal(true)

            debug_continue()
            expect(debug_is_paused()).to_equal(false)

        it "can continue when not paused":
            debug_set_active(true)
            debug_continue()  # Should be safe
            expect(debug_is_paused()).to_equal(false)

    describe "Pause/continue cycle":
        """Test repeated pause/continue operations."""

        it "handles multiple pause/continue cycles":
            debug_set_active(true)

            debug_pause()
            expect(debug_is_paused()).to_equal(true)

            debug_continue()
            expect(debug_is_paused()).to_equal(false)

            debug_pause()
            expect(debug_is_paused()).to_equal(true)

            debug_continue()
            expect(debug_is_paused()).to_equal(false)

describe "Location Tracking":
    """Tests for tracking current execution location."""

    describe "Setting location":
        """Test updating current location."""

        it "sets current file and line":
            debug_set_active(true)
            debug_set_current_location("test.spl", 42, 5)

            val file = debug_current_file()
            val line = debug_current_line()

            expect(file).to_equal("test.spl")
            expect(line).to_equal(42)

        it "updates location multiple times":
            debug_set_active(true)
            debug_set_current_location("file1.spl", 10, 0)
            expect(debug_current_file()).to_equal("file1.spl")

            debug_set_current_location("file2.spl", 20, 0)
            expect(debug_current_file()).to_equal("file2.spl")

        it "tracks location through different files":
            debug_set_active(true)

            debug_set_current_location("main.spl", 10, 0)
            expect(debug_current_file()).to_equal("main.spl")
            expect(debug_current_line()).to_equal(10)

            debug_set_current_location("utils.spl", 55, 8)
            expect(debug_current_file()).to_equal("utils.spl")
            expect(debug_current_line()).to_equal(55)

    describe "Getting location":
        """Test retrieving current location."""

        it "returns current file":
            debug_set_active(true)
            debug_set_current_location("myfile.spl", 10, 0)

            val file = debug_current_file()
            expect(file).to_equal("myfile.spl")

        it "returns current line":
            debug_set_active(true)
            debug_set_current_location("test.spl", 123, 0)

            val line = debug_current_line()
            expect(line).to_equal(123)

        it "tracks line changes in same file":
            debug_set_active(true)
            debug_set_current_location("test.spl", 10, 0)
            expect(debug_current_line()).to_equal(10)

            debug_set_current_location("test.spl", 11, 0)
            expect(debug_current_line()).to_equal(11)

            debug_set_current_location("test.spl", 12, 0)
            expect(debug_current_line()).to_equal(12)

    describe "Edge cases":
        """Test boundary conditions for location tracking."""

        it "handles line 0":
            debug_set_active(true)
            debug_set_current_location("test.spl", 0, 0)
            expect(debug_current_line()).to_equal(0)

        it "handles large line numbers":
            debug_set_active(true)
            debug_set_current_location("test.spl", 999999, 0)
            expect(debug_current_line()).to_equal(999999)

        it "handles empty file path":
            debug_set_active(true)
            debug_set_current_location("", 10, 0)
            val file = debug_current_file()
            expect(file).to_equal("")

        it "handles paths with special characters":
            debug_set_active(true)
            val path = "src/app/my-module_v2.spl"
            debug_set_current_location(path, 10, 0)
            expect(debug_current_file()).to_equal(path)

        it "handles absolute paths":
            debug_set_active(true)
            val path = "/home/user/project/src/main.spl"
            debug_set_current_location(path, 10, 0)
            expect(debug_current_file()).to_equal(path)

        it "handles relative paths":
            debug_set_active(true)
            val path = "./src/main.spl"
            debug_set_current_location(path, 10, 0)
            expect(debug_current_file()).to_equal(path)

describe "State Persistence":
    """Tests that debug state persists correctly."""

    it "maintains state across operations":
        debug_set_active(true)
        debug_set_current_location("test.spl", 10, 0)
        debug_pause()

        # State should persist
        expect(debug_is_active()).to_equal(true)
        expect(debug_current_file()).to_equal("test.spl")
        expect(debug_current_line()).to_equal(10)
        expect(debug_is_paused()).to_equal(true)

    it "preserves location when toggling debug":
        debug_set_active(true)
        debug_set_current_location("test.spl", 42, 0)

        debug_set_active(false)
        debug_set_active(true)

        # Location may or may not persist - implementation dependent
        # Just verify no crash
        val file = debug_current_file()
        val line = debug_current_line()
        expect(true).to_equal(true)

describe "Performance and Overhead":
    """Tests for minimal overhead when debug is off."""

    it "has no overhead when inactive":
        debug_set_active(false)

        # These operations should be extremely fast when debug off
        for i in 0..1000:
            debug_is_active()  # Should return immediately

        expect(true).to_equal(true)

    it "handles high frequency location updates":
        debug_set_active(true)

        # Simulate expression evaluation on every line
        for i in 0..1000:
            debug_set_current_location("test.spl", i, 0)

        val line = debug_current_line()
        expect(line).to(be_gte(0))

describe "Integration Scenarios":
    """Tests combining multiple debug features."""

    it "tracks location while stepping":
        debug_set_active(true)
        debug_set_step_mode(2)  # StepIn

        debug_set_current_location("test.spl", 10, 0)
        expect(debug_current_line()).to_equal(10)

        debug_set_current_location("test.spl", 11, 0)
        expect(debug_current_line()).to_equal(11)

    it "maintains breakpoints while paused":
        debug_set_active(true)
        debug_add_breakpoint("test.spl", 10, 1)
        debug_pause()

        expect(debug_has_breakpoint("test.spl", 10)).to_equal(true)
        expect(debug_is_paused()).to_equal(true)

    it "tracks location with active breakpoints":
        debug_set_active(true)
        debug_add_breakpoint("test.spl", 42, 1)

        debug_set_current_location("test.spl", 41, 0)
        expect(debug_should_break()).to_equal(false)

        debug_set_current_location("test.spl", 42, 0)
        expect(debug_should_break()).to_equal(true)

    it "handles full debug session lifecycle":
        # Activate
        debug_set_active(true)
        expect(debug_is_active()).to_equal(true)

        # Set breakpoint
        debug_add_breakpoint("test.spl", 20, 1)

        # Execute to breakpoint
        debug_set_current_location("test.spl", 20, 0)
        expect(debug_should_break()).to_equal(true)

        # Pause at breakpoint
        debug_pause()
        expect(debug_is_paused()).to_equal(true)

        # Inspect state (location, stack, etc.)
        expect(debug_current_file()).to_equal("test.spl")
        expect(debug_current_line()).to_equal(20)

        # Continue
        debug_continue()
        expect(debug_is_paused()).to_equal(false)

        # Deactivate
        debug_set_active(false)
        expect(debug_is_active()).to_equal(false)
