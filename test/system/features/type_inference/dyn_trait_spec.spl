# SSpec Test: Dynamic Trait Objects (dyn Trait)
# Feature: Type inference for dynamic trait dispatch
# Category: Type System
# Status: Complete

feature "Dynamic Trait Objects":
    """
    The type checker should correctly handle dynamic trait objects (dyn Trait),
    supporting runtime polymorphism with type safety.

    Key capabilities:
    - Type unification of dyn Trait types
    - Coercion from concrete types to dyn Trait
    - Method dispatch resolution (static vs dynamic)
    - Container types with dyn Trait elements
    """

    scenario "Same dyn trait types unify":
        """
        Two variables of the same dyn Trait type should unify,
        allowing assignment and comparison.
        """
        given:
            trait Show:
                fn show() -> str

            val x: dyn Show = create_show_impl()
            var y: dyn Show = nil

        when "assigning same dyn trait type":
            y = x

        then "type checker should accept the assignment":
            # No type error - both are dyn Show
            assert_type_checks()

    scenario "Different dyn trait types don't unify":
        """
        Two variables of different dyn Trait types should NOT unify,
        preventing incorrect assignments.
        """
        given:
            trait Show:
                fn show() -> str

            trait Debug:
                fn debug() -> str

            val x: dyn Show = create_show_impl()

        when "attempting to assign different dyn trait type":
            var y: dyn Debug = x  # Should fail

        then "type checker should reject the assignment":
            expect_type_error "cannot unify dyn Show with dyn Debug"

    scenario "Concrete type coerces to dyn Trait":
        """
        A concrete type implementing a trait should coerce to dyn Trait,
        enabling polymorphism.
        """
        given:
            trait Show:
                fn show() -> str

            class Point:
                x: i64
                y: i64

            impl Show for Point:
                fn show() -> str:
                    "Point({self.x}, {self.y})"

            val point = Point(x: 3, y: 4)

        when "assigning concrete type to dyn trait":
            val showable: dyn Show = point

        then "type checker should allow coercion":
            assert_type_checks()
            assert showable.show() == "Point(3, 4)"

    scenario "dyn Trait in array types":
        """
        Arrays of dyn Trait should work correctly, allowing
        heterogeneous collections with a common interface.
        """
        given:
            trait Drawable:
                fn draw() -> str

            class Circle:
                radius: f64

            impl Drawable for Circle:
                fn draw() -> str: "Circle"

            class Square:
                side: f64

            impl Drawable for Square:
                fn draw() -> str: "Square"

        when "creating array of dyn Drawable":
            val shapes: [dyn Drawable] = [
                Circle(radius: 5.0),
                Square(side: 10.0)
            ]

        then "type checker should accept the array":
            assert_type_checks()
            assert shapes.len() == 2

    scenario "dyn Trait in Optional types":
        """
        Optional dyn Trait (Option<dyn Trait>) should work,
        allowing nullable trait objects.
        """
        given:
            trait Logger:
                fn log(msg: str)

            var maybe_logger: Option<dyn Logger> = None

        when "assigning Some(concrete impl) to Optional dyn Trait":
            class ConsoleLogger:
                _dummy: i64

            impl Logger for ConsoleLogger:
                fn log(msg: str):
                    print msg

            maybe_logger = Some(ConsoleLogger())

        then "type checker should accept the assignment":
            assert_type_checks()
            assert maybe_logger.is_some()

    scenario "Static dispatch with interface binding":
        """
        When an interface binding exists, dispatch should be static
        (monomorphized at compile time).
        """
        given:
            trait Serializer:
                fn serialize(data: str) -> bytes

            class JsonSerializer:
                _dummy: i64

            impl Serializer for JsonSerializer:
                fn serialize(data: str) -> bytes:
                    data.encode("utf-8")

            # Binding: Serializer interface bound to JsonSerializer
            val serializer: Serializer = JsonSerializer()

        when "calling trait method with binding":
            val result = serializer.serialize("test")

        then "dispatch should be static (direct call)":
            assert_dispatch_mode(serializer, "Static")
            assert_type_checks()

    scenario "Dynamic dispatch without interface binding":
        """
        When no interface binding exists, dispatch should be dynamic
        (vtable lookup at runtime).
        """
        given:
            trait Serializer:
                fn serialize(data: str) -> bytes

            class JsonSerializer impl Serializer:
                fn serialize(data: str) -> bytes:
                    data.encode("utf-8")

            class JsonSerializer2:
                _dummy: i64

            impl Serializer for JsonSerializer2:
                fn serialize(data: str) -> bytes:
                    data.encode("utf-8")

            # No binding: using dyn Trait directly
            val serializer: dyn Serializer = JsonSerializer2()

        when "calling trait method without binding":
            val result = serializer.serialize("test")

        then "dispatch should be dynamic (vtable call)":
            assert_dispatch_mode(serializer, "Dynamic")
            assert_type_checks()

    scenario "Cannot assign dyn Trait to concrete type":
        """
        A dyn Trait value cannot be assigned to a concrete type variable,
        preventing unsafe downcasts.
        """
        given:
            trait Show:
                fn show() -> str

            class Point:
                x: i64
                y: i64

            impl Show for Point:
                fn show() -> str: "Point"

            val showable: dyn Show = Point(x: 1, y: 2)

        when "attempting to assign dyn Trait to concrete type":
            val point: Point = showable  # Should fail

        then "type checker should reject the assignment":
            expect_type_error "cannot unify dyn Show with Point"

    scenario "dyn Trait method calls type check":
        """
        Method calls on dyn Trait should type check against
        the trait's method signatures.
        """
        given:
            trait Calculator:
                fn add(a: i64, b: i64) -> i64
                fn multiply(a: i64, b: i64) -> i64

            class BasicCalc:
                _dummy: i64

            impl Calculator for BasicCalc:
                fn add(a: i64, b: i64) -> i64: a + b
                fn multiply(a: i64, b: i64) -> i64: a * b

            val calc: dyn Calculator = BasicCalc()

        when "calling trait methods on dyn object":
            val sum = calc.add(3, 4)
            val product = calc.multiply(5, 6)

        then "type checker should validate method signatures":
            assert_type_checks()
            assert sum == 7
            assert product == 30

    scenario "dyn Trait with generic methods":
        """
        dyn Trait should work with traits that have generic methods,
        with type parameters resolved at call site.
        """
        given:
            trait Container<T>:
                fn get() -> T
                fn set(value: T)

            class Box<T>:
                value: T

            impl Container<T> for Box<T>:
                fn get() -> T: self.value
                fn set(value: T): self.value = value

            val container: dyn Container<i64> = Box(value: 42)

        when "calling generic methods on dyn trait object":
            val value = container.get()
            container.set(100)

        then "type checker should resolve generic parameters":
            assert_type(value) == "i64"
            assert_type_checks()

# Helper assertions (assumed to exist in test framework)
fn assert_type_checks():
    """Verify that the code type checks without errors"""
    pass

fn expect_type_error(message: str):
    """Expect a specific type error message"""
    pass

fn assert_dispatch_mode(obj, mode: str):
    """Check if dispatch mode is Static or Dynamic"""
    pass

fn assert_type(value) -> str:
    """Get the type of a value as a string"""
    "unknown"
