# Pass and Unit Value Equivalence Spec
# Tests that `pass` and `()` are synonymous in Simple

use std.spec.*

describe "pass and () equivalence":
    it "both work in match arms":
        var result_with_pass = ""
        var result_with_unit = ""

        val opt1 = Some(42)
        match opt1:
            Some(x):
                result_with_pass = "found"
            None:
                pass

        val opt2 = Some(42)
        match opt2:
            Some(x):
                result_with_unit = "found"
            None:
                ()

        expect(result_with_pass).to(equal("found"))
        expect(result_with_unit).to(equal("found"))

    it "both work as standalone statements":
        var executed = false

        # With pass
        pass
        executed = true
        expect(executed).to(be_true())

        # With ()
        executed = false
        ()
        executed = true
        expect(executed).to(be_true())

    it "both work in if-else branches":
        val x = 5
        var branch_taken = ""

        # Using pass
        if x == 10:
            branch_taken = "ten"
        else:
            pass
            branch_taken = "other"

        expect(branch_taken).to(equal("other"))

        # Using ()
        branch_taken = ""
        if x == 10:
            branch_taken = "ten"
        else:
            ()
            branch_taken = "other"

        expect(branch_taken).to(equal("other"))

    it "both work in loops":
        var count = 0

        # With pass
        for i in 0..3:
            if i == 1:
                pass
            count = count + 1

        expect(count).to(equal(3))

        # With ()
        count = 0
        for i in 0..3:
            if i == 1:
                ()
            count = count + 1

        expect(count).to(equal(3))

    it "both work in nested match":
        val opt = Some(None)
        var result = ""

        # Using pass
        match opt:
            Some(inner):
                match inner:
                    Some(val):
                        result = "nested some"
                    None:
                        pass
                result = "outer some"
            None:
                result = "none"

        expect(result).to(equal("outer some"))

        # Using ()
        result = ""
        match opt:
            Some(inner):
                match inner:
                    Some(val):
                        result = "nested some"
                    None:
                        ()
                result = "outer some"
            None:
                result = "none"

        expect(result).to(equal("outer some"))

describe "pass and () documentation":
    it "documents that () is unit value":
        # () is the unit type/value in Simple
        # Type: ()
        # Value: ()
        val unit = ()
        expect(unit).to(equal(()))

    it "documents that pass is no-op statement":
        # pass is a no-op statement (does nothing)
        # Equivalent to () but more explicit in intent
        var x = 0
        pass
        x = 1
        expect(x).to(equal(1))

    it "shows they compile to same code":
        # Both are semantically equivalent
        # Compiler treats them identically
        # Choose based on clarity:
        # - () for expression contexts
        # - pass for "intentionally doing nothing"

        val result1 = match Some(1):
            Some(x): x
            None: ()

        val result2 = match Some(1):
            Some(x): x
            None: pass

        # Both return 1
        expect(result1).to(equal(1))
        expect(result2).to(equal(1))

describe "style guidelines":
    it "recommends () for expression-oriented code":
        # Preferred in expression contexts
        val value = match Some(42):
            Some(x): x
            None: ()  # Returns unit value

        expect(value).to(equal(42))

    it "recommends pass for explicit no-op intent":
        # Clearer when explicitly doing nothing
        var logged = false

        match Some("error"):
            Some(msg):
                # In real code, might log here
                pass  # Explicitly: "not logging in this branch"
                logged = false
            None:
                logged = true

        expect(logged).to(be_false())
