"""
# Lambdas and Closures Specification

**Feature IDs:** #2300
**Category:** Language
**Status:** Implemented

Lambdas (anonymous functions) and closures enable functional programming patterns in Simple.
Lambdas are inline anonymous functions defined with the `\` syntax, while closures are
functions that capture variables from their enclosing scope. Both support type inference,
implicit returns, and composition with higher-order functions like map, filter, and fold.

## Syntax

```simple
# Lambda with type annotation (explicit)
items.map(\x: x * 2)

# Lambda with placeholder syntax (implicit)
items.map(\_.value)

# Lambda returning value
fn apply_twice(f: fn(i32) -> i32, x: i32) -> i32:
    f(f(x))

# Closure capturing variables
fn make_adder(n: i32) -> fn(i32) -> i32:
    \x: x + n
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| Lambda | Anonymous function defined inline with `\` syntax |
| Closure | Function that captures variables from enclosing scope |
| Capture | Process of binding outer scope variables into a function |
| Placeholder Lambda | Shorthand syntax using `_` for lambda parameters |
| Higher-Order Function | Function taking or returning other functions |

## Behavior

Lambdas and closures:
- Are first-class values that can be stored in variables and passed to functions
- Capture variables by reference from their enclosing lexical scope
- Support implicit return of the lambda body expression
- Work with type inference to minimize annotation requirements
- Integrate seamlessly with collection methods (map, filter, fold)

## Related Specifications

- Function Types (fn type declarations)
- Higher-Order Functions (map, filter, reduce operations)
- Placeholder Syntax (underscore patterns in lambdas)
"""

import std.spec

describe "Lambdas and Closures":
    """
    ## Lambda and Closure Specification

    This test suite verifies lambda function and closure behavior including:
    - Basic lambda definition and invocation
    - Type inference in lambda parameters
    - Variable capture from enclosing scopes
    - Closures that modify captured state
    - Integration with higher-order functions
    - Placeholder lambda syntax for concise expressions
    """

    context "basic lambdas":
        it "executes simple lambda":
            val add = \x: \y: x + y
            val add_five = add(5)
            expect add_five(3) == 8

        it "uses lambda with collection methods":
            val numbers = [1, 2, 3, 4, 5]
            val doubled = numbers.map(\x: x * 2)
            expect doubled == [2, 4, 6, 8, 10]

        it "filters with lambda":
            val numbers = [1, 2, 3, 4, 5]
            val evens = numbers.filter(\x: x % 2 == 0)
            expect evens == [2, 4]

    context "lambda with type annotations":
        it "executes lambda with explicit parameter type":
            val square = \x: i32: x * x
            expect square(5) == 25

        it "executes lambda with return type":
            val to_text = \x: i32 -> text: x.to_string()
            expect to_text(42) == "42"

    context "simple closures":
        it "captures variables from outer scope":
            val multiplier = 5
            val multiply = \x: x * multiplier
            expect multiply(3) == 15
            expect multiply(7) == 35

        it "creates closure with multiple captured variables":
            val a = 10
            val b = 20
            val combine = \x: a + b + x
            expect combine(5) == 35

    context "closure state and mutation":
        it "closure uses captured mutable variable":
            var counter = 0
            val increment = \:
                counter = counter + 1
                counter
            expect increment() == 1
            expect increment() == 2
            expect counter == 2

    context "higher-order functions with lambdas":
        it "passes lambda to higher-order function":
            fn apply_twice(f: fn(i32) -> i32, x: i32) -> i32:
                f(f(x))
            val double = \x: x * 2
            expect apply_twice(double, 5) == 20

        it "returns lambda from function":
            fn make_adder(n: i32) -> fn(i32) -> i32:
                \x: x + n
            val add_ten = make_adder(10)
            expect add_ten(5) == 15
            expect add_ten(20) == 30

        it "chains lambda operations":
            val numbers = [1, 2, 3, 4, 5]
            val result = numbers
                .filter(\x: x > 2)
                .map(\x: x * 2)
            expect result == [6, 8, 10]

    context "lambda composition":
        it "composes lambdas":
            val add_one = \x: x + 1
            val double = \x: x * 2
            val composed = \x: double(add_one(x))
            expect composed(5) == 12

    context "placeholder lambda syntax":
        it "uses underscore placeholder in lambda":
            val items = [1, 2, 3]
            val result = items.map(\_.to_string())
            expect result == ["1", "2", "3"]

        it "accesses nested fields with placeholder":
            class Point:
                x: i32
                y: i32
            val points = [Point(x: 1, y: 2), Point(x: 3, y: 4)]
            val x_values = points.map(\_.x)
            expect x_values == [1, 3]
