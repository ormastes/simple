# Freeze and Unfreeze - Comprehensive SSpec Tests
# Testing freeze() function for creating immutable collections

describe "Freeze and Unfreeze":

    context "Freeze Function":
        it "should freeze mutable array":
            var arr = [1, 2, 3]
            val frozen = freeze(arr)
            expect(frozen).to_equal([1, 2, 3])

        it "should freeze mutable dict":
            var dict = {"a": 1}
            val frozen = freeze(dict)
            expect(frozen["a"]).to_equal(1)

        it "should be idempotent":
            val arr = freeze([1, 2, 3])
            val frozen_again = freeze(arr)
            expect(frozen_again).to_equal(arr)

        it "should freeze empty array":
            val frozen = freeze([])
            expect(frozen.len()).to_equal(0)

        it "should freeze empty dict":
            val frozen = freeze({})
            expect(frozen.len()).to_equal(0)

    context "Frozen Array Operations":
        it "should allow reads on frozen array":
            val frozen = freeze([1, 2, 3])
            expect(frozen[0]).to_equal(1)
            expect(frozen[2]).to_equal(3)

        it "should allow len on frozen array":
            val frozen = freeze([1, 2, 3])
            expect(frozen.len()).to_equal(3)

        it "should allow iteration on frozen array":
            val frozen = freeze([1, 2, 3])
            var sum = 0
            for x in frozen:
                sum = sum + x
            expect(sum).to_equal(6)

        it "should reject push on frozen array":
            val frozen = freeze([1, 2, 3])
            expect { frozen.push(4) }.to_raise_error("cannot push to frozen array")

        it "should reject pop on frozen array":
            val frozen = freeze([1, 2, 3])
            expect { frozen.pop() }.to_raise_error("cannot pop from frozen array")

        it "should reject insert on frozen array":
            val frozen = freeze([1, 2, 3])
            expect { frozen.insert(1, 10) }.to_raise_error()

        it "should reject remove on frozen array":
            val frozen = freeze([1, 2, 3])
            expect { frozen.remove(1) }.to_raise_error()

        it "should reject indexing assignment on frozen":
            val frozen = freeze([1, 2, 3])
            expect { frozen[0] = 10 }.to_raise_error()

    context "Functional Operations on Frozen":
        it "should allow map on frozen array":
            val frozen = freeze([1, 2, 3])
            val doubled = frozen.map(\x: x * 2)
            expect(doubled).to_equal([2, 4, 6])

        it "should allow filter on frozen array":
            val frozen = freeze([1, 2, 3, 4, 5])
            val evens = frozen.filter(\x: x % 2 == 0)
            expect(evens).to_equal([2, 4])

        it "should allow concat on frozen arrays":
            val frozen1 = freeze([1, 2])
            val frozen2 = freeze([3, 4])
            val result = frozen1 + frozen2
            expect(result).to_equal([1, 2, 3, 4])

    context "Frozen Dict Operations":
        it "should allow reads on frozen dict":
            val frozen = freeze({"a": 1, "b": 2})
            expect(frozen["a"]).to_equal(1)

        it "should reject insert on frozen dict":
            val frozen = freeze({"a": 1})
            expect { frozen["b"] = 2 }.to_raise_error()

        it "should reject remove on frozen dict":
            val frozen = freeze({"a": 1, "b": 2})
            expect { frozen.remove("a") }.to_raise_error()

    context "Memory Optimization":
        it "should remove RefCell overhead when frozen":
            var arr = [1, 2, 3]
            val frozen = freeze(arr)
            # Frozen should use less memory (no RefCell)
            # This is verified by implementation, not runtime test
