# Fixed-Size Array Edge Cases - Comprehensive SSpec Tests

describe "Fixed-Size Array Edge Cases":

    context "Size Zero":
        it "should allow size-zero arrays":
            val empty: [i64; 0] = []
            expect(empty.len()).to_equal(0)

        it "should iterate over size-zero arrays":
            val empty: [i64; 0] = []
            var count = 0
            for _ in empty:
                count = count + 1
            expect(count).to_equal(0)

    context "Large Sizes":
        it "should handle large fixed-size arrays":
            val buffer: [u8; 1024] = [0; 1024]
            expect(buffer.len()).to_equal(1024)

        it "should handle very large arrays":
            val big: [i64; 10000] = [0; 10000]
            expect(big.len()).to_equal(10000)

    context "Array Concatenation":
        it "should calculate size for concatenation":
            val a: [i64; 2] = [1, 2]
            val b: [i64; 3] = [3, 4, 5]
            val c = a + b
            expect(c.len()).to_equal(5)
            expect(c).to_equal([1, 2, 3, 4, 5])

        it "should concatenate with empty array":
            val a: [i64; 3] = [1, 2, 3]
            val b: [i64; 0] = []
            val c = a + b
            expect(c.len()).to_equal(3)

    context "Slicing":
        it "should return dynamic array from slice":
            val vec5: [i64; 5] = [1, 2, 3, 4, 5]
            val slice = vec5[1:4]
            expect(slice).to_equal([2, 3, 4])

        it "should slice to end":
            val vec5: [i64; 5] = [1, 2, 3, 4, 5]
            val slice = vec5[2:]
            expect(slice).to_equal([3, 4, 5])

        it "should slice from start":
            val vec5: [i64; 5] = [1, 2, 3, 4, 5]
            val slice = vec5[:3]
            expect(slice).to_equal([1, 2, 3])

    context "Runtime Size Checks":
        it "should check size at runtime when needed":
            fn make_array(n: i64) -> [i64]:
                [0 for _ in 0..n]

            val arr = make_array(5)
            expect(arr.len()).to_equal(5)

    context "Conversion":
        it "should convert dynamic to fixed-size with check":
            val arr: [i64] = [1, 2, 3]
            val vec3 = arr.to_fixed::<3>()
            expect(vec3.len()).to_equal(3)

        it "should error on wrong size conversion":
            val arr: [i64] = [1, 2]
            expect { arr.to_fixed::<3>() }.to_raise_error("size mismatch")

    context "Negative Indexing":
        it "should support negative indices":
            val arr: [i64; 5] = [1, 2, 3, 4, 5]
            expect(arr[-1]).to_equal(5)
            expect(arr[-2]).to_equal(4)

    context "Boundary Conditions":
        it "should handle single element arrays":
            val single: [i64; 1] = [42]
            expect(single[0]).to_equal(42)
            expect(single.len()).to_equal(1)
