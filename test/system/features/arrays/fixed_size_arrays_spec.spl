# Fixed-Size Arrays - Comprehensive SSpec Tests
# Decision #8: [T; N] syntax with compile-time size checking

describe "Fixed-Size Arrays":

    context "Basic Syntax":
        it "should create fixed-size array with type annotation":
            val vec3: [f64; 3] = [1.0, 2.0, 3.0]
            expect(vec3.len()).to_equal(3)

        it "should create fixed-size int array":
            val arr: [i64; 5] = [1, 2, 3, 4, 5]
            expect(arr.len()).to_equal(5)

        it "should create 2D fixed-size array":
            val mat3: [[f64; 3]; 3] = [
                [1.0, 0.0, 0.0],
                [0.0, 1.0, 0.0],
                [0.0, 0.0, 1.0],
            ]
            expect(mat3[0][0]).to_equal(1.0)

        it "should create 3D fixed-size array":
            val cube: [[[i64; 2]; 2]; 2] = [
                [[1, 2], [3, 4]],
                [[5, 6], [7, 8]],
            ]
            expect(cube[1][1][1]).to_equal(8)

    context "Compile-Time Size Checking":
        it "should accept exact size match":
            val vec3: [f64; 3] = [1.0, 2.0, 3.0]
            expect(vec3.len()).to_equal(3)

        # These would be compile errors (commented out):
        # it "should reject size mismatch - too few":
        #     val vec3: [f64; 3] = [1.0, 2.0]  # ERROR: size mismatch

        # it "should reject size mismatch - too many":
        #     val vec3: [f64; 3] = [1.0, 2.0, 3.0, 4.0]  # ERROR: size mismatch

    context "Size-Changing Operations Rejected":
        # These would be compile errors (commented out):
        # it "should reject push on fixed-size array":
        #     var vec3: [f64; 3] = [1.0, 2.0, 3.0]
        #     vec3.push(4.0)  # ERROR: cannot push to fixed-size array

        # it "should reject pop on fixed-size array":
        #     var vec3: [f64; 3] = [1.0, 2.0, 3.0]
        #     vec3.pop()  # ERROR: cannot pop from fixed-size array

        # it "should reject insert on fixed-size array":
        #     var vec3: [f64; 3] = [1.0, 2.0, 3.0]
        #     vec3.insert(1, 1.5)  # ERROR: cannot insert

        # it "should reject remove on fixed-size array":
        #     var vec3: [f64; 3] = [1.0, 2.0, 3.0]
        #     vec3.remove(1)  # ERROR: cannot remove

        # it "should reject clear on fixed-size array":
        #     var vec3: [f64; 3] = [1.0, 2.0, 3.0]
        #     vec3.clear()  # ERROR: cannot clear

    context "Allowed Operations":
        it "should allow indexing read":
            val vec3: [f64; 3] = [1.0, 2.0, 3.0]
            expect(vec3[0]).to_equal(1.0)
            expect(vec3[2]).to_equal(3.0)

        it "should allow indexing write":
            var vec3: [f64; 3] = [1.0, 2.0, 3.0]
            vec3[1] = 10.0
            expect(vec3[1]).to_equal(10.0)

        it "should allow len()":
            val vec3: [f64; 3] = [1.0, 2.0, 3.0]
            expect(vec3.len()).to_equal(3)

        it "should allow iteration":
            val vec3: [f64; 3] = [1.0, 2.0, 3.0]
            var sum = 0.0
            for x in vec3:
                sum = sum + x
            expect(sum).to_equal(6.0)

        it "should allow map (returns dynamic array)":
            val vec3: [f64; 3] = [1.0, 2.0, 3.0]
            val doubled = vec3.map(\x: x * 2.0)
            expect(doubled).to_equal([2.0, 4.0, 6.0])

        it "should allow filter (returns dynamic array)":
            val arr: [i64; 5] = [1, 2, 3, 4, 5]
            val evens = arr.filter(\x: x % 2 == 0)
            expect(evens).to_equal([2, 4])

    context "Function Parameters":
        it "should enforce size in function parameters":
            fn dot(a: [f64; 3], b: [f64; 3]) -> f64:
                a[0]*b[0] + a[1]*b[1] + a[2]*b[2]

            val v1: [f64; 3] = [1.0, 2.0, 3.0]
            val v2: [f64; 3] = [4.0, 5.0, 6.0]
            expect(dot(v1, v2)).to_equal(32.0)

        it "should work with inline literals":
            fn sum(arr: [i64; 3]) -> i64:
                arr[0] + arr[1] + arr[2]

            val result = sum([1, 2, 3])
            expect(result).to_equal(6)

        # This would be a compile error:
        # it "should reject wrong size in function call":
        #     fn needs_three(v: [i64; 3]): pass
        #     val vec4: [i64; 4] = [1, 2, 3, 4]
        #     needs_three(vec4)  # ERROR: size mismatch

    context "Type Inference":
        it "should infer size from function parameter":
            fn process(v: [f64; 3]) -> f64:
                v[0] + v[1] + v[2]

            val result = process([1.0, 2.0, 3.0])
            expect(result).to_equal(6.0)

        it "should infer from return type":
            fn make_vec3() -> [f64; 3]:
                [1.0, 2.0, 3.0]

            val v = make_vec3()
            expect(v.len()).to_equal(3)

    context "Const Fixed-Size Arrays":
        it "should create const fixed-size array":
            val UNIT_X: const [f64; 3] = [1.0, 0.0, 0.0]
            expect(UNIT_X[0]).to_equal(1.0)

        it "should allow reads on const array":
            val ORIGIN: const [f64; 3] = [0.0, 0.0, 0.0]
            expect(ORIGIN[0]).to_equal(0.0)
            expect(ORIGIN[1]).to_equal(0.0)
            expect(ORIGIN[2]).to_equal(0.0)

        # This would be a compile error:
        # it "should reject mutation of const array":
        #     val UNIT_X: const [f64; 3] = [1.0, 0.0, 0.0]
        #     UNIT_X[0] = 2.0  # ERROR: cannot mutate const array

    context "Real-World Use Cases":
        it "should work for 3D vectors":
            struct Vec3:
                data: [f64; 3]

                static fn new(x: f64, y: f64, z: f64) -> Vec3:
                    Vec3(data: [x, y, z])

                fn magnitude() -> f64:
                    val x = self.data[0]
                    val y = self.data[1]
                    val z = self.data[2]
                    (x*x + y*y + z*z).sqrt()

            val v = Vec3.new(3.0, 4.0, 0.0)
            expect(v.magnitude()).to_equal(5.0)

        it "should work for RGB colors":
            type Color = [u8; 3]

            val RED: const Color = [255, 0, 0]
            val GREEN: const Color = [0, 255, 0]

            expect(RED[0]).to_equal(255)
            expect(GREEN[1]).to_equal(255)

        it "should work for fixed buffers":
            fn process_buffer(buf: [u8; 256]):
                # Process exactly 256 bytes
                buf.len()

            val buffer: [u8; 256] = [0; 256]
            val size = process_buffer(buffer)
            expect(size).to_equal(256)
