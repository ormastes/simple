"""
# AOP Around Advice Specification

**Feature IDs:** #AOP-AROUND-001 to #AOP-AROUND-010
**Category:** Language
**Status:** Planned
**Tags:** skip

Around advice wraps target function execution and provides control over whether
and how the target is called via the `proceed()` callback. Around advice can
modify arguments, return values, or completely replace execution.

## Syntax

```simple
fn my_around_advice(proceed):
    # Pre-processing
    val result = proceed()  # Must call exactly once
    # Post-processing
    result  # Return modified or original result

on pc{ execution(* target(..)) } use my_around_advice around priority 10
```

## Safety Rules

- Around advice MUST call `proceed()` exactly once
- Not calling `proceed()` is a runtime error
- Calling `proceed()` more than once is a runtime error
- Around advice chain applies outermost-first by priority
"""

use std.spec.*


# ============================================================================
# Test Group 1: Basic Around Behavior
# ============================================================================

describe "Basic Around Advice":
    """
    ## Wrapping Target Execution

    Around advice receives a `proceed` callback that invokes the target
    function (or next advice in chain). The advice controls execution flow.
    """

    context "wrapping execution":
        it "wraps target with around advice":
            fn wrapper(proceed):
                val result = proceed()
                result + 10

            fn target() -> i64:
                32

            on pc{ execution(* target(..)) } use wrapper around priority 10

            expect target() == 42  # 32 + 10

        it "can add behavior before target":
            var before_called = false

            fn pre_wrapper(proceed):
                before_called = true
                proceed()

            fn target() -> i64:
                42

            on pc{ execution(* target(..)) } use pre_wrapper around priority 10

            val result = target()
            expect result == 42
            expect before_called == true

        it "can add behavior after target":
            var after_called = false

            fn post_wrapper(proceed):
                val result = proceed()
                after_called = true
                result

            fn target() -> i64:
                42

            on pc{ execution(* target(..)) } use post_wrapper around priority 10

            val result = target()
            expect result == 42
            expect after_called == true


# ============================================================================
# Test Group 2: Proceed Callback
# ============================================================================

describe "Proceed Callback Behavior":
    """
    ## The proceed() Function

    The `proceed` callback continues execution to the target function or
    next advice. It passes through arguments and returns the result.
    """

    context "proceed invocation":
        it "proceed returns target result":
            fn passthrough(proceed):
                proceed()

            fn get_value() -> i64:
                42

            on pc{ execution(* get_value(..)) } use passthrough around priority 10

            expect get_value() == 42

        it "proceed passes arguments to target":
            fn passthrough(proceed):
                proceed()

            fn add(a: i64, b: i64) -> i64:
                a + b

            on pc{ execution(* add(..)) } use passthrough around priority 10

            expect add(20, 22) == 42

    context "result modification":
        it "modifies return value after proceed":
            fn double_result(proceed):
                proceed() * 2

            fn half() -> i64:
                21

            on pc{ execution(* half(..)) } use double_result around priority 10

            expect half() == 42  # 21 * 2

        it "replaces return value completely":
            fn override_result(proceed):
                val _original = proceed()
                99

            fn original() -> i64:
                42

            on pc{ execution(* original(..)) } use override_result around priority 10

            expect original() == 99


# ============================================================================
# Test Group 3: Around Advice Chaining
# ============================================================================

describe "Around Advice Chain":
    """
    ## Multiple Around Advices

    When multiple around advices match the same join point, they form a chain.
    Higher priority wraps outermost, executing first and last.
    """

    context "chain ordering":
        it "higher priority wraps outermost":
            fn add_one(proceed):
                proceed() + 1

            fn multiply_two(proceed):
                proceed() * 2

            fn base() -> i64:
                3

            # Priority 100 wraps priority 10
            on pc{ execution(* base(..)) } use add_one around priority 100
            on pc{ execution(* base(..)) } use multiply_two around priority 10

            # add_one(multiply_two(base()))
            # = add_one(multiply_two(3))
            # = add_one(3 * 2)
            # = add_one(6)
            # = 6 + 1
            # = 7
            expect base() == 7

        it "lower priority executes closer to target":
            var order: [text] = []

            fn outer(proceed):
                order.push("outer-start")
                val result = proceed()
                order.push("outer-end")
                result

            fn inner(proceed):
                order.push("inner-start")
                val result = proceed()
                order.push("inner-end")
                result

            fn target() -> i64:
                order.push("target")
                42

            on pc{ execution(* target(..)) } use outer around priority 100
            on pc{ execution(* target(..)) } use inner around priority 10

            target()
            expect order[0] == "outer-start"
            expect order[1] == "inner-start"
            expect order[2] == "target"
            expect order[3] == "inner-end"
            expect order[4] == "outer-end"

    context "three-level chain":
        it "chains three around advices correctly":
            fn add_one(proceed):
                proceed() + 1

            fn multiply_two(proceed):
                proceed() * 2

            fn subtract_five(proceed):
                proceed() - 5

            fn base() -> i64:
                10

            on pc{ execution(* base(..)) } use add_one around priority 100
            on pc{ execution(* base(..)) } use multiply_two around priority 50
            on pc{ execution(* base(..)) } use subtract_five around priority 10

            # add_one(multiply_two(subtract_five(base())))
            # = add_one(multiply_two(subtract_five(10)))
            # = add_one(multiply_two(10 - 5))
            # = add_one(multiply_two(5))
            # = add_one(5 * 2)
            # = add_one(10)
            # = 10 + 1
            # = 11
            expect base() == 11


# ============================================================================
# Test Group 4: Proceed Safety Rules
# ============================================================================

describe "Proceed Safety Enforcement":
    """
    ## Enforcing Proceed Rules

    Around advice must call proceed() exactly once. The runtime verifies
    this constraint and raises errors on violations.
    """

    context "proceed once requirement":
        it "allows calling proceed exactly once":
            fn valid_advice(proceed):
                proceed()

            fn target() -> i64:
                42

            on pc{ execution(* target(..)) } use valid_advice around priority 10

            expect target() == 42

        # TODO: Enable when try/catch is implemented
        # it "fails when proceed not called", tag: ["skip"]:
        #     # This test verifies runtime enforcement
        #     fn bad_advice_no_proceed(proceed):
        #         42  # Forgot to call proceed!
        #
        #     fn target() -> i64:
        #         0
        #
        #     on pc{ execution(* target(..)) } use bad_advice_no_proceed around priority 10
        #
        #     var caught = false
        #     try:
        #         target()
        #     catch e:
        #         caught = true
        #         expect e.message.contains("did not call proceed")
        #
        #     expect caught == true
        it "proceed safety enforcement placeholder":
            expect true  # TODO: try/catch not implemented

        # TODO: Enable when try/catch is implemented
        # it "fails when proceed called twice", tag: ["skip"]:
        #     fn bad_advice_double_proceed(proceed):
        #         val first = proceed()
        #         val second = proceed()  # Error!
        #         first + second
        #
        #     fn target() -> i64:
        #         21
        #
        #     on pc{ execution(* target(..)) } use bad_advice_double_proceed around priority 10
        #
        #     var caught = false
        #     try:
        #         target()
        #     catch e:
        #         caught = true
        #         expect e.message.contains("more than once")
        #
        #     expect caught == true


# ============================================================================
# Test Group 5: Error Handling with Result
# ============================================================================

describe "Around Advice Error Handling":
    """
    ## Handling Errors in Around Advice

    Around advice can handle Result types and transform Ok/Err values.
    """

    context "error propagation":
        it "propagates Err from target":
            fn passthrough(proceed):
                proceed()

            fn failing() -> Result<i64, text>:
                Err("intentional failure")

            on pc{ execution(* failing(..)) } use passthrough around priority 10

            val result = failing()
            expect result.err.?

        it "can handle Err and provide fallback":
            fn error_handler(proceed):
                val result = proceed()
                match result:
                    case Err(_):
                        Ok(-1)  # Return fallback on error
                    case Ok(v):
                        Ok(v)

            fn risky() -> Result<i64, text>:
                Err("boom")

            on pc{ execution(* risky(..)) } use error_handler around priority 10

            expect risky().unwrap() == -1

        it "can transform Err message":
            fn error_transformer(proceed):
                val result = proceed()
                match result:
                    case Err(msg):
                        Err("Wrapped: {msg}")
                    case Ok(v):
                        Ok(v)

            fn original_error() -> Result<i64, text>:
                Err("original")

            on pc{ execution(* original_error(..)) } use error_transformer around priority 10

            val result = original_error()
            match result:
                case Err(msg):
                    expect msg.contains("Wrapped")
                    expect msg.contains("original")
                case Ok(_):
                    expect false  # Should not reach here


# ============================================================================
# Test Group 6: Argument Access
# ============================================================================

describe "Around Advice Argument Access":
    """
    ## Accessing and Modifying Arguments

    Around advice can access the original arguments and optionally modify
    them before passing to proceed().
    """

    context "argument inspection":
        it "can inspect arguments before proceed":
            var captured_args: [i64] = []

            fn arg_logger(proceed, args):
                for arg in args:
                    captured_args.push(arg)
                proceed()

            fn sum(a: i64, b: i64, c: i64) -> i64:
                a + b + c

            on pc{ execution(* sum(..)) } use arg_logger around priority 10

            val result = sum(10, 20, 12)
            expect result == 42
            expect captured_args.len() == 3
            expect captured_args[0] == 10
            expect captured_args[1] == 20
            expect captured_args[2] == 12

    context "argument modification":
        it "can modify arguments before proceed":
            fn double_args(proceed, args):
                val doubled = args.map(\x: x * 2)
                proceed_with(doubled)

            fn add(a: i64, b: i64) -> i64:
                a + b

            on pc{ execution(* add(..)) } use double_args around priority 10

            # add(10, 11) with doubled args = add(20, 22) = 42
            expect add(10, 11) == 42


# ============================================================================
# Test Group 7: Use Cases
# ============================================================================

describe "Around Advice Use Cases":
    """
    ## Common Around Advice Patterns

    Around advice enables various cross-cutting patterns including caching,
    retry logic, transaction management, and timing.
    """

    context "caching":
        it "implements memoization with around":
            var cache: Dict<i64, i64> = {}

            fn cache_advice(proceed, args):
                val key = args[0]
                if key in cache:
                    cache[key]
                else:
                    val result = proceed()
                    cache[key] = result
                    result

            var call_count = 0

            fn expensive(n: i64) -> i64:
                call_count = call_count + 1
                n * n

            on pc{ execution(* expensive(..)) } use cache_advice around priority 10

            expect expensive(5) == 25
            expect expensive(5) == 25  # Cached
            expect expensive(5) == 25  # Cached
            expect call_count == 1  # Only computed once

    context "retry logic":
        it "implements retry with around":
            fn retry_advice(proceed):
                var attempts = 0
                var last_error: Option<text> = None

                while attempts < 3:
                    val result = proceed()
                    match result:
                        case Ok(v):
                            return Ok(v)
                        case Err(e):
                            attempts = attempts + 1
                            last_error = Some(e)

                Err(last_error.unwrap_or("max retries"))

            var attempt_count = 0

            fn flaky() -> Result<i64, text>:
                attempt_count = attempt_count + 1
                if attempt_count < 3:
                    Err("not yet")
                else:
                    Ok(42)

            on pc{ execution(* flaky(..)) } use retry_advice around priority 10

            expect flaky().unwrap() == 42
            expect attempt_count == 3

    context "timing":
        it "measures execution time with around":
            var elapsed_ms: i64 = 0

            fn timer_advice(proceed):
                val start = time.now_ms()
                val result = proceed()
                elapsed_ms = time.now_ms() - start
                result

            fn slow_operation() -> i64:
                time.sleep_ms(10)
                42

            on pc{ execution(* slow_operation(..)) } use timer_advice around priority 10

            expect slow_operation() == 42
            expect elapsed_ms >= 10

    context "transaction management":
        it "wraps in transaction with around":
            var tx_started = false
            var tx_committed = false
            var tx_rolled_back = false

            fn tx_advice(proceed):
                tx_started = true
                val result = proceed()
                match result:
                    case Ok(v):
                        tx_committed = true
                        Ok(v)
                    case Err(e):
                        tx_rolled_back = true
                        Err(e)

            fn db_operation() -> Result<i64, text>:
                Ok(42)

            on pc{ execution(* db_operation(..)) } use tx_advice around priority 10

            db_operation()
            expect tx_started == true
            expect tx_committed == true
            expect tx_rolled_back == false
