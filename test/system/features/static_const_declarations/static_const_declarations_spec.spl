# @pending
# @skip - Uses unsupported keyword: with
"""
# Static and Const Declarations Specification

**Feature IDs:** #STATIC-001 to #STATIC-015
**Category:** Language | Declarations
**Difficulty:** 2/5
**Status:** Planned

## Overview

Static and const declarations provide compile-time and runtime constants with
different scoping and initialization rules:
1. `static val` - Module-level immutable constants with static lifetime
2. `static var` - Module-level mutable state (requires careful use)
3. `const` - Compile-time constants with inline optimization
4. `static fn` - Static methods accessible via type/module name

## Syntax

```simple
# Static value (module-level constant)
static val PI = 3.14159
static val MAX_SIZE = 1000

# Static mutable (rare, requires synchronization)
static var counter = 0

# Const (compile-time constant)
const VERSION = "1.0.0"
const DEBUG = false

# Static method
impl Math:
    static fn abs(n: i64) -> i64:
        if n < 0: -n else: n

# Static method usage
val result = Math.abs(-42)
```

## Key Concepts

| Concept | Scope | Initialization | Mutability | Use Case |
|---------|-------|-----------------|-----------|----------|
| static val | Module | Runtime | Immutable | Constants, caches |
| static var | Module | Runtime | Mutable | State, counters |
| const | Module | Compile-time | Immutable | Literals, flags |
| static fn | Type | N/A | N/A | Factory, utility |

## Behavior

- Static values are initialized once at module load
- Constants are inlined at compile time
- Static methods do not receive `self` parameter
- Static var requires thread-safe access in concurrent contexts
- Statics are lazily initialized (first access)

## Related Specifications

- [Module System](module_system_spec.spl) - Scoping rules
- [Functions](functions_spec.spl) - Method definitions
"""



# ============================================================================
# Test Group 1: Static Value Parsing and Syntax
# ============================================================================

describe "Static Value Declaration":
    """
    ## Static Value Parsing

    Verifies that `static val` declarations are parsed and recognized correctly.
    """

    it "parses simple static value":
        val source = "static val PI = 3.14159"
        expect(true).to_equal(true)

    it "parses static value with type annotation":
        val source = "static val MAX_SIZE: i64 = 1000"
        expect(true).to_equal(true)

    it "parses static value with complex expression":
        val source = "static val GREETING = \"Hello, \" + \"World\""
        expect(true).to_equal(true)

    it "parses multiple static values":
        val source = """
static val A = 1
static val B = 2
static val C = 3
"""
        expect(true).to_equal(true)


# ============================================================================
# Test Group 2: Const Declaration Parsing and Syntax
# ============================================================================

describe "Const Declaration":
    """
    ## Const Declaration Parsing

    Verifies that `const` declarations are parsed and recognized correctly.
    Const values are compile-time constants.
    """

    it "parses simple const":
        val source = "const DEBUG = false"
        expect(true).to_equal(true)

    it "parses const with type annotation":
        val source = "const VERSION: text = \"1.0.0\""
        expect(true).to_equal(true)

    it "parses const with numeric value":
        val source = "const MAX_RETRIES = 5"
        expect(true).to_equal(true)

    it "parses const with string value":
        val source = "const APP_NAME = \"MyApp\""
        expect(true).to_equal(true)


# ============================================================================
# Test Group 3: Static Method Parsing and Syntax
# ============================================================================

describe "Static Method Declaration":
    """
    ## Static Method Parsing

    Verifies that `static fn` method declarations are parsed correctly.
    Static methods belong to the type/module and do not receive self.
    """

    it "parses simple static method":
        val source = """
impl Calculator:
    static fn add(a: i64, b: i64) -> i64:
        a + b
"""
        expect(true).to_equal(true)

    it "parses static method with no parameters":
        val source = """
impl Clock:
    static fn now() -> i64:
        42
"""
        expect(true).to_equal(true)

    it "parses static method with multiple parameters":
        val source = """
impl Point:
    static fn distance(x1: i64, y1: i64, x2: i64, y2: i64) -> i64:
        0
"""
        expect(true).to_equal(true)

    it "parses static method returning complex type":
        val source = """
impl Factory:
    static fn create_list() -> [i64]:
        []
"""
        expect(true).to_equal(true)


# ============================================================================
# Test Group 4: Static Value Initialization
# ============================================================================

describe "Static Value Initialization":
    """
    ## Static Value Initialization

    Tests runtime initialization of static values.
    """

    it "initializes simple static value":
        val source = """
static val NUMBER = 42

fn test():
    NUMBER
"""
        expect(true).to_equal(true)

    it "initializes static value from function call":
        val source = """
fn get_value():
    100

static val VALUE = get_value()
"""
        expect(true).to_equal(true)

    it "initializes static value from collection":
        val source = """
static val NUMBERS = [1, 2, 3, 4, 5]
"""
        expect(true).to_equal(true)


# ============================================================================
# Test Group 5: Static Value Access and Usage
# ============================================================================

describe "Static Value Access":
    """
    ## Static Value Access

    Tests accessing and using static values in functions and expressions.
    """

    it "accesses static value in function":
        val source = """
static val PI = 3
fn area(r):
    PI * r * r
"""
        expect(true).to_equal(true)

    it "accesses multiple static values":
        val source = """
static val X = 1
static val Y = 2
fn sum():
    X + Y
"""
        expect(true).to_equal(true)

    it "uses static value in expression":
        val source = """
static val MAX = 100
fn is_valid(n):
    n <= MAX
"""
        expect(true).to_equal(true)


# ============================================================================
# Test Group 6: Const Value Evaluation
# ============================================================================

describe "Const Value Evaluation":
    """
    ## Const Value Evaluation

    Tests that const values are evaluated at compile time.
    """

    it "evaluates const arithmetic":
        val source = """
const RESULT = 2 + 3
"""
        expect(true).to_equal(true)

    it "evaluates const string concatenation":
        val source = """
const FULL_NAME = "John" + " " + "Doe"
"""
        expect(true).to_equal(true)

    it "uses const in expression":
        val source = """
const DEBUG = true
fn maybe_print(msg):
    if DEBUG: print msg
"""
        expect(true).to_equal(true)


# ============================================================================
# Test Group 7: Static Method Call Syntax
# ============================================================================

describe "Static Method Call Syntax":
    """
    ## Static Method Call Syntax

    Tests that static methods are called correctly via type/module name.
    """

    it "calls static method on class":
        val source = """
impl Math:
    static fn abs(n: i64) -> i64:
        if n < 0: -n else: n

fn test():
    Math.abs(-42)
"""
        expect(true).to_equal(true)

    it "calls static method with multiple arguments":
        val source = """
impl Util:
    static fn max(a: i64, b: i64) -> i64:
        if a > b: a else: b

fn test():
    Util.max(10, 20)
"""
        expect(true).to_equal(true)

    it "calls static method and uses result":
        val source = """
impl Factory:
    static fn create() -> i64:
        42

fn test():
    val result = Factory.create()
    result
"""
        expect(true).to_equal(true)


# ============================================================================
# Test Group 8: Static Var Declaration
# ============================================================================

describe "Static Var Declaration":
    """
    ## Static Var Declaration

    Tests mutable static variables (rare usage, requires care).
    """

    it "parses static mutable variable":
        val source = "static var counter = 0"
        expect(true).to_equal(true)

    it "parses static var with type annotation":
        val source = "static var state: i64 = 100"
        expect(true).to_equal(true)

    it "accesses static var":
        val source = """
static var count = 0
fn get_count():
    count
"""
        expect(true).to_equal(true)


# ============================================================================
# Test Group 9: Visibility and Scoping
# ============================================================================

describe "Static and Const Visibility":
    """
    ## Visibility and Scoping

    Tests visibility modifiers on static and const declarations.
    """

    it "parses public static value":
        val source = "pub static val PUBLIC_CONST = 42"
        expect(true).to_equal(true)

    it "parses public const":
        val source = "pub const PUBLIC_CONST = \"visible\""
        expect(true).to_equal(true)

    it "parses public static method":
        val source = """
impl Math:
    pub static fn add(a: i64, b: i64) -> i64:
        a + b
"""
        expect(true).to_equal(true)

    it "parses private static value":
        val source = "static val PRIVATE = 100"
        expect(true).to_equal(true)


# ============================================================================
# Test Group 10: Type Annotations on Statics
# ============================================================================

describe "Static Type Annotations":
    """
    ## Type Annotations on Statics

    Tests explicit type annotations for static values.
    """

    it "annotates static with primitive type":
        val source = "static val NUM: i64 = 42"
        expect(true).to_equal(true)

    it "annotates static with generic type":
        val source = "static val ITEMS: [i64] = [1, 2, 3]"
        expect(true).to_equal(true)

    it "annotates const with text type":
        val source = "const MESSAGE: text = \"Hello\""
        expect(true).to_equal(true)

    it "annotates static with optional type":
        val source = "static val VALUE: i64? = None"
        expect(true).to_equal(true)


# ============================================================================
# Test Group 11: Static Initialization Order
# ============================================================================

describe "Static Initialization Order":
    """
    ## Static Initialization Order

    Tests the order of static initialization across module.
    """

    it "initializes statics before main code":
        val source = """
static val A = 1
static val B = 2

fn test():
    A + B
"""
        expect(true).to_equal(true)

    it "allows static reference to earlier static":
        val source = """
static val BASE = 100
static val OFFSET = BASE + 50
"""
        expect(true).to_equal(true)

    it "handles circular static references safely":
        val source = """
static val X = 10
static val Y = X + 5
"""
        expect(true).to_equal(true)


# ============================================================================
# Test Group 12: Static Edge Cases
# ============================================================================

describe "Static Declaration Edge Cases":
    """
    ## Edge Cases

    Tests boundary conditions and error cases.
    """

    it "rejects static with no initializer":
        val source = "static val UNINITIALIZED: i64"
        expect(true).to_equal(true)  # Should error

    it "rejects const with no initializer":
        val source = "const UNINITIALIZED: i64"
        expect(true).to_equal(true)  # Should error

    it "rejects static keyword in function body":
        val source = """
fn test():
    static val LOCAL = 42
"""
        expect(true).to_equal(true)  # Should error

    it "allows static in class definition":
        val source = """
class MyClass:
    static val CLASS_CONST = 42
"""
        expect(true).to_equal(true)

    it "rejects duplicate static declaration":
        val source = """
static val VALUE = 1
static val VALUE = 2
"""
        expect(true).to_equal(true)  # Should error


# ============================================================================
# Test Group 13: Const Expression Restrictions
# ============================================================================

describe "Const Expression Restrictions":
    """
    ## Const Expression Restrictions

    Tests what kinds of expressions are allowed in const initialization.
    """

    it "allows const with arithmetic":
        val source = "const VALUE = 10 * 2 + 5"
        expect(true).to_equal(true)

    it "allows const with string literal":
        val source = "const NAME = \"System\""
        expect(true).to_equal(true)

    it "allows const with boolean":
        val source = "const ENABLED = true"
        expect(true).to_equal(true)

    it "rejects const with function call":
        val source = """
fn get_value():
    42

const VALUE = get_value()
"""
        expect(true).to_equal(true)  # May error depending on semantics

    it "rejects const with non-literal array":
        val source = """
fn get_array():
    [1, 2, 3]

const ITEMS = get_array()
"""
        expect(true).to_equal(true)  # May error


# ============================================================================
# Test Group 14: Static Method in Type Context
# ============================================================================

describe "Static Methods in Type Context":
    """
    ## Static Methods in Type Context

    Tests static methods as factory functions and type methods.
    """

    it "uses static method as factory":
        val source = """
class Point:
    x: i64
    y: i64

impl Point:
    static fn origin() -> Point:
        Point(x: 0, y: 0)

fn test():
    val p = Point.origin()
"""
        expect(true).to_equal(true)

    it "static method separate from instance methods":
        val source = """
impl Counter:
    var count: i64

    fn increment():
        self.count = self.count + 1

    static fn create() -> Counter:
        Counter(count: 0)
"""
        expect(true).to_equal(true)


# ============================================================================
# Test Group 15: Cross-Module Static References
# ============================================================================

describe "Cross-Module Static References":
    """
    ## Cross-Module Static References

    Tests accessing statics and consts from other modules.
    """

    it "references static from imported module":
        val source = """
import math.constants

fn test():
    constants.PI
"""
        expect(true).to_equal(true)

    it "references const from imported module":
        val source = """
import config.defaults

fn test():
    val timeout = defaults.TIMEOUT
"""
        expect(true).to_equal(true)

    it "calls static method from imported module":
        val source = """
import utils.math

fn test():
    math.abs(-5)
"""
        expect(true).to_equal(true)
