/// SSpec tests for underscore wildcard support
/// Tests _ (underscore) as a placeholder in:
/// - Lambda parameters: \_: expr
/// - For loop patterns: for _ in items:
/// - Match patterns: case _:

use spec.{describe, it, expect}

# ============================================================================
# Helper Functions for Underscore Wildcard Tests
# ============================================================================

# For loop with underscore pattern
fn sum_n_times(value: i64, n: i64) -> i64:
    var total = 0
    for _ in 0..n:
        total = total + value
    return total

# Match with underscore wildcard
fn classify_number(x: i64) -> text:
    match x:
        case 0: "zero"
        case 1: "one"
        case 2: "two"
        case _: "many"

# Enum match with underscore in payload
enum MyOption:
    Some(i64)
    Nil

fn is_some(opt: MyOption) -> bool:
    match opt:
        case MyOption.Some(_): true
        case MyOption.Nil: false

# ============================================================================
# SSpec Tests
# ============================================================================

describe "Underscore Wildcard Support":
    describe "in lambda parameters":
        it "ignores single argument":
            val f = \_: 42
            expect(f(100)).to_equal(42)
            expect(f(0)).to_equal(42)
            expect(f(-5)).to_equal(42)

        it "works in map to transform values":
            val items = [1, 2, 3, 4, 5]
            val result = items.map(\_: 0)
            expect(result.len()).to_equal(5)

    describe "in for loop patterns":
        it "iterates without binding":
            var total = 0
            for _ in 0..5:
                total = total + 1
            expect(total).to_equal(5)

        it "uses sum_n_times helper":
            expect(sum_n_times(10, 3)).to_equal(30)
            expect(sum_n_times(5, 4)).to_equal(20)

        it "works with list iteration":
            var count = 0
            for _ in [1, 2, 3]:
                count = count + 1
            expect(count).to_equal(3)

    describe "in match patterns":
        it "catches unmatched cases":
            expect(classify_number(0)).to_equal("zero")
            expect(classify_number(1)).to_equal("one")
            expect(classify_number(2)).to_equal("two")
            expect(classify_number(100)).to_equal("many")
            expect(classify_number(-1)).to_equal("many")

        it "ignores enum payload":
            expect(is_some(MyOption.Some(42))).to_equal(true)
            expect(is_some(MyOption.Some(0))).to_equal(true)
            expect(is_some(MyOption.Nil)).to_equal(false)
