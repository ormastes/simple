"""
# Transform Specification

**Feature IDs:** #MATH-004
**Category:** Stdlib
**Difficulty:** 3/5
**Status:** Implemented

## Overview
Transform (f32) and Transformd (f64) combining position, rotation, and scale.

## Key Concepts
| Concept | Description |
|---------|-------------|
| Transform | Position + rotation + scale |
| Composition | Parent-child transform combining |
| to_mat4 | Convert to 4x4 matrix |

## Behavior
- Identity transform: origin, no rotation, unit scale
- Compose transforms for hierarchy
- Convert to matrix for GPU upload
- SLERP-based interpolation
"""

import std.spec
use math

# ============================================================================
# Transform Construction
# ============================================================================

describe "Transform Construction":
    it "creates identity transform":
        val t = math.Transform.identity()
        expect t.position.is_zero() == true
        expect t.rotation.w == 1.0
        expect t.scale.x == 1.0
        expect t.scale.y == 1.0
        expect t.scale.z == 1.0

    it "converts to mat4":
        val t = math.Transform.identity()
        val m = t.to_mat4()
        expect m.data[0] == 1.0
        expect m.data[5] == 1.0
        expect m.data[10] == 1.0
        expect m.data[15] == 1.0

# ============================================================================
# Transform Direction Vectors
# ============================================================================

describe "Transform Direction Vectors":
    it "identity forward is +Z":
        val t = math.Transform.identity()
        val fwd = t.forward()
        expect fwd.z == 1.0

    it "identity right is +X":
        val t = math.Transform.identity()
        val r = t.right()
        expect r.x == 1.0

    it "identity up is +Y":
        val t = math.Transform.identity()
        val u = t.up()
        expect u.y == 1.0

# ============================================================================
# Transform Composition
# ============================================================================

describe "Transform Composition":
    it "combines identity transforms":
        val parent = math.Transform.identity()
        val child = math.Transform.identity()
        val combined = parent.combine(child)
        expect combined.position.is_zero() == true

    it "combines translation":
        val parent = math.Transform(
            position: math.Vec3(10.0, 0.0, 0.0),
            rotation: math.Quat.identity(),
            scale: math.Vec3.one()
        )
        val child = math.Transform(
            position: math.Vec3(5.0, 0.0, 0.0),
            rotation: math.Quat.identity(),
            scale: math.Vec3.one()
        )
        val combined = parent.combine(child)
        expect combined.position.x == 15.0

    it "transforms a point":
        val t = math.Transform(
            position: math.Vec3(10.0, 20.0, 30.0),
            rotation: math.Quat.identity(),
            scale: math.Vec3.one()
        )
        val p = math.Vec3(1.0, 2.0, 3.0)
        val result = t.transform_point(p)
        expect result.x == 11.0
        expect result.y == 22.0
        expect result.z == 33.0

# ============================================================================
# Transform Interpolation
# ============================================================================

describe "Transform Interpolation":
    it "lerps between transforms":
        val a = math.Transform(
            position: math.Vec3.zero(),
            rotation: math.Quat.identity(),
            scale: math.Vec3.one()
        )
        val b = math.Transform(
            position: math.Vec3(10.0, 10.0, 10.0),
            rotation: math.Quat.identity(),
            scale: math.Vec3.one()
        )
        val mid = a.lerp(b, 0.5)
        expect mid.position.x == 5.0
        expect mid.position.y == 5.0
        expect mid.position.z == 5.0
