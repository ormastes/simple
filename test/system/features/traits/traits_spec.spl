"""
# Traits Specification

**Feature IDs:** #TBD
**Category:** Language
**Difficulty:** 3/5
**Status:** Implemented

## Overview

Traits define shared behavior that types can implement, enabling polymorphism
and code reuse. They are similar to interfaces in other languages but support
default implementations, associated types, and trait bounds for generics.

## Syntax

```simple
trait Printable:
    fn print(self)

trait Addable:
    fn add(self, other: Self) -> Self

    fn double(self) -> Self:  # Default implementation
        self.add(self)

impl Printable for Point:
    fn print(self):
        print("({x}, {y})")
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| Trait | Interface defining shared behavior |
| Implementation | Concrete behavior for a specific type |
| Default Method | Trait method with provided implementation |
| Trait Bound | Generic constraint requiring trait implementation |

## Behavior

- Traits define method signatures types must implement
- Default methods provide optional implementations
- Types can implement multiple traits
- Trait bounds constrain generic type parameters
"""

use std.spec


# ============================================================================
# Trait Basics
# ============================================================================

describe "Traits":
    """
    ## Core Trait Functionality

    Tests for trait definition, implementation, and usage including
    default methods, trait bounds, and multiple trait implementations.
    """

    context "basic trait implementation":
        """
        ### Scenario: Trait Implementation

        Tests implementing traits for structs.
        """

        it "implements trait for struct":
            trait Summable:
                fn sum(self):
                    return 0

            struct Point:
                x: i64
                y: i64

            impl Summable for Point:
                fn sum(self):
                    return self.x + self.y

            val p = Point { x: 10, y: 20 }
            expect p.sum() == 30

        it "implements trait with arguments":
            trait Calculator:
                fn add(self, n):
                    return 0

            struct Counter:
                value: i64

            impl Calculator for Counter:
                fn add(self, n):
                    return self.value + n

            val c = Counter { value: 50 }
            expect c.add(25) == 75

    context "multiple trait implementations":
        """
        ### Scenario: Multiple Types Implementing Same Trait

        Tests polymorphism through trait implementations.
        """

        it "allows multiple types to implement same trait":
            trait Valuable:
                fn value(self):
                    return 0

            struct Coin:
                amount: i64

            struct Bill:
                amount: i64

            impl Valuable for Coin:
                fn value(self):
                    return self.amount

            impl Valuable for Bill:
                fn value(self):
                    return self.amount * 100

            val c = Coin { amount: 5 }
            val b = Bill { amount: 2 }
            expect c.value() + b.value() == 205


# ============================================================================
# Default Trait Methods
# ============================================================================

describe "Default Trait Methods":
    """
    ## Default Method Implementations

    Tests for traits with default method implementations.
    """

    it "uses default trait method when not overridden":
        trait Greeter:
            fn greet(self) -> i64
            fn farewell(self) -> i64:
                return 99

        struct Person:
            name: str

        impl Greeter for Person:
            fn greet(self) -> i64:
                return 42

        val p = Person { name: "Alice" }
        expect p.farewell() == 99

    it "allows overriding default trait method":
        trait Greeter:
            fn greet(self) -> i64
            fn farewell(self) -> i64:
                return 99

        struct Person:
            name: str

        impl Greeter for Person:
            fn greet(self) -> i64:
                return 42
            fn farewell(self) -> i64:
                return 7

        val p = Person { name: "Bob" }
        expect p.farewell() == 7

    it "default method can call abstract method":
        trait Calculator:
            fn compute(self) -> i64
            fn double(self) -> i64:
                return self.compute() * 2

        struct Value:
            n: i64

        impl Calculator for Value:
            fn compute(self) -> i64:
                return self.n

        val v = Value { n: 21 }
        expect v.double() == 42


# ============================================================================
# Dynamic Trait Objects
# ============================================================================

describe "Dynamic Trait Objects":
    """
    ## dyn Trait for Dynamic Dispatch

    Tests for trait objects enabling runtime polymorphism.
    """

    it "coerces concrete type to dyn Trait via let binding":
        trait Drawable:
            fn draw(self) -> i64

        struct Circle:
            radius: i64

        impl Drawable for Circle:
            fn draw(self) -> i64:
                return self.radius * 3

        val c = Circle { radius: 7 }
        val drawable: dyn Drawable = c
        expect drawable.draw() == 21

    it "passes concrete type to dyn Trait parameter":
        trait Shape:
            fn area(self) -> i64

        struct Square:
            side: i64

        impl Shape for Square:
            fn area(self) -> i64:
                return self.side * self.side

        fn process_shape(s: dyn Shape) -> i64:
            return s.area()

        val sq = Square { side: 6 }
        expect process_shape(sq) == 36

    it "handles multiple types via dyn Trait":
        trait Describable:
            fn value(self) -> i64

        struct A:
            x: i64

        struct B:
            y: i64

        impl Describable for A:
            fn value(self) -> i64:
                return self.x * 10

        impl Describable for B:
            fn value(self) -> i64:
                return self.y + 100

        fn get_value(d: dyn Describable) -> i64:
            return d.value()

        val a = A { x: 5 }
        val b = B { y: 7 }
        expect get_value(a) + get_value(b) == 157
