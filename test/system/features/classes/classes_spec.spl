"""
# Classes and Object-Oriented Programming Specification

**Feature ID:** #OOP-001
**Category:** Language | Classes
**Status:** Implemented

## Overview

Tests for class definitions, instance creation, field access, methods,
impl blocks, context blocks, method_missing, auto-forwarding properties,
and static polymorphism with interface bindings.

## Syntax

```simple
class Calculator:
    static fn add(a, b):
        return a + b

struct Point:
    x: i64
    y: i64

impl Point:
    fn sum(self):
        return self.x + self.y

context obj:
    method()  # Dispatches to obj.method()
```
"""



# ============================================================================
# Test Group 1: Static Class Methods
# ============================================================================

describe "Static Class Methods":
    """
    ## Static Method Definitions

    Tests for static methods on classes using `static fn`.
    """

    it "calls static method on class":
        class Calculator:
            static fn add(a, b):
                return a + b

        expect Calculator.add(3, 4) == 7

    it "calls multiple static methods":
        class Math:
            static fn double(x):
                return x * 2

            static fn triple(x):
                return x * 3

        expect Math.double(5) + Math.triple(4) == 22


# ============================================================================
# Test Group 2: Impl Blocks
# ============================================================================

describe "Impl Blocks":
    """
    ## Implementation Blocks for Structs

    Tests for adding methods to structs via impl blocks.
    Note: Block-scoped impl blocks are not yet supported. These tests
    are skipped but verified via Rust tests in interpreter_oop.rs.
    """

    it "adds method to struct via impl":
        # Block-scoped impl now works!
        struct Point:
            x: i64
            y: i64

        impl Point:
            fn sum(self):
                return self.x + self.y

        val p = Point { x: 15, y: 25 }
        expect p.sum() == 40

    it "adds method with arguments via impl":
        # Block-scoped impl now works!
        struct Counter:
            value: i64

        impl Counter:
            fn add(self, n):
                return self.value + n

        val c = Counter { value: 10 }
        expect c.add(5) == 15


# ============================================================================
# Test Group 3: Class Instantiation
# ============================================================================

describe "Class Instantiation":
    """
    ## Direct Construction Syntax

    Tests for creating class instances with ClassName(field: value).
    """

    it "creates instances with direct construction":
        class Person:
            name: str
            age: i64

        val p = Person { name: "Alice", age: 30 }
        expect p.age == 30

    it "accesses string field":
        class Greeting:
            message: str

        val g = Greeting { message: "Hello" }
        var result = 0
        if g.message == "Hello":
            result = 1
        expect result == 1

    it "creates class with default field values", tag: ["skip"]:
        # Block-scoped class default field values need investigation
        class Counter:
            count: i64 = 0

        val c = Counter {}
        expect c.count == 0


# ============================================================================
# Test Group 4: Instance Methods
# ============================================================================

describe "Instance Methods":
    """
    ## Methods Defined in Class Body

    Tests for instance methods with self access.
    """

    it "calls instance method":
        class Box:
            value: i64

            fn get_double(self):
                return self.value * 2

        val b = Box { value: 21 }
        expect b.get_double() == 42

    it "calls method with arguments":
        class Adder:
            base: i64

            fn add(self, x):
                return self.base + x

        val a = Adder { base: 10 }
        expect a.add(5) == 15


# ============================================================================
# Test Group 5: Context Blocks
# ============================================================================

describe "Context Blocks":
    """
    ## Context Block for Method Dispatch

    Tests for `context obj:` blocks where unqualified calls dispatch to context object.
    Note: Block-scoped context blocks are not yet supported. These tests
    are skipped but verified via Rust tests in interpreter_oop.rs.
    """

    it "dispatches method to context object":
        # Block-scoped context now works!
        class Calculator:
            fn double(self, x):
                return x * 2

        val calc = Calculator {}
        var res = 0
        context calc:
            res = double(21)
        expect res == 42

    it "accesses self fields in context method":
        # Block-scoped context now works!
        class Adder:
            base: i64 = 10

            fn add(self, x):
                return self.base + x

        val a = Adder { base: 30 }
        var res = 0
        context a:
            res = add(12)
        expect res == 42


# ============================================================================
# Test Group 6: Method Missing
# ============================================================================

describe "Method Missing":
    """
    ## Dynamic Method Dispatch via method_missing

    Tests for method_missing which handles calls to undefined methods.
    """

    it "calls method_missing for unknown method":
        class DSL:
            fn method_missing(self, name, args, block):
                return 42

        val d = DSL {}
        expect d.unknown_method() == 42

    it "passes arguments to method_missing":
        class Multiplier:
            factor: i64 = 10

            fn method_missing(self, name, args, block):
                val x = args[0]
                return self.factor * x

        val m = Multiplier { factor: 7 }
        expect m.any_method(6) == 42

    it "uses method_missing in context block":
        # Block-scoped context now works!
        class Counter:
            count: i64 = 0

            fn method_missing(self, name, args, block):
                return 42

        val c = Counter { count: 0 }
        var res = 0
        context c:
            res = something_undefined()
        expect res == 42


# ============================================================================
# Test Group 7: Auto-Forwarding Properties
# ============================================================================

describe "Auto-Forwarding Properties":
    """
    ## Property Getter/Setter Patterns

    Tests for get_/set_/is_ method patterns with backing _field.
    """

    it "gets property via get_ method":
        class Person:
            fn get_name(self) -> str:
                return self._name

        val p = Person { _name: "Alice" }
        var result = 0
        if p.get_name() == "Alice":
            result = 1
        expect result == 1

    it "sets property via set_ method returning new instance":
        class Counter:
            fn get_value(self) -> i64:
                return self._value

            fn set_value(self, v: i64) -> Counter:
                return Counter { _value: v }

        val c = Counter { _value: 10 }
        val c2 = c.set_value(42)
        expect c2.get_value() == 42

    it "checks boolean property via is_ method":
        class Item:
            fn is_active(self) -> bool:
                return self._active

        val item = Item { _active: true }
        var result = 0
        if item.is_active():
            result = 1
        expect result == 1

    it "uses combined getter and setter":
        class Box:
            fn get_content(self) -> i64:
                return self._content

            fn set_content(self, v: i64) -> Box:
                return Box { _content: v }

        val b = Box { _content: 0 }
        val b2 = b.set_content(100)
        expect b2.get_content() == 100


# ============================================================================
# Test Group 8: Static Polymorphism (Interface Bindings)
# ============================================================================

describe "Static Polymorphism":
    """
    ## Interface Bindings with bind Statement

    Tests for static polymorphism where trait bindings enable
    compile-time dispatch to concrete implementations.
    """

    it "binds trait to concrete class":
        trait Logger:
            fn log(self, msg: str) -> str

        class ConsoleLogger:
            fn log(self, msg: str) -> str:
                return "Console: " + msg

        bind Logger = ConsoleLogger

        fn create_logger() -> Logger:
            return ConsoleLogger {}

        val logger: Logger = create_logger()
        val res = logger.log("Hello")
        var result = 0
        if res == "Console: Hello":
            result = 1
        expect result == 1

    it "binds trait with multiple methods":
        trait Calculator:
            fn add(self, a: i64, b: i64) -> i64
            fn multiply(self, a: i64, b: i64) -> i64

        class SimpleCalc:
            fn add(self, a: i64, b: i64) -> i64:
                return a + b
            fn multiply(self, a: i64, b: i64) -> i64:
                return a * b

        bind Calculator = SimpleCalc

        val calc: Calculator = SimpleCalc {}
        expect calc.add(3, 4) + calc.multiply(2, 5) == 17

    it "binds trait with fields":
        trait Counter:
            fn get_value(self) -> i64
            fn increment(self) -> i64

        class SimpleCounter:
            value: i64

            fn get_value(self) -> i64:
                return self.value

            fn increment(self) -> i64:
                return self.value + 1

        bind Counter = SimpleCounter

        val counter: Counter = SimpleCounter { value: 42 }
        expect counter.get_value() == 42

    it "passes bound trait as function parameter":
        trait Greeter:
            fn greet(self, name: str) -> i64

        class FormalGreeter:
            multiplier: i64

            fn greet(self, name: str) -> i64:
                return self.multiplier * 10

        bind Greeter = FormalGreeter

        fn do_greeting(g: Greeter) -> i64:
            return g.greet("Alice")

        val greeter: Greeter = FormalGreeter { multiplier: 5 }
        expect do_greeting(greeter) == 50


# ============================================================================
# Test Group 9: Trait Polymorphism
# ============================================================================

describe "Trait Polymorphism":
    """
    ## Multiple Types Implementing Same Trait

    Tests for polymorphism through trait implementations.
    Note: Block-scoped trait implementations are not yet supported.
    This test is skipped but verified via Rust tests in interpreter_oop.rs.
    """

    it "calculates different areas via Shape trait":
        # Block-scoped impl Trait for Type now works!
        trait Shape:
            fn area(self) -> i64

        struct Square:
            side: i64

        struct Rectangle:
            width: i64
            height: i64

        impl Shape for Square:
            fn area(self) -> i64:
                return self.side * self.side

        impl Shape for Rectangle:
            fn area(self) -> i64:
                return self.width * self.height

        val s = Square { side: 5 }
        val r = Rectangle { width: 4, height: 3 }
        expect s.area() + r.area() == 37
