"""
# Implementation Blocks Specification

**Feature IDs:** #830-835
**Category:** Language
**Difficulty:** 2/5
**Status:** Implemented

## Overview

Implementation blocks (`impl`) provide a flexible way to define methods for types outside
of the type definition. This enables separation of concerns, method organization, and
extension of types in different modules without modifying the original definition.

## Syntax

```simple
# Type definition
struct Point:
    x: i64
    y: i64

# Implementation block
impl Point:
    fn distance_from_origin() -> f64:
        (self.x * self.x + self.y * self.y).sqrt()

    static fn origin() -> Point:
        Point(x: 0, y: 0)
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| Impl Block | Collection of methods for a type |
| Instance Method | Methods that receive self as implicit parameter |
| Static Method | Methods that don't receive self |
| Method Organization | Grouping related behavior in impl blocks |

## Behavior

- Methods in impl blocks are part of the type's interface
- Impl blocks can be placed in any module or location
- Multiple impl blocks for the same type are merged
- Static methods are called with type name prefix
- Instance methods use dot notation on values

## Related Specifications

- [Classes](../classes/classes_spec.spl) - Type definitions
- [Methods](../methods/methods_spec.spl) - Method syntax and semantics
- [Modules](../modules/modules_spec.spl) - Module organization

## Implementation Notes

Implementation blocks are handled at:
- Parser level: impl blocks are collected and associated with types
- Type checking: methods are added to type's method table
- HIR: method calls are resolved through impl blocks
- Codegen: method dispatch uses standard calling convention

## Examples

```simple
# Organization with impl blocks
impl Point:
    # Accessors
    fn get_x() -> i64:
        self.x

    fn get_y() -> i64:
        self.y

    # Transformations
    fn translate(dx: i64, dy: i64) -> Point:
        Point(x: self.x + dx, y: self.y + dy)

    # Factories
    static fn from_tuple(t: (i64, i64)) -> Point:
        Point(x: t.0, y: t.1)
```
"""

import std.spec


# ============================================================================
# Basic Implementation Blocks
# ============================================================================

describe "Implementation Blocks - Basic":
    """
    ## Basic Impl Block Definition and Usage

    Tests basic implementation block syntax and method definition.
    """

    context "with simple impl block":
        """
        ### Scenario: Basic Method Definition

        Methods are defined in impl blocks for types.
        """

        it "defines methods in impl block":
            struct Point:
                x: i64
                y: i64

            impl Point:
                fn get_x() -> i64:
                    self.x

            val p = Point(x: 5, y: 10)
            expect(p.get_x()).to(eq(5))

    context "with multiple methods":
        """
        ### Scenario: Multiple Methods in Impl Block

        Multiple methods can be defined in a single impl block.
        """

        it "defines multiple methods":
            struct Rectangle:
                width: i64
                height: i64

            impl Rectangle:
                fn area() -> i64:
                    self.width * self.height

                fn perimeter() -> i64:
                    2 * (self.width + self.height)

            val r = Rectangle(width: 4, height: 5)
            expect(r.area()).to(eq(20))
            expect(r.perimeter()).to(eq(18))


# ============================================================================
# Static Methods
# ============================================================================

describe "Implementation Blocks - Static Methods":
    """
    ## Static Method Definition

    Tests static methods in implementation blocks.
    """

    context "with static factory methods":
        """
        ### Scenario: Factory Method Pattern

        Static methods create instances with custom initialization.
        """

        it "uses static factory method":
            struct Point:
                x: i64
                y: i64

            impl Point:
                static fn origin() -> Point:
                    Point(x: 0, y: 0)

                static fn from_coords(x: i64, y: i64) -> Point:
                    Point(x: x, y: y)

            val p1 = Point.origin()
            expect(p1.x).to(eq(0))
            expect(p1.y).to(eq(0))

            val p2 = Point.from_coords(3, 4)
            expect(p2.x).to(eq(3))
            expect(p2.y).to(eq(4))

    context "with static utility methods":
        """
        ### Scenario: Static Utilities

        Static methods provide utility functions related to the type.
        """

        it "calls static utility methods":
            class Calculator:
                value: Int

            impl Calculator:
                static fn max(a: Int, b: Int) -> Int:
                    if a > b: a else: b

                static fn min(a: Int, b: Int) -> Int:
                    if a < b: a else: b

            expect(Calculator.max(5, 3)).to(eq(5))
            expect(Calculator.min(5, 3)).to(eq(3))


# ============================================================================
# Instance Methods
# ============================================================================

describe "Implementation Blocks - Instance Methods":
    """
    ## Instance Method Definition

    Tests instance methods that operate on self.
    """

    context "with immutable methods":
        """
        ### Scenario: Read-Only Methods

        Immutable methods don't modify the instance.
        """

        it "defines immutable methods":
            struct Circle:
                radius: f64

            impl Circle:
                fn area() -> f64:
                    3.14159 * self.radius * self.radius

                fn circumference() -> f64:
                    2.0 * 3.14159 * self.radius

            val c = Circle(radius: 5.0)
            # Approximate equality due to floating point
            expect(c.area() > 78.0).to(eq(true))
            expect(c.circumference() > 31.0).to(eq(true))

    context "with mutable methods":
        """
        ### Scenario: State-Modifying Methods

        Mutable methods can modify the instance.
        """

        it "defines mutable methods":
            class Counter:
                count: Int

            impl Counter:
                me increment():
                    self.count = self.count + 1

                me decrement():
                    self.count = self.count - 1

            val c = Counter(count: 0)
            c.increment()
            expect(c.count).to(eq(1))
            c.decrement()
            expect(c.count).to(eq(0))


# ============================================================================
# Multiple Implementation Blocks
# ============================================================================

describe "Implementation Blocks - Multiple Blocks":
    """
    ## Multiple Impl Blocks for Same Type

    Tests defining multiple implementation blocks for a single type.
    """

    context "with separate impl blocks":
        """
        ### Scenario: Block Organization

        Methods can be organized into multiple impl blocks by concern.
        """

        it "organizes methods in multiple blocks":
            struct Person:
                name: text
                age: Int

            impl Person:
                fn get_name() -> text:
                    self.name

            impl Person:
                fn get_age() -> Int:
                    self.age

            impl Person:
                static fn create(name: text, age: Int) -> Person:
                    Person(name: name, age: age)

            val p = Person.create("Alice", 30)
            expect(p.get_name()).to(eq("Alice"))
            expect(p.get_age()).to(eq(30))

    context "with mixed static and instance":
        """
        ### Scenario: Mixed Method Types

        Impl blocks can contain both static and instance methods.
        """

        it "mixes static and instance methods":
            struct Temperature:
                celsius: f64

            impl Temperature:
                static fn from_fahrenheit(f: f64) -> Temperature:
                    Temperature(celsius: (f - 32.0) * 5.0 / 9.0)

                fn to_fahrenheit() -> f64:
                    self.celsius * 9.0 / 5.0 + 32.0

            val t = Temperature.from_fahrenheit(32.0)
            # Approximately 0 celsius
            expect(t.celsius > -1.0 and t.celsius < 1.0).to(eq(true))


# ============================================================================
# Method Chaining
# ============================================================================

describe "Implementation Blocks - Method Chaining":
    """
    ## Method Chaining with Impl Blocks

    Tests method chaining patterns in impl blocks.
    """

    context "with chainable methods":
        """
        ### Scenario: Fluent Interface

        Methods return self for chaining.
        """

        it "supports method chaining":
            class Builder:
                data: text

            impl Builder:
                me add_part(part: text) -> Builder:
                    self.data = self.data + part
                    self

                me uppercase():
                    self.data = self.data.uppercase()
                    self

            val result = Builder(data: "")
                .add_part("hello")
                .add_part(" world")
                .uppercase()

            expect(result.data).to(eq("HELLO WORLD"))


# ============================================================================
# Edge Cases
# ============================================================================

describe "Implementation Blocks - Edge Cases":
    """
    ## Edge Case Handling

    Tests edge cases and special scenarios with impl blocks.
    """

    context "with generic types":
        """
        ### Scenario: Generic Type Implementation

        Impl blocks can define methods for generic types.
        """

        it "implements methods for generic types":
            struct Container<T>:
                value: T

            impl Container<Int>:
                fn double() -> Int:
                    self.value * 2

            val c = Container<Int>(value: 5)
            expect(c.double()).to(eq(10))

    context "with nested types":
        """
        ### Scenario: Nested Type Methods

        Types can have nested implementations.
        """

        it "defines methods for nested types":
            struct Outer:
                value: Int

            impl Outer:
                fn get_value() -> Int:
                    self.value

            val o = Outer(value: 42)
            expect(o.get_value()).to(eq(42))


# ============================================================================
# Helper Functions
# ============================================================================

# Placeholder for impl block test helpers
