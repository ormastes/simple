# @pending
"""
# Generator State Machine Codegen Specification

**Feature IDs:** #800-805
**Category:** Codegen
**Difficulty:** 4/5
**Status:** In Progress

## Overview

Generator state machine codegen provides optimized code generation for generator functions
that implement explicit state machines. This feature enables low-overhead coroutine semantics
with fine-grained control over state transitions and stack frame management.

## Syntax

```simple
# Generator with explicit state machine
gen fibonacci() -> Int:
    var a = 0
    var b = 1

    loop:
        yield a
        val temp = a + b
        a = b
        b = temp
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| State Machine | Explicit representation of generator execution state |
| Yield Point | Location where generator suspends and resumes |
| Stack Frame | Preserved local state between yield points |
| Codegen Optimization | Direct state machine compilation without trampolining |

## Behavior

- Generator functions compile to explicit state machine data structures
- Each yield point corresponds to a state transition
- Local variables preserved across yield points in the state frame
- Type-safe state representation with discriminant unions
- Zero-copy variable capture where possible

## Related Specifications

- [Generators](../generators/generators_spec.spl) - Generator syntax and semantics
- [Coroutines](../coroutines/coroutines_spec.spl) - Coroutine implementation
- [Memory Management](../memory_management/memory_management_spec.spl) - Stack frame management

## Implementation Notes

State machine codegen targets:
- Direct MIR emission for state transitions
- Optimized codegen for single-yield common case
- Frame layout analyzed for memory efficiency
- Stack allocation preferred over heap when possible

## Examples

```simple
# Simple state machine generator
gen counter(max: Int) -> Int:
    var i = 0
    loop:
        if i >= max:
            break
        yield i
        i = i + 1
```
"""



# ============================================================================
# Basic Generator State Machine
# ============================================================================

describe "Generator State Machine - Basic":
    """
    ## Basic State Machine Compilation

    Tests basic generator state machine compilation and execution.
    """

    context "with simple sequential yields":
        """
        ### Scenario: Linear Generator Execution

        A generator with sequential yield points compiles to a linear state machine.
        """

        it "executes basic generator":
            gen simple_gen() -> Int:
                yield 1
                yield 2
                yield 3

            val g = simple_gen()
            expect(g()).to_equal(1)
            expect(g()).to_equal(2)
            expect(g()).to_equal(3)

    context "with local variable preservation":
        """
        ### Scenario: State Frame Variables

        Local variables are preserved across yield points in the state frame.
        """

        it "preserves local state across yields":
            gen counter(limit: Int) -> Int:
                var i = 0
                loop:
                    if i >= limit:
                        break
                    yield i
                    i = i + 1

            val g = counter(3)
            expect(g()).to_equal(0)
            expect(g()).to_equal(1)
            expect(g()).to_equal(2)


# ============================================================================
# State Machine Transitions
# ============================================================================

describe "Generator State Machine - Transitions":
    """
    ## State Transition Handling

    Tests proper handling of state transitions and branching.
    """

    context "with conditional branching":
        """
        ### Scenario: Branched State Paths

        Generators with conditional logic create branched state paths.
        """

        it "handles branched execution paths":
            gen branched(mode: Bool) -> Int:
                if mode:
                    yield 1
                    yield 2
                else:
                    yield 10
                    yield 20

            val g1 = branched(true)
            expect(g1()).to_equal(1)
            expect(g1()).to_equal(2)

            val g2 = branched(false)
            expect(g2()).to_equal(10)
            expect(g2()).to_equal(20)

    context "with loop state machines":
        """
        ### Scenario: Loop-Based Generators

        Loop constructs create loop-based state machines with state transitions.
        """

        it "compiles loop-based generator":
            gen loop_gen(count: Int) -> Int:
                var i = 0
                loop:
                    if i >= count:
                        break
                    yield i * 2
                    i = i + 1

            val g = loop_gen(3)
            expect(g()).to_equal(0)
            expect(g()).to_equal(2)
            expect(g()).to_equal(4)


# ============================================================================
# Stack Frame Management
# ============================================================================

describe "Generator State Machine - Stack Frames":
    """
    ## Stack Frame Layout and Management

    Tests stack frame allocation and variable preservation.
    """

    context "with multiple local variables":
        """
        ### Scenario: Complex State Frame

        Multiple local variables create complex state frame layouts.
        """

        it "allocates correct frame layout":
            gen multi_var() -> Int:
                var a = 1
                var b = 2
                var c = 3
                yield a + b
                yield b + c
                yield a + c

            val g = multi_var()
            expect(g()).to_equal(3))  # 1 + 2
            expect(g()).to_equal(5))  # 2 + 3
            expect(g()).to_equal(4))  # 1 + 3

    context "with captured parameters":
        """
        ### Scenario: Parameter Capture in Frame

        Function parameters are captured in the state frame.
        """

        it "captures parameters in frame":
            gen param_gen(x: Int, y: Int) -> Int:
                yield x
                yield y
                yield x + y

            val g = param_gen(5, 3)
            expect(g()).to_equal(5)
            expect(g()).to_equal(3)
            expect(g()).to_equal(8)


# ============================================================================
# Edge Cases
# ============================================================================

describe "Generator State Machine - Edge Cases":
    """
    ## Edge Case Handling

    Tests edge cases and special scenarios in state machine codegen.
    """

    context "with single yield":
        """
        ### Scenario: Trivial Generator

        Single-yield generators are optimized as special case.
        """

        it "handles single-yield optimization":
            gen single_yield() -> Int:
                yield 42

            val g = single_yield()
            expect(g()).to_equal(42)

    context "with nested loops":
        """
        ### Scenario: Nested Loop State Machine

        Nested loops create multi-level state machines.
        """

        it "compiles nested loop generator":
            gen nested_loops(n: Int) -> Int:
                var i = 0
                loop:
                    if i >= n:
                        break
                    var j = 0
                    loop:
                        if j >= 2:
                            break
                        yield i * 10 + j
                        j = j + 1
                    i = i + 1

            val g = nested_loops(2)
            expect(g()).to_equal(0)
            expect(g()).to_equal(1)
            expect(g()).to_equal(10)
            expect(g()).to_equal(11)


# ============================================================================
# Helper Functions
# ============================================================================

# Placeholder for any test helper functions as needed
