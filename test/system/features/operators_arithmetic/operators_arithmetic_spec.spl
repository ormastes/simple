# @pending
# @skip - Uses unsupported keyword: with
"""
# Arithmetic Operators Specification

**Feature IDs:** #100-110
**Category:** Syntax
**Difficulty:** 2/5
**Status:** Implemented

## Overview

Arithmetic operators in Simple provide standard mathematical operations on numeric types
(Int and Float). The language supports binary operators (+, -, *, /, %, **, //), unary
negation (-), automatic type coercion between Int and Float, and special behaviors for
strings and arrays.

## Syntax

### Binary Operators

```simple
val sum = 2 + 3           # Addition: 5
val diff = 10 - 4         # Subtraction: 6
val product = 4 * 5       # Multiplication: 20
val quotient = 20 / 4     # Division: 5
val remainder = 17 % 5    # Modulo: 2
val power = 2 ** 8        # Exponentiation: 256
val floor_div = 17.fdiv(5) # Floor division: 3 (// is now parallel operator)
```

### Unary Operators

```simple
val neg = -42             # Negation: -42
val pos_to_neg = -(5 + 3) # Negate expression: -8
```

### Operator Precedence

```simple
2 + 3 * 4         # 14 (multiplication before addition)
(2 + 3) * 4       # 20 (parentheses override)
2 ** 3 ** 2       # 512 (right-associative: 2 ** (3 ** 2)
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| Binary Operators | Operators requiring two operands (+, -, *, /, %, **, //) |
| Unary Operators | Operators requiring one operand (-) |
| Precedence | Order of evaluation (** > *, /, %, // > +, -) |
| Associativity | Left-to-right except ** (right-to-left) |
| Type Coercion | Int + Float automatically promotes to Float |

## Behavior

- **Addition (+)**: Works on Int, Float, String (concatenation), Array (concatenation)
- **Subtraction (-)**: Works on Int, Float
- **Multiplication (*)**: Works on Int, Float, String repetition (String * Int)
- **Division (/)**: Always returns numeric result, errors on division by zero
- **Modulo (%)**: Integer remainder, errors on modulo by zero
- **Exponentiation (**)**: Power operator, right-associative, no negative Int exponents
- **Floor Division (//)**: Euclidean division, rounds toward negative infinity
- **Negation (-)**: Unary minus, negates numeric values

## Related Specifications

- [Type Inference](../type_inference/type_inference_spec.md) - Type deduction for expressions
- [Comparison Operators](../operators_comparison/operators_comparison_spec.md) - Relational operators
- [Bitwise Operators](../operators_bitwise/operators_bitwise_spec.md) - Bit manipulation

## Implementation Notes

**Parser:** `src/parser/src/expressions/binary.rs`
- Precedence climbing algorithm
- Right-associativity for exponentiation

**Interpreter:** `src/compiler/src/interpreter/expr/ops.rs`
- Runtime evaluation with type coercion
- Error handling for division by zero
- Special handling for String and Array types

**Performance:** Most operations compile to native CPU instructions. Type coercion adds
minimal overhead (single conversion per mixed-type expression).

## Examples

```simple
# Basic arithmetic
val x = 10 + 20          # 30
val y = 100 - 25         # 75
val z = 6 * 7            # 42

# Type coercion
val mixed = 10 + 3.5     # 13.5 (Int promoted to Float)
val result = 2.0 * 5     # 10.0 (Int promoted to Float)

# String operations
val greeting = "Hello" + " " + "World"  # "Hello World"
val repeated = "x" * 5                  # "xxxxx"

# Exponentiation
val squared = 5 ** 2     # 25
val cubed = 2 ** 3       # 8
```
"""



# ============================================================================
# Addition Operator (+)
# ============================================================================

describe "Arithmetic Operators - Addition":
    """
    ## Addition Operator (+)

    The addition operator performs numeric addition on Int and Float types,
    with automatic type promotion when mixing types.
    """

    context "with integers":
        """
        ### Scenario: Integer Addition

        Adding two integers produces an integer result.

        ```simple
        val sum = 2 + 3  # 5
        ```
        """

        it "adds positive integers":
            val result = 2 + 3
            expect(result).to_equal(5)

        it "adds negative integers":
            val result = -5 + (-3)
            expect(result).to_equal(-8)

        it "adds zero":
            val result = 42 + 0
            expect(result).to_equal(42)

        it "adds large integers":
            val result = 1000 + 2000
            expect(result).to_equal(3000)

    context "with floats":
        """
        ### Scenario: Float Addition

        Adding two floats produces a float result.

        ```simple
        val sum = 2.5 + 3.5  # 6.0
        ```
        """

        it "adds positive floats":
            val result = 2.5 + 3.5
            expect(result).to_equal(6.0)

        it "adds negative floats":
            val result = -1.5 + (-2.5)
            expect(result).to_equal(-4.0)

    context "with mixed types":
        """
        ### Scenario: Mixed Type Addition

        Adding Int and Float promotes Int to Float.

        ```simple
        val sum = 10 + 3.5  # 13.5 (Float)
        ```
        """

        it "promotes int to float (int + float)":
            val result = 10 + 3.5
            expect(result).to_equal(13.5)

        it "promotes int to float (float + int)":
            val result = 2.5 + 7
            expect(result).to_equal(9.5)


# ============================================================================
# Subtraction Operator (-)
# ============================================================================

describe "Arithmetic Operators - Subtraction":
    """
    ## Subtraction Operator (-)

    The subtraction operator performs numeric subtraction on Int and Float types.
    """

    context "with integers":
        """
        ### Scenario: Integer Subtraction

        Subtracting two integers produces an integer result.

        ```simple
        val diff = 10 - 3  # 7
        ```
        """

        it "subtracts positive integers":
            val result = 10 - 3
            expect(result).to_equal(7)

        it "subtracts resulting in negative":
            val result = 3 - 10
            expect(result).to_equal(-7)

        it "subtracts zero":
            val result = 42 - 0
            expect(result).to_equal(42)

    context "with floats":
        """
        ### Scenario: Float Subtraction

        Subtracting two floats produces a float result.
        """

        it "subtracts positive floats":
            val result = 10.5 - 3.2
            expect(result).to_equal(7.3)

    context "with mixed types":
        """
        ### Scenario: Mixed Type Subtraction

        Subtracting Int and Float promotes Int to Float.
        """

        it "promotes int to float (int - float)":
            val result = 10 - 2.5
            expect(result).to_equal(7.5)

        it "promotes int to float (float - int)":
            val result = 10.5 - 3
            expect(result).to_equal(7.5)


# ============================================================================
# Multiplication Operator (*)
# ============================================================================

describe "Arithmetic Operators - Multiplication":
    """
    ## Multiplication Operator (*)

    The multiplication operator performs numeric multiplication on Int and Float types.
    """

    context "with integers":
        """
        ### Scenario: Integer Multiplication

        Multiplying two integers produces an integer result.

        ```simple
        val product = 4 * 5  # 20
        ```
        """

        it "multiplies positive integers":
            val result = 4 * 5
            expect(result).to_equal(20)

        it "multiplies by zero":
            val result = 42 * 0
            expect(result == 0).to_equal(true)

        it "multiplies by one":
            val result = 42 * 1
            expect(result).to_equal(42)

        it "multiplies negative numbers":
            val result = -3 * 4
            expect(result).to_equal(-12)

        it "multiplies two negatives":
            val result = -3 * -4
            expect(result).to_equal(12)

    context "with floats":
        """
        ### Scenario: Float Multiplication

        Multiplying two floats produces a float result.
        """

        it "multiplies positive floats":
            val result = 2.5 * 4.0
            expect(result).to_equal(10.0)

    context "with mixed types":
        """
        ### Scenario: Mixed Type Multiplication

        Multiplying Int and Float promotes Int to Float.
        """

        it "promotes int to float (int * float)":
            val result = 5 * 2.5
            expect(result).to_equal(12.5)

        it "promotes int to float (float * int)":
            val result = 3.5 * 2
            expect(result).to_equal(7.0)


# ============================================================================
# Division Operator (/)
# ============================================================================

describe "Arithmetic Operators - Division":
    """
    ## Division Operator (/)

    The division operator performs numeric division on Int and Float types.
    Division by zero produces an error.
    """

    context "with integers":
        """
        ### Scenario: Integer Division

        Dividing two integers produces a numeric result.

        ```simple
        val quotient = 20 / 4  # 5
        ```
        """

        it "divides evenly":
            val result = 20 / 4
            expect(result).to_equal(5)

        it "divides with remainder":
            val result = 17 / 5
            expect(result).to_equal(3)

        it "divides one by itself":
            val result = 42 / 42
            expect(result).to_equal(1)

    context "with floats":
        """
        ### Scenario: Float Division

        Dividing floats produces a float result.
        """

        it "divides floats":
            val result = 10.0 / 4.0
            expect(result).to_equal(2.5)

    context "with mixed types":
        """
        ### Scenario: Mixed Type Division

        Dividing Int and Float promotes Int to Float.
        """

        it "promotes int to float (int / float)":
            val result = 10 / 4.0
            expect(result).to_equal(2.5)

        it "promotes int to float (float / int)":
            val result = 10.0 / 4
            expect(result).to_equal(2.5)


# ============================================================================
# Modulo Operator (%)
# ============================================================================

describe "Arithmetic Operators - Modulo":
    """
    ## Modulo Operator (%)

    The modulo operator computes the remainder of integer division.
    """

    context "with positive integers":
        """
        ### Scenario: Positive Integer Modulo

        Modulo with positive integers returns the remainder.

        ```simple
        val remainder = 17 % 5  # 2
        ```
        """

        it "computes remainder":
            val result = 17 % 5
            expect(result).to_equal(2)

        it "returns zero for even division":
            val result = 20 % 4
            expect(result == 0).to_equal(true)

        it "returns operand when divisor is larger":
            val result = 3 % 5
            expect(result).to_equal(3)

    context "with negative integers":
        """
        ### Scenario: Negative Integer Modulo

        Modulo with negative integers follows language semantics.
        """

        it "handles negative dividend":
            val result = -17 % 5
            expect(result).to_equal(-2)

        it "handles negative divisor":
            val result = 17 % -5
            expect(result).to_equal(2)


# ============================================================================
# Exponentiation Operator (**)
# ============================================================================

describe "Arithmetic Operators - Exponentiation":
    """
    ## Exponentiation Operator (**)

    The exponentiation operator raises a number to a power.
    Right-associative: 2 ** 3 ** 2 means 2 ** (3 ** 2).
    """

    context "with integers":
        """
        ### Scenario: Integer Exponentiation

        Raising an integer to an integer power.

        ```simple
        val squared = 5 ** 2  # 25
        ```
        """

        it "computes square":
            val result = 5 ** 2
            expect(result).to_equal(25)

        it "computes cube":
            val result = 2 ** 3
            expect(result).to_equal(8)

        it "computes power of zero":
            val result = 42 ** 0
            expect(result).to_equal(1)

        it "computes power of one":
            val result = 42 ** 1
            expect(result).to_equal(42)

    context "with floats":
        """
        ### Scenario: Float Exponentiation

        Raising floats to powers.
        """

        it "computes float power":
            val result = 2.0 ** 3.0
            expect(result).to_equal(8.0)

    context "with right associativity":
        """
        ### Scenario: Right Associativity

        Exponentiation is right-associative.

        ```simple
        2 ** 3 ** 2  # 2 ** (3 ** 2) = 2 ** 9 = 512
        ```
        """

        it "evaluates right to left":
            val result = 2 ** 3 ** 2
            expect(result).to_equal(512)


# ============================================================================
# Floor Division Operator (//)
# ============================================================================

describe "Arithmetic Operators - Floor Division":
    """
    ## Floor Division Operator (//)

    Floor division divides and rounds toward negative infinity.
    Uses Euclidean division semantics.
    """

    context "with positive integers":
        """
        ### Scenario: Positive Floor Division

        Floor division with positive integers.

        ```simple
        val result = 17 // 5  # 3
        ```
        """

        it "divides and floors":
            val result = 17.fdiv(5)
            expect(result).to_equal(3)

        it "returns exact result for even division":
            val result = 20.fdiv(4)
            expect(result).to_equal(5)


# ============================================================================
# Unary Negation (-)
# ============================================================================

describe "Arithmetic Operators - Unary Negation":
    """
    ## Unary Negation Operator (-)

    The unary minus operator negates a numeric value.
    """

    context "with integers":
        """
        ### Scenario: Integer Negation

        Negating an integer produces its opposite.

        ```simple
        val neg = -42  # -42
        ```
        """

        it "negates positive integer":
            val result = -42
            expect(result).to_equal(-42)

        it "negates negative integer":
            val x = -42
            val result = -x
            expect(result).to_equal(42)

        it "negates zero":
            val result = -0
            expect(result == 0).to_equal(true)

    context "with floats":
        """
        ### Scenario: Float Negation

        Negating a float produces its opposite.
        """

        it "negates positive float":
            val result = -3.5
            expect(result).to_equal(-3.5)

    context "with expressions":
        """
        ### Scenario: Expression Negation

        Negating an expression.

        ```simple
        val neg = -(5 + 3)  # -8
        ```
        """

        it "negates expression result":
            val result = -(5 + 3)
            expect(result).to_equal(-8)


# ============================================================================
# Operator Precedence
# ============================================================================

describe "Arithmetic Operators - Precedence":
    """
    ## Operator Precedence

    Operators are evaluated in precedence order:
    1. ** (exponentiation)
    2. *, /, % (multiplication, division, modulo)
    3. +, - (addition, subtraction)

    Note: Floor division is now a method (.fdiv), not an operator.
    The // operator is now used for parallel execution.
    """

    context "multiplication before addition":
        """
        ### Scenario: Multiplication Precedence

        Multiplication has higher precedence than addition.

        ```simple
        2 + 3 * 4  # 14, not 20
        ```
        """

        it "evaluates multiplication first":
            val result = 2 + 3 * 4
            expect(result).to_equal(14)

        it "uses parentheses to override":
            val result = (2 + 3) * 4
            expect(result).to_equal(20)

    context "exponentiation before multiplication":
        """
        ### Scenario: Exponentiation Precedence

        Exponentiation has higher precedence than multiplication.

        ```simple
        2 * 3 ** 2  # 18, not 36
        ```
        """

        it "evaluates exponentiation first":
            val result = 2 * 3 ** 2
            expect(result).to_equal(18)

        it "uses parentheses to override":
            val result = (2 * 3) ** 2
            expect(result).to_equal(36)

    context "complex expressions":
        """
        ### Scenario: Complex Precedence

        Multiple operators with different precedence.
        """

        it "evaluates complex expression correctly":
            val result = 2 + 3 * 4 - 5
            expect(result).to_equal(9)

        it "evaluates with division":
            val result = 20 / 4 + 3 * 2
            expect(result).to_equal(11)


# ============================================================================
# Type Coercion
# ============================================================================

describe "Arithmetic Operators - Type Coercion":
    """
    ## Automatic Type Coercion

    When mixing Int and Float in arithmetic operations, Int is automatically
    promoted to Float, and the result is Float.
    """

    context "in complex expressions":
        """
        ### Scenario: Mixed Type Expressions

        Complex expressions with mixed Int and Float types.
        """

        it "promotes in nested expressions":
            val result = 10 + 5 * 2.0
            expect(result).to_equal(20.0)

        it "promotes across multiple operations":
            val result = 1 + 2 + 3.0
            expect(result).to_equal(6.0)


# ============================================================================
# Edge Cases
# ============================================================================

describe "Arithmetic Operators - Edge Cases":
    """
    ## Edge Case Handling

    Tests for special cases and boundaries.
    """

    context "with zero":
        """
        ### Scenario: Operations with Zero

        Zero has special properties in arithmetic.
        """

        it "multiplies by zero":
            val result = 42 * 0
            expect(result == 0).to_equal(true)

        it "adds zero (identity)":
            val result = 42 + 0
            expect(result).to_equal(42)

    context "with one":
        """
        ### Scenario: Operations with One

        One is the multiplicative identity.
        """

        it "multiplies by one":
            val result = 42 * 1
            expect(result).to_equal(42)

        it "divides by one":
            val result = 42 / 1
            expect(result).to_equal(42)

        it "raises to power of zero":
            val result = 42 ** 0
            expect(result).to_equal(1)
