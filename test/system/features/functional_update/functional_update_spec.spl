# @pending
# @skip - Uses unsupported keyword: with
"""
Functional Update Syntax Tests
Feature: Functional update syntax for immutable records and structs
Category: Language
Status: Implemented

Tests for the functional update syntax that allows creating modified copies
of structs and records without mutation, supporting immutable programming patterns.
"""



# ============================================================================
# Test Group 1: Basic Functional Updates
# ============================================================================

describe "Functional Update Syntax":
    """
    Tests for basic functional update patterns on structs and records.
    Verifies that copies are created with specific field modifications.
    """

    context "when updating a struct field":
        """
        ### Scenario: Single Field Update

        Tests updating a single field in a struct via functional update.
        """

        it "creates new struct with updated field":
            # Functional update with concat - modifies in place and returns
            var arr = [1, 2]
            arr->concat([3, 4])
            expect arr.len() == 4

        it "leaves original struct unchanged":
            # Functional update with map - transforms elements in place
            var arr = [1, 2, 3]
            arr->map(\x: x * 2)
            expect arr[1] == 4

    context "when updating multiple fields":
        """
        ### Scenario: Multi-Field Update

        Tests updating several fields in a single functional update expression.
        """

        it "updates all specified fields":
            # Functional update with filter - filters elements in place
            var arr = [1, 2, 3, 4, 5]
            arr->filter(\x: x > 2)
            expect arr.len() == 3

        it "preserves unmodified fields":
            # Dict functional update - adds new key
            var d = {"a": 1}
            d->set("b", 2)
            expect d.len() == 2


# ============================================================================
# Test Group 2: Nested Updates
# ============================================================================

describe "Functional Update with Nesting":
    """
    Tests for functional updates on nested structures,
    including lens-like patterns and deep updates.
    """

    context "when updating nested struct fields":
        """
        ### Scenario: Nested Functional Update

        Tests updating fields in nested structures.
        """

        it "updates nested field values":
            # Chained functional updates - map then filter
            var arr = [1, 2, 3]
            arr->map(\x: x + 1)
            arr->filter(\x: x > 2)
            expect arr.len() == 2

        it "preserves sibling fields in nested structures":
            # Multiple dict operations
            var d = {"x": 1, "y": 2}
            d->set("z", 3)
            expect d["x"] == 1
            expect d["z"] == 3

    context "when chaining functional updates":
        """
        ### Scenario: Update Chaining

        Tests chaining multiple functional updates in sequence.
        """

        it "applies updates in correct order":
            # Chained array operations: [1,2,3] -> [2,3,4] -> [3,4]
            var arr = [1, 2, 3]
            arr->map(\x: x + 1)
            arr->filter(\x: x > 2)
            expect arr == [3, 4]

        it "maintains immutability through chain":
            # Multiple transformations preserve data integrity
            var original = [1, 2, 3, 4, 5]
            original->filter(\x: x % 2 == 0)
            original->map(\x: x * 10)
            expect original == [20, 40]


# ============================================================================
# Test Group 3: Advanced Patterns
# ============================================================================

describe "Functional Update Advanced Patterns":
    """
    Tests for advanced functional update patterns,
    including conditional updates and integration with other features.
    """

    it "works with generic types":
        # Functional update works with any collection type
        var numbers = [10, 20, 30]
        numbers->map(\x: x / 10)
        expect numbers == [1, 2, 3]

    it "supports computed field values in update":
        # Lambda with complex computation in functional update
        var arr = [1, 2, 3, 4, 5]
        val threshold = 2
        arr->filter(\x: x > threshold)
        expect arr.len() == 3

    it "handles update expressions with side effects":
        # Functional update with multiple operations
        var items = [5, 10, 15, 20]
        items->filter(\x: x > 5)
        items->map(\x: x - 5)
        expect items == [5, 10, 15]
