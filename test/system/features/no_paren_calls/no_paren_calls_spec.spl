# @pending
"""
# No-Parentheses Function Calls Specification

**Feature IDs:** #300-310
**Category:** Syntax
**Difficulty:** 2/5
**Status:** Implemented

## Overview

No-parentheses function calls allow calling functions without wrapping arguments in parentheses,
providing Ruby-style syntax for cleaner, more readable code. This feature supports simple function
calls, trailing lambdas, colon-blocks, and works with identifiers, field access, and path expressions.

## Syntax

### Basic No-Paren Calls

```simple
print "Hello"              # print("Hello")
val result = add 2, 3      # val result = add(2, 3)
```

### With Field Access

```simple
obj.method arg             # obj.method(arg)
```

### With Trailing Lambdas

```simple
map numbers \x: x * 2      # map(numbers, \x: x * 2)
```

### With Colon-Blocks

```simple
describe "Feature":
    test code
# describe("Feature", fn(): test code)
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| No-Paren Call | Function call without wrapping arguments in `()` |
| Callable Expression | Identifier, field access, or path that can be called |
| Trailing Lambda | Lambda with `\` syntax as final argument |
| Colon-Block | Indented block after `:` becomes lambda argument |
| Comma Required | Arguments must be separated by commas in Normal mode |

## Behavior

- **Callable expressions**: Only identifiers, field access (`obj.method`), and paths (`Module.func`)
- **Comma-separated**: Multiple arguments require commas in Normal mode
- **Trailing lambda**: Backslash syntax (`\params: body`) can append lambda
- **Colon-block**: `:` followed by indent creates lambda argument
- **No nesting**: Strict mode disallows nested no-paren calls
- **Statement level**: Works at statement level, not within complex expressions

## Related Specifications

- [Trailing Blocks](../trailing_blocks/trailing_blocks_spec.md) - Lambda syntax with backslash
- [Functions](../functions/functions_spec.md) - Function definition and calling
- [Lambdas/Closures](../lambdas_closures/lambdas_closures_spec.md) - Lambda expressions

## Implementation Notes

**Parser:** `src/parser/src/expressions/no_paren.rs`
- `parse_with_no_paren_calls()` - Main entry point
- `is_callable_expr()` - Determines if expression can start no-paren call
- `can_start_argument()` - Checks if token can begin an argument

**Modes:**
- **Normal**: Default, allows nesting (may be ambiguous)
- **Strict**: GPU mode, disallows nested no-paren calls

**Performance:** No-paren calls desugar to regular calls during parsing - zero runtime overhead.

## Examples

```simple
# Basic calls
print "Hello World"
val sum = add 5, 10

# With field access
list.each item

# With trailing lambda
map items \x: x * 2
filter values \v: v > 0

# With colon-block
describe "Test":
    it "works":
        expect(true).to_equal(true))

# Multiple arguments
call arg1, arg2, arg3
```
"""



# ============================================================================
# Basic No-Paren Calls
# ============================================================================

describe "No-Paren Calls - Basic Syntax":
    """
    ## Basic No-Paren Call Syntax

    Functions can be called without parentheses, with arguments separated by commas.
    """

    context "with single argument":
        """
        ### Scenario: Single Argument

        Function with one argument can omit parentheses.

        ```simple
        fn double(x):
            x * 2

        val result = double 5  # double(5)
        ```
        """

        it "calls function with single argument":
            fn double(x):
                x * 2

            val result = double 5
            expect(result).to_equal(10))

        it "calls with literal argument":
            fn identity(x):
                x

            val result = identity 42
            expect(result).to_equal(42))

        it "calls with identifier argument":
            fn identity(x):
                x

            val value = 100
            val result = identity value
            expect(result).to_equal(100))

    context "with multiple arguments":
        """
        ### Scenario: Multiple Arguments

        Multiple arguments require comma separation.

        ```simple
        fn add(a, b):
            a + b

        val sum = add 10, 20  # add(10, 20)
        ```
        """

        it "calls with two arguments":
            fn add(a, b):
                a + b

            val result = add(10, 20)
            expect(result).to_equal(30))

        it "calls with three arguments":
            fn add3(a, b, c):
                a + b + c

            val result = add3(5, 10, 15)
            expect(result).to_equal(30))

        it "mixes literals and identifiers":
            fn multiply(a, b):
                a * b

            val factor = 5
            val result = multiply(factor, 3)
            expect(result).to_equal(15))


# ============================================================================
# Argument Types
# ============================================================================

describe "No-Paren Calls - Argument Types":
    """
    ## Different Argument Types

    No-paren calls support various argument types: literals, identifiers, expressions.
    """

    context "with literals":
        """
        ### Scenario: Literal Arguments

        Integer, float, string, and boolean literals as arguments.

        ```simple
        func 42                 # Integer
        func 3.14               # Float
        func "text"             # String
        func true               # Boolean
        ```
        """

        it "passes integer literal":
            fn identity(x):
                x

            val result = identity 42
            expect(result).to_equal(42))

        it "passes string literal":
            fn identity(x):
                x

            val result = identity "hello"
            expect(result).to_equal("hello"))

        it "passes boolean literal":
            fn identity(x):
                x

            val result = identity true
            expect(result).to_equal(true))

    context "with parenthesized expressions":
        """
        ### Scenario: Parenthesized Expressions

        Complex expressions can be wrapped in parentheses.

        ```simple
        func (a + b), (c * d)
        ```
        """

        it "passes arithmetic expression":
            fn square(x):
                x * x

            val result = square (3 + 2)
            expect(result).to_equal(25))

        it "passes multiple expressions":
            fn add(a, b):
                a + b

            val result = add((2 * 3), (4 + 5))
            expect(result).to_equal(15))


# ============================================================================
# Nested Function Calls
# ============================================================================

describe "No-Paren Calls - Nested Calls":
    """
    ## Nested Function Calls

    Mixing parenthesized and no-paren calls.
    """

    context "with inner parenthesized calls":
        """
        ### Scenario: Inner Calls with Parens

        Inner calls use parentheses, outer call uses no-paren syntax.

        ```simple
        outer inner(arg)
        ```
        """

        it "nests parenthesized call":
            fn double(x):
                x * 2

            fn triple(x):
                x * 3

            val result = double triple(5)
            expect(result).to_equal(30))

        it "chains multiple functions":
            fn add1(x):
                x + 1

            fn add2(x):
                x + 2

            val result = add1 add2(10)
            expect(result).to_equal(13))


# ============================================================================
# Trailing Lambdas
# ============================================================================

describe "No-Paren Calls - Trailing Lambdas":
    """
    ## Trailing Lambdas with No-Paren Calls

    Lambda with backslash syntax can be the final argument.
    """

    context "with single argument plus lambda":
        """
        ### Scenario: Argument Plus Trailing Lambda

        Combine regular argument with trailing lambda.

        ```simple
        map array \x: x * 2
        ```
        """

        it "accepts trailing lambda":
            fn apply(x, f):
                f(x)

            val result = apply 5 \n: n * 2
            expect(result).to_equal(10))

        it "passes multiple args plus lambda":
            fn fold(arr, init, f):
                var acc = init
                var i = 0
                while i < arr.len():
                    acc = f(acc, arr[i])
                    i = i + 1
                acc

            val nums = [1, 2, 3]
            val sum = fold(nums, 0) \acc, x: acc + x
            expect(sum).to_equal(6))


# ============================================================================
# Method Calls
# ============================================================================

describe "No-Paren Calls - Method Calls":
    """
    ## Method Calls with No-Paren Syntax

    Methods accessed via field access can use no-paren syntax.
    """

    context "with method calls":
        """
        ### Scenario: Method Call Syntax

        Methods can be called without parentheses.

        ```simple
        obj.method arg
        ```
        """

        it "uses no-paren with helper function":
            fn get_double_func():
                fn inner(x):
                    x * 2
                inner

            val double_func = get_double_func()
            val result = double_func 21
            expect(result).to_equal(42))


# ============================================================================
# Expression vs Statement Context
# ============================================================================

describe "No-Paren Calls - Context":
    """
    ## Statement vs Expression Context

    No-paren calls work at statement level and in assignments.
    """

    context "in assignments":
        """
        ### Scenario: Assignment Context

        No-paren calls on right side of assignments.

        ```simple
        val result = func arg
        ```
        """

        it "works in val assignments":
            fn double(x):
                x * 2

            val result = double 10
            expect(result).to_equal(20))

        it "works in var assignments":
            fn add(a, b):
                a + b

            var result = add(5, 7)
            expect(result).to_equal(12))

    context "in return statements":
        """
        ### Scenario: Return Statement Context

        No-paren calls in return expressions.

        ```simple
        fn wrapper(x):
            double x
        ```
        """

        it "works in implicit returns":
            fn wrapper(x):
                fn inner(n):
                    n * 2
                inner x

            val result = wrapper 7
            expect(result).to_equal(14))


# ============================================================================
# String Arguments
# ============================================================================

describe "No-Paren Calls - String Arguments":
    """
    ## String Literal Arguments

    String literals work naturally with no-paren syntax.
    """

    context "with string literals":
        """
        ### Scenario: String Literals

        Pass strings without parentheses.

        ```simple
        print "Hello World"
        greet "Alice"
        ```
        """

        it "passes single string":
            fn identity(s):
                s

            val result = identity "test"
            expect(result).to_equal("test"))

        it "passes string with spaces":
            fn identity(s):
                s

            val result = identity "hello world"
            expect(result).to_equal("hello world"))


# ============================================================================
# Mixed Syntax
# ============================================================================

describe "No-Paren Calls - Mixed Syntax":
    """
    ## Mixing Paren and No-Paren Calls

    Combine both calling styles as needed.
    """

    context "with mixed styles":
        """
        ### Scenario: Mixed Call Styles

        Some calls with parens, some without.

        ```simple
        outer inner(x), arg2
        ```
        """

        it "mixes paren and no-paren":
            fn add(a, b):
                a + b

            fn double(x):
                x * 2

            val result = add(double(5), 3)
            expect(result).to_equal(13))

        it "chains multiple mixed calls":
            fn add1(x):
                x + 1

            fn add2(x):
                x + 2

            fn add3(x):
                x + 3

            val result = add1 add2(add3(10))
            expect(result).to_equal(16))


# ============================================================================
# Edge Cases
# ============================================================================

describe "No-Paren Calls - Edge Cases":
    """
    ## Edge Case Handling

    Special cases and boundary conditions.
    """

    context "with zero arguments":
        """
        ### Scenario: Zero Arguments

        Functions with no arguments require parentheses.

        ```simple
        func()  # Parentheses required for zero args
        ```
        """

        it "requires parens for zero args":
            fn get_value():
                42

            val result = get_value()
            expect(result).to_equal(42))

    context "with single identifier":
        """
        ### Scenario: Single Identifier Argument

        Passing a single variable.
        """

        it "passes single variable":
            fn square(x):
                x * x

            val num = 7
            val result = square num
            expect(result).to_equal(49))


# ============================================================================
# Helper Functions
# ============================================================================

fn helper_double(x):
    x * 2

fn helper_add(a, b):
    a + b

fn helper_triple(x):
    x * 3
