"""
# Collections Operations Specification

**Feature IDs:** #COLL-001 to #COLL-050
**Category:** Language | Data Structures
**Difficulty:** 2/5
**Status:** Implemented

## Overview

Collections provide fundamental data structures for organizing and manipulating
groups of values. Simple provides arrays, dictionaries, sets, and ranges as
built-in collection types with extensive operations.

## Syntax

```simple
# Arrays (ordered, indexable)
[1, 2, 3]                      # Array literal
arr[0]                         # Indexing
arr[-1]                        # Negative indexing (from end)
arr[1:3]                       # Slicing
arr.len()                      # Length

# Dictionaries (key-value maps)
{"name": "Alice", "age": 30}  # Dict literal
dict["name"]                   # Lookup
dict["age"] = 31               # Insertion

# Ranges (sequences)
0..10                          # Exclusive range (0 to 9)
0..=10                         # Inclusive range (0 to 10)
for i in 0..5:                 # Iteration
    print i

# Operations
items.map(\x: x * 2)           # Transform
items.filter(\x: x > 5)        # Filter
list1.merge(list2)             # Combine
```

## Key Concepts

| Type | Mutability | Ordered | Indexable | Keyed |
|------|-----------|---------|-----------|-------|
| Array | Mutable | Yes | Yes | No |
| Dict | Mutable | No* | No | Yes |
| Set | Mutable | No | No | No |
| Range | Immutable | Yes | No | No |

## Behavior

- Arrays are 0-indexed with optional negative indexing
- Dictionaries support flexible key types (string, int, etc.)
- Ranges are lazy and don't allocate full storage
- Collection methods are chainable
- Most operations preserve the collection type
"""



# ============================================================================
# Test Group 1: Array Basics
# ============================================================================

describe "Array Primitives":
    """
    ## Array Primitives

    Basic array creation, indexing, and length operations.
    """

    context "arrays":
        it "reports length of array":
            val arr = [1, 2, 3, 4, 5]
            expect(arr.len()).to(eq(5))

        it "reports length of empty array":
            val arr: [i64] = []
            expect(arr.len()).to(eq(0))

        it "accesses first element":
            val arr = [1, 2, 3, 4, 5]
            expect(arr[0]).to(eq(1))

        it "accesses middle element":
            val arr = [1, 2, 3, 4, 5]
            expect(arr[2]).to(eq(3))

        it "accesses last element with positive index":
            val arr = [1, 2, 3, 4, 5]
            expect(arr[4]).to(eq(5))

        it "accesses last element with negative index":
            val arr = [1, 2, 3, 4, 5]
            expect(arr[-1]).to(eq(5))

        it "accesses second-to-last with negative index":
            val arr = [1, 2, 3, 4, 5]
            expect(arr[-2]).to(eq(4))


# ============================================================================
# Test Group 2: Array Mutation
# ============================================================================

describe "Array Mutation":
    """
    ## Array Mutation

    Tests mutable operations on arrays.
    """

    context "pushing values":
        it "allows pushing values":
            var arr = [1, 2, 3, 4, 5]
            arr.push(6)
            expect(arr.len()).to(eq(6))
            expect(arr[arr.len() - 1]).to(eq(6))

        it "push returns unit":
            var arr = [1]
            val result = arr.push(2)
            expect(arr.len()).to(eq(2))

        it "allows pushing different values":
            var arr = [1, 2, 3]
            arr.push(4)
            arr.push(5)
            arr.push(6)
            expect(arr.len()).to(eq(6))

    context "popping values":
        it "removes last element":
            var arr = [1, 2, 3]
            val popped = arr.pop()
            expect popped == 3
            expect arr.len() == 2

        it "pops from single-element array":
            var arr = [42]
            val popped = arr.pop()
            expect popped == 42
            expect arr.len() == 0


# ============================================================================
# Test Group 3: Array Slicing
# ============================================================================

describe "Array Slicing":
    """
    ## Array Slicing

    Tests slicing operations on arrays.
    """

    it "slices array with start and end":
        val arr = [1, 2, 3, 4, 5]
        expect(arr[1:4]).to(eq([2, 3, 4]))

    it "slices with zero start":
        val arr = [1, 2, 3, 4, 5]
        expect(arr[0:3]).to(eq([1, 2, 3]))

    it "slices to end":
        val arr = [1, 2, 3, 4, 5]
        expect(arr[2:5]).to(eq([3, 4, 5]))

    it "slices with omitted start":
        val arr = [1, 2, 3, 4, 5]
        expect(arr[:3]).to(eq([1, 2, 3]))

    it "slices with omitted end":
        val arr = [1, 2, 3, 4, 5]
        expect(arr[2:]).to(eq([3, 4, 5]))

    it "slices with negative indices":
        val arr = [1, 2, 3, 4, 5]
        expect(arr[-3:-1]).to(eq([3, 4]))

    it "reverses array":
        val arr = [1, 2, 3, 4, 5]
        expect(arr[::-1]).to(eq([5, 4, 3, 2, 1]))


# ============================================================================
# Test Group 4: Dictionary Basics
# ============================================================================

describe "Dictionary Primitives":
    """
    ## Dictionary Primitives

    Basic dictionary creation, insertion, and retrieval.
    """

    context "dictionaries":
        it "stores and retrieves keys":
            val dict = {"name": "Alice", "age": 30}
            expect(dict["name"]).to(eq("Alice"))
            expect(dict["age"]).to(eq(30))

        it "handles empty dictionary":
            val dict: {text: i64} = {}
            expect(dict.len()).to(eq(0))

        it "inserts new key":
            var dict: {text: i64} = {}
            dict["key"] = 42
            expect(dict["key"]).to(eq(42))

        it "updates existing key":
            var dict = {"a": 1}
            dict["a"] = 2
            expect(dict["a"]).to(eq(2))

        it "handles multiple keys":
            var dict: {text: text} = {}
            dict["a"] = "apple"
            dict["b"] = "banana"
            dict["c"] = "cherry"
            expect(dict.len()).to(eq(3))


# ============================================================================
# Test Group 5: Array Iteration
# ============================================================================

describe "Array Iteration":
    """
    ## Array Iteration

    Tests looping and iteration over arrays.
    """

    context "ranges and loops":
        it "sums a small range":
            val sum = 0
            for i in [1, 2, 3]:
                sum = sum + i
            expect(sum).to(eq(6))

        it "iterates array with modification":
            var total = 0
            for item in [10, 20, 30]:
                total = total + item
            expect(total).to(eq(60))

        it "collects iteration results":
            val numbers = [1, 2, 3, 4, 5]
            var results = []
            for n in numbers:
                results.push(n * 2)
            expect(results.len()).to(eq(5))

        it "counts iterations":
            var count = 0
            for _ in [0, 1, 2, 3]:
                count = count + 1
            expect(count).to(eq(4))


# ============================================================================
# Test Group 6: Array Methods - Map and Filter
# ============================================================================

describe "Array Transformation Methods":
    """
    ## Array Transformation Methods

    Tests map, filter, and similar transformation operations.
    """

    it "maps with lambda":
        val nums = [1, 2, 3]
        val doubled = nums.map(\x: x * 2)
        expect(doubled).to(eq([2, 4, 6]))

    it "filters with lambda":
        val nums = [1, 2, 3, 4, 5]
        val evens = nums.filter(\x: x % 2 == 0)
        expect(evens.len()).to(eq(2))

    it "chains map and filter":
        val nums = [1, 2, 3, 4, 5]
        val result = nums.filter(\x: x > 2).map(\x: x * 2)
        expect result == [6, 8, 10]


# ============================================================================
# Test Group 7: Array Merging and Concatenation
# ============================================================================

describe "Array Merging":
    """
    ## Array Merging

    Tests combining arrays.
    """

    it "merges two arrays":
        val arr1 = [1, 2, 3]
        val arr2 = [4, 5, 6]
        val merged = arr1.merge(arr2)
        expect(merged).to(eq([1, 2, 3, 4, 5, 6]))

    it "merges empty with non-empty":
        val arr1: [i64] = []
        val arr2 = [1, 2]
        expect(arr1.merge(arr2)).to(eq([1, 2]))

    it "merges non-empty with empty":
        val arr1 = [1, 2]
        val arr2: [i64] = []
        expect(arr1.merge(arr2)).to(eq([1, 2]))


# ============================================================================
# Test Group 8: Range Operations
# ============================================================================

describe "Range Operations":
    """
    ## Range Operations

    Tests range creation and iteration.
    """

    it "iterates exclusive range":
        var sum = 0
        for i in 0..5:
            sum = sum + i
        expect(sum).to(eq(10))  # 0+1+2+3+4

    it "iterates inclusive range":
        var sum = 0
        for i in 0..=5:
            sum = sum + i
        expect(sum).to(eq(15))  # 0+1+2+3+4+5

    it "handles single-element range":
        var count = 0
        for _ in 5..6:
            count = count + 1
        expect(count).to(eq(1))

    it "handles empty range":
        var count = 0
        for _ in 5..5:
            count = count + 1
        expect(count).to(eq(0))


# ============================================================================
# Test Group 9: Dictionary Iteration
# ============================================================================

describe "Dictionary Iteration":
    """
    ## Dictionary Iteration

    Tests iterating over dictionaries.
    """

    it "iterates dictionary keys":
        val dict = {"a": 1, "b": 2, "c": 3}
        var count = 0
        for key in dict.keys():
            count = count + 1
        expect(count).to(eq(3))

    it "iterates dictionary values":
        val dict = {"a": 10, "b": 20, "c": 30}
        var sum = 0
        for value in dict.values():
            sum = sum + value
        expect(sum).to(eq(60))


# ============================================================================
# Test Group 10: Collection Existence Checks
# ============================================================================

describe "Collection Existence Checks":
    """
    ## Collection Existence Checks

    Tests checking if collections are empty or present.
    """

    it "checks non-empty array":
        val arr = [1, 2, 3]
        expect(arr.?).to(eq(true))

    it "checks empty array":
        val arr: [i64] = []
        expect(arr.?).to(eq(false))

    it "checks non-empty dictionary":
        val dict = {"a": 1}
        expect(dict.?).to(eq(true))

    it "checks empty dictionary":
        val dict: {text: i64} = {}
        expect(dict.?).to(eq(false))


# ============================================================================
# Test Group 11: Array First and Last
# ============================================================================

describe "Array First and Last":
    """
    ## Array First and Last

    Tests accessing first and last elements.
    """

    it "gets first element":
        val arr = [10, 20, 30]
        expect(arr.first()).to(eq(10))

    it "gets last element":
        val arr = [10, 20, 30]
        expect(arr.last()).to(eq(30))

    it "uses first with existence check":
        val arr = [1, 2, 3]
        expect(arr.first.?).to(eq(true))

    it "uses first with empty array":
        val arr: [i64] = []
        expect(not arr.first.?).to(eq(true))


# ============================================================================
# Test Group 12: Set Operations
# ============================================================================

describe "Set Operations":
    """
    ## Set Operations

    Tests set functionality (unique values).
    """

    it "creates set from array":
        val arr = [1, 2, 3, 2, 1]
        val unique_count = arr.len()
        # Note: set operations may vary
        expect(unique_count).to(eq(5))

    it "checks set membership":
        val items = [1, 2, 3, 4, 5]
        var found = false
        for item in items:
            if item == 3: found = true
        expect(found).to(eq(true))


# ============================================================================
# Test Group 13: Array Sorting and Ordering
# ============================================================================

describe "Array Ordering":
    """
    ## Array Ordering

    Tests sorting and ordering operations.
    """

    it "sorts numeric array":
        val arr = [3, 1, 4, 1, 5, 9]
        val sorted = arr.sorted()
        expect(sorted).to(eq([1, 1, 3, 4, 5, 9]))

    it "reverses array":
        val arr = [1, 2, 3, 4, 5]
        val reversed = arr.reversed()
        expect(reversed).to(eq([5, 4, 3, 2, 1]))


# ============================================================================
# Test Group 14: Collection Comprehension
# ============================================================================

describe "Collection Comprehension":
    """
    ## Collection Comprehension

    Tests list/array comprehension syntax.
    """

    it "creates array with comprehension":
        val result = [for i in 0..5: i * 2]
        expect(result).to(eq([0, 2, 4, 6, 8]))

    it "filters in comprehension":
        val result = [for i in 0..10 if i % 2 == 0: i]
        expect(result.len()).to(eq(5))

    it "comprehension with transformation":
        val result = [for i in [1, 2, 3]: i * i]
        expect(result).to(eq([1, 4, 9]))


# ============================================================================
# Test Group 15: Practical Collection Examples
# ============================================================================

describe "Collection Practical Examples":
    """
    ## Collection Practical Examples

    Real-world collection usage patterns.
    """

    it "builds list from loop":
        var items = []
        for i in 1..6:
            items.push(i)
        expect(items.len()).to(eq(5))

    it "accesses user data":
        val users = [
            {"id": 1, "name": "Alice"},
            {"id": 2, "name": "Bob"},
            {"id": 3, "name": "Carol"}
        ]
        expect(users.len()).to(eq(3))

    it "processes configuration":
        val config = {
            "host": "localhost",
            "port": 8080,
            "debug": true
        }
        expect(config["host"]).to(eq("localhost"))

    it "accumulates results":
        var totals = []
        for i in 1..4:
            totals.push(i * 10)
        expect(totals).to(eq([10, 20, 30]))

    it "filters and transforms data":
        val numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        val evens = numbers.filter(\x: x % 2 == 0)
        val doubled = evens.map(\x: x * 2)
        expect(doubled).to(eq([4, 8, 12, 16, 20]))
