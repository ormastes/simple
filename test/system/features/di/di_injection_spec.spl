"""
# Dependency Injection Specification

**Feature IDs:** #DI-INJ-001 to #DI-INJ-007
**Category:** Runtime | Dependency Injection
**Status:** Implemented
**Tags:** di, integration

Integration tests for DI Container with realistic service patterns.
Tests focus on scenarios not covered by unit tests.
"""

import std.spec


# ============================================================================
# Type Definitions (module level for impl blocks)
# ============================================================================

# --- Profile Types ---

enum Profile:
    Test
    Dev
    Prod
    Sdn

impl Profile:
    fn name() -> text:
        match self:
            case Test: "test"
            case Dev: "dev"
            case Prod: "prod"
            case Sdn: "sdn"

    static fn from_text(name: text) -> Profile:
        match name:
            case "test": Profile.Test
            case "dev": Profile.Dev
            case "prod": Profile.Prod
            case "sdn": Profile.Sdn
            case _: Profile.Dev


# --- Service Types ---

struct Repository:
    name: text

struct UserService:
    repo: Repository


# --- Container for text values ---

struct TextContainer:
    data: Dict<text, text>

impl TextContainer:
    static fn empty() -> TextContainer:
        TextContainer(data: {})

    me set(key: text, value: text):
        self.data[key] = value

    fn get(key: text) -> text?:
        if self.data.contains_key(key):
            Some(self.data[key])
        else:
            nil

    fn has(key: text) -> bool:
        self.data.contains_key(key)


# ============================================================================
# Test Group 1: Service Pattern
# ============================================================================

describe "Service with Dependencies":
    """
    Tests realistic service patterns where services depend on other services.
    """

    it "creates service with repository dependency":
        # Direct construction simulates what a DI container would do
        val repo = Repository(name: "users")
        val service = UserService(repo: repo)

        expect service.repo.name == "users"

    it "chains multiple text dependencies":
        # Three-level dependency chain: App -> Service -> Config
        var container = TextContainer.empty()

        # Level 1: Config
        container.set("DbConfig", "db://localhost:5432")

        # Level 2: Service depends on Config
        val config = container.get("DbConfig")
        expect config.?
        val pool = "pool:{config.unwrap()}"
        container.set("ConnectionPool", pool)

        # Level 3: App depends on Service
        val pool_value = container.get("ConnectionPool")
        expect pool_value.?
        val app = "app using {pool_value.unwrap()}"

        expect app == "app using pool:db://localhost:5432"


# ============================================================================
# Test Group 2: Profile Behavior
# ============================================================================

describe "Profile-Based Configuration":
    """
    Tests that profile patterns work correctly.
    """

    it "profile enum converts to text":
        val p = Profile.Test
        expect p.name() == "test"

    it "profile enum parses from text":
        val p = Profile.from_text("prod")
        expect p.name() == "prod"

    it "profile defaults to dev for unknown":
        val p = Profile.from_text("unknown")
        expect p.name() == "dev"

    it "all profiles have unique names":
        val test = Profile.Test.name()
        val dev = Profile.Dev.name()
        val prod = Profile.Prod.name()
        val sdn = Profile.Sdn.name()

        expect test != dev
        expect dev != prod
        expect prod != sdn


# ============================================================================
# Test Group 3: Container Pattern
# ============================================================================

describe "Container Binding Pattern":
    """
    Tests the container binding and retrieval pattern.
    """

    it "stores and retrieves values":
        var container = TextContainer.empty()
        container.set("service", "my_service")

        val result = container.get("service")
        expect result.?
        expect result.unwrap() == "my_service"

    it "has returns true for existing keys":
        var container = TextContainer.empty()
        container.set("key", "value")

        expect container.has("key")
        expect not container.has("missing")

    it "get returns None for missing keys":
        val container = TextContainer.empty()
        val result = container.get("missing")

        expect not result.?

    it "set overwrites existing values":
        var container = TextContainer.empty()
        container.set("key", "first")
        container.set("key", "second")

        val result = container.get("key")
        expect result.?
        expect result.unwrap() == "second"


# ============================================================================
# Test Group 4: Error Handling Pattern
# ============================================================================

describe "DI Error Handling Pattern":
    """
    Tests Result-based error handling for DI resolution.
    """

    fn resolve(data: Dict<text, text>, name: text) -> Result<text, text>:
        if data.contains_key(name):
            Ok(data[name])
        else:
            Err("No binding for: {name}")

    it "returns Ok for existing binding":
        val data: Dict<text, text> = {"Service": "instance"}
        val result = resolve(data, "Service")

        expect result.ok.?
        expect result.unwrap() == "instance"

    it "returns Err for missing binding":
        val data: Dict<text, text> = {}
        val result = resolve(data, "Missing")

        expect result.err.?
        val err_msg = result.unwrap_err()
        expect err_msg.starts_with("No binding")


# ============================================================================
# Test Group 5: @inject Decorator
# ============================================================================

describe "@inject Decorator Recognition":
    """
    Tests that @inject decorator is recognized by the parser/HIR.
    Note: Full runtime injection requires interpreter support (future).
    """

    it "function with @inject is parsed":
        @inject
        fn create_service(config: text) -> text:
            "service:{config}"

        # The function exists and is callable
        # (decorator doesn't break parsing)
        expect create_service("test") == "service:test"

    it "class method with @inject is parsed":
        class Database:
            connection: text

            @inject
            static fn create(connection: text) -> Database:
                Database(connection: connection)

        val db = Database.create("db://localhost")
        expect db.connection == "db://localhost"
