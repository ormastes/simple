"""
# Null Coalescing and Try Operator Parser Specification

**Feature IDs:** #PARSER-NULL-001
**Category:** Parser / Operators
**Difficulty:** 3/5
**Status:** In Progress

## Overview

Tests for the `??` (null coalescing) and `?` (try) operators in various contexts.
These operators should work correctly in:
- Simple expressions
- Return statements
- For loop bodies
- If expression bodies
- Match arms

## Known Issues

The following patterns cause parse errors:
1. `val x = expr ?? return Err(...)` - "expected expression, found Return"
2. `val x = expr?` inside for loop body - may cause issues
3. `val x = if cond: Some(fn()?) else: None` - "expected identifier, found Val"

## Workarounds

Use explicit if/else or match instead of operators in these contexts.
"""

describe "Null Coalescing Operator (??)":
    """Basic null coalescing operator tests."""

    context "simple expressions":
        it "returns left value when present":
            val opt: i64? = Some(42)
            val result = opt ?? 0
            expect(result).to_equal(42)

        it "returns right value when None":
            val opt: i64? = None
            val result = opt ?? 99
            expect(result).to_equal(99)

        it "chains multiple coalescing":
            val a: i64? = None
            val b: i64? = None
            val c: i64? = Some(10)
            val result = a ?? b ?? c ?? 0
            expect(result).to_equal(10)

    context "with function calls":
        it "evaluates right side lazily":
            var counter = 0
            fn increment() -> i64:
                counter = counter + 1
                counter

            val opt: i64? = Some(5)
            val result = opt ?? increment()
            expect(result).to_equal(5)
            expect(counter).to_equal(0)

        it "calls right side when None":
            var counter = 0
            fn increment() -> i64:
                counter = counter + 1
                counter

            val opt: i64? = None
            val result = opt ?? increment()
            expect(result).to_equal(1)
            expect(counter).to_equal(1)

describe "Try Operator (?)":
    """Basic try operator tests."""

    context "with Result type":
        it "unwraps Ok value":
            fn get_ok() -> Result<i64, text>:
                Ok(42)

            fn use_ok() -> Result<i64, text>:
                val x = get_ok()?
                Ok(x + 1)

            val result = use_ok()
            match result:
                case Ok(v): expect(v).to_equal(43)
                case Err(_): fail("Expected Ok")

        it "propagates Err":
            fn get_err() -> Result<i64, text>:
                Err("error")

            fn use_err() -> Result<i64, text>:
                val x = get_err()?
                Ok(x + 1)

            val result = use_err()
            match result:
                case Ok(_): fail("Expected Err")
                case Err(e): expect(e).to_equal("error")

    context "with Option type":
        it "unwraps Some value":
            fn get_some() -> i64?:
                Some(42)

            fn use_some() -> i64?:
                val x = get_some()?
                Some(x + 1)

            val result = use_some()
            match result:
                case Some(v): expect(v).to_equal(43)
                case None: fail("Expected Some")

        it "propagates None":
            fn get_none() -> i64?:
                None

            fn use_none() -> i64?:
                val x = get_none()?
                Some(x + 1)

            val result = use_none()
            match result:
                case Some(_): fail("Expected None")
                case None: pass

describe "Parser Edge Cases":
    """Document known parser limitations with ?? and ?."""

    context "workaround patterns":
        """These patterns work correctly."""

        it "explicit if/else instead of ?? return":
            fn parse_value(s: text) -> Result<i64, text>:
                val opt = s.parse_int()
                if not opt.?:
                    return Err("parse failed")
                val value = opt.unwrap()
                Ok(value)

            val result = parse_value("42")
            match result:
                case Ok(v): expect(v).to_equal(42)
                case Err(_): fail("Expected Ok")

        it "match instead of ? in for loop":
            fn sum_parsed(items: [text]) -> Result<i64, text>:
                var total = 0
                for item in items:
                    val result = item.parse_int()
                    match result:
                        case Some(n): total = total + n
                        case None: return Err("parse failed: {item}")
                Ok(total)

            val result = sum_parsed(["1", "2", "3"])
            match result:
                case Ok(v): expect(v).to_equal(6)
                case Err(_): fail("Expected Ok")

        it "explicit match for optional config":
            fn parse_config(dict: Dict<text, text>) -> Result<i64, text>:
                var timeout: i64? = None
                if dict["timeout"].?:
                    val timeout_str = dict["timeout"].unwrap()
                    val parsed = timeout_str.parse_int()
                    match parsed:
                        case Some(t): timeout = Some(t)
                        case None: return Err("invalid timeout")
                Ok(timeout ?? 30)

            var config: Dict<text, text> = {}
            config["timeout"] = "60"
            val result = parse_config(config)
            match result:
                case Ok(v): expect(v).to_equal(60)
                case Err(_): fail("Expected Ok")

    context "previously reported bugs (now fixed)":
        """These patterns were reported as parser bugs but work in current bootstrap."""

        it "? in if-expression body":
            fn parse_int_result(s: text) -> Result<i64, text>:
                val parsed = s.parse_int()
                if not parsed.?:
                    return Err("parse failed")
                Ok(parsed.unwrap())

            fn parse_optional(has_value: bool, s: text) -> Result<i64?, text>:
                val result = if has_value:
                    Some(parse_int_result(s)?)
                else:
                    None
                Ok(result)

            val r1 = parse_optional(true, "42")
            match r1:
                case Ok(v): expect(v.unwrap()).to_equal(42)
                case Err(_): fail("Expected Ok")

            val r2 = parse_optional(false, "")
            match r2:
                case Ok(v): expect(not v.?)
                case Err(_): fail("Expected Ok")

        it "? in for loop with Result":
            fn parse_int_result(s: text) -> Result<i64, text>:
                val parsed = s.parse_int()
                if not parsed.?:
                    return Err("parse failed: {s}")
                Ok(parsed.unwrap())

            fn sum_parsed(items: [text]) -> Result<i64, text>:
                var total = 0
                for item in items:
                    val n = parse_int_result(item)?
                    total = total + n
                Ok(total)

            val r1 = sum_parsed(["1", "2", "3"])
            match r1:
                case Ok(v): expect(v).to_equal(6)
                case Err(_): fail("Expected Ok")

            val r2 = sum_parsed(["1", "abc", "3"])
            match r2:
                case Ok(_): fail("Expected Err")
                case Err(e): expect(e).to_equal("parse failed: abc")

    skip context "known parser bugs":
        """The ?? return bug requires bootstrap rebuild to fix.
        Source fix applied to src/compiler/parser.spl and
        src/app/parser/expr/postfix.spl."""

        skip it "?? return Err pattern":
            """
            BUG: Bootstrap parser error "expected expression, found Return"
            Root cause: bootstrap binary's parse_primary_expr() doesn't handle
            KwReturn in expression position. Source fix exists in both
            src/compiler/parser.spl and src/app/parser/expr/postfix.spl
            but requires bootstrap rebuild to take effect.
            """
            # After bootstrap rebuild, uncomment and this should work:
            # fn parse_with_default(s: text) -> Result<i64, text>:
            #     val value = s.parse_int() ?? return Err("parse failed")
            #     Ok(value)
            pass
