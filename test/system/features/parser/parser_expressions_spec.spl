"""
# Parser Expression Specification

**Feature IDs:** #PARSER-EXPR-001 to #PARSER-EXPR-030
**Category:** Infrastructure | Parser
**Status:** Implemented

Tests that the parser correctly parses various expression forms including
arithmetic, logical, comparison, indexing, method calls, and more.

## Syntax

```simple
# Arithmetic
x + y, x - y, x * y, x / y, x % y, x ** y, x // y

# Comparison
x < y, x > y, x <= y, x >= y, x == y, x != y

# Logical
x and y, x or y, not x

# Method/Field access
obj.method(), obj.field

# Indexing
arr[0], arr[i], arr[1:3]
```
"""



# ============================================================================
# Test Group 1: Arithmetic Expressions
# ============================================================================

describe "Arithmetic Expression Parsing":
    """
    ## Binary Arithmetic Operators

    Tests parsing of addition, subtraction, multiplication, division, etc.
    """

    context "basic operations":
        it "parses addition":
            val x = 1 + 2
            expect x == 3

        it "parses subtraction":
            val x = 5 - 3
            expect x == 2

        it "parses multiplication":
            val x = 4 * 5
            expect x == 20

        it "parses division":
            val x = 10 / 2
            expect x == 5

        it "parses modulo":
            val x = 7 % 3
            expect x == 1

        it "parses power":
            val x = 2 ** 3
            expect x == 8

        it "parses integer division":
            val x = 7.fdiv(3)
            expect x == 2

    context "operator precedence":
        it "multiplication before addition":
            val x = 2 + 3 * 4
            expect x == 14

        it "parentheses override precedence":
            val x = (2 + 3) * 4
            expect x == 20

        it "nested parentheses":
            val x = ((1 + 2) * 3)
            expect x == 9

    context "unary operations":
        it "parses unary minus":
            val x = -5
            expect x == -5

        it "parses bitwise not":
            val x = ~0
            expect x == -1


# ============================================================================
# Test Group 2: Comparison Expressions
# ============================================================================

describe "Comparison Expression Parsing":
    """
    ## Comparison Operators

    Tests parsing of comparison operators for equality and ordering.
    """

    it "parses less than":
        expect (1 < 2) == true

    it "parses greater than":
        expect (2 > 1) == true

    it "parses less than or equal":
        expect (2 <= 2) == true

    it "parses greater than or equal":
        expect (3 >= 2) == true

    it "parses equals":
        expect (2 == 2) == true

    it "parses not equals":
        expect (1 != 2) == true


# ============================================================================
# Test Group 3: Logical Expressions
# ============================================================================

describe "Logical Expression Parsing":
    """
    ## Logical Operators

    Tests parsing of boolean logic operators.
    """

    it "parses and":
        val x = true and false
        expect x == false

    it "parses or":
        val x = true or false
        expect x == true

    it "parses not":
        val x = not true
        expect x == false

    it "parses combined logical":
        val x = (true and false) or true
        expect x == true


# ============================================================================
# Test Group 4: Method and Field Access
# ============================================================================

describe "Method and Field Access Parsing":
    """
    ## Dot Notation for Members

    Tests parsing of method calls and field access on objects.
    """

    context "method calls":
        it "parses no-arg method call":
            val arr = [1, 2, 3]
            val len = arr.len()
            expect len == 3

        it "parses method call with args":
            val arr = [1, 2, 3]
            expect arr.contains(2)

        it "parses chained method calls":
            val arr = [1, 2, 3]
            val result = arr.map(\x: x * 2).filter(\x: x > 2)
            expect result.len() == 2

    context "field access":
        it "parses field access":
            class Point:
                x: i64
                y: i64
            val p = Point(x: 10, y: 20)
            expect p.x == 10

        it "parses nested field access":
            class Inner:
                value: i64
            class Outer:
                inner: Inner
            val o = Outer(inner: Inner(value: 42))
            expect o.inner.value == 42


# ============================================================================
# Test Group 5: Indexing Expressions
# ============================================================================

describe "Indexing Expression Parsing":
    """
    ## Square Bracket Indexing

    Tests parsing of array/collection indexing and slicing.
    """

    context "simple indexing":
        it "parses integer index":
            val arr = [10, 20, 30]
            expect arr[0] == 10

        it "parses variable index":
            val arr = [10, 20, 30]
            val i = 1
            expect arr[i] == 20

        it "parses expression index":
            val arr = [10, 20, 30]
            expect arr[1 + 1] == 30

        it "parses negative index":
            val arr = [10, 20, 30]
            expect arr[-1] == 30

    context "slicing":
        it "parses start end slice":
            val arr = [0, 1, 2, 3, 4]
            val sliced = arr[1:4]
            expect sliced.len() == 3

        it "parses end slice":
            val arr = [0, 1, 2, 3, 4]
            val sliced = arr[:3]
            expect sliced.len() == 3

        it "parses start slice":
            val arr = [0, 1, 2, 3, 4]
            val sliced = arr[2:]
            expect sliced.len() == 3


# ============================================================================
# Test Group 6: Function Call Expressions
# ============================================================================

describe "Function Call Expression Parsing":
    """
    ## Function Invocation Syntax

    Tests parsing of function calls with various argument styles.
    """

    context "positional arguments":
        it "parses no-arg call":
            fn get_value() -> i64:
                42
            expect get_value() == 42

        it "parses single arg call":
            fn double(x: i64) -> i64:
                x * 2
            expect double(21) == 42

        it "parses multi-arg call":
            fn add(a: i64, b: i64, c: i64) -> i64:
                a + b + c
            expect add(10, 20, 12) == 42

    context "named arguments":
        it "parses named arguments":
            fn greet(name: text, greeting: text) -> text:
                "{greeting}, {name}!"
            val result = greet(name = "World", greeting = "Hello")
            expect result == "Hello, World!"


# ============================================================================
# Test Group 7: Path Expressions
# ============================================================================

describe "Path Expression Parsing":
    """
    ## Double Colon Path Syntax

    Tests parsing of module paths and enum variants.
    """

    it "parses enum variant":
        enum Color:
            Red
            Green
            Blue
        val c = Color.Red
        expect c == Color.Red

    it "parses nested path":
        # Module path syntax - using function call instead
        fn get_value() -> i64:
            42
        expect get_value() == 42


# ============================================================================
# Test Group 8: Conditional Expressions
# ============================================================================

describe "Conditional Expression Parsing":
    """
    ## Inline If Expressions

    Tests parsing of if expressions that return values.
    """

    it "parses if-else expression":
        val x = if true: 1 else: 0
        expect x == 1

    it "parses conditional comparison":
        val a = 10
        val b = 5
        val max = if a > b: a else: b
        expect max == 10


# ============================================================================
# Test Group 9: Lambda Expressions
# ============================================================================

describe "Lambda Expression Parsing":
    """
    ## Backslash Lambda Syntax

    Tests parsing of lambda/anonymous function expressions.
    """

    it "parses single parameter lambda":
        val f = \x: x + 1
        expect f(41) == 42

    it "parses multi-parameter lambda":
        val f = \a, b: a + b
        expect f(20, 22) == 42

    it "parses no-parameter lambda":
        val f = \: 42
        expect f() == 42

    it "uses lambda with map":
        val arr = [1, 2, 3]
        val doubled = arr.map(\x: x * 2)
        expect doubled[0] == 2


# ============================================================================
# Test Group 10: is/in Expressions
# ============================================================================

describe "is/in Expression Parsing":
    """
    ## Type and Membership Tests

    Tests parsing of is (type check) and in (membership) operators.
    """

    it "parses is expression":
        val opt: Option<i64> = Some(42)
        if opt is Some(x):
            expect x == 42

    it "parses in expression":
        val list = [1, 2, 3]
        expect 2 in list

    it "parses not in expression":
        val list = [1, 2, 3]
        expect not (5 in list)


# ============================================================================
# Test Group 11: Nested Expressions
# ============================================================================

describe "Nested Expression Parsing":
    """
    ## Complex Nested Expressions

    Tests parsing of deeply nested and complex expressions.
    """

    it "parses deeply nested arithmetic":
        val x = ((1 + 2) * (3 + 4)) - ((5 - 6) * (7 - 8))
        expect x == 21 - 1

    it "parses nested collections":
        val arr = [[1, 2], [3, 4]]
        expect arr[0][1] == 2

    it "parses nested method chains":
        val result = [1, 2, 3, 4, 5]
            .filter(\x: x > 2)
            .map(\x: x * 2)
            .filter(\x: x < 10)
        expect result.len() == 2


# ============================================================================
# Test Group 12: Optional Chaining
# ============================================================================

describe "Optional Chaining Expression Parsing":
    """
    ## Safe Navigation with ?.

    Tests parsing of optional chaining and null coalescing.
    """

    it "parses optional chaining":
        val opt: Option<text> = Some("hello")
        val len = opt?.len()
        expect len == Some(5)

    it "parses null coalescing":
        val opt: Option<i64> = None
        val value = opt ?? 42
        expect value == 42

    it "parses chained optional access":
        struct User:
            name: Option<text>
        val user: Option<User> = Some(User { name: Some("Alice") })
        val name = user?.name ?? "Unknown"
        expect name == "Alice"
