"""
# Dual Syntax for Argument Assignment Specification

**Feature IDs:** #1200-1210
**Category:** Syntax
**Difficulty:** 2/5
**Status:** Implemented

## Overview

Support BOTH `:` and `=` for argument assignment in ALL contexts with no preference
between syntaxes. This provides flexibility and aligns with Pattern A approach
(like `pass` vs `()`).

## Syntax

Both syntaxes are equally valid:

```simple
# Function calls
greet(name: "World")      # Colon syntax
greet(name = "World")     # Equals syntax

# Struct initialization
Point(x: 3, y: 4)         # Colon syntax
Point(x = 3, y = 4)       # Equals syntax

# No-paren calls
process data: "hello"     # Colon syntax
process data = "hello"    # Equals syntax
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| Pattern A | Both syntaxes equally valid, no deprecation |
| Backward Compatible | All existing `:` code continues to work |
| Context Coverage | Function calls, struct init, no-paren calls |

## Behavior

Both `:` and `=` are accepted in:
- Function call arguments
- Struct field initialization
- No-paren call arguments
- Mixed usage within same call is allowed
- Both syntaxes produce identical AST and bytecode

## Related Specifications

- [Parser Expressions](../../../../doc/spec/parser/lexer_parser_grammar_expressions.md)
- [Function Calls](parser_function_call_spec.spl)

## Implementation Notes

This feature maintains backward compatibility while providing syntax flexibility.
No preference is given to either syntax - developers can choose based on context
or personal preference.
"""


# ============================================================================
# Test Group 1: Function Calls (Regression Tests)
# ============================================================================

describe "Dual Syntax - Function Calls":
    """
    ## Function Call Argument Assignment

    Function calls already supported both `:` and `=` - these are regression tests
    to ensure the functionality remains intact.
    """

    context "colon syntax in function calls":
        """
        ### Scenario: Traditional colon syntax

        The original syntax using `:` for named arguments.
        """

        it "accepts single named argument with colon":
            fn greet(name: text) -> text:
                "Hello, {name}!"

            val result = greet(name: "World")
            expect result == "Hello, World!"

        it "accepts multiple named arguments with colons":
            fn add(a: i64, b: i64) -> i64:
                a + b

            val result = add(a: 10, b: 20)
            expect result == 30

    context "equals syntax in function calls":
        """
        ### Scenario: Equals syntax for arguments

        Alternative syntax using `=` for named arguments.
        """

        it "accepts single named argument with equals":
            fn greet(name: text) -> text:
                "Hello, {name}!"

            val result = greet(name = "World")
            expect result == "Hello, World!"

        it "accepts multiple named arguments with equals":
            fn add(a: i64, b: i64) -> i64:
                a + b

            val result = add(a = 10, b = 20)
            expect result == 30

    context "mixed syntax in function calls":
        """
        ### Scenario: Mixing `:` and `=` in same call

        Both syntaxes can be used together in a single function call.
        """

        it "accepts mixed colon and equals syntax":
            fn compute(a: i64, b: i64, c: i64) -> i64:
                a + b * c

            val result = compute(a: 10, b = 20, c: 12)
            expect result == 250

        it "produces identical results regardless of syntax":
            fn format(prefix: text, value: i64, suffix: text) -> text:
                "{prefix}{value}{suffix}"

            val result1 = format(prefix: "[", value: 42, suffix: "]")
            val result2 = format(prefix = "[", value = 42, suffix = "]")
            val result3 = format(prefix: "[", value = 42, suffix: "]")

            expect result1 == result2
            expect result2 == result3


# ============================================================================
# Test Group 2: Struct Initialization (New Support)
# ============================================================================

describe "Dual Syntax - Struct Initialization":
    """
    ## Struct Field Assignment

    Struct initialization now supports both `:` and `=` for field assignment,
    providing consistency with function call syntax.
    """

    context "colon syntax in struct init":
        """
        ### Scenario: Traditional colon syntax for struct fields

        The original syntax using `:` for struct field initialization.
        """

        it "accepts single field with colon":
            struct Person:
                name: text

            val person = Person(name: "Alice")
            expect person.name == "Alice"

        it "accepts multiple fields with colons":
            struct Point:
                x: i64
                y: i64

            val point = Point(x: 3, y: 4)
            expect point.x == 3
            expect point.y == 4

        it "accepts many fields with colons":
            struct Rectangle:
                x: i64
                y: i64
                width: i64
                height: i64

            val rect = Rectangle(x: 10, y: 20, width: 100, height: 50)
            expect rect.width == 100
            expect rect.height == 50

    context "equals syntax in struct init":
        """
        ### Scenario: Equals syntax for struct fields

        New support for `=` syntax in struct field initialization.
        """

        it "accepts single field with equals":
            struct Person:
                name: text

            val person = Person(name = "Bob")
            expect person.name == "Bob"

        it "accepts multiple fields with equals":
            struct Point:
                x: i64
                y: i64

            val point = Point(x = 5, y = 6)
            expect point.x == 5
            expect point.y == 6

        it "accepts many fields with equals":
            struct Rectangle:
                x: i64
                y: i64
                width: i64
                height: i64

            val rect = Rectangle(x = 0, y = 0, width = 200, height = 100)
            expect rect.width == 200
            expect rect.height == 100

    context "mixed syntax in struct init":
        """
        ### Scenario: Mixing `:` and `=` in struct initialization

        Both syntaxes can be used together when initializing a struct.
        """

        it "accepts mixed colon and equals syntax":
            struct Config:
                host: text
                port: i64
                timeout: i64
                retries: i64

            val config = Config(host: "localhost", port = 8080, timeout: 30, retries = 3)
            expect config.host == "localhost"
            expect config.port == 8080
            expect config.timeout == 30
            expect config.retries == 3

        it "produces identical structs regardless of syntax":
            struct Point:
                x: i64
                y: i64

            val p1 = Point(x: 10, y: 20)
            val p2 = Point(x = 10, y = 20)
            val p3 = Point(x: 10, y = 20)

            expect p1.x == p2.x
            expect p1.y == p2.y
            expect p2.x == p3.x
            expect p2.y == p3.y

    context "shorthand syntax still works":
        """
        ### Scenario: Shorthand initialization unchanged

        Field shorthand (omitting the value when variable name matches field name)
        continues to work as before.
        """

        it "accepts shorthand syntax":
            struct Point:
                x: i64
                y: i64

            val x = 7
            val y = 8
            val point = Point(x, y)

            expect point.x == 7
            expect point.y == 8

        it "mixes shorthand with explicit syntax":
            struct Point:
                x: i64
                y: i64

            val x = 9
            val point = Point(x, y: 10)

            expect point.x == 9
            expect point.y == 10


# ============================================================================
# Test Group 3: No-Paren Calls (New Support)
# ============================================================================

describe "Dual Syntax - No-Paren Calls":
    """
    ## No-Paren Call Argument Assignment

    No-paren calls now support both `:` and `=` for named argument assignment.
    """

    context "colon syntax in no-paren calls":
        """
        ### Scenario: Traditional colon syntax for no-paren calls

        The original syntax using `:` for no-paren call arguments.
        """

        it "accepts single argument with colon":
            fn process(data: text) -> text:
                "Processing: {data}"

            val result = process data: "hello"
            expect result == "Processing: hello"

        it "accepts multiple arguments with colons":
            fn combine(a: i64, b: i64, c: i64) -> i64:
                a + b + c

            val result = combine a: 1 b: 2 c: 3
            expect result == 6

    context "equals syntax in no-paren calls":
        """
        ### Scenario: Equals syntax for no-paren calls

        New support for `=` syntax in no-paren call arguments.
        """

        it "accepts single argument with equals":
            fn process(data: text) -> text:
                "Processing: {data}"

            val result = process data = "world"
            expect result == "Processing: world"

        it "accepts multiple arguments with equals":
            fn combine(a: i64, b: i64, c: i64) -> i64:
                a + b + c

            val result = combine a = 4 b = 5 c = 6
            expect result == 15

    context "mixed syntax in no-paren calls":
        """
        ### Scenario: Mixing `:` and `=` in no-paren calls

        Both syntaxes can be used together in no-paren calls.
        """

        it "accepts mixed colon and equals syntax":
            fn compute(a: i64, b: i64, c: i64) -> i64:
                a * b + c

            val result = compute a: 5 b = 3 c: 7
            expect result == 22

        it "produces identical results regardless of syntax":
            fn format(prefix: text, value: i64) -> text:
                "{prefix}{value}"

            val result1 = format prefix: ">" value: 99
            val result2 = format prefix = ">" value = 99
            val result3 = format prefix: ">" value = 99

            expect result1 == result2
            expect result2 == result3


# ============================================================================
# Test Group 4: Edge Cases and Complex Scenarios
# ============================================================================

describe "Dual Syntax - Edge Cases":
    """
    ## Edge Cases and Complex Usage

    Tests for nested calls, multiline arguments, and other edge cases.
    """

    context "nested calls and struct init":
        """
        ### Scenario: Combining different contexts

        Both syntaxes work correctly when nesting function calls and struct init.
        """

        it "handles nested function calls with mixed syntax":
            fn outer(a: i64, b: i64) -> i64:
                a + b

            fn inner(x: i64) -> i64:
                x * 2

            val result = outer(a: inner(x = 5), b = 10)
            expect result == 20

        it "handles struct init inside function call":
            struct Point:
                x: i64
                y: i64

            fn distance(p: Point) -> i64:
                p.x + p.y

            val result = distance(p = Point(x: 3, y = 4))
            expect result == 7

        it "handles function call result in struct init":
            fn get_value() -> i64:
                42

            struct Container:
                value: i64

            val container = Container(value = get_value())
            expect container.value == 42

    context "multiline arguments":
        """
        ### Scenario: Arguments spanning multiple lines

        Both syntaxes work with multiline formatting.
        """

        it "handles multiline with colon syntax":
            fn long_call(a: i64, b: i64, c: i64, d: i64) -> i64:
                a + b + c + d

            val result = long_call(
                a: 1,
                b: 2,
                c: 3,
                d: 4
            )
            expect result == 10

        it "handles multiline with equals syntax":
            fn long_call(a: i64, b: i64, c: i64, d: i64) -> i64:
                a + b + c + d

            val result = long_call(
                a = 5,
                b = 6,
                c = 7,
                d = 8
            )
            expect result == 26

        it "handles multiline with mixed syntax":
            struct Config:
                host: text
                port: i64
                ssl: bool

            val config = Config(
                host: "example.com",
                port = 443,
                ssl: true
            )
            expect config.port == 443

    context "whitespace handling":
        """
        ### Scenario: Various whitespace patterns

        Both syntaxes handle whitespace correctly.
        """

        it "handles spaces around colon":
            fn test(x: i64) -> i64:
                x

            val r1 = test(x:42)
            val r2 = test(x: 42)
            val r3 = test(x :42)
            val r4 = test(x : 42)

            expect r1 == r2
            expect r2 == r3
            expect r3 == r4

        it "handles spaces around equals":
            fn test(x: i64) -> i64:
                x

            val r1 = test(x=42)
            val r2 = test(x= 42)
            val r3 = test(x =42)
            val r4 = test(x = 42)

            expect r1 == r2
            expect r2 == r3
            expect r3 == r4


# ============================================================================
# Test Group 5: Consistency Verification
# ============================================================================

describe "Dual Syntax - Consistency":
    """
    ## Syntax Consistency

    Verify that both syntaxes produce identical behavior across all contexts.
    """

    it "produces same results in all contexts combined":
        struct Point:
            x: i64
            y: i64

        fn distance(p: Point) -> i64:
            p.x + p.y

        # All colon
        val r1 = distance(p: Point(x: 10, y: 20))

        # All equals
        val r2 = distance(p = Point(x = 10, y = 20))

        # Mixed outer call
        val r3 = distance(p: Point(x = 10, y = 20))

        # Mixed inner struct
        val r4 = distance(p = Point(x: 10, y = 20))

        expect r1 == 30
        expect r2 == 30
        expect r3 == 30
        expect r4 == 30

    it "works identically in real-world scenarios":
        struct Config:
            server: text
            port: i64
            timeout: i64

        fn connect(cfg: Config) -> text:
            "Connected to {cfg.server}:{cfg.port}"

        # Scenario 1: All colon syntax
        val config1 = Config(server: "localhost", port: 8080, timeout: 30)
        val result1 = connect(cfg: config1)

        # Scenario 2: All equals syntax
        val config2 = Config(server = "localhost", port = 8080, timeout = 30)
        val result2 = connect(cfg = config2)

        # Scenario 3: Mixed syntax
        val config3 = Config(server: "localhost", port = 8080, timeout: 30)
        val result3 = connect(cfg = config3)

        expect result1 == "Connected to localhost:8080"
        expect result2 == "Connected to localhost:8080"
        expect result3 == "Connected to localhost:8080"
