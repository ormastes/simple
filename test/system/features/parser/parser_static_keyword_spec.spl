describe "Static methods in classes":
    it "parses static method in class":
        class Math:
            static fn add(a: i32, b: i32) -> i32:
                return a + b

        expect Math.add(2, 3) == 5

    it "calls static method without instance":
        class Utils:
            static fn double(x: i32) -> i32:
                return x * 2

        expect Utils.double(5) == 10

    it "parses static method with no parameters":
        class Counter:
            static fn get_version() -> i32:
                return 1

        expect Counter.get_version() == 1

    it "parses static method returning text":
        class Formatter:
            static fn format() -> text:
                return "formatted"

        expect Formatter.format() == "formatted"

describe "Static methods in impl blocks":
    it "parses static method in impl block":
        struct Point:
            x: i64
            y: i64

        impl Point:
            static fn origin() -> Point:
                return Point(x: 0, y: 0)

        val p = Point.origin()
        expect p.x == 0
        expect p.y == 0

    it "parses multiple static methods in impl":
        struct Rectangle:
            width: f64
            height: f64

        impl Rectangle:
            static fn square(size: f64) -> Rectangle:
                return Rectangle(width: size, height: size)

            static fn from_dimensions(w: f64, h: f64) -> Rectangle:
                return Rectangle(width: w, height: h)

        val sq = Rectangle.square(10.0)
        expect sq.width == 10.0
        expect sq.height == 10.0

describe "Static vs instance methods":
    it "distinguishes static from instance methods":
        class Example:
            value: i32

            static fn create() -> Example:
                return Example(value: 42)

            fn get_value() -> i32:
                return self.value

        val ex = Example.create()
        expect ex.get_value() == 42

    it "parses class with both static and instance methods":
        class Logger:
            name: text

            static fn default_logger() -> Logger:
                return Logger(name: "default")

            fn log(message: text):
                pass

        val logger = Logger.default_logger()
        expect logger.name == "default"

describe "Static methods as factories":
    it "uses static method as constructor alternative":
        struct Color:
            r: u8
            g: u8
            b: u8

        impl Color:
            static fn red() -> Color:
                return Color(r: 255, g: 0, b: 0)

            static fn green() -> Color:
                return Color(r: 0, g: 255, b: 0)

            static fn blue() -> Color:
                return Color(r: 0, g: 0, b: 255)

        val c = Color.red()
        expect c.r == 255
        expect c.g == 0
        expect c.b == 0

    it "uses static method with parameters":
        struct Config:
            port: i32
            host: text

        impl Config:
            static fn new(port: i32, host: text) -> Config:
                return Config(port: port, host: host)

        val cfg = Config.new(8080, "localhost")
        expect cfg.port == 8080

describe "Static method visibility":
    it "parses public static method":
        class PublicUtils:
            pub static fn helper() -> i32:
                return 100

        expect PublicUtils.helper() == 100

    it "parses private static method":
        class PrivateUtils:
            static fn internal() -> i32:
                return 200

        expect PrivateUtils.internal() == 200

describe "Static methods with generics":
    it "parses static generic method":
        class Container:
            static fn create<T>(value: T) -> T:
                return value

        expect Container.create(42) == 42
        expect Container.create("text") == "text"

describe "Static methods calling other static methods":
    it "calls static method from another static method":
        class Calculator:
            static fn add(a: i32, b: i32) -> i32:
                return a + b

            static fn add_three(a: i32, b: i32, c: i32) -> i32:
                return Calculator.add(Calculator.add(a, b), c)

        expect Calculator.add_three(1, 2, 3) == 6

describe "Static methods with default parameters":
    it "parses static method with default parameter":
        class Builder:
            static fn build(size = 10) -> i32:
                return size

        expect Builder.build() == 10
        expect Builder.build(20) == 20

describe "Static methods returning complex types":
    it "parses static method returning array":
        class ArrayFactory:
            static fn create_array() -> [i32]:
                return [1, 2, 3]

        val arr = ArrayFactory.create_array()
        expect arr.len() == 3

    it "parses static method returning option":
        class OptionFactory:
            static fn some_value() -> Option<i32>:
                return Some(42)

        val opt = OptionFactory.some_value()
        expect opt.is_some() == true

describe "Static method edge cases":
    it "parses static method with no return type":
        class Printer:
            static fn print_hello():
                pass

        Printer.print_hello()
        expect true

    it "parses static method with complex expression":
        class Complex:
            static fn compute() -> i32:
                val x = 10
                val y = 20
                return x + y + 5

        expect Complex.compute() == 35

    it "parses nested static method calls":
        class Nested:
            static fn level1() -> i32:
                return Nested.level2()

            static fn level2() -> i32:
                return 42

        expect Nested.level1() == 42

describe "Static methods in async contexts":
    it "parses async static method":
        class AsyncUtils:
            static async fn fetch() -> i32:
                return 42

        # Note: actual await testing requires async runtime
        expect true

# TODO: Trait implementation with 'implements' keyword not yet supported
# describe "Static methods with traits", skip:
#     it "parses static method in trait implementation":
#         trait Factory:
#             static fn create() -> Self
#
#         class Widget implements Factory:
#             value: i32
#
#             static fn create() -> Widget:
#                 return Widget(value: 0)
#
#         val w = Widget.create()
#         expect w.value == 0
