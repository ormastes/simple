"""
Parser Edge Cases Tests
Feature: Parser Edge Cases (Operators, Keywords, FFI)
Category: System, Parser
Status: In Progress

Tests for parser edge cases including:
- Matrix multiplication (@) operator
- Bitwise XOR (xor) keyword
- super keyword in inheritance
- Array type syntax [T]
"""

describe "Parser Edge Cases":
    """
    Tests for parser edge cases and bug fixes.
    """

    context "Matrix Multiplication Operator":
        it "parses @ operator in expressions":
            val result = 3 @ 4
            expect result == 12

        it "parses @ operator with variables":
            val a = 2
            val b = 5
            val result = a @ b
            expect result == 10

    context "Bitwise XOR Keyword":
        it "parses xor keyword in expressions":
            val result = 5 xor 3
            expect result == 6

        it "parses xor keyword with variables":
            val a = 12
            val b = 7
            val result = a xor b
            expect result == 11

        it "parses xor in complex expressions":
            val result = (5 xor 3) xor 1
            expect result == 7

    context "Super Keyword":
        it "parses super in simple context":
            class Base:
                fn greet():
                    return "Hello"

            class Derived(Base):
                fn greet():
                    val base_msg = super.greet()
                    return base_msg + " World"

            val obj = Derived()
            expect obj.greet() == "Hello World"

    context "Array Type Syntax":
        it "parses array types with square brackets":
            fn takes_array(items: [i64]) -> [i64]:
                return items

            val nums = [1, 2, 3]
            val result = takes_array(nums)
            expect result.length() == 3

        it "parses array return types":
            fn make_array() -> [str]:
                return ["a", "b", "c"]

            val result = make_array()
            expect result[0] == "a"

    context "Operator Precedence":
        it "handles @ and xor together":
            val result = (3 @ 2) xor 5
            expect result == 3  # (3 @ 2) = 6, 6 xor 5 = 3

        it "handles multiple operators":
            val a = 10
            val b = 3
            val c = (a xor b) @ 2
            expect c == 18  # 10 xor 3 = 9, 9 @ 2 = 18
