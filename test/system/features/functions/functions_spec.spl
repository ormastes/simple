"""
# Function Definitions Specification

**Feature IDs:** #1004
**Category:** Language
**Status:** In Progress

Tests for function definition and invocation.
Verifies function parameters, return types, implicit returns, and various calling patterns.
"""

import std.spec

describe "Function Definitions":
    """
    Tests for function definitions, parameter handling, and return behavior.
    Verifies function signatures, parameter passing, type inference, and implicit returns.
    """

    context "basic function definition":
        """
        ### Scenario: Simple Functions

        Tests basic function definitions with parameters and return types.
        """

        it "defines function with explicit return type":
            fn add(a: i32, b: i32) -> i32:
                return a + b
            expect add(2, 3) == 5

        it "uses implicit return of last expression":
            fn multiply(a: i32, b: i32) -> i32:
                a * b
            expect multiply(3, 4) == 12

        it "calls function with no parameters":
            fn get_greeting() -> text:
                "Hello, World!"
            expect get_greeting() == "Hello, World!"

    context "function parameters":
        """
        ### Scenario: Parameter Handling

        Tests various parameter styles and type inference.
        """

        it "passes multiple parameters":
            fn combine(x: i32, y: i32, z: i32) -> i32:
                x + y + z
            expect combine(1, 2, 3) == 6

        it "uses type inference for parameters":
            fn double(x):
                x * 2
            expect double(5) == 10

        it "uses named arguments":
            fn create_point(x: i32, y: i32) -> text:
                "{x}, {y}"
            expect create_point(x: 3, y: 4) == "3, 4"

    context "function return types":
        """
        ### Scenario: Return Behavior

        Tests function return types and implicit returns.
        """

        it "returns single value":
            fn square(x: i32) -> i32:
                x * x
            expect square(5) == 25

        it "returns early with explicit return":
            fn get_sign(x: i32) -> text:
                if x < 0:
                    return "negative"
                "positive"
            expect get_sign(-5) == "negative"

        it "returns without explicit type annotation":
            fn concat(a: text, b: text):
                a + b
            expect concat("hello", "world") == "helloworld"

    context "function with no return":
        """
        ### Scenario: Void Functions

        Tests functions that perform actions without returning values.
        """

        it "executes function with side effects":
            var counter = 0
            fn increment():
                counter = counter + 1
            increment()
            expect counter == 1

        it "calls function multiple times":
            var value = 0
            fn set_value(x: i32):
                value = x
            set_value(42)
            expect value == 42

    context "higher-order functions":
        """
        ### Scenario: Functions as Arguments

        Tests passing functions as parameters and returning functions.
        """

        it "accepts function parameter":
            fn apply(f: fn(i32) -> i32, x: i32) -> i32:
                f(x)
            fn double(n: i32) -> i32:
                n * 2
            expect apply(double, 5) == 10

        it "uses lambda function":
            fn apply(f: fn(i32) -> i32, x: i32) -> i32:
                f(x)
            expect apply(\n: n + 10, 5) == 15

        it "returns function":
            fn make_adder(x: i32) -> fn(i32) -> i32:
                \y: x + y
            val add_five = make_adder(5)
            expect add_five(3) == 8

    context "generic functions":
        """
        ### Scenario: Parametric Functions

        Tests generic functions with type parameters.
        """

        it "defines generic function":
            fn identity<T>(x: T) -> T:
                x
            expect identity(42) == 42

        it "uses generic with constraints":
            fn get_first<T>(items: List<T>) -> Option<T>:
                items.first
            val first = get_first([1, 2, 3])
            expect first == Some(1)

        it "uses multiple type parameters":
            fn pair<A, B>(a: A, b: B) -> text:
                "pair"
            expect pair(1, "hello") == "pair"

    context "recursive functions":
        """
        ### Scenario: Recursion

        Tests recursive function definitions and termination.
        """

        it "defines recursive factorial function":
            fn factorial(n: i32) -> i32:
                if n <= 1:
                    1
                else:
                    n * factorial(n - 1)
            expect factorial(5) == 120

        it "uses tail recursion":
            fn sum_to(n: i32) -> i32:
                if n <= 0:
                    0
                else:
                    n + sum_to(n - 1)
            expect sum_to(10) == 55
