"""
# Config Loader Specification

**Feature ID:** TBD
**Category:** Configuration / File Loading
**Status:** Implemented

## Overview

The config loader provides a Simple-native configuration format using `.spl`
syntax with variable assignments. It supports hierarchical config loading
with directory-based precedence.

## Config File Format

```simple
# Numbers
port = 8080
timeout = 30.5

# Booleans
logging = true
debug = false

# Strings
name = "MyApp"

# Identifiers (constants)
mode = PRODUCTION

# Arrays
ports = [8080, 8081, 8082]

# Nested values (dotted keys)
train.epochs = 100
train.lr = 0.001
```

## Hierarchy & Precedence

Config files are searched from the current directory up to the project root.
Configs closer to the current directory override those higher in the hierarchy.

```
/project/__init__.spl          (lowest precedence)
/project/subdir/__init__.spl   (highest precedence)
```
"""

use config


# ============================================================================
# Config File Parsing
# ============================================================================

describe "Config File Parsing":
    """
    Parse Simple-syntax config files into Config objects.
    """

    it "parses basic integers":
        val content = "port = 8080"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["port"]).to(eq(8080))
            case Err(_):
                fail("Parse failed")

    it "parses floats":
        val content = "timeout = 30.5"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["timeout"]).to(eq(30.5))
            case Err(_):
                fail("Parse failed")

    it "parses booleans":
        val content = "logging = true\ndebug = false"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["logging"]).to(eq(true))
                expect(dict["debug"]).to(eq(false))
            case Err(_):
                fail("Parse failed")

    it "parses strings":
        val content = "name = \"MyApp\""
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["name"]).to(eq("MyApp"))
            case Err(_):
                fail("Parse failed")

    it "parses identifiers as constants":
        val content = "mode = PRODUCTION"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["mode"]).to(eq("PRODUCTION"))
            case Err(_):
                fail("Parse failed")

    it "parses arrays":
        val content = "ports = [8080, 8081, 8082]"
        match config.parse_config_file(content):
            case Ok(dict):
                val ports = dict["ports"]
                expect(ports.len()).to(eq(3))
                expect(ports[0]).to(eq(8080))
                expect(ports[1]).to(eq(8081))
                expect(ports[2]).to(eq(8082))
            case Err(_):
                fail("Parse failed")

    it "parses nested values with dotted keys":
        val content = "train.epochs = 100\ntrain.lr = 0.001"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["train"]["epochs"]).to(eq(100))
                expect(dict["train"]["lr"]).to(eq(0.001))
            case Err(_):
                fail("Parse failed")

    it "skips comments":
        val content = "# This is a comment\nport = 8080\n# Another comment"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["port"]).to(eq(8080))
            case Err(_):
                fail("Parse failed")

    it "skips empty lines":
        val content = "port = 8080\n\nlogging = true"
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["port"]).to(eq(8080))
                expect(dict["logging"]).to(eq(true))
            case Err(_):
                fail("Parse failed")

    it "handles multiline config":
        val content = """
            port = 8080
            timeout = 30.5
            logging = true
            app_name = "MyApp"
            mode = PRODUCTION
        """
        match config.parse_config_file(content):
            case Ok(dict):
                expect(dict["port"]).to(eq(8080))
                expect(dict["timeout"]).to(eq(30.5))
                expect(dict["logging"]).to(eq(true))
                expect(dict["app_name"]).to(eq("MyApp"))
                expect(dict["mode"]).to(eq("PRODUCTION"))
            case Err(_):
                fail("Parse failed")


# ============================================================================
# File Loading
# ============================================================================

describe "Config File Loading":
    """
    Load config from files on disk.
    """

    it "loads basic config from file":
        val fixture_path = "simple/test/fixtures/config/basic_config.spl"
        match config.from_file(fixture_path):
            case Ok(cfg):
                match cfg.get("port"):
                    case Some(p): expect(p).to(eq(8080))
                    case None: fail("Port not found")
                match cfg.get("logging"):
                    case Some(l): expect(l).to(eq(true))
                    case None: fail("Logging not found")
            case Err(msg):
                fail("Load failed: " + msg)

    it "loads nested config from file":
        val fixture_path = "simple/test/fixtures/config/nested_config.spl"
        match config.from_file(fixture_path):
            case Ok(cfg):
                match cfg.get("server.port"):
                    case Some(p): expect(p).to(eq(8080))
                    case None: fail("server.port not found")
                match cfg.get("train.epochs"):
                    case Some(e): expect(e).to(eq(100))
                    case None: fail("train.epochs not found")
            case Err(msg):
                fail("Load failed: " + msg)

    it "returns error for non-existent file":
        match config.from_file("nonexistent.spl"):
            case Ok(_):
                fail("Should have failed")
            case Err(msg):
                # Success - expected error
                pass


# ============================================================================
# Hierarchical Loading
# ============================================================================

describe "Hierarchical Config Loading":
    """
    Load and merge configs from directory hierarchy.
    """

    it "loads from single config file":
        val root_path = "simple/test/fixtures/config/hierarchy/project_root.spl"
        match config.from_hierarchy(root_path):
            case Ok(cfg):
                match cfg.get("port"):
                    case Some(p): expect(p).to(eq(8080))
                    case None: fail("Port not found")
                match cfg.get("project_name"):
                    case Some(n): expect(n).to(eq("MyProject"))
                    case None: fail("Project name not found")
            case Err(msg):
                fail("Load failed: " + msg)

    it "returns empty config when no files found":
        match config.from_hierarchy("/nonexistent/path"):
            case Ok(cfg):
                match cfg.get("anything"):
                    case Some(_): fail("Should be empty")
                    case None: pass  # Expected
            case Err(msg):
                fail("Should return empty config, not error: " + msg)


# ============================================================================
# Config Access
# ============================================================================

describe "Config Access":
    """
    Access config values with dotted path syntax.
    """

    it "gets simple values":
        val cfg = config.from_dict({"port": 8080, "logging": true})
        match cfg.get("port"):
            case Some(p): expect(p).to(eq(8080))
            case None: fail("Port not found")

    it "gets nested values with dotted path":
        val cfg = config.from_dict({"server": {"port": 8080}})
        match cfg.get("server.port"):
            case Some(p): expect(p).to(eq(8080))
            case None: fail("Nested value not found")

    it "returns None for missing keys":
        val cfg = config.from_dict({"port": 8080})
        match cfg.get("missing"):
            case Some(_): fail("Should be None")
            case None: pass  # Expected


# ============================================================================
# Config Merging
# ============================================================================

describe "Config Merging":
    """
    Merge multiple configs with precedence.
    """

    it "merges configs with overlay precedence":
        val base = config.from_dict({"a": 1, "b": 2})
        val overlay = config.from_dict({"b": 3, "c": 4})
        val merged = config.merge(base, overlay)

        match merged.get("a"):
            case Some(v): expect(v).to(eq(1))
            case None: fail("a not found")
        match merged.get("b"):
            case Some(v): expect(v).to(eq(3))  # Overlay wins
            case None: fail("b not found")
        match merged.get("c"):
            case Some(v): expect(v).to(eq(4))
            case None: fail("c not found")
