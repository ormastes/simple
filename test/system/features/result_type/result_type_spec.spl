# @pending
# @skip - Uses unsupported keyword: with
"""
# Result Type Specification

**Feature ID:** #RESULT-001
**Category:** Language | Types
**Status:** Implemented

## Overview

Tests for the Result type representing success or error outcomes,
including constructors, pattern matching, and safe unwrapping mechanisms.

## Syntax

```simple
val success: Result<i32, text> = Ok(42)
val failure: Result<i32, text> = Err("error")

match result:
    Ok(value) => print "Success: {value}"
    Err(msg) => print "Error: {msg}"

val unwrapped = result.unwrap()              # Raises if Err
val safe = result.unwrap_or(0)               # Default if Err
val propagated = fallible_operation()?       # Early return on Err
```
"""



# ============================================================================
# Test Group 1: Basic Result Usage
# ============================================================================

describe "Result Type Basic Usage":
    """
    ## Result Construction and Access

    Verifies creation of Ok/Err values, basic unwrapping,
    and pattern matching with Result types.
    """

    context "Ok values":
        it "creates Ok with value":
            val res = Ok(42)
            expect res.unwrap() == 42

        it "checks Ok is ok":
            val res = Ok(10)
            expect res.ok.?

        it "checks Ok is not err":
            val res = Ok(5)
            expect not res.err.?

    context "Err values":
        it "creates Err with error":
            val res = Err("error message")
            expect res.err.?

        it "checks Err is not ok":
            val res = Err("oops")
            expect not res.ok.?

        it "uses unwrap_or for Err":
            val res = Err("error")
            expect res.unwrap_or(99) == 99


# ============================================================================
# Test Group 2: Result from Functions
# ============================================================================

describe "Result from Functions":
    """
    ## Functions Returning Result

    Tests for functions that return Result types for error handling.
    """

    it "returns Ok from function":
        fn safe_divide(a, b):
            if b == 0:
                return Err("division by zero")
            return Ok(a / b)

        val r = safe_divide(20, 4)
        expect r.unwrap() == 5

    it "returns Err from function":
        fn safe_divide(a, b):
            if b == 0:
                return Err("division by zero")
            return Ok(a / b)

        val r = safe_divide(10, 0)
        expect r.unwrap_or(-1) == -1

    it "chains Result operations":
        fn step1(x):
            if x < 0:
                return Err("negative")
            return Ok(x + 10)

        fn step2(x):
            if x > 100:
                return Err("too large")
            return Ok(x * 2)

        val r1 = step1(5)
        val r2 = r1.map(\x: step2(x).unwrap_or(-1)
        expect r2.unwrap() == 30  # (5 + 10) * 2


# ============================================================================
# Test Group 3: Question Mark Operator
# ============================================================================

describe "Question Mark Operator":
    """
    ## ? Operator for Error Propagation

    Tests the ? operator that propagates errors by early return.
    """

    it "propagates Ok value":
        fn may_fail(x) -> Result<i64, text>:
            if x < 0:
                return Err("negative")
            return Ok(x * 2)

        fn caller(x):
            val result = may_fail(x)?
            return Ok(result + 1)

        val res = caller(5)
        expect res.unwrap() == 11  # 5 * 2 + 1

    it "propagates Err to caller":
        fn may_fail(x) -> Result<i64, text>:
            if x < 0:
                return Err("negative")
            return Ok(x * 2)

        fn caller(x):
            val result = may_fail(x)?
            return Ok(result + 1)

        val res = caller(-5)
        expect res.unwrap_or(-99) == -99

    it "chains multiple ? operators":
        fn step1(x):
            if x < 0:
                return Err("step1 failed")
            return Ok(x + 10)

        fn step2(x):
            if x > 100:
                return Err("step2 failed")
            return Ok(x * 2)

        fn pipeline(x):
            val a = step1(x)?
            val b = step2(a)?
            return Ok(b)

        val res = pipeline(5)
        expect res.unwrap() == 30  # (5 + 10) * 2


# ============================================================================
# Test Group 4: Result Pattern Matching
# ============================================================================

describe "Result Pattern Matching":
    """
    ## Pattern Matching with Result

    Tests pattern matching on Result types with Ok and Err variants.
    """

    it "matches Ok variant":
        val res = Ok(100)
        var output = 0
        match res:
            case Ok(value):
                output = value
            case Err(_):
                output = -1
        expect output == 100

    it "matches Err variant":
        val res = Err("failure")
        var output = 0
        match res:
            case Ok(value):
                output = value
            case Err(_):
                output = -1
        expect output == -1

    it "uses if let with Ok":
        val res = Ok(100)
        var output = 0
        if let Ok(value) = res:
            output = value
        expect output == 100

    it "uses if let with Err else":
        val res: Result<i64, text> = Err("error")
        var output = 0
        if let Ok(value) = res:
            output = value
        else:
            output = -1
        expect output == -1

