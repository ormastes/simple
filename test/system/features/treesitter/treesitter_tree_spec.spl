"""
# TreeSitter Tree Specification

**Feature IDs:** #TS-TREE-001 to #TS-TREE-020
**Category:** Infrastructure | Parser
**Status:** Implemented

Tests the Tree and Node data structures for the TreeSitter parser,
including node navigation, field access, and span tracking.

## API

```simple
use std.parser.treesitter.{Tree, Node, NodeId, Span, NodeArena}

val tree = parser.parse(source)?
val root = tree.root()?
val child = root.child(0)?
val field = root.child_by_field("name")?
```
"""

use std.spec
use std.parser.treesitter.{TreeSitterParser, Tree, Node, NodeId, Span, NodeArena}


# ============================================================================
# Test Group 1: Tree Root Access
# ============================================================================

describe "TreeSitter Tree Root":
    """
    ## Root Node Access

    Tests accessing the root node of a parsed tree.
    """

    it "returns root node from tree":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val root = tree.root()
        expect root.?

    it "root is module type":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val root = tree.root().unwrap()
        expect root.kind == "module"

    it "root has children":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val root = tree.root().unwrap()
        expect root.child_count() > 0


# ============================================================================
# Test Group 2: Node Children Access
# ============================================================================

describe "TreeSitter Node Children":
    """
    ## Child Node Navigation

    Tests navigating to child nodes.
    """

    it "accesses first child":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val root = tree.root().unwrap()
        val first = root.child(0)
        expect first.?

    it "returns None for invalid index":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val root = tree.root().unwrap()
        val invalid = root.child(1000)
        expect not invalid.?

    it "returns None for negative index":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val root = tree.root().unwrap()
        val invalid = root.child(-1)
        expect not invalid.?

    it "counts children correctly":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = """val x = 1
val y = 2
val z = 3"""
        val tree = parser.parse(source).unwrap()
        val root = tree.root().unwrap()
        expect root.child_count() >= 3


# ============================================================================
# Test Group 3: Node Field Access
# ============================================================================

describe "TreeSitter Node Fields":
    """
    ## Named Field Access

    Tests accessing named fields on nodes.
    """

    it "accesses field by name":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn test():\n    42"
        val tree = parser.parse(source).unwrap()
        val root = tree.root().unwrap()
        # Function should have named fields
        expect root.child_count() > 0

    it "returns None for missing field":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val root = tree.root().unwrap()
        val missing = root.child_by_field("nonexistent")
        expect not missing.?


# ============================================================================
# Test Group 4: Node Span Information
# ============================================================================

describe "TreeSitter Node Spans":
    """
    ## Source Position Tracking

    Tests that nodes have correct source position information.
    """

    context "byte positions":
        it "has valid start byte":
            var parser = TreeSitterParser.new("simple").unwrap()
            val tree = parser.parse("val x = 42").unwrap()
            val root = tree.root().unwrap()
            expect root.span.start_byte >= 0

        it "has valid end byte":
            var parser = TreeSitterParser.new("simple").unwrap()
            val tree = parser.parse("val x = 42").unwrap()
            val root = tree.root().unwrap()
            expect root.span.end_byte > root.span.start_byte

        it "end byte covers full source":
            var parser = TreeSitterParser.new("simple").unwrap()
            val source = "val x = 42"
            val tree = parser.parse(source).unwrap()
            val root = tree.root().unwrap()
            expect root.span.end_byte >= source.len() as i64

    context "line positions":
        it "has valid start line":
            var parser = TreeSitterParser.new("simple").unwrap()
            val tree = parser.parse("val x = 42").unwrap()
            val root = tree.root().unwrap()
            expect root.span.start_line >= 1

        it "tracks multi-line spans":
            var parser = TreeSitterParser.new("simple").unwrap()
            val source = "val x = 1\nval y = 2\nval z = 3"
            val tree = parser.parse(source).unwrap()
            val root = tree.root().unwrap()
            expect root.span.end_line >= root.span.start_line

    context "column positions":
        it "has valid start column":
            var parser = TreeSitterParser.new("simple").unwrap()
            val tree = parser.parse("val x = 42").unwrap()
            val root = tree.root().unwrap()
            expect root.span.start_column >= 1


# ============================================================================
# Test Group 5: Span Contains Method
# ============================================================================

describe "TreeSitter Span Contains":
    """
    ## Position Containment Check

    Tests the span.contains(line, column) method.
    """

    it "contains point in single-line span":
        val span = Span(
            start_byte: 0, end_byte: 10,
            start_line: 1, end_line: 1,
            start_column: 1, end_column: 11
        )
        expect span.contains(1, 5)

    it "does not contain point outside span":
        val span = Span(
            start_byte: 0, end_byte: 10,
            start_line: 1, end_line: 1,
            start_column: 1, end_column: 11
        )
        expect not span.contains(1, 15)

    it "contains point in multi-line span":
        val span = Span(
            start_byte: 0, end_byte: 30,
            start_line: 1, end_line: 3,
            start_column: 1, end_column: 5
        )
        expect span.contains(2, 5)


# ============================================================================
# Test Group 6: Node Kind Information
# ============================================================================

describe "TreeSitter Node Kinds":
    """
    ## Node Type Identification

    Tests node kind identification and naming.
    """

    it "reports node kind":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val root = tree.root().unwrap()
        expect root.kind.len() > 0

    it "identifies named vs anonymous nodes":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val root = tree.root().unwrap()
        # Root should be a named node
        expect root.is_named()


# ============================================================================
# Test Group 7: Node Text Extraction
# ============================================================================

describe "TreeSitter Node Text":
    """
    ## Source Text Access

    Tests accessing source text for nodes.
    """

    it "extracts node text":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val root = tree.root().unwrap()
        # Root should have cached text
        expect root.text.len() > 0


# ============================================================================
# Test Group 8: Tree Source Access
# ============================================================================

describe "TreeSitter Tree Source":
    """
    ## Source Code Preservation

    Tests that the tree preserves the original source.
    """

    it "preserves source text":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 42"
        val tree = parser.parse(source).unwrap()
        expect tree.source == source

    it "preserves multi-line source":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = """fn add(a, b):
    a + b"""
        val tree = parser.parse(source).unwrap()
        expect tree.source == source


# ============================================================================
# Test Group 9: Node Arena
# ============================================================================

describe "TreeSitter Node Arena":
    """
    ## Arena Allocation

    Tests the arena allocator for nodes.
    """

    it "creates empty arena":
        var arena = NodeArena.new()
        # New arena should be valid
        expect true

    it "allocates node":
        var arena = NodeArena.new()
        val node = Node(
            id: NodeId(index: 0, generation: 0),
            kind: "test",
            span: Span(start_byte: 0, end_byte: 4, start_line: 1, end_line: 1, start_column: 1, end_column: 5),
            children: [],
            fields: {},
            has_error: false,
            text: "test"
        )
        val id = arena.alloc(node)
        expect id.index == 0

    it "retrieves allocated node":
        var arena = NodeArena.new()
        val node = Node(
            id: NodeId(index: 0, generation: 0),
            kind: "identifier",
            span: Span(start_byte: 0, end_byte: 3, start_line: 1, end_line: 1, start_column: 1, end_column: 4),
            children: [],
            fields: {},
            has_error: false,
            text: "foo"
        )
        val id = arena.alloc(node)
        val retrieved = arena.get(id)
        expect retrieved.?

    it "returns None for invalid generation":
        var arena = NodeArena.new()
        val bad_id = NodeId(index: 0, generation: 999)
        val result = arena.get(bad_id)
        expect not result.?


# ============================================================================
# Test Group 10: Tree Version
# ============================================================================

describe "TreeSitter Tree Version":
    """
    ## Version Tracking

    Tests tree version for incremental parsing.
    """

    it "initial tree has version 0":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        expect tree.version == 0

    it "preserves version through access":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val v1 = tree.version
        val _ = tree.root()
        expect tree.version == v1

