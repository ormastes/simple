# @skip - treesitter incremental parsing syntax issues
# @pending
"""
# TreeSitter Incremental Parsing Specification

**Feature IDs:** #TS-INC-001 to #TS-INC-020
**Category:** Infrastructure | Parser
**Status:** Implemented

Tests the incremental parsing system for efficient re-parsing
after document edits.

## API

```simple
use std.parser.treesitter.edits.{InputEdit, Point, compute_edits)

val edits = compute_edits(old_text, new_text)
val new_tree = parser.parse_incremental(new_source, old_tree, edits)?
```
"""

use std.parser.treesitter.edits.{
    InputEdit, Point, compute_edits, DiffOp, count_lines, compute_end_point
)
use std.parser.treesitter (TreeSitterParser, Tree, Span)


# ============================================================================
# Test Group 1: Point Structure
# ============================================================================

describe "TreeSitter Point":
    """
    ## Source Position

    Tests the Point (line, column) structure.
    """

    it "creates point":
        val p = Point.new(1, 5)
        expect p.line == 1
        expect p.column == 5

    it "compares points on same line":
        val p1 = Point.new(1, 5)
        val p2 = Point.new(1, 10)
        expect p1.is_before(p2)
        expect p2.is_after(p1)

    it "compares points on different lines":
        val p1 = Point.new(1, 100)
        val p2 = Point.new(2, 1)
        expect p1.is_before(p2)
        expect p2.is_after(p1)

    it "checks point equality":
        val p1 = Point.new(3, 7)
        val p2 = Point.new(3, 7)
        expect p1.equals(p2)

    it "compare returns negative for before":
        val p1 = Point.new(1, 1)
        val p2 = Point.new(2, 1)
        expect p1.compare(p2) < 0

    it "compare returns positive for after":
        val p1 = Point.new(2, 1)
        val p2 = Point.new(1, 1)
        expect p1.compare(p2) > 0

    it "compare returns zero for equal":
        val p1 = Point.new(5, 10)
        val p2 = Point.new(5, 10)
        expect p1.compare(p2) == 0


# ============================================================================
# Test Group 2: InputEdit Structure
# ============================================================================

describe "TreeSitter InputEdit":
    """
    ## Edit Description

    Tests the InputEdit structure for describing changes.
    """

    it "creates InputEdit":
        val edit = InputEdit.new(
            0, 5, 3,
            Point.new(1, 1),
            Point.new(1, 6),
            Point.new(1, 4)
        )
        expect edit.start_byte == 0
        expect edit.old_end_byte == 5
        expect edit.new_end_byte == 3

    it "checks if edit affects span":
        val edit = InputEdit.new(
            10, 15, 12,
            Point.new(1, 11),
            Point.new(1, 16),
            Point.new(1, 13)
        )
        val span = Span(
            start_byte: 8, end_byte: 20,
            start_line: 1, end_line: 1,
            start_column: 9, end_column: 21
        )
        expect edit.affects_span(span)

    it "edit does not affect span before":
        val edit = InputEdit.new(
            100, 110, 105,
            Point.new(5, 1),
            Point.new(5, 11),
            Point.new(5, 6)
        )
        val span = Span(
            start_byte: 0, end_byte: 50,
            start_line: 1, end_line: 2,
            start_column: 1, end_column: 10
        )
        expect not edit.affects_span(span)


# ============================================================================
# Test Group 3: Byte Adjustment
# ============================================================================

describe "TreeSitter Edit Byte Adjustment":
    """
    ## Position Adjustment After Edit

    Tests adjusting byte positions after edits.
    """

    it "does not adjust byte before edit":
        val edit = InputEdit.new(
            10, 15, 12,
            Point.new(1, 11), Point.new(1, 16), Point.new(1, 13)
        )
        val adjusted = edit.adjust_byte(5)
        expect adjusted == 5

    it "maps byte inside edit to start":
        val edit = InputEdit.new(
            10, 15, 12,
            Point.new(1, 11), Point.new(1, 16), Point.new(1, 13)
        )
        val adjusted = edit.adjust_byte(12)
        expect adjusted == 10

    it "shifts byte after edit by delta":
        val edit = InputEdit.new(
            10, 15, 12,  # Delete 5, insert 2 = delta -3
            Point.new(1, 11), Point.new(1, 16), Point.new(1, 13)
        )
        val adjusted = edit.adjust_byte(20)
        expect adjusted == 17  # 20 + (-3)


# ============================================================================
# Test Group 4: Point Adjustment
# ============================================================================

describe "TreeSitter Edit Point Adjustment":
    """
    ## Line/Column Adjustment

    Tests adjusting point positions after edits.
    """

    it "does not adjust point before edit":
        val edit = InputEdit.new(
            10, 15, 12,
            Point.new(2, 1), Point.new(2, 6), Point.new(2, 3)
        )
        val adjusted = edit.adjust_point(Point.new(1, 5))
        expect adjusted.line == 1
        expect adjusted.column == 5

    it "maps point inside edit to start":
        val edit = InputEdit.new(
            10, 15, 12,
            Point.new(2, 1), Point.new(2, 6), Point.new(2, 3)
        )
        val adjusted = edit.adjust_point(Point.new(2, 3))
        expect adjusted.equals(Point.new(2, 1))


# ============================================================================
# Test Group 5: Compute Edits
# ============================================================================

describe "TreeSitter Compute Edits":
    """
    ## Edit Detection

    Tests computing edits between texts.
    """

    it "returns empty for identical texts":
        val edits = compute_edits("hello", "hello")
        expect edits.len() == 0

    it "detects insertion":
        val edits = compute_edits("ab", "abc")
        expect edits.len() >= 1

    it "detects deletion":
        val edits = compute_edits("abc", "ab")
        expect edits.len() >= 1

    it "detects replacement":
        val edits = compute_edits("hello", "hallo")
        expect edits.len() >= 1

    it "handles empty old text":
        val edits = compute_edits("", "hello")
        expect edits.len() >= 1

    it "handles empty new text":
        val edits = compute_edits("hello", "")
        expect edits.len() >= 1


# ============================================================================
# Test Group 6: Diff Operations
# ============================================================================

describe "TreeSitter Diff Operations":
    """
    ## Diff Operation Types

    Tests the different diff operation types.
    """

    it "creates Equal operation":
        val op = DiffOp.Equal(start: 0, len: 5)
        expect true

    it "creates Delete operation":
        val op = DiffOp.Delete(start: 0, len: 3)
        expect true

    it "creates Insert operation":
        val op = DiffOp.Insert(start: 0, len: 2)
        expect true


# ============================================================================
# Test Group 7: Line Counting
# ============================================================================

describe "TreeSitter Line Counting":
    """
    ## Line Number Tracking

    Tests counting lines in text.
    """

    it "counts single line":
        val count = count_lines("hello")
        expect count == 1

    it "counts multiple lines":
        val count = count_lines("line1\nline2\nline3")
        expect count == 3

    it "counts empty string as one line":
        val count = count_lines("")
        expect count == 1

    it "counts trailing newline":
        val count = count_lines("line1\nline2\n")
        expect count == 3


# ============================================================================
# Test Group 8: End Point Computation
# ============================================================================

describe "TreeSitter End Point":
    """
    ## Computing End Position

    Tests computing the end point of text.
    """

    it "computes end point of empty string":
        val end = compute_end_point("")
        expect end.line == 1
        expect end.column == 1

    it "computes end point of single line":
        val end = compute_end_point("hello")
        expect end.line == 1
        expect end.column == 6

    it "computes end point of multiple lines":
        val end = compute_end_point("line1\nline2")
        expect end.line == 2
        expect end.column == 6


# ============================================================================
# Test Group 9: Incremental Parse Integration
# ============================================================================

describe "TreeSitter Incremental Parsing":
    """
    ## Incremental Re-Parse

    Tests incremental parsing after edits.
    """

    it "parses after simple edit":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree1 = parser.parse("val x = 42").unwrap()

        # Parse updated source
        val tree2 = parser.parse("val x = 43").unwrap()
        expect tree2.root().?

    it "parses after insertion":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree1 = parser.parse("val x = 1").unwrap()

        # Insert more code
        val tree2 = parser.parse("val x = 1\nval y = 2").unwrap()
        expect tree2.root().?

    it "parses after deletion":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree1 = parser.parse("val x = 1\nval y = 2").unwrap()

        # Delete second line
        val tree2 = parser.parse("val x = 1").unwrap()
        expect tree2.root().?


# ============================================================================
# Test Group 10: Multi-Line Edits
# ============================================================================

describe "TreeSitter Multi-Line Edits":
    """
    ## Complex Edit Handling

    Tests edits spanning multiple lines.
    """

    it "handles multi-line insertion":
        val old_text = "val x = 1"
        val new_text = """val x = 1
val y = 2
val z = 3"""
        val edits = compute_edits(old_text, new_text)
        expect edits.len() >= 1

    it "handles multi-line deletion":
        val old_text = """val x = 1
val y = 2
val z = 3"""
        val new_text = "val x = 1"
        val edits = compute_edits(old_text, new_text)
        expect edits.len() >= 1

    it "handles mixed edits":
        val old_text = """fn test():
    val x = 1
    val y = 2"""
        val new_text = """fn test():
    val x = 10
    val z = 3"""
        val edits = compute_edits(old_text, new_text)
        expect edits.len() >= 1


# ============================================================================
# Test Group 11: Edit Performance
# ============================================================================

describe "TreeSitter Edit Performance":
    """
    ## Efficient Edit Detection

    Tests that edit detection is efficient.
    """

    it "handles large identical texts quickly":
        var large = ""
        for i in 0..100:
            large = large + "val x_{i} = {i}\n"
        val edits = compute_edits(large, large)
        expect edits.len() == 0

    it "handles single character change in large text":
        var base = "val x = "
        for i in 0..50:
            base = base + "a"
        val modified = base + "b"  # Add one char
        val edits = compute_edits(base, modified)
        expect edits.len() >= 1

