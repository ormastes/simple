"""
# TreeSitter Cursor Specification

**Feature IDs:** #TS-CURSOR-001 to #TS-CURSOR-015
**Category:** Infrastructure | Parser
**Status:** Implemented

Tests the TreeCursor for efficient tree traversal, including
child/sibling/parent navigation and depth tracking.

## API

```simple
use std.parser.treesitter.{TreeSitterParser, TreeCursor}

val tree = parser.parse(source)?
var cursor = tree.walk()
cursor.goto_first_child()
cursor.goto_next_sibling()
cursor.goto_parent()
```
"""

use std.spec
use std.parser.treesitter.{TreeSitterParser, Tree, Node, TreeCursor}


# ============================================================================
# Test Group 1: Cursor Creation
# ============================================================================

describe "TreeSitter Cursor Creation":
    """
    ## Creating Tree Cursors

    Tests cursor initialization from trees.
    """

    it "creates cursor from tree":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        # Cursor should be valid
        expect cursor.node().?

    it "cursor starts at root":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        val root = tree.root().unwrap()
        val cursor_node = cursor.node().unwrap()
        expect cursor_node.kind == root.kind

    it "cursor starts at depth 0":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        expect cursor.depth == 0


# ============================================================================
# Test Group 2: Navigate to First Child
# ============================================================================

describe "TreeSitter Cursor First Child":
    """
    ## Descending to Children

    Tests navigation to first child node.
    """

    it "goes to first child":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        val moved = cursor.goto_first_child()
        expect moved

    it "returns false when no children":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("42").unwrap()
        var cursor = tree.walk()
        # Navigate to a leaf node
        cursor.goto_first_child()
        # Try to go deeper - might fail if at leaf
        val at_root_child = cursor.node().?
        expect at_root_child

    it "increases depth after first child":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        val initial_depth = cursor.depth
        cursor.goto_first_child()
        expect cursor.depth == initial_depth + 1

    it "updates current node after first child":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        val root_kind = cursor.node().unwrap().kind
        cursor.goto_first_child()
        val child_kind = cursor.node().unwrap().kind
        # Child should be different from root (or at least we moved)
        expect cursor.depth == 1


# ============================================================================
# Test Group 3: Navigate to Next Sibling
# ============================================================================

describe "TreeSitter Cursor Next Sibling":
    """
    ## Sibling Navigation

    Tests navigation to next sibling node.
    """

    it "goes to next sibling":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = """val x = 1
val y = 2"""
        val tree = parser.parse(source).unwrap()
        var cursor = tree.walk()
        cursor.goto_first_child()  # First statement
        val moved = cursor.goto_next_sibling()
        # May or may not have sibling depending on structure
        expect true  # Test cursor behavior

    it "returns false when no more siblings":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        # Root has no siblings
        val moved = cursor.goto_next_sibling()
        expect not moved

    it "maintains depth when moving to sibling":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = """val x = 1
val y = 2"""
        val tree = parser.parse(source).unwrap()
        var cursor = tree.walk()
        cursor.goto_first_child()
        val depth_before = cursor.depth
        cursor.goto_next_sibling()
        expect cursor.depth == depth_before


# ============================================================================
# Test Group 4: Navigate to Parent
# ============================================================================

describe "TreeSitter Cursor Parent":
    """
    ## Ascending to Parent

    Tests navigation back to parent node.
    """

    it "goes to parent":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        cursor.goto_first_child()
        val moved = cursor.goto_parent()
        expect moved

    it "returns false at root":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        val moved = cursor.goto_parent()
        expect not moved

    it "decreases depth after parent":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        cursor.goto_first_child()
        val depth_before = cursor.depth
        cursor.goto_parent()
        expect cursor.depth == depth_before - 1

    it "returns to original node after child-parent":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        val original_kind = cursor.node().unwrap().kind
        cursor.goto_first_child()
        cursor.goto_parent()
        val after_kind = cursor.node().unwrap().kind
        expect original_kind == after_kind


# ============================================================================
# Test Group 5: Deep Traversal
# ============================================================================

describe "TreeSitter Cursor Deep Traversal":
    """
    ## Multi-Level Navigation

    Tests navigating multiple levels deep.
    """

    it "traverses multiple levels":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn test():\n    if x:\n        y"
        val tree = parser.parse(source).unwrap()
        var cursor = tree.walk()
        cursor.goto_first_child()  # Level 1
        cursor.goto_first_child()  # Level 2
        expect cursor.depth >= 2

    it "tracks parent stack correctly":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn test():\n    val x = 42"
        val tree = parser.parse(source).unwrap()
        var cursor = tree.walk()

        # Go down
        cursor.goto_first_child()
        cursor.goto_first_child()

        # Come back up
        cursor.goto_parent()
        cursor.goto_parent()

        expect cursor.depth == 0


# ============================================================================
# Test Group 6: Cursor Node Access
# ============================================================================

describe "TreeSitter Cursor Node Access":
    """
    ## Current Node Access

    Tests accessing the current node from cursor.
    """

    it "gets current node":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        val node = cursor.node()
        expect node.?

    it "node has valid kind":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        val node = cursor.node().unwrap()
        expect node.kind.len() > 0

    it "node changes after navigation":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        val root_node = cursor.node().unwrap()
        cursor.goto_first_child()
        val child_node = cursor.node().unwrap()
        # Nodes may have same kind but different positions
        expect cursor.depth == 1


# ============================================================================
# Test Group 7: Full Tree Walk
# ============================================================================

describe "TreeSitter Cursor Full Walk":
    """
    ## Complete Tree Traversal

    Tests walking the entire tree.
    """

    it "can visit all nodes":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        var cursor = tree.walk()
        var visited = 0

        # Simple pre-order traversal
        visited = visited + 1  # Count root
        if cursor.goto_first_child():
            visited = visited + 1
            while cursor.goto_next_sibling():
                visited = visited + 1
            cursor.goto_parent()

        expect visited >= 1

    it "visits nested structure":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn add(a, b):\n    a + b"
        val tree = parser.parse(source).unwrap()
        var cursor = tree.walk()

        # Count nodes at each level
        var count = 1  # root
        if cursor.goto_first_child():
            count = count + 1
            if cursor.goto_first_child():
                count = count + 1
                cursor.goto_parent()
            cursor.goto_parent()

        expect count >= 2


# ============================================================================
# Test Group 8: Cursor Reset
# ============================================================================

describe "TreeSitter Cursor Navigation Reset":
    """
    ## Resetting Cursor Position

    Tests returning cursor to specific positions.
    """

    it "can return to root by going to parent repeatedly":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn test():\n    val x = 1\n    val y = 2"
        val tree = parser.parse(source).unwrap()
        var cursor = tree.walk()

        # Navigate deep
        cursor.goto_first_child()
        cursor.goto_first_child()

        # Return to root
        while cursor.goto_parent():
            pass

        expect cursor.depth == 0


# ============================================================================
# Test Group 9: Complex Navigation Patterns
# ============================================================================

describe "TreeSitter Cursor Complex Patterns":
    """
    ## Real-World Navigation

    Tests complex navigation patterns used in practice.
    """

    it "navigates function structure":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = """fn calculate(x, y):
    val result = x + y
    return result"""
        val tree = parser.parse(source).unwrap()
        var cursor = tree.walk()

        # Navigate into function
        cursor.goto_first_child()
        expect cursor.node().?

    it "navigates if-else structure":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = """if x > 0:
    positive = true
else:
    positive = false"""
        val tree = parser.parse(source).unwrap()
        var cursor = tree.walk()

        cursor.goto_first_child()
        expect cursor.node().?

