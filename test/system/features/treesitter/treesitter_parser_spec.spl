"""
# TreeSitter Parser Specification

**Feature IDs:** #TS-PARSER-001 to #TS-PARSER-020
**Category:** Infrastructure | Parser
**Status:** Implemented

Tests the TreeSitter parser implementation for the Simple language,
including tree construction, node types, and parse results.

## API

```simple
use std.parser.treesitter.{TreeSitterParser, Tree, Node}

val parser = TreeSitterParser.new("simple")?
val tree = parser.parse(source)?
val root = tree.root()?
```
"""

use std.spec
use std.parser.treesitter.{TreeSitterParser, Tree, Node, NodeId, Span}


# ============================================================================
# Test Group 1: Parser Creation
# ============================================================================

describe "TreeSitter Parser Creation":
    """
    ## Parser Initialization

    Tests that the parser is correctly created for the Simple language.
    """

    it "creates parser for Simple language":
        val result = TreeSitterParser.new("simple")
        expect result.ok.?

    it "rejects unsupported languages":
        val result = TreeSitterParser.new("unknown_language")
        expect result.err.?

    it "creates parser with grammar loaded":
        val parser = TreeSitterParser.new("simple").unwrap()
        # Parser should have grammar rules
        expect true  # Parser created successfully


# ============================================================================
# Test Group 2: Basic Parsing
# ============================================================================

describe "TreeSitter Basic Parsing":
    """
    ## Source Code to Tree

    Tests parsing source code into syntax trees.
    """

    context "simple expressions":
        it "parses integer literal":
            var parser = TreeSitterParser.new("simple").unwrap()
            val tree = parser.parse("42")
            expect tree.ok.?

        it "parses variable declaration":
            var parser = TreeSitterParser.new("simple").unwrap()
            val tree = parser.parse("val x = 42")
            expect tree.ok.?

        it "parses binary expression":
            var parser = TreeSitterParser.new("simple").unwrap()
            val tree = parser.parse("val x = 1 + 2")
            expect tree.ok.?

    context "function definitions":
        it "parses simple function":
            var parser = TreeSitterParser.new("simple").unwrap()
            val source = "fn add(a, b):\n    a + b"
            val tree = parser.parse(source)
            expect tree.ok.?

        it "parses function with return type":
            var parser = TreeSitterParser.new("simple").unwrap()
            val source = "fn get_value() -> i64:\n    42"
            val tree = parser.parse(source)
            expect tree.ok.?

        it "parses function with parameters":
            var parser = TreeSitterParser.new("simple").unwrap()
            val source = "fn greet(name: text) -> text:\n    name"
            val tree = parser.parse(source)
            expect tree.ok.?

    context "control flow":
        it "parses if statement":
            var parser = TreeSitterParser.new("simple").unwrap()
            val source = "if x > 0:\n    y = 1"
            val tree = parser.parse(source)
            expect tree.ok.?

        it "parses while loop":
            var parser = TreeSitterParser.new("simple").unwrap()
            val source = "while x < 10:\n    x = x + 1"
            val tree = parser.parse(source)
            expect tree.ok.?

        it "parses for loop":
            var parser = TreeSitterParser.new("simple").unwrap()
            val source = "for i in range(10):\n    sum = sum + i"
            val tree = parser.parse(source)
            expect tree.ok.?


# ============================================================================
# Test Group 3: Tree Structure
# ============================================================================

describe "TreeSitter Tree Structure":
    """
    ## Syntax Tree Properties

    Tests the structure of parsed syntax trees.
    """

    context "root node":
        it "has root node after parsing":
            var parser = TreeSitterParser.new("simple").unwrap()
            val tree = parser.parse("val x = 42").unwrap()
            val root = tree.root()
            expect root.?

        it "root node is module type":
            var parser = TreeSitterParser.new("simple").unwrap()
            val tree = parser.parse("val x = 42").unwrap()
            val root = tree.root().unwrap()
            expect root.kind == "module"

    context "child nodes":
        it "function has children":
            var parser = TreeSitterParser.new("simple").unwrap()
            val source = "fn test():\n    42"
            val tree = parser.parse(source).unwrap()
            val root = tree.root().unwrap()
            expect root.child_count() > 0

    context "node spans":
        it "nodes have valid spans":
            var parser = TreeSitterParser.new("simple").unwrap()
            val tree = parser.parse("val x = 42").unwrap()
            val root = tree.root().unwrap()
            expect root.span.start_byte >= 0
            expect root.span.end_byte > root.span.start_byte


# ============================================================================
# Test Group 4: Node Types
# ============================================================================

describe "TreeSitter Node Types":
    """
    ## Node Kind Identification

    Tests that nodes are correctly typed by kind.
    """

    it "identifies function definition":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn test():\n    42"
        val tree = parser.parse(source).unwrap()
        val root = tree.root().unwrap()
        # Root should contain function_definition
        expect root.child_count() > 0

    it "identifies variable declaration":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val root = tree.root().unwrap()
        expect root.child_count() > 0

    it "identifies struct definition":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = "struct Point:\n    x: i64\n    y: i64"
        val tree = parser.parse(source).unwrap()
        val root = tree.root().unwrap()
        expect root.child_count() > 0


# ============================================================================
# Test Group 5: Multi-Statement Parsing
# ============================================================================

describe "TreeSitter Multi-Statement Parsing":
    """
    ## Multiple Statements

    Tests parsing of multiple statements in a module.
    """

    it "parses multiple declarations":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = """val x = 1
val y = 2
val z = 3"""
        val tree = parser.parse(source).unwrap()
        val root = tree.root().unwrap()
        expect root.child_count() >= 3

    it "parses mixed declarations":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = """val x = 42
fn add(a, b):
    a + b
struct Point:
    x: i64"""
        val tree = parser.parse(source).unwrap()
        val root = tree.root().unwrap()
        expect root.child_count() >= 3


# ============================================================================
# Test Group 6: Complex Expressions
# ============================================================================

describe "TreeSitter Complex Expression Parsing":
    """
    ## Nested and Complex Expressions

    Tests parsing of complex nested expressions.
    """

    it "parses nested arithmetic":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = ((1 + 2) * 3)")
        expect tree.ok.?

    it "parses method chain":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = obj.method1().method2()")
        expect tree.ok.?

    it "parses array literal":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val arr = [1, 2, 3]")
        expect tree.ok.?

    it "parses dictionary literal":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse(r'val d = {"key": "value"}')
        expect tree.ok.?

    it "parses lambda expression":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse(r"val f = \x: x + 1")
        expect tree.ok.?


# ============================================================================
# Test Group 7: Source Information
# ============================================================================

describe "TreeSitter Source Information":
    """
    ## Source Text and Positions

    Tests that source information is correctly preserved.
    """

    it "preserves source text":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 42"
        val tree = parser.parse(source).unwrap()
        expect tree.source == source

    it "tracks line numbers":
        var parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 42\nval y = 43"
        val tree = parser.parse(source).unwrap()
        val root = tree.root().unwrap()
        expect root.span.start_line == 1

    it "tracks column positions":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        val root = tree.root().unwrap()
        expect root.span.start_column >= 1


# ============================================================================
# Test Group 8: Tree Version
# ============================================================================

describe "TreeSitter Tree Versioning":
    """
    ## Tree Version Tracking

    Tests tree version management for incremental parsing.
    """

    it "initial tree has version 0":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("val x = 42").unwrap()
        expect tree.version == 0

    it "incremental parse increments version":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree1 = parser.parse("val x = 42").unwrap()
        # Incremental parse would increment version
        expect tree1.version >= 0


# ============================================================================
# Test Group 9: Parse Result
# ============================================================================

describe "TreeSitter Parse Results":
    """
    ## Success and Error Results

    Tests that parsing returns appropriate results.
    """

    it "returns Ok for valid syntax":
        var parser = TreeSitterParser.new("simple").unwrap()
        val result = parser.parse("val x = 42")
        expect result.ok.?

    it "returns tree for valid syntax":
        var parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("fn test():\n    42").unwrap()
        expect tree.root().?
