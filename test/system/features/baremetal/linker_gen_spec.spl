# @skip - Uses unsupported keyword: with
"""
# Linker Script Generator Specification

**Feature IDs:** #BM-LINKER-001
**Category:** Bare-Metal / Tooling
**Difficulty:** 3/5
**Status:** In Progress

## Overview

The linker script generator converts board SDN definitions into GNU LD
linker scripts for bare-metal targets. It handles:
- Memory region definitions
- Section layout
- Entry point specification
- Symbol generation

## Key Concepts

| Concept | Description |
|---------|-------------|
| Memory Region | Named memory area with origin, length, permissions |
| Section | Code/data placement with alignment and input patterns |
| Entry Point | First instruction to execute after reset |
| KEEP | Prevents section from being garbage collected |

## Implementation Notes

- Hex addresses formatted with 0x prefix
- Size suffixes: K (1024), M (1048576), G (1073741824)
- Permissions: r (read), w (write), x (execute)
"""

describe "Memory Size Parsing":
    """Verify size suffix parsing (K, M, G)."""

    context "Kilobyte suffix":
        it "parses 1K as 1024":
            val KB = 1024
            expect(1 * KB).to_equal(1024)

        it "parses 64K as 65536":
            val KB = 1024
            expect(64 * KB).to_equal(65536)

        it "parses 640K as 655360":
            """Conventional memory limit."""
            val KB = 1024
            expect(640 * KB).to_equal(655360)

    context "Megabyte suffix":
        it "parses 1M as 1048576":
            val MB = 1048576
            expect(1 * MB).to_equal(1048576)

        it "parses 16M as 16777216":
            val MB = 1048576
            expect(16 * MB).to_equal(16777216)

    context "Gigabyte suffix":
        it "parses 1G as 1073741824":
            val GB = 1073741824
            expect(1 * GB).to_equal(1073741824)

describe "Hex Address Parsing":
    """Verify hexadecimal address parsing."""

    it "parses 0x0 as 0":
        val addr = 0x0
        expect(addr).to_equal(0)

    it "parses 0x100000 as 1048576":
        """1MB mark - protected mode RAM start."""
        val addr = 0x100000
        expect(addr).to_equal(1048576)

    it "parses 0xB8000 as VGA buffer":
        """VGA text mode buffer address."""
        val addr = 0xB8000
        expect(addr).to_equal(753664)

    it "parses 0xF4 as debug exit port":
        val addr = 0xF4
        expect(addr).to_equal(244)

describe "Memory Region Formatting":
    """Verify memory region output format."""

    context "Permission strings":
        it "read-only is 'r'":
            val perms = "r"
            expect(perms).to_equal("r")

        it "read-write is 'rw'":
            val perms = "rw"
            expect(perms).to_equal("rw")

        it "read-write-execute is 'rwx'":
            val perms = "rwx"
            expect(perms).to_equal("rwx")

        it "read-execute is 'rx'":
            val perms = "rx"
            expect(perms).to_equal("rx")

    context "Origin formatting":
        it "formats 0 as 0x0":
            val expected = "0x0"
            expect(expected).to_equal("0x0")

        it "formats 1MB as 0x100000":
            val expected = "0x100000"
            expect(expected).to_equal("0x100000")

describe "Section Layout":
    """Verify section configuration."""

    context "Standard sections":
        it ".text section contains code":
            val section_name = ".text"
            expect(section_name).to_equal(".text")

        it ".rodata section contains read-only data":
            val section_name = ".rodata"
            expect(section_name).to_equal(".rodata")

        it ".data section contains initialized data":
            val section_name = ".data"
            expect(section_name).to_equal(".data")

        it ".bss section contains uninitialized data":
            val section_name = ".bss"
            expect(section_name).to_equal(".bss")

    context "Multiboot section":
        it "multiboot must be within first 8KB":
            """Multiboot spec requires header in first 8KB."""
            val MULTIBOOT_ADDR = 0x100000
            val MULTIBOOT_LIMIT = 0x102000  # 8KB after 1MB
            expect(MULTIBOOT_ADDR).to_be_less_than(MULTIBOOT_LIMIT)

        it "multiboot section uses KEEP":
            """Prevent linker from discarding multiboot header."""
            val keep = true
            expect(keep).to_equal(true)

    context "Alignment":
        it "page alignment is 4096":
            val PAGE_SIZE = 4096
            expect(PAGE_SIZE).to_equal(4096)

        it "multiboot header alignment is 4":
            val MULTIBOOT_ALIGN = 4
            expect(MULTIBOOT_ALIGN).to_equal(4)

describe "Entry Point":
    """Verify entry point specification."""

    it "default entry point is _start":
        val entry = "_start"
        expect(entry).to_equal("_start")

    it "generates ENTRY() directive":
        val directive = "ENTRY(_start)"
        expect(directive).to_equal("ENTRY(_start)")

describe "Symbol Generation":
    """Verify linker symbol generation."""

    context "Section boundary symbols":
        it "generates __text_start symbol":
            val symbol = "__text_start"
            expect(symbol).to_equal("__text_start")

        it "generates __text_end symbol":
            val symbol = "__text_end"
            expect(symbol).to_equal("__text_end")

        it "generates __bss_start symbol":
            val symbol = "__bss_start"
            expect(symbol).to_equal("__bss_start")

        it "generates __bss_end symbol":
            val symbol = "__bss_end"
            expect(symbol).to_equal("__bss_end")

    context "End of image symbol":
        it "generates _end symbol":
            val symbol = "_end"
            expect(symbol).to_equal("_end")

describe "QEMU x86 Board Configuration":
    """Verify QEMU x86 board definition."""

    context "Board metadata":
        it "name is QEMU x86 (i686)":
            val name = "QEMU x86 (i686)"
            expect(name).to_equal("QEMU x86 (i686)")

        it "target is i686-unknown-none":
            val target = "i686-unknown-none"
            expect(target).to_equal("i686-unknown-none")

        it "arch is i686":
            val arch = "i686"
            expect(arch).to_equal("i686")

    context "Memory regions":
        it "lowmem starts at 0":
            val LOWMEM_ORIGIN = 0x0
            expect(LOWMEM_ORIGIN).to_equal(0)

        it "lowmem is 640K":
            val LOWMEM_SIZE = 640 * 1024
            expect(LOWMEM_SIZE).to_equal(655360)

        it "ram starts at 1MB":
            val RAM_ORIGIN = 0x100000
            expect(RAM_ORIGIN).to_equal(1048576)

        it "ram is 16M":
            val RAM_SIZE = 16 * 1048576
            expect(RAM_SIZE).to_equal(16777216)

        it "VGA buffer at 0xB8000":
            val VGA_ORIGIN = 0xB8000
            expect(VGA_ORIGIN).to_equal(753664)

    context "QEMU settings":
        it "machine is pc":
            val machine = "pc"
            expect(machine).to_equal("pc")

        it "cpu is qemu32":
            val cpu = "qemu32"
            expect(cpu).to_equal("qemu32")

        it "debug exit iobase is 0xF4":
            val iobase = 0xF4
            expect(iobase).to_equal(244)

describe "Arduino Uno Board Configuration":
    """Verify Arduino Uno (AVR) board definition."""

    context "Board metadata":
        it "arch is avr":
            val arch = "avr"
            expect(arch).to_equal("avr")

        it "cpu is atmega328p":
            val cpu = "atmega328p"
            expect(cpu).to_equal("atmega328p")

    context "Memory regions":
        it "flash is 32K":
            val FLASH_SIZE = 32 * 1024
            expect(FLASH_SIZE).to_equal(32768)

        it "sram is 2K":
            val SRAM_SIZE = 2 * 1024
            expect(SRAM_SIZE).to_equal(2048)

        it "eeprom is 1K":
            val EEPROM_SIZE = 1 * 1024
            expect(EEPROM_SIZE).to_equal(1024)

        it "sram starts at 0x100":
            """First 256 bytes are registers and I/O."""
            val SRAM_ORIGIN = 0x100
            expect(SRAM_ORIGIN).to_equal(256)

    context "Stack configuration":
        it "stack is 256 bytes":
            val STACK_SIZE = 256
            expect(STACK_SIZE).to_equal(256)

        it "stack top is 0x8FF":
            """Top of 2KB SRAM."""
            val STACK_TOP = 0x8FF
            expect(STACK_TOP).to_equal(2303)

describe "MSP430 LaunchPad Board Configuration":
    """Verify MSP430 LaunchPad board definition."""

    context "Board metadata":
        it "arch is msp430":
            val arch = "msp430"
            expect(arch).to_equal("msp430")

        it "cpu is msp430g2553":
            val cpu = "msp430g2553"
            expect(cpu).to_equal("msp430g2553")

    context "Memory regions":
        it "flash is 16K":
            val FLASH_SIZE = 16 * 1024
            expect(FLASH_SIZE).to_equal(16384)

        it "ram is 512 bytes":
            val RAM_SIZE = 512
            expect(RAM_SIZE).to_equal(512)

        it "flash starts at 0xC000":
            val FLASH_ORIGIN = 0xC000
            expect(FLASH_ORIGIN).to_equal(49152)

        it "ram starts at 0x200":
            val RAM_ORIGIN = 0x200
            expect(RAM_ORIGIN).to_equal(512)

    context "Interrupt vectors":
        it "vector table at 0xFFE0":
            val VECTOR_ADDR = 0xFFE0
            expect(VECTOR_ADDR).to_equal(65504)
