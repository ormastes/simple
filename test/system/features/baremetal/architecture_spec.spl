# Architecture Support Specification
#
# Tests multi-architecture support (8/16/32/64-bit) including:
# - Target architecture properties
# - Pointer-sized types (usize/isize)
# - Calling conventions
# - Type layout per architecture
#
# Feature IDs: #BM-ARCH-001
# Category: Bare-Metal
# Status: In Progress

from std.common.target import {TargetArch, PointerSize, Endian, TargetConfig}

describe "Target Architecture":
    describe "8-bit Architectures":
        it "AVR has correct properties":
            val avr = TargetArch.AVR
            expect(avr.bits()).to(eq(8))
            expect(avr.pointer_bytes()).to(eq(2))
            expect(avr.stack_align()).to(eq(1))
            expect(avr.max_atomic_width()).to(eq(8))
            expect(avr.has_fpu()).to(eq(false))
            expect(avr.is_harvard()).to(eq(true))
            expect(avr.endianness()).to(eq(Endian.Little))

        it "MCS51 has correct properties":
            val mcs51 = TargetArch.MCS51
            expect(mcs51.bits()).to(eq(8))
            expect(mcs51.pointer_bytes()).to(eq(2))
            expect(mcs51.stack_align()).to(eq(1))
            expect(mcs51.has_fpu()).to(eq(false))
            expect(mcs51.is_harvard()).to(eq(true))
            expect(mcs51.endianness()).to(eq(Endian.Big))

        it "AVR parses from string":
            val parsed = TargetArch.parse("avr")
            expect(parsed.?).to(eq(true))
            expect(parsed.unwrap()).to(eq(TargetArch.AVR))

            val parsed2 = TargetArch.parse("atmega")
            expect(parsed2.?).to(eq(true))
            expect(parsed2.unwrap()).to(eq(TargetArch.AVR))

    describe "16-bit Architectures":
        it "MSP430 has correct properties":
            val msp = TargetArch.MSP430
            expect(msp.bits()).to(eq(16))
            expect(msp.pointer_bytes()).to(eq(2))
            expect(msp.stack_align()).to(eq(2))
            expect(msp.max_atomic_width()).to(eq(16))
            expect(msp.has_fpu()).to(eq(false))
            expect(msp.is_harvard()).to(eq(false))
            expect(msp.endianness()).to(eq(Endian.Little))

        it "MSP430 parses from string":
            val parsed = TargetArch.parse("msp430")
            expect(parsed.?).to(eq(true))
            expect(parsed.unwrap()).to(eq(TargetArch.MSP430))

    describe "32-bit Architectures":
        it "x86 has correct properties":
            val x86 = TargetArch.X86
            expect(x86.bits()).to(eq(32))
            expect(x86.pointer_bytes()).to(eq(4))
            expect(x86.stack_align()).to(eq(4))
            expect(x86.max_atomic_width()).to(eq(64))
            expect(x86.has_fpu()).to(eq(true))
            expect(x86.is_harvard()).to(eq(false))

        it "ARM has correct properties":
            val arm = TargetArch.Arm
            expect(arm.bits()).to(eq(32))
            expect(arm.pointer_bytes()).to(eq(4))
            expect(arm.stack_align()).to(eq(4))
            expect(arm.has_fpu()).to(eq(false))  # Cortex-M0/M3

        it "RISC-V 32 has correct properties":
            val rv32 = TargetArch.Riscv32
            expect(rv32.bits()).to(eq(32))
            expect(rv32.pointer_bytes()).to(eq(4))

    describe "64-bit Architectures":
        it "x86_64 has correct properties":
            val x64 = TargetArch.X86_64
            expect(x64.bits()).to(eq(64))
            expect(x64.pointer_bytes()).to(eq(8))
            expect(x64.stack_align()).to(eq(16))
            expect(x64.max_atomic_width()).to(eq(128))
            expect(x64.has_fpu()).to(eq(true))

        it "AArch64 has correct properties":
            val arm64 = TargetArch.Aarch64
            expect(arm64.bits()).to(eq(64))
            expect(arm64.pointer_bytes()).to(eq(8))
            expect(arm64.stack_align()).to(eq(16))

        it "RISC-V 64 has correct properties":
            val rv64 = TargetArch.Riscv64
            expect(rv64.bits()).to(eq(64))
            expect(rv64.pointer_bytes()).to(eq(8))

describe "Pointer Size":
    it "8-bit and 16-bit use 16-bit pointers":
        expect(TargetArch.AVR.pointer_size()).to(eq(PointerSize.Bits16))
        expect(TargetArch.MCS51.pointer_size()).to(eq(PointerSize.Bits16))
        expect(TargetArch.MSP430.pointer_size()).to(eq(PointerSize.Bits16))

    it "32-bit uses 32-bit pointers":
        expect(TargetArch.X86.pointer_size()).to(eq(PointerSize.Bits32))
        expect(TargetArch.Arm.pointer_size()).to(eq(PointerSize.Bits32))
        expect(TargetArch.Riscv32.pointer_size()).to(eq(PointerSize.Bits32))

    it "64-bit uses 64-bit pointers":
        expect(TargetArch.X86_64.pointer_size()).to(eq(PointerSize.Bits64))
        expect(TargetArch.Aarch64.pointer_size()).to(eq(PointerSize.Bits64))
        expect(TargetArch.Riscv64.pointer_size()).to(eq(PointerSize.Bits64))

    it "PointerSize returns correct byte count":
        expect(PointerSize.Bits16.bytes()).to(eq(2))
        expect(PointerSize.Bits32.bytes()).to(eq(4))
        expect(PointerSize.Bits64.bytes()).to(eq(8))

describe "Target Triple":
    it "generates correct bare-metal triples":
        expect(TargetArch.AVR.triple_str_baremetal()).to(eq("avr-unknown-unknown"))
        expect(TargetArch.MSP430.triple_str_baremetal()).to(eq("msp430-none-elf"))
        expect(TargetArch.X86.triple_str_baremetal()).to(eq("i686-unknown-none"))
        expect(TargetArch.Arm.triple_str_baremetal()).to(eq("thumbv7m-none-eabi"))
        expect(TargetArch.X86_64.triple_str_baremetal()).to(eq("x86_64-unknown-none"))

    it "generates correct hosted triples":
        expect(TargetArch.X86.triple_str()).to(eq("i686-unknown-linux-gnu"))
        expect(TargetArch.X86_64.triple_str()).to(eq("x86_64-unknown-linux-gnu"))
        expect(TargetArch.Arm.triple_str()).to(eq("armv7-unknown-linux-gnueabihf"))

describe "Target Config":
    it "configures 8-bit correctly":
        val config = TargetConfig.for_arch(TargetArch.AVR)
        expect(config.pointer_bytes).to(eq(2))
        expect(config.value_bytes).to(eq(2))
        expect(config.tag_bits).to(eq(0))
        expect(config.heap_align).to(eq(1))
        expect(config.default_stack_size).to(eq(256))

    it "configures 16-bit correctly":
        val config = TargetConfig.for_arch(TargetArch.MSP430)
        expect(config.pointer_bytes).to(eq(2))
        expect(config.value_bytes).to(eq(2))
        expect(config.tag_bits).to(eq(1))
        expect(config.heap_align).to(eq(2))
        expect(config.default_stack_size).to(eq(512))

    it "configures 32-bit correctly":
        val config = TargetConfig.for_arch(TargetArch.X86)
        expect(config.pointer_bytes).to(eq(4))
        expect(config.value_bytes).to(eq(8))
        expect(config.tag_bits).to(eq(2))
        expect(config.heap_align).to(eq(4))

    it "configures 64-bit correctly":
        val config = TargetConfig.for_arch(TargetArch.X86_64)
        expect(config.pointer_bytes).to(eq(8))
        expect(config.value_bytes).to(eq(8))
        expect(config.tag_bits).to(eq(3))
        expect(config.heap_align).to(eq(8))

describe "Architecture Bit Width Helpers":
    it "is_8bit returns true for 8-bit":
        expect(TargetArch.AVR.is_8bit()).to(eq(true))
        expect(TargetArch.MCS51.is_8bit()).to(eq(true))
        expect(TargetArch.X86.is_8bit()).to(eq(false))

    it "is_16bit returns true for 16-bit":
        expect(TargetArch.MSP430.is_16bit()).to(eq(true))
        expect(TargetArch.AVR.is_16bit()).to(eq(false))

    it "is_32bit returns true for 32-bit":
        expect(TargetArch.X86.is_32bit()).to(eq(true))
        expect(TargetArch.Arm.is_32bit()).to(eq(true))
        expect(TargetArch.X86_64.is_32bit()).to(eq(false))

    it "is_64bit returns true for 64-bit":
        expect(TargetArch.X86_64.is_64bit()).to(eq(true))
        expect(TargetArch.Aarch64.is_64bit()).to(eq(true))
        expect(TargetArch.X86.is_64bit()).to(eq(false))

describe "Endianness":
    it "most architectures are little-endian":
        expect(TargetArch.AVR.endianness()).to(eq(Endian.Little))
        expect(TargetArch.MSP430.endianness()).to(eq(Endian.Little))
        expect(TargetArch.X86.endianness()).to(eq(Endian.Little))
        expect(TargetArch.X86_64.endianness()).to(eq(Endian.Little))

    it "MCS51 is big-endian":
        expect(TargetArch.MCS51.endianness()).to(eq(Endian.Big))
