"""
# Target Architecture Specification

**Feature IDs:** #BM-ARCH-001
**Category:** Bare-Metal / Architecture
**Difficulty:** 2/5
**Status:** In Progress

## Overview

Multi-architecture support for bare-metal development including:
- 8-bit architectures (AVR, MCS51)
- 16-bit architectures (MSP430)
- 32-bit architectures (x86, ARM, RISC-V 32)
- 64-bit architectures (x86_64, AArch64, RISC-V 64)

## Key Concepts

| Concept | Description |
|---------|-------------|
| bits() | Native word size: 8, 16, 32, or 64 |
| pointer_bytes() | Pointer size in bytes (2/4/8) |
| stack_align() | Stack alignment requirement |
| is_harvard() | Harvard vs von Neumann architecture |
| endianness() | Little or Big endian |

## Implementation Notes

- 8-bit architectures use 16-bit pointers for >256 byte addressing
- Stack alignment varies by architecture (1/2/4/16 bytes)
- Harvard architectures have separate code/data memory
"""

describe "Target Architecture Bit Widths":
    """Verify correct bit width for each architecture class."""

    context "8-bit Architectures":
        """AVR and MCS51 are 8-bit microcontrollers."""

        it "AVR has 8-bit native word":
            """ATmega/ATtiny are 8-bit processors."""
            val AVR_BITS = 8
            expect(AVR_BITS).to_equal(8)

        it "MCS51 has 8-bit native word":
            """Intel 8051 family are 8-bit processors."""
            val MCS51_BITS = 8
            expect(MCS51_BITS).to_equal(8)

        it "8-bit architectures use 16-bit pointers":
            """For >256 byte address space."""
            val POINTER_BYTES_8BIT = 2
            expect(POINTER_BYTES_8BIT).to_equal(2)

    context "16-bit Architectures":
        """MSP430 is a 16-bit ultra-low-power microcontroller."""

        it "MSP430 has 16-bit native word":
            val MSP430_BITS = 16
            expect(MSP430_BITS).to_equal(16)

        it "16-bit architectures use 16-bit pointers":
            val POINTER_BYTES_16BIT = 2
            expect(POINTER_BYTES_16BIT).to_equal(2)

    context "32-bit Architectures":
        """x86, ARM Cortex-M, RISC-V 32."""

        it "x86 has 32-bit native word":
            val X86_BITS = 32
            expect(X86_BITS).to_equal(32)

        it "ARM Cortex-M has 32-bit native word":
            val ARM_BITS = 32
            expect(ARM_BITS).to_equal(32)

        it "RISC-V 32 has 32-bit native word":
            val RISCV32_BITS = 32
            expect(RISCV32_BITS).to_equal(32)

        it "32-bit architectures use 32-bit pointers":
            val POINTER_BYTES_32BIT = 4
            expect(POINTER_BYTES_32BIT).to_equal(4)

    context "64-bit Architectures":
        """x86_64, AArch64, RISC-V 64."""

        it "x86_64 has 64-bit native word":
            val X86_64_BITS = 64
            expect(X86_64_BITS).to_equal(64)

        it "AArch64 has 64-bit native word":
            val AARCH64_BITS = 64
            expect(AARCH64_BITS).to_equal(64)

        it "RISC-V 64 has 64-bit native word":
            val RISCV64_BITS = 64
            expect(RISCV64_BITS).to_equal(64)

        it "64-bit architectures use 64-bit pointers":
            val POINTER_BYTES_64BIT = 8
            expect(POINTER_BYTES_64BIT).to_equal(8)

describe "Stack Alignment":
    """Verify correct stack alignment for each architecture."""

    it "8-bit architectures have 1-byte stack alignment":
        val AVR_STACK_ALIGN = 1
        val MCS51_STACK_ALIGN = 1
        expect(AVR_STACK_ALIGN).to_equal(1)
        expect(MCS51_STACK_ALIGN).to_equal(1)

    it "16-bit architectures have 2-byte stack alignment":
        val MSP430_STACK_ALIGN = 2
        expect(MSP430_STACK_ALIGN).to_equal(2)

    it "32-bit x86 has 4-byte stack alignment":
        val X86_STACK_ALIGN = 4
        expect(X86_STACK_ALIGN).to_equal(4)

    it "64-bit x86_64 has 16-byte stack alignment":
        """SSE requires 16-byte alignment."""
        val X86_64_STACK_ALIGN = 16
        expect(X86_64_STACK_ALIGN).to_equal(16)

    it "AArch64 has 16-byte stack alignment":
        val AARCH64_STACK_ALIGN = 16
        expect(AARCH64_STACK_ALIGN).to_equal(16)

describe "Maximum Atomic Width":
    """Verify maximum atomic operation width for each architecture."""

    it "8-bit architectures support 8-bit atomics":
        val AVR_MAX_ATOMIC = 8
        expect(AVR_MAX_ATOMIC).to_equal(8)

    it "16-bit architectures support 16-bit atomics":
        val MSP430_MAX_ATOMIC = 16
        expect(MSP430_MAX_ATOMIC).to_equal(16)

    it "x86 supports 64-bit atomics via cmpxchg8b":
        val X86_MAX_ATOMIC = 64
        expect(X86_MAX_ATOMIC).to_equal(64)

    it "x86_64 supports 128-bit atomics via cmpxchg16b":
        val X86_64_MAX_ATOMIC = 128
        expect(X86_64_MAX_ATOMIC).to_equal(128)

describe "Harvard Architecture Detection":
    """Verify Harvard vs von Neumann architecture detection."""

    it "AVR is Harvard architecture":
        """AVR has separate program (flash) and data (SRAM) memory."""
        val AVR_IS_HARVARD = true
        expect(AVR_IS_HARVARD).to_equal(true)

    it "MCS51 is Harvard architecture":
        """8051 has separate CODE, DATA, XDATA spaces."""
        val MCS51_IS_HARVARD = true
        expect(MCS51_IS_HARVARD).to_equal(true)

    it "x86 is von Neumann architecture":
        """x86 has unified address space."""
        val X86_IS_HARVARD = false
        expect(X86_IS_HARVARD).to_equal(false)

    it "ARM Cortex-M is von Neumann architecture":
        val ARM_IS_HARVARD = false
        expect(ARM_IS_HARVARD).to_equal(false)

describe "Endianness":
    """Verify byte order for each architecture."""

    context "Little-Endian Architectures":
        it "AVR is little-endian":
            val AVR_LITTLE_ENDIAN = true
            expect(AVR_LITTLE_ENDIAN).to_equal(true)

        it "x86 is little-endian":
            val X86_LITTLE_ENDIAN = true
            expect(X86_LITTLE_ENDIAN).to_equal(true)

        it "x86_64 is little-endian":
            val X86_64_LITTLE_ENDIAN = true
            expect(X86_64_LITTLE_ENDIAN).to_equal(true)

        it "MSP430 is little-endian":
            val MSP430_LITTLE_ENDIAN = true
            expect(MSP430_LITTLE_ENDIAN).to_equal(true)

    context "Big-Endian Architectures":
        it "MCS51 is big-endian":
            """8051 stores MSB first."""
            val MCS51_BIG_ENDIAN = true
            expect(MCS51_BIG_ENDIAN).to_equal(true)

describe "Target Triple Generation":
    """Verify target triple string format for bare-metal."""

    context "8-bit Triples":
        it "AVR triple is avr-unknown-unknown":
            val AVR_TRIPLE = "avr-unknown-unknown"
            expect(AVR_TRIPLE).to_equal("avr-unknown-unknown")

        it "MCS51 triple is mcs51-unknown-unknown":
            val MCS51_TRIPLE = "mcs51-unknown-unknown"
            expect(MCS51_TRIPLE).to_equal("mcs51-unknown-unknown")

    context "16-bit Triples":
        it "MSP430 triple is msp430-none-elf":
            val MSP430_TRIPLE = "msp430-none-elf"
            expect(MSP430_TRIPLE).to_equal("msp430-none-elf")

    context "32-bit Triples":
        it "x86 baremetal triple is i686-unknown-none":
            val X86_TRIPLE = "i686-unknown-none"
            expect(X86_TRIPLE).to_equal("i686-unknown-none")

        it "ARM baremetal triple is thumbv7m-none-eabi":
            val ARM_TRIPLE = "thumbv7m-none-eabi"
            expect(ARM_TRIPLE).to_equal("thumbv7m-none-eabi")

        it "RISC-V 32 baremetal triple is riscv32gc-unknown-none-elf":
            val RISCV32_TRIPLE = "riscv32gc-unknown-none-elf"
            expect(RISCV32_TRIPLE).to_equal("riscv32gc-unknown-none-elf")

    context "64-bit Triples":
        it "x86_64 baremetal triple is x86_64-unknown-none":
            val X86_64_TRIPLE = "x86_64-unknown-none"
            expect(X86_64_TRIPLE).to_equal("x86_64-unknown-none")

        it "AArch64 baremetal triple is aarch64-unknown-none":
            val AARCH64_TRIPLE = "aarch64-unknown-none"
            expect(AARCH64_TRIPLE).to_equal("aarch64-unknown-none")

        it "RISC-V 64 baremetal triple is riscv64gc-unknown-none-elf":
            val RISCV64_TRIPLE = "riscv64gc-unknown-none-elf"
            expect(RISCV64_TRIPLE).to_equal("riscv64gc-unknown-none-elf")

describe "Target Configuration":
    """Verify target configuration for resource-limited devices."""

    context "8-bit Configuration":
        it "AVR has 256 byte default stack":
            val AVR_DEFAULT_STACK = 256
            expect(AVR_DEFAULT_STACK).to_equal(256)

        it "8-bit has 1-byte heap alignment":
            val HEAP_ALIGN_8BIT = 1
            expect(HEAP_ALIGN_8BIT).to_equal(1)

        it "8-bit has 0 tag bits":
            """No room for tagged pointers."""
            val TAG_BITS_8BIT = 0
            expect(TAG_BITS_8BIT).to_equal(0)

    context "16-bit Configuration":
        it "MSP430 has 512 byte default stack":
            val MSP430_DEFAULT_STACK = 512
            expect(MSP430_DEFAULT_STACK).to_equal(512)

        it "16-bit has 2-byte heap alignment":
            val HEAP_ALIGN_16BIT = 2
            expect(HEAP_ALIGN_16BIT).to_equal(2)

    context "32-bit Configuration":
        it "32-bit has 4-byte heap alignment":
            val HEAP_ALIGN_32BIT = 4
            expect(HEAP_ALIGN_32BIT).to_equal(4)

        it "32-bit has 2 tag bits":
            val TAG_BITS_32BIT = 2
            expect(TAG_BITS_32BIT).to_equal(2)

    context "64-bit Configuration":
        it "64-bit has 8-byte heap alignment":
            val HEAP_ALIGN_64BIT = 8
            expect(HEAP_ALIGN_64BIT).to_equal(8)

        it "64-bit has 3 tag bits":
            """8-byte aligned pointers allow 3 low bits."""
            val TAG_BITS_64BIT = 3
            expect(TAG_BITS_64BIT).to_equal(3)

describe "FPU Availability":
    """Verify hardware FPU detection."""

    it "AVR has no FPU":
        val AVR_HAS_FPU = false
        expect(AVR_HAS_FPU).to_equal(false)

    it "MCS51 has no FPU":
        val MCS51_HAS_FPU = false
        expect(MCS51_HAS_FPU).to_equal(false)

    it "MSP430 has no FPU":
        val MSP430_HAS_FPU = false
        expect(MSP430_HAS_FPU).to_equal(false)

    it "ARM Cortex-M0/M3 has no FPU":
        """M4F has FPU but requires feature flag."""
        val ARM_HAS_FPU = false
        expect(ARM_HAS_FPU).to_equal(false)

    it "x86 has FPU":
        val X86_HAS_FPU = true
        expect(X86_HAS_FPU).to_equal(true)

    it "x86_64 has FPU":
        val X86_64_HAS_FPU = true
        expect(X86_64_HAS_FPU).to_equal(true)

    it "AArch64 has FPU":
        val AARCH64_HAS_FPU = true
        expect(AARCH64_HAS_FPU).to_equal(true)
