"""
# Pattern Matching Specification

**Feature IDs:** #PATTERN-MATCH
**Category:** Language
**Status:** Implemented

Pattern matching provides a way to extract and deconstruct values using patterns.
It supports matching on enums, structs, tuples, literals, and wildcards. Pattern
matching integrates with guard clauses for conditional matching and provides
exhaustiveness checking to ensure all cases are handled.

## Syntax

```simple
match value:
    case pattern:
        body
    case pattern if guard:
        body
    case _:
        default_body
```

## Key Behaviors

- Pattern matching deconstructs values into their components
- Variables bound in patterns are available in match arm bodies
- Patterns include literals, enums, tuples, records, and wildcards
- Guard clauses add conditional logic after pattern matching
- Exhaustiveness checking ensures all possible cases are covered
- Nested patterns allow matching on deeply structured data
"""

import std.spec


# ============================================================================
# Test Group 1: Basic Pattern Matching
# ============================================================================

describe "Basic Pattern Matching":
    """
    Verifies fundamental pattern matching functionality including literal
    matching, wildcard patterns, and variable binding. This covers the core
    pattern matching features used in everyday code.
    """

    context "literal patterns":
        it "matches exact literal values":
            fn classify(x: i64) -> text:
                match x:
                    case 0:
                        "zero"
                    case 1:
                        "one"
                    case _:
                        "other"
            expect classify(0) == "zero"
            expect classify(1) == "one"
            expect classify(42) == "other"

        it "matches string literals":
            fn describe_color(color: text) -> text:
                match color:
                    case "red":
                        "primary"
                    case "blue":
                        "primary"
                    case "green":
                        "primary"
                    case _:
                        "unknown"
            expect describe_color("red") == "primary"
            expect describe_color("purple") == "unknown"

    context "wildcard patterns":
        it "matches anything with underscore":
            fn always_default(x: i64) -> text:
                match x:
                    case _:
                        "matched"
            expect always_default(100) == "matched"
            expect always_default(-1) == "matched"

    context "variable patterns":
        it "binds value to variable":
            fn double_it(x: i64) -> i64:
                match x:
                    case n:
                        n * 2
            expect double_it(5) == 10
            expect double_it(0) == 0


# ============================================================================
# Test Group 2: Tuple Pattern Matching
# ============================================================================

describe "Tuple Pattern Matching":
    """
    Verifies pattern matching on tuple values with multiple components.
    Tests destructuring tuples, nested tuple patterns, and partial matching
    with wildcards.
    """

    context "basic tuple patterns":
        it "destructures tuple into components":
            fn add_pair(pair: (i64, i64)) -> i64:
                match pair:
                    case (a, b):
                        a + b
            expect add_pair((3, 4)) == 7
            expect add_pair((0, 0)) == 0

        it "matches specific tuple values":
            fn describe_point(point: (i64, i64)) -> text:
                match point:
                    case (0, 0):
                        "origin"
                    case (x, 0):
                        "on x-axis"
                    case (0, y):
                        "on y-axis"
                    case _:
                        "general"
            expect describe_point((0, 0)) == "origin"
            expect describe_point((5, 0)) == "on x-axis"
            expect describe_point((0, 3)) == "on y-axis"
            expect describe_point((2, 3)) == "general"

    context "nested tuple patterns":
        it "matches nested tuples":
            fn extract_nested(value: ((i64, text), bool)) -> text:
                match value:
                    case ((n, s), b):
                        if b:
                            s
                        else:
                            "{n}"
            expect extract_nested(((42, "answer"), true)) == "answer"


# ============================================================================
# Test Group 3: Enum Pattern Matching
# ============================================================================

describe "Enum Pattern Matching":
    """
    Verifies pattern matching on enum values with different variants.
    Tests simple variants, variants with payloads, nested variants, and
    exhaustiveness checking.
    """

    context "simple enum variants":
        it "matches enum variants":
            enum Color:
                Red
                Green
                Blue

            fn to_string(color: Color) -> text:
                match color:
                    case Color::Red:
                        "red"
                    case Color::Green:
                        "green"
                    case Color::Blue:
                        "blue"

            expect to_string(Color::Red) == "red"
            expect to_string(Color::Blue) == "blue"

    context "enum variants with payloads":
        it "extracts payload from variant":
            enum Result<T, E>:
                Ok(T)
                Err(E)

            fn handle_result(result: Result<i64, text>) -> text:
                match result:
                    case Result::Ok(value):
                        "success: {value}"
                    case Result::Err(error):
                        "error: {error}"

            expect handle_result(Result::Ok(42)) == "success: 42"
            expect handle_result(Result::Err("oops")) == "error: oops"

    context "option patterns":
        it "matches Option Some and None":
            fn process_option(opt: Option<i64>) -> text:
                match opt:
                    case Some(n):
                        "value: {n}"
                    case None:
                        "empty"

            expect process_option(Some(100)) == "value: 100"
            expect process_option(None) == "empty"


# ============================================================================
# Test Group 4: Pattern Matching with Guards
# ============================================================================

describe "Pattern Matching with Guards":
    """
    Verifies guard clauses in pattern matching that add conditional logic
    after pattern matching succeeds. Guards use variables bound by patterns
    and can express complex conditions.
    """

    context "guards with numeric patterns":
        it "uses guard to add range check":
            fn classify_age(age: i64) -> text:
                match age:
                    case n if n < 0:
                        "invalid"
                    case n if n < 13:
                        "child"
                    case n if n < 18:
                        "teen"
                    case _:
                        "adult"

            expect classify_age(-5) == "invalid"
            expect classify_age(10) == "child"
            expect classify_age(15) == "teen"
            expect classify_age(25) == "adult"

    context "guards with complex expressions":
        it "uses multiple conditions in guard":
            fn categorize_number(n: i64) -> text:
                match n:
                    case x if x > 0 && x % 2 == 0:
                        "positive even"
                    case x if x > 0:
                        "positive odd"
                    case x if x < 0:
                        "negative"
                    case _:
                        "zero"

            expect categorize_number(4) == "positive even"
            expect categorize_number(3) == "positive odd"
            expect categorize_number(-5) == "negative"
            expect categorize_number(0) == "zero"


# ============================================================================
# Test Group 5: Complex Pattern Matching
# ============================================================================

describe "Complex Pattern Matching":
    """
    Verifies advanced pattern matching scenarios including nested patterns,
    multiple variables, and integration with other language features.
    """

    context "multiple variable binding":
        it "binds multiple variables in pattern":
            fn swap_and_add(pair: (i64, i64)) -> (i64, i64):
                match pair:
                    case (a, b):
                        (b, a)

            val (x, y) = swap_and_add((3, 7))
            expect x == 7
            expect y == 3

    context "pattern matching in function parameters":
        it "uses pattern in parameter directly":
            fn get_first((x, _): (i64, i64)) -> i64:
                x

            expect get_first((42, 99)) == 42

    context "pattern matching in variable binding":
        it "destructures in variable assignment":
            val (a, b) = (10, 20)
            expect a == 10
            expect b == 20
