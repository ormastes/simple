"""
# Pattern Matching Specification

**Feature IDs:** #PATTERN-MATCH
**Category:** Language
**Status:** Implemented

Pattern matching provides a way to extract and deconstruct values using patterns.
It supports matching on enums, structs, tuples, literals, and wildcards. Pattern
matching integrates with guard clauses for conditional matching and provides
exhaustiveness checking to ensure all cases are handled.

## Syntax

```simple
match value:
    case pattern:
        body
    case pattern if guard:
        body
    case _:
        default_body
```

## Key Behaviors

- Pattern matching deconstructs values into their components
- Variables bound in patterns are available in match arm bodies
- Patterns include literals, enums, tuples, records, and wildcards
- Guard clauses add conditional logic after pattern matching
- Exhaustiveness checking ensures all possible cases are covered
- Nested patterns allow matching on deeply structured data
"""

use std.spec


# ============================================================================
# Test Group 1: Basic Pattern Matching
# ============================================================================

describe "Basic Pattern Matching":
    """
    Verifies fundamental pattern matching functionality including literal
    matching, wildcard patterns, and variable binding. This covers the core
    pattern matching features used in everyday code.
    """

    context "literal patterns":
        it "matches exact literal values":
            fn classify(x: i64) -> text:
                match x:
                    case 0:
                        "zero"
                    case 1:
                        "one"
                    case _:
                        "other"
            expect classify(0) == "zero"
            expect classify(1) == "one"
            expect classify(42) == "other"

        it "matches string literals":
            fn describe_color(color: text) -> text:
                match color:
                    case "red":
                        "primary"
                    case "blue":
                        "primary"
                    case "green":
                        "primary"
                    case _:
                        "unknown"
            expect describe_color("red") == "primary"
            expect describe_color("purple") == "unknown"

    context "wildcard patterns":
        it "matches anything with underscore":
            fn always_default(x: i64) -> text:
                match x:
                    case _:
                        "matched"
            expect always_default(100) == "matched"
            expect always_default(-1) == "matched"

    context "variable patterns":
        it "binds value to variable":
            fn double_it(x: i64) -> i64:
                match x:
                    case n:
                        n * 2
            expect double_it(5) == 10
            expect double_it(0) == 0


# ============================================================================
# Test Group 2: Tuple Pattern Matching
# ============================================================================

describe "Tuple Pattern Matching":
    """
    Verifies pattern matching on tuple values with multiple components.
    Tests destructuring tuples, nested tuple patterns, and partial matching
    with wildcards.
    """

    context "basic tuple patterns":
        it "destructures tuple into components":
            fn add_pair(pair: (i64, i64)) -> i64:
                match pair:
                    case (a, b):
                        a + b
            expect add_pair((3, 4)) == 7
            expect add_pair((0, 0)) == 0

        it "matches specific tuple values":
            fn describe_point(point: (i64, i64)) -> text:
                match point:
                    case (0, 0):
                        "origin"
                    case (x, 0):
                        "on x-axis"
                    case (0, y):
                        "on y-axis"
                    case _:
                        "general"
            expect describe_point((0, 0)) == "origin"
            expect describe_point((5, 0)) == "on x-axis"
            expect describe_point((0, 3)) == "on y-axis"
            expect describe_point((2, 3)) == "general"

    context "nested tuple patterns":
        it "matches nested tuples":
            fn extract_nested(value: ((i64, text), bool)) -> text:
                match value:
                    case ((n, s), b):
                        if b:
                            s
                        else:
                            "{n}"
            expect extract_nested(((42, "answer"), true)) == "answer"


# ============================================================================
# Test Group 3: Enum Pattern Matching
# ============================================================================

describe "Enum Pattern Matching":
    """
    Verifies pattern matching on enum values with different variants.
    Tests simple variants, variants with payloads, nested variants, and
    exhaustiveness checking.
    """

    context "simple enum variants":
        it "matches enum variants":
            enum Color:
                Red
                Green
                Blue

            fn to_string(color: Color) -> text:
                match color:
                    case Color::Red:
                        "red"
                    case Color::Green:
                        "green"
                    case Color::Blue:
                        "blue"

            expect to_string(Color::Red) == "red"
            expect to_string(Color::Blue) == "blue"

    context "enum variants with payloads":
        it "extracts payload from variant":
            enum Result<T, E>:
                Ok(T)
                Err(E)

            fn handle_result(result: Result<i64, text>) -> text:
                match result:
                    case Result::Ok(value):
                        "success: {value}"
                    case Result::Err(error):
                        "error: {error}"

            expect handle_result(Result::Ok(42)) == "success: 42"
            expect handle_result(Result::Err("oops")) == "error: oops"

    context "option patterns":
        it "matches Option Some and None":
            fn process_option(opt: Option<i64>) -> text:
                match opt:
                    case Some(n):
                        "value: {n}"
                    case None:
                        "empty"

            expect process_option(Some(100)) == "value: 100"
            expect process_option(None) == "empty"


# ============================================================================
# Test Group 4: Pattern Matching with Guards
# ============================================================================

describe "Pattern Matching with Guards":
    """
    Verifies guard clauses in pattern matching that add conditional logic
    after pattern matching succeeds. Guards use variables bound by patterns
    and can express complex conditions.
    """

    context "guards with numeric patterns":
        it "uses guard to add range check":
            fn classify_age(age: i64) -> text:
                match age:
                    case n if n < 0:
                        "invalid"
                    case n if n < 13:
                        "child"
                    case n if n < 18:
                        "teen"
                    case _:
                        "adult"

            expect classify_age(-5) == "invalid"
            expect classify_age(10) == "child"
            expect classify_age(15) == "teen"
            expect classify_age(25) == "adult"

    context "guards with complex expressions":
        it "uses multiple conditions in guard":
            fn categorize_number(n: i64) -> text:
                match n:
                    case x if x > 0 && x % 2 == 0:
                        "positive even"
                    case x if x > 0:
                        "positive odd"
                    case x if x < 0:
                        "negative"
                    case _:
                        "zero"

            expect categorize_number(4) == "positive even"
            expect categorize_number(3) == "positive odd"
            expect categorize_number(-5) == "negative"
            expect categorize_number(0) == "zero"


# ============================================================================
# Test Group 5: Complex Pattern Matching
# ============================================================================

describe "Complex Pattern Matching":
    """
    Verifies advanced pattern matching scenarios including nested patterns,
    multiple variables, and integration with other language features.
    """

    context "multiple variable binding":
        it "binds multiple variables in pattern":
            fn swap_and_add(pair: (i64, i64)) -> (i64, i64):
                match pair:
                    case (a, b):
                        (b, a)

            val (x, y) = swap_and_add((3, 7))
            expect x == 7
            expect y == 3

    context "pattern matching in function parameters":
        it "uses pattern in parameter directly":
            fn get_first((x, _): (i64, i64)) -> i64:
                x

            expect get_first((42, 99)) == 42

    context "pattern matching in variable binding":
        it "destructures in variable assignment":
            val (a, b) = (10, 20)
            expect a == 10
            expect b == 20


# ============================================================================
# Test Group 6: Or Patterns
# ============================================================================

describe "Or Patterns":
    """
    ## Multiple Patterns with |

    Tests for matching multiple patterns using the | operator.
    """

    it "matches multiple literal values":
        fn classify(x):
            match x:
                case 1 | 2 | 3:
                    return 1  # small
                case 4 | 5 | 6:
                    return 2  # medium
                case _:
                    return 3  # large
        expect classify(2) == 1
        expect classify(5) == 2
        expect classify(99) == 3

    it "uses or pattern with wildcard":
        fn verify(x):
            match x:
                case 0 | 1:
                    return 10
                case _:
                    return 99
        expect verify(0) == 10
        expect verify(1) == 10
        expect verify(99) == 99


# ============================================================================
# Test Group 7: Range Patterns
# ============================================================================

describe "Range Patterns":
    """
    ## Matching Ranges with .. and ..=

    Tests for matching ranges of values in patterns.
    """

    it "matches exclusive range":
        fn classify(x):
            match x:
                case 0..10:
                    return 1
                case 10..20:
                    return 2
                case _:
                    return 3
        expect classify(5) == 1
        expect classify(15) == 2

    it "excludes end in exclusive range":
        fn classify(x):
            match x:
                case 0..10:
                    return 1
                case 10..20:
                    return 2
                case _:
                    return 3
        expect classify(10) == 2  # 10 not in 0..10

    it "matches inclusive range":
        fn classify(x):
            match x:
                case 0..=5:
                    return 1
                case 6..=10:
                    return 2
                case _:
                    return 3
        expect classify(5) == 1  # 5 is in 0..=5
        expect classify(6) == 2


# ============================================================================
# Test Group 8: If Let / While Let
# ============================================================================

describe "If Let and While Let":
    """
    ## Pattern Matching in Conditionals

    Tests for if let and while let pattern matching constructs.
    """

    context "if let patterns":
        it "matches Some with if let":
            val opt = Some(42)
            var res = 0
            if let Some(x) = opt:
                res = x
            expect res == 42

        it "uses else with if let":
            val opt: Option<i64> = None
            var res = 0
            if let Some(x) = opt:
                res = x
            else:
                res = -1
            expect res == -1

        it "matches Ok with if let":
            val res = Ok(100)
            var output = 0
            if let Ok(value) = res:
                output = value
            expect output == 100

    context "while let patterns":
        it "loops with while let":
            fn next_item(n):
                if n > 0:
                    return Some(n)
                return None

            var counter = 3
            var sum = 0
            while let Some(value) = next_item(counter):
                sum = sum + value
                counter = counter - 1
            expect sum == 6  # 3 + 2 + 1


# ============================================================================
# Test Group 9: Match Guards
# ============================================================================

describe "Match Guards":
    """
    ## Conditional Pattern Matching

    Tests for match guards that add conditional checks to patterns.
    """

    it "uses basic match guard":
        fn classify(x):
            match x:
                case n if n < 0:
                    return -1
                case n if n == 0:
                    return 0
                case n if n > 0:
                    return 1
            return -99
        expect classify(5) == 1
        expect classify(-10) == -1
        expect classify(0) == 0

    it "uses guard with bound variable":
        fn verify(pair):
            match pair:
                case (a, b) if a + b > 10:
                    return 1
                case (a, b) if a + b == 10:
                    return 0
                case _:
                    return -1
        expect verify((7, 5)) == 1  # 12 > 10
        expect verify((5, 5)) == 0  # 10 == 10

    it "falls through when guard fails":
        fn test(x):
            match x:
                case n if n > 100:
                    return 100
                case n if n > 10:
                    return 10
                case n:
                    return n
        expect test(50) == 10  # 50 > 10 but not > 100
