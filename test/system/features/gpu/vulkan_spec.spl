# Vulkan Compute Backend Tests
#
# Tests specific to Vulkan compute functionality.
# These tests require Vulkan SDK to be available.

use std.gpu.*
use std.testing.gpu_helpers.*
use app.io.vulkan_ffi.*

describe "Vulkan Availability":
    it "checks Vulkan availability":
        val available = vulkan_available()
        # Just verify the function runs without error
        assert available or not available

describe "Vulkan Initialization":
    @tag(skip: "requires_vulkan")
    it "initializes Vulkan":
        require_vulkan()
        assert vulkan_init()

    @tag(skip: "requires_vulkan")
    it "reports device count":
        require_vulkan()
        vulkan_init()
        val count = vulkan_device_count()
        assert count > 0

    @tag(skip: "requires_vulkan")
    it "shuts down cleanly":
        require_vulkan()
        vulkan_init()
        assert vulkan_shutdown()

describe "Vulkan Device Selection":
    @tag(skip: "requires_vulkan")
    it "selects device":
        require_vulkan()
        vulkan_init()
        assert vulkan_select_device(0)
        assert vulkan_get_device() == 0

    @tag(skip: "requires_vulkan")
    it "gets device info":
        require_vulkan()
        vulkan_init()
        vulkan_select_device(0)

        val info = vulkan_device_info(0)
        assert info.name.len() > 0
        assert info.total_memory > 0

    @tag(skip: "requires_vulkan")
    it "reports device type":
        require_vulkan()
        vulkan_init()
        val info = vulkan_device_info(0)

        match info.device_type:
            case Discrete | Integrated | Virtual | Cpu | Unknown:
                assert true

    @tag(skip: "requires_vulkan")
    it "gets API version":
        require_vulkan()
        vulkan_init()
        val info = vulkan_device_info(0)
        val (major, minor, patch) = info.api_version
        assert major >= 1

describe "Vulkan Buffer Operations":
    @tag(skip: "requires_vulkan")
    it "allocates storage buffer":
        require_vulkan()
        vulkan_init()
        vulkan_select_device(0)

        val buffer = vulkan_alloc_storage(1024)
        assert buffer.is_valid
        assert buffer.size == 1024
        assert vulkan_free_buffer(buffer)

    @tag(skip: "requires_vulkan")
    it "allocates different buffer types":
        require_vulkan()
        vulkan_init()
        vulkan_select_device(0)

        val storage = vulkan_alloc_buffer(1024, VulkanBufferUsage.Storage)
        assert storage.is_valid
        vulkan_free_buffer(storage)

    @tag(skip: "requires_vulkan")
    it "copies data to buffer":
        require_vulkan()
        vulkan_init()
        vulkan_select_device(0)

        val buffer = vulkan_alloc_storage(16)
        val data: [u8] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        assert vulkan_copy_to(buffer, data)
        vulkan_free_buffer(buffer)

    @tag(skip: "requires_vulkan")
    it "copies data from buffer":
        require_vulkan()
        vulkan_init()
        vulkan_select_device(0)

        val buffer = vulkan_alloc_storage(16)
        val src: [u8] = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160]
        vulkan_copy_to(buffer, src)

        var dst: [u8] = []
        for i in 0..16:
            dst.push(0)

        assert vulkan_copy_from(dst, buffer)
        vulkan_free_buffer(buffer)

    @tag(skip: "requires_vulkan")
    it "copies between buffers":
        require_vulkan()
        vulkan_init()
        vulkan_select_device(0)

        val src = vulkan_alloc_storage(1024)
        val dst = vulkan_alloc_storage(1024)

        assert vulkan_copy_buffer(dst, src, 1024)

        vulkan_free_buffer(src)
        vulkan_free_buffer(dst)

describe "Vulkan Shader Compilation":
    @tag(skip: "requires_vulkan")
    it "compiles GLSL compute shader":
        require_vulkan()
        vulkan_init()
        vulkan_select_device(0)

        val shader = vulkan_compile_glsl(VECTOR_ADD_GLSL)
        assert shader.is_valid
        vulkan_destroy_shader(shader)

    @tag(skip: "requires_vulkan")
    it "creates compute pipeline":
        require_vulkan()
        vulkan_init()
        vulkan_select_device(0)

        val shader = vulkan_compile_glsl(VECTOR_ADD_GLSL)
        assert shader.is_valid

        val pipeline = vulkan_create_pipeline(shader, "main")
        assert pipeline.is_valid

        vulkan_destroy_pipeline(pipeline)
        vulkan_destroy_shader(shader)

describe "Vulkan Descriptor Sets":
    @tag(skip: "requires_vulkan")
    it "creates descriptor set":
        require_vulkan()
        vulkan_init()
        vulkan_select_device(0)

        val shader = vulkan_compile_glsl(VECTOR_ADD_GLSL)
        val pipeline = vulkan_create_pipeline(shader, "main")

        val descriptors = vulkan_create_descriptors(pipeline)
        assert descriptors.is_valid

        vulkan_destroy_descriptors(descriptors)
        vulkan_destroy_pipeline(pipeline)
        vulkan_destroy_shader(shader)

    @tag(skip: "requires_vulkan")
    it "binds buffers to descriptors":
        require_vulkan()
        vulkan_init()
        vulkan_select_device(0)

        val shader = vulkan_compile_glsl(VECTOR_ADD_GLSL)
        val pipeline = vulkan_create_pipeline(shader, "main")
        val descriptors = vulkan_create_descriptors(pipeline)

        val buffer = vulkan_alloc_storage(1024)
        assert vulkan_bind_buffer(descriptors, 0, buffer)

        vulkan_free_buffer(buffer)
        vulkan_destroy_descriptors(descriptors)
        vulkan_destroy_pipeline(pipeline)
        vulkan_destroy_shader(shader)

describe "Vulkan Command Execution":
    @tag(skip: "requires_vulkan")
    it "records and submits commands":
        require_vulkan()
        vulkan_init()
        vulkan_select_device(0)

        val cmd = vulkan_begin_compute()
        assert cmd.is_valid
        assert vulkan_end_compute(cmd)
        assert vulkan_submit_and_wait(cmd)

    @tag(skip: "requires_vulkan")
    it "waits for device idle":
        require_vulkan()
        vulkan_init()
        vulkan_select_device(0)
        assert vulkan_wait_idle()

describe "Vulkan Compute Dispatch":
    @tag(skip: "requires_vulkan")
    it "runs vector add kernel":
        require_vulkan()
        val gpu = gpu_vulkan(0)

        # Allocate buffers
        val n: i64 = 256
        val size = n * 4  # 4 bytes per float
        val a = gpu_alloc(gpu, size)
        val b = gpu_alloc(gpu, size)
        val c = gpu_alloc(gpu, size)

        # Initialize with test data
        val data_a = make_f32_array(n, 1.0)
        val data_b = make_f32_array(n, 2.0)
        gpu_copy_to(a, data_a)
        gpu_copy_to(b, data_b)

        # Run vector add
        val success = gpu_vector_add(gpu, a, b, c, n)
        assert success

        # Cleanup
        gpu_free(a)
        gpu_free(b)
        gpu_free(c)

describe "Vulkan Error Handling":
    @tag(skip: "requires_vulkan")
    it "gets last error message":
        require_vulkan()
        vulkan_init()
        val error = vulkan_last_error()
        # After successful operations, error should be empty
        assert true

describe "Vulkan GPU Wrapper":
    @tag(skip: "requires_vulkan")
    it "creates gpu_vulkan device wrapper":
        require_vulkan()
        val gpu = gpu_vulkan(0)
        assert gpu.is_valid()
        assert gpu.backend_name() == "Vulkan"

    @tag(skip: "requires_vulkan")
    it "synchronizes via wrapper":
        require_vulkan()
        val gpu = gpu_vulkan(0)
        assert gpu.sync()
