# Module System - Real System Tests
#
# Tests the module import system via subprocess execution.
# Verifies use import syntax, path resolution, and module function calls.

use std.text.{NL}

extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn file_write(path: text, content: text) -> bool:
    rt_file_write_text(path, content)

fn write_source(path: text, content: text) -> bool:
    val cmd = "cat > " + path + " << 'SIMPLE_WRITE_EOF'" + NL + content + NL + "SIMPLE_WRITE_EOF"
    val (out, err, code) = rt_process_run("/bin/sh", ["-c", cmd])
    code == 0

fn interp_print(varname: text) -> text:
    "print \"" + "{" + varname + "}" + "\""

fn file_delete(path: text) -> bool:
    rt_file_delete(path)

fn process_run(cmd: text, args: [text]) -> (text, text, i64):
    rt_process_run(cmd, args)

describe "Module System - Import Syntax":
    it "use module.{func} imports a single function":
        val mod_path = "/tmp/sml_sys_mod_single.spl"
        val main_path = "/tmp/sml_sys_main_single.spl"

        val mod_src = "fn ping() -> text:" + NL + "    \"pong\""
        write_source(mod_path, mod_src)

        val main_src = "use sml_sys_mod_single." + "{" + "ping" + "}" + NL + NL + "print ping()"
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("pong")

        file_delete(mod_path)
        file_delete(main_path)

    it "use module.{a, b} imports multiple functions":
        val mod_path = "/tmp/sml_sys_mod_multi.spl"
        val main_path = "/tmp/sml_sys_main_multi.spl"

        val mod_src = "fn foo() -> text:" + NL + "    \"foo\"" + NL + NL + "fn bar() -> text:" + NL + "    \"bar\""
        write_source(mod_path, mod_src)

        val main_src = "use sml_sys_mod_multi." + "{" + "foo, bar" + "}" + NL + NL + "print foo()" + NL + "print bar()"
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout).to_contain("foo")
        expect(stdout).to_contain("bar")

        file_delete(mod_path)
        file_delete(main_path)

    it "imported function can call local function in its module":
        val mod_path = "/tmp/sml_sys_mod_local.spl"
        val main_path = "/tmp/sml_sys_main_local.spl"

        val mod_src = "fn helper() -> i64:" + NL + "    7" + NL + NL + "fn compute() -> i64:" + NL + "    helper() * helper()"
        write_source(mod_path, mod_src)

        val main_src = "use sml_sys_mod_local." + "{" + "compute" + "}" + NL + NL + "val result = compute()" + NL + interp_print("result")
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("49")

        file_delete(mod_path)
        file_delete(main_path)

describe "Module System - Function Calls":
    it "module function with multiple arguments":
        val mod_path = "/tmp/sml_sys_mod_args.spl"
        val main_path = "/tmp/sml_sys_main_args.spl"

        val mod_src = "fn max3(a: i64, b: i64, c: i64) -> i64:" + NL + "    var m = a" + NL + "    if b > m:" + NL + "        m = b" + NL + "    if c > m:" + NL + "        m = c" + NL + "    m"
        write_source(mod_path, mod_src)

        val main_src = "use sml_sys_mod_args." + "{" + "max3" + "}" + NL + NL + "val result = max3(3, 7, 2)" + NL + interp_print("result")
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("7")

        file_delete(mod_path)
        file_delete(main_path)

    it "module from one file imports another module":
        val lib_path = "/tmp/sml_sys_lib.spl"
        val app_path = "/tmp/sml_sys_app.spl"
        val main_path = "/tmp/sml_sys_chain_main.spl"

        val lib_src = "fn square(n: i64) -> i64:" + NL + "    n * n"
        write_source(lib_path, lib_src)

        val app_src = "use sml_sys_lib." + "{" + "square" + "}" + NL + NL + "fn sum_squares(a: i64, b: i64) -> i64:" + NL + "    square(a) + square(b)"
        write_source(app_path, app_src)

        val main_src = "use sml_sys_app." + "{" + "sum_squares" + "}" + NL + NL + "val result = sum_squares(3, 4)" + NL + interp_print("result")
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout.trim()).to_equal("25")

        file_delete(lib_path)
        file_delete(app_path)
        file_delete(main_path)

describe "Module System - std Module Access":
    it "std.text.NL is accessible when imported":
        val main_path = "/tmp/sml_sys_std_text_main.spl"
        val main_src = "use std.text." + "{" + "NL" + "}" + NL + NL + "val msg = \"line1\" + NL + \"line2\"" + NL + "print msg"
        write_source(main_path, main_src)

        val (stdout, stderr, code) = process_run("bin/release/simple", [main_path])
        expect(code).to_equal(0)
        expect(stdout).to_contain("line1")
        expect(stdout).to_contain("line2")

        file_delete(main_path)
