# Standalone test for Claude CLI wrapper
# Run with: bin/simple run test_claude_cli_wrapper.spl

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn _unwrap_idx(opt) -> i64:
    match opt:
        Some(i): return i
        nil: return -1

fn _extract_json_string(json: text, key: text) -> text:
    val quote = "\""
    val search = quote + key + quote + ":"
    val idx = _unwrap_idx(json.index_of(search))
    if idx < 0:
        return ""
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    if trimmed.starts_with(quote):
        val rest = trimmed.substring(1)
        var end = 0
        var escaped = false
        while end < rest.len():
            val ch = rest[end]
            if escaped:
                escaped = false
            elif ch == "\\":
                escaped = true
            elif ch == "\"":
                return rest.substring(0, end)
            end = end + 1
    ""

fn _extract_json_bool(json: text, key: text) -> bool:
    val quote = "\""
    val search = quote + key + quote + ":"
    val idx = _unwrap_idx(json.index_of(search))
    if idx < 0:
        return false
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    trimmed.starts_with("true")

print "========================================="
print "Claude CLI Wrapper Integration Test"
print "========================================="
print ""

# Test 1: Version check
print "[TEST 1] Checking Claude CLI version..."
val version_result = rt_process_run("claude", ["--version"])
val version_stdout = version_result.0 ?? ""
val version_exit = version_result.2
print "Exit code: " + version_exit.to_text()
print "Version: " + version_stdout.trim()
if version_exit == 0:
    print "✓ Claude CLI is available"
else:
    print "✗ Claude CLI not found"
    print "ERROR: Cannot proceed with tests"
print ""

# Test 2: Simple prompt
print "[TEST 2] Sending simple prompt..."
var args: [text] = []
args = args + ["-p", "Say exactly: TEST_OK"]
args = args + ["--output-format", "json"]
args = args + ["--model", "claude-haiku-4-5-20251001"]

val result = rt_process_run("claude", args)
val stdout = result.0 ?? ""
val stderr = result.1 ?? ""
val exit_code = result.2

print "Exit code: " + exit_code.to_text()
if stderr != "":
    print "Stderr: " + stderr

if exit_code != 0:
    print "✗ Claude CLI failed"
    print ""
else:
    val response = _extract_json_string(stdout, "result")
    val is_error = _extract_json_bool(stdout, "is_error")
    val session_id = _extract_json_string(stdout, "session_id")

    print "Response: " + response
    print "Is error: " + is_error.to_text()
    print "Session ID length: " + session_id.len().to_text()

    if is_error:
        print "✗ Claude returned error"
    elif not response.contains("TEST_OK"):
        print "✗ Response doesn't contain expected text"
    elif session_id.len() == 0:
        print "✗ No session ID returned"
    else:
        print "✓ Simple prompt works"
    print ""

# Test 3: Multi-turn conversation
print "[TEST 3] Testing multi-turn conversation..."
var args1: [text] = []
args1 = args1 + ["-p", "My secret code is ALPHA123. Remember it."]
args1 = args1 + ["--output-format", "json"]
args1 = args1 + ["--model", "claude-haiku-4-5-20251001"]

val result1 = rt_process_run("claude", args1)
val stdout1 = result1.0 ?? ""
val exit1 = result1.2

if exit1 != 0:
    print "✗ First turn failed"
    print ""
else:
    val session_id = _extract_json_string(stdout1, "session_id")
    print "Turn 1 session ID: " + session_id

    var args2: [text] = []
    args2 = args2 + ["-p", "What is my secret code?"]
    args2 = args2 + ["--output-format", "json"]
    args2 = args2 + ["--model", "claude-haiku-4-5-20251001"]
    args2 = args2 + ["--resume", session_id]

    val result2 = rt_process_run("claude", args2)
    val stdout2 = result2.0 ?? ""
    val exit2 = result2.2

    if exit2 != 0:
        print "✗ Second turn failed"
    else:
        val response2 = _extract_json_string(stdout2, "result")
        print "Turn 2 response: " + response2

        if response2.contains("ALPHA123"):
            print "✓ Multi-turn conversation works"
        else:
            print "✗ Context not maintained"
    print ""

# Test 4: System prompt
print "[TEST 4] Testing system prompt..."
var args_sys: [text] = []
args_sys = args_sys + ["-p", "What should I say?"]
args_sys = args_sys + ["--output-format", "json"]
args_sys = args_sys + ["--model", "claude-haiku-4-5-20251001"]
args_sys = args_sys + ["--system-prompt", "Always respond with EXACTLY: SYSTEM_OK"]

val result_sys = rt_process_run("claude", args_sys)
val stdout_sys = result_sys.0 ?? ""
val exit_sys = result_sys.2

if exit_sys != 0:
    print "✗ System prompt test failed"
else:
    val response_sys = _extract_json_string(stdout_sys, "result")
    print "Response: " + response_sys

    if response_sys.contains("SYSTEM_OK"):
        print "✓ System prompt works"
    else:
        print "✗ System prompt not respected"
print ""

# Test 5: Special characters
print "[TEST 5] Testing special characters..."
var args_special: [text] = []
args_special = args_special + ["-p", "Echo this: \"quoted\" and newline\ntest"]
args_special = args_special + ["--output-format", "json"]
args_special = args_special + ["--model", "claude-haiku-4-5-20251001"]

val result_special = rt_process_run("claude", args_special)
val stdout_special = result_special.0 ?? ""
val exit_special = result_special.2

if exit_special != 0:
    print "✗ Special characters test failed"
else:
    val response_special = _extract_json_string(stdout_special, "result")
    print "Response length: " + response_special.len().to_text()
    print "Contains 'quoted': " + response_special.contains("quoted").to_text()
    print "✓ Special characters handled"
print ""

print "========================================="
print "Integration Test Complete"
print "========================================="
