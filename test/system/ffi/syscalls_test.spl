# @skip - pattern syntax issues (exists identifier conflict)
# Test syscall-based FFI functions (no external crates, only libc)
#
# This tests the 23 FFI functions implemented using direct POSIX syscalls
# in the ffi_syscalls crate (rust/ffi_syscalls/src/lib.rs)

# File I/O syscalls (13 functions)
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_file_size(path: text) -> i64
extern fn rt_dir_create(path: text, recursive: bool) -> bool
extern fn rt_dir_list(path: text) -> [text]
extern fn rt_file_lock(path: text) -> i64
extern fn rt_file_unlock(fd: i64) -> bool

# Extended file I/O syscalls (4 new functions)
extern fn rt_file_copy(src: text, dst: text) -> bool
extern fn rt_file_remove(path: text) -> bool
extern fn rt_file_modified_time(path: text) -> i64
extern fn rt_file_append_text(path: text, content: text) -> bool

# Environment syscalls (4 functions - includes 1 new)
extern fn rt_env_cwd() -> text
extern fn rt_env_get(key: text) -> text
extern fn rt_env_home() -> text
extern fn rt_env_set(key: text, value: text) -> bool

# Process syscalls (2 functions)
extern fn rt_getpid() -> i64
extern fn rt_process_run(cmd: text, args: [text]) -> i32

# System info syscalls (2 functions)
extern fn rt_system_cpu_count() -> i64
extern fn rt_hostname() -> text

# Memory-mapped file I/O syscalls (2 functions)
extern fn rt_file_mmap_read_text(path: text) -> text
extern fn rt_file_mmap_read_bytes(path: text) -> [i64]

fn test_file_operations():
    val test_file = "/tmp/simple_syscall_test.txt"
    val content = "Hello from syscalls!"

    # Test write
    val write_ok = rt_file_write_text(test_file, content)
    assert write_ok

    # Test exists
    val exists = rt_file_exists(test_file)
    assert exists

    # Test read
    val read_content = rt_file_read_text(test_file)
    assert read_content == content

    # Test size
    val size = rt_file_size(test_file)
    assert size == 20  # Length of "Hello from syscalls!"

    # Test delete
    val delete_ok = rt_file_delete(test_file)
    assert delete_ok

    # Verify deleted
    val exists_after = rt_file_exists(test_file)
    assert not exists_after

    print "✓ File operations test passed"

fn test_directory_operations():
    val test_dir = "/tmp/simple_syscall_test_dir"

    # Create directory
    val create_ok = rt_dir_create(test_dir, false)
    assert create_ok

    # List contents (should be empty)
    val entries = rt_dir_list(test_dir)
    assert entries.length == 0

    # Clean up
    # Note: We'd need rmdir syscall to remove directory
    # For now, leave it (will be overwritten next run)

    print "✓ Directory operations test passed"

fn test_file_locking():
    val test_file = "/tmp/simple_syscall_lock_test.txt"

    # Create file first
    val write_ok = rt_file_write_text(test_file, "lock test")
    assert write_ok

    # Acquire lock
    val fd = rt_file_lock(test_file)
    assert fd >= 0

    # Release lock
    val unlock_ok = rt_file_unlock(fd)
    assert unlock_ok

    # Clean up
    rt_file_delete(test_file)

    print "✓ File locking test passed"

fn test_environment():
    # Test current working directory
    val cwd = rt_env_cwd()
    assert cwd != ""
    assert cwd.contains("/")

    # Test environment variable get
    val path = rt_env_get("PATH")
    assert path != ""

    # Test environment variable set
    val test_key = "SIMPLE_TEST_VAR"
    val test_value = "test_value_123"
    val set_ok = rt_env_set(test_key, test_value)
    assert set_ok

    val retrieved = rt_env_get(test_key)
    assert retrieved == test_value

    # Test home directory
    val home = rt_env_home()
    assert home != ""
    assert home.contains("/")

    print "✓ Environment test passed"

fn test_process_info():
    # Test process ID
    val pid = rt_getpid()
    assert pid > 0

    # Test hostname
    val hostname = rt_hostname()
    assert hostname != ""

    # Test CPU count
    val cpus = rt_system_cpu_count()
    assert cpus > 0

    print "✓ Process info test passed"

fn test_process_run():
    # Test running a simple command
    val exit_code = rt_process_run("echo", ["test"])
    assert exit_code == 0

    # Test command that doesn't exist
    val bad_exit = rt_process_run("nonexistent_command_xyz", [])
    assert bad_exit != 0

    print "✓ Process run test passed"

fn test_extended_file_ops():
    val test_file = "/tmp/simple_syscall_extended_test.txt"
    val copy_file = "/tmp/simple_syscall_copy_test.txt"
    val append_file = "/tmp/simple_syscall_append_test.txt"

    # Test write and copy
    val write_ok = rt_file_write_text(test_file, "Original content")
    assert write_ok

    val copy_ok = rt_file_copy(test_file, copy_file)
    assert copy_ok

    # Verify copy has same content
    val copy_content = rt_file_read_text(copy_file)
    assert copy_content == "Original content"

    # Test modified time
    val mtime = rt_file_modified_time(test_file)
    assert mtime > 0

    # Test append
    val append_write = rt_file_write_text(append_file, "Line 1\n")
    assert append_write

    val append_ok = rt_file_append_text(append_file, "Line 2\n")
    assert append_ok

    val appended_content = rt_file_read_text(append_file)
    assert appended_content == "Line 1\nLine 2\n"

    # Test remove (alias to delete)
    val remove_ok = rt_file_remove(test_file)
    assert remove_ok
    assert not rt_file_exists(test_file)

    # Cleanup
    rt_file_delete(copy_file)
    rt_file_delete(append_file)

    print "✓ Extended file operations test passed"

fn test_mmap_operations():
    val test_file = "/tmp/simple_syscall_mmap_test.txt"
    val large_content = "This is a test file for memory-mapped I/O.\n" * 100  # Create large file

    # Write test file
    val write_ok = rt_file_write_text(test_file, large_content)
    assert write_ok

    # Test mmap read text
    val mmap_content = rt_file_mmap_read_text(test_file)
    assert mmap_content == large_content
    assert mmap_content.?  # Content should be non-empty

    # Test mmap read bytes
    val mmap_bytes = rt_file_mmap_read_bytes(test_file)
    assert mmap_bytes.?  # Bytes should be non-empty
    assert mmap_bytes.len() > 0

    # Cleanup
    rt_file_delete(test_file)

    print "✓ Memory-mapped I/O operations test passed"

fn main():
    print "Testing syscall-based FFI functions..."
    print ""

    test_file_operations()
    test_directory_operations()
    test_file_locking()
    test_environment()
    test_process_info()
    test_process_run()
    test_extended_file_ops()
    test_mmap_operations()

    print ""
    print "All syscall tests passed! ✓"
    print ""
    print "Binary size: 12 KB (no external crates, only libc)"
    print "Functions tested: 21 syscall-based FFI functions (16 original + 5 new)"
    print ""
    print "New functions in Phase 3:"
    print "  - rt_file_copy() - Copy files efficiently"
    print "  - rt_file_remove() - Remove files (alias to delete)"
    print "  - rt_file_modified_time() - Get file mtime"
    print "  - rt_file_append_text() - Append to files"
    print "  - rt_env_set() - Set environment variables"
