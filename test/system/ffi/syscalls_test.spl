# Test syscall-based FFI functions (no external crates, only libc)

use std.spec

extern fn rt_file_mmap_read_text(path: text) -> text
extern fn rt_file_mmap_read_bytes(path: text) -> [i64]
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool

describe "Syscalls FFI Test":
    it "file exists check":
        val result = rt_file_exists("VERSION")
        check(result)

    it "mmap read text returns file content":
        val result = rt_file_mmap_read_text("VERSION")
        val content = result ?? ""
        check(content != "")

    it "mmap read text matches regular read":
        val mmap_result = rt_file_mmap_read_text("VERSION")
        val mmap_text = mmap_result ?? ""
        val regular_result = rt_file_read_text("VERSION")
        val regular_text = regular_result ?? ""
        expect(mmap_text).to_equal(regular_text)

    it "mmap read text handles large files":
        val result = rt_file_mmap_read_text("CLAUDE.md")
        val content = result ?? ""
        check(content.length > 1000)

    it "mmap read text returns empty for missing file":
        val result = rt_file_mmap_read_text("NONEXISTENT_FILE_12345.txt")
        val content = result ?? ""
        expect(content).to_equal("")

    it "mmap read bytes returns data":
        val result = rt_file_mmap_read_bytes("VERSION")
        check(true)

    it "directory operations":
        # Test rt_dir_remove_all via app.io wrapper
        extern fn rt_dir_remove_all(path: text) -> bool
        val test_dir = "/tmp/simple_test_dir_syscalls"
        val (out1, err1, code1) = rt_process_run("mkdir", ["-p", test_dir + "/subdir"])
        expect(code1).to_equal(0)
        val result = rt_dir_remove_all(test_dir)
        expect(result).to_equal(true)

    it "file locking":
        # Test rt_file_lock/unlock FFI functions
        extern fn rt_file_lock(path: text, timeout_secs: i64) -> i64
        extern fn rt_file_unlock(handle: i64) -> bool
        val test_file = "/tmp/simple_test_lock.txt"
        val (out, err, code) = rt_process_run("touch", [test_file])
        expect(code).to_equal(0)
        val handle = rt_file_lock(test_file, 5)
        expect(handle).to_be_greater_than(-1)
        val unlock_result = rt_file_unlock(handle)
        expect(unlock_result).to_equal(true)

    it "process run":
        val (stdout, stderr, code) = rt_process_run("echo", ["hello"])
        expect(stdout.contains("hello")).to_equal(true)
        expect(code).to_equal(0)
