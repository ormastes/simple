# Test syscall-based FFI functions (no external crates, only libc)

use std.spec

extern fn rt_file_mmap_read_text(path: text) -> text
extern fn rt_file_mmap_read_bytes(path: text) -> [i64]
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool

describe "Syscalls FFI Test":
    it "file exists check":
        val result = rt_file_exists("VERSION")
        check(result)

    it "mmap read text returns file content":
        val result = rt_file_mmap_read_text("VERSION")
        val content = result ?? ""
        check(content != "")

    it "mmap read text matches regular read":
        val mmap_result = rt_file_mmap_read_text("VERSION")
        val mmap_text = mmap_result ?? ""
        val regular_result = rt_file_read_text("VERSION")
        val regular_text = regular_result ?? ""
        expect(mmap_text).to_equal(regular_text)

    it "mmap read text handles large files":
        val result = rt_file_mmap_read_text("CLAUDE.md")
        val content = result ?? ""
        check(content.length > 1000)

    it "mmap read text returns empty for missing file":
        val result = rt_file_mmap_read_text("NONEXISTENT_FILE_12345.txt")
        val content = result ?? ""
        expect(content).to_equal("")

    it "mmap read bytes returns data":
        val result = rt_file_mmap_read_bytes("VERSION")
        check(true)

    skip_it "directory operations":
        # TODO: needs rt_dir_* syscall wrappers
        check(true)

    skip_it "file locking":
        # TODO: needs rt_file_lock/unlock syscall wrappers
        check(true)

    it "process run":
        val (stdout, stderr, code) = rt_process_run("echo", ["hello"])
        expect(stdout.contains("hello")).to_equal(true)
        expect(code).to_equal(0)
