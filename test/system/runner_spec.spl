"""
Property Testing Framework - Runner Tests
Feature: Property test execution engine with configurable iterations and shrinking
"""

# Simple LCG random number generator
fn lcg_next(seed: i64) -> i64:
    val a = 1103515245
    val c = 12345
    val m = 2147483648
    return ((a * seed + c) % m).abs()

fn gen_i64(seed: i64) -> i64:
    return lcg_next(seed=seed)

fn gen_i64_range(seed: i64, min: i64, max: i64) -> i64:
    val range = max - min
    if range <= 0:
        return min
    val raw = lcg_next(seed=seed)
    return min + (raw % range)

# String generation using predefined characters
fn gen_string_with_length(seed: i64, min: i64, max: i64) -> text:
    val chars = "abcdefghijklmnopqrstuvwxyz"
    val length = gen_i64_range(seed=seed, min=min, max=max)
    var result = ""
    var i = 0
    while i < length:
        val idx = gen_i64_range(seed=seed + i, min=0, max=26)
        result = result + chars.substring(start=idx, end=idx + 1)
        i = i + 1
    return result

fn gen_list_i64(seed: i64, min_len: i64, max_len: i64, val_min: i64, val_max: i64) -> [i64]:
    val size = gen_i64_range(seed=seed, min=min_len, max=max_len)
    var result = []
    var i = 0
    while i < size:
        result.push(gen_i64_range(seed=seed + i + 1, min=val_min, max=val_max))
        i = i + 1
    return result

# Shrinking implementations
fn shrink_i64(value: i64) -> [i64]:
    if value == 0:
        return []
    var candidates = [0]
    candidates.push(value / 2)
    if value > 0:
        candidates.push(value - 1)
    else:
        candidates.push(value + 1)
    return candidates

# Property test result types
enum PropertyResultType:
    Success
    Failure
    Timeout

struct PropertyTestResult:
    result_type: PropertyResultType
    iterations: i64
    original_input: i64
    minimal_input: i64
    shrinks: i64

# Shrinking helper
fn shrink_to_minimal(failing_value: i64, test_fn: fn(i64) -> bool, max_shrinks: i64) -> (i64, i64):
    var current = failing_value
    var shrink_count = 0

    while shrink_count < max_shrinks:
        val candidates = shrink_i64(value=current)
        if len(candidates) == 0:
            return (current, shrink_count)

        var found_smaller = false
        for candidate in candidates:
            if not test_fn(candidate):
                current = candidate
                shrink_count = shrink_count + 1
                found_smaller = true
                break

        if not found_smaller:
            return (current, shrink_count)

    return (current, shrink_count)

# Main property test runner
fn run_property_test(test_fn: fn(i64) -> bool, seed: i64, iterations: i64, max_shrinks: i64) -> PropertyTestResult:
    var i = 0
    while i < iterations:
        val input = gen_i64(seed=seed + i)
        if not test_fn(input):
            val (minimal, shrinks) = shrink_to_minimal(failing_value=input, test_fn=test_fn, max_shrinks=max_shrinks)
            return PropertyTestResult(
                result_type: PropertyResultType.Failure,
                iterations: i,
                original_input: input,
                minimal_input: minimal,
                shrinks: shrinks
            )
        i = i + 1

    return PropertyTestResult(
        result_type: PropertyResultType.Success,
        iterations: iterations,
        original_input: 0,
        minimal_input: 0,
        shrinks: 0
    )

fn run_property_test_range(test_fn: fn(i64) -> bool, seed: i64, min: i64, max: i64, iterations: i64, max_shrinks: i64) -> PropertyTestResult:
    var i = 0
    while i < iterations:
        val input = gen_i64_range(seed=seed + i, min=min, max=max)
        if not test_fn(input):
            val (minimal, shrinks) = shrink_to_minimal(failing_value=input, test_fn=test_fn, max_shrinks=max_shrinks)
            return PropertyTestResult(
                result_type: PropertyResultType.Failure,
                iterations: i,
                original_input: input,
                minimal_input: minimal,
                shrinks: shrinks
            )
        i = i + 1

    return PropertyTestResult(
        result_type: PropertyResultType.Success,
        iterations: iterations,
        original_input: 0,
        minimal_input: 0,
        shrinks: 0
    )

# Quick check with reduced iterations
fn quick_check(test_fn: fn(i64) -> bool, seed: i64) -> bool:
    val result = run_property_test(test_fn=test_fn, seed=seed, iterations=10, max_shrinks=10)
    return result.result_type == PropertyResultType.Success

# Thorough check with many iterations
fn thorough_check(test_fn: fn(i64) -> bool, seed: i64) -> bool:
    val result = run_property_test(test_fn=test_fn, seed=seed, iterations=1000, max_shrinks=100)
    return result.result_type == PropertyResultType.Success

describe "Property Test Runner":
    """
    Tests the property test runner including test execution, failure detection,
    shrinking integration, configuration options, and common property examples.
    """

    context "Basic Execution":
        it "runs property test with generator":
            val result = run_property_test(
                test_fn=|x| x * 0 == 0,
                seed=42,
                iterations=50,
                max_shrinks=100
            )

            # Property x * 0 == 0 always holds
            expect result.result_type == PropertyResultType.Success
            expect result.iterations == 50

        it "detects property violations":
            val result = run_property_test_range(
                test_fn=|x| x < 100,
                seed=42,
                min=0,
                max=200,
                iterations=100,
                max_shrinks=100
            )

            # Should detect the violation
            expect result.result_type == PropertyResultType.Failure
            # Original input should be >= 100
            expect result.original_input >= 100
            # Minimal should also be >= 100
            expect result.minimal_input >= 100

        it "runs specified number of iterations":
            var iteration_count = 0
            val seed = 42

            var i = 0
            while i < 25:
                val value = gen_i64(seed=seed + i)
                iteration_count = iteration_count + 1
                i = i + 1

            expect iteration_count == 25

    context "Shrinking on Failure":
        it "shrinks to minimal failing case":
            val result = run_property_test_range(
                test_fn=|x| x < 50,
                seed=42,
                min=0,
                max=1000,
                iterations=100,
                max_shrinks=50
            )

            # Should find a failure
            if result.result_type == PropertyResultType.Failure:
                # Minimal should be 50 (smallest value that fails)
                expect result.minimal_input == 50
                # Should have performed some shrinks
                expect result.shrinks >= 0
            else:
                # If no failure found, that's also valid
                pass

        it "respects max_shrinks limit":
            val result = run_property_test_range(
                test_fn=|x| x < 1000,
                seed=42,
                min=0,
                max=10000,
                iterations=10,
                max_shrinks=3
            )

            if result.result_type == PropertyResultType.Failure:
                # Should not exceed max_shrinks
                expect result.shrinks <= 3

    context "Configuration":
        it "uses custom seed for reproducibility":
            # Capture generated values
            var values1 = []
            var values2 = []
            var values3 = []

            var i = 0
            while i < 10:
                values1.push(gen_i64(seed=42 + i))
                i = i + 1

            i = 0
            while i < 10:
                values2.push(gen_i64(seed=42 + i))
                i = i + 1

            i = 0
            while i < 10:
                values3.push(gen_i64(seed=123 + i))
                i = i + 1

            # Same seed should produce same sequence
            expect values1 == values2
            # Different seed should produce different sequence
            expect values1 != values3

        it "supports quick check mode":
            # quick_check runs fewer iterations
            val result = quick_check(
                test_fn=|x| x * 0 == 0,
                seed=42
            )

            expect result == true

        it "supports thorough check mode":
            # thorough_check runs many iterations
            val result = thorough_check(
                test_fn=|x| x + 0 == x,
                seed=42
            )

            expect result == true

    context "Property Examples":
        it "tests commutativity":
            var passed = true
            var i = 0
            while i < 100:
                val a = gen_i64_range(seed=42 + i, min=-1000, max=1000)
                val b = gen_i64_range(seed=42 + i + 1000, min=-1000, max=1000)
                if a + b != b + a:
                    passed = false
                    break
                i = i + 1

            expect passed

        it "tests associativity":
            var passed = true
            var i = 0
            while i < 100:
                val a = gen_i64_range(seed=42 + i, min=-100, max=100)
                val b = gen_i64_range(seed=42 + i + 1000, min=-100, max=100)
                val c = gen_i64_range(seed=42 + i + 2000, min=-100, max=100)
                if (a + b) + c != a + (b + c):
                    passed = false
                    break
                i = i + 1

            expect passed

        it "tests identity property":
            var passed = true
            var i = 0
            while i < 100:
                val x = gen_i64(seed=42 + i)
                if x + 0 != x:
                    passed = false
                    break
                i = i + 1

            expect passed

        it "tests reverse twice is identity":
            var passed = true
            var i = 0
            while i < 50:
                val list = gen_list_i64(seed=42 + i, min_len=0, max_len=10, val_min=-100, val_max=100)
                val reversed_twice = list.reverse().reverse()
                if reversed_twice != list:
                    passed = false
                    break
                i = i + 1

            expect passed

        it "tests string concatenation length":
            var passed = true
            var i = 0
            while i < 50:
                val s1 = gen_string_with_length(seed=42 + i, min=0, max=10)
                val s2 = gen_string_with_length(seed=42 + i + 1000, min=0, max=10)
                val concatenated = s1 + s2
                if len(concatenated) != len(s1) + len(s2):
                    passed = false
                    break
                i = i + 1

            expect passed
