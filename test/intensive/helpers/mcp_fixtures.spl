# MCP Test Fixtures and Helpers
# Provides reusable MCP protocol test data and JSON helpers

use std.text_utils.*

# --- JSON Helper Functions (from existing tests) ---

fn jobj(pairs: [text]) -> text:
    var result = "{"
    for i in 0..pairs.length():
        if i > 0:
            result = result + ","
        result = result + pairs[i]
    result = result + "}"
    result

fn jpair(key: text, val_str: text) -> text:
    "\"{key}\":{val_str}"

fn jstr(s: text) -> text:
    # Escape special characters
    var escaped = s
    escaped = str_replace(escaped, "\\", "\\\\")
    escaped = str_replace(escaped, "\"", "\\\"")
    escaped = str_replace(escaped, "\n", "\\n")
    escaped = str_replace(escaped, "\t", "\\t")
    escaped = str_replace(escaped, "\r", "\\r")
    "\"{escaped}\""

fn jnum(n: i64) -> text:
    "{n}"

fn jbool(b: bool) -> text:
    if b:
        "true"
    else:
        "false"

fn jarray(items: [text]) -> text:
    var result = "["
    for i in 0..items.length():
        if i > 0:
            result = result + ","
        result = result + items[i]
    result = result + "]"
    result

fn jnull() -> text:
    "null"

# --- MCP Request Builders ---

fn build_initialize_request(id: i64) -> text:
    jobj([
        jpair("jsonrpc", jstr("2.0")),
        jpair("id", jnum(id)),
        jpair("method", jstr("initialize")),
        jpair("params", jobj([
            jpair("protocolVersion", jstr("2024-11-05")),
            jpair("capabilities", jobj([])),
            jpair("clientInfo", jobj([
                jpair("name", jstr("test-client")),
                jpair("version", jstr("1.0.0"))
            ]))
        ]))
    ])

fn build_resources_list_request(id: i64) -> text:
    jobj([
        jpair("jsonrpc", jstr("2.0")),
        jpair("id", jnum(id)),
        jpair("method", jstr("resources/list"))
    ])

fn build_resources_read_request(id: i64, uri: text) -> text:
    jobj([
        jpair("jsonrpc", jstr("2.0")),
        jpair("id", jnum(id)),
        jpair("method", jstr("resources/read")),
        jpair("params", jobj([
            jpair("uri", jstr(uri))
        ]))
    ])

fn build_prompts_list_request(id: i64) -> text:
    jobj([
        jpair("jsonrpc", jstr("2.0")),
        jpair("id", jnum(id)),
        jpair("method", jstr("prompts/list"))
    ])

fn build_prompts_get_request(id: i64, name: text, arguments: [text]) -> text:
    val args_obj = jobj(arguments)
    jobj([
        jpair("jsonrpc", jstr("2.0")),
        jpair("id", jnum(id)),
        jpair("method", jstr("prompts/get")),
        jpair("params", jobj([
            jpair("name", jstr(name)),
            jpair("arguments", args_obj)
        ]))
    ])

fn build_invalid_request(id: i64) -> text:
    jobj([
        jpair("jsonrpc", jstr("2.0")),
        jpair("id", jnum(id)),
        jpair("method", jstr("invalid/method"))
    ])

fn build_malformed_json() -> text:
    "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"test\""  # Missing closing brace

# --- MCP Response Builders ---

fn build_success_response(id: i64, result: text) -> text:
    jobj([
        jpair("jsonrpc", jstr("2.0")),
        jpair("id", jnum(id)),
        jpair("result", result)
    ])

fn build_error_response(id: i64, code: i64, message: text) -> text:
    jobj([
        jpair("jsonrpc", jstr("2.0")),
        jpair("id", jnum(id)),
        jpair("error", jobj([
            jpair("code", jnum(code)),
            jpair("message", jstr(message))
        ]))
    ])

# --- MCP Resource Data Builders ---

fn build_file_resource(uri: text, name: text, description: text) -> text:
    jobj([
        jpair("uri", jstr(uri)),
        jpair("name", jstr(name)),
        jpair("description", jstr(description)),
        jpair("mimeType", jstr("text/plain"))
    ])

fn build_symbol_resource(uri: text, name: text) -> text:
    jobj([
        jpair("uri", jstr(uri)),
        jpair("name", jstr(name)),
        jpair("description", jstr("Symbol: {name}")),
        jpair("mimeType", jstr("text/plain"))
    ])

fn build_bugdb_resource(uri: text, name: text) -> text:
    jobj([
        jpair("uri", jstr(uri)),
        jpair("name", jstr(name)),
        jpair("description", jstr("Bug Database: {name}")),
        jpair("mimeType", jstr("application/json"))
    ])

# --- MCP Prompt Data Builders ---

fn build_prompt_info(name: text, description: text, arguments: [text]) -> text:
    val args_array = jarray(arguments)
    jobj([
        jpair("name", jstr(name)),
        jpair("description", jstr(description)),
        jpair("arguments", args_array)
    ])

fn build_prompt_argument(name: text, description: text, required: bool) -> text:
    jobj([
        jpair("name", jstr(name)),
        jpair("description", jstr(description)),
        jpair("required", jbool(required))
    ])

# --- Bug Database JSON Builders ---

fn build_bug_json(id: text, severity: text, status: text, title: text) -> text:
    jobj([
        jpair("id", jstr(id)),
        jpair("severity", jstr(severity)),
        jpair("status", jstr(status)),
        jpair("title", jstr(title)),
        jpair("file", jstr("test/file.spl")),
        jpair("line", jnum(100)),
        jpair("reproducible_by", jstr("test_{id}")),
        jpair("description", jarray([jstr("Test description")])),
        jpair("fix_strategy", jarray([])),
        jpair("investigation_log", jarray([]))
    ])

fn build_bug_array_json(bugs: [(text, text, text, text)]) -> text:
    var bug_jsons = []
    for bug in bugs:
        val (id, severity, status, title) = bug
        bug_jsons = bug_jsons + [build_bug_json(id, severity, status, title)]
    jarray(bug_jsons)

fn build_bugdb_stats_json(total: i64, open: i64, critical: i64) -> text:
    jobj([
        jpair("total", jnum(total)),
        jpair("open", jnum(open)),
        jpair("investigating", jnum(0)),
        jpair("fixed", jnum(0)),
        jpair("closed", jnum(total - open)),
        jpair("critical", jnum(critical)),
        jpair("high", jnum(0)),
        jpair("medium", jnum(0)),
        jpair("low", jnum(0))
    ])

# --- JSON Extraction Helpers ---

fn extract_json_string(json: text, key: text) -> text:
    # Simple JSON string extraction (not a full parser)
    # NOTE: Avoids str_find/index_of (returns Option which triggers "cannot convert
    # enum to int" bug) and s[i] character indexing (same bug). Uses .contains()
    # for existence check and .substring() + manual scanning for extraction.
    val key_pattern = "\"" + key + "\":"
    if not json.contains(key_pattern):
        return ""

    # Find key_pattern position manually
    var start_idx = -1
    var scan = 0
    val kp_len = key_pattern.length()
    while scan <= json.length() - kp_len:
        if json.substring(scan, scan + kp_len) == key_pattern:
            start_idx = scan
            break
        scan = scan + 1

    if start_idx < 0:
        return ""

    val value_start = start_idx + kp_len
    val json_rest = json.substring(value_start, json.length())

    # Skip whitespace using .substring() character access
    var i = 0
    while i < json_rest.length():
        val ch = json_rest.substring(i, i + 1)
        if ch == " " or ch == "\t" or ch == "\n":
            i = i + 1
        else:
            break

    if i >= json_rest.length():
        return ""

    # Check if value is a string (starts with ")
    val first_ch = json_rest.substring(i, i + 1)
    if first_ch == "\"":
        # Find closing quote
        var j = i + 1
        while j < json_rest.length():
            if json_rest.substring(j, j + 1) == "\"":
                return json_rest.substring(i + 1, j)
            j = j + 1
        return ""

    ""

fn is_digit_char(ch: text) -> bool:
    ch == "0" or ch == "1" or ch == "2" or ch == "3" or ch == "4" or ch == "5" or ch == "6" or ch == "7" or ch == "8" or ch == "9"

fn extract_json_number(json: text, key: text) -> i64:
    # NOTE: Uses manual scanning and .substring() to avoid enum-to-int bugs.
    val key_pattern = "\"" + key + "\":"
    if not json.contains(key_pattern):
        return 0

    # Find key_pattern position manually
    var start_idx = -1
    var scan = 0
    val kp_len = key_pattern.length()
    while scan <= json.length() - kp_len:
        if json.substring(scan, scan + kp_len) == key_pattern:
            start_idx = scan
            break
        scan = scan + 1

    if start_idx < 0:
        return 0

    val value_start = start_idx + kp_len
    val json_rest = json.substring(value_start, json.length())

    # Skip whitespace
    var i = 0
    while i < json_rest.length():
        val ch = json_rest.substring(i, i + 1)
        if ch == " " or ch == "\t":
            i = i + 1
        else:
            break

    var num_str = ""
    while i < json_rest.length():
        val ch = json_rest.substring(i, i + 1)
        if is_digit_char(ch):
            num_str = num_str + ch
            i = i + 1
        else:
            break

    if num_str.length() > 0:
        num_str.to_int()
    else:
        0

fn json_contains(json: text, substring: text) -> bool:
    str_find(json, substring) >= 0

fn json_contains_key(json: text, key: text) -> bool:
    json_contains(json, "\"{key}\":")

# --- Test URI Builders ---

fn build_file_uri(path: text) -> text:
    "file://{path}"

fn build_symbol_uri(file: text, symbol: text) -> text:
    "symbol://{file}#{symbol}"

fn build_type_uri(type_name: text) -> text:
    "type://{type_name}"

fn build_bugdb_uri(query: text) -> text:
    "bugdb://{query}"

# --- Assertion Helpers ---

fn assert_valid_json_rpc(json: text):
    assert json_contains_key(json, "jsonrpc")
    val version = extract_json_string(json, "jsonrpc")
    assert version == "2.0"

fn assert_has_id(json: text, expected_id: i64):
    assert json_contains_key(json, "id")
    val id = extract_json_number(json, "id")
    assert id == expected_id

fn assert_has_result(json: text):
    assert json_contains_key(json, "result")

fn assert_has_error(json: text):
    assert json_contains_key(json, "error")

fn assert_error_code(json: text, expected_code: i64):
    assert_has_error(json)
    # Would need more sophisticated extraction for nested error.code

# --- Test Data Collections ---

fn get_test_uris() -> [text]:
    [
        build_file_uri("src/main.spl"),
        build_symbol_uri("src/main.spl", "main"),
        build_type_uri("String"),
        build_bugdb_uri("all"),
        build_bugdb_uri("open"),
        build_bugdb_uri("critical")
    ]

fn get_test_prompt_names() -> [text]:
    [
        "refactor-extract-function",
        "refactor-rename-symbol",
        "generate-tests",
        "generate-docs",
        "analyze-find-bugs",
        "analyze-performance"
    ]
