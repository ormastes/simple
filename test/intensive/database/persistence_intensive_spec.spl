# Database Persistence Intensive Testing
# Tests for save/load operations, file I/O, error handling

use lib.database.core.{StringInterner, SdnTable, SdnRow, SdnDatabase}
use lib.database.bug.{BugDatabase, Bug, BugSeverity, BugStatus}
use test.lib.database_fixtures.{generate_simple_bug, generate_bug_database, cleanup_test_file, cleanup_test_files}

describe "Bug Database Persistence - Intensive":
    context "save and load operations":
        it "handles save/load roundtrip with 100 bugs":
            val test_file = "/tmp/test_bugdb_100.sdn"
            cleanup_test_file(test_file)

            # Create database with 100 bugs
            var bugdb = create_bug_database(test_file)
            for i in 0..100:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))

            # Save
            val save_result = bugdb.save()
            assert save_result

            # Load
            var loaded = create_bug_database(test_file)
            assert loaded.all_bugs().len() == 100

            # Verify a few bugs
            for i in 0..10:
                val bug_result = loaded.get_bug("bug_{i}")
                assert bug_result.?
                val bug = bug_result?
                assert bug.id == "bug_{i}"

            cleanup_test_file(test_file)

        it "handles save/load with 1K bugs":
            val test_file = "/tmp/test_bugdb_1k.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)
            for i in 0..1000:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))

            val save_result = bugdb.save()
            assert save_result

            var loaded = create_bug_database(test_file)
            assert loaded.all_bugs().len() == 1000

            cleanup_test_file(test_file)

        it "handles bugs with unicode data":
            val test_file = "/tmp/test_bugdb_unicode.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)

            # Add bugs with unicode in various fields
            val bug1 = Bug(
                id: "bug_unicode_1",
                severity: BugSeverity.P0,
                status: BugStatus.Open,
                title: "æµ‹è¯• Bug with ğŸš€ emoji",
                description: ["First line: ×©×œ×•×", "Second line: Ù…Ø±Ø­Ø¨Ø§"],
                file: "src/æµ‹è¯•/file.spl",
                line: 100,
                reproducible_by: "test_unicode",
                fix_strategy: [],
                investigation_log: [],
                created_at: 1738724000000000,
                updated_at: 1738724000000000,
                valid: true
            )

            bugdb.add_bug(bug1)

            # Save and load
            val save_result = bugdb.save()
            assert save_result

            var loaded = create_bug_database(test_file)
            val bug_result = loaded.get_bug("bug_unicode_1")
            assert bug_result.?

            val loaded_bug = bug_result?
            assert loaded_bug.title == "æµ‹è¯• Bug with ğŸš€ emoji"
            assert loaded_bug.file == "src/æµ‹è¯•/file.spl"

            cleanup_test_file(test_file)

        it "handles bugs with long descriptions":
            val test_file = "/tmp/test_bugdb_long.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)

            val long_desc = generate_long_string(5000)
            val bug = Bug(
                id: "bug_long",
                severity: BugSeverity.P1,
                status: BugStatus.Open,
                title: "Bug with long description",
                description: [long_desc, long_desc, long_desc],
                file: "test.spl",
                line: 100,
                reproducible_by: "test",
                fix_strategy: [],
                investigation_log: [],
                created_at: 1738724000000000,
                updated_at: 1738724000000000,
                valid: true
            )

            bugdb.add_bug(bug)

            val save_result = bugdb.save()
            assert save_result

            var loaded = create_bug_database(test_file)
            val bug_result = loaded.get_bug("bug_long")
            assert bug_result.?

            cleanup_test_file(test_file)

        it "handles multiple save operations":
            val test_file = "/tmp/test_bugdb_multi_save.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)

            # Save 1: 10 bugs
            for i in 0..10:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))
            bugdb.save()

            # Save 2: 10 more bugs
            for i in 10..20:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))
            bugdb.save()

            # Save 3: 10 more bugs
            for i in 20..30:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))
            bugdb.save()

            # Final load should have all 30
            var loaded = create_bug_database(test_file)
            assert loaded.all_bugs().len() == 30

            cleanup_test_file(test_file)

    context "file system operations":
        it "creates file if not exists":
            val test_file = "/tmp/test_bugdb_create.sdn"
            cleanup_test_file(test_file)

            assert not file_exists(test_file)

            var bugdb = create_bug_database(test_file)
            for i in 0..10:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))
            bugdb.save()

            assert file_exists(test_file)

            cleanup_test_file(test_file)

        it "overwrites existing file":
            val test_file = "/tmp/test_bugdb_overwrite.sdn"
            cleanup_test_file(test_file)

            # First save: 10 bugs
            var bugdb1 = create_bug_database(test_file)
            for i in 0..10:
                bugdb1.add_bug(generate_simple_bug("bug1_{i}"))
            bugdb1.save()

            var load1 = create_bug_database(test_file)
            assert load1.all_bugs().len() == 10

            # Second save: 20 bugs (should overwrite)
            var bugdb2 = create_bug_database(test_file)
            for i in 0..20:
                bugdb2.add_bug(generate_simple_bug("bug2_{i}"))
            bugdb2.save()

            var load2 = create_bug_database(test_file)
            assert load2.all_bugs().len() == 20

            cleanup_test_file(test_file)

        it "handles file deletion after save":
            val test_file = "/tmp/test_bugdb_delete.sdn"
            cleanup_test_file(test_file)

            var bugdb = create_bug_database(test_file)
            for i in 0..10:
                bugdb.add_bug(generate_simple_bug("bug_{i}"))
            bugdb.save()

            assert file_exists(test_file)

            file_delete(test_file)

            assert not file_exists(test_file)

    context "error handling":
        it "handles load of non-existent file":
            val test_file = "/tmp/nonexistent_bugdb.sdn"
            cleanup_test_file(test_file)  # Ensure it doesn't exist

            var bugdb = create_bug_database(test_file)
            # Should create empty database
            assert bugdb.all_bugs().len() == 0

        it "handles empty file":
            val test_file = "/tmp/test_bugdb_empty.sdn"
            cleanup_test_file(test_file)

            # Create empty file
            file_write(test_file, "")

            var bugdb = create_bug_database(test_file)
            # Should handle gracefully - empty database
            assert bugdb.all_bugs().len() == 0

            cleanup_test_file(test_file)

        it "preserves data integrity across save/load":
            val test_file = "/tmp/test_bugdb_integrity.sdn"
            cleanup_test_file(test_file)

            # Create database with variety of bugs
            var bugdb = create_bug_database(test_file)
            val severities = [BugSeverity.P0, BugSeverity.P1, BugSeverity.P2, BugSeverity.P3]
            val statuses = [BugStatus.Open, BugStatus.Investigating, BugStatus.Fixed, BugStatus.Closed]

            for i in 0..40:
                val severity = severities[i % 4]
                val status = statuses[(i / 4) % 4]
                val bug = Bug(
                    id: "bug_{i}",
                    severity: severity,
                    status: status,
                    title: "Bug {i} - severity {severity}",
                    description: ["Description for bug {i}"],
                    file: "test/file_{i % 10}.spl",
                    line: 100 + i,
                    reproducible_by: "test_{i}",
                    fix_strategy: [],
                    investigation_log: [],
                    created_at: 1738724000000000,
                    updated_at: 1738724000000000,
                    valid: true
                )
                bugdb.add_bug(bug)

            bugdb.save()

            var loaded = create_bug_database(test_file)

            # Verify statistics match
            val stats = loaded.stats()
            assert stats.total == 40

            # Verify specific bugs
            for i in 0..10:
                val original_result = bugdb.get_bug("bug_{i}")
                val loaded_result = loaded.get_bug("bug_{i}")

                assert original_result.?
                assert loaded_result.?

                val original = original_result?
                val loaded_bug = loaded_result?

                assert original.id == loaded_bug.id
                assert original.severity == loaded_bug.severity
                assert original.status == loaded_bug.status
                assert original.title == loaded_bug.title

            cleanup_test_file(test_file)

describe "Atomic Operations - Intensive":
    context "atomic write operations":
        it "performs atomic write successfully":
            val test_file = "/tmp/test_atomic_write.txt"
            cleanup_test_file(test_file)

            val content = "test content"
            val result = atomic_write(test_file, content)
            assert result

            val read = file_read(test_file)
            assert read == content

            cleanup_test_file(test_file)

        it "handles multiple atomic writes":
            val test_file = "/tmp/test_atomic_multi.txt"
            cleanup_test_file(test_file)

            for i in 0..10:
                val content = "content_{i}"
                atomic_write(test_file, content)

                val read = file_read(test_file)
                assert read == content

            cleanup_test_file(test_file)

        it "handles atomic write with large content":
            val test_file = "/tmp/test_atomic_large.txt"
            cleanup_test_file(test_file)

            val large_content = generate_long_string(10000)
            val result = atomic_write(test_file, large_content)
            assert result

            val read = file_read(test_file)
            assert read.len() == large_content.len()

            cleanup_test_file(test_file)

        it "handles atomic write with unicode":
            val test_file = "/tmp/test_atomic_unicode.txt"
            cleanup_test_file(test_file)

            val content = "æµ‹è¯• ğŸš€ ×©×œ×•× Ù…Ø±Ø­Ø¨Ø§"
            val result = atomic_write(test_file, content)
            assert result

            val read = file_read(test_file)
            assert read == content

            cleanup_test_file(test_file)

    context "atomic append operations":
        it "performs atomic append successfully":
            val test_file = "/tmp/test_atomic_append.txt"
            cleanup_test_file(test_file)

            # Initial write
            file_write(test_file, "line1\n")

            # Atomic append
            val result = atomic_append(test_file, "line2\n")
            assert result

            val content = file_read(test_file)
            assert content == "line1\nline2\n"

            cleanup_test_file(test_file)

        it "handles multiple atomic appends":
            val test_file = "/tmp/test_atomic_multi_append.txt"
            cleanup_test_file(test_file)

            file_write(test_file, "start\n")

            for i in 0..10:
                atomic_append(test_file, "line_{i}\n")

            val content = file_read(test_file)
            assert content.?
            assert content.contains("start")
            assert content.contains("line_0")
            assert content.contains("line_9")

            cleanup_test_file(test_file)

    context "atomic read operations":
        it "performs atomic read successfully":
            val test_file = "/tmp/test_atomic_read.txt"
            cleanup_test_file(test_file)

            val content = "test content"
            file_write(test_file, content)

            val read_result = atomic_read(test_file)
            assert read_result.?

            val read = read_result?
            assert read == content

            cleanup_test_file(test_file)

        it "handles atomic read of non-existent file":
            val test_file = "/tmp/nonexistent_atomic.txt"
            cleanup_test_file(test_file)

            val result = atomic_read(test_file)
            assert not result.?

    context "lock management":
        it "handles rapid lock/unlock cycles":
            val test_file = "/tmp/test_lock_cycles.txt"
            val lock_file = "{test_file}.lock"
            cleanup_test_files([test_file, lock_file])

            for i in 0..50:
                atomic_write(test_file, "content_{i}")

            # All operations should succeed
            assert file_exists(test_file)

            cleanup_test_files([test_file, lock_file])

        it "cleans up lock files after operations":
            val test_file = "/tmp/test_lock_cleanup.txt"
            val lock_file = "{test_file}.lock"
            cleanup_test_files([test_file, lock_file])

            atomic_write(test_file, "content")

            # Lock file should be cleaned up
            # (May still exist briefly, implementation dependent)

            cleanup_test_files([test_file, lock_file])
