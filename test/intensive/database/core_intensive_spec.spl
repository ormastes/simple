# Database Core Intensive Testing
# Comprehensive tests for StringInterner, SdnRow, SdnTable core components

use lib.database.core.{StringInterner, SdnTable, SdnRow, SdnDatabase}
use test.lib.database_fixtures.{generate_simple_string, generate_unicode_string, generate_simple_row, generate_row_with_many_fields, cleanup_test_file}


describe "StringInterner - Intensive":
    context "stress testing":
        it "handles 500 unique strings":
            var interner = StringInterner(strings: {}, reverse: {}, next_id: 0)

            # Intern 500 unique strings (reduced from 10K to avoid timeout)
            for i in 0..500:
                val s = "string_{i}"
                val id = interner.intern(s)
                check(id >= 0)

            # Verify total count
            val strings = dict_keys(interner.strings)
            check(strings.len() == 500)

        it "handles duplicate strings efficiently":
            var interner = StringInterner(strings: {}, reverse: {}, next_id: 0)

            # Intern same string 100 times (reduced from 1000 to avoid timeout)
            var first_id = -1
            for i in 0..100:
                val id = interner.intern("duplicate")
                if i == 0:
                    first_id = id
                else:
                    check(id == first_id) # Same ID for duplicates

            # Should only have 1 entry
            val strings = dict_keys(interner.strings)
            check(strings.len() == 1)

        it "handles unicode edge cases":
            var interner = StringInterner(strings: {}, reverse: {}, next_id: 0)

            val unicode_strings = [
                "ÊµãËØï",              # Chinese
                "üöÄüéâ‚ú®",           # Emojis
                "◊©◊ú◊ï◊ù",             # Hebrew (RTL)
                "ŸÖÿ±ÿ≠ÿ®ÿß",            # Arabic (RTL)
                "√ëo√±o",             # Spanish accents
                "Œ∫Œ±ŒªŒ∑ŒºŒ≠œÅŒ±",         # Greek
                "„Åì„Çì„Å´„Å°„ÅØ"         # Japanese
            ]

            for s in unicode_strings:
                val id = interner.intern(s)
                val lookup = interner.lookup(id)
                check(lookup.?)
                check(lookup? == s)

        it "handles empty string":
            var interner = StringInterner(strings: {}, reverse: {}, next_id: 0)

            val id = interner.intern("")
            check(id >= 0)

            val lookup = interner.lookup(id)
            check(lookup.?)
            check(lookup? == "")

        it "handles whitespace-only strings":
            var interner = StringInterner(strings: {}, reverse: {}, next_id: 0)

            val whitespace_strings = [
                " ",
                "  ",
                "\t",
                "\n",
                "\r\n",
                "   \t\n   "
            ]

            for s in whitespace_strings:
                val id = interner.intern(s)
                val lookup = interner.lookup(id)
                check(lookup.?)
                check(lookup? == s)

        it "handles strings with newlines and tabs":
            var interner = StringInterner(strings: {}, reverse: {}, next_id: 0)

            val s = "line1\nline2\tcolumn2\r\nline3"
            val id = interner.intern(s)
            val lookup = interner.lookup(id)
            check(lookup.?)
            check(lookup? == s)

        it "maintains bidirectional mapping":
            var interner = StringInterner(strings: {}, reverse: {}, next_id: 0)

            for i in 0..50:
                val s = "test_{i}"
                val id = interner.intern(s)

                # Forward lookup: string -> id
                val forward = interner.get(s)
                check(forward.?)
                check(forward? == id)

                # Reverse lookup: id -> string
                val reverse = interner.lookup(id)
                check(reverse.?)
                check(reverse? == s)

    context "edge cases":
        it "handles get on non-existent string":
            val interner = StringInterner(strings: {}, reverse: {}, next_id: 0)

            val result = interner.get("nonexistent")
            check(not result.?)

        it "handles lookup on invalid ID":
            val interner = StringInterner(strings: {}, reverse: {}, next_id: 0)

            val result = interner.lookup(999999)
            check(not result.?)

        it "handles negative ID lookup":
            val interner = StringInterner(strings: {}, reverse: {}, next_id: 0)

            val result = interner.lookup(-1)
            check(not result.?)

        it "handles ID sequence correctly":
            var interner = StringInterner(strings: {}, reverse: {}, next_id: 0)

            val id1 = interner.intern("first")
            val id2 = interner.intern("second")
            val id3 = interner.intern("third")

            check(id1 == 0)
            check(id2 == 1)
            check(id3 == 2)
            check(interner.next_id == 3)

describe "SdnRow - Intensive":
    context "field operations":
        it "handles rows with many fields":
            val row = generate_row_with_many_fields("row1", 50)

            check(row.get("id")? == "row1")
            val fields = dict_keys(row.fields)
            check(fields.len() == 51)  # 50 + id field

        it "handles get for all types":
            var row = SdnRow(fields: {})
            row.set("id", "test1")
            row.set("string_field", "value")
            row.set("number_field", "123")
            row.set("bool_field", "true")
            row.set("empty_field", "")

            check(row.get("string_field")? == "value")
            check(row.get("number_field")? == "123")
            check(row.get("bool_field")? == "true")
            check(row.get("empty_field")? == "")

        it "handles get for missing field":
            val row = generate_simple_row("test1")

            val result = row.get("nonexistent")
            check(not result.?) # Returns None for missing fields

        it "handles has correctly":
            var row = SdnRow(fields: {})
            row.set("id", "test1")
            row.set("existing", "value")

            check(row.has("existing"))
            check(not row.has("nonexistent"))

        it "handles unicode in field names":
            var row = SdnRow(fields: {})
            row.set("id", "test1")
            row.set("ÂêçÂâç", "value")
            row.set("üöÄ", "rocket")

            check(row.has("ÂêçÂâç"))
            check(row.has("üöÄ"))
            check(row.get("ÂêçÂâç")? == "value")
            check(row.get("üöÄ")? == "rocket")

        it "handles unicode in field values":
            val row = generate_row_with_unicode("test1")

            check(row.get("name").?)
            check(row.get("emoji")? == "üöÄüéâ‚ú®")

    context "edge cases":
        it "handles empty fields dictionary":
            val row = SdnRow(fields: {})

            val fields = dict_keys(row.fields)
            check(fields.len() == 0)

describe "SdnTable - Intensive":
    context "large datasets":
        it "handles 100 rows":
            val table = generate_table_with_rows("test_table", 100)

            check(table.name == "test_table")
            check(table.rows.len() == 100)

        it "handles 500 rows":
            val table = generate_table_with_rows("test_table", 500)

            check(table.rows.len() == 500)

        it "handles rows with many columns":
            var table = SdnTable.new("wide_table", [])

            for i in 0..10:
                val row = generate_row_with_many_fields("row_{i}", 20)
                table.add_row(row)

            check(table.rows.len() == 10)

    context "add and retrieve operations":
        it "maintains correct row count":
            var table = SdnTable.new("test", [])

            for i in 0..50:
                val row = generate_simple_row("row_{i}")
                table.add_row(row)

            check(table.rows.len() == 50)

        it "retrieves rows by ID correctly":
            var table = SdnTable.new("test", [])

            # Add 50 rows (reduced from 100 to avoid timeout)
            for i in 0..50:
                val row = generate_simple_row("row_{i}")
                table.add_row(row)

            # Retrieve each row
            for i in 0..50:
                val result = table.get_row("row_{i}")
                check(result.?)
                val row = result?
                check(row.get("id")? == "row_{i}")

        it "handles get_row for non-existent ID":
            val table = generate_table_with_rows("test", 10)

            val result = table.get_row("nonexistent")
            check(not result.?)

        it "handles duplicate ID prevention":
            var table = SdnTable.new("test", [])

            val row1 = generate_simple_row("dup")
            table.add_row(row1)

            val row2 = generate_simple_row("dup")
            table.add_row(row2)  # Should not add duplicate

            val result = table.get_row("dup")
            check(result.?)
            # Should still only have one entry
            check(table.rows.len() == 1)

    context "soft delete operations":
        it "marks rows as deleted":
            var table = generate_table_with_rows("test", 10)

            # Soft delete row_5
            table.mark_deleted("row_5")

            val result = table.get_row("row_5")
            check(result.?)
            val row = result?
            # Check if row has valid field set to false
            if val Some(valid_str) = row.get("valid"):
                check(valid_str == "false")

        it "excludes soft-deleted rows from active count":
            var table = generate_table_with_rows("test", 10)

            # Delete 3 rows
            table.mark_deleted("row_2")
            table.mark_deleted("row_5")
            table.mark_deleted("row_8")

            # Still have all 10 rows, but 3 are marked deleted
            check(table.rows.len() == 10)

            # Use valid_rows() method to get only valid rows
            val valid_rows = table.valid_rows()
            check(valid_rows.len() == 7)

        it "handles soft delete of non-existent row":
            var table = generate_table_with_rows("test", 10)

            table.mark_deleted("nonexistent")
            # Should not crash, table unchanged
            check(table.rows.len() == 10)

    context "schema handling":
        it "maintains schema definition":
            val schema = ["id", "name", "value"]
            val table = SdnTable.new("test", schema)

            check(table.schema.len() == 3)
            check(table.schema[0] == "id")
            check(table.schema[1] == "name")
            check(table.schema[2] == "value")

        it "allows empty schema":
            val table = SdnTable.new("test", [])

            check(table.schema.len() == 0)

    context "edge cases":
        it "handles empty table":
            val table = SdnTable.new("empty", [])

            check(table.rows.len() == 0)

        it "handles table name with unicode":
            val table = SdnTable.new("ÊµãËØï_table_üöÄ", [])

            check(table.name == "ÊµãËØï_table_üöÄ")
