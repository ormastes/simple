# Database Core Intensive Testing
# Comprehensive tests for StringInterner, SdnRow, SdnTable core components

use lib.database.mod.{StringInterner, SdnTable, SdnRow, SdnDatabase}
use test.lib.database_fixtures.{generate_simple_string, generate_unicode_string, generate_simple_row, generate_row_with_many_fields, cleanup_test_file}


describe "StringInterner - Intensive":
    context "stress testing":
        it "handles 10K unique strings":
            var interner = StringInterner.empty()

            # Intern 10K unique strings
            for i in 0..10000:
                val s = "string_{i}"
                val id = interner.intern(s)
                assert id >= 0

            # Verify total count
            val strings = dict_keys(interner.strings)
            assert strings.len() == 10000

        it "handles duplicate strings efficiently":
            var interner = StringInterner.empty()

            # Intern same string 1000 times
            var first_id = -1
            for i in 0..1000:
                val id = interner.intern("duplicate")
                if i == 0:
                    first_id = id
                else:
                    assert id == first_id  # Same ID for duplicates

            # Should only have 1 entry
            val strings = dict_keys(interner.strings)
            assert strings.len() == 1

        it "handles unicode edge cases":
            var interner = StringInterner.empty()

            val unicode_strings = [
                "æµ‹è¯•",              # Chinese
                "ğŸš€ğŸ‰âœ¨",           # Emojis
                "×©×œ×•×",             # Hebrew (RTL)
                "Ù…Ø±Ø­Ø¨Ø§",            # Arabic (RTL)
                "Ã‘oÃ±o",             # Spanish accents
                "ÎºÎ±Î»Î·Î¼Î­ÏÎ±",         # Greek
                "ã“ã‚“ã«ã¡ã¯"         # Japanese
            ]

            for s in unicode_strings:
                val id = interner.intern(s)
                val lookup = interner.lookup(id)
                assert lookup.?
                assert lookup? == s

        it "handles empty string":
            var interner = StringInterner.empty()

            val id = interner.intern("")
            assert id >= 0

            val lookup = interner.lookup(id)
            assert lookup.?
            assert lookup? == ""

        it "handles whitespace-only strings":
            var interner = StringInterner.empty()

            val whitespace_strings = [
                " ",
                "  ",
                "\t",
                "\n",
                "\r\n",
                "   \t\n   "
            ]

            for s in whitespace_strings:
                val id = interner.intern(s)
                val lookup = interner.lookup(id)
                assert lookup.?
                assert lookup? == s

        it "handles strings with newlines and tabs":
            var interner = StringInterner.empty()

            val s = "line1\nline2\tcolumn2\r\nline3"
            val id = interner.intern(s)
            val lookup = interner.lookup(id)
            assert lookup.?
            assert lookup? == s

        it "maintains bidirectional mapping":
            var interner = StringInterner.empty()

            for i in 0..100:
                val s = "test_{i}"
                val id = interner.intern(s)

                # Forward lookup: string -> id
                val forward = interner.get(s)
                assert forward.?
                assert forward? == id

                # Reverse lookup: id -> string
                val reverse = interner.lookup(id)
                assert reverse.?
                assert reverse? == s

    context "edge cases":
        it "handles get on non-existent string":
            val interner = StringInterner.empty()

            val result = interner.get("nonexistent")
            assert not result.?

        it "handles lookup on invalid ID":
            val interner = StringInterner.empty()

            val result = interner.lookup(999999)
            assert not result.?

        it "handles negative ID lookup":
            val interner = StringInterner.empty()

            val result = interner.lookup(-1)
            assert not result.?

        it "handles ID sequence correctly":
            var interner = StringInterner.empty()

            val id1 = interner.intern("first")
            val id2 = interner.intern("second")
            val id3 = interner.intern("third")

            assert id1 == 0
            assert id2 == 1
            assert id3 == 2
            assert interner.next_id == 3

describe "SdnRow - Intensive":
    context "field operations":
        it "handles rows with many fields":
            val row = generate_row_with_many_fields("row1", 100)

            assert row.get("id")? == "row1"
            val fields = dict_keys(row.fields)
            assert fields.len() == 101  # 100 + id field

        it "handles get for all types":
            var row = SdnRow.empty()
            row.set("id", "test1")
            row.set("string_field", "value")
            row.set("number_field", "123")
            row.set("bool_field", "true")
            row.set("empty_field", "")

            assert row.get("string_field")? == "value"
            assert row.get("number_field")? == "123"
            assert row.get("bool_field")? == "true"
            assert row.get("empty_field")? == ""

        it "handles get for missing field":
            val row = generate_simple_row("test1")

            val result = row.get("nonexistent")
            assert not result.?  # Returns None for missing fields

        it "handles has correctly":
            var row = SdnRow.empty()
            row.set("id", "test1")
            row.set("existing", "value")

            assert row.has("existing")
            assert not row.has("nonexistent")

        it "handles unicode in field names":
            var row = SdnRow.empty()
            row.set("id", "test1")
            row.set("åå‰", "value")
            row.set("ğŸš€", "rocket")

            assert row.has("åå‰")
            assert row.has("ğŸš€")
            assert row.get("åå‰")? == "value"
            assert row.get("ğŸš€")? == "rocket"

        it "handles unicode in field values":
            val row = generate_row_with_unicode("test1")

            assert row.get("name").?
            assert row.get("emoji")? == "ğŸš€ğŸ‰âœ¨"

    context "edge cases":
        it "handles empty fields dictionary":
            val row = SdnRow.empty()

            val fields = dict_keys(row.fields)
            assert fields.len() == 0

describe "SdnTable - Intensive":
    context "large datasets":
        it "handles 1K rows":
            val table = generate_table_with_rows("test_table", 1000)

            assert table.name == "test_table"
            assert table.rows.len() == 1000

        it "handles 10K rows":
            val table = generate_table_with_rows("test_table", 10000)

            assert table.rows.len() == 10000

        it "handles rows with many columns":
            var table = SdnTable.new("wide_table", [])

            for i in 0..10:
                val row = generate_row_with_many_fields("row_{i}", 100)
                table.add_row(row)

            assert table.rows.len() == 10

    context "add and retrieve operations":
        it "maintains correct row count":
            var table = SdnTable.new("test", [])

            for i in 0..100:
                val row = generate_simple_row("row_{i}")
                table.add_row(row)

            assert table.rows.len() == 100

        it "retrieves rows by ID correctly":
            var table = SdnTable.new("test", [])

            # Add 100 rows
            for i in 0..100:
                val row = generate_simple_row("row_{i}")
                table.add_row(row)

            # Retrieve each row
            for i in 0..100:
                val result = table.get_row("row_{i}")
                assert result.?
                val row = result?
                assert row.get("id")? == "row_{i}"

        it "handles get_row for non-existent ID":
            val table = generate_table_with_rows("test", 10)

            val result = table.get_row("nonexistent")
            assert not result.?

        it "handles duplicate ID prevention":
            var table = SdnTable.new("test", [])

            val row1 = generate_simple_row("dup")
            table.add_row(row1)

            val row2 = generate_simple_row("dup")
            table.add_row(row2)  # Should not add duplicate

            val result = table.get_row("dup")
            assert result.?
            # Should still only have one entry
            assert table.rows.len() == 1

    context "soft delete operations":
        it "marks rows as deleted":
            var table = generate_table_with_rows("test", 10)

            # Soft delete row_5
            table.mark_deleted("row_5")

            val result = table.get_row("row_5")
            assert result.?
            val row = result?
            # Check if row has valid field set to false
            if val Some(valid_str) = row.get("valid"):
                assert valid_str == "false"

        it "excludes soft-deleted rows from active count":
            var table = generate_table_with_rows("test", 10)

            # Delete 3 rows
            table.mark_deleted("row_2")
            table.mark_deleted("row_5")
            table.mark_deleted("row_8")

            # Still have all 10 rows, but 3 are marked deleted
            assert table.rows.len() == 10

            # Use valid_rows() method to get only valid rows
            val valid_rows = table.valid_rows()
            assert valid_rows.len() == 7

        it "handles soft delete of non-existent row":
            var table = generate_table_with_rows("test", 10)

            table.mark_deleted("nonexistent")
            # Should not crash, table unchanged
            assert table.rows.len() == 10

    context "schema handling":
        it "maintains schema definition":
            val schema = ["id", "name", "value"]
            val table = SdnTable.new("test", schema)

            assert table.schema.len() == 3
            assert table.schema[0] == "id"
            assert table.schema[1] == "name"
            assert table.schema[2] == "value"

        it "allows empty schema":
            val table = SdnTable.new("test", [])

            assert table.schema.len() == 0

    context "edge cases":
        it "handles empty table":
            val table = SdnTable.new("empty", [])

            assert table.rows.len() == 0

        it "handles table name with unicode":
            val table = SdnTable.new("æµ‹è¯•_table_ğŸš€", [])

            assert table.name == "æµ‹è¯•_table_ğŸš€"
