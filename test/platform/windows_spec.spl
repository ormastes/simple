# Windows-Specific Platform Tests
#
# Tests Windows-specific functionality:
# - UNC path handling
# - Drive letter handling
# - MSVC linker integration
# - Windows command resolution (.exe)
# - cmd.exe shell execution
#
# These tests are ONLY run on Windows platforms.

use std.spec
use std.platform.{
    is_windows, normalize_path, normalize_windows_path,
    resolve_command, dir_sep, path_sep, exe_ext,
    is_absolute_windows
}
use std.fs.path.{Path, is_absolute}
use app.io.{shell, process_run}
use compiler.linker.msvc.{
    find_visual_studio, find_link_exe, is_msvc_available,
    is_lld_link_available, auto_detect_windows_linker,
    WindowsLinkerType, convert_library_name,
    MsvcLinker, MsvcConfig
}
use compiler.linker.link.{auto_detect_linker, SystemLinker}

# Skip all tests if not on Windows
@platform("windows")

# ===========================================================================
# Windows Path Normalization Tests
# ===========================================================================

describe "Windows Path Normalization":
    it "converts forward slashes to backslashes":
        val path = "C:/Users/Test/file.txt"
        val normalized = normalize_windows_path(path)

        expect(normalized).to_equal("C:\\Users\\Test\\file.txt")

    it "handles drive letters correctly":
        val path = "C:/Program Files/Simple"
        val normalized = normalize_windows_path(path)

        expect(normalized.starts_with("C:\\")).to_be(true)
        expect(normalized.contains("Program Files")).to_be(true)

    it "converts UNC paths correctly":
        val path = "//server/share/file.txt"
        val normalized = normalize_windows_path(path)

        expect(normalized.starts_with("\\\\")).to_be(true)
        expect(normalized.contains("server")).to_be(true)
        expect(normalized.contains("share")).to_be(true)

    it "handles mixed slashes":
        val path = "C:\\Users/Test\\Documents/file.txt"
        val normalized = normalize_windows_path(path)

        # All slashes should be backslashes
        expect(not normalized.contains("/")).to_be(true)
        expect(normalized.contains("\\")).to_be(true)

    it "preserves single backslashes":
        val path = "C:\\Windows\\System32"
        val normalized = normalize_windows_path(path)

        expect(normalized).to_equal(path)

    it "handles paths without drive letters":
        val path = "relative/path/to/file.txt"
        val normalized = normalize_windows_path(path)

        # Should still convert slashes
        expect(normalized).to_equal("relative\\path\\to\\file.txt")

# ===========================================================================
# Windows Path Detection Tests
# ===========================================================================

describe "Windows Path Detection":
    it "detects absolute paths with drive letters":
        expect(is_absolute_windows("C:\\Windows")).to_be(true)
        expect(is_absolute_windows("D:\\Data")).to_be(true)
        expect(is_absolute_windows("E:\\")).to_be(true)

    it "detects UNC paths as absolute":
        expect(is_absolute_windows("\\\\server\\share")).to_be(true)
        expect(is_absolute_windows("\\\\nas\\backup\\file.txt")).to_be(true)

    it "detects relative paths":
        expect(is_absolute_windows("relative\\path")).to_be(false)
        expect(is_absolute_windows("file.txt")).to_be(false)
        expect(is_absolute_windows("..\\parent")).to_be(false)

    it "Path.is_absolute works on Windows":
        val abs = Path.new("C:\\Windows\\System32")
        expect(abs.is_absolute()).to_be(true)

        val rel = Path.new("System32\\notepad.exe")
        expect(rel.is_absolute()).to_be(false)

# ===========================================================================
# Windows Separator Tests
# ===========================================================================

describe "Windows Separators":
    it "dir_sep returns backslash":
        expect(dir_sep()).to_equal("\\")

    it "path_sep returns semicolon":
        expect(path_sep()).to_equal(";")

    it "exe_ext returns .exe":
        expect(exe_ext()).to_equal(".exe")

# ===========================================================================
# Windows Command Resolution Tests
# ===========================================================================

describe "Windows Command Resolution":
    it "adds .exe extension to commands without extension":
        val resolved = resolve_command("notepad")

        # Should contain notepad.exe
        expect(resolved.contains("notepad.exe")).to_be(true)

    it "preserves commands with .exe extension":
        val resolved = resolve_command("cmd.exe")

        expect(resolved.contains("cmd.exe")).to_be(true)

    it "handles .bat and .cmd files":
        # These should not get .exe added
        val bat = resolve_command("test.bat")
        val cmd = resolve_command("test.cmd")

        expect(bat.ends_with(".bat")).to_be(true)
        expect(cmd.ends_with(".cmd")).to_be(true)

    it "preserves absolute paths":
        val abs_path = "C:\\Windows\\System32\\cmd.exe"
        val resolved = resolve_command(abs_path)

        expect(resolved.contains("cmd.exe")).to_be(true)

    it "resolves common Windows commands":
        # Try to resolve cmd.exe (should be in System32)
        val resolved = resolve_command("cmd")

        # Should find it in PATH and add .exe
        expect(resolved.contains("cmd.exe")).to_be(true)

# ===========================================================================
# Windows Shell Execution Tests
# ===========================================================================

describe "Windows Shell Execution":
    it "executes cmd.exe commands":
        val result = shell("echo test")

        expect(result.exit_code).to_equal(0)
        expect(result.stdout.contains("test")).to_be(true)

    it "handles Windows-specific commands":
        val result = shell("dir")

        # dir should work on Windows
        expect(result.exit_code).to_equal(0)

    it "handles exit codes":
        val result = shell("exit 0")
        expect(result.exit_code).to_equal(0)

        val result_fail = shell("exit 1")
        expect(result_fail.exit_code).to_equal(1)

    it "captures stdout correctly":
        val result = shell("echo hello from windows")

        expect(result.stdout.contains("hello")).to_be(true)
        expect(result.stdout.contains("windows")).to_be(true)

# ===========================================================================
# Windows Path Class Tests
# ===========================================================================

describe "Windows Path Class":
    it "handles Windows paths correctly":
        val p = Path.new("C:\\Users\\Test")
        expect(p.to_string()).to_equal("C:\\Users\\Test")

    it "joins paths with backslashes":
        val base = Path.new("C:\\Users")
        val joined = base.join("Test").join("Documents")

        val result = joined.to_string()
        expect(result.contains("Users")).to_be(true)
        expect(result.contains("Test")).to_be(true)
        expect(result.contains("Documents")).to_be(true)

    it "extracts file names from Windows paths":
        val p = Path.new("C:\\Users\\Test\\file.txt")
        val name = p.file_name()

        expect(name).to_equal("file.txt")

    it "handles UNC paths in Path class":
        val p = Path.new("\\\\server\\share\\file.txt")
        val name = p.file_name()

        expect(name).to_equal("file.txt")

# ===========================================================================
# MSVC Linker Detection Tests
# ===========================================================================

describe "MSVC Linker Detection":
    it "can check if MSVC is available":
        # Just verify the function runs without crashing
        val available = is_msvc_available()

        # Result is boolean (true or false)
        val is_bool = available == true or available == false
        expect(is_bool).to_be(true)

    it "can check if lld-link is available":
        val available = is_lld_link_available()

        val is_bool = available == true or available == false
        expect(is_bool).to_be(true)

    it "auto_detect_windows_linker returns valid linker":
        val linker = auto_detect_windows_linker()

        val valid = match linker:
            case WindowsLinkerType.Msvc | WindowsLinkerType.LldLink | WindowsLinkerType.Lld:
                true

        expect(valid).to_be(true)

    it "Windows linker type has string representation":
        val linker = auto_detect_windows_linker()
        val name = linker.to_string()

        expect(name.len() > 0).to_be(true)

# ===========================================================================
# MSVC Integration Tests
# ===========================================================================

describe "MSVC Integration":
    it "convert_library_name handles -l prefix":
        val converted = convert_library_name("-lkernel32")

        expect(converted).to_equal("kernel32.lib")

    it "convert_library_name converts .a to .lib":
        val converted = convert_library_name("libfoo.a")

        expect(converted).to_equal("foo.lib")

    it "convert_library_name handles plain .a files":
        val converted = convert_library_name("foo.a")

        expect(converted).to_equal("foo.lib")

    it "convert_library_name preserves .lib files":
        val converted = convert_library_name("kernel32.lib")

        expect(converted).to_equal("kernel32.lib")

    slow_it "find_visual_studio returns path or None":
        # This is a slow test because it may search the filesystem
        val vs_path = find_visual_studio()

        # Should be either Some(path) or None
        match vs_path:
            case Some(path):
                expect(path.len() > 0).to_be(true)
            case None:
                pass  # MSVC not installed, which is ok

    slow_it "find_link_exe returns path or None":
        # This is a slow test because it may search the filesystem
        val link_path = find_link_exe()

        # Should be either Some(path) or None
        match link_path:
            case Some(path):
                expect(path.contains("link.exe")).to_be(true)
            case None:
                pass  # MSVC not installed, which is ok

# ===========================================================================
# Linker Auto-Detection Tests (Windows)
# ===========================================================================

describe "Linker Auto-Detection on Windows":
    it "auto_detect_linker returns Windows-compatible linker":
        val linker = auto_detect_linker()

        # Should be one of the Windows-compatible linkers
        val valid = match linker:
            case SystemLinker.LldLink | SystemLinker.Msvc | SystemLinker.Lld:
                true
            case _:
                false

        expect(valid).to_be(true)

    it "detected linker has Windows-appropriate name":
        val linker = auto_detect_linker()
        val name = linker.name()

        # Should mention Windows linkers
        val is_windows_linker = name.contains("lld-link") or
                               name.contains("MSVC") or
                               name.contains("lld")

        expect(is_windows_linker).to_be(true)

# ===========================================================================
# Windows Process Management Tests
# ===========================================================================

describe "Windows Process Management":
    it "process_run works with cmd.exe":
        val (stdout, stderr, code) = process_run("cmd.exe", ["/c", "echo", "test"])

        expect(code).to_equal(0)
        expect(stdout.contains("test")).to_be(true)

    it "process_run resolves commands without .exe":
        # notepad should be resolved to notepad.exe
        val (stdout, stderr, code) = process_run("cmd", ["/c", "echo", "test"])

        expect(code).to_equal(0)

# ===========================================================================
# Integration Tests
# ===========================================================================

describe "Windows Integration":
    it "can build complete Windows path":
        val p = Path.new("C:\\")
            .join("Users")
            .join("Test")
            .join("Documents")
            .join("file.txt")

        val result = p.to_string()

        expect(result.starts_with("C:\\")).to_be(true)
        expect(result.contains("Users")).to_be(true)
        expect(result.contains("Test")).to_be(true)
        expect(result.contains("Documents")).to_be(true)
        expect(result.ends_with("file.txt")).to_be(true)

    it "platform detection is consistent on Windows":
        expect(is_windows()).to_be(true)
        expect(dir_sep()).to_equal("\\")
        expect(path_sep()).to_equal(";")
        expect(exe_ext()).to_equal(".exe")

    it "can normalize and join paths":
        val base = normalize_windows_path("C:/Users")
        val p = Path.new(base).join("Test")

        expect(p.to_string().contains("Users")).to_be(true)
        expect(p.to_string().contains("Test")).to_be(true)
