# Windows-Specific Platform Tests
#
# Tests Windows-specific functionality:
# - UNC path handling
# - Drive letter handling
# - MSVC linker integration
# - Windows command resolution (.exe)
# - cmd.exe shell execution
#
# These tests are ONLY run on Windows platforms.

use std.spec
use std.platform.{
    is_windows, normalize_path, normalize_windows_path,
    resolve_command, dir_sep, path_sep, exe_ext,
    is_absolute_windows, is_mingw_path,
    mingw_to_windows, windows_to_mingw,
    clear_command_cache, get_command_cache_stats
}
use std.fs.path.{Path, is_absolute}
use app.io.{shell, process_run}
use compiler.linker.msvc.{
    find_visual_studio, find_link_exe, is_msvc_available,
    is_lld_link_available, auto_detect_windows_linker,
    WindowsLinkerType, convert_library_name,
    MsvcLinker, MsvcConfig
}
use compiler.linker.link.{auto_detect_linker, SystemLinker}

# Skip all tests if not on Windows
@platform("windows")

# ===========================================================================
# Windows Path Normalization Tests
# ===========================================================================

describe "Windows Path Normalization":
    it "converts forward slashes to backslashes":
        val path = "C:/Users/Test/file.txt"
        val normalized = normalize_windows_path(path)

        expect(normalized).to_equal("C:\\Users\\Test\\file.txt")

    it "handles drive letters correctly":
        val path = "C:/Program Files/Simple"
        val normalized = normalize_windows_path(path)

        expect(normalized.starts_with("C:\\")).to_be(true)
        expect(normalized.contains("Program Files")).to_be(true)

    it "converts UNC paths correctly":
        val path = "//server/share/file.txt"
        val normalized = normalize_windows_path(path)

        expect(normalized.starts_with("\\\\")).to_be(true)
        expect(normalized.contains("server")).to_be(true)
        expect(normalized.contains("share")).to_be(true)

    it "handles mixed slashes":
        val path = "C:\\Users/Test\\Documents/file.txt"
        val normalized = normalize_windows_path(path)

        # All slashes should be backslashes
        expect(not normalized.contains("/")).to_be(true)
        expect(normalized.contains("\\")).to_be(true)

    it "preserves single backslashes":
        val path = "C:\\Windows\\System32"
        val normalized = normalize_windows_path(path)

        expect(normalized).to_equal(path)

    it "handles paths without drive letters":
        val path = "relative/path/to/file.txt"
        val normalized = normalize_windows_path(path)

        # Should still convert slashes
        expect(normalized).to_equal("relative\\path\\to\\file.txt")

# ===========================================================================
# MinGW Path Support Tests
# ===========================================================================

describe "MinGW Path Support":
    it "detects MinGW-style paths":
        use std.platform.is_mingw_path

        expect(is_mingw_path("/c/Users/Test")).to_be(true)
        expect(is_mingw_path("/d/Projects/code")).to_be(true)
        expect(is_mingw_path("/e/Data")).to_be(true)

    it "rejects non-MinGW paths":
        use std.platform.is_mingw_path

        expect(is_mingw_path("C:\\Users\\Test")).to_be(false)
        expect(is_mingw_path("/usr/local/bin")).to_be(false)
        expect(is_mingw_path("relative/path")).to_be(false)
        expect(is_mingw_path("/")).to_be(false)

    it "converts MinGW paths to Windows format":
        use std.platform.mingw_to_windows

        val path1 = mingw_to_windows("/c/Users/Test/file.txt")
        expect(path1).to_equal("C:\\Users\\Test\\file.txt")

        val path2 = mingw_to_windows("/d/Projects/code")
        expect(path2).to_equal("D:\\Projects\\code")

    it "converts Windows paths to MinGW format":
        use std.platform.windows_to_mingw

        val path1 = windows_to_mingw("C:\\Users\\Test\\file.txt")
        expect(path1).to_equal("/c/Users/Test/file.txt")

        val path2 = windows_to_mingw("D:\\Projects\\code")
        expect(path2).to_equal("/d/Projects/code")

    it "handles MinGW paths in normalize_windows_path":
        val path = "/c/Users/Test/Documents/file.txt"
        val normalized = normalize_windows_path(path)

        expect(normalized).to_equal("C:\\Users\\Test\\Documents\\file.txt")

    it "treats MinGW paths as absolute":
        expect(is_absolute_windows("/c/Users/Test")).to_be(true)
        expect(is_absolute_windows("/d/Projects")).to_be(true)

    it "bidirectional conversion preserves path":
        use std.platform.{mingw_to_windows, windows_to_mingw}

        val original_mingw = "/c/Users/Test/file.txt"
        val to_windows = mingw_to_windows(original_mingw)
        val back_to_mingw = windows_to_mingw(to_windows)

        expect(back_to_mingw).to_equal(original_mingw)

        val original_windows = "C:\\Users\\Test\\file.txt"
        val to_mingw = windows_to_mingw(original_windows)
        val back_to_windows = mingw_to_windows(to_mingw)

        expect(back_to_windows).to_equal(original_windows)

# ===========================================================================
# Windows Path Detection Tests
# ===========================================================================

describe "Windows Path Detection":
    it "detects absolute paths with drive letters":
        expect(is_absolute_windows("C:\\Windows")).to_be(true)
        expect(is_absolute_windows("D:\\Data")).to_be(true)
        expect(is_absolute_windows("E:\\")).to_be(true)

    it "detects UNC paths as absolute":
        expect(is_absolute_windows("\\\\server\\share")).to_be(true)
        expect(is_absolute_windows("\\\\nas\\backup\\file.txt")).to_be(true)

    it "detects relative paths":
        expect(is_absolute_windows("relative\\path")).to_be(false)
        expect(is_absolute_windows("file.txt")).to_be(false)
        expect(is_absolute_windows("..\\parent")).to_be(false)

    it "Path.is_absolute works on Windows":
        val abs = Path.new("C:\\Windows\\System32")
        expect(abs.is_absolute()).to_be(true)

        val rel = Path.new("System32\\notepad.exe")
        expect(rel.is_absolute()).to_be(false)

# ===========================================================================
# Windows Separator Tests
# ===========================================================================

describe "Windows Separators":
    it "dir_sep returns backslash":
        expect(dir_sep()).to_equal("\\")

    it "path_sep returns semicolon":
        expect(path_sep()).to_equal(";")

    it "exe_ext returns .exe":
        expect(exe_ext()).to_equal(".exe")

# ===========================================================================
# Windows Command Resolution Tests
# ===========================================================================

describe "Windows Command Resolution":
    it "adds .exe extension to commands without extension":
        val resolved = resolve_command("notepad")

        # Should contain notepad.exe
        expect(resolved.contains("notepad.exe")).to_be(true)

    it "preserves commands with .exe extension":
        val resolved = resolve_command("cmd.exe")

        expect(resolved.contains("cmd.exe")).to_be(true)

    it "handles .bat and .cmd files":
        # These should not get .exe added
        val bat = resolve_command("test.bat")
        val cmd = resolve_command("test.cmd")

        expect(bat.ends_with(".bat")).to_be(true)
        expect(cmd.ends_with(".cmd")).to_be(true)

    it "preserves absolute paths":
        val abs_path = "C:\\Windows\\System32\\cmd.exe"
        val resolved = resolve_command(abs_path)

        expect(resolved.contains("cmd.exe")).to_be(true)

    it "resolves common Windows commands":
        # Try to resolve cmd.exe (should be in System32)
        val resolved = resolve_command("cmd")

        # Should find it in PATH and add .exe
        expect(resolved.contains("cmd.exe")).to_be(true)

# ===========================================================================
# Windows Shell Execution Tests
# ===========================================================================

describe "Windows Shell Execution":
    it "executes cmd.exe commands":
        val result = shell("echo test")

        expect(result.exit_code).to_equal(0)
        expect(result.stdout.contains("test")).to_be(true)

    it "handles Windows-specific commands":
        val result = shell("dir")

        # dir should work on Windows
        expect(result.exit_code).to_equal(0)

    it "handles exit codes":
        val result = shell("exit 0")
        expect(result.exit_code).to_equal(0)

        val result_fail = shell("exit 1")
        expect(result_fail.exit_code).to_equal(1)

    it "captures stdout correctly":
        val result = shell("echo hello from windows")

        expect(result.stdout.contains("hello")).to_be(true)
        expect(result.stdout.contains("windows")).to_be(true)

# ===========================================================================
# Windows Path Class Tests
# ===========================================================================

describe "Windows Path Class":
    it "handles Windows paths correctly":
        val p = Path.new("C:\\Users\\Test")
        expect(p.to_string()).to_equal("C:\\Users\\Test")

    it "joins paths with backslashes":
        val base = Path.new("C:\\Users")
        val joined = base.join("Test").join("Documents")

        val result = joined.to_string()
        expect(result.contains("Users")).to_be(true)
        expect(result.contains("Test")).to_be(true)
        expect(result.contains("Documents")).to_be(true)

    it "extracts file names from Windows paths":
        val p = Path.new("C:\\Users\\Test\\file.txt")
        val name = p.file_name()

        expect(name).to_equal("file.txt")

    it "handles UNC paths in Path class":
        val p = Path.new("\\\\server\\share\\file.txt")
        val name = p.file_name()

        expect(name).to_equal("file.txt")

# ===========================================================================
# MSVC Linker Detection Tests
# ===========================================================================

describe "MSVC Linker Detection":
    it "can check if MSVC is available":
        # Just verify the function runs without crashing
        val available = is_msvc_available()

        # Result is boolean (true or false)
        val is_bool = available == true or available == false
        expect(is_bool).to_be(true)

    it "can check if lld-link is available":
        val available = is_lld_link_available()

        val is_bool = available == true or available == false
        expect(is_bool).to_be(true)

    it "auto_detect_windows_linker returns valid linker":
        val linker = auto_detect_windows_linker()

        val valid = match linker:
            case WindowsLinkerType.Msvc | WindowsLinkerType.LldLink | WindowsLinkerType.Lld:
                true

        expect(valid).to_be(true)

    it "Windows linker type has string representation":
        val linker = auto_detect_windows_linker()
        val name = linker.to_string()

        expect(name.len() > 0).to_be(true)

# ===========================================================================
# MSVC Integration Tests
# ===========================================================================

describe "MSVC Integration":
    it "convert_library_name handles -l prefix":
        val converted = convert_library_name("-lkernel32")

        expect(converted).to_equal("kernel32.lib")

    it "convert_library_name converts .a to .lib":
        val converted = convert_library_name("libfoo.a")

        expect(converted).to_equal("foo.lib")

    it "convert_library_name handles plain .a files":
        val converted = convert_library_name("foo.a")

        expect(converted).to_equal("foo.lib")

    it "convert_library_name preserves .lib files":
        val converted = convert_library_name("kernel32.lib")

        expect(converted).to_equal("kernel32.lib")

    slow_it "find_visual_studio returns path or None":
        # This is a slow test because it may search the filesystem
        val vs_path = find_visual_studio()

        # Should be either Some(path) or None
        match vs_path:
            case Some(path):
                expect(path.len() > 0).to_be(true)
            case None:
                pass  # MSVC not installed, which is ok

    slow_it "find_link_exe returns path or None":
        # This is a slow test because it may search the filesystem
        val link_path = find_link_exe()

        # Should be either Some(path) or None
        match link_path:
            case Some(path):
                expect(path.contains("link.exe")).to_be(true)
            case None:
                pass  # MSVC not installed, which is ok

# ===========================================================================
# Linker Auto-Detection Tests (Windows)
# ===========================================================================

describe "Linker Auto-Detection on Windows":
    it "auto_detect_linker returns Windows-compatible linker":
        val linker = auto_detect_linker()

        # Should be one of the Windows-compatible linkers
        val valid = match linker:
            case SystemLinker.LldLink | SystemLinker.Msvc | SystemLinker.Lld:
                true
            case _:
                false

        expect(valid).to_be(true)

    it "detected linker has Windows-appropriate name":
        val linker = auto_detect_linker()
        val name = linker.name()

        # Should mention Windows linkers
        val is_windows_linker = name.contains("lld-link") or
                               name.contains("MSVC") or
                               name.contains("lld")

        expect(is_windows_linker).to_be(true)

# ===========================================================================
# Windows Process Management Tests
# ===========================================================================

describe "Windows Process Management":
    it "process_run works with cmd.exe":
        val (stdout, stderr, code) = process_run("cmd.exe", ["/c", "echo", "test"])

        expect(code).to_equal(0)
        expect(stdout.contains("test")).to_be(true)

    it "process_run resolves commands without .exe":
        # notepad should be resolved to notepad.exe
        val (stdout, stderr, code) = process_run("cmd", ["/c", "echo", "test"])

        expect(code).to_equal(0)

# ===========================================================================
# Integration Tests
# ===========================================================================

describe "Windows Integration":
    it "can build complete Windows path":
        val p = Path.new("C:\\")
            .join("Users")
            .join("Test")
            .join("Documents")
            .join("file.txt")

        val result = p.to_string()

        expect(result.starts_with("C:\\")).to_be(true)
        expect(result.contains("Users")).to_be(true)
        expect(result.contains("Test")).to_be(true)
        expect(result.contains("Documents")).to_be(true)
        expect(result.ends_with("file.txt")).to_be(true)

    it "platform detection is consistent on Windows":
        expect(is_windows()).to_be(true)
        expect(dir_sep()).to_equal("\\")
        expect(path_sep()).to_equal(";")
        expect(exe_ext()).to_equal(".exe")

    it "can normalize and join paths":
        val base = normalize_windows_path("C:/Users")
        val p = Path.new(base).join("Test")

        expect(p.to_string().contains("Users")).to_be(true)
        expect(p.to_string().contains("Test")).to_be(true)

# ===========================================================================
# Command Cache Tests
# ===========================================================================

describe "Command Resolution Cache":
    it "caches resolved commands":
        use std.platform.{resolve_command, clear_command_cache, get_command_cache_stats}

        # Clear cache to start fresh
        clear_command_cache()

        # First resolution (cache miss)
        val cmd1 = resolve_command("cmd")
        expect(cmd1.contains("cmd.exe")).to_be(true)

        # Second resolution (cache hit - should be fast)
        val cmd2 = resolve_command("cmd")
        expect(cmd2).to_equal(cmd1)

        # Cache should have 1 entry
        val stats = get_command_cache_stats()
        expect(stats.contains("1 entries")).to_be(true)

    it "caches multiple different commands":
        use std.platform.{resolve_command, clear_command_cache}

        clear_command_cache()

        # Resolve multiple commands
        val cmd1 = resolve_command("cmd")
        val notepad1 = resolve_command("notepad")
        val powershell1 = resolve_command("powershell")

        # Resolve again (all should hit cache)
        val cmd2 = resolve_command("cmd")
        val notepad2 = resolve_command("notepad")
        val powershell2 = resolve_command("powershell")

        # All should match
        expect(cmd2).to_equal(cmd1)
        expect(notepad2).to_equal(notepad1)
        expect(powershell2).to_equal(powershell1)

    it "invalidates cache when PATH changes":
        use std.platform.{resolve_command, clear_command_cache}
        use app.io.{rt_env_get, rt_env_set}

        clear_command_cache()

        # Save original PATH
        val original_path = rt_env_get("PATH")

        # Resolve a command
        val cmd1 = resolve_command("cmd")

        # Change PATH (this should invalidate cache)
        rt_env_set("PATH", "C:\\Windows\\System32")

        # Resolve again (cache should be invalidated)
        val cmd2 = resolve_command("cmd")

        # Restore original PATH
        rt_env_set("PATH", original_path)

        # Both resolutions should succeed (may or may not be equal)
        expect(cmd1.contains("cmd.exe")).to_be(true)
        expect(cmd2.contains("cmd.exe")).to_be(true)

    it "handles absolute paths without caching overhead":
        use std.platform.{resolve_command, clear_command_cache}

        clear_command_cache()

        # Absolute path should be returned as-is
        val abs_path = "C:\\Windows\\System32\\cmd.exe"
        val resolved = resolve_command(abs_path)

        expect(resolved).to_equal(abs_path)

    it "caches commands with .exe already":
        use std.platform.{resolve_command, clear_command_cache}

        clear_command_cache()

        # Command with .exe extension
        val cmd1 = resolve_command("cmd.exe")
        val cmd2 = resolve_command("cmd.exe")

        expect(cmd2).to_equal(cmd1)
        expect(cmd1.contains("cmd.exe")).to_be(true)

    it "tracks cache hit rate":
        use std.platform.{resolve_command, clear_command_cache, get_command_cache_stats}

        clear_command_cache()

        # First call = miss
        resolve_command("cmd")

        # Next 9 calls = hits
        for _ in 0..9:
            resolve_command("cmd")

        # Hit rate should be 90% (9 hits out of 10 total)
        val stats = get_command_cache_stats()
        expect(stats.contains("90")).to_be(true)  # Should mention 90% hit rate
