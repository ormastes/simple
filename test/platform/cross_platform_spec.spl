# Cross-Platform Support Tests
#
# Tests platform detection, path handling, and process management
# across Linux, macOS, Windows, and FreeBSD.
#
# These tests run on ALL platforms and verify platform-specific behavior.

use std.spec
use std.platform.{
    is_windows, is_unix, is_macos, is_linux, is_freebsd,
    is_x86_64, is_arm64,
    dir_sep, path_sep, exe_ext, lib_ext,
    normalize_path, join_path, resolve_command,
    home_dir, temp_dir, line_ending,
    platform_name, platform_triple
}
use std.common.target.{TargetOS, TargetArch}
use std.fs.path.{Path, get_current_dir, get_home_dir, get_temp_dir}
use app.io.{shell, process_run}
use compiler.linker.link.{auto_detect_linker, SystemLinker, get_linker_info}

# ===========================================================================
# Platform Detection Tests
# ===========================================================================

describe "Platform Detection":
    it "detects current operating system":
        val os = TargetOS.host()

        # Should be one of the supported OSes
        val valid = match os:
            case TargetOS.Linux | TargetOS.Windows | TargetOS.MacOS | TargetOS.FreeBSD:
                true
            case _:
                false

        expect(valid).to_be(true)

    it "detects current architecture":
        val arch = TargetArch.host()

        # Should be a valid architecture
        val valid = match arch:
            case TargetArch.X86_64 | TargetArch.Aarch64 | TargetArch.X86 | TargetArch.Arm:
                true
            case _:
                false

        expect(valid).to_be(true)

    it "platform name includes OS and architecture":
        val name = platform_name()

        # Should contain a hyphen separating OS and arch
        expect(name.contains("-")).to_be(true)

    it "is_windows returns true only on Windows":
        val on_windows = is_windows()
        val os = TargetOS.host()

        if os == TargetOS.Windows:
            expect(on_windows).to_be(true)
        else:
            expect(on_windows).to_be(false)

    it "is_unix returns true on Unix-like systems":
        val on_unix = is_unix()
        val os = TargetOS.host()

        match os:
            case TargetOS.Linux | TargetOS.MacOS | TargetOS.FreeBSD:
                expect(on_unix).to_be(true)
            case TargetOS.Windows:
                expect(on_unix).to_be(false)
            case _:
                pass

# ===========================================================================
# Path Separator Tests
# ===========================================================================

describe "Path Separators":
    it "dir_sep returns platform-specific directory separator":
        val sep = dir_sep()

        if is_windows():
            expect(sep).to_equal("\\")
        else:
            expect(sep).to_equal("/")

    it "path_sep returns platform-specific PATH separator":
        val sep = path_sep()

        if is_windows():
            expect(sep).to_equal(";")
        else:
            expect(sep).to_equal(":")

    it "exe_ext returns correct executable extension":
        val ext = exe_ext()

        if is_windows():
            expect(ext).to_equal(".exe")
        else:
            expect(ext).to_equal("")

    it "lib_ext returns correct library extension":
        val ext = lib_ext()

        if is_windows():
            expect(ext).to_equal(".dll")
        elif is_macos():
            expect(ext).to_equal(".dylib")
        else:
            expect(ext).to_equal(".so")

# ===========================================================================
# Path Handling Tests
# ===========================================================================

describe "Path Handling":
    it "Path.new creates path from string":
        val p = Path.new("/usr/bin")
        expect(p.to_string()).to_equal("/usr/bin")

    it "Path.join combines path components":
        val base = Path.new("/usr")
        val joined = base.join("bin")

        val result = joined.to_string()
        expect(result.contains("usr")).to_be(true)
        expect(result.contains("bin")).to_be(true)

    it "Path.file_name extracts last component":
        val p = Path.new("/usr/bin/simple")
        val name = p.file_name()

        expect(name).to_equal("simple")

    it "Path.extension extracts file extension":
        val p = Path.new("/path/to/file.txt")
        val ext = p.extension()

        expect(ext).to_equal("txt")

# ===========================================================================
# Process Management Tests
# ===========================================================================

describe "Process Management":
    it "shell executes simple commands":
        val result = shell("echo test")

        expect(result.exit_code).to_equal(0)
        expect(result.stdout.contains("test")).to_be(true)

# ===========================================================================
# Linker Auto-Detection Tests
# ===========================================================================

describe "Linker Auto-Detection":
    it "auto_detect_linker returns valid linker":
        val linker = auto_detect_linker()

        val valid = match linker:
            case SystemLinker.Mold | SystemLinker.Lld | SystemLinker.LldLink |
                 SystemLinker.Msvc | SystemLinker.Ld | SystemLinker.Ld64:
                true

        expect(valid).to_be(true)

    it "get_linker_info returns non-empty string":
        val info = get_linker_info()

        expect(info.len() > 0).to_be(true)
        expect(info.contains("linker")).to_be(true)
