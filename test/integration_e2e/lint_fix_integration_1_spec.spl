"""
# Integration & E2E Test


**Feature IDs:** #INTEGRATION
**Category:** End-to-End Testing
**Status:** Implemented
"""

use std.spec.{check}
use std.text.{NL}

describe "Integration Test Scenario":
    it "e2e workflow 1":
        val input = "source code"
        val stage1 = input + " -> parsed"
        val stage2 = stage1 + " -> typed"
        val stage3 = stage2 + " -> compiled"
        check(stage3.contains("compiled"))
        
    it "e2e workflow 2":
        val data = [1, 2, 3, 4, 5]
        var processed = []
        for x in data:
            processed = processed.append(x * 2)
        var sum = 0
        for x in processed:
            sum = sum + x
        check(sum == 30)
        
    it "e2e workflow 3":
        val config = {"input": "test.spl", "output": "test.out"}
        val input_file = config["input"]
        val output_file = config["output"]
        check(input_file.ends_with(".spl"))
        check(output_file.ends_with(".out"))
        
    it "error propagation":
        var error = nil
        if error == nil:
            check(true)
        else:
            check(false)
            
    it "state transitions":
        var state = "init"
        if state == "init":
            state = "processing"
        if state == "processing":
            state = "complete"
        check(state == "complete")
        
    it "data pipeline":
        val raw = [1, 2, 3, 4, 5]
        var filtered = []
        for x in raw:
            if x % 2 == 0:
                filtered = filtered.append(x)
        var transformed = []
        for x in filtered:
            transformed = transformed.append(x * 10)
        check(transformed.len() == 2)
        
    it "module interaction":
        val module_a = {"export": "value_a"}
        val module_b = {"import": module_a["export"]}
        check(module_b["import"] == "value_a")
        
    it "nested processing":
        val outer = [[1, 2], [3, 4], [5, 6]]
        var flattened = []
        for inner in outer:
            for x in inner:
                flattened = flattened.append(x)
        check(flattened.len() == 6)
        
    it "error recovery flow":
        val opt = nil
        val result = opt ?? "default"
        check(result == "default")
        
    it "full validation":
        val input = [1, 2, 3, 4, 5]
        var validated = true
        for x in input:
            if x <= 0:
                validated = false
        check(validated)
