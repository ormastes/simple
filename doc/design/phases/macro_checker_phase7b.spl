"""
Macro Type Checking - Phase 7B: Macro Call Type Checking

Implements type checking for macro calls (argument validation).

Status: Phase 7B In Progress
"""

type Symbol = text

# ============================================================================
# Import from Phase 7A
# ============================================================================

# Type system
enum HirType:
    Int
    Str
    Bool
    Unit
    TypeParam(id: i64)
    Arrow(from: HirType, to: HirType)
    Generic(name: Symbol, args: [HirType])
    List(elem: HirType)

impl HirType:
    fn to_string() -> text:
        match self:
            case Int: "i32"
            case Str: "String"
            case Bool: "bool"
            case Unit: "()"
            case TypeParam(id): "T{id}"
            case Arrow(from, to):
                "fn({from.to_string()}) -> {to.to_string()}"
            case Generic(name, args):
                if args.len() == 0:
                    name
                else:
                    var arg_strs = []
                    for arg in args:
                        arg_strs.push(arg.to_string())
                    val args_str = if arg_strs.len() > 0: arg_strs[0] else: ""
                    "{name}<{args_str}>"
            case List(elem):
                "[{elem.to_string()}]"

# Expression
enum Expr:
    IntLit(value: i64)
    StrLit(value: text)
    BoolLit(value: bool)
    Var(name: Symbol)
    Call(func: Expr, args: [Expr])
    If(cond: Expr, then_branch: Expr, else_branch: Expr)
    Block(stmts: [Expr])

impl Expr:
    fn to_string() -> text:
        match self:
            case IntLit(value): "{value}"
            case StrLit(value): "\"{value}\""
            case BoolLit(value): if value: "true" else: "false"
            case Var(name): name
            case Call(func, _): "{func.to_string()}(...)"
            case If(cond, _, _): "if {cond.to_string()} ..."
            case Block(_): "{ ... }"

# MacroParam
class MacroParam:
    name: Symbol
    ty: HirType
    is_variadic: bool

impl MacroParam:
    static fn regular(name: Symbol, ty: HirType) -> MacroParam:
        MacroParam(name: name, ty: ty, is_variadic: false)

    static fn variadic(name: Symbol, elem_ty: HirType) -> MacroParam:
        MacroParam(name: name, ty: HirType.List(elem: elem_ty), is_variadic: true)

# MacroDef
class MacroDef:
    name: Symbol
    params: [MacroParam]
    body: Expr
    expansion_ty: HirType
    hygiene_scope: i64

impl MacroDef:
    static fn new_macro(
        name: Symbol,
        params: [MacroParam],
        body: Expr,
        expansion_ty: HirType
    ) -> MacroDef:
        MacroDef(
            name: name,
            params: params,
            body: body,
            expansion_ty: expansion_ty,
            hygiene_scope: 0
        )

    fn param_count() -> i64:
        var count = 0
        for param in self.params:
            if not param.is_variadic:
                count = count + 1
        count

    fn has_variadic() -> bool:
        for param in self.params:
            if param.is_variadic:
                return true
        false

# MacroRegistry
class MacroRegistry:
    macros: text  # Dict<Symbol, MacroDef>
    next_hygiene_scope: i64

impl MacroRegistry:
    static fn empty() -> MacroRegistry:
        MacroRegistry(macros: {}, next_hygiene_scope: 1)

    me register_macro(macro_def: MacroDef):
        var updated_def = macro_def
        updated_def.hygiene_scope = self.next_hygiene_scope
        self.next_hygiene_scope = self.next_hygiene_scope + 1
        self.macros[macro_def.name] = updated_def

    fn lookup_macro(name: Symbol) -> MacroDef:
        if name in self.macros:
            return self.macros[name]
        MacroDef(
            name: "__missing__",
            params: [],
            body: Expr.IntLit(value: 0),
            expansion_ty: HirType.Unit,
            hygiene_scope: 0
        )

    fn has_macro(name: Symbol) -> bool:
        name in self.macros

# ============================================================================
# Macro Call
# ============================================================================

class MacroCall:
    """
    Macro call site

    Examples:
        @assert(x > 0, "x must be positive")
        @log("INFO", "message1", "message2")
    """
    name: Symbol
    args: [Expr]

impl MacroCall:
    static fn new_call(name: Symbol, args: [Expr]) -> MacroCall:
        MacroCall(name: name, args: args)

    fn arg_count() -> i64:
        self.args.len()

    fn to_string() -> text:
        "@{self.name}({self.arg_count()} args)"

# ============================================================================
# Type Environment (Simplified)
# ============================================================================

class TypeEnv:
    """
    Type environment for inferring expression types

    Simplified: only handles literals and variables
    """
    vars: text  # Dict<Symbol, HirType>

impl TypeEnv:
    static fn empty() -> TypeEnv:
        TypeEnv(vars: {})

    me bind_var(name: Symbol, ty: HirType):
        """Bind variable to type"""
        self.vars[name] = ty

    fn infer_expr(expr: Expr) -> HirType:
        """
        Infer type of expression

        Simplified: only handles literals
        """
        match expr:
            case IntLit(_): HirType.Int
            case StrLit(_): HirType.Str
            case BoolLit(_): HirType.Bool
            case Var(name):
                if name in self.vars:
                    self.vars[name]
                else:
                    HirType.Unit  # Unknown variable
            case _: HirType.Unit

# ============================================================================
# Macro Type Checker
# ============================================================================

class MacroTypeChecker:
    """
    Type checker for macro calls

    Validates:
    - Macro exists
    - Correct number of arguments
    - Argument types match parameters
    """
    registry: MacroRegistry
    type_env: TypeEnv

impl MacroTypeChecker:
    static fn new_checker(registry: MacroRegistry) -> MacroTypeChecker:
        MacroTypeChecker(
            registry: registry,
            type_env: TypeEnv.empty()
        )

    fn check_macro_call(call: MacroCall) -> bool:
        """
        Type check a macro call

        Returns: true if valid, false if error
        """
        # 1. Lookup macro
        if not self.registry.has_macro(call.name):
            return false

        val macro_def = self.registry.lookup_macro(call.name)

        # 2. Check arity
        if not self.check_arity(call.args, macro_def.params):
            return false

        # 3. Check argument types
        for i, (arg, param) in call.args.zip(macro_def.params).enumerate():
            # Infer argument type
            val arg_ty = self.type_env.infer_expr(arg)

            # Check against parameter type
            if not self.types_match(arg_ty, param.ty):
                return false

        true

    fn check_arity(args: [Expr], params: [MacroParam]) -> bool:
        """
        Check argument count matches parameters

        Handles variadic parameters:
        - Non-variadic: exact match
        - Variadic: at least non-variadic count
        """
        val non_variadic_count = self.count_non_variadic(params)
        val has_variadic = self.has_variadic_param(params)

        if has_variadic:
            # At least non_variadic_count arguments
            args.len() >= non_variadic_count
        else:
            # Exact match
            args.len() == params.len()

    fn count_non_variadic(params: [MacroParam]) -> i64:
        """Count non-variadic parameters"""
        var count = 0
        for param in params:
            if not param.is_variadic:
                count = count + 1
        count

    fn has_variadic_param(params: [MacroParam]) -> bool:
        """Check if params has variadic"""
        for param in params:
            if param.is_variadic:
                return true
        false

    fn types_match(ty1: HirType, ty2: HirType) -> bool:
        """
        Check if two types match

        Simplified: exact match only
        """
        match (ty1, ty2):
            case (Int, Int): true
            case (Str, Str): true
            case (Bool, Bool): true
            case (Unit, Unit): true
            case _: false

    fn get_expansion_type(call: MacroCall) -> HirType:
        """
        Get expansion type for a valid macro call

        Assumes call is valid (already checked)
        """
        val macro_def = self.registry.lookup_macro(call.name)
        macro_def.expansion_ty

# ============================================================================
# Error Reporting
# ============================================================================

class MacroTypeError:
    """Macro type error"""
    message: text

impl MacroTypeError:
    static fn macro_not_found(name: Symbol) -> MacroTypeError:
        MacroTypeError(message: "Macro '{name}' not found")

    static fn wrong_arity(name: Symbol, expected: i64, actual: i64) -> MacroTypeError:
        MacroTypeError(
            message: "Macro '{name}': expected {expected} arguments, got {actual}"
        )

    static fn type_mismatch(name: Symbol, arg_idx: i64, expected: HirType, actual: HirType) -> MacroTypeError:
        MacroTypeError(
            message: "Macro '{name}': argument {arg_idx} has type {actual.to_string()}, expected {expected.to_string()}"
        )

    fn to_string() -> text:
        self.message

# ============================================================================
# Tests
# ============================================================================

fn test_macro_call():
    """Test macro call creation"""
    val args = [
        Expr.BoolLit(value: true),
        Expr.StrLit(value: "msg")
    ]
    val call = MacroCall.new_call("assert", args)

    assert call.name == "assert", "Call name"
    assert call.arg_count() == 2, "Two arguments"

    print "âœ… Macro call creation"

fn test_type_env():
    """Test type environment"""
    val env = TypeEnv.empty()

    env.bind_var("x", HirType.Int)

    val ty = env.infer_expr(Expr.Var(name: "x"))
    assert ty.to_string() == "i32", "Variable type"

    val lit_ty = env.infer_expr(Expr.IntLit(value: 42))
    assert lit_ty.to_string() == "i32", "Literal type"

    print "âœ… Type environment"

fn test_check_valid_call():
    """Test valid macro call"""
    val registry = MacroRegistry.empty()

    # Register macro: assert(cond: bool, msg: text)
    val params = [
        MacroParam.regular("cond", HirType.Bool),
        MacroParam.regular("msg", HirType.Str)
    ]
    val macro_def = MacroDef.new_macro(
        "assert",
        params,
        Expr.Block(stmts: []),
        HirType.Unit
    )
    registry.register_macro(macro_def)

    # Create checker
    val checker = MacroTypeChecker.new_checker(registry)

    # Valid call: @assert(true, "message")
    val args = [
        Expr.BoolLit(value: true),
        Expr.StrLit(value: "message")
    ]
    val call = MacroCall.new_call("assert", args)

    assert checker.check_macro_call(call), "Valid call"

    print "âœ… Valid macro call"

fn test_check_type_mismatch():
    """Test type mismatch error"""
    val registry = MacroRegistry.empty()

    # Register macro: assert(cond: bool, msg: text)
    val params = [
        MacroParam.regular("cond", HirType.Bool),
        MacroParam.regular("msg", HirType.Str)
    ]
    val macro_def = MacroDef.new_macro(
        "assert",
        params,
        Expr.Block(stmts: []),
        HirType.Unit
    )
    registry.register_macro(macro_def)

    val checker = MacroTypeChecker.new_checker(registry)

    # Invalid call: @assert(42, "message") - first arg is i32, not bool
    val args = [
        Expr.IntLit(value: 42),
        Expr.StrLit(value: "message")
    ]
    val call = MacroCall.new_call("assert", args)

    assert not checker.check_macro_call(call), "Type mismatch detected"

    print "âœ… Type mismatch detection"

fn test_check_wrong_arity():
    """Test wrong arity error"""
    val registry = MacroRegistry.empty()

    # Register macro: assert(cond: bool, msg: text)
    val params = [
        MacroParam.regular("cond", HirType.Bool),
        MacroParam.regular("msg", HirType.Str)
    ]
    val macro_def = MacroDef.new_macro(
        "assert",
        params,
        Expr.Block(stmts: []),
        HirType.Unit
    )
    registry.register_macro(macro_def)

    val checker = MacroTypeChecker.new_checker(registry)

    # Invalid call: @assert(true) - missing second argument
    val args = [Expr.BoolLit(value: true)]
    val call = MacroCall.new_call("assert", args)

    assert not checker.check_macro_call(call), "Wrong arity detected"

    print "âœ… Wrong arity detection"

fn test_check_variadic_call():
    """Test variadic macro call"""
    val registry = MacroRegistry.empty()

    # Register macro: log(...msgs: [text])
    val params = [
        MacroParam.variadic("msgs", HirType.Str)
    ]
    val macro_def = MacroDef.new_macro(
        "log",
        params,
        Expr.Block(stmts: []),
        HirType.Unit
    )
    registry.register_macro(macro_def)

    val checker = MacroTypeChecker.new_checker(registry)

    # Valid call: @log("a", "b", "c")
    val args = [
        Expr.StrLit(value: "a"),
        Expr.StrLit(value: "b"),
        Expr.StrLit(value: "c")
    ]
    val call = MacroCall.new_call("log", args)

    assert checker.check_macro_call(call), "Variadic call valid"

    # Valid call: @log() - zero arguments OK for variadic
    val empty_call = MacroCall.new_call("log", [])
    assert checker.check_macro_call(empty_call), "Empty variadic call valid"

    print "âœ… Variadic macro call"

fn test_macro_not_found():
    """Test macro not found error"""
    val registry = MacroRegistry.empty()
    val checker = MacroTypeChecker.new_checker(registry)

    val call = MacroCall.new_call("unknown", [])

    assert not checker.check_macro_call(call), "Macro not found detected"

    print "âœ… Macro not found detection"

fn test_get_expansion_type():
    """Test getting expansion type"""
    val registry = MacroRegistry.empty()

    # Register macro with i32 expansion type
    val macro_def = MacroDef.new_macro(
        "double",
        [MacroParam.regular("x", HirType.Int)],
        Expr.Var(name: "x"),
        HirType.Int
    )
    registry.register_macro(macro_def)

    val checker = MacroTypeChecker.new_checker(registry)

    val call = MacroCall.new_call("double", [Expr.IntLit(value: 5)])
    val exp_ty = checker.get_expansion_type(call)

    assert exp_ty.to_string() == "i32", "Expansion type"

    print "âœ… Get expansion type"

fn test_error_messages():
    """Test error message generation"""
    val err1 = MacroTypeError.macro_not_found("unknown")
    assert err1.to_string().len() > 0, "Macro not found message"

    val err2 = MacroTypeError.wrong_arity("test", 2, 1)
    assert err2.to_string().len() > 0, "Wrong arity message"

    val err3 = MacroTypeError.type_mismatch("test", 0, HirType.Bool, HirType.Int)
    assert err3.to_string().len() > 0, "Type mismatch message"

    print "âœ… Error messages"

fn main():
    print ""
    print "Macro Type Checking Phase 7B Tests"
    print "==================================="

    test_macro_call()
    test_type_env()
    test_check_valid_call()
    test_check_type_mismatch()
    test_check_wrong_arity()
    test_check_variadic_call()
    test_macro_not_found()
    test_get_expansion_type()
    test_error_messages()

    print ""
    print "ðŸŽ‰ Phase 7B Complete!"
    print ""
    print "Implemented:"
    print "  âœ… MacroCall - macro call site representation"
    print "  âœ… MacroTypeChecker - call validation"
    print "  âœ… TypeEnv - type inference for expressions"
    print "  âœ… Arity checking (regular + variadic)"
    print "  âœ… Type matching for arguments"
    print "  âœ… Expansion type inference"
    print "  âœ… MacroTypeError - error messages"
    print ""
    print "Progress: 7/15 hours (47% of Phase 7)"
    print "Next: Phase 7C - Macro Expansion Type Inference (5h)"
