"""
Variance Inference - Phase 6A: Variance Representation

Implements variance types, composition rules, and environment.

Status: Phase 6A In Progress
"""

type Symbol = text

# ============================================================================
# Variance
# ============================================================================

enum Variance:
    """
    Variance of a type parameter

    Examples:
        Covariant (+T):     F<A> <: F<B> if A <: B (producer, read-only)
        Contravariant (-T): F<A> <: F<B> if B <: A (consumer, input)
        Inv (T):            F<A> <: F<B> only if A = B (both, mutable)
        Bivariant (Â±T):     F<A> <: F<B> always (unused parameter)
    """
    Covariant        # +T (producer, read-only)
    Contravariant    # -T (consumer, input)
    Inv              # T (both, mutable) - renamed from Invariant (keyword conflict)
    Bivariant        # Â±T (unused)

impl Variance:
    fn to_string() -> text:
        match self:
            case Covariant: "+"
            case Contravariant: "-"
            case Inv: "="
            case Bivariant: "Â±"

    fn to_long_string() -> text:
        match self:
            case Covariant: "covariant"
            case Contravariant: "contravariant"
            case Inv: "inv"
            case Bivariant: "bivariant"

    fn is_covariant() -> bool:
        match self:
            case Covariant: true
            case _: false

    fn is_contravariant() -> bool:
        match self:
            case Contravariant: true
            case _: false

    fn is_inv() -> bool:
        match self:
            case Inv: true
            case _: false

    fn is_bivariant() -> bool:
        match self:
            case Bivariant: true
            case _: false

# ============================================================================
# Variance Operations
# ============================================================================

class VarianceOps:
    """Helper class for variance operations"""

    static fn flip(v: Variance) -> Variance:
        """
        Flip variance (for contravariant position)

        Examples:
            flip(Covariant) = Contravariant
            flip(Contravariant) = Covariant
            flip(Invariant) = Invariant
            flip(Bivariant) = Bivariant
        """
        match v:
            case Covariant: Variance.Contravariant
            case Contravariant: Variance.Covariant
            case Inv: Variance.Inv
            case Bivariant: Variance.Bivariant

    static fn compose(outer: Variance, inner: Variance) -> Variance:
        """
        Compose two variance contexts

        Rules:
            Covariant + v = v
            Contravariant + v = flip(v)
            Invariant + v = Invariant
            Bivariant + v = Bivariant

        Examples:
            compose(Covariant, Covariant) = Covariant
            compose(Contravariant, Covariant) = Contravariant
            compose(Contravariant, Contravariant) = Covariant (double flip)
            compose(Invariant, Covariant) = Invariant
        """
        match outer:
            case Covariant:
                # Covariant context preserves variance
                inner

            case Contravariant:
                # Contravariant context flips variance
                VarianceOps.flip(inner)

            case Inv:
                # Invariant context forces invariance
                Variance.Inv

            case Bivariant:
                # Bivariant context forces bivariance
                Variance.Bivariant

    static fn combine(v1: Variance, v2: Variance) -> Variance:
        """
        Combine two variance constraints (intersection)

        Rules:
            Bivariant + v = v (unused constraint)
            v + Bivariant = v (unused constraint)
            Covariant + Covariant = Covariant (both agree)
            Contravariant + Contravariant = Contravariant (both agree)
            Otherwise = Invariant (conflict)

        Examples:
            combine(Covariant, Bivariant) = Covariant
            combine(Covariant, Covariant) = Covariant
            combine(Covariant, Contravariant) = Invariant (conflict)
            combine(Invariant, Covariant) = Invariant (already most restrictive)
        """
        match (v1, v2):
            # Bivariant is identity (unused parameter)
            case (Bivariant, v): v
            case (v, Bivariant): v

            # Same variance â†’ keep it
            case (Covariant, Covariant): Variance.Covariant
            case (Contravariant, Contravariant): Variance.Contravariant
            case (Invariant, Invariant): Variance.Inv

            # Conflict â†’ invariant (most restrictive)
            case _: Variance.Inv

# ============================================================================
# Type Parameter Definition
# ============================================================================

class TypeParamDef:
    """
    Type parameter definition with variance

    Examples:
        +T (covariant, explicit)
        T (invariant by default, inferred)
        -U (contravariant, explicit)
    """
    name: Symbol
    variance: Variance  # Explicit or inferred

impl TypeParamDef:
    static fn covariant(name: Symbol) -> TypeParamDef:
        TypeParamDef(name: name, variance: Variance.Covariant)

    static fn contravariant(name: Symbol) -> TypeParamDef:
        TypeParamDef(name: name, variance: Variance.Contravariant)

    static fn inv(name: Symbol) -> TypeParamDef:
        TypeParamDef(name: name, variance: Variance.Inv)

    static fn bivariant(name: Symbol) -> TypeParamDef:
        TypeParamDef(name: name, variance: Variance.Bivariant)

    fn to_string() -> text:
        "{self.variance.to_string()}{self.name}"

# ============================================================================
# Variance Environment
# ============================================================================

class VarianceEnv:
    """
    Environment tracking variance for type parameters

    Maps: type name â†’ parameter name â†’ variance

    Example:
        Box â†’ T â†’ Covariant
        Cell â†’ T â†’ Invariant
        Fn â†’ T â†’ Contravariant
        Fn â†’ U â†’ Covariant
    """
    type_variances: text  # Dict<Symbol, Dict<Symbol, Variance>>

impl VarianceEnv:
    static fn empty() -> VarianceEnv:
        VarianceEnv(type_variances: {})

    me set_type_variance(type_name: Symbol, param_name: Symbol, variance: Variance):
        """Set variance for a type parameter"""
        if type_name not in self.type_variances:
            self.type_variances[type_name] = {}

        # Get inner dict, modify it, assign back
        var type_vars = self.type_variances[type_name]
        type_vars[param_name] = variance
        self.type_variances[type_name] = type_vars

    fn get_type_variance(type_name: Symbol, param_name: Symbol) -> Variance:
        """
        Get variance for a type parameter

        Returns: Variance or Bivariant if not found
        """
        if type_name not in self.type_variances:
            return Variance.Bivariant

        val type_vars = self.type_variances[type_name]

        if param_name not in type_vars:
            return Variance.Bivariant

        type_vars[param_name]

    fn get_type_variances(type_name: Symbol) -> [Variance]:
        """
        Get all variances for a type's parameters (in order)

        Returns: List of variances, empty if type not found
        """
        if type_name not in self.type_variances:
            return []

        val type_vars = self.type_variances[type_name]
        var result = []

        # NOTE: Dict iteration order may not match parameter order
        # In real implementation, would need to track parameter order separately
        for param_name in type_vars:
            result.push(type_vars[param_name])

        result

    me set_type_variances(type_name: Symbol, variances: [Variance], param_names: [Symbol]):
        """
        Set all variances for a type's parameters

        Requires: variances.len() == param_names.len()
        """
        if type_name not in self.type_variances:
            self.type_variances[type_name] = {}

        # Get inner dict, modify it, assign back
        var type_vars = self.type_variances[type_name]

        for i, param_name in param_names.enumerate():
            if i < variances.len():
                type_vars[param_name] = variances[i]

        self.type_variances[type_name] = type_vars

    fn has_type(type_name: Symbol) -> bool:
        """Check if type is in environment"""
        type_name in self.type_variances

    fn type_count() -> i64:
        """Count types in environment"""
        self.type_variances.len()

# ============================================================================
# Tests
# ============================================================================

fn test_variance_basic():
    """Test basic variance creation"""
    val cov = Variance.Covariant
    val contra = Variance.Contravariant
    val inv = Variance.Inv
    val bi = Variance.Bivariant

    assert cov.is_covariant(), "Is covariant"
    assert contra.is_contravariant(), "Is contravariant"
    assert inv.is_inv(), "Is invariant"
    assert bi.is_bivariant(), "Is bivariant"

    assert cov.to_string() == "+", "Covariant symbol"
    assert contra.to_string() == "-", "Contravariant symbol"
    assert inv.to_string() == "=", "Invariant symbol"
    assert bi.to_string() == "Â±", "Bivariant symbol"

    print "âœ… Basic variance"

fn test_variance_flip():
    """Test variance flipping"""
    val cov = Variance.Covariant
    val contra = Variance.Contravariant
    val inv = Variance.Inv
    val bi = Variance.Bivariant

    # Flip covariant â†’ contravariant
    val flipped_cov = VarianceOps.flip(cov)
    assert flipped_cov.is_contravariant(), "Flip covariant"

    # Flip contravariant â†’ covariant
    val flipped_contra = VarianceOps.flip(contra)
    assert flipped_contra.is_covariant(), "Flip contravariant"

    # Flip invariant â†’ invariant
    val flipped_inv = VarianceOps.flip(inv)
    assert flipped_inv.is_inv(), "Flip invariant"

    # Flip bivariant â†’ bivariant
    val flipped_bi = VarianceOps.flip(bi)
    assert flipped_bi.is_bivariant(), "Flip bivariant"

    print "âœ… Variance flip"

fn test_variance_compose():
    """Test variance composition"""
    val cov = Variance.Covariant
    val contra = Variance.Contravariant
    val inv = Variance.Inv

    # Covariant + v = v
    val result1 = VarianceOps.compose(cov, cov)
    assert result1.is_covariant(), "Cov + Cov = Cov"

    val result2 = VarianceOps.compose(cov, contra)
    assert result2.is_contravariant(), "Cov + Contra = Contra"

    # Contravariant + v = flip(v)
    val result3 = VarianceOps.compose(contra, cov)
    assert result3.is_contravariant(), "Contra + Cov = Contra"

    val result4 = VarianceOps.compose(contra, contra)
    assert result4.is_covariant(), "Contra + Contra = Cov (double flip)"

    # Invariant + v = Invariant
    val result5 = VarianceOps.compose(inv, cov)
    assert result5.is_inv(), "Inv + Cov = Inv"

    print "âœ… Variance compose"

fn test_variance_combine():
    """Test variance combination"""
    val cov = Variance.Covariant
    val contra = Variance.Contravariant
    val inv = Variance.Inv
    val bi = Variance.Bivariant

    # Bivariant is identity
    val result1 = VarianceOps.combine(bi, cov)
    assert result1.is_covariant(), "Bi + Cov = Cov"

    val result2 = VarianceOps.combine(cov, bi)
    assert result2.is_covariant(), "Cov + Bi = Cov"

    # Same variance â†’ keep it
    val result3 = VarianceOps.combine(cov, cov)
    assert result3.is_covariant(), "Cov + Cov = Cov"

    val result4 = VarianceOps.combine(contra, contra)
    assert result4.is_contravariant(), "Contra + Contra = Contra"

    # Conflict â†’ invariant
    val result5 = VarianceOps.combine(cov, contra)
    assert result5.is_inv(), "Cov + Contra = Inv (conflict)"

    val result6 = VarianceOps.combine(inv, cov)
    assert result6.is_inv(), "Inv + Cov = Inv (already invariant)"

    print "âœ… Variance combine"

fn test_type_param_def():
    """Test type parameter definition"""
    val t_cov = TypeParamDef.covariant("T")
    val u_contra = TypeParamDef.contravariant("U")
    val v_inv = TypeParamDef.inv("V")

    assert t_cov.variance.is_covariant(), "T is covariant"
    assert u_contra.variance.is_contravariant(), "U is contravariant"
    assert v_inv.variance.is_inv(), "V is invariant"

    assert t_cov.to_string() == "+T", "T string"
    assert u_contra.to_string() == "-U", "U string"
    assert v_inv.to_string() == "=V", "V string"

    print "âœ… Type parameter definition"

fn test_variance_env():
    """Test variance environment"""
    val env = VarianceEnv.empty()

    assert env.type_count() == 0, "Initially empty"

    # Set Box<T> = Covariant
    env.set_type_variance("Box", "T", Variance.Covariant)

    assert env.has_type("Box"), "Has Box"
    assert env.type_count() == 1, "One type"

    val t_var = env.get_type_variance("Box", "T")
    assert t_var.is_covariant(), "Box<T> is covariant"

    # Set Cell<T> = Invariant
    env.set_type_variance("Cell", "T", Variance.Inv)

    assert env.has_type("Cell"), "Has Cell"
    assert env.type_count() == 2, "Two types"

    val cell_t_var = env.get_type_variance("Cell", "T")
    assert cell_t_var.is_inv(), "Cell<T> is invariant"

    # Get unknown type â†’ Bivariant
    val unknown = env.get_type_variance("Unknown", "X")
    assert unknown.is_bivariant(), "Unknown type is bivariant"

    print "âœ… Variance environment"

fn test_variance_env_multiple():
    """Test variance environment with multiple parameters"""
    val env = VarianceEnv.empty()

    # Set Fn<T, U> = (Contravariant, Covariant)
    env.set_type_variance("Fn", "T", Variance.Contravariant)
    env.set_type_variance("Fn", "U", Variance.Covariant)

    val t_var = env.get_type_variance("Fn", "T")
    val u_var = env.get_type_variance("Fn", "U")

    assert t_var.is_contravariant(), "Fn<T> is contravariant"
    assert u_var.is_covariant(), "Fn<U> is covariant"

    print "âœ… Variance environment multiple params"

fn test_variance_env_bulk():
    """Test setting all variances at once"""
    val env = VarianceEnv.empty()

    # Set Result<T, E> = (Covariant, Covariant)
    val variances = [Variance.Covariant, Variance.Covariant]
    val param_names = ["T", "E"]

    env.set_type_variances("Result", variances, param_names)

    val t_var = env.get_type_variance("Result", "T")
    val e_var = env.get_type_variance("Result", "E")

    assert t_var.is_covariant(), "Result<T> is covariant"
    assert e_var.is_covariant(), "Result<E> is covariant"

    print "âœ… Variance environment bulk set"

fn main():
    print ""
    print "Variance Inference Phase 6A Tests"
    print "=================================="

    test_variance_basic()
    test_variance_flip()
    test_variance_compose()
    test_variance_combine()
    test_type_param_def()
    test_variance_env()
    test_variance_env_multiple()
    test_variance_env_bulk()

    print ""
    print "ðŸŽ‰ Phase 6A Complete!"
    print ""
    print "Implemented:"
    print "  âœ… Variance enum (Covariant/Contravariant/Invariant/Bivariant)"
    print "  âœ… VarianceOps - flip, compose, combine"
    print "  âœ… TypeParamDef - type parameters with variance"
    print "  âœ… VarianceEnv - environment tracking"
    print ""
    print "Progress: 2/8 hours (25% of Phase 6)"
    print "Next: Phase 6B - Variance Inference Algorithm (3h)"
