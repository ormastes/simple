# I18n Locale-Aware `__init__.spl` Specification

## Overview

Enable Rust compiler to reference `__init__` values with locale variants, mirroring Simple's module structure. Default locale is compiled-in at build time, while additional locales are loaded at runtime on demand.

---

## Design Goals

1. **Mirror Simple's module system** - Rust sees same folder structure as Simple
2. **Compile-time default** - Default locale embedded in binary (zero runtime cost)
3. **Runtime extensibility** - Load additional locales dynamically when needed
4. **Zero-overhead defaults** - No i18n overhead if using default locale
5. **Simple compatibility** - `__init__.spl` follows module system rules

---

## File Structure

### Flat Structure (RECOMMENDED)

```
i18n/
├── __init__.spl           # Default locale (English) - COMPILED IN
├── __init__.ko.spl        # Korean locale overlay - RUNTIME LOADED
├── __init__.ja.spl        # Japanese locale overlay - RUNTIME LOADED
│
├── parser.spl             # Default parser errors
├── parser.ko.spl          # Korean parser errors
├── parser.ja.spl          # Japanese parser errors
│
├── compiler.spl           # Default compiler errors
├── compiler.ko.spl        # Korean compiler errors
└── compiler.ja.spl        # Japanese compiler errors
```

**Advantages:**
- ✅ Simple flat structure
- ✅ Locale suffix pattern clear
- ✅ Default `.spl` = no suffix = English
- ✅ Easy to compile default into binary

**File Resolution:**
```rust
// Default (compile-time)
load("i18n/__init__.spl")         → English (embedded in binary)
load("i18n/parser.spl")           → English (embedded in binary)

// Runtime (on-demand)
load("i18n/__init__.ko.spl")      → Korean (loaded from disk)
load("i18n/parser.ko.spl")        → Korean (loaded from disk)
```

### Directory Structure (Alternative)

```
i18n/
├── en/
│   ├── __init__.spl       # English - COMPILED IN
│   ├── parser.spl
│   └── compiler.spl
└── ko/
    ├── __init__.spl       # Korean - RUNTIME LOADED
    ├── parser.spl
    └── compiler.spl
```

**Trade-offs:**
- ⚠️ Less clear which is default
- ⚠️ Need special logic to know "en/" is compiled-in
- ✅ More organized with many locales

**DECISION: Use Flat Structure for MVP**

---

## `__init__.spl` Content Rules

Since these are i18n data files (NOT Simple modules), we RELAX the module system restrictions:

### Allowed in i18n `__init__.spl`:

```simple
# i18n/__init__.spl - English default

# Dictionary literal with severity names
val severity = {
    "error": "error",
    "warning": "warning",
    "info": "info",
    "help": "help",
    "note": "note"
}

# Optional: Functions for formatting
fn format_error_count(n: Int) -> String:
    if n == 1:
        "1 error"
    else:
        "{n} errors"

# Optional: Constants
val compiler_version = "0.1.0"
```

### Korean variant:

```simple
# i18n/__init__.ko.spl - Korean overlay

val severity = {
    "error": "오류",
    "warning": "경고",
    "info": "정보",
    "help": "도움말",
    "note": "참고"
}

fn format_error_count(n: Int) -> String:
    if n == 1:
        "오류 1개"
    else:
        "오류 {n}개"
```

**Key Difference from Module `__init__.spl`:**
- ✅ Variables allowed (data-driven)
- ✅ Functions allowed (formatting helpers)
- ❌ No `mod` declaration (not a module)
- ❌ No `pub mod` child declarations
- ❌ No `use`/`export use` imports

---

## Compilation Strategy

### Phase 1: Compile-Time Default Embedding

**Build-time code generation:**

```rust
// In build.rs
fn main() {
    // Parse default locale catalogs at compile time
    let default_locale = env::var("SIMPLE_DEFAULT_LOCALE").unwrap_or("en".to_string());

    // Generate Rust code with embedded catalog
    generate_default_catalog("i18n/__init__.spl", "severity");
    generate_default_catalog("i18n/parser.spl", "messages");
    generate_default_catalog("i18n/compiler.spl", "messages");
}

fn generate_default_catalog(path: &str, var_name: &str) {
    // Parse Simple file
    let ast = parse_simple_file(path);

    // Extract dictionary literal
    let dict = extract_variable(&ast, var_name);

    // Generate Rust code
    let rust_code = format!(r#"
        pub static DEFAULT_{}: phf::Map<&'static str, &'static str> = phf_map! {{
            {}
        }};
    "#, var_name.to_uppercase(), generate_phf_entries(dict));

    // Write to OUT_DIR
    write_generated_code(rust_code);
}
```

**Generated Rust code (in `default_catalogs.rs`):**

```rust
// Auto-generated by build.rs - DO NOT EDIT

use phf::phf_map;

pub static DEFAULT_SEVERITY: phf::Map<&'static str, &'static str> = phf_map! {
    "error" => "error",
    "warning" => "warning",
    "info" => "info",
    "help" => "help",
    "note" => "note",
};

pub static DEFAULT_PARSER_MESSAGES: phf::Map<&'static str, LocalizedMessage> = phf_map! {
    "E0001" => LocalizedMessage {
        id: "E0001",
        title: "Syntax Error",
        message: "{message}",
        label: Some("syntax error here"),
        help: None,
        note: None,
    },
    // ... E0002-E0012
};
```

### Phase 2: Runtime Locale Loading

**Runtime catalog loader:**

```rust
// In src/i18n/src/lib.rs

impl I18n {
    pub fn new(locale: Locale) -> Self {
        let registry = if locale.is_default() {
            // Use compiled-in default
            CatalogRegistry::from_defaults()
        } else {
            // Load from disk
            CatalogRegistry::from_locale_files(&locale)
        };

        Self { locale, registry }
    }
}

impl CatalogRegistry {
    /// Use compile-time embedded defaults
    fn from_defaults() -> Self {
        let mut registry = Self::new();

        // Load from generated code
        registry.register_default("common", &DEFAULT_SEVERITY);
        registry.register_default("parser", &DEFAULT_PARSER_MESSAGES);

        registry
    }

    /// Load runtime locale files
    fn from_locale_files(locale: &Locale) -> Self {
        let mut registry = Self::new();
        let base_dir = find_i18n_dir();

        // Load __init__.<locale>.spl
        let init_path = base_dir.join(format!("__init__.{}.spl", locale.code));
        if init_path.exists() {
            registry.load_file(&init_path, "common", locale);
        }

        // Load parser.<locale>.spl
        let parser_path = base_dir.join(format!("parser.{}.spl", locale.code));
        if parser_path.exists() {
            registry.load_file(&parser_path, "parser", locale);
        }

        registry
    }
}
```

---

## Locale Resolution Rules

### Default Locale (Compile-Time)

```rust
// Set at compile time via environment variable
// In Cargo.toml or build command:
// SIMPLE_DEFAULT_LOCALE=en cargo build

const DEFAULT_LOCALE: &str = env!("SIMPLE_DEFAULT_LOCALE", "en");
```

### Runtime Locale Selection

```rust
impl Locale {
    pub fn from_env() -> Self {
        // 1. Check SIMPLE_LANG environment variable
        if let Ok(lang) = env::var("SIMPLE_LANG") {
            return Self::parse(&lang);
        }

        // 2. Check LANG environment variable
        if let Ok(lang) = env::var("LANG") {
            return Self::parse(&lang);
        }

        // 3. Use compile-time default
        Self::default()
    }

    pub fn is_default(&self) -> bool {
        self.code == DEFAULT_LOCALE
    }
}
```

### Locale Fallback Chain

```
User requests "ko_KR" (Korean, South Korea)
  ↓
1. Try __init__.ko_KR.spl (specific region)
  ↓ (not found)
2. Try __init__.ko.spl (language only)
  ↓ (not found)
3. Fall back to __init__.spl (default, embedded)
```

---

## API Design

### High-Level Usage

```rust
use simple_i18n::{I18n, MessageContext};

fn main() {
    // Default locale (compile-time embedded, zero overhead)
    let i18n_default = I18n::default();  // Uses DEFAULT_LOCALE

    // Runtime locale (loads from disk)
    let i18n_korean = I18n::with_locale("ko");

    // From environment
    let i18n_auto = I18n::from_env();  // Reads SIMPLE_LANG
}
```

### Message Retrieval

```rust
// Get severity name
let i18n = I18n::with_locale("ko");
let error_text = i18n.get_severity("error");
// Returns: "오류" (loaded from __init__.ko.spl)

// Get error message
let mut ctx = MessageContext::new();
ctx.insert("expected", "identifier");
ctx.insert("found", "number");

let msg = i18n.get_message("parser", "E0002", &ctx);
// Returns: "식별자을(를) 예상했지만 숫자을(를) 발견했습니다"
```

### CLI Integration

```rust
// In src/driver/src/main.rs

#[derive(Parser)]
struct Cli {
    #[clap(long)]
    lang: Option<String>,
}

fn main() {
    let cli = Cli::parse();

    // Set locale for this execution
    if let Some(lang) = cli.lang {
        env::set_var("SIMPLE_LANG", lang);
    }

    // I18n auto-detects from environment
    let i18n = I18n::from_env();

    // Compile and show errors in user's language
    compile_with_i18n(&i18n);
}
```

---

## Implementation Plan

### Phase 1: Build-Time Catalog Generation

**Files to create:**
- `build.rs` - Parse default `.spl` files, generate Rust code
- `src/i18n/src/codegen/` - Code generation utilities
- `src/i18n/src/default_catalogs.rs` - Generated defaults (git-ignored)

**Dependencies:**
- Add `phf` = "0.11" for compile-time perfect hash maps
- Add `phf_codegen` = "0.11" to build-dependencies

**Tasks:**
1. Create `build.rs` script
2. Parse `i18n/__init__.spl` and extract `val severity`
3. Parse `i18n/parser.spl` and extract `val messages`
4. Generate `phf::Map` declarations
5. Write to `OUT_DIR/default_catalogs.rs`
6. Include in `lib.rs` via `include!(concat!(env!("OUT_DIR"), "/default_catalogs.rs"));`

### Phase 2: Runtime Locale Loading

**Files to modify:**
- `src/i18n/src/lib.rs` - Add `Locale::is_default()`, `I18n::from_env()`
- `src/i18n/src/catalog.rs` - Add `CatalogRegistry::from_defaults()`, `from_locale_files()`
- `src/i18n/src/simple_catalog.rs` - Support locale suffix parsing

**Tasks:**
1. Add default locale detection
2. Implement compile-time catalog loading
3. Implement runtime catalog loading with locale suffix
4. Add locale fallback chain

### Phase 3: File Structure Setup

**Create files:**
```bash
# Default locale (English)
touch i18n/__init__.spl
touch i18n/parser.spl
touch i18n/compiler.spl

# Korean locale
touch i18n/__init__.ko.spl
touch i18n/parser.ko.spl
touch i18n/compiler.ko.spl
```

**Populate content:**
- Move existing content from `i18n/locales/en/*.spl` to `i18n/*.spl`
- Move existing content from `i18n/locales/ko/*.spl` to `i18n/*.ko.spl`

### Phase 4: Integration Testing

**Tests:**
1. Build with default locale embedded
2. Load Korean locale at runtime
3. Verify fallback to English for missing keys
4. Test CLI `--lang` flag
5. Test environment variable detection

---

## Performance Characteristics

### Default Locale (Compile-Time)

```rust
// Zero runtime cost - direct memory access
let error_text = DEFAULT_SEVERITY.get("error");  // O(1) phf lookup
```

**Characteristics:**
- ✅ **Zero-cost abstraction** - Same as hardcoded strings
- ✅ **No I/O** - Embedded in binary
- ✅ **No parsing** - Pre-parsed at build time
- ✅ **Perfect hashing** - O(1) lookup via `phf`
- ✅ **Small binary size** - ~10KB for English catalogs

### Runtime Locale

```rust
// Lazy loading - parse on first use
let i18n = I18n::with_locale("ko");  // Parses __init__.ko.spl
let error_text = i18n.get_severity("error");  // Cached lookup
```

**Characteristics:**
- ⚠️ **First-time cost** - Parse `.spl` file (~1-2ms)
- ✅ **Cached** - Subsequent lookups are O(1)
- ✅ **Lazy** - Only load if non-default locale requested
- ✅ **Memory efficient** - Only one locale in memory at a time

---

## Migration Path

### From Current Implementation

**Current structure:**
```
i18n/locales/
├── en/
│   ├── __init__.spl  (WRONG - violates spec)
│   └── parser.spl
└── ko/
    ├── __init__.spl  (WRONG - violates spec)
    └── parser.spl
```

**New structure:**
```
i18n/
├── __init__.spl       # Rename from locales/en/__init__.spl
├── __init__.ko.spl    # Rename from locales/ko/__init__.spl
├── parser.spl         # Rename from locales/en/parser.spl
└── parser.ko.spl      # Rename from locales/ko/parser.spl
```

**Migration steps:**
1. Create `i18n/` directory at workspace root
2. Move `i18n/locales/en/*.spl` → `i18n/*.spl`
3. Move `i18n/locales/ko/*.spl` → `i18n/*.ko.spl`
4. Remove old `i18n/locales/` directory
5. Update Rust code to use new paths

---

## Benefits of This Design

### 1. Zero-Cost Default Locale
```rust
// English (default) - compiled in, no runtime overhead
let msg = i18n.get_message("parser", "E0002", &ctx);
// Equivalent to: DEFAULT_PARSER_MESSAGES["E0002"]
```

### 2. Mirrors Simple's Module System
```
Simple module:     src/core/__init__.spl
I18n catalog:      i18n/__init__.spl       (default)
I18n catalog (ko): i18n/__init__.ko.spl    (locale variant)
```

### 3. Flexible Deployment
```bash
# Minimal binary - only English
cargo build --release
# Size: ~500KB (default locale embedded)

# With runtime locales
cargo build --release
cp i18n/*.ko.spl /usr/share/simple/i18n/
# Binary: ~500KB, Locales: ~20KB per language on disk
```

### 4. Easy Extension
```bash
# Add Japanese support
cp i18n/__init__.spl i18n/__init__.ja.spl
# Edit Japanese translations
simple build main.spl --lang ja
```

---

## Example: Complete Flow

### Build Time (English Default)

```bash
SIMPLE_DEFAULT_LOCALE=en cargo build
```

1. `build.rs` parses `i18n/__init__.spl`
2. Extracts `val severity = {...}`
3. Generates `DEFAULT_SEVERITY` phf map
4. Embeds in binary

### Runtime (Korean Requested)

```bash
simple build main.spl --lang ko
```

1. CLI sets `SIMPLE_LANG=ko`
2. `I18n::from_env()` detects locale
3. Checks `locale.is_default()` → false
4. Loads `i18n/__init__.ko.spl` from disk
5. Parses and caches
6. Returns Korean messages

### Runtime (English Default)

```bash
simple build main.spl
```

1. `I18n::from_env()` uses default
2. Checks `locale.is_default()` → true
3. Uses `DEFAULT_SEVERITY` (compiled-in)
4. Zero I/O, zero parsing

---

## Success Criteria

✅ **Compile-time:**
- [ ] Default locale embedded in binary via `build.rs`
- [ ] `phf` maps generated for zero-cost lookup
- [ ] Binary size < 600KB with English catalog

✅ **Runtime:**
- [ ] Load `__init__.ko.spl` successfully
- [ ] Fallback to English for missing keys
- [ ] `--lang ko` flag works end-to-end
- [ ] Environment variable detection works

✅ **Performance:**
- [ ] Default locale: 0ns overhead (compile-time)
- [ ] Korean locale: < 2ms first load, cached after
- [ ] Memory usage: < 100KB per locale

✅ **Usability:**
- [ ] File structure mirrors Simple's modules
- [ ] Easy to add new languages
- [ ] Clear default vs. locale variants
