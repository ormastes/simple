# Simple Package Manager - Design Document

**Date:** 2026-02-01
**Status:** Design Phase
**Based On:** Research of npm, pnpm, Cargo, apt (2026 state-of-the-art)

---

## Executive Summary

Design a fast, modern package manager for Simple Language that achieves:
- **70% disk savings** through global cache with hard links (pnpm model)
- **3-4x faster installs** through parallel HTTP/2 downloads
- **Reproducible builds** via lockfiles (SDN format)
- **Better error messages** through PubGrub dependency resolver

**Key Insight:** Start simple (global cache + lockfiles), add complexity incrementally (registry, advanced resolver).

---

## 1. Design Principles

### 1.1 Core Values

1. **Fast by Default**
   - Parallel operations everywhere
   - Global cache minimizes downloads
   - HTTP/2 multiplexing
   - Target: <2s cold install (10 deps), <100ms warm install

2. **Simple First, Power When Needed**
   - Path dependencies for local development
   - Git dependencies for unreleased packages
   - Registry for published packages (future)

3. **Reproducible Builds**
   - Lockfile captures exact dependency tree
   - Checksums verify integrity
   - SDN format (merge-friendly, human-readable)

4. **Excellent Error Messages**
   - Explain why resolution failed
   - Suggest fixes
   - Show dependency chain

### 1.2 Non-Goals (v1.0)

- ❌ Monorepo/workspaces (defer to v2.0)
- ❌ Binary compatibility (use source packages)
- ❌ Paid private registry (start with git)
- ❌ Plugin system (YAGNI)

---

## 2. Architecture Overview

### 2.1 Component Diagram

```
┌─────────────────────────────────────────────┐
│           Simple Package Manager            │
├─────────────────────────────────────────────┤
│                                             │
│  ┌──────────────┐      ┌──────────────┐   │
│  │   CLI        │─────▶│  Resolver    │   │
│  │  (commands)  │      │  (PubGrub)   │   │
│  └──────────────┘      └──────────────┘   │
│         │                      │            │
│         ▼                      ▼            │
│  ┌──────────────┐      ┌──────────────┐   │
│  │  Manifest    │      │   Lockfile   │   │
│  │  (simple.sdn)│      │ (simple.lock)│   │
│  └──────────────┘      └──────────────┘   │
│         │                      │            │
│         └──────────┬───────────┘            │
│                    ▼                        │
│            ┌──────────────┐                 │
│            │   Fetcher    │                 │
│            │ (HTTP/2 + ∥)│                 │
│            └──────────────┘                 │
│                    │                        │
│                    ▼                        │
│            ┌──────────────┐                 │
│            │ Global Cache │                 │
│            │  (hard links)│                 │
│            └──────────────┘                 │
│                    │                        │
│                    ▼                        │
│            ┌──────────────┐                 │
│            │  Installer   │                 │
│            │ (deps/ dir)  │                 │
│            └──────────────┘                 │
└─────────────────────────────────────────────┘

External:
  Git Repos ────▶ Fetcher
  HTTP Registry ─▶ Fetcher
```

### 2.2 Data Flow

**Install Flow:**
```
1. Read simple.sdn (manifest)
2. Check simple.lock exists?
   Yes → Use locked versions
   No → Resolve dependencies
3. For each package:
   - Check global cache
   - Download if missing (parallel HTTP/2)
   - Verify checksum
   - Store in cache
4. Create hard links from cache to deps/
5. Generate/update simple.lock
```

**Add Package Flow:**
```
1. Add dependency to simple.sdn
2. Run resolver with new constraint
3. Update simple.lock with new tree
4. Install missing packages
```

---

## 3. File Formats

### 3.1 Package Manifest (simple.sdn)

**Location:** `simple.sdn` (project root)

```sdn
package:
  name: myapp
  version: 0.1.0
  description: My Simple application
  authors: [Alice <alice@example.com>]
  license: MIT

dependencies:
  # Registry packages (future)
  http: ^1.0                    # SemVer constraint
  json: >=2.0, <3.0             # Range

  # Git dependencies
  mylib:
    git: https://github.com/alice/mylib
    tag: v1.2.3                 # Or: branch, commit

  # Path dependencies (local development)
  utils:
    path: ../utils

  # Optional dependencies
  tls:
    version: ^2.0
    optional: true

dev_dependencies:
  test_framework: ^1.0

# Platform-specific dependencies
target_linux:
  dependencies:
    linux_api: ^1.0

target_windows:
  dependencies:
    windows_api: ^1.0
```

**Schema:**
- `package.name`: Lowercase, hyphens allowed, must match registry (future)
- `package.version`: SemVer (MAJOR.MINOR.PATCH)
- `dependencies`: Map of package name → version spec or details
- `dev_dependencies`: Only installed in root project

### 3.2 Lockfile (simple.lock)

**Location:** `simple.lock` (project root, committed to git)

```sdn
# Generated by Simple Package Manager
# Do not edit manually

lockfile_version: 1
generated: 2026-02-01T12:34:56Z
simple_version: 0.3.0

# Resolved dependency tree (flat)
packages |name, version, source, checksum|
  http, 1.1.0, registry, sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
  url, 1.2.0, registry, sha256:abc123def456...
  mylib, 0.5.0, git+https://github.com/alice/mylib#abc1234, sha256:def456abc123...
  utils, 0.1.0, path+../utils, sha256:123456abcdef...

# Dependency edges (for verification)
dependencies |package, version, deps|
  http, 1.1.0, [url@1.2.0]
  mylib, 0.5.0, []
  url, 1.2.0, []
  utils, 0.1.0, []
```

**Design Decisions:**
1. **Flat structure** - All packages at top level (depth-1 tree)
2. **SDN format** - Merge-friendly, human-readable
3. **Checksums** - SHA256 for all sources (registry, git, path)
4. **Source URLs** - Preserve origin for debugging
5. **Version field** - Only bump when format changes (Cargo approach)

### 3.3 Registry Index (Future: Phase 5)

**Location:** Git repository (`https://github.com/simple-lang/registry/index/`)

```sdn
# index/ht/tp/http.sdn

package:
  name: http
  description: HTTP client library
  repository: https://github.com/simple-lang/http
  homepage: https://simple-lang.org/http
  documentation: https://docs.simple-lang.org/http
  license: MIT
  keywords: [http, client, web]

versions |version, published, yanked, checksum, deps|
  1.0.0, 2024-12-01T00:00:00Z, false, sha256:e3b0c44..., []
  1.1.0, 2024-12-15T00:00:00Z, false, sha256:abc123..., [url>=1.0]
  1.2.0, 2025-01-10T00:00:00Z, false, sha256:def456..., [url>=1.2, tls^2.0]
```

**Sparse Protocol:**
- Fetch only metadata for needed packages
- Path: `index/{first2}/{next2}/{name}.sdn`
- Example: `http` → `index/ht/tp/http.sdn`

---

## 4. Dependency Resolution

### 4.1 Version Constraints (SemVer)

**Syntax:**

| Constraint | Meaning | Example |
|------------|---------|---------|
| `^1.2.3` | Compatible with 1.2.3 | >=1.2.3, <2.0.0 |
| `~1.2.3` | Minor-level compatible | >=1.2.3, <1.3.0 |
| `>=1.0, <2.0` | Range | >=1.0.0, <2.0.0 |
| `1.2.3` | Exact | 1.2.3 only |
| `*` | Any | Latest version |

**Caret (^) Rules:**
- `^1.2.3` → `>=1.2.3, <2.0.0` (standard)
- `^0.2.3` → `>=0.2.3, <0.3.0` (0.x is unstable)
- `^0.0.3` → `=0.0.3` (0.0.x is highly unstable)

### 4.2 PubGrub Algorithm (Phase 6)

**Why PubGrub over backtracking?**
- 66x faster on complex dependency graphs (rattler benchmark)
- Better error messages (shows full conflict chain)
- Conflict-driven clause learning prunes search space

**Example Resolution:**

```
Step 1: Add root dependency
  myapp 0.1.0 requires: http ^1.0, json ^2.0

Step 2: Choose http version
  Try http 1.1.0 (latest compatible)
  http 1.1.0 requires: url ^1.0

Step 3: Choose json version
  Try json 2.0.1 (latest compatible)
  json 2.0.1 requires: url ^2.0

  ❌ CONFLICT: url can't be both ^1.0 and ^2.0

Step 4: Learn clause
  "http 1.1.0 and json 2.0.1 are incompatible"

Step 5: Backtrack with knowledge
  Try json 2.0.0
  json 2.0.0 requires: url ^1.0
  ✅ Compatible! Use url 1.2.0
```

**Error Message:**
```
Error: Cannot resolve dependencies

  Package 'json 2.0.1' requires url ^2.0
  But package 'http 1.1.0' requires url ^1.0

  Dependency chain:
    myapp 0.1.0 → http ^1.0
    myapp 0.1.0 → json ^2.0

  Possible solutions:
    1. Use json 2.0.0 (compatible with url ^1.0)
    2. Use http 1.2.0 (compatible with url ^2.0)
    3. Relax constraint on json to >=2.0.0, <2.0.1
```

### 4.3 Dependency Source Priority

**Order:**

1. **Lockfile** (if exists) - Use exact versions
2. **Path dependencies** - Local development overrides
3. **Git dependencies** - Pinned commits
4. **Registry** (future) - Published packages

**Rationale:**
- Lockfile ensures reproducibility
- Path deps enable local development
- Git deps allow unreleased code
- Registry is for stable releases

---

## 5. Global Cache Design

### 5.1 Cache Structure

```
~/.simple/
├── cache/
│   ├── packages/
│   │   ├── http-1.0.0/
│   │   │   ├── simple.sdn
│   │   │   ├── src/
│   │   │   └── lib/
│   │   ├── http-1.1.0/
│   │   └── json-2.0.1/
│   ├── git/
│   │   └── github.com-alice-mylib-abc1234/
│   └── index/                    # Future: registry metadata cache
│       └── ht/tp/http.sdn
├── config.sdn                    # Global configuration
└── credentials.sdn               # Registry auth tokens (chmod 600)
```

### 5.2 Hard Links

**Mechanism:**

```rust
use std::fs;

// Create hard link from cache to project
fs::hard_link(
    "~/.simple/cache/packages/http-1.1.0",
    "./deps/http"
)?;
```

**Benefits:**
- **Zero-copy installation** - Instant for cached packages
- **70% disk savings** - Shared files across projects
- **Atomic operations** - Link creation is atomic

**Platform Support:**
- ✅ Linux: Full support
- ✅ macOS: Full support
- ⚠️ Windows: Requires admin OR developer mode (Win 10+)

**Fallback Strategy:**
```rust
match fs::hard_link(src, dst) {
    Ok(_) => Ok(()),
    Err(e) if e.kind() == PermissionDenied => {
        // Windows without admin: copy instead
        fs::copy(src, dst)?;
        warn!("Hard link failed, using copy (slower)");
        Ok(())
    }
    Err(e) => Err(e),
}
```

### 5.3 Cache Management

**Commands:**

```bash
# Show cache stats
simple cache info
# Output:
# Cache directory: ~/.simple/cache
# Total size: 1.2 GB
# Packages: 143
# Last cleaned: 2026-01-15

# Clean unused packages
simple cache clean
# Removes packages not referenced by any project

# Clear entire cache
simple cache clear
# Removes all cached packages (forces re-download)
```

**Cleanup Strategy:**
- Keep packages used in last 30 days
- Remove git checkouts older than 90 days
- Keep registry index (small)

---

## 6. Parallel Downloads

### 6.1 HTTP/2 Client

**Implementation:**

```rust
use reqwest::Client;
use tokio::task::JoinSet;

pub struct PackageFetcher {
    client: Client,
    max_concurrent: usize,
}

impl PackageFetcher {
    pub fn new() -> Self {
        Self {
            client: Client::builder()
                .http2_prior_knowledge()  // Force HTTP/2
                .build()
                .unwrap(),
            max_concurrent: 12,           // Configurable
        }
    }

    pub async fn fetch_all(&self, packages: Vec<Package>) -> Result<Vec<Downloaded>> {
        let mut tasks = JoinSet::new();
        let semaphore = Arc::new(Semaphore::new(self.max_concurrent));

        for pkg in packages {
            let client = self.client.clone();
            let sem = semaphore.clone();

            tasks.spawn(async move {
                let _permit = sem.acquire().await.unwrap();
                client.get(&pkg.url).send().await
            });
        }

        let mut results = Vec::new();
        while let Some(result) = tasks.join_next().await {
            results.push(result??);
        }

        Ok(results)
    }
}
```

**Configuration:**

```sdn
# ~/.simple/config.sdn

network:
  max_concurrent_downloads: 12    # Default: 12
  timeout_seconds: 30
  retry_count: 3
  http2_only: true                # Fallback to HTTP/1.1 if false
```

### 6.2 Progress Reporting

**Terminal UI:**

```
Downloading packages...
[████████████████──────] 8/10 (80%)
  ✓ http-1.1.0      [2.3 MB] (done)
  ✓ json-2.0.1      [890 KB] (done)
  ✓ url-1.2.0       [1.5 MB] (done)
  ↓ crypto-3.1.0    [4.1 MB] 45% (1.8 MB/s)
  ↓ tls-2.5.0       [3.4 MB] 12% (2.1 MB/s)
```

**Implementation:**

```rust
use indicatif::{MultiProgress, ProgressBar};

let multi = MultiProgress::new();
for pkg in packages {
    let pb = multi.add(ProgressBar::new(pkg.size));
    pb.set_message(format!("↓ {}-{}", pkg.name, pkg.version));

    // Update progress as bytes download
    // On completion: pb.finish_with_message("✓");
}
```

---

## 7. Command-Line Interface

### 7.1 Core Commands

```bash
# Install dependencies
simple install                   # Use lockfile if exists
simple install --force           # Ignore lockfile, re-resolve

# Add dependency
simple add http ^1.0             # Add to dependencies
simple add --dev test_framework  # Add to dev_dependencies
simple add --path ../utils       # Path dependency

# Remove dependency
simple remove http

# Update dependencies
simple update                    # Update all (within constraints)
simple update http               # Update specific package

# Show dependency tree
simple tree
simple tree --depth 2            # Limit depth

# Cache management
simple cache info
simple cache clean
simple cache clear

# Publish (future)
simple publish
simple publish --dry-run
```

### 7.2 Example Workflows

**Starting new project:**
```bash
simple init myapp               # Creates simple.sdn
cd myapp
simple add http ^1.0            # Add dependency
simple install                  # Downloads and creates lockfile
```

**Joining existing project:**
```bash
git clone https://github.com/alice/myapp
cd myapp
simple install                  # Uses lockfile (reproducible)
```

**Updating dependency:**
```bash
simple add http ^1.1            # Change constraint
simple install                  # Re-resolves, updates lockfile
```

---

## 8. Security & Integrity

### 8.1 Checksum Verification

**SHA256 for all sources:**

```rust
use sha2::{Sha256, Digest};

fn verify_package(path: &Path, expected: &str) -> Result<()> {
    let content = fs::read(path)?;
    let mut hasher = Sha256::new();
    hasher.update(&content);
    let actual = format!("sha256:{:x}", hasher.finalize());

    if actual != expected {
        return Err(Error::ChecksumMismatch {
            expected: expected.to_string(),
            actual,
        });
    }

    Ok(())
}
```

**Lockfile ensures integrity:**
- Every package has SHA256 checksum
- Git dependencies: hash of commit + tree
- Path dependencies: hash of source files

### 8.2 Yanked Versions (Future)

**Registry metadata:**
```sdn
versions |version, yanked, yanked_reason|
  1.0.0, false, ""
  1.0.1, true, "Security vulnerability CVE-2025-1234"
  1.1.0, false, ""
```

**Behavior:**
- ✅ Allow if in lockfile (reproducibility)
- ⚠️ Warn user about yanked version
- ❌ Prevent `simple add yanked@1.0.1`

### 8.3 Credential Management

```sdn
# ~/.simple/credentials.sdn (chmod 600)

credentials |registry, token|
  https://registry.simple-lang.org, simple_abc123def456...
  https://private.corp.com, corp_token_xyz789...
```

**Environment variable override:**
```bash
export SIMPLE_REGISTRY_TOKEN="simple_abc123..."
simple publish
```

---

## 9. Performance Targets

### 9.1 Benchmarks

| Operation | Target | Notes |
|-----------|--------|-------|
| Cold install (10 deps) | < 2s | First time, empty cache |
| Warm install (10 deps) | < 100ms | All in cache, hard links |
| Add package | < 1s | Resolve + download |
| Dependency tree | < 50ms | Read lockfile |
| Cache clean | < 500ms | Scan + delete |

### 9.2 Comparison to Other Managers

**10-package project (2026 data):**

| Manager | Cold Install | Warm Install |
|---------|--------------|--------------|
| Bun | 0.8s | 30ms |
| pnpm | 4.2s | 50ms |
| Yarn | 6.8s | 100ms |
| npm | 14.3s | 200ms |
| **Simple (target)** | **< 2s** | **< 100ms** |

**Realism Check:**
- Bun uses Zig + native code (very fast)
- pnpm is Rust + Node (fast, mature)
- Simple will be Rust-native → should match pnpm speed

---

## 10. Implementation Phases

### Phase 3.5: Dependency Foundation (2-3 weeks)

**Goals:**
- Manifest parsing (simple.sdn)
- Lockfile generation (simple.lock)
- SemVer constraint parsing
- Simple backtracking resolver

**Deliverables:**
- `simple install` reads manifest + lockfile
- `simple add` updates manifest
- Path dependencies work
- Git dependencies work (future: clone via git)

### Phase 4: Global Cache (1-2 weeks)

**Goals:**
- Global cache directory (`~/.simple/cache/`)
- Hard link creation
- Cache management commands

**Deliverables:**
- 70% disk savings
- Instant warm installs
- `simple cache info/clean/clear`

### Phase 5: Git Registry (2-3 weeks)

**Goals:**
- Sparse protocol client
- Package metadata fetching
- Search and discovery

**Deliverables:**
- `simple add http` fetches from registry
- `simple search query` finds packages
- Registry index cached locally

### Phase 6: PubGrub Resolver (3-4 weeks)

**Goals:**
- Replace backtracking with PubGrub
- Better error messages
- Faster resolution

**Deliverables:**
- 10x faster resolution on complex graphs
- Clear conflict explanations
- Suggested fixes

### Phase 7: Parallel HTTP/2 (1-2 weeks)

**Goals:**
- Async downloads with tokio
- HTTP/2 multiplexing
- Progress bars

**Deliverables:**
- 3-4x faster downloads
- Real-time progress indicators
- Configurable concurrency

---

## 11. Future Enhancements

### Beyond v1.0

1. **Monorepo/Workspaces**
   - Multiple packages in one repo
   - Shared dependencies
   - Cross-package development

2. **Binary Packages**
   - Pre-compiled stdlib modules
   - Platform-specific builds
   - Faster installation

3. **HTTP Registry Server**
   - REST API
   - Full-text search
   - Download statistics
   - Publish workflow

4. **Delta Updates**
   - Only download changed files
   - rsync-style diffs
   - 90%+ bandwidth savings for updates

5. **CI Optimizations**
   - Cacheable Docker layers
   - GitHub Actions integration
   - Hermetic builds

---

## 12. Design Decisions Log

### Decision 1: SDN for Lockfile

**Options:**
- JSON (npm)
- YAML (pnpm)
- TOML (Cargo)
- SDN (Simple's native format)

**Choice:** SDN

**Rationale:**
- ✅ Merge-friendly (table format)
- ✅ Human-readable
- ✅ Consistent with manifest
- ✅ Native to Simple ecosystem

### Decision 2: Global Cache with Hard Links

**Options:**
- Node_modules per project (npm)
- Global cache + hard links (pnpm)
- Content-addressable + symlinks (Nix)

**Choice:** Global cache + hard links (pnpm model)

**Rationale:**
- ✅ 70% disk savings (proven)
- ✅ Fast warm installs
- ✅ Simpler than content-addressable
- ⚠️ Windows requires admin (but has fallback)

### Decision 3: PubGrub vs Backtracking

**Options:**
- Backtracking (npm, yarn)
- PubGrub (Dart pub, Poetry)
- SAT solver (libsolv, used by conda)

**Choice:** Start with backtracking, migrate to PubGrub

**Rationale:**
- ✅ Backtracking is simpler to implement
- ✅ PubGrub is future-proof (better errors, faster)
- ✅ Can migrate incrementally

### Decision 4: Git Registry vs HTTP Registry

**Options:**
- Git-based index (Cargo sparse protocol)
- HTTP API (npm)
- Hybrid (start with git, add HTTP later)

**Choice:** Git-based index (sparse protocol)

**Rationale:**
- ✅ No server infrastructure needed
- ✅ GitHub provides CDN + reliability
- ✅ Easy to mirror/fork
- ✅ Can add HTTP API later without breaking clients

---

## Conclusion

This design balances:
- **Simplicity** - Start with global cache + lockfiles
- **Performance** - Parallel downloads, hard links, HTTP/2
- **Ecosystem Growth** - Registry enables package discovery
- **Long-term Vision** - PubGrub, workspaces, binary packages

**Next Step:** Implement Phase 3.5 (Dependency Foundation) - manifest + lockfile + resolver.

---

**Document Status:** Complete
**Review Date:** 2026-02-01
**Next Review:** After Phase 3.5 implementation
