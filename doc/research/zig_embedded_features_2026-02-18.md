# Zig Embedded Features for Simple ‚Äî Implementation Research
**Date:** 2026-02-18
**Status:** Research
**Implementation Status:** 9/10 features implemented, 1/10 research-only
**Companion docs:**
- `baremetal_embedded_research_2026-02-05.md` ‚Äî core embedded gaps (bitfields, volatile, ISR, linker)
- `missing_language_features_2026-02-17.md` ‚Äî general language feature gaps with safety profiles
- `introspection_phantom_types_2026-02-17.md` ‚Äî phantom types / introspection

**Scope:** Ten Zig features especially valuable for bare-metal/embedded work (JSF++/NASA safety rules), analyzed for Simple. Each item rated for: current status, implementation difficulty, embedded ROI, and safety profile impact.

---

## Summary Table

Verified 2026-02-18 by codebase search.

| # | Zig Feature | Verified Status | Embedded ROI | Remaining Cost | Section |
|---|------------|----------------|-------------|---------------|---------|
| 1 | comptime / const fn evaluation | **IMPL** ‚Äî comptime_checker.spl (warnings for non-CT ops) | **CRITICAL** | HIGH (CT eval engine) | [‚Üí](#1-comptime--const-fn-evaluation) |
| 2 | extern struct / packed struct / union | **IMPL** ‚Äî parse_layout_attrs() wired (attributes.spl) | **CRITICAL** | MEDIUM (codegen wiring) | [‚Üí](#2-deterministic-abilayout-types) |
| 3 | LinkSection / AddrSpace / `@link_section` | **IMPL** ‚Äî link_attrs.spl (src/compiler_core/) | HIGH | LOW (annotation wiring) | [‚Üí](#3-section-placement--address-spaces) |
| 4 | callconv(.naked) / ISR entrypoints | **IMPL** ‚Äî callconv_bridge.spl + FunctionAttr.callconv | HIGH | MEDIUM | [‚Üí](#4-calling-convention--naked-entrypoints) |
| 5 | Volatile pointer + atomics as builtins | **IMPL** ‚Äî volatile_ops.spl (src/app/io/) | **CRITICAL** | LOW‚ÜíMEDIUM | [‚Üí](#5-volatile--atomics-as-explicit-primitives) |
| 6 | C header import / wffi-wrapper infra | **IMPL** ‚Äî wffi_bindgen.spl (src/compiler_core/) | MEDIUM | MEDIUM | [‚Üí](#6-c-header-import--wffi-wrapper-infra) |
| 7 | Built-in cross-compilation (`-target`) | **IMPL** ‚Äî target_presets.spl (8 presets) | HIGH | MEDIUM | [‚Üí](#7-built-in-cross-compilation) |
| 8 | Inline test{} / debug{} blocks | **IMPL** ‚Äî __builtin_test_mode / __builtin_debug_mode in eval.spl | MEDIUM | LOW | [‚Üí](#8-inline-test--debug-blocks) |
| 9 | Error return traces (not stack unwinding) | **IMPL** ‚Äî error_trace.spl (src/std/) | MEDIUM | MEDIUM | [‚Üí](#9-error-return-traces) |
| 10 | Sentinel-terminated types | **RESEARCH** ‚Äî sentinel_types_design_2026-02-18.md | MEDIUM | HIGH | [‚Üí](#10-sentinel-terminated-types) |

**Highest embedded ROI (steal first):**
1. comptime / const fn (generate tables, bounds)
2. extern/packed struct + layout control (MMIO, DMA)
3. Section placement / LinkSection (ISR tables, boot headers)
4. Volatile as explicit primitive (MMIO correctness)
5. Error return traces + errdefer ergonomics

---

## 1. comptime / const fn Evaluation

### 1.1 Current Status ‚Äî SYNTAX_ONLY (verified)

**Syntax:** ‚úÖ Parser accepts both syntaxes (parser.spl:2293, 2157-2163)
```simple
const fn fibonacci(n: i64) -> i64:   # parsed as normal function ‚Äî identical to fn
    if n <= 1: n
    else: fibonacci(n - 1) + fibonacci(n - 2)

comptime val FACTORIAL_5 = factorial(5)  # treated as eager val (comment in parser: "treat like val")
const MAX_SIZE = 64 * 1024               # parsed as const binding
```

**Runtime behavior:** ‚ùå No actual compile-time evaluation. `comptime val` evaluates at **module load time** (runtime), not compile time. `const fn` is called at runtime like any other function. No CT execution engine exists ‚Äî verified by examining `eval.spl` (no comptime-phase handling).

**Evidence:** `test/unit/parser/comptime_spec.spl` shows they work exactly like normal `val`/`fn` ‚Äî evaluated when module loads, not at compile time.

**Key gap:** There is NO mechanism to:
- Actually evaluate `const fn` calls at compile time
- Error or warn when a `comptime` expression cannot be CT-evaluated (e.g., calls a non-const fn, does I/O)
- Use a CT value as an array size or type-level constant

### 1.2 Why It Matters (Bare-Metal)

Zig comptime is what eliminates the C preprocessor. Without CT eval:
- CRC tables, interrupt vector tables, lookup tables must be hand-written or generated by external tooling
- No compile-time bounds checking on array sizes
- No zero-cost "configuration as code" for register maps, pin assignments, protocol frame layouts

Example of what should work but doesn't today:
```simple
const fn crc32_table() -> [u32; 256]:
    var table = [u32; 256]
    for i in 0..256:
        var crc = i as u32
        for _ in 0..8:
            if crc & 1 != 0:
                crc = (crc >> 1) xor 0xEDB88320u32
            else:
                crc = crc >> 1
        table[i] = crc
    table

const CRC32_TABLE = crc32_table()   # SHOULD be ROM; IS runtime today

const BAUD_RATE = 115200
const fn compute_brr(pclk: i64, baud: i64) -> i64:
    (pclk + baud / 2) / baud      # Round-divide; SHOULD be CT

const USART1_BRR = compute_brr(72_000_000, BAUD_RATE)
```

### 1.3 Missing: comptime-cannot-eval Error / Warning

**Proposed:** When a value declared `comptime` or `const` calls a function that:
- Has I/O side effects
- Calls an `extern fn` (FFI)
- Is not itself declared `const fn`
- Contains unbounded recursion or loops

...the compiler should emit an error (strict) or warning (lenient):
```
error: `comptime` expression calls non-const function `load_config` at line 42
  hint: `load_config` reads files at runtime and cannot be evaluated at compile time
  hint: mark with `@runtime_only` to silence if intentional
```

**Grammar:** No change needed ‚Äî `comptime`/`const` already parsed. This is a **semantic analysis pass**.

### 1.4 Safety Profile

| Rule | Rationale |
|------|-----------|
| Restrict to **total, terminating subset** | No unbounded loops, no unbounded recursion; enforce step limit |
| Forbid CT I/O, environment reads, randomness | Determinism; reproducible builds |
| CT code must follow same rules as runtime code | No "sneaking" unsafe patterns into macros |
| `--emit-comptime-log` for audit | Regulated environments need to see what ran at build time |
| `const fn` step limit: configurable (default 1M ops) | Fail-fast on infinite loops |

### 1.5 Implementation Plan

**Phase A ‚Äî Semantic analysis (medium effort):**
1. Add `is_const_fn: bool` flag to function declaration AST node
2. Const-fn checker: walk body, error on:
   - Calls to non-const fns
   - `extern fn` calls
   - I/O operations (detect by SFFI pattern)
3. `comptime val` checker: verify RHS is a call to a `const fn` or a literal expression
4. Emit `WARN: comptime expression will be evaluated at runtime` if CT eval not possible

**Phase B ‚Äî CT evaluation engine (high effort, future):**
1. Simple interpreter subset that runs at compile time (reuse `src/compiler_core/interpreter/eval.spl`)
2. CT values stored in compiler symbol table
3. CT results embedded in generated binary as `.rodata` constants

---

## 2. Deterministic ABI/Layout Types

### 2.1 Current Status ‚Äî SYNTAX_ONLY (verified)

Verification revealed more than the earlier doc stated:
- `@repr(C)`, `@repr("packed")`, `@repr("transparent")`, `@packed`, `@align(N)` ‚Äî **fully parsed** into `LayoutAttr` structures (found in `src/compiler_core/attributes.spl`)
- Parsed AST nodes are stored, but **no codegen enforces actual struct layout** in the runtime
- Regular structs have no guaranteed C-ABI layout at runtime
- Bitfields: grammar designed, not implemented in compiler (confirmed)

### 2.2 Zig Equivalents

| Zig | Purpose | Simple Proposed |
|-----|---------|----------------|
| `extern struct` | C ABI layout, no padding insertion | `@repr(C) struct` |
| `packed struct` | Bit-exact layout, backing integer | `@packed struct` or `bitfield` |
| `extern union` / `packed union` | Layout-controlled union | `unsafe union` (from #7b in missing_features) |

### 2.3 Why It Matters (Bare-Metal)

MMIO peripheral register blocks MUST match the hardware layout exactly:
```simple
# USART peripheral registers ‚Äî must be exactly 32 bytes, C-layout
@repr(C)
@align(4)
struct UsartRegs:
    sr:   u32    # Status register   @ base + 0x00
    dr:   u32    # Data register     @ base + 0x04
    brr:  u32    # Baud rate reg     @ base + 0x08
    cr1:  u32    # Control 1         @ base + 0x0C
    cr2:  u32    # Control 2         @ base + 0x10
    cr3:  u32    # Control 3         @ base + 0x14
    gtpr: u32    # Guard time reg    @ base + 0x18
```

Without `@repr(C)`, the compiler may insert padding or reorder fields.

### 2.4 Packed Structs for Register Bit-Fields

Zig uses `packed struct` with a backing integer type:
```zig
const Cr1 = packed struct(u32) {
    ue:   u1,   // USART enable
    re:   u1,   // Receiver enable
    te:   u1,   // Transmitter enable
    idleie: u1, // Idle interrupt enable
    rxneie: u1, // RXNE interrupt enable
    // ...
    _pad: u21,
};
```

Simple already has a `bitfield` declaration designed (but not implemented):
```simple
# Already designed, needs compiler implementation
bitfield Cr1(u32):
    ue:     1    # USART enable
    re:     1    # Receiver enable
    te:     1    # Transmitter enable
    idleie: 1    # Idle interrupt enable
    rxneie: 1    # RXNE interrupt enable
    _:      21   # Reserved
```

### 2.5 Static Size / Alignment Assertions

Zig: `comptime { std.debug.assert(@sizeOf(UsartRegs) == 28); }`

Simple proposed:
```simple
static_assert(size_of<UsartRegs>() == 28, "USART register layout mismatch")
static_assert(align_of<DmaDescriptor>() >= 4)
```

### 2.6 Safety Profile

| Aspect | Policy |
|--------|--------|
| `@repr(C)` | Required for all FFI/MMIO structs ‚Äî explicitly declarative |
| `@packed` / bitfields | Restrict to HAL/FFI layers; require static size assertions |
| Unsafe unions | `unsafe union` must be private + struct-local (from #7b) |
| No pointer arithmetic on union fields | Explicit accessor fns only |

### 2.7 Implementation Plan

| Task | Effort |
|------|--------|
| `@repr(C)` annotation: codegen emits C-compatible layout | MEDIUM |
| `@packed` annotation: disable padding insertion | MEDIUM |
| `@align(N)` annotation: enforce alignment | LOW |
| `bitfield` declaration: implement parser + codegen | HIGH (24h per 2026-02-05 research) |
| `static_assert(size_of<T>() == N)` | LOW |
| `size_of<T>()` / `align_of<T>()` built-in CT fns | MEDIUM |

---

## 3. Section Placement + Address Spaces

### 3.1 Current Status ‚Äî NOT_IMPL (verified)

‚ùå Zero references to `link_section`, `addr_space`, or `linksection` anywhere in the codebase. The linker SDN format (`doc/spec/layout.sdn`) describes section placement but there's no language-level annotation to tag functions or variables to specific sections.

### 3.2 Zig Equivalents

```zig
// Place in specific linker section
export fn _start() callconv(.Naked) noreturn {
    // reset vector
}

var bss_data: [1024]u8 linksection(".bss") = undefined;
const flash_table: [256]u8 linksection(".rodata") = build_table();

// Address space (for different memory regions)
var mmio_reg: u32 addrspace(.mmio) = undefined;
```

### 3.3 Proposed Simple Syntax

```simple
# Section placement annotation
@link_section(".isr_vector")
val interrupt_vectors: [fn(); 64] = [reset_handler, ...]

@link_section(".fast")    # ITCM / fast RAM
fn critical_isr():
    tick_count += 1

@link_section(".rodata")  # Explicitly in flash
const LOOKUP: [u8; 256] = build_table()

# Address space annotation (for MMIO modeling)
@addr_space("mmio")
val usart1: UsartRegs* = 0x40011000 as UsartRegs*
```

### 3.4 Grammar

```
annotation_arg: '@' IDENT '(' string_literal ')'
# Already fits existing @IDENT(expr) annotation pattern ‚Äî O(1), no new keywords
```

`@link_section("name")` and `@addr_space("name")` slot directly into the existing `@IDENT(...)` annotation production. Zero new keywords needed.

### 3.5 Why It Matters (Bare-Metal)

| Use Case | Annotation |
|----------|-----------|
| ISR vector table at fixed flash address | `@link_section(".isr_vector")` |
| Hot ISR code in ITCM (fast instruction RAM) | `@link_section(".fast")` |
| Boot header at specific flash offset | `@link_section(".boot_header")` |
| DMA descriptors in DMA-accessible SRAM | `@link_section(".dma_buffers")` |
| Const tables in flash | `@link_section(".rodata")` |

### 3.6 Safety Profile

| Rule | Rationale |
|------|-----------|
| Section/addr-space are "sharp knives" | Require explicit annotation; not implicit |
| Only designated HAL/BSP modules may use `@link_section` | Lintable rule |
| Compiler emits section map in build artifact | Auditable: which function is where |
| `@addr_space` requires `unsafe` access to dereference | Prevents accidental raw memory access |

### 3.7 Implementation Plan

| Task | Effort |
|------|--------|
| `@link_section("name")` annotation: store on fn/var decl AST node | LOW |
| Codegen: emit `section` attribute in C/LLVM output | LOW |
| `@addr_space("name")` annotation: type system modeling | MEDIUM |
| Linker script integration: match Simple annotations to SDN sections | MEDIUM |

**Total estimate:** LOW-MEDIUM. The annotation infrastructure already exists. This is mainly wiring through to codegen.

---

## 4. Calling Convention + Naked Entrypoints

### 4.1 Current Status ‚Äî NOT_IMPL (verified)

‚ùå Zero references to `callconv`, `naked`, or calling convention control anywhere in parser.spl, tokens.spl, or eval.spl. Inline assembly stub exists (`src/compiler_core/inline_asm.spl`) but without calling convention integration.

### 4.2 Zig Equivalents

```zig
fn systick() callconv(.Interrupt) void { ... }
fn _start() callconv(.Naked) noreturn { ... }
fn c_func(x: i32) callconv(.C) i32 { return x * 2; }
```

### 4.3 Proposed Simple Syntax

```simple
# Annotation-based calling convention (fits @IDENT pattern)
@callconv("Naked")
fn _start() -> !:
    # No stack frame; raw assembly entry
    asm("bl main")

@callconv("Interrupt")   # ARM-specific: saves/restores FPU state
fn systick_handler():
    tick_count += 1

@callconv("C")           # Ensure C ABI for FFI
fn exported_callback(ctx: u64) -> i32:
    handle(ctx)
```

### 4.4 Why Naked Functions Matter (Bare-Metal)

**Startup code** must run before the stack pointer is valid:
- `_start` / `Reset_Handler` in ARM Cortex-M: initializes `.data`, zeros `.bss`, calls `main`
- Cannot use a stack frame until the stack is initialized
- Current workaround: write startup in SFFI (C/Rust), call Simple from `main`

With `@callconv("Naked")`, Simple could own the entire boot sequence:
```simple
@callconv("Naked")
@link_section(".isr_vector.reset")
fn reset_handler() -> !:
    # Copy .data from flash to SRAM
    asm("bl _init_data")
    # Zero .bss
    asm("bl _zero_bss")
    # Enter main
    asm("bl main")
    loop: pass    # Should never reach here
```

### 4.5 Safety Profile

| Rule | Rationale |
|------|-----------|
| `@callconv("Naked")` restricted to startup/ISR layer | HAL/BSP-only; tiny audited surface |
| Naked functions cannot call non-naked Simple functions directly | Stack may not be ready |
| `@callconv("Interrupt")` validated against target ABI | Cortex-M vs RISC-V vs x86 have different ISR conventions |
| Naked functions must be in designated `unsafe` module | All unsafe surface grouped |

### 4.6 Implementation Plan

| Task | Effort |
|------|--------|
| `@callconv("Name")` annotation: store on fn decl AST | LOW |
| Codegen: emit calling convention attribute in LLVM/C output | MEDIUM |
| Validation: Naked fn body restricted to `asm()` calls | MEDIUM |
| `asm("...")` inline assembly basic support | HIGH |

---

## 5. Volatile + Atomics as Explicit Primitives

### 5.1 Current Status ‚Äî PARTIAL (verified)

- **Volatile annotations:** ‚úÖ **PARSED AND TYPED** ‚Äî `src/compiler_shared/volatile.spl` (80 lines) defines `VolatileAccess`, `VolatileContext`, `VolatileKind` (`Read`/`Write`/`ReadWrite`/`None_`). `@volatile`, `@volatile_read`, `@volatile_write`, `@nonvolatile` annotations are recognized.
- **Runtime enforcement:** ‚ùå `eval.spl` (interpreter) **ignores volatile annotations** ‚Äî no volatile load/store semantics at runtime.
- **Compiler backend:** ‚ö†Ô∏è Partially implemented ‚Äî LLVM backend would need to emit volatile IR nodes; integration incomplete.
- **SFFI builtins:** ‚ùå `rt_volatile_read_u32` etc. do NOT yet exist in `src/app/io/mod.spl` ‚Äî still need adding.
- **Atomics:** ‚úÖ `src/std/atomic.spl` ‚Äî full memory ordering (`Relaxed`, `Acquire`, `Release`, `AcqRel`, `SeqCst`), `fence()`, atomic load/store/fetch_add etc. WORKING.

### 5.2 Zig Approach

Zig models volatility as a type qualifier on pointers:
```zig
const uart_dr: *volatile u8 = @ptrFromInt(0x40011004);
uart_dr.* = 'A';     // guaranteed memory write
const ch = uart_dr.*; // guaranteed memory read
```

Atomics are explicit builtins:
```zig
@atomicStore(u32, &counter, 0, .Monotonic);
const old = @atomicRmw(u32, &counter, .Add, 1, .SeqCst);
```

### 5.3 Proposed Simple Syntax

**Option A ‚Äî Volatile pointer type (cleanest, Zig-inspired):**
```simple
# Volatile pointer type
val uart_dr: volatile ptr<u8> = rawptr(0x40011004)
uart_dr.* = 'A'        # guaranteed write ‚Äî not optimized away
val ch = uart_dr.*     # guaranteed read

# MMIO struct using @repr(C) + volatile fields
@repr(C)
struct GpioPins:
    @volatile moder: u32    # field-level volatile
    @volatile odr:   u32
    @volatile idr:   u32
```

**Option B ‚Äî SFFI volatile builtins (current workaround, improved wrapper):**
```simple
# Already possible via SFFI ‚Äî improve with generic wrappers
fn mmio_read_u32(addr: u64) -> u32:
    rt_volatile_read_u32(addr)

fn mmio_write_u32(addr: u64, val: u32):
    rt_volatile_write_u32(addr, val)

# Usage: explicit but wordy
val status = mmio_read_u32(USART1_BASE + 0x00)
mmio_write_u32(USART1_BASE + 0x04, 'A' as u32)
```

**Recommended:** Option A for language-level cleanliness; Option B as the near-term SFFI path. Add SFFI volatiles in `src/app/io/mod.spl` immediately; pursue Option A as a type system feature.

### 5.4 Volatile vs Atomic ‚Äî The Critical Distinction

JSF++/NASA rule: **volatile is NOT synchronization**.

| Concept | Use For | Not For |
|---------|---------|--------|
| `volatile` | Prevent compiler from eliding MMIO reads/writes | Thread synchronization |
| `atomic` | Memory ordering between CPU cores / ISR+main | Single-threaded MMIO |
| Both together | MMIO shared with another CPU core / DMA | ‚Äî |

Simple's existing atomics (`src/std/atomic.spl`) cover the synchronization case. Volatile covers MMIO. Both are needed and distinct.

### 5.5 Safety Profile

| Rule | Rationale |
|------|-----------|
| `volatile` access requires explicit annotation | Prevents silent volatility loss |
| Volatile pointer dereference in `unsafe` block | Explicit at call site |
| `volatile` ‚â† `atomic` ‚Äî compiler warns if confused | Prevent synchronization bugs |
| All MMIO reads/writes through typed volatile pointer | Prevents misaligned/wrong-width access |

### 5.6 Implementation Plan

**Near-term (SFFI ‚Äî LOW effort):**
- Add `rt_volatile_read_u8/u16/u32/u64` and matching writes to `src/app/io/mod.spl`
- Add `rt_memory_barrier()` SFFI function

**Language-level (MEDIUM effort):**
- `volatile ptr<T>` type: new type modifier in `parse_type()`
- `@volatile` field annotation: stored on struct field AST node
- Codegen: emit `volatile` qualifier in C/LLVM output for all volatile-annotated accesses
- Validation: volatile dereference inside `unsafe` block

---

## 6. C Header Import + WFFI-Wrapper Infra

### 6.1 Current Status ‚Äî PARTIAL (verified)

Simple has MORE than the earlier doc stated, but differently than expected:
- **Two-Tier (Runtime):** `extern fn rt_*` ‚Üí Simple wrapper `fn` ‚Äî ‚úÖ working
- **Three-Tier (External):** C++/Rust FFI ‚Üí `extern fn` ‚Üí Simple API ‚Äî ‚úÖ working
- **WFFI runtime library:** `src/compiler_core/wffi/mod.spl` (72 lines) ‚Äî `wffi_load(path)`, `wffi_get(handle, name)`, `wffi_call_0/1/2/3/4(fptr, args)` ‚Äî dynamically loads `.so`/`.dll` at **runtime** (dlopen/dlsym pattern). This is a RUNTIME dynamic FFI, not a compile-time header importer.
- **`@wffi` annotation:** ‚ùå Does NOT exist ‚Äî no annotation syntax for auto-generating wrappers
- **`simple-bindgen` tool:** ‚ùå Does not exist

**Key distinction vs Zig:** Zig's `@cImport` parses C headers at **compile time** and generates typed bindings. Simple's WFFI does **runtime** dynamic loading with untyped function pointers. Very different approaches.

### 6.2 Zig's `@cImport` Approach

```zig
const c = @cImport({
    @cInclude("string.h");
    @cInclude("my_driver.h");
});

// Automatic: c.strlen, c.my_driver_init, etc.
const len = c.strlen("hello");
```

Zig parses C headers **at compile time** using a built-in C preprocessor/parser. All symbols become available directly.

### 6.3 Proposed Simple WFFI Improvements

#### 6.3.1 Auto-Generate `extern fn` from C Headers

Rather than Zig's fully integrated approach (which requires a C parser in the compiler), Simple can use a **code generation tool**:

```bash
# Tool: simple-bindgen (like Rust's bindgen)
bin/simple bindgen --header vendor/stm32f4.h --output src/hal/stm32f4_ffi.spl

# Generated output:
extern fn HAL_GPIO_WritePin(GPIOx: u64, GPIO_Pin: u16, PinState: i32)
extern fn HAL_UART_Transmit(huart: u64, pData: u64, Size: u16, Timeout: u32) -> i32
# ... (one extern fn per exported C function)
```

#### 6.3.2 SFFI Wrapper Pattern Improvements

Current pattern:
```simple
# Layer 1: extern declaration
extern fn rt_file_read_text(path: text) -> text

# Layer 2: Simple wrapper
fn file_read(path: text) -> text:
    rt_file_read_text(path)
```

Proposed improvement ‚Äî **`@wffi` annotation** that auto-generates the wrapper:
```simple
# Single declaration with @wffi generates both layers
@wffi(prefix: "rt_")
fn file_read(path: text) -> text    # extern + wrapper auto-generated

# Or explicit mapping:
@extern("rt_volatile_read_u32")
fn mmio_read_u32(addr: u64) -> u32
```

#### 6.3.3 Typed MMIO Register Maps

Instead of raw `extern fn` for MMIO, use typed register-map structs:
```simple
# HAL layer: typed, safe MMIO access
@repr(C)
struct UsartHal:
    regs: volatile ptr<UsartRegs>

    fn transmit_byte(me, ch: u8):
        # Wait for TXE (TX empty)
        while (self.regs.sr & (1 << 7)) == 0: pass_do_nothing
        self.regs.dr = ch as u32

    fn read_byte(me) -> Option<u8>:
        if (self.regs.sr & (1 << 5)) != 0:  # RXNE set
            Some((self.regs.dr & 0xFF) as u8)
        else:
            nil

fn usart1() -> UsartHal:
    UsartHal(regs: rawptr(0x40011000))
```

### 6.4 Safety Profile

| Rule | Rationale |
|------|-----------|
| All C imports go through a curated API wrapper | Prevents dragging in enormous surface area |
| Generated `extern fn` declarations reviewed before use | Must be part of safety case |
| MMIO access always through typed register-map structs | Prevents wrong-width / misaligned access |
| No global `@cImport` (Zig style) ‚Äî curated only | Large header imports can bring in unsafe patterns |

### 6.5 Implementation Plan

| Task | Effort |
|------|--------|
| `simple-bindgen` tool: parse C header, emit `extern fn` declarations | HIGH |
| `@wffi(prefix)` annotation: auto-generate extern + wrapper | MEDIUM |
| `@extern("c_name")` annotation: explicit C symbol mapping | LOW |
| Typed MMIO register map patterns: stdlib templates | LOW |

---

## 7. Built-in Cross-Compilation

### 7.1 Current Status ‚Äî PARTIAL (verified)

- `--target=embedded` flag: ‚úÖ Sets immutable defaults, disables GC
- CLI accepts target triples: `src/app/cli/main.spl` documents 10+ triples: `x86_64`, `aarch64`, `riscv64`, `aarch64-macos`, `x86_64-macos`, `i686`, `armv7`, `riscv32`, `wasm32-wasi`, `wasm32`, `wasm64`
- Baremetal modules exist: `src/baremetal/arm/`, `src/baremetal/riscv*/` ‚Äî confirmed
- **Backend routing:** ‚ùå Compiler backend doesn't fully consume the target flag for code generation
- **ARM Thumb2 / RISC-V codegen:** ‚ùå Not confirmed working end-to-end
- **Target triple format:** Standard Rust-style triples listed but not all validated

### 7.2 Zig Approach

```bash
# Zig: cross-compile is first-class
zig build-exe blinky.zig -target thumb-freestanding-eabi -mcpu cortex_m4
```

Zig ships its own copy of LLVM and musl/libc, so cross-compilation requires no external toolchain setup. The `build.zig` file is a programmatic build system in the language itself.

### 7.3 What Simple Needs

#### 7.3.1 Target Triple Specification

```bash
# Proposed CLI
bin/simple build --target=arm-none-eabi --cpu=cortex-m4 --float-abi=hard
bin/simple build --target=riscv32imc-none-elf --no-std
bin/simple build --target=x86_64-linux-gnu   # native
```

SDN build config:
```sdn
build:
    target: arm-none-eabi
    cpu: cortex-m4
    float-abi: hard
    features: [+fp-armv8, +neon]
    linker-script: embedded.ld
    no-std: true
    no-gc: true
```

#### 7.3.2 Embedded Target Preset

Pre-defined target presets reduce per-project boilerplate:
```sdn
target-preset: stm32f411
# Expands to:
#   target: arm-none-eabi
#   cpu: cortex-m4+fp
#   memory:
#     flash: { origin: 0x08000000, size: 512K }
#     sram:  { origin: 0x20000000, size: 128K }
```

#### 7.3.3 Build Reproducibility

Per JSF/NASA: lock build tool versions, emit build provenance.
```sdn
build-provenance:
    compiler: simple 1.x.y
    target: arm-none-eabi
    cpu: cortex-m4
    timestamp: 2026-02-18T10:00:00Z
    git-hash: abc123
```

### 7.4 Safety Profile

| Rule | Rationale |
|------|-----------|
| Lock compiler version in project manifest | Reproducible builds |
| Emit build provenance as part of release artifact | Regulatory audit trail |
| Test ALL supported configurations in CI | Conditional compilation paths must be tested |
| Target triple in manifest, not just CLI | Prevents "works on my machine" |

### 7.5 Implementation Plan

| Task | Effort |
|------|--------|
| Standard target triple format (CPU-OS-ABI) | LOW |
| SDN build config: target + CPU + features | LOW |
| Embedded target presets (STM32, RP2040, RISC-V common targets) | MEDIUM |
| LLVM cross-codegen: ARM Thumb2, RISC-V32 | HIGH |
| Build provenance emission | LOW |

---

## 8. Inline test{} / debug{} Blocks

### 8.1 Current Status

Simple has SSpec (`src/std/spec.spl`) for BDD-style tests in separate `_spec.spl` files. There are NO inline test blocks in production code. There is no `debug{}` block concept.

### 8.2 Zig Approach

```zig
// Tests live INLINE next to the code they test
pub fn add(a: i32, b: i32) i32 {
    return a + b;
}

test "add basic" {
    try testing.expectEqual(add(1, 2), 3);
}

// All tests compiled out in non-test builds (zig test vs zig build)
```

### 8.3 Proposed Simple Syntax

#### 8.3.1 Inline `test{}` Blocks

```simple
fn add(a: i64, b: i64) -> i64:
    a + b

test "add basic":                         # top-level test block
    expect(add(1, 2)).to_equal(3)
    expect(add(-1, 1)).to_equal(0)

test "add overflow":
    val max = 9223372036854775807i64
    expect(add(max, 1)).to_equal(-9223372036854775808i64)   # wraps
```

**Compile-out:** `test {}` blocks are parsed but excluded from non-test builds (`bin/simple build` vs `bin/simple test`). In embedded builds, test blocks are excluded by default (`--no-std` implies `--no-tests`).

**Relation to SSpec:** Inline `test {}` is a lightweight supplement. SSpec remains for integration/BDD tests. Inline tests are for unit tests that live next to the code. The SSpec runner could discover and run both.

#### 8.3.2 `debug{}` Blocks

Compile-time conditional debug sections (like `#ifdef DEBUG` in C):
```simple
fn process_packet(data: [u8]) -> Result<Packet, text>:
    val pkt = parse_header(data)?

    debug:                               # compiled out in release builds
        print "Packet type: {pkt.type}, len: {pkt.len}"
        validate_checksum(pkt)           # expensive check only in debug

    process_body(pkt)
```

**Compile behavior:**
- `bin/simple build` (release): `debug{}` blocks removed entirely
- `bin/simple build --debug`: `debug{}` blocks included
- `bin/simple test`: both `debug{}` and `test{}` active

#### 8.3.3 Grammar

```
top_level_stmt: ...
    | test_block
    | (inside function body) debug_block

test_block: 'test' string_literal ':' INDENT body DEDENT
debug_block: 'debug' ':' INDENT body DEDENT
```

Both `test` and `debug` are new keywords (currently unused). O(1) in the parser at statement level.

**Alternative:** Use annotations to avoid new keywords:
```simple
@test("add basic"):
    expect(add(1, 2)).to_equal(3)

@debug:
    print "debug info"
```

But `@test` and `@debug` look less clean than keywords. For embedded where test isolation is critical, dedicated keywords make the compile-out semantics explicit.

### 8.4 Safety Profile

| Rule | Rationale |
|------|-----------|
| Test blocks excluded from production binaries (enforced, not optional) | Tests must NOT ship in ROM |
| Tests are part of the safety case ‚Äî traceable to requirements | Make test ‚Üî requirement linking explicit |
| `debug{}` blocks excluded in `--profile=safety` | No debug code in certified builds |
| Test blocks follow same no-recursion, bounded-loop rules as production code | Tests must be analyzable |

### 8.5 Implementation Plan

| Task | Effort |
|------|--------|
| `test "name":` block: parser recognizes, stores as TEST_DECL | LOW |
| `debug:` block: parser recognizes, stores as DEBUG_DECL | LOW |
| Build mode flag: `--test` / `--debug` include/exclude TEST_DECL / DEBUG_DECL | LOW |
| SSpec runner: discover and run inline test blocks | MEDIUM |
| Test block isolation: each `test {}` runs in fresh scope | MEDIUM |

**Total: LOW-MEDIUM effort, HIGH embedded ROI** (removes test code from ROM).

---

## 9. Error Return Traces

### 9.1 Current Status ‚Äî PARTIAL (verified, better than expected)

Verification found more infrastructure than previously known:
- **Panic stack traces:** ‚úÖ `src/std/report/runtime/panic.spl` ‚Äî full `StackFrame`, `StackTrace`, `PanicReport` structs with stack capture. `src/std/debug.spl` exports `debug_stack_trace()`. SFFI: `src/ffi/debug.spl` ‚Üí `rt_debug_stack_trace()`.
- **Error-return trace (Zig-style):** ‚ùå NOT implemented ‚Äî no per-`Result`/`Option` propagation trace; no automatic source-location capture when `?` propagates an error
- **Gap:** What exists is panic traces (for unrecoverable errors). Zig's error return trace captures the chain of `try` return sites for recoverable errors. That chain mechanism is missing.
- `errdefer` is planned (see `missing_language_features_2026-02-17.md` #3)

### 9.2 Zig Approach

Zig captures an **error return trace** ‚Äî a compact stack of source locations where an error was returned ‚Äî distinct from stack unwinding:
```zig
// When you return an error, Zig captures the return site
fn parse(data: []const u8) !Config {
    const header = try read_header(data);  // if this fails, captures location
    return Config{ .data = header };
}

// Output on test failure:
// error: FileNotFound
//     /path/to/file.zig:42:17: in parse
//     /path/to/file.zig:15:5: in load_config
//     /path/to/main.zig:8:3: in main
```

This is NOT stack unwinding ‚Äî the trace is stored as a fixed-size array of frame pointers, no heap allocation needed.

### 9.3 Simple Proposed Design (Sketch for the Planned Task)

```simple
# Error trace: compact array of (file, line) pairs
# No heap allocation ‚Äî fixed max depth
const MAX_TRACE_DEPTH = 16

struct ErrorTrace:
    depth: i64
    frames: [(file: text, line: i64); MAX_TRACE_DEPTH]

# Result type with optional trace
type TracedResult<T, E> = Result<T, (E, ErrorTrace)>

# Macro / compiler support: auto-capture return site
fn parse(data: [u8]) -> TracedResult<Config, text>:
    val header = read_header(data)?   # ? captures return site if Err
    Ok(Config(data: header))
```

### 9.4 Safety Profile

| Rule | Rationale |
|------|-----------|
| Fixed-size trace array ‚Äî no heap allocation | Determinism |
| Trace storage configurable per build profile | ROM-constrained embedded may use depth=4 |
| Trace disabled in `--profile=safety` unless explicitly enabled | No overhead without opt-in |
| Error trace ‚â† exception ‚Äî no unwinding, no cleanup | Consistent with no-exceptions rule |

---

## 10. Sentinel-Terminated Types

### 10.1 Current Status

‚ùå Not implemented. Needs deeper research.

### 10.2 Zig Approach

Zig has sentinel termination as part of the type system:
```zig
const cstr: [*:0]const u8 = "hello\x00";   // C string (null-terminated)
const slice: [:0]const u8 = "hello";        // known-length null-terminated slice
const ring: [*:255]u8 = &ring_buf;         // 255-terminated ring buffer
```

The sentinel value is part of the **type**, not a convention. The compiler knows:
- A `[*:0]u8` must have a `0` byte somewhere reachable
- Slicing a `[:0]u8` preserves the sentinel guarantee
- Passing to C functions expecting `const char*` is type-safe

### 10.3 Why It Matters (Bare-Metal)

| Use Case | Sentinel | Benefit |
|----------|----------|---------|
| C string interop | `\0` (null) | Type-safe C FFI |
| UART packet with end-of-message byte | `0xFF` | No buffer overread |
| DMA ring buffer with sentinel | Any byte | Hardware DMA without length tracking |
| Protocol frames with terminators | Framing byte | Off-by-one bugs prevented by construction |

### 10.4 Open Research Questions

This feature requires deeper research before proposing a design:

1. **Type system integration:** Sentinel types need the type to carry a value (`T` with sentinel `S`). This interacts with generics (`[*:S]T` requires `S: const T`). How does this interact with Simple's existing type system?

2. **CT vs runtime sentinel:** Zig's sentinels are compile-time constants. If Simple adds CT eval (feature #1), can sentinel values be CT-evaluated? What if the sentinel is a `const` expression?

3. **Slice vs pointer:** Zig distinguishes `[*:0]u8` (unknown-length, sentinel-terminated) from `[:0]u8` (known-length, also sentinel-terminated). Does Simple need both? The `[:0]u8` form is safer ‚Äî can verify sentinel in O(N) at creation.

4. **Grammar conflict:** `[T; N]` is a fixed-size array. `[:0]T` is a sentinel-terminated slice. The `:` inside `[]` is currently used for dict types (`[key: value]`). Conflict must be analyzed.

5. **Interaction with Option:** A null-terminated C string is arguably `Option<CStr>` ‚Äî the `\0` encodes "no more data" (None). Is sentinel-termination a special case of `Option<T>` encoding, or a separate concept?

6. **Safety:** Sentinel-terminated types can silently overread if the sentinel is missing. The type system guarantees it exists at creation, but not after mutation. What invariants can be maintained?

**Recommendation:** Research sentinel types separately in `doc/research/sentinel_types_2026-02-XX.md` after comptime (feature #1) is designed, since CT sentinel values depend on CT evaluation.

### 10.5 Tentative Proposed Syntax (for research, not final)

```simple
# Null-terminated C string (sentinel value 0 at type level)
type CStr = [:0u8]u8    # slice with known length + null sentinel

# Usage:
val hello: CStr = "hello"    # compiler adds null terminator
val len = hello.len          # 5 (not counting null)

# C interop:
extern fn strlen(s: CStr) -> u64  # safe: knows it's null-terminated
extern fn puts(s: CStr) -> i32
```

---

## Cross-Cutting: JSF++ / NASA Policy Summary

Statuses verified 2026-02-18.

| Zig Feature | Verified Status | JSF++/NASA Compliance | Action |
|------------|----------------|----------------------|--------|
| comptime (CT eval) | SYNTAX_ONLY ‚Äî runtime eval | ‚ö†Ô∏è Total/bounded subset only | Phase A: semantic checker; Phase B: CT eval engine |
| extern/packed struct | SYNTAX_ONLY ‚Äî parsed, not enforced in layout | ‚úÖ Required for MMIO | Wire `@repr(C)`/`@packed` through to codegen |
| `@link_section` | NOT_IMPL | ‚úÖ Required for vector tables | LOW effort annotation wiring |
| callconv Naked | NOT_IMPL | ‚ö†Ô∏è Tiny audited surface only | Annotation-based, ISR/boot only |
| volatile | PARTIAL ‚Äî parsed/typed; runtime ignores; SFFI builtins missing | ‚úÖ Required for MMIO correctness | Add SFFI builtins; wire compiler backend |
| C import / bindgen | PARTIAL ‚Äî runtime WFFI exists; no compile-time bindgen | ‚ö†Ô∏è Curated API only | `simple-bindgen` tool + `@wffi` annotation |
| Cross-compilation | PARTIAL ‚Äî triples documented; backend incomplete | ‚úÖ Required for embedded | Wire backend target selection; add presets |
| Inline test{} | NOT_IMPL | ‚úÖ Required ‚Äî tests must not ship in ROM | LOW effort new keywords |
| Error return trace | PARTIAL ‚Äî panic traces exist; error-prop trace missing | ‚úÖ Fixed-size, no heap | Separate task |
| Sentinel types | NOT_IMPL | ‚ö†Ô∏è Safe if type-system enforced | Research needed first |

---

## Implementation Priority

### Tier 1 ‚Äî Near-Term (High ROI, Low-Medium Effort)

| Feature | Effort | Why Now |
|---------|--------|---------|
| SFFI volatile builtins (rt_volatile_read/write) | LOW | Unblocks MMIO today; SFFI path already exists |
| `@link_section("name")` annotation | LOW | Annotation wiring only; no new keywords |
| `@repr(C)` + `@packed` + `@align(N)` | MEDIUM | Unblocks correct MMIO struct layout |
| `static_assert(size_of<T>() == N)` | LOW | Catch layout bugs immediately |
| Inline `test{}` block (parse + compile-out) | LOW | Clean up test-in-ROM concern |
| `debug{}` block (parse + compile-out in release) | LOW | Clean debug instrumentation |
| CT semantic checker (warn when comptime ‚â† RT) | MEDIUM | Makes existing `comptime` syntax meaningful |

### Tier 2 ‚Äî Medium Term (High Embedded ROI, Medium Effort)

| Feature | Effort | Dependencies |
|---------|--------|-------------|
| `bitfield` declaration (already designed) | HIGH | `@repr(C)` + codegen |
| `@callconv("Naked")` / `@callconv("Interrupt")` | MEDIUM | Basic asm support |
| `@addr_space("mmio")` | MEDIUM | Type system + codegen |
| `simple-bindgen` C header tool | HIGH | None (standalone tool) |
| CT evaluation engine (Phase B) | HIGH | CT semantic checker |
| Target presets (STM32, RP2040) | MEDIUM | Build system |

### Tier 3 ‚Äî Research + Long Term

| Feature | Status |
|---------|--------|
| Error return trace | Separate task ‚Äî planned |
| Sentinel-terminated types | Research needed first |
| Full LLVM cross-codegen (ARM Thumb2, RISC-V) | HIGH effort |
| Inline assembly (`asm("...")`) | HIGH effort |
| `volatile ptr<T>` type (language-level) | After SFFI path validated |

---

## Quick Reference: Bare-Metal Checklist

For a Simple program targeting bare-metal embedded (Cortex-M, RISC-V):

| Capability | Today | After Tier 1 | After Tier 2 |
|-----------|-------|--------------|--------------|
| Volatile MMIO access | SFFI workaround | SFFI builtins ‚úÖ | `volatile ptr<T>` ‚úÖ |
| C-layout structs for registers | ‚ùå | `@repr(C)` ‚úÖ | + `bitfield` ‚úÖ |
| CRC/lookup tables in ROM | Runtime only | CT checker warns | CT eval engine ‚úÖ |
| ISR handler in Simple | SFFI only | `@callconv("Interrupt")` ‚úÖ | + `@link_section` ‚úÖ |
| Boot/startup in Simple | SFFI only | `@callconv("Naked")` ‚úÖ | + naked asm ‚úÖ |
| Tests excluded from ROM | Manual / separate files | `test{}` blocks ‚úÖ | ‚Äî |
| Cross-compile target | `--target=embedded` | Target triples ‚úÖ | + presets ‚úÖ |
| C header FFI | Manual `extern fn` | `simple-bindgen` ‚úÖ | ‚Äî |
| Error traces | None | Planned task | ‚úÖ |
| Sentinel C strings | SFFI | ‚Äî | Research needed |

---

## Implementation Status (2026-02-18)

All 10 Zig embedded features have been implemented or researched:

| # | Feature | Status | File |
|---|---------|--------|------|
| 1 | comptime semantic checker | ‚úÖ IMPL | `src/compiler_core/comptime_checker.spl` |
| 2 | @repr(C)/@packed/@align wiring | ‚úÖ IMPL | `src/compiler_core/attributes.spl` |
| 3 | @link_section/@addr_space | ‚úÖ IMPL | `src/compiler_core/link_attrs.spl` |
| 4 | @callconv extension | ‚úÖ IMPL | `src/compiler_core/callconv_bridge.spl` |
| 5 | volatile SFFI builtins | ‚úÖ IMPL | `src/app/io/volatile_ops.spl` |
| 6 | @wffi bindgen annotation | ‚úÖ IMPL | `src/compiler_core/wffi_bindgen.spl` |
| 7 | cross-compilation presets | ‚úÖ IMPL | `src/compiler_core/target_presets.spl` |
| 8 | @test/@debug blocks | ‚úÖ IMPL | `src/compiler_core/interpreter/eval.spl` |
| 9 | error return traces | ‚úÖ IMPL | `src/std/error_trace.spl` |
| 10 | sentinel types | üìÑ RESEARCH | `doc/research/sentinel_types_design_2026-02-18.md` |

**Tests:** 13 new spec files added across `test/unit/compiler/`, `test/unit/app/`, `test/unit/std/`, and `test/integration/`

**Zero regressions** ‚Äî no existing functionality modified except for additive changes to `eval.spl` (4 new builtin identifiers), `attributes.spl` (callconv extension + layout wiring), and `mod.spl` (volatile imports).
