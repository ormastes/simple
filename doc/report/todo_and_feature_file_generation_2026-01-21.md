# TODO and Feature File Generation

**Date:** 2026-01-21
**Purpose:** Document where TODO and feature files are generated, what files are created, and when they are updated

## Summary Table

| System | Command | Source Data | Generated Files | When Updated |
|--------|---------|-------------|-----------------|--------------|
| **TODO** | `simple todo-scan` | Source code | `doc/todo/todo_db.sdn` | Manual command |
| **TODO** | `simple todo-gen` | `doc/todo/todo_db.sdn` | `doc/TODO.md` | Manual command |
| **Feature** | `simple test` | Test files (`*_spec.spl`) | `doc/feature/feature_db.sdn`<br>`doc/feature/feature.md`<br>`doc/feature/category/*.md` | **Every test run** |

## 1. TODO File Generation

### A. TODO Database: `doc/todo/todo_db.sdn`

#### Generated By
**Command:** `simple todo-scan [options]`

**Source:** `src/rust/driver/src/cli/doc_gen.rs:321-385`

#### When Updated
⚠️ **Manual Only** - You must explicitly run the command

#### How It Works

```bash
# Basic scan - scans entire codebase from current directory
simple todo-scan

# Scan specific directory
simple todo-scan --path src/

# Use custom database path
simple todo-scan --db doc/todos.sdn

# Validate only (don't update database)
simple todo-scan --validate

# Incremental mode (only scan changed files)
simple todo-scan --incremental

# Parallel mode (faster scanning)
simple todo-scan --parallel
```

#### Process Flow

```
Source Code (*.rs, *.spl)
    ↓
TodoParser.scan_directory()
    ↓
Parse TODOs with format validation
    ↓
Load existing doc/todo/todo_db.sdn (if exists)
    ↓
Update database:
  - Add new TODOs (status = "open")
  - Update changed TODOs (preserve status)
  - Mark removed TODOs (valid = false)
    ↓
Save to doc/todo/todo_db.sdn
```

**Code:** `src/rust/driver/src/cli/doc_gen.rs:358-384`

```rust
// Scan and update
match update_todo_db_incremental_parallel(&mut db, &scan_path, incremental, parallel) {
    Ok((added, updated, removed)) => {
        println!("Scan complete:");
        println!("  Added:   {} TODOs", added);
        println!("  Updated: {} TODOs", updated);
        println!("  Removed: {} TODOs", removed);
        println!("  Total:   {} TODOs", db.valid_records().len());

        if !validate_only {
            // Save database (line 369)
            if let Err(e) = save_todo_db(&db_path, &db) {
                eprintln!("error: failed to save database: {}", e);
                return 1;
            }
            println!("Database saved to {}", db_path.display());
        }
    }
}
```

#### Database Format

**File:** `doc/todo/todo_db.sdn`

**Structure:**
```sdn
todos |id, keyword, area, priority, description, file, line, issue, blocked, status, valid|
    1, TODO, runtime, P0, "Implement TCP write", src/runtime/net.rs, 42, 234, , open, true
    2, FIXME, parser, P1, "Fix edge case", src/parser/expr.rs, 156, , 100,101, blocked, true
    3, TODO, stdlib, P2, "Add docs", src/lib/std/core.spl, 89, , , open, true
```

**Columns:**
1. `id` - Unique TODO ID (auto-incremented)
2. `keyword` - TODO or FIXME
3. `area` - Component area (runtime, parser, etc.)
4. `priority` - P0-P3 or critical/high/medium/low
5. `description` - What needs to be done
6. `file` - Source file path
7. `line` - Line number
8. `issue` - Optional issue number
9. `blocked` - Comma-separated blocked issue numbers
10. `status` - open, blocked, in_progress, stale
11. `valid` - true/false (false = removed from source)

### B. TODO Documentation: `doc/TODO.md`

#### Generated By
**Command:** `simple todo-gen [options]`

**Source:** `src/rust/driver/src/cli/doc_gen.rs:388-423`

#### When Updated
⚠️ **Manual Only** - You must explicitly run the command

#### How It Works

```bash
# Basic generation
simple todo-gen

# Use custom database path
simple todo-gen --db doc/todos.sdn

# Custom output directory
simple todo-gen -o docs/
```

#### Process Flow

```
doc/todo/todo_db.sdn
    ↓
Load database
    ↓
Generate markdown:
  - Statistics (total, open, blocked, stale)
  - By Area table
  - By Priority table
  - P0 Critical TODOs section
  - P1 High Priority TODOs section
  - P2 Medium Priority TODOs (if < 50)
  - Blocked TODOs section
  - Stale TODOs section
  - Appendix (legend, areas)
    ↓
Write to doc/TODO.md
```

**Code:** `src/rust/driver/src/todo_db.rs:581-745`

```rust
pub fn generate_todo_docs(db: &TodoDb, output_dir: &Path) -> Result<(), String> {
    let records: Vec<&TodoRecord> = db.valid_records();

    let mut md = String::new();
    md.push_str("# TODO List\n\n");

    // Generate all sections...

    let path = output_dir.join("TODO.md");  // line 740
    fs::create_dir_all(output_dir).map_err(|e| e.to_string())?;
    fs::write(&path, md).map_err(|e| e.to_string())?;  // line 742

    Ok(())
}
```

#### Generated Content

**File:** `doc/TODO.md`

**Sections:**
1. Header with statistics
2. Statistics by Area (table)
3. Statistics by Priority (table)
4. P0 Critical TODOs (detailed list)
5. P1 High Priority TODOs (detailed list)
6. P2 Medium Priority TODOs (summary if > 50)
7. Blocked TODOs
8. Stale TODOs
9. Appendix (legend and area descriptions)

## 2. Feature File Generation

### A. Feature Database: `doc/feature/feature_db.sdn`

#### Generated By
**Command:** `simple test` (automatic, runs after every test)

**Source:** `src/rust/driver/src/cli/test_runner/runner.rs:39`

#### When Updated
✅ **Automatic** - Updates **every time you run tests**

#### How It Works

```bash
# Any test command automatically updates feature database
simple test
simple test test/lib/std/
simple test --unit
simple test --tag network
```

#### Process Flow

```
simple test
    ↓
Discover test files (*_spec.spl)
    ↓
Execute test files
    ↓
Collect results (passed/failed)
    ↓
update_feature_database()  ← Called at line 39
    ↓
Filter _spec.spl files
    ↓
Identify failed specs
    ↓
update_feature_db_from_sspec()
    ↓
For each _spec.spl file:
  - Parse SSpec metadata (#[feature], #[only], #[skip], etc.)
  - Extract feature ID, name, description
  - Determine status:
      * ignored (if #[ignore] present)
      * failed (if test failed)
      * planned (if recovering from ignored/failed)
      * preserved (if complete/in_progress)
    ↓
Save to doc/feature/feature_db.sdn
    ↓
Generate feature docs (feature.md, category/*.md)
```

**Code:** `src/rust/driver/src/cli/test_runner/runner.rs:30-56`

```rust
pub fn run_tests(test_path: &Path, options: &TestOptions, quiet: bool) -> TestRunResult {
    // ... discover and execute tests ...

    let (mut results, mut total_passed, mut total_failed) =
        execute_test_files(&runner, &test_files, &options, quiet);

    // Update feature database (line 39)
    update_feature_database(&test_files, &mut results, &mut total_failed);

    // ... continue with doctests and diagrams ...
}
```

**Code:** `src/rust/driver/src/cli/test_runner/feature_db.rs:10-39`

```rust
pub fn update_feature_database(
    test_files: &[PathBuf],
    results: &mut Vec<TestFileResult>,
    total_failed: &mut usize
) {
    let feature_db_path = PathBuf::from("doc/features/feature_db.sdn");

    // Filter for spec files
    let sspec_files: Vec<PathBuf> = test_files
        .iter()
        .filter(|path| path.file_name()
            .and_then(|n| n.to_str())
            .map(|n| n.ends_with("_spec.spl"))
            .unwrap_or(false))
        .cloned()
        .collect();

    // Identify failed specs
    let failed_specs: Vec<PathBuf> = results
        .iter()
        .filter(|result| result.failed > 0 || result.error.is_some())
        .map(|result| result.path.clone())
        .collect();

    // Update database
    if let Err(e) = crate::feature_db::update_feature_db_from_sspec(
        &feature_db_path,
        &sspec_files,
        &failed_specs
    ) {
        // ... error handling ...
    }
}
```

**Code:** `src/rust/driver/src/feature_db.rs:243-278`

```rust
pub fn update_feature_db_from_sspec(
    db_path: &Path,
    specs: &[PathBuf],
    failed_specs: &[PathBuf]
) -> Result<(), String> {
    let mut db = load_feature_db(db_path).unwrap_or_else(|_| FeatureDb::new());

    // ... parse specs and update records ...

    // Save database (line 274)
    save_feature_db(db_path, &db).map_err(|e| e.to_string())?;

    // Generate docs (line 275-276)
    let docs_dir = Path::new("doc/feature");
    let _ = generate_feature_docs(&db, docs_dir);

    Ok(())
}
```

#### Database Format

**File:** `doc/feature/feature_db.sdn`

**Structure:**
```sdn
features |id, category, name, description, spec, mode_interpreter, mode_jit, mode_smf_cranelift, mode_smf_llvm, platforms, status, valid|
    1, Infrastructure, Lexer, "Tokenizes source code...", doc/spec/lexer_parser.md, supported, supported, supported, supported, , complete, true
    2, Infrastructure, Parser, "Transforms tokens...", doc/spec/lexer_parser.md, supported, supported, supported, supported, , complete, true
    40, Concurrency, Actors, "Actor-based concurrency...", doc/spec/concurrency.md, supported, supported, supported, supported, , planned, true
```

**Columns:**
1. `id` - Unique feature ID (from #[feature] attribute)
2. `category` - Feature category (derived from path or manual)
3. `name` - Feature name
4. `description` - Feature description
5. `spec` - Spec file path
6. `mode_interpreter` - supported/not_supported
7. `mode_jit` - supported/not_supported
8. `mode_smf_cranelift` - supported/not_supported
9. `mode_smf_llvm` - supported/not_supported
10. `platforms` - Platform restrictions (empty = all)
11. `status` - planned, in_progress, complete, failed, ignored
12. `valid` - true/false

### B. Feature Index: `doc/feature/feature.md`

#### Generated By
**Command:** `simple test` (automatic, part of feature database update)

**Source:** `src/rust/driver/src/feature_db.rs:389-432`

#### When Updated
✅ **Automatic** - Updates **every time you run tests**

#### Process Flow

```
update_feature_db_from_sspec() completes
    ↓
generate_feature_docs() called
    ↓
generate_feature_index()
    ↓
Collect category statistics:
  - Total features per category
  - Skipped features
  - Ignored features
  - Failed features
    ↓
Generate markdown table with links to category docs
    ↓
Write to doc/feature/feature.md
```

**Code:** `src/rust/driver/src/feature_db.rs:395-432`

```rust
fn generate_feature_index(output_dir: &Path, records: &[&FeatureRecord], last_id: &str) -> Result<(), String> {
    let mut categories: BTreeMap<String, CategoryCounts> = BTreeMap::new();
    // ... collect category stats ...

    let mut md = String::new();
    md.push_str("# Feature Categories\n\n");
    if !last_id.is_empty() {
        md.push_str(&format!("Last ID: `{}`\n\n", last_id));
    }
    md.push_str("| Category | Features | Skips | Ignores | Fails |\n");
    md.push_str("|----------|----------|-------|---------|-------|\n");

    for (category, counts) in &categories {
        let link = category_link(category);
        md.push_str(&format!(
            "| [{}]({}) | {} | {} | {} | {} |\n",
            category, link, counts.total, counts.skipped, counts.ignored, counts.failed
        ));
    }

    let path = output_dir.join("feature.md");  // line 429
    fs::write(&path, md).map_err(|e| e.to_string())?;  // line 430
    Ok(())
}
```

#### Generated Content

**File:** `doc/feature/feature.md`

**Structure:**
```markdown
# Feature Categories

Last ID: `612`

| Category | Features | Skips | Ignores | Fails |
|----------|----------|-------|---------|-------|
| [Infrastructure](category/Infrastructure.md) | 9 | 0 | 0 | 0 |
| [Types](category/Types.md) | 7 | 0 | 0 | 0 |
| [Language](category/Language.md) | 11 | 0 | 0 | 0 |
...
```

### C. Category Docs: `doc/feature/category/*.md`

#### Generated By
**Command:** `simple test` (automatic, part of feature database update)

**Source:** `src/rust/driver/src/feature_db.rs:434-490`

#### When Updated
✅ **Automatic** - Updates **every time you run tests**

#### Generated Files

```
doc/feature/category/
├── Codegen.md
├── Concurrency.md
├── Control_Flow.md
├── Data_Structures.md
├── Infrastructure.md
├── Language.md
├── Testing_Framework.md
└── Types.md
```

#### Process Flow

```
generate_feature_docs() continues
    ↓
generate_category_docs()
    ↓
Group features by category
    ↓
For each category:
  - Create category markdown file
  - List subcategories (if any)
  - Generate feature table:
      * ID, Name, Description
      * Spec link
      * Run modes (interpreter, jit, cranelift, llvm)
      * Status
    ↓
Write to doc/feature/category/{Category}.md
```

**Code:** `src/rust/driver/src/feature_db.rs:434-490`

```rust
fn generate_category_docs(output_dir: &Path, records: &[&FeatureRecord]) -> Result<(), String> {
    let mut categories: BTreeMap<String, Vec<&FeatureRecord>> = BTreeMap::new();
    for record in records {
        let category = if record.category.is_empty() {
            "Uncategorized".to_string()
        } else {
            record.category.clone()
        };
        categories.entry(category).or_default().push(record);
    }

    for (category, items) in &categories {
        let path = category_doc_path(output_dir, category);  // line 446
        // ... generate markdown ...
        fs::write(&path, md).map_err(|e| e.to_string())?;  // line 488
    }

    Ok(())
}
```

**Path Generation:** `src/rust/driver/src/feature_db.rs:560-568`

```rust
fn category_doc_path(output_dir: &Path, category: &str) -> PathBuf {
    let parts = split_category(category);
    let mut path = output_dir.join("category");
    for part in &parts[..parts.len().saturating_sub(1)] {
        path = path.join(slugify(part));
    }
    let file_name = parts.last().cloned().unwrap_or_else(|| "index".to_string());
    path.join(format!("{}.md", slugify(&file_name)))
}
```

#### Generated Content

**File:** `doc/feature/category/Infrastructure.md` (example)

**Structure:**
```markdown
# Infrastructure

## Features

| ID | Name | Description | Spec | Run Modes | Status |
|----|------|-------------|------|-----------|--------|
| 1 | Lexer | Tokenizes source code... | [lexer_parser.md](../spec/lexer_parser.md) | ✓ ✓ ✓ ✓ | complete |
| 2 | Parser | Transforms tokens... | [lexer_parser.md](../spec/lexer_parser.md) | ✓ ✓ ✓ ✓ | complete |
...
```

## 3. File Generation Timeline

### TODO Files (Manual)

```
Developer writes code with TODOs
    ↓
(Time passes...)
    ↓
Developer runs: simple todo-scan
    ↓
doc/todo/todo_db.sdn updated
    ↓
(Time passes...)
    ↓
Developer runs: simple todo-gen
    ↓
doc/TODO.md generated
```

**Frequency:** On-demand, when developer wants to update TODO tracking

**Files:**
- `doc/todo/todo_db.sdn` - Updated by `simple todo-scan`
- `doc/TODO.md` - Updated by `simple todo-gen`

### Feature Files (Automatic)

```
Developer writes test spec (*_spec.spl)
    ↓
Developer runs: simple test
    ↓
Tests execute
    ↓
AUTOMATIC: update_feature_database() called
    ↓
doc/feature/feature_db.sdn updated
    ↓
AUTOMATIC: generate_feature_docs() called
    ↓
doc/feature/feature.md generated
doc/feature/category/*.md generated
```

**Frequency:** **Every test run** (automatic)

**Files:**
- `doc/feature/feature_db.sdn` - Updated **every test run**
- `doc/feature/feature.md` - Updated **every test run**
- `doc/feature/category/*.md` - Updated **every test run**

## 4. Complete File List

### TODO System Files

| File | Purpose | Generated By | When |
|------|---------|--------------|------|
| `doc/todo/todo_db.sdn` | TODO database (SDN format) | `simple todo-scan` | Manual |
| `doc/TODO.md` | Human-readable TODO documentation | `simple todo-gen` | Manual |

### Feature System Files

| File | Purpose | Generated By | When |
|------|---------|--------------|------|
| `doc/feature/feature_db.sdn` | Feature database (SDN format) | `simple test` | **Every test run** |
| `doc/feature/feature.md` | Feature category index | `simple test` | **Every test run** |
| `doc/feature/category/Codegen.md` | Codegen features | `simple test` | **Every test run** |
| `doc/feature/category/Concurrency.md` | Concurrency features | `simple test` | **Every test run** |
| `doc/feature/category/Control_Flow.md` | Control flow features | `simple test` | **Every test run** |
| `doc/feature/category/Data_Structures.md` | Data structure features | `simple test` | **Every test run** |
| `doc/feature/category/Infrastructure.md` | Infrastructure features | `simple test` | **Every test run** |
| `doc/feature/category/Language.md` | Language features | `simple test` | **Every test run** |
| `doc/feature/category/Testing_Framework.md` | Test framework features | `simple test` | **Every test run** |
| `doc/feature/category/Types.md` | Type system features | `simple test` | **Every test run** |

## 5. Key Differences

| Aspect | TODO Files | Feature Files |
|--------|-----------|---------------|
| **Update trigger** | Manual command | **Automatic on test run** |
| **Commands** | `todo-scan`, `todo-gen` | `test` (implicit) |
| **Source data** | Source code comments | Test spec files |
| **Database file** | `doc/todo/todo_db.sdn` | `doc/feature/feature_db.sdn` |
| **Doc files** | `doc/TODO.md` (1 file) | `doc/feature/feature.md`<br>`doc/feature/category/*.md` (9+ files) |
| **Update frequency** | When you remember | **Every test run** |

## 6. Workflow Examples

### Updating TODO Documentation

```bash
# 1. Write code with TODOs
# src/runtime/net.rs
# TODO: [runtime][P1] Implement TCP write [#234]

# 2. Scan codebase to update database
simple todo-scan

# Output:
# Scanning TODOs from .
# Scan complete:
#   Added:   1 TODOs
#   Updated: 0 TODOs
#   Removed: 0 TODOs
#   Total:   71 TODOs
# Database saved to doc/todo/todo_db.sdn

# 3. Generate human-readable docs
simple todo-gen

# Output:
# Generating TODO docs from doc/todo/todo_db.sdn...
# Generated docs for 71 TODOs
#   -> doc/TODO.md
```

### Feature Documentation (Automatic)

```bash
# 1. Write test spec with feature metadata
# test/lib/std/unit/core/actors_spec.spl

#[feature(40)]
describe "Actors":
    """
    Actor-based concurrency with spawn.
    """
    # ... tests ...

# 2. Run tests - feature database auto-updates
simple test test/lib/std/unit/core/actors_spec.spl

# Output:
# Running tests from test/lib/std/unit/core/actors_spec.spl...
# ✓ actors_spec.spl (5 passed, 0 failed)
#
# Feature database updated:  ← AUTOMATIC
#   - 1 feature updated
#   - doc/feature/feature_db.sdn
#   - doc/feature/feature.md
#   - doc/feature/category/Concurrency.md

# 3. Check generated files
cat doc/feature/feature_db.sdn | grep "40,"
# 40, Concurrency, Actors, "Actor-based...", ..., planned, true

cat doc/feature/category/Concurrency.md
# Shows Actors feature in table
```

## 7. Related Files

### TODO System
- `src/rust/driver/src/todo_parser.rs` - Parses TODOs from source
- `src/rust/driver/src/todo_db.rs` - Database management and doc generation
- `src/rust/driver/src/cli/doc_gen.rs` - CLI commands (todo-scan, todo-gen)

### Feature System
- `src/rust/driver/src/feature_db.rs` - Database management and doc generation
- `src/rust/driver/src/cli/test_runner/feature_db.rs` - Test integration
- `src/rust/driver/src/cli/test_runner/runner.rs` - Automatic update trigger

## See Also

- `doc/report/todo_and_feature_status_update_2026-01-21.md` - Status update mechanisms
- `doc/report/todo_status_generation_2026-01-21.md` - TODO status generation
- `.claude/skills/todo.md` - TODO format specification
