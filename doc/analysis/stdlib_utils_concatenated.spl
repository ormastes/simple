# FILE: src/std/algorithm_utils.spl
# Size: 11381 bytes, Lines: 411

# Algorithm Utilities Module
#
# Sorting algorithms, searching algorithms, and list manipulation utilities.
# All operations work on i64 lists and are pure Simple implementations.
#
# Categories:
# - Helpers: is_sorted, lists_equal, swap
# - Sorting: bubble_sort, selection_sort, insertion_sort, quick_sort, merge_sort
# - Searching: linear_search, binary_search, find_min/max, find_min/max_index
# - Manipulation: reverse_list, take, drop, sum, count_occurrences, etc.
#
# All functions are pure Simple - no external dependencies required.

# ============================================================================
# Exports
# ============================================================================

export is_sorted, lists_equal, swap
export bubble_sort, selection_sort, insertion_sort, quick_sort, merge_sort, merge_sorted
export linear_search, binary_search, find_min, find_max, find_min_index, find_max_index
export reverse_list, take, drop, sum, count_occurrences, find_all_indices
export remove_duplicates, is_prefix, is_suffix, find_sublist

# ============================================================================
# Helper Functions
# ============================================================================

fn is_sorted(list: [i64]) -> bool:
    """Check if list is sorted in ascending order.

    Example:
        is_sorted([1, 2, 3, 4])  # true
        is_sorted([1, 3, 2])     # false
    """
    if list.len() <= 1:
        return true
    for i in 0..(list.len() - 1):
        if list[i] > list[i + 1]:
            return false
    true

fn lists_equal(a: [i64], b: [i64]) -> bool:
    """Check if two lists are equal element-wise.

    Example:
        lists_equal([1, 2, 3], [1, 2, 3])  # true
        lists_equal([1, 2], [1, 2, 3])     # false
    """
    if a.len() != b.len():
        return false
    for i in 0..a.len():
        if a[i] != b[i]:
            return false
    true

fn swap(list: [i64], i: i64, j: i64) -> [i64]:
    """Swap elements at indices i and j. Returns new list.

    Example:
        swap([1, 2, 3], i=0, j=2)  # [3, 2, 1]
    """
    var result = list
    val temp = result[i]
    result[i] = result[j]
    result[j] = temp
    result

# ============================================================================
# Sorting Algorithms
# ============================================================================

fn bubble_sort(list: [i64]) -> [i64]:
    """Bubble sort algorithm. O(n²) time complexity.

    Example:
        bubble_sort([3, 1, 4, 1, 5])  # [1, 1, 3, 4, 5]
    """
    var result = list
    val n = result.len()
    for i in 0..n:
        for j in 0..(n - i - 1):
            if result[j] > result[j + 1]:
                result = swap(result, i=j, j=j + 1)
    result

fn selection_sort(list: [i64]) -> [i64]:
    """Selection sort algorithm. O(n²) time complexity.

    Example:
        selection_sort([64, 25, 12, 22, 11])  # [11, 12, 22, 25, 64]
    """
    var result = list
    val n = result.len()
    for i in 0..n:
        var min_idx = i
        for j in (i + 1)..n:
            if result[j] < result[min_idx]:
                min_idx = j
        if min_idx != i:
            result = swap(result, i=i, j=min_idx)
    result

fn insertion_sort(list: [i64]) -> [i64]:
    """Insertion sort algorithm. O(n²) time complexity, efficient for small lists.

    Example:
        insertion_sort([12, 11, 13, 5, 6])  # [5, 6, 11, 12, 13]
    """
    var result = list
    val n = result.len()
    for i in 1..n:
        val key = result[i]
        var j = i - 1
        while j >= 0 and result[j] > key:
            result[j + 1] = result[j]
            j = j - 1
        result[j + 1] = key
    result

fn quick_sort(list: [i64]) -> [i64]:
    """Quick sort algorithm. O(n log n) average time complexity.

    Example:
        quick_sort([10, 7, 8, 9, 1, 5])  # [1, 5, 7, 8, 9, 10]
    """
    if list.len() <= 1:
        return list
    val pivot = list[list.len() / 2]
    var less: [i64] = []
    var equal: [i64] = []
    var greater: [i64] = []
    for x in list:
        if x < pivot:
            less = less + [x]
        else if x == pivot:
            equal = equal + [x]
        else:
            greater = greater + [x]
    quick_sort(less) + equal + quick_sort(greater)

fn merge_sort(list: [i64]) -> [i64]:
    """Merge sort algorithm. O(n log n) time complexity, stable sort.

    Example:
        merge_sort([38, 27, 43, 3, 9, 82, 10])  # [3, 9, 10, 27, 38, 43, 82]
    """
    if list.len() <= 1:
        return list
    val mid = list.len() / 2
    var left: [i64] = []
    var right: [i64] = []
    for i in 0..mid:
        left = left + [list[i]]
    for i in mid..list.len():
        right = right + [list[i]]
    merge_sorted(left=merge_sort(left), right=merge_sort(right))

fn merge_sorted(left: [i64], right: [i64]) -> [i64]:
    """Merge two sorted lists. Helper for merge_sort.

    Example:
        merge_sorted(left=[1, 3, 5], right=[2, 4, 6])  # [1, 2, 3, 4, 5, 6]
    """
    var result: [i64] = []
    var i = 0
    var j = 0
    while i < left.len() and j < right.len():
        if left[i] <= right[j]:
            result = result + [left[i]]
            i = i + 1
        else:
            result = result + [right[j]]
            j = j + 1
    while i < left.len():
        result = result + [left[i]]
        i = i + 1
    while j < right.len():
        result = result + [right[j]]
        j = j + 1
    result

# ============================================================================
# Search Algorithms
# ============================================================================

fn linear_search(list: [i64], target: i64) -> i64?:
    """Linear search. Returns index of first occurrence or nil.

    Example:
        linear_search([1, 2, 3, 4], target=3)  # 2
        linear_search([1, 2, 3], target=5)     # nil
    """
    for i in 0..list.len():
        if list[i] == target:
            return i
    nil

fn binary_search(list: [i64], target: i64) -> i64?:
    """Binary search on sorted list. Returns index or nil.

    Example:
        binary_search([1, 2, 3, 4, 5], target=3)  # 2
        binary_search([1, 3, 5], target=2)        # nil
    """
    var low = 0
    var high = list.len() - 1
    while low <= high:
        val mid = (low + high) / 2
        if list[mid] == target:
            return mid
        else if list[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    nil

fn find_min(list: [i64]) -> i64?:
    """Find minimum value in list. Returns nil for empty list.

    Example:
        find_min([3, 1, 4, 1, 5])  # 1
        find_min([])               # nil
    """
    if list.len() == 0:
        return nil
    var min_val = list[0]
    for x in list:
        if x < min_val:
            min_val = x
    min_val

fn find_max(list: [i64]) -> i64?:
    """Find maximum value in list. Returns nil for empty list.

    Example:
        find_max([3, 1, 4, 1, 5])  # 5
        find_max([])               # nil
    """
    if list.len() == 0:
        return nil
    var max_val = list[0]
    for x in list:
        if x > max_val:
            max_val = x
    max_val

fn find_min_index(list: [i64]) -> i64?:
    """Find index of minimum value. Returns nil for empty list.

    Example:
        find_min_index([3, 1, 4, 1, 5])  # 1
    """
    if list.len() == 0:
        return nil
    var min_idx = 0
    for i in 1..list.len():
        if list[i] < list[min_idx]:
            min_idx = i
    min_idx

fn find_max_index(list: [i64]) -> i64?:
    """Find index of maximum value. Returns nil for empty list.

    Example:
        find_max_index([3, 1, 4, 1, 5])  # 4
    """
    if list.len() == 0:
        return nil
    var max_idx = 0
    for i in 1..list.len():
        if list[i] > list[max_idx]:
            max_idx = i
    max_idx

# ============================================================================
# List Manipulation
# ============================================================================

fn reverse_list(list: [i64]) -> [i64]:
    """Reverse a list.

    Example:
        reverse_list([1, 2, 3, 4])  # [4, 3, 2, 1]
    """
    var result: [i64] = []
    for i in 0..list.len():
        result = [list[i]] + result
    result

fn take(list: [i64], n: i64) -> [i64]:
    """Take first n elements from list.

    Example:
        take([1, 2, 3, 4, 5], n=3)  # [1, 2, 3]
    """
    var result: [i64] = []
    val count = if n < list.len(): n else: list.len()
    for i in 0..count:
        result = result + [list[i]]
    result

fn drop(list: [i64], n: i64) -> [i64]:
    """Drop first n elements from list.

    Example:
        drop([1, 2, 3, 4, 5], n=2)  # [3, 4, 5]
    """
    if n >= list.len():
        return []
    var result: [i64] = []
    for i in n..list.len():
        result = result + [list[i]]
    result

fn sum(list: [i64]) -> i64:
    """Sum all elements in list.

    Example:
        sum([1, 2, 3, 4, 5])  # 15
    """
    var total = 0
    for x in list:
        total = total + x
    total

fn count_occurrences(list: [i64], target: i64) -> i64:
    """Count occurrences of target in list.

    Example:
        count_occurrences([1, 2, 1, 3, 1], target=1)  # 3
    """
    var match_count = 0
    for x in list:
        if x == target:
            match_count = match_count + 1
    match_count

fn find_all_indices(list: [i64], target: i64) -> [i64]:
    """Find all indices where target appears.

    Example:
        find_all_indices([1, 2, 1, 3, 1], target=1)  # [0, 2, 4]
    """
    var indices: [i64] = []
    for i in 0..list.len():
        if list[i] == target:
            indices = indices + [i]
    indices

fn remove_duplicates(list: [i64]) -> [i64]:
    """Remove duplicate values, preserving first occurrence.

    Example:
        remove_duplicates([1, 2, 1, 3, 2])  # [1, 2, 3]
    """
    var result: [i64] = []
    for x in list:
        var found = false
        for y in result:
            if x == y:
                found = true
        if not found:
            result = result + [x]
    result

fn is_prefix(prefix: [i64], list: [i64]) -> bool:
    """Check if prefix is a prefix of list.

    Example:
        is_prefix([1, 2], [1, 2, 3, 4])  # true
        is_prefix([1, 3], [1, 2, 3])     # false
    """
    if prefix.len() > list.len():
        return false
    for i in 0..prefix.len():
        if prefix[i] != list[i]:
            return false
    true

fn is_suffix(suffix: [i64], list: [i64]) -> bool:
    """Check if suffix is a suffix of list.

    Example:
        is_suffix([3, 4], [1, 2, 3, 4])  # true
        is_suffix([2, 4], [1, 2, 3, 4])  # false
    """
    if suffix.len() > list.len():
        return false
    val offset = list.len() - suffix.len()
    for i in 0..suffix.len():
        if suffix[i] != list[offset + i]:
            return false
    true

fn find_sublist(haystack: [i64], needle: [i64]) -> i64?:
    """Find first occurrence of needle sublist in haystack.

    Example:
        find_sublist([1, 2, 3, 4, 5], [3, 4])  # 2
        find_sublist([1, 2, 3], [4, 5])        # nil
    """
    if needle.len() > haystack.len():
        return nil
    for i in 0..(haystack.len() - needle.len() + 1):
        var found = true
        for j in 0..needle.len():
            if haystack[i + j] != needle[j]:
                found = false
        if found:
            return i
    nil


# FILE: src/std/amqp_utils.spl
# Size: 26972 bytes, Lines: 738

# AMQP (Advanced Message Queuing Protocol) 0-9-1 Utilities
# Provides comprehensive support for AMQP messaging operations

# ============================================================================
# Constants and Protocol Definitions
# ============================================================================

# Frame types
val FRAME_METHOD = 1
val FRAME_HEADER = 2
val FRAME_BODY = 3
val FRAME_HEARTBEAT = 8

# Frame constants
val FRAME_END = 206
val FRAME_MIN_SIZE = 4096

# Protocol version
val PROTOCOL_VERSION_MAJOR = 0
val PROTOCOL_VERSION_MINOR = 9
val PROTOCOL_VERSION_REVISION = 1

# Class IDs
val CLASS_CONNECTION = 10
val CLASS_CHANNEL = 20
val CLASS_EXCHANGE = 40
val CLASS_QUEUE = 50
val CLASS_BASIC = 60

# Connection method IDs
val CONNECTION_START = 10
val CONNECTION_START_OK = 11
val CONNECTION_TUNE = 30
val CONNECTION_TUNE_OK = 31
val CONNECTION_OPEN = 40
val CONNECTION_OPEN_OK = 41
val CONNECTION_CLOSE = 50
val CONNECTION_CLOSE_OK = 51

# Channel method IDs
val CHANNEL_OPEN = 10
val CHANNEL_OPEN_OK = 11
val CHANNEL_CLOSE = 40
val CHANNEL_CLOSE_OK = 41
val CHANNEL_FLOW = 20
val CHANNEL_FLOW_OK = 21

# Exchange method IDs
val EXCHANGE_DECLARE = 10
val EXCHANGE_DECLARE_OK = 11
val EXCHANGE_DELETE = 20
val EXCHANGE_DELETE_OK = 21
val EXCHANGE_BIND = 30
val EXCHANGE_BIND_OK = 31

# Queue method IDs
val QUEUE_DECLARE = 10
val QUEUE_DECLARE_OK = 11
val QUEUE_BIND = 20
val QUEUE_BIND_OK = 21
val QUEUE_PURGE = 30
val QUEUE_PURGE_OK = 31
val QUEUE_DELETE = 40
val QUEUE_DELETE_OK = 41

# Basic method IDs
val BASIC_QOS = 10
val BASIC_QOS_OK = 11
val BASIC_CONSUME = 20
val BASIC_CONSUME_OK = 21
val BASIC_CANCEL = 30
val BASIC_CANCEL_OK = 31
val BASIC_PUBLISH = 40
val BASIC_RETURN = 50
val BASIC_DELIVER = 60
val BASIC_GET = 70
val BASIC_GET_OK = 71
val BASIC_GET_EMPTY = 72
val BASIC_ACK = 80
val BASIC_REJECT = 90
val BASIC_RECOVER_ASYNC = 100
val BASIC_RECOVER = 110
val BASIC_RECOVER_OK = 111
val BASIC_NACK = 120

# Exchange types
val EXCHANGE_TYPE_DIRECT = "direct"
val EXCHANGE_TYPE_FANOUT = "fanout"
val EXCHANGE_TYPE_TOPIC = "topic"
val EXCHANGE_TYPE_HEADERS = "headers"

# Delivery modes
val DELIVERY_MODE_NON_PERSISTENT = 1
val DELIVERY_MODE_PERSISTENT = 2

# ============================================================================
# Frame Structure Functions
# ============================================================================

fn create_frame(frame_type: i64, channel: i64, payload: text) -> (i64, i64, text):
    # Create a frame tuple (type, channel, payload)
    (frame_type, channel, payload)

fn frame_type(frame: (i64, i64, text)) -> i64:
    # Extract frame type from frame tuple
    val type_val = frame.0
    type_val

fn frame_channel(frame: (i64, i64, text)) -> i64:
    # Extract channel from frame tuple
    val channel_val = frame.1
    channel_val

fn frame_payload(frame: (i64, i64, text)) -> text:
    # Extract payload from frame tuple
    val payload_val = frame.2
    payload_val

fn is_method_frame(frame: (i64, i64, text)) -> bool:
    val type_val = frame_type(frame)
    type_val == FRAME_METHOD

fn is_header_frame(frame: (i64, i64, text)) -> bool:
    val type_val = frame_type(frame)
    type_val == FRAME_HEADER

fn is_body_frame(frame: (i64, i64, text)) -> bool:
    val type_val = frame_type(frame)
    type_val == FRAME_BODY

fn is_heartbeat_frame(frame: (i64, i64, text)) -> bool:
    val type_val = frame_type(frame)
    type_val == FRAME_HEARTBEAT

# ============================================================================
# Connection Management
# ============================================================================

fn create_connection_start(version_major: i64, version_minor: i64,
                           server_properties: text, mechanisms: text,
                           locales: text) -> text:
    # Create Connection.Start method frame payload
    val payload = "START:{version_major}.{version_minor}:{server_properties}:{mechanisms}:{locales}"
    payload

fn create_connection_start_ok(client_properties: text, mechanism: text,
                              response: text, locale: text) -> text:
    # Create Connection.Start-Ok method frame payload
    val payload = "START_OK:{client_properties}:{mechanism}:{response}:{locale}"
    payload

fn create_connection_tune(channel_max: i64, frame_max: i64, heartbeat: i64) -> text:
    # Create Connection.Tune method frame payload
    val payload = "TUNE:{channel_max}:{frame_max}:{heartbeat}"
    payload

fn create_connection_tune_ok(channel_max: i64, frame_max: i64, heartbeat: i64) -> text:
    # Create Connection.Tune-Ok method frame payload
    val payload = "TUNE_OK:{channel_max}:{frame_max}:{heartbeat}"
    payload

fn create_connection_open(virtual_host: text, capabilities: text, insist: bool) -> text:
    # Create Connection.Open method frame payload
    val insist_str = if insist: "1" else: "0"
    val payload = "OPEN:{virtual_host}:{capabilities}:{insist_str}"
    payload

fn create_connection_open_ok(known_hosts: text) -> text:
    # Create Connection.Open-Ok method frame payload
    val payload = "OPEN_OK:{known_hosts}"
    payload

fn create_connection_close(reply_code: i64, reply_text: text,
                           class_id: i64, method_id: i64) -> text:
    # Create Connection.Close method frame payload
    val payload = "CLOSE:{reply_code}:{reply_text}:{class_id}:{method_id}"
    payload

fn create_connection_close_ok() -> text:
    # Create Connection.Close-Ok method frame payload
    val payload = "CLOSE_OK"
    payload

# ============================================================================
# Channel Management
# ============================================================================

fn create_channel_open(out_of_band: text) -> text:
    # Create Channel.Open method frame payload
    val payload = "CH_OPEN:{out_of_band}"
    payload

fn create_channel_open_ok(channel_id: text) -> text:
    # Create Channel.Open-Ok method frame payload
    val payload = "CH_OPEN_OK:{channel_id}"
    payload

fn create_channel_flow(active: bool) -> text:
    # Create Channel.Flow method frame payload
    val active_str = if active: "1" else: "0"
    val payload = "CH_FLOW:{active_str}"
    payload

fn create_channel_flow_ok(active: bool) -> text:
    # Create Channel.Flow-Ok method frame payload
    val active_str = if active: "1" else: "0"
    val payload = "CH_FLOW_OK:{active_str}"
    payload

fn create_channel_close(reply_code: i64, reply_text: text,
                        class_id: i64, method_id: i64) -> text:
    # Create Channel.Close method frame payload
    val payload = "CH_CLOSE:{reply_code}:{reply_text}:{class_id}:{method_id}"
    payload

fn create_channel_close_ok() -> text:
    # Create Channel.Close-Ok method frame payload
    val payload = "CH_CLOSE_OK"
    payload

# ============================================================================
# Exchange Operations
# ============================================================================

fn create_exchange_declare(exchange: text, exchange_type: text,
                           passive: bool, durable: bool,
                           auto_delete: bool, internal: bool,
                           nowait: bool, arguments: text) -> text:
    # Create Exchange.Declare method frame payload
    val passive_str = if passive: "1" else: "0"
    val durable_str = if durable: "1" else: "0"
    val auto_delete_str = if auto_delete: "1" else: "0"
    val internal_str = if internal: "1" else: "0"
    val nowait_str = if nowait: "1" else: "0"
    val payload = "EX_DECLARE:{exchange}:{exchange_type}:{passive_str}:{durable_str}:{auto_delete_str}:{internal_str}:{nowait_str}:{arguments}"
    payload

fn create_exchange_declare_ok() -> text:
    # Create Exchange.Declare-Ok method frame payload
    val payload = "EX_DECLARE_OK"
    payload

fn create_exchange_delete(exchange: text, if_unused: bool, nowait: bool) -> text:
    # Create Exchange.Delete method frame payload
    val if_unused_str = if if_unused: "1" else: "0"
    val nowait_str = if nowait: "1" else: "0"
    val payload = "EX_DELETE:{exchange}:{if_unused_str}:{nowait_str}"
    payload

fn create_exchange_delete_ok() -> text:
    # Create Exchange.Delete-Ok method frame payload
    val payload = "EX_DELETE_OK"
    payload

fn create_exchange_bind(destination: text, source: text, routing_key: text,
                        nowait: bool, arguments: text) -> text:
    # Create Exchange.Bind method frame payload
    val nowait_str = if nowait: "1" else: "0"
    val payload = "EX_BIND:{destination}:{source}:{routing_key}:{nowait_str}:{arguments}"
    payload

fn create_exchange_bind_ok() -> text:
    # Create Exchange.Bind-Ok method frame payload
    val payload = "EX_BIND_OK"
    payload

# ============================================================================
# Queue Operations
# ============================================================================

fn create_queue_declare(queue: text, passive: bool, durable: bool,
                        exclusive: bool, auto_delete: bool,
                        nowait: bool, arguments: text) -> text:
    # Create Queue.Declare method frame payload
    val passive_str = if passive: "1" else: "0"
    val durable_str = if durable: "1" else: "0"
    val exclusive_str = if exclusive: "1" else: "0"
    val auto_delete_str = if auto_delete: "1" else: "0"
    val nowait_str = if nowait: "1" else: "0"
    val payload = "Q_DECLARE:{queue}:{passive_str}:{durable_str}:{exclusive_str}:{auto_delete_str}:{nowait_str}:{arguments}"
    payload

fn create_queue_declare_ok(queue: text, message_count: i64, consumer_count: i64) -> text:
    # Create Queue.Declare-Ok method frame payload
    val payload = "Q_DECLARE_OK:{queue}:{message_count}:{consumer_count}"
    payload

fn create_queue_bind(queue: text, exchange: text, routing_key: text,
                     nowait: bool, arguments: text) -> text:
    # Create Queue.Bind method frame payload
    val nowait_str = if nowait: "1" else: "0"
    val payload = "Q_BIND:{queue}:{exchange}:{routing_key}:{nowait_str}:{arguments}"
    payload

fn create_queue_bind_ok() -> text:
    # Create Queue.Bind-Ok method frame payload
    val payload = "Q_BIND_OK"
    payload

fn create_queue_purge(queue: text, nowait: bool) -> text:
    # Create Queue.Purge method frame payload
    val nowait_str = if nowait: "1" else: "0"
    val payload = "Q_PURGE:{queue}:{nowait_str}"
    payload

fn create_queue_purge_ok(message_count: i64) -> text:
    # Create Queue.Purge-Ok method frame payload
    val payload = "Q_PURGE_OK:{message_count}"
    payload

fn create_queue_delete(queue: text, if_unused: bool, if_empty: bool, nowait: bool) -> text:
    # Create Queue.Delete method frame payload
    val if_unused_str = if if_unused: "1" else: "0"
    val if_empty_str = if if_empty: "1" else: "0"
    val nowait_str = if nowait: "1" else: "0"
    val payload = "Q_DELETE:{queue}:{if_unused_str}:{if_empty_str}:{nowait_str}"
    payload

fn create_queue_delete_ok(message_count: i64) -> text:
    # Create Queue.Delete-Ok method frame payload
    val payload = "Q_DELETE_OK:{message_count}"
    payload

# ============================================================================
# Basic Operations - QoS
# ============================================================================

fn create_basic_qos(prefetch_size: i64, prefetch_count: i64, global: bool) -> text:
    # Create Basic.Qos method frame payload
    val global_str = if global: "1" else: "0"
    val payload = "BASIC_QOS:{prefetch_size}:{prefetch_count}:{global_str}"
    payload

fn create_basic_qos_ok() -> text:
    # Create Basic.Qos-Ok method frame payload
    val payload = "BASIC_QOS_OK"
    payload

# ============================================================================
# Basic Operations - Consume
# ============================================================================

fn create_basic_consume(queue: text, consumer_tag: text, no_local: bool,
                        no_ack: bool, exclusive: bool, nowait: bool,
                        arguments: text) -> text:
    # Create Basic.Consume method frame payload
    val no_local_str = if no_local: "1" else: "0"
    val no_ack_str = if no_ack: "1" else: "0"
    val exclusive_str = if exclusive: "1" else: "0"
    val nowait_str = if nowait: "1" else: "0"
    val payload = "BASIC_CONSUME:{queue}:{consumer_tag}:{no_local_str}:{no_ack_str}:{exclusive_str}:{nowait_str}:{arguments}"
    payload

fn create_basic_consume_ok(consumer_tag: text) -> text:
    # Create Basic.Consume-Ok method frame payload
    val payload = "BASIC_CONSUME_OK:{consumer_tag}"
    payload

fn create_basic_cancel(consumer_tag: text, nowait: bool) -> text:
    # Create Basic.Cancel method frame payload
    val nowait_str = if nowait: "1" else: "0"
    val payload = "BASIC_CANCEL:{consumer_tag}:{nowait_str}"
    payload

fn create_basic_cancel_ok(consumer_tag: text) -> text:
    # Create Basic.Cancel-Ok method frame payload
    val payload = "BASIC_CANCEL_OK:{consumer_tag}"
    payload

# ============================================================================
# Basic Operations - Publish and Deliver
# ============================================================================

fn create_basic_publish(exchange: text, routing_key: text,
                        mandatory: bool, immediate: bool) -> text:
    # Create Basic.Publish method frame payload
    val mandatory_str = if mandatory: "1" else: "0"
    val immediate_str = if immediate: "1" else: "0"
    val payload = "BASIC_PUBLISH:{exchange}:{routing_key}:{mandatory_str}:{immediate_str}"
    payload

fn create_basic_return(reply_code: i64, reply_text: text,
                       exchange: text, routing_key: text) -> text:
    # Create Basic.Return method frame payload
    val payload = "BASIC_RETURN:{reply_code}:{reply_text}:{exchange}:{routing_key}"
    payload

fn create_basic_deliver(consumer_tag: text, delivery_tag: i64,
                        redelivered: bool, exchange: text, routing_key: text) -> text:
    # Create Basic.Deliver method frame payload
    val redelivered_str = if redelivered: "1" else: "0"
    val payload = "BASIC_DELIVER:{consumer_tag}:{delivery_tag}:{redelivered_str}:{exchange}:{routing_key}"
    payload

# ============================================================================
# Basic Operations - Get
# ============================================================================

fn create_basic_get(queue: text, no_ack: bool) -> text:
    # Create Basic.Get method frame payload
    val no_ack_str = if no_ack: "1" else: "0"
    val payload = "BASIC_GET:{queue}:{no_ack_str}"
    payload

fn create_basic_get_ok(delivery_tag: i64, redelivered: bool,
                       exchange: text, routing_key: text, message_count: i64) -> text:
    # Create Basic.Get-Ok method frame payload
    val redelivered_str = if redelivered: "1" else: "0"
    val payload = "BASIC_GET_OK:{delivery_tag}:{redelivered_str}:{exchange}:{routing_key}:{message_count}"
    payload

fn create_basic_get_empty(cluster_id: text) -> text:
    # Create Basic.Get-Empty method frame payload
    val payload = "BASIC_GET_EMPTY:{cluster_id}"
    payload

# ============================================================================
# Basic Operations - Ack/Nack/Reject
# ============================================================================

fn create_basic_ack(delivery_tag: i64, multiple: bool) -> text:
    # Create Basic.Ack method frame payload
    val multiple_str = if multiple: "1" else: "0"
    val payload = "BASIC_ACK:{delivery_tag}:{multiple_str}"
    payload

fn create_basic_reject(delivery_tag: i64, requeue: bool) -> text:
    # Create Basic.Reject method frame payload
    val requeue_str = if requeue: "1" else: "0"
    val payload = "BASIC_REJECT:{delivery_tag}:{requeue_str}"
    payload

fn create_basic_nack(delivery_tag: i64, multiple: bool, requeue: bool) -> text:
    # Create Basic.Nack method frame payload
    val multiple_str = if multiple: "1" else: "0"
    val requeue_str = if requeue: "1" else: "0"
    val payload = "BASIC_NACK:{delivery_tag}:{multiple_str}:{requeue_str}"
    payload

fn create_basic_recover(requeue: bool) -> text:
    # Create Basic.Recover method frame payload
    val requeue_str = if requeue: "1" else: "0"
    val payload = "BASIC_RECOVER:{requeue_str}"
    payload

fn create_basic_recover_ok() -> text:
    # Create Basic.Recover-Ok method frame payload
    val payload = "BASIC_RECOVER_OK"
    payload

# ============================================================================
# Message Properties
# ============================================================================

fn create_message_properties(content_type: text, content_encoding: text,
                             headers: text, delivery_mode: i64,
                             priority: i64, correlation_id: text,
                             reply_to: text, expiration: text,
                             message_id: text, timestamp: i64,
                             type_name: text, user_id: text,
                             app_id: text, cluster_id: text) -> text:
    # Create message properties payload
    val payload = "PROPS:{content_type}:{content_encoding}:{headers}:{delivery_mode}:{priority}:{correlation_id}:{reply_to}:{expiration}:{message_id}:{timestamp}:{type_name}:{user_id}:{app_id}:{cluster_id}"
    payload

fn parse_message_property(properties: text, key: text) -> text:
    # Parse a specific property from message properties
    # Simplified parsing - in real implementation would split on colons
    val result = "{key}=value"
    result

fn set_message_property(properties: text, key: text, value: text) -> text:
    # Set a specific property in message properties
    # Simplified implementation
    val updated = "{properties}:{key}={value}"
    updated

# ============================================================================
# Routing and Pattern Matching
# ============================================================================

fn matches_direct_routing(routing_key: text, binding_key: text) -> bool:
    # Check if routing key matches binding key for direct exchange
    routing_key == binding_key

fn matches_fanout_routing(routing_key: text, binding_key: text) -> bool:
    # Fanout exchanges ignore routing keys
    true

fn matches_topic_pattern(routing_key: text, pattern: text) -> bool:
    # Check if routing key matches topic pattern
    # Simplified implementation - real version would handle * and #
    # * matches exactly one word
    # # matches zero or more words
    val has_wildcard = pattern == "#"
    if has_wildcard:
        true
    else:
        routing_key == pattern

fn validate_routing_key(routing_key: text) -> bool:
    # Validate routing key format
    # Must not be empty and follow AMQP naming rules
    val is_empty = routing_key == ""
    not is_empty

fn validate_queue_name(queue_name: text) -> bool:
    # Validate queue name format
    # Can be empty (server-generated) or follow AMQP naming rules
    true

fn validate_exchange_name(exchange_name: text) -> bool:
    # Validate exchange name format
    # Can be empty (default exchange) or follow AMQP naming rules
    true

# ============================================================================
# Frame Encoding and Decoding
# ============================================================================

fn encode_short_string(value: text) -> text:
    # Encode a short string (length prefix + data)
    val len = 0  # Would be actual length in real implementation
    val encoded = "STR:{len}:{value}"
    encoded

fn decode_short_string(data: text) -> text:
    # Decode a short string
    # Simplified - would parse length prefix in real implementation
    val decoded = data
    decoded

fn encode_long_string(value: text) -> text:
    # Encode a long string (length prefix + data)
    val len = 0  # Would be actual length in real implementation
    val encoded = "LSTR:{len}:{value}"
    encoded

fn decode_long_string(data: text) -> text:
    # Decode a long string
    val decoded = data
    decoded

fn encode_field_table(fields: text) -> text:
    # Encode a field table (key-value pairs)
    val encoded = "TABLE:{fields}"
    encoded

fn decode_field_table(data: text) -> text:
    # Decode a field table
    val decoded = data
    decoded

fn encode_frame_header(frame_type: i64, channel: i64, size: i64) -> text:
    # Encode frame header (type, channel, size)
    val header = "HEADER:{frame_type}:{channel}:{size}"
    header

fn decode_frame_header(data: text) -> (i64, i64, i64):
    # Decode frame header
    # Returns (frame_type, channel, size)
    # Simplified implementation
    (1, 0, 0)

# ============================================================================
# Message Building and Parsing
# ============================================================================

fn build_message(properties: text, body: text) -> text:
    # Build a complete message with properties and body
    val message = "MSG:{properties}:BODY:{body}"
    message

fn parse_message_body(message: text) -> text:
    # Extract message body from complete message
    # Simplified implementation
    val body = message
    body

fn parse_message_properties(message: text) -> text:
    # Extract message properties from complete message
    # Simplified implementation
    val props = "props"
    props

fn calculate_message_size(properties: text, body: text) -> i64:
    # Calculate total message size in bytes
    # Simplified - would calculate actual byte length
    val size = 100
    size

fn split_message_body(body: text, max_frame_size: i64) -> text:
    # Split message body into frame-sized chunks
    # Returns comma-separated chunks (simplified)
    val chunks = body
    chunks

# ============================================================================
# Utility Functions
# ============================================================================

fn create_heartbeat_frame() -> (i64, i64, text):
    # Create a heartbeat frame
    create_frame(FRAME_HEARTBEAT, 0, "")

fn is_valid_channel(channel: i64, max_channels: i64) -> bool:
    # Check if channel number is valid
    val is_positive = channel > 0
    val is_in_range = channel <= max_channels
    is_positive and is_in_range

fn calculate_frame_size(payload: text) -> i64:
    # Calculate total frame size (header + payload + end marker)
    # Simplified - would calculate actual byte length
    val size = 100
    size

fn validate_frame_size(size: i64, max_frame_size: i64) -> bool:
    # Check if frame size is within limits
    val is_within_limit = size <= max_frame_size
    val is_above_min = size >= FRAME_MIN_SIZE
    is_within_limit and is_above_min

fn format_method_frame(class_id: i64, method_id: i64, arguments: text) -> text:
    # Format a method frame payload
    val payload = "METHOD:{class_id}:{method_id}:{arguments}"
    payload

fn format_content_header(class_id: i64, body_size: i64, properties: text) -> text:
    # Format a content header frame payload
    val payload = "HEADER:{class_id}:{body_size}:{properties}"
    payload

fn format_content_body(body: text) -> text:
    # Format a content body frame payload
    val payload = "BODY:{body}"
    payload

fn parse_method_frame(payload: text) -> (i64, i64, text):
    # Parse a method frame payload
    # Returns (class_id, method_id, arguments)
    # Simplified implementation
    (0, 0, "")

fn parse_content_header(payload: text) -> (i64, i64, text):
    # Parse a content header frame payload
    # Returns (class_id, body_size, properties)
    # Simplified implementation
    (0, 0, "")

fn parse_content_body(payload: text) -> text:
    # Parse a content body frame payload
    val body = payload
    body

# ============================================================================
# Error Handling
# ============================================================================

fn create_error_reply(code: i64, text: text, class_id: i64, method_id: i64) -> text:
    # Create an error reply payload
    val reply = "ERROR:{code}:{text}:{class_id}:{method_id}"
    reply

fn is_error_code(code: i64) -> bool:
    # Check if code represents an error
    val is_error = code >= 300
    is_error

fn format_error_message(code: i64, text: text) -> text:
    # Format an error message
    val message = "AMQP Error {code}: {text}"
    message

# ============================================================================
# Exchange Type Validation
# ============================================================================

fn is_valid_exchange_type(exchange_type: text) -> bool:
    # Validate exchange type
    val is_direct = exchange_type == EXCHANGE_TYPE_DIRECT
    val is_fanout = exchange_type == EXCHANGE_TYPE_FANOUT
    val is_topic = exchange_type == EXCHANGE_TYPE_TOPIC
    val is_headers = exchange_type == EXCHANGE_TYPE_HEADERS
    is_direct or is_fanout or is_topic or is_headers

fn get_exchange_type_description(exchange_type: text) -> text:
    # Get description of exchange type
    if exchange_type == EXCHANGE_TYPE_DIRECT:
        "Routes messages with exact routing key match"
    else:
        if exchange_type == EXCHANGE_TYPE_FANOUT:
            "Routes messages to all bound queues"
        else:
            if exchange_type == EXCHANGE_TYPE_TOPIC:
                "Routes messages using wildcard pattern matching"
            else:
                if exchange_type == EXCHANGE_TYPE_HEADERS:
                    "Routes messages based on header attributes"
                else:
                    "Unknown exchange type"

# ============================================================================
# Virtual Host Management
# ============================================================================

fn format_virtual_host(vhost: text) -> text:
    # Format virtual host name
    if vhost == "":
        "/"
    else:
        vhost

fn validate_virtual_host(vhost: text) -> bool:
    # Validate virtual host name
    true

# ============================================================================
# Delivery Mode Helpers
# ============================================================================

fn is_persistent_delivery(delivery_mode: i64) -> bool:
    # Check if message delivery mode is persistent
    delivery_mode == DELIVERY_MODE_PERSISTENT

fn is_non_persistent_delivery(delivery_mode: i64) -> bool:
    # Check if message delivery mode is non-persistent
    delivery_mode == DELIVERY_MODE_NON_PERSISTENT

fn get_delivery_mode_description(delivery_mode: i64) -> text:
    # Get description of delivery mode
    if delivery_mode == DELIVERY_MODE_PERSISTENT:
        "Message will be persisted to disk"
    else:
        if delivery_mode == DELIVERY_MODE_NON_PERSISTENT:
            "Message will not be persisted to disk"
        else:
            "Unknown delivery mode"


# FILE: src/std/bitwise_utils.spl
# Size: 11975 bytes, Lines: 490

# Bitwise Operation Utilities
#
# Helper functions for bitwise operations and bit manipulation.
# Pure Simple implementation - no external dependencies.
#
# Assumes i64 values (64-bit signed integers).
# All operations preserve signed integer semantics.
#
# Functions:
# - Bit testing: test_bit, set_bit, clear_bit, toggle_bit
# - Bit counting: count_ones, count_zeros, leading_zeros, trailing_zeros
# - Bit manipulation: reverse_bits, rotate_left, rotate_right
# - Masks and patterns: create_mask, extract_bits, insert_bits
# - Bitwise predicates: is_power_of_two, is_bit_set
# - Bitwise utilities: lowest_set_bit, highest_set_bit

# ============================================================================
# Bit Testing
# ============================================================================

fn test_bit(n: i64, bit: i64) -> bool:
    """Test if bit at position is set.

    Position 0 is LSB (least significant bit).

    Example:
        test_bit(0b1010, 1)  # true (2nd bit is 1)
        test_bit(0b1010, 0)  # false (1st bit is 0)
    """
    if bit < 0 or bit >= 64:
        return false
    ((n >> bit) & 1) == 1

fn is_bit_set(n: i64, bit: i64) -> bool:
    """Check if bit at position is set (alias for test_bit).

    Example:
        is_bit_set(0b1010, 3)  # true
    """
    test_bit(n, bit)

# ============================================================================
# Bit Manipulation
# ============================================================================

fn set_bit(n: i64, bit: i64) -> i64:
    """Set bit at position to 1.

    Example:
        set_bit(0b1000, 0)  # 0b1001
        set_bit(0b1010, 2)  # 0b1110
    """
    if bit < 0 or bit >= 64:
        return n
    n | (1 << bit)

fn clear_bit(n: i64, bit: i64) -> i64:
    """Clear bit at position (set to 0).

    Example:
        clear_bit(0b1010, 1)  # 0b1000
        clear_bit(0b1111, 2)  # 0b1011
    """
    if bit < 0 or bit >= 64:
        return n
    n & ~(1 << bit)

fn toggle_bit(n: i64, bit: i64) -> i64:
    """Toggle bit at position (flip 0<->1).

    Example:
        toggle_bit(0b1010, 0)  # 0b1011
        toggle_bit(0b1010, 1)  # 0b1000
    """
    if bit < 0 or bit >= 64:
        return n
    n ^ (1 << bit)

# ============================================================================
# Bit Counting
# ============================================================================

fn count_ones(n: i64) -> i64:
    """Count number of 1 bits (population count).

    Uses Brian Kernighan's algorithm.

    Example:
        count_ones(0b1010)  # 2
        count_ones(0b1111)  # 4
    """
    var count = 0
    var value = n

    # Handle negative numbers by treating as unsigned
    if value < 0:
        # For negative numbers, we need to count in unsigned representation
        # Convert to positive by adding 2^64 (conceptually)
        value = value & 0x7FFFFFFFFFFFFFFF  # Clear sign bit
        count = count + 1  # Sign bit was 1

    while value != 0:
        value = value & (value - 1)
        count = count + 1

    count

fn count_zeros(n: i64) -> i64:
    """Count number of 0 bits.

    Example:
        count_zeros(0b1010)  # 62 (in 64-bit)
    """
    64 - count_ones(n)

fn leading_zeros(n: i64) -> i64:
    """Count leading zero bits from MSB.

    Example:
        leading_zeros(0b0001)  # 60 (for 64-bit)
        leading_zeros(0b1000)  # 60
    """
    if n == 0:
        return 64

    var count = 0
    var value = n

    # Handle negative numbers
    if value < 0:
        return 0

    # Find highest set bit
    var bit = 63
    while bit >= 0:
        if (value >> bit) & 1 == 1:
            return 63 - bit
        bit = bit - 1

    64

fn trailing_zeros(n: i64) -> i64:
    """Count trailing zero bits from LSB.

    Example:
        trailing_zeros(0b1000)  # 3
        trailing_zeros(0b1100)  # 2
    """
    if n == 0:
        return 64

    var count = 0
    var value = n

    while (value & 1) == 0:
        count = count + 1
        value = value >> 1

    count

# ============================================================================
# Bit Pattern Operations
# ============================================================================

fn reverse_bits(n: i64) -> i64:
    """Reverse bit order.

    Example:
        reverse_bits(0b1010)  # 0b0101000...
    """
    var result = 0
    var value = n
    var i = 0

    while i < 64:
        result = (result << 1) | (value & 1)
        value = value >> 1
        i = i + 1

    result

fn rotate_left(n: i64, shift: i64) -> i64:
    """Rotate bits left (circular shift).

    Example:
        rotate_left(0b11000, 2)  # 0b00011...
    """
    val s = shift % 64
    if s == 0:
        return n
    (n << s) | ((n >> (64 - s)) & ((1 << s) - 1))

fn rotate_right(n: i64, shift: i64) -> i64:
    """Rotate bits right (circular shift).

    Example:
        rotate_right(0b00011, 2)  # 0b11000...
    """
    val s = shift % 64
    if s == 0:
        return n
    ((n >> s) | (n << (64 - s))) & 0x7FFFFFFFFFFFFFFF

# ============================================================================
# Bit Masks
# ============================================================================

fn create_mask(width: i64, position: i64) -> i64:
    """Create bit mask of given width at position.

    Example:
        create_mask(3, 2)  # 0b11100 (3 bits starting at position 2)
    """
    if width <= 0 or width > 64 or position < 0 or position >= 64:
        return 0

    var mask = 0
    var i = 0
    while i < width and (position + i) < 64:
        mask = mask | (1 << (position + i))
        i = i + 1

    mask

fn extract_bits(n: i64, start: i64, width: i64) -> i64:
    """Extract bits from position for width.

    Example:
        extract_bits(0b11010110, 2, 3)  # 0b101
    """
    if width <= 0 or start < 0 or start >= 64:
        return 0

    val mask = create_mask(width, 0)
    (n >> start) & mask

fn insert_bits(target: i64, value: i64, start: i64, width: i64) -> i64:
    """Insert bits into target at position.

    Example:
        insert_bits(0b11110000, 0b101, 2, 3)  # 0b11110100
    """
    if width <= 0 or start < 0 or start >= 64:
        return target

    val mask = create_mask(width, start)
    val cleared = target & ~mask
    val shifted = (value << start) & mask
    cleared | shifted

# ============================================================================
# Bitwise Predicates
# ============================================================================

fn is_power_of_two_bits(n: i64) -> bool:
    """Check if number is power of 2 using bitwise operation.

    Example:
        is_power_of_two_bits(8)  # true
        is_power_of_two_bits(7)  # false
    """
    n > 0 and (n & (n - 1)) == 0

fn has_single_bit(n: i64) -> bool:
    """Check if number has exactly one bit set.

    Example:
        has_single_bit(8)  # true
        has_single_bit(9)  # false
    """
    count_ones(n) == 1

# ============================================================================
# Bit Position Finding
# ============================================================================

fn lowest_set_bit(n: i64) -> i64:
    """Find position of lowest set bit.

    Returns -1 if no bits are set.

    Example:
        lowest_set_bit(0b1010)  # 1
        lowest_set_bit(0b1000)  # 3
    """
    if n == 0:
        return -1

    var position = 0
    var value = n

    while (value & 1) == 0:
        value = value >> 1
        position = position + 1

    position

fn highest_set_bit(n: i64) -> i64:
    """Find position of highest set bit.

    Returns -1 if no bits are set.

    Example:
        highest_set_bit(0b1010)  # 3
        highest_set_bit(0b0001)  # 0
    """
    if n == 0:
        return -1

    if n < 0:
        return 63

    var position = 0
    var value = n

    while value > 0:
        value = value >> 1
        position = position + 1

    position - 1

# ============================================================================
# Bit Parity
# ============================================================================

fn parity(n: i64) -> i64:
    """Calculate parity (XOR of all bits).

    Returns 0 for even parity, 1 for odd parity.

    Example:
        parity(0b1010)  # 0 (even: 2 bits set)
        parity(0b1011)  # 1 (odd: 3 bits set)
    """
    count_ones(n) % 2

fn has_even_parity(n: i64) -> bool:
    """Check if number has even parity.

    Example:
        has_even_parity(0b1010)  # true
        has_even_parity(0b1011)  # false
    """
    parity(n) == 0

fn has_odd_parity(n: i64) -> bool:
    """Check if number has odd parity.

    Example:
        has_odd_parity(0b111)  # true
    """
    parity(n) == 1

# ============================================================================
# Bitwise Utilities
# ============================================================================

fn isolate_lowest_set_bit(n: i64) -> i64:
    """Isolate the lowest set bit, clear all others.

    Example:
        isolate_lowest_set_bit(0b1010)  # 0b0010
        isolate_lowest_set_bit(0b1100)  # 0b0100
    """
    n & (-n)

fn clear_lowest_set_bit(n: i64) -> i64:
    """Clear the lowest set bit.

    Example:
        clear_lowest_set_bit(0b1010)  # 0b1000
        clear_lowest_set_bit(0b1111)  # 0b1110
    """
    n & (n - 1)

fn is_subset_bits(subset: i64, set: i64) -> bool:
    """Check if all bits in subset are also set in set.

    Example:
        is_subset_bits(0b0101, 0b1111)  # true
        is_subset_bits(0b1000, 0b0111)  # false
    """
    (subset & set) == subset

fn next_power_of_two(n: i64) -> i64:
    """Find next power of 2 greater than or equal to n.

    Example:
        next_power_of_two(5)  # 8
        next_power_of_two(8)  # 8
    """
    if n <= 0:
        return 1

    if is_power_of_two_bits(n):
        return n

    var power = 1
    while power < n:
        power = power << 1

    power

fn prev_power_of_two(n: i64) -> i64:
    """Find previous power of 2 less than or equal to n.

    Example:
        prev_power_of_two(9)  # 8
        prev_power_of_two(8)  # 8
    """
    if n <= 0:
        return 0

    if is_power_of_two_bits(n):
        return n

    var power = 1
    while (power << 1) <= n:
        power = power << 1

    power

# ============================================================================
# Byte Operations
# ============================================================================

fn get_byte(n: i64, byte_index: i64) -> i64:
    """Extract byte at index (0 = LSB).

    Example:
        get_byte(0x12345678, 1)  # 0x56
    """
    if byte_index < 0 or byte_index >= 8:
        return 0
    (n >> (byte_index * 8)) & 0xFF

fn set_byte(n: i64, byte_index: i64, value: i64) -> i64:
    """Set byte at index.

    Example:
        set_byte(0x12345678, 1, 0xFF)  # 0x1234FF78
    """
    if byte_index < 0 or byte_index >= 8:
        return n

    val shift = byte_index * 8
    val mask = 0xFF << shift
    val cleared = n & ~mask
    val byte_val = (value & 0xFF) << shift

    cleared | byte_val

fn swap_bytes(n: i64) -> i64:
    """Swap byte order (endianness conversion).

    Example:
        swap_bytes(0x12345678)  # 0x78563412 (partial, 64-bit)
    """
    var result = 0
    var i = 0

    while i < 8:
        val byte = get_byte(n, i)
        result = result | (byte << ((7 - i) * 8))
        i = i + 1

    result

# ============================================================================
# Bit String Conversion
# ============================================================================

fn to_bit_string(n: i64, width: i64) -> text:
    """Convert number to binary string representation.

    Example:
        to_bit_string(10, 8)  # "00001010"
        to_bit_string(5, 4)   # "0101"
    """
    var result = ""
    var i = width - 1

    while i >= 0:
        if test_bit(n, i):
            result = result + "1"
        else:
            result = result + "0"
        i = i - 1

    result


# FILE: src/std/collection_utils.spl
# Size: 10934 bytes, Lines: 465

# Collection Utilities
#
# Additional collection helper functions for arrays and lists.
# Complements array.spl and list_utils.spl with advanced operations.
# Pure Simple implementation - no external dependencies.
#
# Functions:
# - partition: Split array by predicate
# - group_consecutive: Group consecutive equal elements
# - intersperse: Insert element between all elements
# - transpose: Transpose 2D array
# - cartesian_product: Cartesian product of two arrays
# - sliding_window: Create sliding windows
# - frequencies: Count element frequencies
# - mode: Find most common element
# - median: Find median value
# - remove_duplicates: Remove duplicate elements (preserve order)
# - intersect: Find common elements
# - difference: Find elements in first but not second
# - union: Combine unique elements from both arrays

# ============================================================================
# Array Partitioning
# ============================================================================

fn partition(arr, predicate):
    """Split array into two: [matches, non-matches].

    Returns tuple of two arrays.

    Example:
        partition([1,2,3,4,5], \x: x % 2 == 0)
        # ([2, 4], [1, 3, 5])
    """
    var matches = []
    var non_matches = []

    for item in arr:
        if predicate(item):
            matches.push(item)
        else:
            non_matches.push(item)

    (matches, non_matches)

fn group_consecutive(arr):
    """Group consecutive equal elements.

    Example:
        group_consecutive([1,1,2,2,2,3,1])
        # [[1,1], [2,2,2], [3], [1]]
    """
    if arr.len() == 0:
        return []

    var result = []
    var current_group = [arr[0]]

    var i = 1
    while i < arr.len():
        if arr[i] == arr[i-1]:
            current_group.push(arr[i])
        else:
            result.push(current_group)
            current_group = [arr[i]]
        i = i + 1

    result.push(current_group)
    result

# ============================================================================
# Array Transformation
# ============================================================================

fn intersperse(arr, separator):
    """Insert separator between all elements.

    Example:
        intersperse([1,2,3], 0)  # [1,0,2,0,3]
    """
    if arr.len() <= 1:
        return arr

    var result = [arr[0]]
    var i = 1
    while i < arr.len():
        result.push(separator)
        result.push(arr[i])
        i = i + 1

    result

fn transpose(matrix):
    """Transpose a 2D array (matrix).

    Example:
        transpose([[1,2,3], [4,5,6]])
        # [[1,4], [2,5], [3,6]]
    """
    if matrix.len() == 0:
        return []

    val rows = matrix.len()
    val cols = matrix[0].len()

    var result = []
    var col = 0
    while col < cols:
        var new_row = []
        var row = 0
        while row < rows:
            new_row.push(matrix[row][col])
            row = row + 1
        result.push(new_row)
        col = col + 1

    result

fn cartesian_product(arr1, arr2):
    """Cartesian product of two arrays.

    Returns array of tuples representing all pairs.

    Example:
        cartesian_product([1,2], [3,4])
        # [(1,3), (1,4), (2,3), (2,4)]
    """
    var result = []

    for a in arr1:
        for b in arr2:
            result.push((a, b))

    result

fn sliding_window(arr, size):
    """Create sliding windows of given size.

    Example:
        sliding_window([1,2,3,4,5], 3)
        # [[1,2,3], [2,3,4], [3,4,5]]
    """
    if size > arr.len() or size <= 0:
        return []

    var result = []
    var i = 0
    while i <= arr.len() - size:
        var window = []
        var j = 0
        while j < size:
            window.push(arr[i + j])
            j = j + 1
        result.push(window)
        i = i + 1

    result

# ============================================================================
# Statistical Functions
# ============================================================================

fn frequencies(arr):
    """Count element frequencies.

    Returns dictionary-like representation as array of (element, count) tuples.

    Example:
        frequencies([1,2,2,3,3,3])
        # [(1,1), (2,2), (3,3)]
    """
    var counts = []

    for item in arr:
        # Find if item already counted
        var found = false
        var idx = 0
        while idx < counts.len():
            val (elem, count) = counts[idx]
            if elem == item:
                counts[idx] = (elem, count + 1)
                found = true
                break
            idx = idx + 1

        if not found:
            counts.push((item, 1))

    counts

fn mode(arr):
    """Find most common element.

    Returns the element that appears most frequently.
    If multiple elements tie, returns the first one encountered.

    Returns nil for empty array.
    """
    if arr.len() == 0:
        return nil

    val freqs = frequencies(arr)

    var max_count = 0
    var mode_elem = nil

    for (elem, count) in freqs:
        if count > max_count:
            max_count = count
            mode_elem = elem

    mode_elem

fn median(arr):
    """Find median value of sorted numeric array.

    Array must be sorted for correct result.
    For even-length arrays, returns lower middle element.

    Returns nil for empty array.
    """
    if arr.len() == 0:
        return nil

    val mid = arr.len() / 2

    if arr.len() % 2 == 1:
        # Odd length: return middle element
        arr[mid]
    else:
        # Even length: return lower middle
        # (Ideally would average the two middle elements,
        # but that requires float conversion)
        arr[mid - 1]

# ============================================================================
# Set Operations
# ============================================================================

fn remove_duplicates(arr):
    """Remove duplicate elements, preserving first occurrence order.

    Example:
        remove_duplicates([1,2,2,3,1,4])  # [1,2,3,4]
    """
    var result = []
    var seen = []

    for item in arr:
        var found = false
        for s in seen:
            if s == item:
                found = true
                break

        if not found:
            result.push(item)
            seen.push(item)

    result

fn intersect(arr1, arr2):
    """Find common elements (set intersection).

    Returns elements that appear in both arrays.
    Duplicates are removed.

    Example:
        intersect([1,2,3], [2,3,4])  # [2,3]
    """
    var result = []
    var seen = []

    for item in arr1:
        # Check if in arr2
        var in_arr2 = false
        for item2 in arr2:
            if item == item2:
                in_arr2 = true
                break

        # Check if not already added
        var already_added = false
        for s in seen:
            if s == item:
                already_added = true
                break

        if in_arr2 and not already_added:
            result.push(item)
            seen.push(item)

    result

fn difference(arr1, arr2):
    """Find elements in arr1 but not in arr2 (set difference).

    Example:
        difference([1,2,3,4], [2,4])  # [1,3]
    """
    var result = []

    for item in arr1:
        var in_arr2 = false
        for item2 in arr2:
            if item == item2:
                in_arr2 = true
                break

        if not in_arr2:
            var already_added = false
            for r in result:
                if r == item:
                    already_added = true
                    break

            if not already_added:
                result.push(item)

    result

fn union(arr1, arr2):
    """Combine unique elements from both arrays (set union).

    Example:
        union([1,2,3], [3,4,5])  # [1,2,3,4,5]
    """
    var result = []
    var seen = []

    # Add all from arr1
    for item in arr1:
        var already_added = false
        for s in seen:
            if s == item:
                already_added = true
                break

        if not already_added:
            result.push(item)
            seen.push(item)

    # Add new elements from arr2
    for item in arr2:
        var already_added = false
        for s in seen:
            if s == item:
                already_added = true
                break

        if not already_added:
            result.push(item)
            seen.push(item)

    result

fn is_subset(arr1, arr2):
    """Check if arr1 is a subset of arr2.

    Returns true if all elements of arr1 are in arr2.
    """
    for item in arr1:
        var found = false
        for item2 in arr2:
            if item == item2:
                found = true
                break

        if not found:
            return false

    true

# ============================================================================
# Array Comparison
# ============================================================================

fn array_equals(arr1, arr2):
    """Check if two arrays are equal (same elements in same order).
    """
    if arr1.len() != arr2.len():
        return false

    var i = 0
    while i < arr1.len():
        if arr1[i] != arr2[i]:
            return false
        i = i + 1

    true

fn starts_with_subarray(arr, prefix):
    """Check if array starts with given prefix array.

    Example:
        starts_with_subarray([1,2,3,4], [1,2])  # true
    """
    if prefix.len() > arr.len():
        return false

    var i = 0
    while i < prefix.len():
        if arr[i] != prefix[i]:
            return false
        i = i + 1

    true

fn ends_with_subarray(arr, suffix):
    """Check if array ends with given suffix array.

    Example:
        ends_with_subarray([1,2,3,4], [3,4])  # true
    """
    if suffix.len() > arr.len():
        return false

    val offset = arr.len() - suffix.len()
    var i = 0
    while i < suffix.len():
        if arr[offset + i] != suffix[i]:
            return false
        i = i + 1

    true

# ============================================================================
# Array Search
# ============================================================================

fn index_of_subarray(arr, subarray):
    """Find index of first occurrence of subarray.

    Returns -1 if not found.

    Example:
        index_of_subarray([1,2,3,2,3], [2,3])  # 1
    """
    if subarray.len() == 0 or subarray.len() > arr.len():
        return -1

    var i = 0
    while i <= arr.len() - subarray.len():
        var match = true
        var j = 0
        while j < subarray.len():
            if arr[i + j] != subarray[j]:
                match = false
                break
            j = j + 1

        if match:
            return i

        i = i + 1

    -1

fn contains_subarray(arr, subarray):
    """Check if array contains subarray.

    Example:
        contains_subarray([1,2,3,4], [2,3])  # true
    """
    index_of_subarray(arr, subarray) >= 0


# FILE: src/std/combinatorics_utils.spl
# Size: 14853 bytes, Lines: 682

# Combinatorics Utilities
#
# Helper functions for combinatorial mathematics and operations.
# Pure Simple implementation - no external dependencies.
#
# Provides permutations, combinations, factorials, and other
# combinatorial functions.
#
# Functions:
# - Factorials: factorial, factorial_tail, double_factorial
# - Binomial: binomial_coefficient, pascal_triangle
# - Permutations: permutations_count, permutations, next_permutation
# - Combinations: combinations_count, combinations
# - Partitions: integer_partitions, set_partitions
# - Sequences: fibonacci, catalan, stirling

# ============================================================================
# Factorial Functions
# ============================================================================

fn factorial(n: i64) -> i64:
    """Calculate factorial n!

    Returns 1 for n <= 0.
    Warning: Can overflow for large n.

    Example:
        factorial(5)  # 120
        factorial(0)  # 1
    """
    if n <= 0:
        return 1

    var result = 1
    var i = 1

    while i <= n:
        result = result * i
        i = i + 1

    result

fn factorial_tail(n: i64, acc: i64) -> i64:
    """Tail-recursive factorial.

    Example:
        factorial_tail(5, 1)  # 120
    """
    if n <= 0:
        return acc
    factorial_tail(n - 1, acc * n)

fn double_factorial(n: i64) -> i64:
    """Calculate double factorial n!!

    n!! = n * (n-2) * (n-4) * ... * 1 or 2

    Example:
        double_factorial(6)  # 48 (6*4*2)
        double_factorial(7)  # 105 (7*5*3*1)
    """
    if n <= 0:
        return 1

    var result = 1
    var i = n

    while i > 0:
        result = result * i
        i = i - 2

    result

fn falling_factorial(n: i64, k: i64) -> i64:
    """Calculate falling factorial (Pochhammer symbol).

    (n)_k = n * (n-1) * ... * (n-k+1)

    Example:
        falling_factorial(5, 3)  # 60 (5*4*3)
    """
    if k <= 0:
        return 1

    var result = 1
    var i = 0

    while i < k:
        result = result * (n - i)
        i = i + 1

    result

fn rising_factorial(n: i64, k: i64) -> i64:
    """Calculate rising factorial.

    n^(k) = n * (n+1) * ... * (n+k-1)

    Example:
        rising_factorial(5, 3)  # 210 (5*6*7)
    """
    if k <= 0:
        return 1

    var result = 1
    var i = 0

    while i < k:
        result = result * (n + i)
        i = i + 1

    result

# ============================================================================
# Binomial Coefficients
# ============================================================================

fn binomial_coefficient(n: i64, k: i64) -> i64:
    """Calculate binomial coefficient C(n, k) = n! / (k! * (n-k)!)

    Number of ways to choose k items from n items.

    Example:
        binomial_coefficient(5, 2)  # 10
        binomial_coefficient(10, 3)  # 120
    """
    if k < 0 or k > n:
        return 0

    if k == 0 or k == n:
        return 1

    # Use symmetry: C(n, k) = C(n, n-k)
    var k_use = k
    if k > n - k:
        k_use = n - k

    var result = 1
    var i = 0

    while i < k_use:
        result = result * (n - i)
        result = result / (i + 1)
        i = i + 1

    result

fn pascal_triangle(rows: i64):
    """Generate Pascal's triangle up to n rows.

    Example:
        pascal_triangle(4)
        # [[1], [1,1], [1,2,1], [1,3,3,1]]
    """
    var triangle = []
    var row_num = 0

    while row_num < rows:
        var row = []
        var col = 0

        while col <= row_num:
            row.push(binomial_coefficient(row_num, col))
            col = col + 1

        triangle.push(row)
        row_num = row_num + 1

    triangle

fn multinomial_coefficient(values):
    """Calculate multinomial coefficient.

    n! / (k1! * k2! * ... * km!) where n = sum(values)

    Example:
        multinomial_coefficient([2, 3, 1])  # 6! / (2! * 3! * 1!) = 60
    """
    var n = 0
    for value in values:
        n = n + value

    var numerator = factorial(n)
    var denominator = 1

    for value in values:
        denominator = denominator * factorial(value)

    numerator / denominator

# ============================================================================
# Permutations
# ============================================================================

fn permutations_count(n: i64, k: i64) -> i64:
    """Count permutations P(n, k) = n! / (n-k)!

    Number of ways to arrange k items from n items.

    Example:
        permutations_count(5, 2)  # 20
        permutations_count(5, 5)  # 120
    """
    if k < 0 or k > n:
        return 0

    falling_factorial(n, k)

fn permutations(arr, k: i64):
    """Generate all k-permutations of array.

    Returns array of permutations.
    Warning: Can be expensive for large inputs.

    Example:
        permutations([1, 2, 3], 2)
        # [[1,2], [1,3], [2,1], [2,3], [3,1], [3,2]]
    """
    if k <= 0:
        return [[]]

    if k > arr.len():
        return []

    var result = []

    var i = 0
    while i < arr.len():
        # Choose element at position i
        val elem = arr[i]

        # Create array without element i
        var remaining = []
        var j = 0
        while j < arr.len():
            if j != i:
                remaining.push(arr[j])
            j = j + 1

        # Get permutations of remaining elements
        val sub_perms = permutations(remaining, k - 1)

        # Add current element to each sub-permutation
        for sub_perm in sub_perms:
            var perm = [elem]
            for elem in sub_perm:
                perm.push(elem)
            result.push(perm)

        i = i + 1

    result

fn next_permutation(arr):
    """Generate next lexicographic permutation in-place.

    Returns true if next permutation exists, false otherwise.
    Modifies array in place.

    Example:
        var arr = [1, 2, 3]
        next_permutation(arr)  # arr becomes [1, 3, 2]
    """
    # Find largest index i such that arr[i] < arr[i+1]
    var i = arr.len() - 2
    while i >= 0:
        if arr[i] < arr[i + 1]:
            break
        i = i - 1

    if i < 0:
        # Already at last permutation
        return false

    # Find largest index j > i such that arr[i] < arr[j]
    var j = arr.len() - 1
    while j > i:
        if arr[i] < arr[j]:
            break
        j = j - 1

    # Swap arr[i] and arr[j]
    val temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp

    # Reverse suffix starting at arr[i+1]
    var left = i + 1
    var right = arr.len() - 1

    while left < right:
        val temp2 = arr[left]
        arr[left] = arr[right]
        arr[right] = temp2
        left = left + 1
        right = right - 1

    true

# ============================================================================
# Combinations
# ============================================================================

fn combinations_count(n: i64, k: i64) -> i64:
    """Count combinations C(n, k).

    Alias for binomial_coefficient.

    Example:
        combinations_count(5, 2)  # 10
    """
    binomial_coefficient(n, k)

fn combinations(arr, k: i64):
    """Generate all k-combinations of array.

    Returns array of combinations.
    Warning: Can be expensive for large inputs.

    Example:
        combinations([1, 2, 3], 2)
        # [[1,2], [1,3], [2,3]]
    """
    if k <= 0:
        return [[]]

    if k > arr.len():
        return []

    if k == arr.len():
        return [arr]

    var result = []

    # Include first element
    val first = arr[0]
    var rest = []
    var i = 1
    while i < arr.len():
        rest.push(arr[i])
        i = i + 1

    # Combinations including first element
    val with_first = combinations(rest, k - 1)
    for combo in with_first:
        var new_combo = [first]
        for elem in combo:
            new_combo.push(elem)
        result.push(new_combo)

    # Combinations not including first element
    val without_first = combinations(rest, k)
    for combo in without_first:
        result.push(combo)

    result

fn combinations_with_replacement(arr, k: i64):
    """Generate k-combinations with replacement.

    Elements can be repeated.

    Example:
        combinations_with_replacement([1, 2], 2)
        # [[1,1], [1,2], [2,2]]
    """
    if k <= 0:
        return [[]]

    if arr.len() == 0:
        return []

    var result = []

    var i = 0
    while i < arr.len():
        val elem = arr[i]

        # Create subarray from current position onward
        var subarray = []
        var j = i
        while j < arr.len():
            subarray.push(arr[j])
            j = j + 1

        # Get combinations of remaining positions
        val sub_combos = combinations_with_replacement(subarray, k - 1)

        for combo in sub_combos:
            var new_combo = [elem]
            for e in combo:
                new_combo.push(e)
            result.push(new_combo)

        i = i + 1

    result

# ============================================================================
# Power Set
# ============================================================================

fn power_set(arr):
    """Generate power set (all subsets).

    Warning: Returns 2^n subsets.

    Example:
        power_set([1, 2])
        # [[], [1], [2], [1,2]]
    """
    if arr.len() == 0:
        return [[]]

    val first = arr[0]
    var rest = []
    var i = 1
    while i < arr.len():
        rest.push(arr[i])
        i = i + 1

    val subsets_without = power_set(rest)
    var result = []

    # Add subsets without first element
    for subset in subsets_without:
        result.push(subset)

    # Add subsets with first element
    for subset in subsets_without:
        var with_first = [first]
        for elem in subset:
            with_first.push(elem)
        result.push(with_first)

    result

fn power_set_size(n: i64) -> i64:
    """Calculate size of power set (2^n).

    Example:
        power_set_size(5)  # 32
    """
    var result = 1
    var i = 0

    while i < n:
        result = result * 2
        i = i + 1

    result

# ============================================================================
# Integer Partitions
# ============================================================================

fn count_partitions(n: i64) -> i64:
    """Count integer partitions of n.

    Uses dynamic programming.

    Example:
        count_partitions(5)  # 7
        # (5, 4+1, 3+2, 3+1+1, 2+2+1, 2+1+1+1, 1+1+1+1+1)
    """
    if n <= 0:
        return 0

    # Dynamic programming table
    var dp = []
    var i = 0
    while i <= n:
        dp.push(0)
        i = i + 1

    dp[0] = 1

    var num = 1
    while num <= n:
        i = num
        while i <= n:
            dp[i] = dp[i] + dp[i - num]
            i = i + 1
        num = num + 1

    dp[n]

fn integer_partitions_helper(n: i64, max_val: i64):
    """Helper for generating integer partitions."""
    if n == 0:
        return [[]]

    if max_val == 0:
        return []

    var result = []

    # Partitions using max_val
    if max_val <= n:
        val with_max = integer_partitions_helper(n - max_val, max_val)
        for partition in with_max:
            var new_partition = [max_val]
            for elem in partition:
                new_partition.push(elem)
            result.push(new_partition)

    # Partitions not using max_val
    val without_max = integer_partitions_helper(n, max_val - 1)
    for partition in without_max:
        result.push(partition)

    result

fn integer_partitions(n: i64):
    """Generate all integer partitions of n.

    Warning: Can be expensive for large n.

    Example:
        integer_partitions(4)
        # [[4], [3,1], [2,2], [2,1,1], [1,1,1,1]]
    """
    integer_partitions_helper(n, n)

# ============================================================================
# Famous Sequences
# ============================================================================

fn fibonacci(n: i64) -> i64:
    """Calculate nth Fibonacci number.

    F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2)

    Example:
        fibonacci(10)  # 55
    """
    if n <= 0:
        return 0
    if n == 1:
        return 1

    var prev = 0
    var curr = 1
    var i = 2

    while i <= n:
        val next = prev + curr
        prev = curr
        curr = next
        i = i + 1

    curr

fn fibonacci_sequence(n: i64):
    """Generate first n Fibonacci numbers.

    Example:
        fibonacci_sequence(7)  # [0, 1, 1, 2, 3, 5, 8]
    """
    var result = []
    var i = 0

    while i < n:
        result.push(fibonacci(i))
        i = i + 1

    result

fn catalan(n: i64) -> i64:
    """Calculate nth Catalan number.

    C(n) = (2n)! / ((n+1)! * n!)

    Example:
        catalan(4)  # 14
    """
    if n <= 1:
        return 1

    binomial_coefficient(2 * n, n) / (n + 1)

fn catalan_sequence(n: i64):
    """Generate first n Catalan numbers.

    Example:
        catalan_sequence(5)  # [1, 1, 2, 5, 14]
    """
    var result = []
    var i = 0

    while i < n:
        result.push(catalan(i))
        i = i + 1

    result

fn stirling_second_kind(n: i64, k: i64) -> i64:
    """Calculate Stirling number of second kind S(n, k).

    Number of ways to partition n objects into k non-empty subsets.

    Example:
        stirling_second_kind(4, 2)  # 7
    """
    if n == 0 and k == 0:
        return 1
    if n == 0 or k == 0:
        return 0
    if k > n:
        return 0

    # S(n, k) = k * S(n-1, k) + S(n-1, k-1)
    var dp = []
    var i = 0
    while i <= n:
        var row = []
        var j = 0
        while j <= k:
            row.push(0)
            j = j + 1
        dp.push(row)
        i = i + 1

    dp[0][0] = 1

    i = 1
    while i <= n:
        var j = 1
        while j <= k and j <= i:
            dp[i][j] = j * dp[i-1][j] + dp[i-1][j-1]
            j = j + 1
        i = i + 1

    dp[n][k]

fn bell_number(n: i64) -> i64:
    """Calculate nth Bell number.

    Number of ways to partition n elements.
    B(n) = sum of S(n, k) for k = 0 to n.

    Example:
        bell_number(3)  # 5
    """
    var sum = 0
    var k = 0

    while k <= n:
        sum = sum + stirling_second_kind(n, k)
        k = k + 1

    sum

# ============================================================================
# Derangements
# ============================================================================

fn derangements(n: i64) -> i64:
    """Calculate number of derangements of n elements.

    Derangement = permutation where no element is in its original position.

    Example:
        derangements(3)  # 2
        # [2,3,1] and [3,1,2]
    """
    if n == 0:
        return 1
    if n == 1:
        return 0

    var d_prev_prev = 1
    var d_prev = 0
    var i = 2

    while i <= n:
        val d_curr = (i - 1) * (d_prev + d_prev_prev)
        d_prev_prev = d_prev
        d_prev = d_curr
        i = i + 1

    d_prev


# FILE: src/std/comparator_utils.spl
# Size: 15760 bytes, Lines: 693

# Comparator Utilities
#
# Helper functions for comparison, ordering, and sorting operations.
# Pure Simple implementation - no external dependencies.
#
# Provides comparators, ordering functions, and utilities for
# working with comparable values.
#
# Functions:
# - Comparators: natural, reverse, by_key, compose_comparators
# - Ordering: min, max, min_by, max_by, clamp
# - Comparison: compare, compare_by, equal_by
# - Sorting helpers: is_sorted, is_sorted_by, find_insertion_point
# - Min/Max finding: min_max, argmin, argmax

# ============================================================================
# Comparison Results
# ============================================================================

fn Less():
    """Comparison result: less than.

    Example:
        compare(1, 2)  # Less()
    """
    -1

fn Equal():
    """Comparison result: equal.

    Example:
        compare(5, 5)  # Equal()
    """
    0

fn Greater():
    """Comparison result: greater than.

    Example:
        compare(10, 5)  # Greater()
    """
    1

# ============================================================================
# Basic Comparison
# ============================================================================

fn compare(a, b):
    """Compare two values.

    Returns: -1 (less), 0 (equal), 1 (greater)

    Example:
        compare(1, 2)  # -1
        compare(5, 5)  # 0
        compare(10, 5)  # 1
    """
    if a < b:
        return Less()
    if a > b:
        return Greater()
    Equal()

fn compare_by(a, b, key_fn):
    """Compare two values by key function.

    Example:
        compare_by("hello", "world", \\s: s.len())  # 0 (same length)
    """
    val key_a = key_fn(a)
    val key_b = key_fn(b)
    compare(key_a, key_b)

fn equal_by(a, b, key_fn):
    """Check equality by key function.

    Example:
        equal_by("hello", "world", \\s: s.len())  # true
    """
    compare_by(a, b, key_fn) == Equal()

# ============================================================================
# Comparator Functions
# ============================================================================

fn natural_comparator():
    """Natural ordering comparator.

    Example:
        val cmp = natural_comparator()
        cmp(1, 2)  # -1
    """
    \\a, b: compare(a, b)

fn reverse_comparator(cmp):
    """Reverse a comparator.

    Example:
        val rev_cmp = reverse_comparator(natural_comparator())
        rev_cmp(1, 2)  # 1
    """
    \\a, b: -cmp(a, b)

fn by_key_comparator(key_fn):
    """Create comparator based on key function.

    Example:
        val len_cmp = by_key_comparator(\\s: s.len())
        len_cmp("hi", "hello")  # -1 (shorter)
    """
    \\a, b: compare(key_fn(a), key_fn(b))

fn compose_comparators(cmp1, cmp2):
    """Compose two comparators (use cmp2 if cmp1 returns Equal).

    Example:
        # Sort by length, then alphabetically
        val cmp = compose_comparators(
            by_key_comparator(\\s: s.len()),
            natural_comparator()
        )
    """
    \\a, b:
        val result1 = cmp1(a, b)
        if result1 == Equal():
            cmp2(a, b)
        else:
            result1

fn nullable_comparator(cmp, null_first: bool):
    """Create comparator that handles nil values.

    Example:
        val cmp = nullable_comparator(natural_comparator(), true)
        cmp(nil, 5)  # -1 (nil comes first)
    """
    \\a, b:
        val a_null = not a.?
        val b_null = not b.?

        if a_null and b_null:
            return Equal()
        if a_null:
            return if null_first: Less() else: Greater()
        if b_null:
            return if null_first: Greater() else: Less()

        cmp(a, b)

# ============================================================================
# Min/Max Operations
# ============================================================================

fn min_value(a, b):
    """Return minimum of two values.

    Example:
        min_value(5, 10)  # 5
    """
    if a < b: a else: b

fn max_value(a, b):
    """Return maximum of two values.

    Example:
        max_value(5, 10)  # 10
    """
    if a > b: a else: b

fn min_by(a, b, key_fn):
    """Return minimum by key function.

    Example:
        min_by("hello", "hi", \\s: s.len())  # "hi"
    """
    if key_fn(a) < key_fn(b):
        a
    else:
        b

fn max_by(a, b, key_fn):
    """Return maximum by key function.

    Example:
        max_by("hello", "hi", \\s: s.len())  # "hello"
    """
    if key_fn(a) > key_fn(b):
        a
    else:
        b

fn min_max(a, b):
    """Return (min, max) tuple.

    Example:
        min_max(10, 5)  # (5, 10)
    """
    if a < b:
        (a, b)
    else:
        (b, a)

fn clamp_value(value, min: i64, max: i64):
    """Clamp value between min and max.

    Example:
        clamp_value(15, 1, 10)  # 10
        clamp_value(-5, 1, 10)  # 1
        clamp_value(5, 1, 10)   # 5
    """
    if value < min:
        return min
    if value > max:
        return max
    value

# ============================================================================
# Array Min/Max
# ============================================================================

fn array_min(arr):
    """Find minimum value in array.

    Returns nil for empty array.

    Example:
        array_min([3, 1, 4, 1, 5])  # 1
    """
    if arr.len() == 0:
        return nil

    var min = arr[0]
    var i = 1

    while i < arr.len():
        if arr[i] < min:
            min = arr[i]
        i = i + 1

    min

fn array_max(arr):
    """Find maximum value in array.

    Returns nil for empty array.

    Example:
        array_max([3, 1, 4, 1, 5])  # 5
    """
    if arr.len() == 0:
        return nil

    var max = arr[0]
    var i = 1

    while i < arr.len():
        if arr[i] > max:
            max = arr[i]
        i = i + 1

    max

fn array_min_max(arr):
    """Find both minimum and maximum in one pass.

    Returns Some((min, max)) or nil for empty array.

    Example:
        array_min_max([3, 1, 4, 1, 5])  # Some((1, 5))
    """
    if arr.len() == 0:
        return nil

    var min = arr[0]
    var max = arr[0]
    var i = 1

    while i < arr.len():
        if arr[i] < min:
            min = arr[i]
        if arr[i] > max:
            max = arr[i]
        i = i + 1

    Some((min, max))

fn array_min_by(arr, key_fn):
    """Find minimum by key function.

    Example:
        array_min_by(["hello", "hi", "world"], \\s: s.len())  # "hi"
    """
    if arr.len() == 0:
        return nil

    var min_item = arr[0]
    var min_key = key_fn(arr[0])
    var i = 1

    while i < arr.len():
        val key = key_fn(arr[i])
        if key < min_key:
            min_key = key
            min_item = arr[i]
        i = i + 1

    min_item

fn array_max_by(arr, key_fn):
    """Find maximum by key function.

    Example:
        array_max_by(["hello", "hi", "world"], \\s: s.len())  # "hello"
    """
    if arr.len() == 0:
        return nil

    var max_item = arr[0]
    var max_key = key_fn(arr[0])
    var i = 1

    while i < arr.len():
        val key = key_fn(arr[i])
        if key > max_key:
            max_key = key
            max_item = arr[i]
        i = i + 1

    max_item

# ============================================================================
# Argument Min/Max (Index Finding)
# ============================================================================

fn argmin(arr):
    """Find index of minimum value.

    Returns Some(index) or nil for empty array.

    Example:
        argmin([3, 1, 4, 1, 5])  # Some(1)
    """
    if arr.len() == 0:
        return nil

    var min_idx = 0
    var min_val = arr[0]
    var i = 1

    while i < arr.len():
        if arr[i] < min_val:
            min_val = arr[i]
            min_idx = i
        i = i + 1

    Some(min_idx)

fn argmax(arr):
    """Find index of maximum value.

    Returns Some(index) or nil for empty array.

    Example:
        argmax([3, 1, 4, 1, 5])  # Some(4)
    """
    if arr.len() == 0:
        return nil

    var max_idx = 0
    var max_val = arr[0]
    var i = 1

    while i < arr.len():
        if arr[i] > max_val:
            max_val = arr[i]
            max_idx = i
        i = i + 1

    Some(max_idx)

fn argmin_by(arr, key_fn):
    """Find index of minimum by key function.

    Example:
        argmin_by(["hello", "hi", "world"], \\s: s.len())  # Some(1)
    """
    if arr.len() == 0:
        return nil

    var min_idx = 0
    var min_key = key_fn(arr[0])
    var i = 1

    while i < arr.len():
        val key = key_fn(arr[i])
        if key < min_key:
            min_key = key
            min_idx = i
        i = i + 1

    Some(min_idx)

fn argmax_by(arr, key_fn):
    """Find index of maximum by key function.

    Example:
        argmax_by(["hello", "hi", "world"], \\s: s.len())  # Some(0)
    """
    if arr.len() == 0:
        return nil

    var max_idx = 0
    var max_key = key_fn(arr[0])
    var i = 1

    while i < arr.len():
        val key = key_fn(arr[i])
        if key > max_key:
            max_key = key
            max_idx = i
        i = i + 1

    Some(max_idx)

# ============================================================================
# Sorting Utilities
# ============================================================================

fn is_sorted(arr):
    """Check if array is sorted in ascending order.

    Example:
        is_sorted([1, 2, 3, 4])  # true
        is_sorted([1, 3, 2, 4])  # false
    """
    var i = 0
    while i < arr.len() - 1:
        if arr[i] > arr[i + 1]:
            return false
        i = i + 1
    true

fn is_sorted_by(arr, key_fn):
    """Check if array is sorted by key function.

    Example:
        is_sorted_by(["hi", "cat", "hello"], \\s: s.len())  # true
    """
    var i = 0
    while i < arr.len() - 1:
        if key_fn(arr[i]) > key_fn(arr[i + 1]):
            return false
        i = i + 1
    true

fn is_strictly_sorted(arr):
    """Check if array is strictly sorted (no duplicates).

    Example:
        is_strictly_sorted([1, 2, 3, 4])  # true
        is_strictly_sorted([1, 2, 2, 4])  # false
    """
    var i = 0
    while i < arr.len() - 1:
        if arr[i] >= arr[i + 1]:
            return false
        i = i + 1
    true

fn find_insertion_point(sorted_arr, value):
    """Find insertion point to maintain sorted order.

    Uses binary search. Returns index where value should be inserted.

    Example:
        find_insertion_point([1, 3, 5, 7], 4)  # 2
    """
    var left = 0
    var right = sorted_arr.len()

    while left < right:
        val mid = left + (right - left) / 2
        if sorted_arr[mid] < value:
            left = mid + 1
        else:
            right = mid

    left

# ============================================================================
# Comparison Predicates
# ============================================================================

fn between(value, lower, upper):
    """Check if value is between lower and upper (inclusive).

    Example:
        between(5, 1, 10)  # true
        between(15, 1, 10)  # false
    """
    value >= lower and value <= upper

fn between_exclusive(value, lower, upper):
    """Check if value is between lower and upper (exclusive).

    Example:
        between_exclusive(5, 1, 10)  # true
        between_exclusive(1, 1, 10)  # false
    """
    value > lower and value < upper

fn is_ascending(a, b, c):
    """Check if three values are in ascending order.

    Example:
        is_ascending(1, 5, 10)  # true
        is_ascending(1, 10, 5)  # false
    """
    a <= b and b <= c

fn is_descending(a, b, c):
    """Check if three values are in descending order.

    Example:
        is_descending(10, 5, 1)  # true
    """
    a >= b and b >= c

# ============================================================================
# K-th Element Finding
# ============================================================================

fn kth_smallest(arr, k: i64):
    """Find k-th smallest element (0-indexed).

    Uses simple selection. For small arrays only.
    Returns nil if k is out of bounds.

    Example:
        kth_smallest([3, 1, 4, 1, 5], 2)  # Some(3)
    """
    if k < 0 or k >= arr.len():
        return nil

    # Create sorted copy
    var sorted = arr
    var i = 0
    while i < sorted.len() - 1:
        var min_idx = i
        var j = i + 1
        while j < sorted.len():
            if sorted[j] < sorted[min_idx]:
                min_idx = j
            j = j + 1

        if min_idx != i:
            val temp = sorted[i]
            sorted[i] = sorted[min_idx]
            sorted[min_idx] = temp

        i = i + 1

    Some(sorted[k])

fn kth_largest(arr, k: i64):
    """Find k-th largest element (0-indexed).

    Example:
        kth_largest([3, 1, 4, 1, 5], 1)  # Some(4)
    """
    kth_smallest(arr, arr.len() - 1 - k)

fn median(arr):
    """Find median value.

    For even-length arrays, returns lower middle element.

    Example:
        median([3, 1, 4, 1, 5])  # Some(3)
    """
    if arr.len() == 0:
        return nil

    val mid = arr.len() / 2
    kth_smallest(arr, mid)

# ============================================================================
# Top-N Finding
# ============================================================================

fn top_n(arr, n: i64):
    """Find top n largest elements.

    Returns array of n largest elements in descending order.

    Example:
        top_n([3, 1, 4, 1, 5, 9], 3)  # [9, 5, 4]
    """
    if n <= 0 or arr.len() == 0:
        return []

    # Simple approach: sort and take last n
    var sorted = arr
    var i = 0
    while i < sorted.len() - 1:
        var max_idx = i
        var j = i + 1
        while j < sorted.len():
            if sorted[j] > sorted[max_idx]:
                max_idx = j
            j = j + 1

        if max_idx != i:
            val temp = sorted[i]
            sorted[i] = sorted[max_idx]
            sorted[max_idx] = temp

        i = i + 1

    var result = []
    i = 0
    val count = if n < sorted.len(): n else: sorted.len()

    while i < count:
        result.push(sorted[i])
        i = i + 1

    result

fn bottom_n(arr, n: i64):
    """Find bottom n smallest elements.

    Returns array of n smallest elements in ascending order.

    Example:
        bottom_n([3, 1, 4, 1, 5, 9], 3)  # [1, 1, 3]
    """
    if n <= 0 or arr.len() == 0:
        return []

    var sorted = arr
    var i = 0
    while i < sorted.len() - 1:
        var min_idx = i
        var j = i + 1
        while j < sorted.len():
            if sorted[j] < sorted[min_idx]:
                min_idx = j
            j = j + 1

        if min_idx != i:
            val temp = sorted[i]
            sorted[i] = sorted[min_idx]
            sorted[min_idx] = temp

        i = i + 1

    var result = []
    i = 0
    val count = if n < sorted.len(): n else: sorted.len()

    while i < count:
        result.push(sorted[i])
        i = i + 1

    result

# ============================================================================
# Lexicographic Comparison
# ============================================================================

fn compare_arrays(arr1, arr2):
    """Compare two arrays lexicographically.

    Returns: -1 (less), 0 (equal), 1 (greater)

    Example:
        compare_arrays([1, 2, 3], [1, 2, 4])  # -1
        compare_arrays([1, 2], [1, 2, 3])     # -1 (shorter)
    """
    val len1 = arr1.len()
    val len2 = arr2.len()
    val min_len = if len1 < len2: len1 else: len2

    var i = 0
    while i < min_len:
        val cmp = compare(arr1[i], arr2[i])
        if cmp != Equal():
            return cmp
        i = i + 1

    # All elements equal up to min_len, compare lengths
    compare(len1, len2)


# FILE: src/std/ds_utils.spl
# Size: 5809 bytes, Lines: 218

# Data Structure Utilities Module
#
# Stack, Queue, and Deque implementations for i64 values.
# All structures are array-based and support common operations.
#
# Categories:
# - Stack: LIFO (Last-In-First-Out) structure
# - Queue: FIFO (First-In-First-Out) structure
# - Deque: Double-ended queue (operations on both ends)
#
# All operations preserve immutability where possible.

# ============================================================================
# Exports
# ============================================================================

export Stack, Queue, Deque
export stack_from_list, queue_from_list, deque_from_list
export stack_get, queue_get, reverse_stack, merge_queues

# ============================================================================
# Stack (LIFO)
# ============================================================================

class Stack:
    items: [i64]

impl Stack:
    static fn create() -> Stack:
        Stack(items: [])

    fn is_empty() -> bool:
        self.items.len() == 0

    fn size() -> i64:
        self.items.len()

    me push(item: i64):
        self.items = self.items + [item]

    me pop() -> i64?:
        if self.items.len() == 0:
            return nil
        val last = self.items[self.items.len() - 1]
        # Remove last element by copying all but last
        var new_items: [i64] = []
        for i in 0..(self.items.len() - 1):
            new_items = new_items + [self.items[i]]
        self.items = new_items
        last

    fn peek() -> i64?:
        if self.items.len() == 0:
            return nil
        self.items[self.items.len() - 1]

    me clear():
        self.items = []

    fn to_list() -> [i64]:
        self.items

# ============================================================================
# Queue (FIFO)
# ============================================================================

class Queue:
    items: [i64]

impl Queue:
    static fn create() -> Queue:
        Queue(items: [])

    fn is_empty() -> bool:
        self.items.len() == 0

    fn size() -> i64:
        self.items.len()

    me enqueue(item: i64):
        self.items = self.items + [item]

    me dequeue() -> i64?:
        if self.items.len() == 0:
            return nil
        val first = self.items[0]
        # Remove first element by copying all but first
        var new_items: [i64] = []
        for i in 1..self.items.len():
            new_items = new_items + [self.items[i]]
        self.items = new_items
        first

    fn peek() -> i64?:
        if self.items.len() == 0:
            return nil
        self.items[0]

    me clear():
        self.items = []

# ============================================================================
# Deque (Double-Ended Queue)
# ============================================================================

class Deque:
    items: [i64]

impl Deque:
    static fn create() -> Deque:
        Deque(items: [])

    fn is_empty() -> bool:
        self.items.len() == 0

    fn size() -> i64:
        self.items.len()

    me push_front(item: i64):
        self.items = [item] + self.items

    me push_back(item: i64):
        self.items = self.items + [item]

    me pop_front() -> i64?:
        if self.items.len() == 0:
            return nil
        val first = self.items[0]
        # Remove first element
        var new_items: [i64] = []
        for i in 1..self.items.len():
            new_items = new_items + [self.items[i]]
        self.items = new_items
        first

    me pop_back() -> i64?:
        if self.items.len() == 0:
            return nil
        val last = self.items[self.items.len() - 1]
        # Remove last element
        var new_items: [i64] = []
        for i in 0..(self.items.len() - 1):
            new_items = new_items + [self.items[i]]
        self.items = new_items
        last

    fn peek_front() -> i64?:
        if self.items.len() == 0:
            return nil
        self.items[0]

    fn peek_back() -> i64?:
        if self.items.len() == 0:
            return nil
        self.items[self.items.len() - 1]

    me clear():
        self.items = []

# ============================================================================
# Helper Functions
# ============================================================================

fn stack_from_list(items: [i64]) -> Stack:
    """Create a stack from a list of items."""
    var stack = Stack.create()
    for item in items:
        stack.push(item)
    stack

fn queue_from_list(items: [i64]) -> Queue:
    """Create a queue from a list of items."""
    var queue = Queue.create()
    for item in items:
        queue.enqueue(item)
    queue

fn deque_from_list(items: [i64]) -> Deque:
    """Create a deque from a list of items."""
    var deque = Deque.create()
    for item in items:
        deque.push_back(item)
    deque

fn stack_get(stack: Stack, idx: i64) -> i64?:
    """Get element from stack by index (0 = top)."""
    val list = stack.to_list()
    if idx >= list.len():
        return nil
    list[list.len() - 1 - idx]

fn queue_get(queue: Queue, idx: i64) -> i64?:
    """Get element from queue by index (0 = front)."""
    if idx >= queue.size():
        return nil
    queue.items[idx]

fn reverse_stack(stack: Stack) -> Stack:
    """Reverse a stack."""
    var result = Stack.create()
    val items = stack.to_list()
    for item in items:
        result.push(item)
    var reversed = Stack.create()
    for _ in 0..items.len():
        val popped = result.pop()
        if popped != nil:
            reversed.push(popped)
    reversed

fn merge_queues(q1: Queue, q2: Queue) -> Queue:
    """Merge two queues."""
    var result = Queue.create()
    for item in q1.items:
        result.enqueue(item)
    for item in q2.items:
        result.enqueue(item)
    result


# FILE: src/std/encoding_utils.spl
# Size: 15485 bytes, Lines: 662

# Encoding Utilities
#
# Text encoding and decoding utilities.
# Pure Simple implementation - no external dependencies.
#
# Functions:
# - Base64: base64_encode, base64_decode
# - Hex: hex_encode, hex_decode, hex_dump
# - URL: url_encode, url_decode
# - Escape: escape_string, unescape_string
# - Binary: binary_encode, binary_decode
# - ROT13: rot13_encode, rot13_decode


# ============================================================================
# Base64 Encoding
# ============================================================================

fn base64_encode(data):
    """Encode byte array to base64 string.

    Example:
        base64_encode([72, 101, 108, 108, 111])  # "SGVsbG8="
    """
    val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    var result = ""

    var i = 0
    while i < data.len():
        val b1 = data[i]
        val b2 = if i + 1 < data.len(): data[i + 1] else: 0
        val b3 = if i + 2 < data.len(): data[i + 2] else: 0

        val n = (b1 << 16) | (b2 << 8) | b3

        result = result + alphabet[(n >> 18) & 63]
        result = result + alphabet[(n >> 12) & 63]
        result = result + if i + 1 < data.len(): alphabet[(n >> 6) & 63] else: '='
        result = result + if i + 2 < data.len(): alphabet[n & 63] else: '='

        i = i + 3

    result

fn base64_decode(encoded: text):
    """Decode base64 string to byte array.

    Returns nil if invalid base64.

    Example:
        base64_decode("SGVsbG8=")  # [72, 101, 108, 108, 111]
    """
    val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

    # Create lookup table
    var lookup = []
    var i = 0
    while i < 256:
        lookup.push(-1)
        i = i + 1

    i = 0
    while i < alphabet.len():
        lookup[alphabet[i].ord()] = i
        i = i + 1

    var result = []
    i = 0

    while i < encoded.len():
        if encoded[i] == '=':
            break

        val c1 = if i < encoded.len(): lookup[encoded[i].ord()] else: -1
        val c2 = if i + 1 < encoded.len(): lookup[encoded[i + 1].ord()] else: -1
        val c3 = if i + 2 < encoded.len() and encoded[i + 2] != '=': lookup[encoded[i + 2].ord()] else: -1
        val c4 = if i + 3 < encoded.len() and encoded[i + 3] != '=': lookup[encoded[i + 3].ord()] else: -1

        if c1 < 0 or c2 < 0:
            return nil

        val n = (c1 << 18) | (c2 << 12) | (if c3 >= 0: c3 << 6 else: 0) | (if c4 >= 0: c4 else: 0)

        result.push((n >> 16) & 255)
        if c3 >= 0:
            result.push((n >> 8) & 255)
        if c4 >= 0:
            result.push(n & 255)

        i = i + 4

    result

fn base64_encode_string(s: text):
    """Encode string to base64.

    Example:
        base64_encode_string("Hello")  # "SGVsbG8="
    """
    var bytes = []
    var i = 0

    while i < s.len():
        bytes.push(s[i].ord())
        i = i + 1

    base64_encode(bytes)

fn base64_decode_string(encoded: text):
    """Decode base64 to string.

    Example:
        base64_decode_string("SGVsbG8=")  # "Hello"
    """
    val bytes = base64_decode(encoded)
    if not bytes.?:
        return nil

    var result = ""
    for byte in bytes:
        result = result + byte.chr()

    result

# ============================================================================
# Hexadecimal Encoding
# ============================================================================

fn hex_encode(data):
    """Encode byte array to hex string.

    Example:
        hex_encode([72, 101, 108, 108, 111])  # "48656c6c6f"
    """
    val hex_chars = "0123456789abcdef"
    var result = ""

    for byte in data:
        result = result + hex_chars[(byte >> 4) & 15]
        result = result + hex_chars[byte & 15]

    result

fn hex_decode(hex: text):
    """Decode hex string to byte array.

    Returns nil if invalid hex.

    Example:
        hex_decode("48656c6c6f")  # [72, 101, 108, 108, 111]
    """
    if hex.len() % 2 != 0:
        return nil

    var result = []
    var i = 0

    while i < hex.len():
        val h1 = hex_digit_value(hex[i])
        val h2 = hex_digit_value(hex[i + 1])

        if h1 < 0 or h2 < 0:
            return nil

        result.push(h1 * 16 + h2)
        i = i + 2

    result

fn hex_digit_value(c):
    """Convert hex character to value.

    Example:
        hex_digit_value('A')  # 10
    """
    val code = c.ord()

    if code >= '0'.ord() and code <= '9'.ord():
        return code - '0'.ord()
    elif code >= 'a'.ord() and code <= 'f'.ord():
        return code - 'a'.ord() + 10
    elif code >= 'A'.ord() and code <= 'F'.ord():
        return code - 'A'.ord() + 10
    else:
        return -1

fn hex_encode_string(s: text):
    """Encode string to hex.

    Example:
        hex_encode_string("Hello")  # "48656c6c6f"
    """
    var bytes = []
    var i = 0

    while i < s.len():
        bytes.push(s[i].ord())
        i = i + 1

    hex_encode(bytes)

fn hex_decode_string(hex: text):
    """Decode hex to string.

    Example:
        hex_decode_string("48656c6c6f")  # "Hello"
    """
    val bytes = hex_decode(hex)
    if not bytes.?:
        return nil

    var result = ""
    for byte in bytes:
        result = result + byte.chr()

    result

fn hex_dump(data, bytes_per_line: i64):
    """Format hex dump with addresses.

    Example:
        hex_dump([1, 2, 3, 4, 5, 6], 4)
        # "0000: 01 02 03 04\n0004: 05 06"
    """
    var result = ""
    val hex_chars = "0123456789abcdef"

    var i = 0
    while i < data.len():
        # Address
        var addr = i
        var addr_str = ""
        var j = 0
        while j < 4:
            addr_str = hex_chars[addr & 15] + addr_str
            addr = addr >> 4
            j = j + 1
        result = result + addr_str + ": "

        # Hex bytes
        var k = 0
        while k < bytes_per_line and i + k < data.len():
            val byte = data[i + k]
            result = result + hex_chars[(byte >> 4) & 15]
            result = result + hex_chars[byte & 15]
            result = result + " "
            k = k + 1

        result = result + "\n"
        i = i + bytes_per_line

    result

# ============================================================================
# URL Encoding
# ============================================================================

fn url_encode(s: text):
    """URL encode string (percent encoding).

    Example:
        url_encode("hello world")  # "hello%20world"
    """
    val hex_chars = "0123456789ABCDEF"
    var result = ""

    var i = 0
    while i < s.len():
        val c = s[i]
        val code = c.ord()

        # Check if safe character
        if is_url_safe(c):
            result = result + c
        else:
            # Percent encode
            result = result + '%'
            result = result + hex_chars[(code >> 4) & 15]
            result = result + hex_chars[code & 15]

        i = i + 1

    result

fn url_decode(s: text):
    """URL decode string.

    Returns nil if invalid encoding.

    Example:
        url_decode("hello%20world")  # "hello world"
    """
    var result = ""
    var i = 0

    while i < s.len():
        if s[i] == '%':
            if i + 2 >= s.len():
                return nil

            val h1 = hex_digit_value(s[i + 1])
            val h2 = hex_digit_value(s[i + 2])

            if h1 < 0 or h2 < 0:
                return nil

            result = result + (h1 * 16 + h2).chr()
            i = i + 3
        elif s[i] == '+':
            result = result + ' '
            i = i + 1
        else:
            result = result + s[i]
            i = i + 1

    result

fn is_url_safe(c):
    """Check if character is URL-safe (doesn't need encoding).

    Example:
        is_url_safe('a')  # true
        is_url_safe(' ')  # false
    """
    val code = c.ord()

    # A-Z, a-z, 0-9, -, _, ., ~
    if code >= 'A'.ord() and code <= 'Z'.ord():
        return true
    if code >= 'a'.ord() and code <= 'z'.ord():
        return true
    if code >= '0'.ord() and code <= '9'.ord():
        return true
    if c == '-' or c == '_' or c == '.' or c == '~':
        return true

    false

# ============================================================================
# String Escaping
# ============================================================================

fn escape_string(s: text):
    """Escape special characters in string.

    Escapes: \\n, \\t, \\r, \\\\, \\"

    Example:
        escape_string("hello\\nworld")  # "hello\\\\nworld"
    """
    var result = ""
    var i = 0

    while i < s.len():
        val c = s[i]

        if c == '\n':
            result = result + "\\n"
        elif c == '\t':
            result = result + "\\t"
        elif c == '\r':
            result = result + "\\r"
        elif c == '\\':
            result = result + "\\\\"
        elif c == '"':
            result = result + "\\\""
        else:
            result = result + c

        i = i + 1

    result

fn unescape_string(s: text):
    """Unescape string.

    Example:
        unescape_string("hello\\\\nworld")  # "hello\\nworld"
    """
    var result = ""
    var i = 0

    while i < s.len():
        if s[i] == '\\' and i + 1 < s.len():
            val next = s[i + 1]

            if next == 'n':
                result = result + '\n'
                i = i + 2
            elif next == 't':
                result = result + '\t'
                i = i + 2
            elif next == 'r':
                result = result + '\r'
                i = i + 2
            elif next == '\\':
                result = result + '\\'
                i = i + 2
            elif next == '"':
                result = result + '"'
                i = i + 2
            else:
                result = result + s[i]
                i = i + 1
        else:
            result = result + s[i]
            i = i + 1

    result

fn escape_html(s: text):
    """Escape HTML special characters.

    Example:
        escape_html("<div>text</div>")  # "&lt;div&gt;text&lt;/div&gt;"
    """
    var result = ""
    var i = 0

    while i < s.len():
        val c = s[i]

        if c == '<':
            result = result + "&lt;"
        elif c == '>':
            result = result + "&gt;"
        elif c == '&':
            result = result + "&amp;"
        elif c == '"':
            result = result + "&quot;"
        elif c == '\'':
            result = result + "&#39;"
        else:
            result = result + c

        i = i + 1

    result

fn escape_csv(s: text):
    """Escape string for CSV.

    Quotes string if contains comma, quote, or newline.

    Example:
        escape_csv("hello, world")  # "\"hello, world\""
    """
    var needs_quoting = false
    var i = 0

    while i < s.len():
        val nl_char = "\n"[0:1]
        if s[i] == ',' or s[i] == '"' or s[i] == nl_char:
            needs_quoting = true
            break
        i = i + 1

    if not needs_quoting:
        return s

    var result = "\""
    i = 0

    while i < s.len():
        if s[i] == '"':
            result = result + "\"\""  # Double quote
        else:
            result = result + s[i]
        i = i + 1

    result + "\""

# ============================================================================
# Binary Encoding
# ============================================================================

fn binary_encode(n: i64, bits: i64):
    """Encode integer as binary string.

    Example:
        binary_encode(5, 8)  # "00000101"
    """
    var result = ""
    var i = bits - 1

    while i >= 0:
        if (n & (1 << i)) != 0:
            result = result + '1'
        else:
            result = result + '0'
        i = i - 1

    result

fn binary_decode(s: text) -> i64:
    """Decode binary string to integer.

    Example:
        binary_decode("00000101")  # 5
    """
    var result = 0
    var i = 0

    while i < s.len():
        result = result << 1
        if s[i] == '1':
            result = result | 1
        i = i + 1

    result

fn octal_encode(n: i64):
    """Encode integer as octal string.

    Example:
        octal_encode(64)  # "100"
    """
    if n == 0:
        return "0"

    var result = ""
    var num = n

    while num > 0:
        val digit = num % 8
        result = digit.chr() + result
        num = num / 8

    result

fn octal_decode(s: text) -> i64:
    """Decode octal string to integer.

    Example:
        octal_decode("100")  # 64
    """
    var result = 0
    var i = 0

    while i < s.len():
        result = result * 8 + (s[i].ord() - '0'.ord())
        i = i + 1

    result

# ============================================================================
# ROT13 Encoding
# ============================================================================

fn rot13_encode(s: text):
    """ROT13 encoding (Caesar cipher with shift 13).

    Example:
        rot13_encode("hello")  # "uryyb"
    """
    var result = ""
    var i = 0

    while i < s.len():
        val c = s[i]
        val code = c.ord()

        if code >= 'a'.ord() and code <= 'z'.ord():
            val shifted = ((code - 'a'.ord() + 13) % 26) + 'a'.ord()
            result = result + shifted.chr()
        elif code >= 'A'.ord() and code <= 'Z'.ord():
            val shifted = ((code - 'A'.ord() + 13) % 26) + 'A'.ord()
            result = result + shifted.chr()
        else:
            result = result + c

        i = i + 1

    result

fn rot13_decode(s: text):
    """ROT13 decoding (same as encoding).

    Example:
        rot13_decode("uryyb")  # "hello"
    """
    rot13_encode(s)

fn caesar_encode(s: text, shift: i64):
    """Caesar cipher with custom shift.

    Example:
        caesar_encode("hello", 3)  # "khoor"
    """
    var result = ""
    var i = 0

    while i < s.len():
        val c = s[i]
        val code = c.ord()

        if code >= 'a'.ord() and code <= 'z'.ord():
            val shifted = ((code - 'a'.ord() + shift) % 26) + 'a'.ord()
            result = result + shifted.chr()
        elif code >= 'A'.ord() and code <= 'Z'.ord():
            val shifted = ((code - 'A'.ord() + shift) % 26) + 'A'.ord()
            result = result + shifted.chr()
        else:
            result = result + c

        i = i + 1

    result

fn caesar_decode(s: text, shift: i64):
    """Decode Caesar cipher.

    Example:
        caesar_decode("khoor", 3)  # "hello"
    """
    caesar_encode(s, 26 - shift)

# ============================================================================
# Unicode Utilities
# ============================================================================

fn char_to_unicode_escape(c) -> text:
    """Convert character to \\uXXXX escape.

    Example:
        char_to_unicode_escape('A')  # "\\u0041"
    """
    val code = c.ord()
    val hex_chars = "0123456789ABCDEF"

    "\\u" +
    hex_chars[(code >> 12) & 15] +
    hex_chars[(code >> 8) & 15] +
    hex_chars[(code >> 4) & 15] +
    hex_chars[code & 15]

fn is_printable(c):
    """Check if character is printable.

    Example:
        is_printable('A')  # true
        is_printable('\n')  # false
    """
    val code = c.ord()
    code >= 32 and code <= 126

fn filter_printable(s: text):
    """Keep only printable characters.

    Example:
        filter_printable("hello\\nworld")  # "helloworld"
    """
    var result = ""
    var i = 0

    while i < s.len():
        if is_printable(s[i]):
            result = result + s[i]
        i = i + 1

    result


# FILE: src/std/format_utils.spl
# Size: 13892 bytes, Lines: 571

# Format Utilities
#
# Advanced string formatting and presentation utilities.
# Pure Simple implementation - no external dependencies.
#
# Provides formatting functions for numbers, tables, alignment,
# wrapping, and structured output.
#
# Functions:
# - Number formatting: format_int, format_hex, format_binary, format_size
# - Alignment: align_left, align_right, align_center
# - Tables: format_table_row, format_table
# - Lists: format_bullet_list, format_numbered_list
# - Wrapping: wrap_text, wrap_at_width
# - Indentation: indent, dedent, indent_block
# - Boxes: box_text, border_text


# ============================================================================
# Number Formatting
# ============================================================================

fn format_int(n: i64, width: i64, pad_char: text) -> text:
    """Format integer with padding.

    Example:
        format_int(42, 5, "0")  # "00042"
        format_int(123, 3, " ")  # "123"
    """
    val s = "{n}"
    if s.len() >= width:
        return s

    var padding = ""
    var needed = width - s.len()
    var i = 0
    while i < needed:
        padding = padding + pad_char
        i = i + 1

    padding + s

fn format_hex(n: i64, width: i64) -> text:
    """Format integer as hexadecimal with padding.

    Example:
        format_hex(255, 4)  # "00FF"
        format_hex(16, 2)   # "10"
    """
    val hex_digits = "0123456789ABCDEF"
    var result = ""
    var value = n

    if value == 0:
        result = "0"
    else:
        while value > 0:
            val digit = value % 16
            result = "{hex_digits[digit]}" + result
            value = value / 16

    # Pad to width
    while result.len() < width:
        result = "0" + result

    result

fn format_binary(n: i64, width: i64) -> text:
    """Format integer as binary with padding.

    Example:
        format_binary(5, 8)  # "00000101"
        format_binary(255, 8)  # "11111111"
    """
    var result = ""
    var value = n
    var i = 0

    if value == 0:
        result = "0"
    else:
        while value > 0:
            if value % 2 == 1:
                result = "1" + result
            else:
                result = "0" + result
            value = value / 2

    # Pad to width
    while result.len() < width:
        result = "0" + result

    result

fn format_size_bytes(bytes: i64) -> text:
    """Format byte size in human-readable form.

    Example:
        format_size_bytes(1024)  # "1.0 KB"
        format_size_bytes(1500000)  # "1.4 MB"
    """
    if bytes < 1024:
        return "{bytes} B"

    val kb = bytes / 1024
    if kb < 1024:
        val frac = (bytes % 1024) / 102  # Approximate tenth
        return "{kb}.{frac} KB"

    val mb = kb / 1024
    if mb < 1024:
        val frac = (kb % 1024) / 102
        return "{mb}.{frac} MB"

    val gb = mb / 1024
    val frac = (mb % 1024) / 102
    "{gb}.{frac} GB"

fn format_percentage(numerator: i64, denominator: i64, decimals: i64) -> text:
    """Format as percentage.

    Example:
        format_percentage(75, 100, 1)  # "75.0%"
        format_percentage(1, 3, 1)  # "33.3%"
    """
    if denominator == 0:
        return "0%"

    val percent = (numerator * 100) / denominator
    val fraction = ((numerator * 100) % denominator) * 10 / denominator

    if decimals > 0:
        "{percent}.{fraction}%"
    else:
        "{percent}%"

# ============================================================================
# Text Alignment
# ============================================================================

fn align_left(text: text, width: i64, fill: text) -> text:
    """Align text left within width.

    Example:
        align_left("hello", 10, " ")  # "hello     "
    """
    if text.len() >= width:
        return text

    var result = text
    while result.len() < width:
        result = result + fill

    result

fn align_right(text: text, width: i64, fill: text) -> text:
    """Align text right within width.

    Example:
        align_right("hello", 10, " ")  # "     hello"
    """
    if text.len() >= width:
        return text

    var result = ""
    while result.len() < (width - text.len()):
        result = result + fill

    result + text

fn align_center(text: text, width: i64, fill: text) -> text:
    """Center text within width.

    Example:
        align_center("hello", 11, " ")  # "   hello   "
    """
    if text.len() >= width:
        return text

    val total_padding = width - text.len()
    val left_padding = total_padding / 2
    val right_padding = total_padding - left_padding

    var result = ""
    var i = 0
    while i < left_padding:
        result = result + fill
        i = i + 1

    result = result + text

    i = 0
    while i < right_padding:
        result = result + fill
        i = i + 1

    result

# ============================================================================
# Table Formatting
# ============================================================================

fn format_table_row(cells, widths, separator: text) -> text:
    """Format a table row with aligned cells.

    Example:
        format_table_row(["ID", "Name", "Age"], [5, 10, 5], " | ")
        # "ID    | Name       | Age  "
    """
    if cells.len() != widths.len():
        return ""

    var result = ""
    var i = 0

    while i < cells.len():
        val cell = align_left("{cells[i]}", widths[i], " ")
        result = result + cell

        if i < cells.len() - 1:
            result = result + separator

        i = i + 1

    result

fn format_table_divider(widths, separator: text, fill: text) -> text:
    """Format a table divider line.

    Example:
        format_table_divider([5, 10, 5], "-+-", "-")
        # "-----+----------+-----"
    """
    var result = ""
    var i = 0

    while i < widths.len():
        var segment = ""
        var j = 0
        while j < widths[i]:
            segment = segment + fill
            j = j + 1

        result = result + segment

        if i < widths.len() - 1:
            result = result + separator

        i = i + 1

    result

# ============================================================================
# List Formatting
# ============================================================================

fn format_bullet_list(items, bullet: text, indent_size: i64) -> text:
    """Format items as bullet list.

    Example:
        format_bullet_list(["Item 1", "Item 2"], "- ", 2)
        # "  - Item 1\n  - Item 2"
    """
    var result = ""
    var padding = ""
    var i = 0

    while i < indent_size:
        padding = padding + " "
        i = i + 1

    i = 0
    while i < items.len():
        result = result + padding + bullet + "{items[i]}"
        if i < items.len() - 1:
            result = result + "\n"
        i = i + 1

    result

fn format_numbered_list(items, start: i64, suffix: text, indent_size: i64) -> text:
    """Format items as numbered list.

    Example:
        format_numbered_list(["First", "Second"], 1, ". ", 2)
        # "  1. First\n  2. Second"
    """
    var result = ""
    var padding = ""
    var i = 0

    while i < indent_size:
        padding = padding + " "
        i = i + 1

    i = 0
    while i < items.len():
        val number = start + i
        result = result + padding + "{number}" + suffix + "{items[i]}"
        if i < items.len() - 1:
            result = result + "\n"
        i = i + 1

    result

# ============================================================================
# Text Wrapping
# ============================================================================

fn wrap_text(text: text, width: i64) -> [text]:
    """Wrap text at word boundaries to fit width.

    Returns array of lines.

    Example:
        wrap_text("hello world foo bar", 10)
        # ["hello", "world foo", "bar"]
    """
    if width <= 0:
        return [text]

    val words = text.split(" ")
    var lines = []
    var current_line = ""

    for word in words:
        val test_line = if current_line.?:
            current_line + " " + word
        else:
            word

        if test_line.len() <= width:
            current_line = test_line
        else:
            if current_line.?:
                lines.push(current_line)
            current_line = word

    if current_line.?:
        lines.push(current_line)

    lines

fn wrap_text_hard(text: text, width: i64) -> [text]:
    """Hard wrap text at exact width (no word boundaries).

    Example:
        wrap_text_hard("abcdefghij", 3)
        # ["abc", "def", "ghi", "j"]
    """
    if width <= 0:
        return [text]

    var lines = []
    var i = 0

    while i < text.len():
        val end = if i + width < text.len():
            i + width
        else:
            text.len()

        lines.push(text[i..end])
        i = i + width

    lines

# ============================================================================
# Indentation
# ============================================================================

fn indent(text: text, spaces: i64) -> text:
    """Add indentation to text.

    Example:
        indent("hello", 4)  # "    hello"
    """
    var prefix = ""
    var i = 0
    while i < spaces:
        prefix = prefix + " "
        i = i + 1

    prefix + text

fn indent_block(text: text, spaces: i64) -> text:
    """Add indentation to each line of text.

    Example:
        indent_block("line1\nline2", 2)
        # "  line1\n  line2"
    """
    val lines = text.split("\n")
    var result = []

    for line in lines:
        result.push(indent(line, spaces))

    result.join("\n")

fn dedent(text: text, spaces: i64) -> text:
    """Remove up to spaces leading spaces from text.

    Example:
        dedent("    hello", 2)  # "  hello"
    """
    var i = 0
    while i < spaces and i < text.len():
        if text[i] != ' ':
            break
        i = i + 1

    if i > 0 and i < text.len():
        text[i..]
    else:
        text

# ============================================================================
# Box Drawing
# ============================================================================

fn box_text(text: text, padding: i64) -> text:
    """Draw box around text.

    Example:
        box_text("Hello", 1)
        # "+-------+\n| Hello |\n+-------+"
    """
    val content_width = text.len() + (padding * 2)
    var top = "+"
    var i = 0
    while i < content_width:
        top = top + "-"
        i = i + 1
    top = top + "+"

    var pad = ""
    i = 0
    while i < padding:
        pad = pad + " "
        i = i + 1

    val middle = "|" + pad + text + pad + "|"
    val bottom = top

    top + "\n" + middle + "\n" + bottom

fn border_text(text: text, border_char: text) -> text:
    """Add border around text.

    Example:
        border_text("Hello", "*")
        # "*******\n*Hello*\n*******"
    """
    val width = text.len() + 2
    var border = ""
    var i = 0
    while i < width:
        border = border + border_char
        i = i + 1

    val middle = border_char + text + border_char

    border + "\n" + middle + "\n" + border

# ============================================================================
# Column Layout
# ============================================================================

fn format_columns(items, columns: i64, width: i64) -> text:
    """Format items in columns.

    Example:
        format_columns(["A", "B", "C", "D"], 2, 10)
        # "A         B         \nC         D         "
    """
    var result = ""
    var i = 0

    while i < items.len():
        val cell = align_left("{items[i]}", width, " ")
        result = result + cell

        if (i + 1) % columns == 0 and i < items.len() - 1:
            result = result + "\n"

        i = i + 1

    result

# ============================================================================
# Progress Indicators
# ============================================================================

fn format_progress_bar(current: i64, total: i64, width: i64, fill: text, empty: text) -> text:
    """Format progress bar.

    Example:
        format_progress_bar(7, 10, 20, "#", "-")
        # "[##############------]"
    """
    if total <= 0:
        return "[" + empty + "]"

    val filled = (current * width) / total
    val unfilled = width - filled

    var bar = "["
    var i = 0

    while i < filled:
        bar = bar + fill
        i = i + 1

    i = 0
    while i < unfilled:
        bar = bar + empty
        i = i + 1

    bar + "]"

fn format_spinner(step: i64) -> text:
    """Get spinner character for animation.

    Example:
        format_spinner(0)  # "|"
        format_spinner(1)  # "/"
        format_spinner(2)  # "-"
        format_spinner(3)  # "\\"
    """
    val frames = ["|", "/", "-", "\\"]
    val index = step % 4
    frames[index]

# ============================================================================
# Key-Value Formatting
# ============================================================================

fn format_key_value(key: text, value: text, separator: text, key_width: i64) -> text:
    """Format key-value pair.

    Example:
        format_key_value("Name", "Alice", ": ", 10)
        # "Name      : Alice"
    """
    val aligned_key = align_left(key, key_width, " ")
    aligned_key + separator + value

fn format_key_value_list(pairs, separator: text, key_width: i64) -> text:
    """Format list of key-value pairs.

    pairs is array of (key, value) tuples.

    Example:
        format_key_value_list([("ID", "1"), ("Name", "Alice")], ": ", 6)
        # "ID    : 1\nName  : Alice"
    """
    var result = ""
    var i = 0

    while i < pairs.len():
        val (key, value) = pairs[i]
        result = result + format_key_value(key, value, separator, key_width)

        if i < pairs.len() - 1:
            result = result + "\n"

        i = i + 1

    result


# FILE: src/std/ftp_utils.spl
# Size: 17319 bytes, Lines: 541

# FTP File Transfer Protocol Module
# Comprehensive FTP client implementation with command support, response parsing,
# and file transfer operations.
#
# Connection format: (host, port, username, mode, current_dir)
# - host: text (server hostname/IP)
# - port: i64 (server port, typically 21)
# - username: text (authenticated username)
# - mode: text ("ascii" or "binary")
# - current_dir: text (current working directory)

# FTP Response Codes
fn response_code_125() -> i64: 125  # Data connection already open; transfer starting
fn response_code_150() -> i64: 150  # File status okay; about to open data connection
fn response_code_200() -> i64: 200  # Command okay
fn response_code_213() -> i64: 213  # File status
fn response_code_214() -> i64: 214  # Help message
fn response_code_220() -> i64: 220  # Service ready for new user
fn response_code_221() -> i64: 221  # Service closing control connection
fn response_code_226() -> i64: 226  # Closing data connection; requested action successful
fn response_code_227() -> i64: 227  # Entering Passive Mode
fn response_code_230() -> i64: 230  # User logged in, proceed
fn response_code_250() -> i64: 250  # Requested file action okay, completed
fn response_code_257() -> i64: 257  # Pathname created
fn response_code_331() -> i64: 331  # User name okay, need password
fn response_code_425() -> i64: 425  # Can't open data connection
fn response_code_426() -> i64: 426  # Connection closed; transfer aborted
fn response_code_450() -> i64: 450  # Requested file action not taken
fn response_code_500() -> i64: 500  # Syntax error, command unrecognized
fn response_code_501() -> i64: 501  # Syntax error in parameters or arguments
fn response_code_502() -> i64: 502  # Command not implemented
fn response_code_530() -> i64: 530  # Not logged in
fn response_code_550() -> i64: 550  # Requested action not taken

# Response Code Classification
fn is_positive_preliminary(code: i64) -> bool:
    code >= 100 and code < 200

fn is_positive_completion(code: i64) -> bool:
    code >= 200 and code < 300

fn is_positive_intermediate(code: i64) -> bool:
    code >= 300 and code < 400

fn is_transient_negative(code: i64) -> bool:
    code >= 400 and code < 500

fn is_permanent_negative(code: i64) -> bool:
    code >= 500 and code < 600

fn is_success_response(code: i64) -> bool:
    is_positive_completion(code) or is_positive_preliminary(code)

fn is_error_response(code: i64) -> bool:
    is_transient_negative(code) or is_permanent_negative(code)

# Response Parsing
fn parse_response_code(response: text) -> i64:
    # Extract first 3 digits from response
    if response.length() < 3:
        return 0
    val code_str = response.substring(0, 3)
    val code = code_str.to_i64()
    if code.?:
        return code
    return 0

fn parse_response_message(response: text) -> text:
    # Extract message after response code
    if response.length() < 4:
        return ""
    return response.substring(4, response.length()).trim()

fn parse_response(response: text) -> (i64, text):
    # Parse response into (code, message) tuple
    val code = parse_response_code(response)
    val message = parse_response_message(response)
    return (code, message)

fn is_multiline_response(response: text) -> bool:
    # Check if response is multiline (has dash after code)
    if response.length() < 4:
        return false
    return response.substring(3, 4) == "-"

# FTP Commands
fn cmd_user(username: text) -> text:
    "USER {username}\r\n"

fn cmd_pass(password: text) -> text:
    "PASS {password}\r\n"

fn cmd_cwd(directory: text) -> text:
    "CWD {directory}\r\n"

fn cmd_pwd() -> text:
    "PWD\r\n"

fn cmd_list(path: text) -> text:
    if path == "":
        return "LIST\r\n"
    "LIST {path}\r\n"

fn cmd_retr(filename: text) -> text:
    "RETR {filename}\r\n"

fn cmd_stor(filename: text) -> text:
    "STOR {filename}\r\n"

fn cmd_dele(filename: text) -> text:
    "DELE {filename}\r\n"

fn cmd_mkd(directory: text) -> text:
    "MKD {directory}\r\n"

fn cmd_rmd(directory: text) -> text:
    "RMD {directory}\r\n"

fn cmd_rnfr(old_name: text) -> text:
    "RNFR {old_name}\r\n"

fn cmd_rnto(new_name: text) -> text:
    "RNTO {new_name}\r\n"

fn cmd_type_ascii() -> text:
    "TYPE A\r\n"

fn cmd_type_binary() -> text:
    "TYPE I\r\n"

fn cmd_mode_stream() -> text:
    "MODE S\r\n"

fn cmd_pasv() -> text:
    "PASV\r\n"

fn cmd_port(ip: text, port: i64) -> text:
    # Convert IP and port to PORT command format
    val port_high = port / 256
    val port_low = port % 256
    val ip_formatted = ip.replace(".", ",")
    "PORT {ip_formatted},{port_high},{port_low}\r\n"

fn cmd_quit() -> text:
    "QUIT\r\n"

fn cmd_noop() -> text:
    "NOOP\r\n"

fn cmd_syst() -> text:
    "SYST\r\n"

fn cmd_help() -> text:
    "HELP\r\n"

fn cmd_stat(path: text) -> text:
    if path == "":
        return "STAT\r\n"
    "STAT {path}\r\n"

# PASV Response Parsing
fn parse_pasv_response(response: text) -> (text, i64):
    # Extract IP and port from PASV response
    # Format: "227 Entering Passive Mode (h1,h2,h3,h4,p1,p2)"
    val start_idx = response.index_of("(")
    if not start_idx.?:
        return ("", 0)
    val end_idx = response.index_of(")")
    if not end_idx.?:
        return ("", 0)

    val start_pos = start_idx + 1
    val end_pos = end_idx
    val params = response.substring(start_pos, end_pos)
    val parts = params.split(",")

    if parts.length() != 6:
        return ("", 0)

    val h1 = parts[0].trim().to_i64()
    val h2 = parts[1].trim().to_i64()
    val h3 = parts[2].trim().to_i64()
    val h4 = parts[3].trim().to_i64()
    val p1 = parts[4].trim().to_i64()
    val p2 = parts[5].trim().to_i64()

    if not h1.? or not h2.? or not h3.? or not h4.? or not p1.? or not p2.?:
        return ("", 0)

    val ip = "{h1}.{h2}.{h3}.{h4}"
    val port = p1 * 256 + p2

    return (ip, port)

fn extract_pasv_ip(response: text) -> text:
    val result = parse_pasv_response(response)
    return result[0]

fn extract_pasv_port(response: text) -> i64:
    val result = parse_pasv_response(response)
    return result[1]

# Path Operations
fn normalize_path(path: text) -> text:
    # Normalize path by removing redundant slashes and dots
    if path == "":
        return "/"

    var normalized = path

    # Replace multiple slashes with single slash
    while normalized.contains("//"):
        normalized = normalized.replace("//", "/")

    # Remove trailing slash unless it's root
    if normalized.length() > 1 and normalized.ends_with("/"):
        normalized = normalized.substring(0, normalized.length() - 1)

    return normalized

fn is_absolute_path(path: text) -> bool:
    path.starts_with("/")

fn is_relative_path(path: text) -> bool:
    not is_absolute_path(path)

fn join_paths(base: text, relative: text) -> text:
    # Join two paths
    if is_absolute_path(relative):
        return normalize_path(relative)

    var result = base
    if not result.ends_with("/"):
        result = result + "/"
    result = result + relative

    return normalize_path(result)

fn get_parent_directory(path: text) -> text:
    # Get parent directory of a path
    val normalized = normalize_path(path)
    if normalized == "/":
        return "/"

    val last_slash = normalized.last_index_of("/")
    if not last_slash.?:
        return "/"

    if last_slash == 0:
        return "/"

    return normalized.substring(0, last_slash)

fn get_filename(path: text) -> text:
    # Extract filename from path
    val normalized = normalize_path(path)
    val last_slash = normalized.last_index_of("/")
    if not last_slash.?:
        return normalized

    return normalized.substring(last_slash + 1, normalized.length())

fn get_directory(path: text) -> text:
    # Extract directory from path
    return get_parent_directory(path)

# File Listing Parsing
fn parse_unix_listing_line(line: text) -> (text, i64, text, text):
    # Parse Unix-style listing line
    # Format: "drwxr-xr-x 2 user group 4096 Jan 1 12:00 filename"
    # Returns: (permissions, size, date, name)
    val parts = line.split_whitespace()
    if parts.length() < 9:
        return ("", 0, "", "")

    val permissions = parts[0]
    val size_str = parts[4]
    val size = size_str.to_i64()
    val month = parts[5]
    val day = parts[6]
    val time = parts[7]
    val date = "{month} {day} {time}"

    # Filename may contain spaces, so join remaining parts
    var name = parts[8]
    var i = 9
    while i < parts.length():
        name = name + " " + parts[i]
        i = i + 1

    val size_val = size ?? 0
    return (permissions, size_val, date, name)

fn parse_listing_permissions(line: text) -> text:
    val result = parse_unix_listing_line(line)
    return result[0]

fn parse_listing_size(line: text) -> i64:
    val result = parse_unix_listing_line(line)
    return result[1]

fn parse_listing_date(line: text) -> text:
    val result = parse_unix_listing_line(line)
    return result[2]

fn parse_listing_name(line: text) -> text:
    val result = parse_unix_listing_line(line)
    return result[3]

fn is_directory_listing(line: text) -> bool:
    # Check if listing line represents a directory
    val permissions = parse_listing_permissions(line)
    if permissions.length() == 0:
        return false
    return permissions.starts_with("d")

fn is_file_listing(line: text) -> bool:
    # Check if listing line represents a file
    val permissions = parse_listing_permissions(line)
    if permissions.length() == 0:
        return false
    return permissions.starts_with("-")

fn is_link_listing(line: text) -> bool:
    # Check if listing line represents a symbolic link
    val permissions = parse_listing_permissions(line)
    if permissions.length() == 0:
        return false
    return permissions.starts_with("l")

# Connection Management
fn create_connection(host: text, port: i64, username: text) -> (text, i64, text, text, text):
    # Create new connection tuple
    # Returns: (host, port, username, mode, current_dir)
    return (host, port, username, "binary", "/")

fn get_connection_host(conn: (text, i64, text, text, text)) -> text:
    return conn[0]

fn get_connection_port(conn: (text, i64, text, text, text)) -> i64:
    return conn[1]

fn get_connection_username(conn: (text, i64, text, text, text)) -> text:
    return conn[2]

fn get_connection_mode(conn: (text, i64, text, text, text)) -> text:
    return conn[3]

fn get_connection_current_dir(conn: (text, i64, text, text, text)) -> text:
    return conn[4]

fn set_connection_mode(conn: (text, i64, text, text, text), mode: text) -> (text, i64, text, text, text):
    # Update connection mode
    val host = get_connection_host(conn)
    val port = get_connection_port(conn)
    val username = get_connection_username(conn)
    val current_dir = get_connection_current_dir(conn)
    return (host, port, username, mode, current_dir)

fn set_connection_current_dir(conn: (text, i64, text, text, text), directory: text) -> (text, i64, text, text, text):
    # Update current directory
    val host = get_connection_host(conn)
    val port = get_connection_port(conn)
    val username = get_connection_username(conn)
    val mode = get_connection_mode(conn)
    return (host, port, username, mode, directory)

fn is_ascii_mode(conn: (text, i64, text, text, text)) -> bool:
    val mode = get_connection_mode(conn)
    return mode == "ascii"

fn is_binary_mode(conn: (text, i64, text, text, text)) -> bool:
    val mode = get_connection_mode(conn)
    return mode == "binary"

# Transfer Mode Helpers
fn transfer_mode_to_command(mode: text) -> text:
    # Convert mode string to TYPE command
    if mode == "ascii":
        return cmd_type_ascii()
    if mode == "binary":
        return cmd_type_binary()
    return cmd_type_binary()

fn get_transfer_mode_ascii() -> text:
    return "ascii"

fn get_transfer_mode_binary() -> text:
    return "binary"

# Path Resolution
fn resolve_path(conn: (text, i64, text, text, text), path: text) -> text:
    # Resolve path relative to current directory
    if is_absolute_path(path):
        return normalize_path(path)

    val current_dir = get_connection_current_dir(conn)
    return join_paths(current_dir, path)

# Response Validation
fn validate_response_code(response: text, expected_code: i64) -> bool:
    val code = parse_response_code(response)
    return code == expected_code

fn validate_response_range(response: text, min_code: i64, max_code: i64) -> bool:
    val code = parse_response_code(response)
    return code >= min_code and code <= max_code

fn validate_success_response(response: text) -> bool:
    val code = parse_response_code(response)
    return is_success_response(code)

fn validate_error_response(response: text) -> bool:
    val code = parse_response_code(response)
    return is_error_response(code)

# Command Builders
fn build_rename_command(old_name: text, new_name: text) -> text:
    # Build RNFR + RNTO command sequence
    val cmd1 = cmd_rnfr(old_name)
    val cmd2 = cmd_rnto(new_name)
    return "{cmd1}{cmd2}"

fn build_upload_command(local_path: text, remote_path: text) -> text:
    # Build STOR command for upload
    val filename = get_filename(remote_path)
    return cmd_stor(filename)

fn build_download_command(remote_path: text) -> text:
    # Build RETR command for download
    val filename = get_filename(remote_path)
    return cmd_retr(filename)

fn build_delete_command(remote_path: text) -> text:
    # Build DELE command for delete
    val filename = get_filename(remote_path)
    return cmd_dele(filename)

# Directory Navigation
fn change_directory_absolute(conn: (text, i64, text, text, text), directory: text) -> (text, i64, text, text, text):
    # Change to absolute directory
    val normalized = normalize_path(directory)
    return set_connection_current_dir(conn, normalized)

fn change_directory_relative(conn: (text, i64, text, text, text), directory: text) -> (text, i64, text, text, text):
    # Change to relative directory
    val current_dir = get_connection_current_dir(conn)
    val new_dir = join_paths(current_dir, directory)
    return set_connection_current_dir(conn, new_dir)

fn change_directory_parent(conn: (text, i64, text, text, text)) -> (text, i64, text, text, text):
    # Change to parent directory
    val current_dir = get_connection_current_dir(conn)
    val parent_dir = get_parent_directory(current_dir)
    return set_connection_current_dir(conn, parent_dir)

fn change_directory_root(conn: (text, i64, text, text, text)) -> (text, i64, text, text, text):
    # Change to root directory
    return set_connection_current_dir(conn, "/")

# Utility Functions
fn format_response(code: i64, message: text) -> text:
    # Format response code and message
    return "{code} {message}"

fn is_valid_response(response: text) -> bool:
    # Check if response has valid format
    if response.length() < 3:
        return false
    val code = parse_response_code(response)
    return code > 0

fn extract_pwd_path(response: text) -> text:
    # Extract path from PWD response
    # Format: "257 "/path/to/dir" is current directory"
    val start_idx = response.index_of("\"")
    if not start_idx.?:
        return ""
    val end_idx = response.index_of("\"", start_idx + 1)
    if not end_idx.?:
        return ""

    val path = response.substring(start_idx + 1, end_idx)
    return path

fn extract_mkd_path(response: text) -> text:
    # Extract path from MKD response
    # Format: "257 "/path/to/dir" created"
    return extract_pwd_path(response)

# File Type Detection
fn is_text_file(filename: text) -> bool:
    # Check if filename represents a text file
    val lower = filename.to_lower()
    val result = lower.ends_with(".txt") or lower.ends_with(".log") or lower.ends_with(".md") or lower.ends_with(".html") or lower.ends_with(".xml") or lower.ends_with(".json")
    return result

fn is_binary_file(filename: text) -> bool:
    # Check if filename represents a binary file
    return not is_text_file(filename)

fn recommend_transfer_mode(filename: text) -> text:
    # Recommend transfer mode based on filename
    if is_text_file(filename):
        return get_transfer_mode_ascii()
    return get_transfer_mode_binary()

# Connection String Helpers
fn format_connection_string(host: text, port: i64, username: text) -> text:
    # Format connection string for display
    return "ftp://{username}@{host}:{port}"

fn parse_connection_string(conn_str: text) -> (text, i64, text):
    # Parse connection string into components
    # Format: "ftp://username@host:port"
    var working = conn_str

    # Remove protocol
    if working.starts_with("ftp://"):
        working = working.substring(6, working.length())

    # Extract username
    val at_idx = working.index_of("@")
    var username = "anonymous"
    if at_idx.?:
        username = working.substring(0, at_idx)
        working = working.substring(at_idx + 1, working.length())

    # Extract host and port
    val colon_idx = working.index_of(":")
    var host = working
    var port = 21

    if colon_idx.?:
        host = working.substring(0, colon_idx)
        val port_str = working.substring(colon_idx + 1, working.length())
        val port_val = port_str.to_i64()
        if port_val.?:
            port = port_val

    return (host, port, username)


# FILE: src/std/gzip_utils.spl
# Size: 1745 bytes, Lines: 48

# GZIP Utilities (Facade)
#
# This file was refactored from 1,891 lines into 8 focused modules.
# See compression/gzip/ directory for implementations.
#
# Backward compatible: All original imports still work.
#
# Architecture:
# - Pure Simple implementation of GZIP compression format (RFC 1952)
# - Implements DEFLATE algorithm (RFC 1951) combining LZ77 + Huffman coding
# - All implementations use concrete types (no generics at runtime)
# - Error handling uses Option/nil pattern (no exceptions)
# - Byte arrays represented as i64 lists
#
# Modules:
# - types.spl: Constants, block types, compression levels
# - crc.spl: CRC32 checksum calculation and verification
# - header.spl: GZIP header/footer parsing and creation
# - lz77.spl: LZ77 sliding window compression algorithm
# - huffman.spl: Huffman tree construction and coding
# - deflate.spl: DEFLATE compression (LZ77 + Huffman)
# - inflate.spl: DEFLATE decompression
# - stream.spl: Stream operations, bit packing, utilities
# - compress.spl: Main compression/decompression API
#
# Features:
# - GZIP header/footer handling (magic bytes, timestamps, OS flags)
# - DEFLATE compression (LZ77 matching + Huffman encoding)
# - CRC32 checksum calculation for data integrity
# - Multiple compression levels (0-9)
# - Fixed and dynamic Huffman codes
# - Sliding window dictionary (32KB)
# - Block-based processing
# - Stream operations for large data

# Import all submodules
mod compression.gzip.types
mod compression.gzip.crc
mod compression.gzip.header
mod compression.gzip.lz77
mod compression.gzip.huffman
mod compression.gzip.deflate
mod compression.gzip.inflate
mod compression.gzip.stream
mod compression.gzip.compress

# Re-export all public APIs for backward compatibility
export *


# FILE: src/std/hash_utils.spl
# Size: 13549 bytes, Lines: 592

# Hash Utilities
#
# Simple hash functions and checksums.
# Pure Simple implementation - no external dependencies.
#
# Note: Not cryptographically secure - for hash tables, checksums only.
#
# Functions:
# - String hashing: hash_string_djb2, hash_string_sdbm, hash_string_fnv
# - Integer hashing: hash_int, hash_combine
# - Checksums: checksum_add, checksum_xor, luhn_checksum
# - Array hashing: hash_array, hash_tuple
# - Hash tables: hash_bucket, hash_with_capacity

# ============================================================================
# String Hash Functions
# ============================================================================

fn hash_string_djb2(s: text) -> i64:
    """DJB2 hash algorithm for strings.

    Simple and fast hash function.
    Good distribution for hash tables.

    Example:
        hash_string_djb2("hello")  # 210714636441
    """
    var hash = 5381

    var i = 0
    while i < s.len():
        # hash * 33 + c
        hash = ((hash << 5) + hash) + s[i].ord()
        i = i + 1

    hash

fn hash_string_sdbm(s: text) -> i64:
    """SDBM hash algorithm for strings.

    Alternative to DJB2.

    Example:
        hash_string_sdbm("hello")  # Different from DJB2
    """
    var hash = 0

    var i = 0
    while i < s.len():
        # hash = hash * 65599 + c
        hash = s[i].ord() + (hash << 6) + (hash << 16) - hash
        i = i + 1

    hash

fn hash_string_fnv(s: text) -> i64:
    """FNV-1a hash algorithm for strings.

    Good distribution, widely used.

    Example:
        hash_string_fnv("hello")
    """
    var hash = 2166136261  # FNV offset basis (32-bit)

    var i = 0
    while i < s.len():
        hash = hash ^ s[i].ord()
        hash = hash * 16777619  # FNV prime
        i = i + 1

    hash

fn hash_string_simple(s: text) -> i64:
    """Simple polynomial rolling hash.

    Example:
        hash_string_simple("test")
    """
    var hash = 0
    val prime = 31

    var i = 0
    while i < s.len():
        hash = hash * prime + s[i].ord()
        i = i + 1

    hash

# ============================================================================
# Integer Hash Functions
# ============================================================================

fn hash_int(n: i64) -> i64:
    """Hash an integer.

    Uses integer mixing.

    Example:
        hash_int(12345)
    """
    var hash = n

    # Integer mixing
    hash = hash ^ (hash >> 16)
    hash = hash * 0x85ebca6b
    hash = hash ^ (hash >> 13)
    hash = hash * 0xc2b2ae35
    hash = hash ^ (hash >> 16)

    hash

fn hash_combine(hash1: i64, hash2: i64) -> i64:
    """Combine two hash values.

    Useful for hashing composite objects.

    Example:
        hash_combine(hash_int(1), hash_int(2))
    """
    # Based on boost::hash_combine
    hash1 ^ (hash2 + 0x9e3779b9 + (hash1 << 6) + (hash1 >> 2))

fn hash_combine_all(hashes):
    """Combine multiple hash values.

    Example:
        hash_combine_all([hash1, hash2, hash3])
    """
    if hashes.len() == 0:
        return 0

    var result = hashes[0]
    var i = 1

    while i < hashes.len():
        result = hash_combine(result, hashes[i])
        i = i + 1

    result

# ============================================================================
# Collection Hashing
# ============================================================================

fn hash_array(arr):
    """Hash an array of integers.

    Example:
        hash_array([1, 2, 3, 4, 5])
    """
    var hash = 0

    for elem in arr:
        hash = hash_combine(hash, hash_int(elem))

    hash

fn hash_string_array(arr):
    """Hash an array of strings.

    Example:
        hash_string_array(["hello", "world"])
    """
    var hash = 0

    for s in arr:
        hash = hash_combine(hash, hash_string_djb2(s))

    hash

fn hash_tuple2(pair):
    """Hash a 2-tuple.

    Example:
        hash_tuple2((1, 2))
    """
    val (a, b) = pair
    hash_combine(hash_int(a), hash_int(b))

fn hash_tuple3(triple):
    """Hash a 3-tuple.

    Example:
        hash_tuple3((1, 2, 3))
    """
    val (a, b, c) = triple
    hash_combine_all([hash_int(a), hash_int(b), hash_int(c)])

# ============================================================================
# Checksums
# ============================================================================

fn checksum_add(arr) -> i64:
    """Simple additive checksum.

    Example:
        checksum_add([1, 2, 3, 4])  # 10
    """
    var sum = 0
    for x in arr:
        sum = sum + x
    sum

fn checksum_xor(arr) -> i64:
    """XOR checksum.

    Example:
        checksum_xor([1, 2, 3, 4])  # 1^2^3^4 = 4
    """
    var result = 0
    for x in arr:
        result = result ^ x
    result

fn checksum_string_add(s: text) -> i64:
    """Additive checksum of string.

    Example:
        checksum_string_add("hello")
    """
    var sum = 0
    var i = 0

    while i < s.len():
        sum = sum + s[i].ord()
        i = i + 1

    sum

fn checksum_string_xor(s: text) -> i64:
    """XOR checksum of string.

    Example:
        checksum_string_xor("hello")
    """
    var result = 0
    var i = 0

    while i < s.len():
        result = result ^ s[i].ord()
        i = i + 1

    result

# ============================================================================
# Luhn Algorithm (Credit Card Checksum)
# ============================================================================

fn luhn_checksum(digits):
    """Calculate Luhn checksum.

    Used for credit card validation.

    Example:
        luhn_checksum([1, 2, 3, 4, 5, 6, 7, 8, 9])
    """
    var sum = 0
    var alternate = false

    var i = digits.len() - 1
    while i >= 0:
        var digit = digits[i]

        if alternate:
            digit = digit * 2
            if digit > 9:
                digit = digit - 9

        sum = sum + digit
        alternate = not alternate
        i = i - 1

    sum % 10

fn luhn_is_valid(digits):
    """Check if digits pass Luhn check.

    Example:
        luhn_is_valid([4, 5, 3, 9, 1, 4, 0, 8, 0, 0, 0, 0, 0, 0, 0, 3])  # Visa
    """
    luhn_checksum(digits) == 0

fn luhn_generate_check_digit(digits):
    """Generate Luhn check digit.

    Returns digit that makes sequence valid.

    Example:
        luhn_generate_check_digit([1, 2, 3, 4, 5, 6, 7, 8, 9])
    """
    var with_zero = digits
    with_zero.push(0)

    val sum_mod = luhn_checksum(with_zero)
    if sum_mod == 0:
        return 0

    10 - sum_mod

# ============================================================================
# CRC (Cyclic Redundancy Check) - Simple Version
# ============================================================================

fn crc8_simple(data):
    """Simple 8-bit CRC.

    Not standard CRC-8, but simple implementation.

    Example:
        crc8_simple([1, 2, 3, 4, 5])
    """
    var crc = 0

    for byte in data:
        crc = crc ^ byte

        var i = 0
        while i < 8:
            if (crc & 0x80) != 0:
                crc = (crc << 1) ^ 0x07  # Polynomial
            else:
                crc = crc << 1

            crc = crc & 0xFF  # Keep 8 bits
            i = i + 1

    crc

fn crc16_simple(data):
    """Simple 16-bit CRC.

    Example:
        crc16_simple([1, 2, 3, 4, 5])
    """
    var crc = 0xFFFF

    for byte in data:
        crc = crc ^ byte

        var i = 0
        while i < 8:
            if (crc & 0x0001) != 0:
                crc = (crc >> 1) ^ 0xA001  # Polynomial
            else:
                crc = crc >> 1
            i = i + 1

    crc

fn crc_string(s: text) -> i64:
    """CRC of string bytes.

    Example:
        crc_string("hello")
    """
    var bytes = []
    var i = 0

    while i < s.len():
        bytes.push(s[i].ord())
        i = i + 1

    crc16_simple(bytes)

# ============================================================================
# Hash Table Utilities
# ============================================================================

fn hash_bucket(hash_value: i64, num_buckets: i64) -> i64:
    """Map hash value to bucket index.

    Example:
        hash_bucket(12345, 100)  # 0-99
    """
    val abs_hash = if hash_value < 0: -hash_value else: hash_value
    abs_hash % num_buckets

fn hash_with_capacity(value, capacity: i64) -> i64:
    """Hash value for hash table with given capacity.

    For integer values.

    Example:
        hash_with_capacity(42, 1000)
    """
    hash_bucket(hash_int(value), capacity)

fn hash_string_with_capacity(s: text, capacity: i64) -> i64:
    """Hash string for hash table.

    Example:
        hash_string_with_capacity("key", 1000)
    """
    hash_bucket(hash_string_djb2(s), capacity)

fn find_next_prime(n: i64) -> i64:
    """Find next prime >= n (for hash table sizing).

    Simple trial division.

    Example:
        find_next_prime(100)  # 101
    """
    if n <= 2:
        return 2

    var candidate = if n % 2 == 0: n + 1 else: n

    while true:
        var is_prime = true
        var i = 3

        while i * i <= candidate:
            if candidate % i == 0:
                is_prime = false
                break
            i = i + 2

        if is_prime:
            return candidate

        candidate = candidate + 2

fn good_hash_capacity(expected_size: i64) -> i64:
    """Recommend good hash table capacity.

    Returns prime number ~1.5x expected size.

    Example:
        good_hash_capacity(100)  # ~150, prime
    """
    val target = expected_size + expected_size / 2
    find_next_prime(target)

# ============================================================================
# Collision Detection
# ============================================================================

fn count_collisions(hash_values, capacity: i64) -> i64:
    """Count hash collisions for given capacity.

    Example:
        count_collisions([hash1, hash2, hash3, ...], 100)
    """
    var buckets = []
    var i = 0
    while i < capacity:
        buckets.push(0)
        i = i + 1

    # Count items per bucket
    for hash_val in hash_values:
        val bucket = hash_bucket(hash_val, capacity)
        buckets[bucket] = buckets[bucket] + 1

    # Count collisions
    var collisions = 0
    for count in buckets:
        if count > 1:
            collisions = collisions + (count - 1)

    collisions

fn hash_distribution_score(hash_values, capacity: i64) -> i64:
    """Score hash distribution quality (lower is better).

    Returns sum of squared bucket sizes.

    Example:
        hash_distribution_score(hashes, 100)
    """
    var buckets = []
    var i = 0
    while i < capacity:
        buckets.push(0)
        i = i + 1

    for hash_val in hash_values:
        val bucket = hash_bucket(hash_val, capacity)
        buckets[bucket] = buckets[bucket] + 1

    var score = 0
    for count in buckets:
        score = score + count * count

    score

# ============================================================================
# Rolling Hash
# ============================================================================

fn rolling_hash_init(s: text, window_size: i64):
    """Initialize rolling hash.

    Returns (hash, base, first_char_code).

    Example:
        val (hash, base, first) = rolling_hash_init("hello", 3)
    """
    val base = 31
    var hash = 0
    var power = 1

    var i = 0
    while i < window_size and i < s.len():
        hash = hash * base + s[i].ord()
        if i < window_size - 1:
            power = power * base
        i = i + 1

    (hash, power, if s.len() > 0: s[0].ord() else: 0)

fn rolling_hash_slide(current_hash: i64, power: i64, old_char: i64, new_char: i64) -> i64:
    """Slide rolling hash window.

    Example:
        val new_hash = rolling_hash_slide(hash, power, 'h', 'o')
    """
    val base = 31
    (current_hash - old_char * power) * base + new_char

# ============================================================================
# Consistent Hashing
# ============================================================================

fn consistent_hash(key: i64, num_servers: i64) -> i64:
    """Simple consistent hashing.

    Maps key to server with minimal disruption on server changes.

    Example:
        consistent_hash(12345, 10)  # Server 0-9
    """
    var h = hash_int(key)
    h = h % (num_servers * 100)  # Create more hash points

    h / 100  # Map to server

fn jump_consistent_hash(key: i64, num_buckets: i64) -> i64:
    """Jump consistent hash algorithm.

    Better than simple consistent hashing.

    Example:
        jump_consistent_hash(12345, 10)
    """
    var k = key
    var b = -1
    var j = 0

    while j < num_buckets:
        b = j
        k = k * 2862933555777941757 + 1
        j = ((b + 1) * (4294967296 / ((k >> 33) + 1)))

    b

# ============================================================================
# Hash Utilities
# ============================================================================

fn hash_equals(h1: i64, h2: i64):
    """Check if two hash values are equal.

    Example:
        hash_equals(hash1, hash2)
    """
    h1 == h2

fn hash_compare(h1: i64, h2: i64) -> i64:
    """Compare two hash values.

    Returns: -1 if h1 < h2, 0 if equal, 1 if h1 > h2.

    Example:
        hash_compare(hash1, hash2)
    """
    if h1 < h2:
        return -1
    elif h1 > h2:
        return 1
    else:
        return 0

fn verify_checksum(data, expected_checksum: i64):
    """Verify checksum matches data.

    Example:
        verify_checksum([1, 2, 3], 6)  # true for additive
    """
    checksum_add(data) == expected_checksum


# FILE: src/std/html_parser_utils.spl
# Size: 680 bytes, Lines: 27

# HTML Parser Utilities (Facade)
#
# This file was refactored from 1,688 lines into 7 focused modules.
# See html/ directory for implementations.
#
# Backward compatible: All original imports still work.
#
# Categories:
# - Types: HTML node types, document structure
# - Lexer: HTML tokenization
# - Parser: HTML parsing to DOM
# - DOM: DOM tree operations
# - Entities: HTML entity encoding/decoding
# - Serializer: HTML serialization
# - Utilities: Common HTML operations

# Import all submodules
mod html.types
mod html.lexer
mod html.parser
mod html.dom
mod html.entities
mod html.serializer
mod html.utilities

# Re-export all public APIs for backward compatibility
export *


# FILE: src/std/json_parser_utils.spl
# Size: 1468 bytes, Lines: 40

# JSON Parser and Serializer Utilities (Facade)
#
# This file was refactored from 2,240 lines into 8 focused modules.
# See json/ directory for implementations.
#
# Backward compatible: All original imports still work.
#
# Value Representation:
#   JSON values are tuples: (type, value)
#   - ("object", {text: json_value})  # Object with key-value pairs
#   - ("array", [json_value])         # Array of values
#   - ("string", text)                # String value
#   - ("number", f64)                 # Number value
#   - ("boolean", bool)               # Boolean value
#   - ("null", nil)                   # Null value
#
# Categories:
# - Types: Constructors, type checking, type conversion
# - Parser: Tokenization, parsing of JSON text
# - Serializer: JSON serialization with formatting options
# - Object ops: get, set, has, remove, keys, values, entries, merge, map, filter
# - Array ops: get, set, append, insert, remove, map, filter, reduce, slice
# - Path ops: JSONPath-like navigation (get_path, set_path, has_path, delete_path)
# - Validation: Schema validation, deep comparison, deep clone
# - Utilities: Deep merge, diff/patch, flatten/unflatten
#
# All functions are pure Simple - no external dependencies required.

# Import all submodules
mod json.types
mod json.parser
mod json.serializer
mod json.object_ops
mod json.array_ops
mod json.path_ops
mod json.validation
mod json.utilities

# Re-export all public APIs for backward compatibility
export *


# FILE: src/std/list_utils.spl
# Size: 6901 bytes, Lines: 241

# List Utilities Module
#
# Comprehensive list manipulation utilities for i64 lists.
# Includes chunking, rotation, deduplication, flattening, and more.
#
# Categories:
# - Basic: reverse_list, take, drop
# - Chunking: chunk, windows
# - Merging: interleave, flatten, intersperse
# - Rotation: rotate_left, rotate_right
# - Deduplication: dedup (consecutive), dedup_all (all occurrences)
# - Comparison: is_sorted, list_equals
#
# All functions are pure Simple - no external dependencies required.

# ============================================================================
# Exports
# ============================================================================

export reverse_list, take, drop
export chunk, windows
export interleave, flatten, intersperse
export rotate_left, rotate_right
export dedup, dedup_all
export is_sorted, list_equals

# ============================================================================
# Basic List Operations
# ============================================================================

fn reverse_list(list: [i64]) -> [i64]:
    """Reverse a list.

    Example:
        reverse_list([1, 2, 3, 4])  # [4, 3, 2, 1]
    """
    var result: [i64] = []
    for i in 0..list.len():
        result = [list[list.len() - 1 - i]] + result
    result

fn take(list: [i64], n: i64) -> [i64]:
    """Take first n elements from list.

    Example:
        take([1, 2, 3, 4, 5], n=3)  # [1, 2, 3]
    """
    var result: [i64] = []
    val count = if n < list.len(): n else: list.len()
    for i in 0..count:
        result = result + [list[i]]
    result

fn drop(list: [i64], n: i64) -> [i64]:
    """Drop first n elements from list.

    Example:
        drop([1, 2, 3, 4, 5], n=2)  # [3, 4, 5]
    """
    if n >= list.len():
        return []
    var result: [i64] = []
    for i in n..list.len():
        result = result + [list[i]]
    result

# ============================================================================
# Chunking Operations
# ============================================================================

fn chunk(list: [i64], size: i64) -> [[i64]]:
    """Split list into chunks of given size. Last chunk may be smaller.

    Example:
        chunk([1, 2, 3, 4, 5], size=2)  # [[1, 2], [3, 4], [5]]
    """
    if size <= 0:
        return []
    var result: [[i64]] = []
    var current: [i64] = []
    for i in 0..list.len():
        current = current + [list[i]]
        if current.len() == size:
            result = result + [current]
            current = []
    if current.len() > 0:
        result = result + [current]
    result

fn windows(list: [i64], size: i64) -> [[i64]]:
    """Create sliding windows of given size over the list.

    Example:
        windows([1, 2, 3, 4], size=2)  # [[1, 2], [2, 3], [3, 4]]
    """
    if size > list.len() or size <= 0:
        return []
    var result: [[i64]] = []
    for i in 0..(list.len() - size + 1):
        var window: [i64] = []
        for j in 0..size:
            window = window + [list[i + j]]
        result = result + [window]
    result

# ============================================================================
# Merging and Interleaving
# ============================================================================

fn interleave(a: [i64], b: [i64]) -> [i64]:
    """Interleave two lists, alternating elements.

    Example:
        interleave(a=[1, 2, 3], b=[4, 5, 6])  # [1, 4, 2, 5, 3, 6]
    """
    var result: [i64] = []
    val max_len = if a.len() > b.len(): a.len() else: b.len()
    for i in 0..max_len:
        if i < a.len():
            result = result + [a[i]]
        if i < b.len():
            result = result + [b[i]]
    result

fn flatten(nested: [[i64]]) -> [i64]:
    """Flatten a nested list (one level deep).

    Example:
        flatten([[1, 2], [3, 4], [5]])  # [1, 2, 3, 4, 5]
    """
    var result: [i64] = []
    for inner in nested:
        for x in inner:
            result = result + [x]
    result

fn intersperse(list: [i64], sep: i64) -> [i64]:
    """Insert separator between all elements.

    Example:
        intersperse([1, 2, 3], sep=0)  # [1, 0, 2, 0, 3]
    """
    if list.len() <= 1:
        return list
    var result: [i64] = [list[0]]
    for i in 1..list.len():
        result = result + [sep, list[i]]
    result

# ============================================================================
# Rotation
# ============================================================================

fn rotate_left(list: [i64], n: i64) -> [i64]:
    """Rotate list left by n positions.

    Example:
        rotate_left([1, 2, 3, 4, 5], n=2)  # [3, 4, 5, 1, 2]
    """
    if list.len() == 0:
        return []
    val shift = n % list.len()
    drop(list, shift) + take(list, shift)

fn rotate_right(list: [i64], n: i64) -> [i64]:
    """Rotate list right by n positions.

    Example:
        rotate_right([1, 2, 3, 4, 5], n=2)  # [4, 5, 1, 2, 3]
    """
    if list.len() == 0:
        return []
    val shift = n % list.len()
    rotate_left(list, list.len() - shift)

# ============================================================================
# Deduplication
# ============================================================================

fn dedup(list: [i64]) -> [i64]:
    """Remove consecutive duplicate elements.

    Example:
        dedup([1, 1, 2, 2, 3, 3])  # [1, 2, 3]
        dedup([1, 2, 1, 2])        # [1, 2, 1, 2] (non-consecutive kept)
    """
    if list.len() == 0:
        return []
    var result: [i64] = [list[0]]
    for i in 1..list.len():
        if list[i] != list[i - 1]:
            result = result + [list[i]]
    result

fn dedup_all(list: [i64]) -> [i64]:
    """Remove all duplicate elements, keeping first occurrence.

    Example:
        dedup_all([1, 2, 1, 3, 2])  # [1, 2, 3]
    """
    var result: [i64] = []
    for x in list:
        var found = false
        for y in result:
            if x == y:
                found = true
        if not found:
            result = result + [x]
    result

# ============================================================================
# Comparison and Validation
# ============================================================================

fn is_sorted(list: [i64]) -> bool:
    """Check if list is sorted in ascending order.

    Example:
        is_sorted([1, 2, 3, 4])  # true
        is_sorted([1, 3, 2])     # false
    """
    if list.len() <= 1:
        return true
    for i in 0..(list.len() - 1):
        if list[i] > list[i + 1]:
            return false
    true

fn list_equals(a: [i64], b: [i64]) -> bool:
    """Check if two lists are equal element-wise.

    Example:
        list_equals(a=[1, 2, 3], b=[1, 2, 3])  # true
        list_equals(a=[1, 2], b=[1, 2, 3])     # false
    """
    if a.len() != b.len():
        return false
    for i in 0..a.len():
        if a[i] != b[i]:
            return false
    true


# FILE: src/std/matrix_utils.spl
# Size: 15538 bytes, Lines: 719

# Matrix Utilities
#
# Matrix operations and linear algebra utilities.
# Pure Simple implementation - no external dependencies.
#
# Represents matrices as 2D arrays (array of arrays).
# Matrix operations use integer arithmetic only.
#
# Functions:
# - Construction: create_matrix, identity_matrix, zero_matrix
# - Properties: dimensions, is_square, trace
# - Basic ops: add, subtract, multiply, scalar_multiply
# - Transformation: transpose, rotate, flip
# - Access: get_row, get_column, get_element
# - Analysis: determinant, is_symmetric, diagonal

# ============================================================================
# Matrix Construction
# ============================================================================

fn create_matrix(rows: i64, cols: i64, initial_value):
    """Create matrix filled with initial value.

    Example:
        create_matrix(3, 3, 0)  # 3x3 zero matrix
    """
    var matrix = []
    var i = 0

    while i < rows:
        var row = []
        var j = 0
        while j < cols:
            row.push(initial_value)
            j = j + 1
        matrix.push(row)
        i = i + 1

    matrix

fn zero_matrix(rows: i64, cols: i64):
    """Create zero matrix.

    Example:
        zero_matrix(3, 3)  # [[0,0,0], [0,0,0], [0,0,0]]
    """
    create_matrix(rows, cols, 0)

fn identity_matrix(n: i64):
    """Create n×n identity matrix.

    Example:
        identity_matrix(3)
        # [[1,0,0], [0,1,0], [0,0,1]]
    """
    var matrix = zero_matrix(n, n)
    var i = 0

    while i < n:
        matrix[i][i] = 1
        i = i + 1

    matrix

fn diagonal_matrix(values):
    """Create diagonal matrix from values.

    Example:
        diagonal_matrix([1, 2, 3])
        # [[1,0,0], [0,2,0], [0,0,3]]
    """
    val n = values.len()
    var matrix = zero_matrix(n, n)
    var i = 0

    while i < n:
        matrix[i][i] = values[i]
        i = i + 1

    matrix

fn from_rows(rows):
    """Create matrix from array of row arrays.

    Example:
        from_rows([[1,2], [3,4]])
    """
    rows

fn from_columns(cols):
    """Create matrix from array of column arrays.

    Example:
        from_columns([[1,3], [2,4]])  # [[1,2], [3,4]]
    """
    if cols.len() == 0:
        return []

    val rows = cols[0].len()
    val columns = cols.len()

    var matrix = []
    var i = 0

    while i < rows:
        var row = []
        var j = 0
        while j < columns:
            row.push(cols[j][i])
            j = j + 1
        matrix.push(row)
        i = i + 1

    matrix

# ============================================================================
# Matrix Properties
# ============================================================================

fn dimensions(matrix):
    """Get matrix dimensions (rows, cols).

    Example:
        dimensions([[1,2,3], [4,5,6]])  # (2, 3)
    """
    if matrix.len() == 0:
        return (0, 0)

    (matrix.len(), matrix[0].len())

fn is_square(matrix):
    """Check if matrix is square.

    Example:
        is_square([[1,2], [3,4]])  # true
    """
    val (rows, cols) = dimensions(matrix)
    rows == cols and rows > 0

fn trace(matrix):
    """Calculate trace (sum of diagonal elements).

    Only for square matrices.

    Example:
        trace([[1,2], [3,4]])  # 5
    """
    if not is_square(matrix):
        return nil

    var sum = 0
    var i = 0

    while i < matrix.len():
        sum = sum + matrix[i][i]
        i = i + 1

    sum

fn is_symmetric(matrix):
    """Check if matrix is symmetric (M = M^T).

    Example:
        is_symmetric([[1,2], [2,1]])  # true
    """
    if not is_square(matrix):
        return false

    val n = matrix.len()
    var i = 0

    while i < n:
        var j = i + 1
        while j < n:
            if matrix[i][j] != matrix[j][i]:
                return false
            j = j + 1
        i = i + 1

    true

fn is_diagonal(matrix):
    """Check if matrix is diagonal.

    Example:
        is_diagonal([[1,0], [0,2]])  # true
    """
    if not is_square(matrix):
        return false

    val n = matrix.len()
    var i = 0

    while i < n:
        var j = 0
        while j < n:
            if i != j and matrix[i][j] != 0:
                return false
            j = j + 1
        i = i + 1

    true

# ============================================================================
# Matrix Access
# ============================================================================

fn get_element(matrix, row: i64, col: i64):
    """Get element at position.

    Example:
        get_element([[1,2], [3,4]], 1, 0)  # 3
    """
    if row < 0 or row >= matrix.len():
        return nil
    if col < 0 or col >= matrix[0].len():
        return nil

    matrix[row][col]

fn get_row(matrix, row: i64):
    """Get row as array.

    Example:
        get_row([[1,2], [3,4]], 1)  # [3, 4]
    """
    if row < 0 or row >= matrix.len():
        return nil

    matrix[row]

fn get_column(matrix, col: i64):
    """Get column as array.

    Example:
        get_column([[1,2], [3,4]], 0)  # [1, 3]
    """
    if matrix.len() == 0:
        return nil
    if col < 0 or col >= matrix[0].len():
        return nil

    var column = []
    for row in matrix:
        column.push(row[col])

    column

fn get_diagonal(matrix):
    """Get main diagonal as array.

    Example:
        get_diagonal([[1,2], [3,4]])  # [1, 4]
    """
    if not is_square(matrix):
        return nil

    var diagonal = []
    var i = 0

    while i < matrix.len():
        diagonal.push(matrix[i][i])
        i = i + 1

    diagonal

# ============================================================================
# Matrix Basic Operations
# ============================================================================

fn add_matrices(m1, m2):
    """Add two matrices.

    Matrices must have same dimensions.

    Example:
        add_matrices([[1,2], [3,4]], [[5,6], [7,8]])
        # [[6,8], [10,12]]
    """
    val (rows1, cols1) = dimensions(m1)
    val (rows2, cols2) = dimensions(m2)

    if rows1 != rows2 or cols1 != cols2:
        return nil

    var result = []
    var i = 0

    while i < rows1:
        var row = []
        var j = 0
        while j < cols1:
            row.push(m1[i][j] + m2[i][j])
            j = j + 1
        result.push(row)
        i = i + 1

    result

fn subtract_matrices(m1, m2):
    """Subtract two matrices.

    Example:
        subtract_matrices([[5,6], [7,8]], [[1,2], [3,4]])
        # [[4,4], [4,4]]
    """
    val (rows1, cols1) = dimensions(m1)
    val (rows2, cols2) = dimensions(m2)

    if rows1 != rows2 or cols1 != cols2:
        return nil

    var result = []
    var i = 0

    while i < rows1:
        var row = []
        var j = 0
        while j < cols1:
            row.push(m1[i][j] - m2[i][j])
            j = j + 1
        result.push(row)
        i = i + 1

    result

fn scalar_multiply(matrix, scalar):
    """Multiply matrix by scalar.

    Example:
        scalar_multiply([[1,2], [3,4]], 2)
        # [[2,4], [6,8]]
    """
    var result = []

    for row in matrix:
        var new_row = []
        for elem in row:
            new_row.push(elem * scalar)
        result.push(new_row)

    result

fn multiply_matrices(m1, m2):
    """Multiply two matrices.

    m1 must have cols equal to m2 rows.

    Example:
        multiply_matrices([[1,2], [3,4]], [[5,6], [7,8]])
        # [[19,22], [43,50]]
    """
    val (rows1, cols1) = dimensions(m1)
    val (rows2, cols2) = dimensions(m2)

    if cols1 != rows2:
        return nil

    var result = []
    var i = 0

    while i < rows1:
        var row = []
        var j = 0
        while j < cols2:
            var sum = 0
            var k = 0
            while k < cols1:
                sum = sum + (m1[i][k] * m2[k][j])
                k = k + 1
            row.push(sum)
            j = j + 1
        result.push(row)
        i = i + 1

    result

# ============================================================================
# Matrix Transformations
# ============================================================================

fn transpose(matrix):
    """Transpose matrix (swap rows and columns).

    Example:
        transpose([[1,2,3], [4,5,6]])
        # [[1,4], [2,5], [3,6]]
    """
    val (rows, cols) = dimensions(matrix)
    if rows == 0 or cols == 0:
        return []

    var result = []
    var j = 0

    while j < cols:
        var column = []
        var i = 0
        while i < rows:
            column.push(matrix[i][j])
            i = i + 1
        result.push(column)
        j = j + 1

    result

fn flip_horizontal(matrix):
    """Flip matrix horizontally (reverse rows).

    Example:
        flip_horizontal([[1,2], [3,4]])
        # [[3,4], [1,2]]
    """
    var result = []
    var i = matrix.len() - 1

    while i >= 0:
        result.push(matrix[i])
        i = i - 1

    result

fn flip_vertical(matrix):
    """Flip matrix vertically (reverse columns).

    Example:
        flip_vertical([[1,2], [3,4]])
        # [[2,1], [4,3]]
    """
    var result = []

    for row in matrix:
        var new_row = []
        var i = row.len() - 1
        while i >= 0:
            new_row.push(row[i])
            i = i - 1
        result.push(new_row)

    result

fn rotate_90_clockwise(matrix):
    """Rotate matrix 90 degrees clockwise.

    Example:
        rotate_90_clockwise([[1,2], [3,4]])
        # [[3,1], [4,2]]
    """
    val transposed = transpose(matrix)
    flip_vertical(transposed)

fn rotate_90_counterclockwise(matrix):
    """Rotate matrix 90 degrees counterclockwise.

    Example:
        rotate_90_counterclockwise([[1,2], [3,4]])
        # [[2,4], [1,3]]
    """
    val transposed = transpose(matrix)
    flip_horizontal(transposed)

# ============================================================================
# Submatrix Operations
# ============================================================================

fn submatrix(matrix, start_row: i64, start_col: i64, num_rows: i64, num_cols: i64):
    """Extract submatrix.

    Example:
        submatrix([[1,2,3], [4,5,6], [7,8,9]], 1, 1, 2, 2)
        # [[5,6], [8,9]]
    """
    var result = []
    var i = 0

    while i < num_rows and (start_row + i) < matrix.len():
        var row = []
        var j = 0
        while j < num_cols and (start_col + j) < matrix[0].len():
            row.push(matrix[start_row + i][start_col + j])
            j = j + 1
        result.push(row)
        i = i + 1

    result

fn minor_matrix(matrix, exclude_row: i64, exclude_col: i64):
    """Get minor (matrix with row and column removed).

    Example:
        minor_matrix([[1,2,3], [4,5,6], [7,8,9]], 0, 0)
        # [[5,6], [8,9]]
    """
    var result = []
    var i = 0

    while i < matrix.len():
        if i != exclude_row:
            var row = []
            var j = 0
            while j < matrix[0].len():
                if j != exclude_col:
                    row.push(matrix[i][j])
                j = j + 1
            result.push(row)
        i = i + 1

    result

# ============================================================================
# Determinant
# ============================================================================

fn determinant(matrix):
    """Calculate determinant of square matrix.

    Uses cofactor expansion. Only works for small matrices.

    Example:
        determinant([[1,2], [3,4]])  # -2
    """
    if not is_square(matrix):
        return nil

    val n = matrix.len()

    if n == 1:
        return matrix[0][0]

    if n == 2:
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]

    # Cofactor expansion along first row
    var det = 0
    var j = 0

    while j < n:
        val minor = minor_matrix(matrix, 0, j)
        val cofactor = if j % 2 == 0: 1 else: -1
        val minor_det = determinant(minor)

        if minor_det.?:
            det = det + cofactor * matrix[0][j] * minor_det

        j = j + 1

    det

# ============================================================================
# Matrix Vector Operations
# ============================================================================

fn matrix_vector_multiply(matrix, vector):
    """Multiply matrix by column vector.

    Example:
        matrix_vector_multiply([[1,2], [3,4]], [5, 6])
        # [17, 39]
    """
    val (rows, cols) = dimensions(matrix)

    if cols != vector.len():
        return nil

    var result = []
    var i = 0

    while i < rows:
        var sum = 0
        var j = 0
        while j < cols:
            sum = sum + matrix[i][j] * vector[j]
            j = j + 1
        result.push(sum)
        i = i + 1

    result

fn dot_product(v1, v2):
    """Calculate dot product of two vectors.

    Example:
        dot_product([1, 2, 3], [4, 5, 6])  # 32
    """
    if v1.len() != v2.len():
        return nil

    var sum = 0
    var i = 0

    while i < v1.len():
        sum = sum + v1[i] * v2[i]
        i = i + 1

    sum

fn outer_product(v1, v2):
    """Calculate outer product of two vectors.

    Returns matrix.

    Example:
        outer_product([1, 2], [3, 4])
        # [[3,4], [6,8]]
    """
    var result = []

    for a in v1:
        var row = []
        for b in v2:
            row.push(a * b)
        result.push(row)

    result

# ============================================================================
# Matrix Comparison
# ============================================================================

fn matrices_equal(m1, m2):
    """Check if two matrices are equal.

    Example:
        matrices_equal([[1,2], [3,4]], [[1,2], [3,4]])  # true
    """
    val (rows1, cols1) = dimensions(m1)
    val (rows2, cols2) = dimensions(m2)

    if rows1 != rows2 or cols1 != cols2:
        return false

    var i = 0
    while i < rows1:
        var j = 0
        while j < cols1:
            if m1[i][j] != m2[i][j]:
                return false
            j = j + 1
        i = i + 1

    true

# ============================================================================
# Matrix Utilities
# ============================================================================

fn matrix_power(matrix, n: i64):
    """Raise square matrix to power n.

    Example:
        matrix_power([[1,1], [1,0]], 2)
        # [[2,1], [1,1]] (Fibonacci)
    """
    if not is_square(matrix):
        return nil

    if n == 0:
        return identity_matrix(matrix.len())

    if n == 1:
        return matrix

    var result = matrix
    var i = 1

    while i < n:
        result = multiply_matrices(result, matrix)
        i = i + 1

    result

fn matrix_sum(matrix):
    """Sum all elements in matrix.

    Example:
        matrix_sum([[1,2], [3,4]])  # 10
    """
    var sum = 0

    for row in matrix:
        for elem in row:
            sum = sum + elem

    sum

fn reshape(matrix, new_rows: i64, new_cols: i64):
    """Reshape matrix to new dimensions.

    Total elements must match.

    Example:
        reshape([[1,2,3,4]], 2, 2)  # [[1,2], [3,4]]
    """
    val (rows, cols) = dimensions(matrix)
    val total = rows * cols

    if total != new_rows * new_cols:
        return nil

    # Flatten
    var flat = []
    for row in matrix:
        for elem in row:
            flat.push(elem)

    # Reshape
    var result = []
    var i = 0

    while i < new_rows:
        var row = []
        var j = 0
        while j < new_cols:
            row.push(flat[i * new_cols + j])
            j = j + 1
        result.push(row)
        i = i + 1

    result


# FILE: src/std/predicate_utils.spl
# Size: 14418 bytes, Lines: 578

# Predicate Utilities
#
# Helper functions for working with predicates (boolean functions).
# Pure Simple implementation - no external dependencies.
#
# Provides predicate combinators, logical operations, and utilities
# for composing and transforming boolean functions.
#
# Functions:
# - Combinators: and_pred, or_pred, not_pred, xor_pred
# - Composition: all_of, any_of, none_of
# - Factories: always_true, always_false, equals_pred
# - Utilities: negate, memoize_pred, count_satisfying

# ============================================================================
# Basic Predicate Combinators
# ============================================================================

fn and_pred(pred1, pred2):
    """Combine two predicates with AND.

    Returns a new predicate that is true when both are true.

    Example:
        val is_positive = \\x: x > 0
        val is_small = \\x: x < 10
        val pred = and_pred(is_positive, is_small)
        pred(5)  # true
        pred(-1)  # false
        pred(15)  # false
    """
    \\x: pred1(x) and pred2(x)

fn or_pred(pred1, pred2):
    """Combine two predicates with OR.

    Returns a new predicate that is true when either is true.

    Example:
        val is_zero = \\x: x == 0
        val is_positive = \\x: x > 0
        val pred = or_pred(is_zero, is_positive)
        pred(5)  # true
        pred(0)  # true
        pred(-1)  # false
    """
    \\x: pred1(x) or pred2(x)

fn not_pred(pred):
    """Negate a predicate.

    Returns a new predicate that is true when pred is false.

    Example:
        val is_positive = \\x: x > 0
        val is_not_positive = not_pred(is_positive)
        is_not_positive(-1)  # true
        is_not_positive(1)  # false
    """
    \\x: not pred(x)

fn xor_pred(pred1, pred2):
    """Combine two predicates with XOR.

    Returns true when exactly one predicate is true.

    Example:
        val is_even = \\x: x % 2 == 0
        val is_small = \\x: x < 10
        val pred = xor_pred(is_even, is_small)
        pred(5)  # true (small but odd)
        pred(12)  # true (even but not small)
        pred(4)  # false (both true)
    """
    \\x:
        val p1 = pred1(x)
        val p2 = pred2(x)
        (p1 or p2) and not (p1 and p2)

fn implies_pred(pred1, pred2):
    """Logical implication: pred1 implies pred2.

    Returns false only when pred1 is true and pred2 is false.

    Example:
        val is_student = \\x: x.is_student
        val has_discount = \\x: x.has_discount
        val pred = implies_pred(is_student, has_discount)
        # "If student, then must have discount"
    """
    \\x: not pred1(x) or pred2(x)

# ============================================================================
# Multiple Predicate Combinators
# ============================================================================

fn all_of(preds):
    """Combine multiple predicates with AND.

    Returns true when all predicates are true.

    Example:
        val pred = all_of([
            \\x: x > 0,
            \\x: x < 10,
            \\x: x % 2 == 0
        ])
        pred(4)  # true
        pred(11)  # false
    """
    \\x:
        for pred in preds:
            if not pred(x):
                return false
        true

fn any_of(preds):
    """Combine multiple predicates with OR.

    Returns true when any predicate is true.

    Example:
        val pred = any_of([
            \\x: x == 0,
            \\x: x > 100,
            \\x: x < -100
        ])
        pred(0)  # true
        pred(150)  # true
        pred(50)  # false
    """
    \\x:
        for pred in preds:
            if pred(x):
                return true
        false

fn none_of(preds):
    """Returns true when none of the predicates are true.

    Example:
        val pred = none_of([
            \\x: x < 0,
            \\x: x > 100
        ])
        pred(50)  # true (in valid range)
        pred(-1)  # false
    """
    \\x:
        for pred in preds:
            if pred(x):
                return false
        true

fn exactly_n_of(preds, n: i64):
    """Returns true when exactly n predicates are true.

    Example:
        val pred = exactly_n_of([
            \\x: x > 0,
            \\x: x % 2 == 0,
            \\x: x < 10
        ], 2)
        pred(4)  # true (positive, even, small - 3 match, fails)
        pred(6)  # true (positive, even, small - 3 match, fails)
        pred(11)  # true (positive, odd, big - 1 match, fails)
        pred(-2)  # true (negative, even, small - 2 match, succeeds)
    """
    \\x:
        var count = 0
        for pred in preds:
            if pred(x):
                count = count + 1
        count == n

fn at_least_n_of(preds, n: i64):
    """Returns true when at least n predicates are true.

    Example:
        val pred = at_least_n_of([
            \\x: x > 0,
            \\x: x % 2 == 0,
            \\x: x < 10
        ], 2)
    """
    \\x:
        var count = 0
        for pred in preds:
            if pred(x):
                count = count + 1
                if count >= n:
                    return true
        false

fn at_most_n_of(preds, n: i64):
    """Returns true when at most n predicates are true.

    Example:
        val pred = at_most_n_of([
            \\x: x > 0,
            \\x: x % 2 == 0,
            \\x: x < 10
        ], 1)
    """
    \\x:
        var count = 0
        for pred in preds:
            if pred(x):
                count = count + 1
                if count > n:
                    return false
        true

# ============================================================================
# Predicate Factories
# ============================================================================

fn always_true():
    """Create a predicate that always returns true.

    Example:
        val pred = always_true()
        pred(anything)  # true
    """
    \\x: true

fn always_false():
    """Create a predicate that always returns false.

    Example:
        val pred = always_false()
        pred(anything)  # false
    """
    \\x: false

fn equals_pred(value):
    """Create a predicate that checks equality with value.

    Example:
        val is_five = equals_pred(5)
        is_five(5)  # true
        is_five(3)  # false
    """
    \\x: x == value

fn not_equals_pred(value):
    """Create a predicate that checks inequality with value.

    Example:
        val is_not_zero = not_equals_pred(0)
        is_not_zero(5)  # true
        is_not_zero(0)  # false
    """
    \\x: x != value

fn in_set_pred(values):
    """Create a predicate that checks if value is in set.

    Example:
        val is_vowel = in_set_pred(["a", "e", "i", "o", "u"])
        is_vowel("a")  # true
        is_vowel("b")  # false
    """
    \\x:
        for value in values:
            if x == value:
                return true
        false

fn not_in_set_pred(values):
    """Create a predicate that checks if value is not in set.

    Example:
        val is_consonant = not_in_set_pred(["a", "e", "i", "o", "u"])
    """
    \\x:
        for value in values:
            if x == value:
                return false
        true

# ============================================================================
# Numeric Range Predicates
# ============================================================================

fn greater_than_pred(threshold):
    """Create predicate for > threshold.

    Example:
        val is_big = greater_than_pred(100)
        is_big(150)  # true
    """
    \\x: x > threshold

fn less_than_pred(threshold):
    """Create predicate for < threshold.

    Example:
        val is_small = less_than_pred(10)
        is_small(5)  # true
    """
    \\x: x < threshold

fn between_pred(lower, upper):
    """Create predicate for lower <= x <= upper.

    Example:
        val is_in_range = between_pred(1, 10)
        is_in_range(5)  # true
        is_in_range(15)  # false
    """
    \\x: x >= lower and x <= upper

fn between_exclusive_pred(lower, upper):
    """Create predicate for lower < x < upper.

    Example:
        val is_in_range = between_exclusive_pred(1, 10)
        is_in_range(5)  # true
        is_in_range(1)  # false
    """
    \\x: x > lower and x < upper

# ============================================================================
# Key-Based Predicates
# ============================================================================

fn by_key_pred(key_fn, pred):
    """Transform predicate to work on key of value.

    Example:
        val has_long_name = by_key_pred(
            \\person: person.name,
            \\name: name.len() > 10
        )
    """
    \\x: pred(key_fn(x))

fn equals_by_key(key_fn, value):
    """Check if key equals value.

    Example:
        val is_named_alice = equals_by_key(
            \\person: person.name,
            "Alice"
        )
    """
    \\x: key_fn(x) == value

# ============================================================================
# Predicate Utilities
# ============================================================================

fn negate(pred):
    """Alias for not_pred.

    Example:
        val is_odd = negate(\\x: x % 2 == 0)
    """
    not_pred(pred)

fn count_satisfying(arr, pred):
    """Count how many elements satisfy predicate.

    Example:
        count_satisfying([1, 2, 3, 4, 5], \\x: x % 2 == 0)  # 2
    """
    var count = 0
    for item in arr:
        if pred(item):
            count = count + 1
    count

fn find_satisfying(arr, pred):
    """Find first element satisfying predicate.

    Returns Some(element) or nil.

    Example:
        find_satisfying([1, 2, 3, 4], \\x: x > 2)  # Some(3)
    """
    for item in arr:
        if pred(item):
            return Some(item)
    nil

fn find_index_satisfying(arr, pred):
    """Find index of first element satisfying predicate.

    Returns Some(index) or nil.

    Example:
        find_index_satisfying([1, 2, 3, 4], \\x: x > 2)  # Some(2)
    """
    var i = 0
    while i < arr.len():
        if pred(arr[i]):
            return Some(i)
        i = i + 1
    nil

fn filter_by_pred(arr, pred):
    """Filter array by predicate (alias for clarity).

    Example:
        filter_by_pred([1, 2, 3, 4, 5], \\x: x % 2 == 0)  # [2, 4]
    """
    var result = []
    for item in arr:
        if pred(item):
            result.push(item)
    result

fn partition_by_pred(arr, pred):
    """Partition array into (satisfying, not_satisfying).

    Example:
        partition_by_pred([1, 2, 3, 4, 5], \\x: x % 2 == 0)
        # ([2, 4], [1, 3, 5])
    """
    var satisfying = []
    var not_satisfying = []

    for item in arr:
        if pred(item):
            satisfying.push(item)
        else:
            not_satisfying.push(item)

    (satisfying, not_satisfying)

# ============================================================================
# Predicate Testing
# ============================================================================

fn test_predicate(pred, test_cases):
    """Test predicate with array of (input, expected) pairs.

    Returns array of failed test cases.

    Example:
        val is_even = \\x: x % 2 == 0
        test_predicate(is_even, [
            (2, true),
            (3, false),
            (4, true)
        ])
        # [] (all passed)
    """
    var failures = []

    for (input, expected) in test_cases:
        val actual = pred(input)
        if actual != expected:
            failures.push((input, expected, actual))

    failures

fn all_satisfy(arr, pred):
    """Check if all elements satisfy predicate.

    Example:
        all_satisfy([2, 4, 6], \\x: x % 2 == 0)  # true
    """
    for item in arr:
        if not pred(item):
            return false
    true

fn any_satisfy(arr, pred):
    """Check if any element satisfies predicate.

    Example:
        any_satisfy([1, 2, 3], \\x: x % 2 == 0)  # true
    """
    for item in arr:
        if pred(item):
            return true
    false

fn none_satisfy(arr, pred):
    """Check if no elements satisfy predicate.

    Example:
        none_satisfy([1, 3, 5], \\x: x % 2 == 0)  # true
    """
    for item in arr:
        if pred(item):
            return false
    true

# ============================================================================
# Cached/Memoized Predicates
# ============================================================================

fn memoize_predicate(pred, max_cache: i64):
    """Memoize a predicate (cache results).

    Note: Simple caching for i64 inputs only.

    Example:
        val expensive_pred = \\x: expensive_check(x)
        val cached = memoize_predicate(expensive_pred, 100)
    """
    var cache = []

    fn memoized(x: i64) -> bool:
        # Check cache
        for (input, result) in cache:
            if input == x:
                return result

        # Compute and cache
        val result = pred(x)

        if cache.len() < max_cache:
            cache.push((x, result))

        result

    memoized

# ============================================================================
# Predicate Composition Patterns
# ============================================================================

fn if_then_else_pred(condition, then_pred, else_pred):
    """Conditional predicate composition.

    If condition is true, use then_pred, otherwise else_pred.

    Example:
        val pred = if_then_else_pred(
            \\x: x > 0,
            \\x: x % 2 == 0,  # Check even if positive
            \\x: true          # Accept all negative
        )
    """
    \\x:
        if condition(x):
            then_pred(x)
        else:
            else_pred(x)

fn chain_predicates(preds):
    """Chain predicates with short-circuit AND.

    Evaluates predicates in order, stops at first false.

    Example:
        val pred = chain_predicates([
            \\x: x != 0,           # Check not zero first
            \\x: 100 % x == 0      # Then check divisibility
        ])
    """
    \\x:
        for pred in preds:
            if not pred(x):
                return false
        true

fn try_predicates(preds):
    """Try predicates in order, return true on first match.

    Short-circuit OR with explicit order.

    Example:
        val pred = try_predicates([
            \\x: x == 0,
            \\x: x > 100,
            \\x: x < -100
        ])
    """
    \\x:
        for pred in preds:
            if pred(x):
                return true
        false


# FILE: src/std/probability_utils.spl
# Size: 1777 bytes, Lines: 57

# Probability Utilities Module
#
# Simple probability calculations and statistical functions.
#
# Categories:
# - Collision probability (birthday paradox)
# - Basic probability math
#
# All operations use pure Simple implementations (no FFI required).

# ============================================================================
# Exports
# ============================================================================

export collision_probability

# ============================================================================
# Collision Probability (Birthday Paradox)
# ============================================================================

fn collision_probability(n: i64) -> f64:
    """Calculate probability of hash collision for n items.

    Uses the birthday paradox formula for estimating collision probability
    in a 64-bit hash space.

    Args:
        n: Number of items to hash

    Returns:
        Probability of at least one collision (0.0 to 1.0)

    Example:
        collision_probability(10)    # Very low: ~0.00000...
        collision_probability(1000)  # Still low: ~0.000027
        collision_probability(10000) # Higher: ~0.0027
    """
    if n <= 0:
        return 0.0
    if n == 1:
        return 0.0

    # Birthday paradox formula: P(collision) ≈ 1 - e^(-n²/2m)
    # where m is the hash space size (2^64 for i64)
    #
    # For 64-bit hashes: m = 2^64 ≈ 1.844 × 10^19
    # Simplified: P ≈ n² / (2 * 2^64) for small n

    val n_f64 = n as f64
    val hash_space = 18446744073709551616.0  # 2^64

    # Calculate n * (n-1) / (2 * hash_space)
    # This is the exact birthday paradox formula for hash collisions
    val numerator = n_f64 * (n_f64 - 1.0)
    val denominator = 2.0 * hash_space

    numerator / denominator


# FILE: src/std/random_utils.spl
# Size: 13994 bytes, Lines: 527

# Random Utilities
#
# Pseudo-random number generation and utilities.
# Pure Simple implementation - no external dependencies.
#
# Uses Linear Congruential Generator (LCG) for PRNG.
# Note: Not cryptographically secure - for simulation/testing only.
#
# Functions:
# - PRNG: rng_create, rng_next, rng_next_range
# - Distributions: random_int, random_float_like, random_bool
# - Arrays: shuffle, sample, random_choice, random_sample
# - Generation: random_array, random_permutation

# ============================================================================
# Random Number Generator (LCG)
# ============================================================================

fn rng_create(seed: i64):
    """Create RNG state from seed.

    Returns RNG state tuple (seed, multiplier, increment, modulus).

    Example:
        val rng = rng_create(12345)
    """
    # LCG parameters (same as glibc)
    val multiplier = 1103515245
    val increment = 12345
    val modulus = 2147483648  # 2^31

    (seed % modulus, multiplier, increment, modulus)

fn rng_next(rng):
    """Generate next random number.

    Returns (new_rng_state, random_value).

    Example:
        val (rng2, value) = rng_next(rng)
    """
    val (state, a, c, m) = rng
    val new_state = (a * state + c) % m

    ((new_state, a, c, m), new_state)

fn rng_next_range(rng, min_val: i64, max_val: i64):
    """Generate random number in range [min, max).

    Returns (new_rng_state, random_value).

    Example:
        val (rng2, dice) = rng_next_range(rng, 1, 7)  # 1-6
    """
    val (new_rng, value) = rng_next(rng)
    val range = max_val - min_val
    val result = min_val + (value % range)

    (new_rng, result)

fn rng_next_float_like(rng, precision: i64):
    """Generate float-like value (scaled integer).

    Returns (new_rng_state, value) where value is in [0, precision).
    Divide by precision to get value in [0, 1).

    Example:
        val (rng2, val) = rng_next_float_like(rng, 1000)
        # val / 1000.0 would be in [0.0, 1.0)
    """
    rng_next_range(rng, 0, precision)

# ============================================================================
# Simple Random Functions
# ============================================================================

fn random_int(rng, max_val: i64):
    """Generate random integer in [0, max_val).

    Example:
        val (rng2, num) = random_int(rng, 100)  # 0-99
    """
    rng_next_range(rng, 0, max_val)

fn random_int_range(rng, min_val: i64, max_val: i64):
    """Generate random integer in [min_val, max_val).

    Example:
        val (rng2, num) = random_int_range(rng, 10, 20)  # 10-19
    """
    rng_next_range(rng, min_val, max_val)

fn random_bool(rng):
    """Generate random boolean.

    Example:
        val (rng2, coin) = random_bool(rng)
    """
    val (new_rng, value) = rng_next(rng)
    (new_rng, value % 2 == 0)

fn random_sign(rng):
    """Generate random sign (-1 or 1).

    Example:
        val (rng2, sign) = random_sign(rng)
    """
    val (new_rng, value) = rng_next(rng)
    (new_rng, if value % 2 == 0: 1 else: -1)

# ============================================================================
# Array Randomization
# ============================================================================

fn shuffle(rng, arr):
    """Shuffle array (Fisher-Yates algorithm).

    Returns (new_rng_state, shuffled_array).

    Example:
        val (rng2, shuffled) = shuffle(rng, [1, 2, 3, 4, 5])
    """
    var result = arr
    var current_rng = rng

    var i = result.len() - 1
    while i > 0:
        # Pick random index j where 0 <= j <= i
        val (new_rng, j) = rng_next_range(current_rng, 0, i + 1)
        current_rng = new_rng

        # Swap elements
        val temp = result[i]
        result[i] = result[j]
        result[j] = temp

        i = i - 1

    (current_rng, result)

fn random_choice(rng, arr):
    """Pick random element from array.

    Returns (new_rng_state, element).

    Example:
        val (rng2, item) = random_choice(rng, [1, 2, 3, 4, 5])
    """
    val (new_rng, idx) = rng_next_range(rng, 0, arr.len())
    (new_rng, arr[idx])

fn random_sample(rng, arr, n: i64):
    """Sample n random elements without replacement.

    Returns (new_rng_state, sample_array).

    Example:
        val (rng2, sample) = random_sample(rng, [1,2,3,4,5], 3)
    """
    if n >= arr.len():
        return shuffle(rng, arr)

    # Shuffle and take first n elements
    val (new_rng, shuffled) = shuffle(rng, arr)
    var result = []
    var i = 0
    while i < n:
        result.push(shuffled[i])
        i = i + 1

    (new_rng, result)

fn random_sample_with_replacement(rng, arr, n: i64):
    """Sample n random elements with replacement.

    Returns (new_rng_state, sample_array).

    Example:
        val (rng2, sample) = random_sample_with_replacement(rng, [1,2,3], 5)
    """
    var result = []
    var current_rng = rng

    var i = 0
    while i < n:
        val (new_rng, elem) = random_choice(current_rng, arr)
        current_rng = new_rng
        result.push(elem)
        i = i + 1

    (current_rng, result)

# ============================================================================
# Random Array Generation
# ============================================================================

fn random_array(rng, length: i64, max_val: i64):
    """Generate array of random integers.

    Example:
        val (rng2, arr) = random_array(rng, 10, 100)  # 10 values 0-99
    """
    var result = []
    var current_rng = rng

    var i = 0
    while i < length:
        val (new_rng, value) = random_int(current_rng, max_val)
        current_rng = new_rng
        result.push(value)
        i = i + 1

    (current_rng, result)

fn random_array_range(rng, length: i64, min_val: i64, max_val: i64):
    """Generate array of random integers in range.

    Example:
        val (rng2, arr) = random_array_range(rng, 10, 1, 7)  # Dice rolls
    """
    var result = []
    var current_rng = rng

    var i = 0
    while i < length:
        val (new_rng, value) = random_int_range(current_rng, min_val, max_val)
        current_rng = new_rng
        result.push(value)
        i = i + 1

    (current_rng, result)

fn random_permutation(rng, n: i64):
    """Generate random permutation of [0, n).

    Example:
        val (rng2, perm) = random_permutation(rng, 5)  # [2,0,4,1,3]
    """
    # Create sequential array
    var arr = []
    var i = 0
    while i < n:
        arr.push(i)
        i = i + 1

    # Shuffle
    shuffle(rng, arr)

fn random_subset(rng, n: i64, k: i64):
    """Generate random k-subset of [0, n).

    Example:
        val (rng2, subset) = random_subset(rng, 10, 3)
    """
    val (new_rng, perm) = random_permutation(rng, n)

    var result = []
    var i = 0
    while i < k and i < perm.len():
        result.push(perm[i])
        i = i + 1

    (new_rng, result)

# ============================================================================
# Weighted Random
# ============================================================================

fn weighted_choice(rng, items, weights):
    """Choose item based on weights.

    weights should be array of positive integers.
    Returns (new_rng_state, chosen_item).

    Example:
        val (rng2, item) = weighted_choice(rng, ['a', 'b', 'c'], [1, 2, 3])
    """
    # Calculate total weight
    var total = 0
    for w in weights:
        total = total + w

    # Pick random value
    val (new_rng, target) = rng_next_range(rng, 0, total)

    # Find item
    var cumulative = 0
    var i = 0
    while i < items.len():
        cumulative = cumulative + weights[i]
        if target < cumulative:
            return (new_rng, items[i])
        i = i + 1

    # Fallback (shouldn't happen)
    (new_rng, items[items.len() - 1])

# ============================================================================
# Distribution Sampling
# ============================================================================

fn random_uniform_int(rng, a: i64, b: i64):
    """Uniform distribution over [a, b].

    Example:
        val (rng2, val) = random_uniform_int(rng, 1, 6)  # Fair die
    """
    rng_next_range(rng, a, b + 1)

fn random_binomial(rng, n: i64, p_numerator: i64, p_denominator: i64):
    """Simple binomial distribution (n trials, p = p_numerator/p_denominator).

    Returns (new_rng_state, successes).

    Example:
        val (rng2, heads) = random_binomial(rng, 10, 1, 2)  # 10 coin flips
    """
    var successes = 0
    var current_rng = rng

    var i = 0
    while i < n:
        val (new_rng, value) = rng_next_range(current_rng, 0, p_denominator)
        current_rng = new_rng

        if value < p_numerator:
            successes = successes + 1

        i = i + 1

    (current_rng, successes)

fn random_geometric(rng, p_numerator: i64, p_denominator: i64):
    """Geometric distribution (number of trials until success).

    Returns (new_rng_state, trials).

    Example:
        val (rng2, rolls) = random_geometric(rng, 1, 6)  # Until 1 on die
    """
    var trials = 1
    var current_rng = rng

    while true:
        val (new_rng, value) = rng_next_range(current_rng, 0, p_denominator)
        current_rng = new_rng

        if value < p_numerator:
            break

        trials = trials + 1

    (current_rng, trials)

# ============================================================================
# Monte Carlo Utilities
# ============================================================================

fn monte_carlo_pi(rng, samples: i64, precision: i64):
    """Estimate π using Monte Carlo method.

    Returns (new_rng_state, pi_estimate_times_precision).
    Divide result by precision to get π estimate.

    Example:
        val (rng2, pi_x_1000) = monte_carlo_pi(rng, 10000, 1000)
        # pi_x_1000 / 1000 ≈ 3.14...
    """
    var inside = 0
    var current_rng = rng

    var i = 0
    while i < samples:
        val (rng1, x) = rng_next_range(current_rng, 0, precision)
        val (rng2, y) = rng_next_range(rng1, 0, precision)
        current_rng = rng2

        # Check if point is inside unit circle
        if x * x + y * y < precision * precision:
            inside = inside + 1

        i = i + 1

    # π ≈ 4 * (inside / samples)
    val estimate = (4 * inside * precision) / samples

    (current_rng, estimate)

fn monte_carlo_integration(rng, samples: i64, func, a: i64, b: i64, precision: i64):
    """Estimate integral using Monte Carlo.

    func should take scaled integer input.

    Returns (new_rng_state, integral_estimate_times_precision).
    """
    var sum = 0
    var current_rng = rng

    val range = b - a

    var i = 0
    while i < samples:
        val (new_rng, x_scaled) = rng_next_range(current_rng, a * precision, b * precision)
        current_rng = new_rng

        val y = func(x_scaled / precision)
        sum = sum + y

        i = i + 1

    val estimate = (sum * range) / samples

    (current_rng, estimate)

# ============================================================================
# Random String Generation
# ============================================================================

fn random_alphanumeric(rng, length: i64):
    """Generate random alphanumeric string.

    Returns (new_rng_state, string).

    Example:
        val (rng2, str) = random_alphanumeric(rng, 10)
    """
    val chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    var result = ""
    var current_rng = rng

    var i = 0
    while i < length:
        val (new_rng, idx) = rng_next_range(current_rng, 0, chars.len())
        current_rng = new_rng
        result = result + chars[idx]
        i = i + 1

    (current_rng, result)

fn random_string(rng, length: i64, alphabet: text):
    """Generate random string from alphabet.

    Example:
        val (rng2, dna) = random_string(rng, 20, "ACGT")
    """
    var result = ""
    var current_rng = rng

    var i = 0
    while i < length:
        val (new_rng, idx) = rng_next_range(current_rng, 0, alphabet.len())
        current_rng = new_rng
        result = result + alphabet[idx]
        i = i + 1

    (current_rng, result)

fn random_digit_string(rng, length: i64):
    """Generate random digit string.

    Example:
        val (rng2, pin) = random_digit_string(rng, 4)  # "1234"
    """
    random_string(rng, length, "0123456789")

fn random_hex_string(rng, length: i64):
    """Generate random hex string.

    Example:
        val (rng2, hex) = random_hex_string(rng, 8)  # "A3F2B1C4"
    """
    random_string(rng, length, "0123456789ABCDEF")

# ============================================================================
# Testing Utilities
# ============================================================================

fn random_test_data(rng, n: i64):
    """Generate random test data array.

    Returns (new_rng_state, test_array).

    Example:
        val (rng2, test) = random_test_data(rng, 100)
    """
    random_array(rng, n, 1000)

fn random_sorted_array(rng, n: i64, max_val: i64):
    """Generate random sorted array.

    Example:
        val (rng2, sorted) = random_sorted_array(rng, 10, 100)
    """
    val (new_rng, arr) = random_array(rng, n, max_val)

    # Simple insertion sort
    var result = arr
    var i = 1
    while i < result.len():
        val key = result[i]
        var j = i - 1

        while j >= 0 and result[j] > key:
            result[j + 1] = result[j]
            j = j - 1

        result[j + 1] = key
        i = i + 1

    (new_rng, result)

fn is_random_enough(arr, expected_avg: i64, tolerance: i64):
    """Check if array is "random enough" (simple test).

    Checks if average is within tolerance of expected.

    Example:
        is_random_enough([1,2,3,4,5], 3, 1)  # true
    """
    var sum = 0
    for x in arr:
        sum = sum + x

    val avg = sum / arr.len()
    val diff = if avg > expected_avg: avg - expected_avg else: expected_avg - avg

    diff <= tolerance


# FILE: src/std/range_utils.spl
# Size: 14027 bytes, Lines: 544

# Range Utilities
#
# Helper functions for working with ranges and intervals.
# Pure Simple implementation - no external dependencies.
#
# Supports numeric ranges, range operations, and interval arithmetic.
# All ranges are inclusive on both ends unless noted.
#
# Functions:
# - Range construction: make_range, range_from, range_to
# - Range predicates: in_range, overlaps, contains_range
# - Range operations: intersection, union, merge_ranges
# - Range iteration: range_map, range_fold, range_filter
# - Range transformation: expand, shrink, shift, split_range
# - Range queries: size, midpoint, clamp_to_range

# ============================================================================
# Range Construction
# ============================================================================

fn make_range(start: i64, end: i64):
    """Create a range from start to end (inclusive).

    Example:
        make_range(1, 10)  # Range from 1 to 10
    """
    (start: start, end: end)

fn range_from(start: i64, length: i64):
    """Create a range from start with given length.

    Example:
        range_from(5, 3)  # (start: 5, end: 7)
    """
    (start: start, end: start + length - 1)

fn range_to(end: i64, length: i64):
    """Create a range ending at end with given length.

    Example:
        range_to(10, 3)  # (start: 8, end: 10)
    """
    (start: end - length + 1, end: end)

fn unit_range():
    """Create a unit range [0, 0].

    Example:
        unit_range()  # (start: 0, end: 0)
    """
    (start: 0, end: 0)

fn infinite_range_from(start: i64):
    """Create a conceptual infinite range from start.

    Note: Represented with very large end value.

    Example:
        infinite_range_from(0)  # (start: 0, end: i64_max)
    """
    (start: start, end: 9223372036854775807)

# ============================================================================
# Range Predicates
# ============================================================================

fn in_range(value: i64, range):
    """Check if value is within range (inclusive).

    Example:
        in_range(5, (start: 1, end: 10))  # true
        in_range(15, (start: 1, end: 10))  # false
    """
    val (start: s, end: e) = range
    value >= s and value <= e

fn is_empty_range(range):
    """Check if range is empty (start > end).

    Example:
        is_empty_range((start: 5, end: 3))  # true
        is_empty_range((start: 1, end: 10))  # false
    """
    val (start: s, end: e) = range
    s > e

fn is_valid_range(range):
    """Check if range is valid (start <= end).

    Example:
        is_valid_range((start: 1, end: 10))  # true
        is_valid_range((start: 10, end: 5))  # false
    """
    not is_empty_range(range)

fn overlaps(range1, range2):
    """Check if two ranges overlap.

    Example:
        overlaps((start: 1, end: 5), (start: 3, end: 8))  # true
        overlaps((start: 1, end: 5), (start: 6, end: 10))  # false
    """
    val (start: s1, end: e1) = range1
    val (start: s2, end: e2) = range2
    s1 <= e2 and s2 <= e1

fn contains_range(outer, inner):
    """Check if outer range contains inner range.

    Example:
        contains_range((start: 1, end: 10), (start: 3, end: 7))  # true
        contains_range((start: 1, end: 10), (start: 8, end: 15))  # false
    """
    val (start: s1, end: e1) = outer
    val (start: s2, end: e2) = inner
    s1 <= s2 and e1 >= e2

fn is_adjacent(range1, range2):
    """Check if ranges are adjacent (touching but not overlapping).

    Example:
        is_adjacent((start: 1, end: 5), (start: 6, end: 10))  # true
        is_adjacent((start: 1, end: 5), (start: 7, end: 10))  # false
    """
    val (start: s1, end: e1) = range1
    val (start: s2, end: e2) = range2
    e1 + 1 == s2 or e2 + 1 == s1

# ============================================================================
# Range Operations
# ============================================================================

fn intersection(range1, range2):
    """Find intersection of two ranges.

    Returns Some(range) if they overlap, nil otherwise.

    Example:
        intersection((start: 1, end: 5), (start: 3, end: 8))
        # Some((start: 3, end: 5))
    """
    if not overlaps(range1, range2):
        return nil

    val (start: s1, end: e1) = range1
    val (start: s2, end: e2) = range2

    val new_start = if s1 > s2: s1 else: s2
    val new_end = if e1 < e2: e1 else: e2

    Some((start: new_start, end: new_end))

fn union_ranges(range1, range2):
    """Find union of two ranges.

    Returns Some(range) if they overlap or are adjacent, nil otherwise.

    Example:
        union_ranges((start: 1, end: 5), (start: 3, end: 8))
        # Some((start: 1, end: 8))
    """
    if not overlaps(range1, range2) and not is_adjacent(range1, range2):
        return nil

    val (start: s1, end: e1) = range1
    val (start: s2, end: e2) = range2

    val new_start = if s1 < s2: s1 else: s2
    val new_end = if e1 > e2: e1 else: e2

    Some((start: new_start, end: new_end))

fn merge_overlapping_ranges(ranges):
    """Merge all overlapping or adjacent ranges.

    Returns array of non-overlapping ranges.

    Example:
        merge_overlapping_ranges([
            (start: 1, end: 5),
            (start: 3, end: 8),
            (start: 10, end: 15)
        ])
        # [(start: 1, end: 8), (start: 10, end: 15)]
    """
    if ranges.len() == 0:
        return []

    # Sort ranges by start position
    var sorted = ranges
    var i = 0
    while i < sorted.len() - 1:
        var j = i + 1
        while j < sorted.len():
            val (start: s1, end: _) = sorted[i]
            val (start: s2, end: _) = sorted[j]
            if s2 < s1:
                val temp = sorted[i]
                sorted[i] = sorted[j]
                sorted[j] = temp
            j = j + 1
        i = i + 1

    var merged = [sorted[0]]
    i = 1

    while i < sorted.len():
        val last_idx = merged.len() - 1
        val current = sorted[i]

        val maybe_union = union_ranges(merged[last_idx], current)
        if val new_range = maybe_union:
            merged[last_idx] = new_range
        else:
            merged.push(current)

        i = i + 1

    merged

# ============================================================================
# Range Queries
# ============================================================================

fn range_size(range):
    """Calculate size (length) of range.

    Returns 0 for empty ranges.

    Example:
        range_size((start: 1, end: 10))  # 10
        range_size((start: 5, end: 5))   # 1
    """
    val (start: s, end: e) = range
    if s > e:
        return 0
    e - s + 1

fn range_midpoint(range):
    """Find midpoint of range.

    Example:
        range_midpoint((start: 1, end: 10))  # 5
        range_midpoint((start: 1, end: 11))  # 6
    """
    val (start: s, end: e) = range
    s + (e - s) / 2

fn clamp_to_range(value: i64, range):
    """Clamp value to be within range.

    Example:
        clamp_to_range(5, (start: 1, end: 10))   # 5
        clamp_to_range(15, (start: 1, end: 10))  # 10
        clamp_to_range(-5, (start: 1, end: 10))  # 1
    """
    val (start: s, end: e) = range
    if value < s:
        return s
    if value > e:
        return e
    value

fn range_distance(range1, range2):
    """Calculate distance between two ranges.

    Returns 0 if ranges overlap.

    Example:
        range_distance((start: 1, end: 5), (start: 8, end: 10))  # 2
        range_distance((start: 1, end: 5), (start: 3, end: 10))  # 0
    """
    if overlaps(range1, range2):
        return 0

    val (start: s1, end: e1) = range1
    val (start: s2, end: e2) = range2

    if e1 < s2:
        s2 - e1 - 1
    else:
        s1 - e2 - 1

# ============================================================================
# Range Transformation
# ============================================================================

fn expand_range(range, amount: i64):
    """Expand range by amount on both sides.

    Example:
        expand_range((start: 5, end: 10), 2)  # (start: 3, end: 12)
    """
    val (start: s, end: e) = range
    (start: s - amount, end: e + amount)

fn shrink_range(range, amount: i64):
    """Shrink range by amount on both sides.

    May result in empty range if amount is too large.

    Example:
        shrink_range((start: 5, end: 10), 1)  # (start: 6, end: 9)
    """
    val (start: s, end: e) = range
    (start: s + amount, end: e - amount)

fn shift_range(range, offset: i64):
    """Shift range by offset.

    Example:
        shift_range((start: 5, end: 10), 3)   # (start: 8, end: 13)
        shift_range((start: 5, end: 10), -2)  # (start: 3, end: 8)
    """
    val (start: s, end: e) = range
    (start: s + offset, end: e + offset)

fn split_range(range, at: i64):
    """Split range at position.

    Returns tuple of two ranges, or nil if position is outside range.

    Example:
        split_range((start: 1, end: 10), 5)
        # Some(((start: 1, end: 5), (start: 6, end: 10)))
    """
    val (start: s, end: e) = range

    if at < s or at > e:
        return nil

    val left = (start: s, end: at)
    val right = (start: at + 1, end: e)

    Some((left, right))

fn split_range_into_n(range, n: i64):
    """Split range into n roughly equal parts.

    Example:
        split_range_into_n((start: 1, end: 10), 3)
        # [(start: 1, end: 3), (start: 4, end: 6), (start: 7, end: 10)]
    """
    if n <= 0:
        return []

    val (start: s, end: e) = range
    val total_size = range_size(range)
    val chunk_size = total_size / n

    var result = []
    var current = s
    var i = 0

    while i < n - 1:
        val chunk_end = current + chunk_size - 1
        result.push((start: current, end: chunk_end))
        current = chunk_end + 1
        i = i + 1

    # Last chunk gets remainder
    result.push((start: current, end: e))

    result

# ============================================================================
# Range Iteration
# ============================================================================

fn range_to_array(range):
    """Convert range to array of values.

    Warning: Can be expensive for large ranges.

    Example:
        range_to_array((start: 1, end: 5))  # [1, 2, 3, 4, 5]
    """
    val (start: s, end: e) = range
    var result = []
    var i = s

    while i <= e:
        result.push(i)
        i = i + 1

    result

fn range_map(range, f):
    """Map function over range values.

    Example:
        range_map((start: 1, end: 5), \\x: x * 2)  # [2, 4, 6, 8, 10]
    """
    val (start: s, end: e) = range
    var result = []
    var i = s

    while i <= e:
        result.push(f(i))
        i = i + 1

    result

fn range_fold(range, initial, f):
    """Fold over range values.

    Example:
        range_fold((start: 1, end: 5), 0, \\acc, x: acc + x)  # 15
    """
    val (start: s, end: e) = range
    var acc = initial
    var i = s

    while i <= e:
        acc = f(acc, i)
        i = i + 1

    acc

fn range_filter(range, predicate):
    """Filter range values by predicate.

    Returns array of values that match predicate.

    Example:
        range_filter((start: 1, end: 10), \\x: x % 2 == 0)
        # [2, 4, 6, 8, 10]
    """
    val (start: s, end: e) = range
    var result = []
    var i = s

    while i <= e:
        if predicate(i):
            result.push(i)
        i = i + 1

    result

fn range_any(range, predicate):
    """Check if any value in range matches predicate.

    Example:
        range_any((start: 1, end: 10), \\x: x > 5)  # true
    """
    val (start: s, end: e) = range
    var i = s

    while i <= e:
        if predicate(i):
            return true
        i = i + 1

    false

fn range_all(range, predicate):
    """Check if all values in range match predicate.

    Example:
        range_all((start: 1, end: 10), \\x: x > 0)  # true
    """
    val (start: s, end: e) = range
    var i = s

    while i <= e:
        if not predicate(i):
            return false
        i = i + 1

    true

# ============================================================================
# Range Comparison
# ============================================================================

fn range_equals(range1, range2):
    """Check if two ranges are equal.

    Example:
        range_equals((start: 1, end: 10), (start: 1, end: 10))  # true
    """
    val (start: s1, end: e1) = range1
    val (start: s2, end: e2) = range2
    s1 == s2 and e1 == e2

fn range_before(range1, range2):
    """Check if range1 is completely before range2.

    Example:
        range_before((start: 1, end: 5), (start: 6, end: 10))  # true
    """
    val (start: _, end: e1) = range1
    val (start: s2, end: _) = range2
    e1 < s2

fn range_after(range1, range2):
    """Check if range1 is completely after range2.

    Example:
        range_after((start: 6, end: 10), (start: 1, end: 5))  # true
    """
    range_before(range2, range1)

# ============================================================================
# Range Utilities
# ============================================================================

fn normalize_range(range):
    """Normalize range so start <= end.

    Swaps start and end if start > end.

    Example:
        normalize_range((start: 10, end: 1))  # (start: 1, end: 10)
    """
    val (start: s, end: e) = range
    if s <= e:
        range
    else:
        (start: e, end: s)

fn range_complement(range, universe):
    """Find complement of range within universe.

    Returns array of ranges that are in universe but not in range.

    Example:
        range_complement((start: 5, end: 8), (start: 1, end: 10))
        # [(start: 1, end: 4), (start: 9, end: 10)]
    """
    val (start: s, end: e) = range
    val (start: us, end: ue) = universe

    var result = []

    # Before range
    if us < s:
        result.push((start: us, end: s - 1))

    # After range
    if e < ue:
        result.push((start: e + 1, end: ue))

    result


# FILE: src/std/regex_engine/char_utils.spl
# Size: 9635 bytes, Lines: 310

# Regular Expression Engine - Character Utilities
#
# Character classification and escape sequence handling.


# ============================================================================
# CHARACTER UTILITIES
# ============================================================================

fn char_code(ch: text) -> i64:
    """Get ASCII code of character."""
    if ch == "": return 0
    if ch == " ": return 32
    if ch == "!": return 33
    if ch == "\"": return 34
    if ch == "#": return 35
    if ch == "$": return 36
    if ch == "%": return 37
    if ch == "&": return 38
    if ch == "'": return 39
    if ch == "(": return 40
    if ch == ")": return 41
    if ch == "*": return 42
    if ch == "+": return 43
    if ch == ",": return 44
    if ch == "-": return 45
    if ch == ".": return 46
    if ch == "/": return 47
    if ch == "0": return 48
    if ch == "1": return 49
    if ch == "2": return 50
    if ch == "3": return 51
    if ch == "4": return 52
    if ch == "5": return 53
    if ch == "6": return 54
    if ch == "7": return 55
    if ch == "8": return 56
    if ch == "9": return 57
    if ch == ":": return 58
    if ch == ";": return 59
    if ch == "<": return 60
    if ch == "=": return 61
    if ch == ">": return 62
    if ch == "?": return 63
    if ch == "@": return 64
    if ch == "A": return 65
    if ch == "B": return 66
    if ch == "C": return 67
    if ch == "D": return 68
    if ch == "E": return 69
    if ch == "F": return 70
    if ch == "G": return 71
    if ch == "H": return 72
    if ch == "I": return 73
    if ch == "J": return 74
    if ch == "K": return 75
    if ch == "L": return 76
    if ch == "M": return 77
    if ch == "N": return 78
    if ch == "O": return 79
    if ch == "P": return 80
    if ch == "Q": return 81
    if ch == "R": return 82
    if ch == "S": return 83
    if ch == "T": return 84
    if ch == "U": return 85
    if ch == "V": return 86
    if ch == "W": return 87
    if ch == "X": return 88
    if ch == "Y": return 89
    if ch == "Z": return 90
    if ch == "[": return 91
    if ch == "\\": return 92
    if ch == "]": return 93
    if ch == "^": return 94
    if ch == "_": return 95
    if ch == "`": return 96
    if ch == "a": return 97
    if ch == "b": return 98
    if ch == "c": return 99
    if ch == "d": return 100
    if ch == "e": return 101
    if ch == "f": return 102
    if ch == "g": return 103
    if ch == "h": return 104
    if ch == "i": return 105
    if ch == "j": return 106
    if ch == "k": return 107
    if ch == "l": return 108
    if ch == "m": return 109
    if ch == "n": return 110
    if ch == "o": return 111
    if ch == "p": return 112
    if ch == "q": return 113
    if ch == "r": return 114
    if ch == "s": return 115
    if ch == "t": return 116
    if ch == "u": return 117
    if ch == "v": return 118
    if ch == "w": return 119
    if ch == "x": return 120
    if ch == "y": return 121
    if ch == "z": return 122
    if ch == "{": return 123
    if ch == "|": return 124
    if ch == "}": return 125
    if ch == "~": return 126
    if ch == "\n": return 10
    if ch == "\t": return 9
    if ch == "\r": return 13
    0

fn string_from_code(code: i64) -> text:
    """Convert ASCII code to string."""
    if code == 32: return " "
    if code == 33: return "!"
    if code == 34: return "\""
    if code == 35: return "#"
    if code == 36: return "$"
    if code == 37: return "%"
    if code == 38: return "&"
    if code == 39: return "'"
    if code == 40: return "("
    if code == 41: return ")"
    if code == 42: return "*"
    if code == 43: return "+"
    if code == 44: return ","
    if code == 45: return "-"
    if code == 46: return "."
    if code == 47: return "/"
    if code == 48: return "0"
    if code == 49: return "1"
    if code == 50: return "2"
    if code == 51: return "3"
    if code == 52: return "4"
    if code == 53: return "5"
    if code == 54: return "6"
    if code == 55: return "7"
    if code == 56: return "8"
    if code == 57: return "9"
    if code == 58: return ":"
    if code == 59: return ";"
    if code == 60: return "<"
    if code == 61: return "="
    if code == 62: return ">"
    if code == 63: return "?"
    if code == 64: return "@"
    if code == 65: return "A"
    if code == 66: return "B"
    if code == 67: return "C"
    if code == 68: return "D"
    if code == 69: return "E"
    if code == 70: return "F"
    if code == 71: return "G"
    if code == 72: return "H"
    if code == 73: return "I"
    if code == 74: return "J"
    if code == 75: return "K"
    if code == 76: return "L"
    if code == 77: return "M"
    if code == 78: return "N"
    if code == 79: return "O"
    if code == 80: return "P"
    if code == 81: return "Q"
    if code == 82: return "R"
    if code == 83: return "S"
    if code == 84: return "T"
    if code == 85: return "U"
    if code == 86: return "V"
    if code == 87: return "W"
    if code == 88: return "X"
    if code == 89: return "Y"
    if code == 90: return "Z"
    if code == 91: return "["
    if code == 92: return "\\"
    if code == 93: return "]"
    if code == 94: return "^"
    if code == 95: return "_"
    if code == 96: return "`"
    if code == 97: return "a"
    if code == 98: return "b"
    if code == 99: return "c"
    if code == 100: return "d"
    if code == 101: return "e"
    if code == 102: return "f"
    if code == 103: return "g"
    if code == 104: return "h"
    if code == 105: return "i"
    if code == 106: return "j"
    if code == 107: return "k"
    if code == 108: return "l"
    if code == 109: return "m"
    if code == 110: return "n"
    if code == 111: return "o"
    if code == 112: return "p"
    if code == 113: return "q"
    if code == 114: return "r"
    if code == 115: return "s"
    if code == 116: return "t"
    if code == 117: return "u"
    if code == 118: return "v"
    if code == 119: return "w"
    if code == 120: return "x"
    if code == 121: return "y"
    if code == 122: return "z"
    if code == 123: return "{"
    if code == 124: return "|"
    if code == 125: return "}"
    if code == 126: return "~"
    if code == 10: return "\n"
    if code == 9: return "\t"
    if code == 13: return "\r"
    ""

fn is_digit_char(ch: text) -> bool:
    """Check if character is a digit (0-9)."""
    val code = char_code(ch)
    code >= 48 and code <= 57

fn is_alpha_char(ch: text) -> bool:
    """Check if character is alphabetic (a-z, A-Z)."""
    val code = char_code(ch)
    val is_upper = code >= 65 and code <= 90
    val is_lower = code >= 97 and code <= 122
    is_upper or is_lower

fn is_alnum_char(ch: text) -> bool:
    """Check if character is alphanumeric."""
    is_alpha_char(ch) or is_digit_char(ch)

fn is_word_char(ch: text) -> bool:
    """Check if character is a word character (alphanumeric or underscore)."""
    is_alnum_char(ch) or ch == "_"

fn is_whitespace_char(ch: text) -> bool:
    """Check if character is whitespace."""
    ch == " " or ch == "\t" or ch == "\n" or ch == "\r"

fn is_hex_char(ch: text) -> bool:
    """Check if character is hexadecimal digit."""
    val code = char_code(ch)
    val is_num = code >= 48 and code <= 57
    val is_upper = code >= 65 and code <= 70
    val is_lower = code >= 97 and code <= 102
    is_num or is_upper or is_lower

fn is_special_regex_char(ch: text) -> bool:
    """Check if character has special meaning in regex."""
    ch == "." or ch == "*" or ch == "+" or ch == "?" or ch == "|" or ch == "(" or ch == ")" or ch == "[" or ch == "]" or ch == "{" or ch == "}" or ch == "^" or ch == "$" or ch == "\\"

# ============================================================================
# ESCAPE SEQUENCES
# ============================================================================

fn escape_regex(text_str: text) -> text:
    """Escape special regex characters for literal matching."""
    var result = ""
    var i = 0
    while i < text_str.len():
        val ch = text_str[i:i + 1]
        if is_special_regex_char(ch):
            result = result + "\\" + ch
        else:
            result = result + ch
        i = i + 1
    result

fn unescape_regex(text_str: text) -> text:
    """Remove escape backslashes from regex string."""
    var result = ""
    var i = 0
    while i < text_str.len():
        val ch = text_str[i:i + 1]
        if ch == "\\":
            if i + 1 < text_str.len():
                val next_ch = text_str[i + 1:i + 2]
                result = result + next_ch
                i = i + 2
            else:
                result = result + ch
                i = i + 1
        else:
            result = result + ch
            i = i + 1
    result

fn expand_escape(esc: text) -> text:
    """Expand escape sequence like \n, \t, \d, \w, \s."""
    if esc == "n": return "\n"
    if esc == "t": return "\t"
    if esc == "r": return "\r"
    if esc == "d": return "[0-9]"
    if esc == "D": return "[^0-9]"
    if esc == "w": return "[a-zA-Z0-9_]"
    if esc == "W": return "[^a-zA-Z0-9_]"
    if esc == "s": return "[ \t\n\r]"
    if esc == "S": return "[^ \t\n\r]"
    if esc == "b": return "\\b"
    if esc == "B": return "\\B"
    esc

fn is_escape_char(ch: text) -> bool:
    """Check if character can be escaped."""
    ch == "n" or ch == "t" or ch == "r" or ch == "d" or ch == "D" or ch == "w" or ch == "W" or ch == "s" or ch == "S" or ch == "b" or ch == "B"

export char_code, string_from_code
export is_digit_char, is_alpha_char, is_alnum_char, is_word_char
export is_whitespace_char, is_hex_char, is_special_regex_char
export escape_regex, unescape_regex, expand_escape, is_escape_char


# FILE: src/std/search_utils.spl
# Size: 17481 bytes, Lines: 738

# Search Utilities
#
# Search algorithms and pattern matching.
# Pure Simple implementation - no external dependencies.
#
# Provides various search algorithms for different scenarios:
# - Linear search (sequential, sentinel)
# - Binary search (standard, lower/upper bound, rotated arrays)
# - Pattern matching (substring search, wildcard matching)
# - Special searches (jump search, interpolation search)
#
# Functions:
# - Linear: linear_search, linear_search_all, sentinel_search
# - Binary: binary_search, lower_bound, upper_bound, binary_search_rotated
# - Pattern: substring_search, wildcard_match, pattern_match_all
# - Special: jump_search, interpolation_search, exponential_search

# ============================================================================
# Linear Search
# ============================================================================

fn linear_search(arr, target):
    """Search for target using linear search.

    Returns index of first occurrence, or nil if not found.
    Time: O(n)

    Example:
        linear_search([1, 3, 5, 7, 9], 5)  # 2
        linear_search([1, 3, 5], 4)         # nil
    """
    var i = 0
    while i < arr.len():
        if arr[i] == target:
            return i
        i = i + 1

    nil

fn linear_search_all(arr, target):
    """Find all occurrences of target.

    Returns array of indices.

    Example:
        linear_search_all([1, 2, 3, 2, 4], 2)  # [1, 3]
    """
    var indices = []
    var i = 0

    while i < arr.len():
        if arr[i] == target:
            indices.push(i)
        i = i + 1

    indices

fn linear_search_with(arr, predicate):
    """Search for first element matching predicate.

    Returns index of first match, or nil.

    Example:
        linear_search_with([1, 2, 3, 4], \x: x > 2)  # 2
    """
    var i = 0
    while i < arr.len():
        if predicate(arr[i]):
            return i
        i = i + 1

    nil

fn sentinel_search(arr, target):
    """Linear search with sentinel optimization.

    Slightly faster than standard linear search.

    Example:
        sentinel_search([1, 3, 5, 7, 9], 5)  # 2
    """
    var work = arr
    work.push(target)  # Add sentinel

    var i = 0
    while work[i] != target:
        i = i + 1

    if i < arr.len():
        return i

    nil

# ============================================================================
# Binary Search
# ============================================================================

fn binary_search(arr, target):
    """Binary search in sorted array.

    Returns index if found, nil otherwise.
    Time: O(log n)
    Array must be sorted.

    Example:
        binary_search([1, 3, 5, 7, 9], 5)  # 2
        binary_search([1, 3, 5, 7, 9], 4)  # nil
    """
    var left = 0
    var right = arr.len() - 1

    while left <= right:
        val mid = left + (right - left) / 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    nil

fn binary_search_first(arr, target):
    """Find first occurrence in sorted array.

    Example:
        binary_search_first([1, 2, 2, 2, 3], 2)  # 1
    """
    var left = 0
    var right = arr.len() - 1
    var result = nil

    while left <= right:
        val mid = left + (right - left) / 2

        if arr[mid] == target:
            result = mid
            right = mid - 1  # Continue searching left
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    result

fn binary_search_last(arr, target):
    """Find last occurrence in sorted array.

    Example:
        binary_search_last([1, 2, 2, 2, 3], 2)  # 3
    """
    var left = 0
    var right = arr.len() - 1
    var result = nil

    while left <= right:
        val mid = left + (right - left) / 2

        if arr[mid] == target:
            result = mid
            left = mid + 1  # Continue searching right
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    result

fn lower_bound(arr, target):
    """Find first position where target could be inserted.

    Returns index of first element >= target.

    Example:
        lower_bound([1, 2, 4, 4, 5], 3)  # 2
        lower_bound([1, 2, 4, 4, 5], 4)  # 2
    """
    var left = 0
    var right = arr.len()

    while left < right:
        val mid = left + (right - left) / 2

        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid

    left

fn upper_bound(arr, target):
    """Find last position where target could be inserted.

    Returns index of first element > target.

    Example:
        upper_bound([1, 2, 4, 4, 5], 3)  # 2
        upper_bound([1, 2, 4, 4, 5], 4)  # 4
    """
    var left = 0
    var right = arr.len()

    while left < right:
        val mid = left + (right - left) / 2

        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid

    left

fn binary_search_range(arr, target):
    """Find range of target in sorted array.

    Returns (first_idx, last_idx) or nil if not found.

    Example:
        binary_search_range([1, 2, 2, 2, 3], 2)  # (1, 3)
    """
    val first = binary_search_first(arr, target)
    if not first.?:
        return nil

    val last = binary_search_last(arr, target)
    (first, last)

# ============================================================================
# Rotated Array Search
# ============================================================================

fn find_pivot(arr):
    """Find pivot point in rotated sorted array.

    Example:
        find_pivot([4, 5, 6, 7, 1, 2, 3])  # 4
    """
    var left = 0
    var right = arr.len() - 1

    while left < right:
        val mid = left + (right - left) / 2

        if arr[mid] > arr[right]:
            left = mid + 1
        else:
            right = mid

    left

fn binary_search_rotated(arr, target):
    """Binary search in rotated sorted array.

    Example:
        binary_search_rotated([4, 5, 6, 7, 1, 2, 3], 2)  # 5
    """
    var left = 0
    var right = arr.len() - 1

    while left <= right:
        val mid = left + (right - left) / 2

        if arr[mid] == target:
            return mid

        # Determine which half is sorted
        if arr[left] <= arr[mid]:
            # Left half is sorted
            if target >= arr[left] and target < arr[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            # Right half is sorted
            if target > arr[mid] and target <= arr[right]:
                left = mid + 1
            else:
                right = mid - 1

    nil

# ============================================================================
# Jump Search
# ============================================================================

fn jump_search(arr, target):
    """Jump search in sorted array.

    Time: O(√n)
    Faster than linear, slower than binary for large arrays.

    Example:
        jump_search([1, 3, 5, 7, 9, 11, 13], 9)  # 4
    """
    val n = arr.len()
    val jump = sqrt_integer(n)

    var prev = 0
    var step = jump

    # Jump ahead
    while step < n and arr[step] < target:
        prev = step
        step = step + jump

    # Linear search in block
    var i = prev
    while i < step and i < n:
        if arr[i] == target:
            return i
        i = i + 1

    nil

fn sqrt_integer(n: i64) -> i64:
    """Integer square root for jump search."""
    if n == 0:
        return 0

    var x = n
    var y = (x + 1) / 2

    while y < x:
        x = y
        y = (x + n / x) / 2

    x

# ============================================================================
# Interpolation Search
# ============================================================================

fn interpolation_search(arr, target):
    """Interpolation search in uniformly distributed sorted array.

    Time: O(log log n) for uniform distribution, O(n) worst case
    Best for uniformly distributed data.

    Example:
        interpolation_search([1, 3, 5, 7, 9], 5)  # 2
    """
    var low = 0
    var high = arr.len() - 1

    while low <= high and target >= arr[low] and target <= arr[high]:
        if low == high:
            if arr[low] == target:
                return low
            return nil

        # Estimate position
        val range = arr[high] - arr[low]
        if range == 0:
            if arr[low] == target:
                return low
            return nil

        val offset = (target - arr[low]) * (high - low) / range
        val pos = low + offset

        if arr[pos] == target:
            return pos
        elif arr[pos] < target:
            low = pos + 1
        else:
            high = pos - 1

    nil

# ============================================================================
# Exponential Search
# ============================================================================

fn exponential_search(arr, target):
    """Exponential search in sorted array.

    Useful for unbounded/infinite arrays.
    Time: O(log n)

    Example:
        exponential_search([1, 2, 3, 4, 5, 6, 7], 5)  # 4
    """
    if arr.len() == 0:
        return nil

    if arr[0] == target:
        return 0

    # Find range
    var i = 1
    while i < arr.len() and arr[i] <= target:
        i = i * 2

    # Binary search in range
    var left = i / 2
    var right = if i < arr.len(): i else: arr.len() - 1

    while left <= right:
        val mid = left + (right - left) / 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    nil

# ============================================================================
# String/Substring Search
# ============================================================================

fn substring_search(text: text, pattern: text) -> i64:
    """Find first occurrence of pattern in text.

    Returns starting index, or -1 if not found.
    Simple brute force algorithm.

    Example:
        substring_search("hello world", "world")  # 6
    """
    val text_len = text.len()
    val pattern_len = pattern.len()

    if pattern_len > text_len:
        return -1

    var i = 0
    while i <= text_len - pattern_len:
        var match = true
        var j = 0

        while j < pattern_len:
            if text[i + j] != pattern[j]:
                match = false
                break
            j = j + 1

        if match:
            return i

        i = i + 1

    -1

fn substring_search_all(text: text, pattern: text):
    """Find all occurrences of pattern in text.

    Returns array of starting indices.

    Example:
        substring_search_all("abababa", "aba")  # [0, 2, 4]
    """
    var indices = []
    val text_len = text.len()
    val pattern_len = pattern.len()

    if pattern_len > text_len:
        return indices

    var i = 0
    while i <= text_len - pattern_len:
        var match = true
        var j = 0

        while j < pattern_len:
            if text[i + j] != pattern[j]:
                match = false
                break
            j = j + 1

        if match:
            indices.push(i)

        i = i + 1

    indices

fn contains_substring(text: text, pattern: text):
    """Check if text contains pattern.

    Example:
        contains_substring("hello world", "world")  # true
    """
    substring_search(text, pattern) >= 0

# ============================================================================
# Pattern Matching
# ============================================================================

fn wildcard_match_helper(text: text, pattern: text, t_idx: i64, p_idx: i64):
    """Helper for wildcard matching."""
    # Base cases
    if p_idx == pattern.len():
        return t_idx == text.len()

    if t_idx == text.len():
        # Check if remaining pattern is all '*'
        var i = p_idx
        while i < pattern.len():
            if pattern[i] != '*':
                return false
            i = i + 1
        return true

    # Current characters
    val p_char = pattern[p_idx]

    # Match
    if p_char == '*':
        # Try matching zero or more characters
        # Zero characters
        if wildcard_match_helper(text, pattern, t_idx, p_idx + 1):
            return true
        # One or more characters
        return wildcard_match_helper(text, pattern, t_idx + 1, p_idx)
    elif p_char == '?' or p_char == text[t_idx]:
        return wildcard_match_helper(text, pattern, t_idx + 1, p_idx + 1)
    else:
        return false

fn wildcard_match(text: text, pattern: text):
    """Match text against wildcard pattern.

    Supports:
    - '*' matches zero or more characters
    - '?' matches exactly one character

    Example:
        wildcard_match("hello", "h*o")    # true
        wildcard_match("hello", "h?llo")  # true
        wildcard_match("hello", "h*x")    # false
    """
    wildcard_match_helper(text, pattern, 0, 0)

fn starts_with_pattern(text: text, prefix: text):
    """Check if text starts with prefix.

    Example:
        starts_with_pattern("hello world", "hello")  # true
    """
    if prefix.len() > text.len():
        return false

    var i = 0
    while i < prefix.len():
        if text[i] != prefix[i]:
            return false
        i = i + 1

    true

fn ends_with_pattern(text: text, suffix: text):
    """Check if text ends with suffix.

    Example:
        ends_with_pattern("hello world", "world")  # true
    """
    val text_len = text.len()
    val suffix_len = suffix.len()

    if suffix_len > text_len:
        return false

    var i = 0
    while i < suffix_len:
        if text[text_len - suffix_len + i] != suffix[i]:
            return false
        i = i + 1

    true

# ============================================================================
# Two Pointer Search
# ============================================================================

fn find_pair_with_sum(arr, target_sum):
    """Find pair of elements that sum to target.

    Array must be sorted.
    Returns (index1, index2) or nil.

    Example:
        find_pair_with_sum([1, 2, 3, 4, 5], 7)  # (1, 4) -> [2, 5]
    """
    var left = 0
    var right = arr.len() - 1

    while left < right:
        val current_sum = arr[left] + arr[right]

        if current_sum == target_sum:
            return (left, right)
        elif current_sum < target_sum:
            left = left + 1
        else:
            right = right - 1

    nil

fn find_triplet_with_sum(arr, target_sum):
    """Find three elements that sum to target.

    Array must be sorted.
    Returns (i, j, k) or nil.

    Example:
        find_triplet_with_sum([1, 2, 3, 4, 5], 9)  # (0, 2, 4) -> [1, 3, 5]
    """
    var i = 0
    while i < arr.len() - 2:
        var left = i + 1
        var right = arr.len() - 1

        while left < right:
            val current_sum = arr[i] + arr[left] + arr[right]

            if current_sum == target_sum:
                return (i, left, right)
            elif current_sum < target_sum:
                left = left + 1
            else:
                right = right - 1

        i = i + 1

    nil

# ============================================================================
# Search Utilities
# ============================================================================

fn find_min(arr):
    """Find minimum element in array.

    Example:
        find_min([3, 1, 4, 1, 5])  # 1
    """
    if arr.len() == 0:
        return nil

    var min_val = arr[0]
    for x in arr:
        if x < min_val:
            min_val = x

    min_val

fn find_max(arr):
    """Find maximum element in array.

    Example:
        find_max([3, 1, 4, 1, 5])  # 5
    """
    if arr.len() == 0:
        return nil

    var max_val = arr[0]
    for x in arr:
        if x > max_val:
            max_val = x

    max_val

fn find_min_max(arr):
    """Find both min and max in single pass.

    Returns (min, max) or nil.

    Example:
        find_min_max([3, 1, 4, 1, 5])  # (1, 5)
    """
    if arr.len() == 0:
        return nil

    var min_val = arr[0]
    var max_val = arr[0]

    for x in arr:
        if x < min_val:
            min_val = x
        if x > max_val:
            max_val = x

    (min_val, max_val)

fn count_occurrences(arr, target):
    """Count occurrences of target in array.

    Example:
        count_occurrences([1, 2, 2, 3, 2, 4], 2)  # 3
    """
    var count = 0
    for x in arr:
        if x == target:
            count = count + 1

    count

fn find_missing_number(arr, n: i64):
    """Find missing number in array [0..n].

    Array should contain n numbers from range [0, n].

    Example:
        find_missing_number([0, 1, 3, 4], 4)  # 2
    """
    # Sum of 0..n
    val expected_sum = n * (n + 1) / 2

    # Actual sum
    var actual_sum = 0
    for x in arr:
        actual_sum = actual_sum + x

    expected_sum - actual_sum

fn best_search_algorithm(arr_size: i64, is_sorted):
    """Recommend best search algorithm.

    Returns name of recommended algorithm.

    Example:
        best_search_algorithm(1000, true)   # "binary_search"
        best_search_algorithm(100, false)   # "linear_search"
    """
    if not is_sorted:
        return "linear_search"

    if arr_size < 100:
        return "linear_search"

    if arr_size < 10000:
        return "binary_search"

    "interpolation_search"


# FILE: src/std/set_utils.spl
# Size: 21498 bytes, Lines: 777

# Set Utilities Module
#
# Comprehensive set data structure implementation for Simple.
# Sets are collections of unique elements with efficient membership testing.
#
# Implementation Strategy:
# - Uses dictionary-backed sets for O(1) membership testing
# - Supports conversion to/from arrays and lists
# - Pure Simple implementation - no generics at runtime
# - Works with any hashable type (strings, numbers, etc.)
#
# Categories:
# - Creation: set_new, set_from_array, set_from_list
# - Basic ops: set_add, set_remove, set_contains, set_size, set_is_empty, set_clear
# - Set algebra: set_union, set_intersection, set_difference, set_symmetric_difference
# - Predicates: set_is_subset, set_is_superset, set_is_disjoint, set_equals
# - Transformations: set_map, set_filter, set_partition
# - Conversion: set_to_array, set_to_list, set_to_sorted_array
# - Multi-element: set_add_all, set_remove_all, set_retain_all
# - Advanced: set_powerset, set_cartesian_product, set_comprehension
# - Iteration: set_foreach, set_reduce, set_any, set_all
# - Copying: set_copy, set_clone
#
# Set representation: Dictionary where keys are elements (as strings) and values are the original elements.
# This allows O(1) lookup while preserving the original values.

# ============================================================================
# Type Helpers - Convert values to hashable keys
# ============================================================================

fn _to_key(value) -> text:
    """Convert value to string key for hashing.
    Works around runtime limitations by using string representation."""
    "{value}"

fn _from_key(key: text, original):
    """Extract original value. For simple types, use the original passed value."""
    original

# ============================================================================
# Set Creation
# ============================================================================

fn set_new():
    """Create a new empty set.

    Returns a dictionary representing the set.

    Example:
        val s = set_new()
        set_is_empty(s)  # true
    """
    {}

fn set_from_array(arr):
    """Create a set from an array, removing duplicates.

    Example:
        set_from_array([1, 2, 2, 3, 1])  # Set containing {1, 2, 3}
    """
    var s = set_new()
    for item in arr:
        s = set_add(s, item)
    s

fn set_from_list(list):
    """Create a set from a list, removing duplicates.

    Example:
        set_from_list([1, 2, 2, 3])  # Set containing {1, 2, 3}
    """
    set_from_array(list)

fn set_of(items):
    """Create a set from variable number of items (passed as array).

    Example:
        set_of([1, 2, 3])  # Set containing {1, 2, 3}
    """
    set_from_array(items)

# ============================================================================
# Basic Set Operations
# ============================================================================

fn set_add(s, item):
    """Add an element to the set. Returns new set.
    If element already exists, returns the original set unchanged.

    Example:
        var s = set_new()
        s = set_add(s, 42)
        set_contains(s, 42)  # true
    """
    val key = _to_key(item)
    if s.contains_key(key):
        return s
    var result = {}
    for k in s.keys():
        result[k] = s[k]
    result[key] = item
    result

fn set_remove(s, item):
    """Remove an element from the set. Returns new set.
    If element doesn't exist, returns the original set unchanged.

    Example:
        var s = set_from_array([1, 2, 3])
        s = set_remove(s, 2)
        set_contains(s, 2)  # false
    """
    val key = _to_key(item)
    if not s.contains_key(key):
        return s
    var result = {}
    for k in s.keys():
        if k != key:
            result[k] = s[k]
    result

fn set_contains(s, item) -> bool:
    """Check if element is in the set.

    Example:
        val s = set_from_array([1, 2, 3])
        set_contains(s, 2)  # true
        set_contains(s, 5)  # false
    """
    val key = _to_key(item)
    s.contains_key(key)

fn set_size(s) -> i64:
    """Get the number of elements in the set.

    Example:
        val s = set_from_array([1, 2, 3])
        set_size(s)  # 3
    """
    s.keys().len()

fn set_is_empty(s) -> bool:
    """Check if set is empty.

    Example:
        set_is_empty(set_new())  # true
    """
    s.keys().len() == 0

fn set_clear(s):
    """Remove all elements from the set. Returns empty set.

    Example:
        var s = set_from_array([1, 2, 3])
        s = set_clear(s)
        set_is_empty(s)  # true
    """
    {}

# ============================================================================
# Set Algebra Operations
# ============================================================================

fn set_union(a, b):
    """Union of two sets - all elements from both sets.

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([3, 4, 5])
        val u = set_union(a, b)  # {1, 2, 3, 4, 5}
    """
    var result = {}
    for k in a.keys():
        result[k] = a[k]
    for k in b.keys():
        result[k] = b[k]
    result

fn set_intersection(a, b):
    """Intersection of two sets - elements present in both.

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([2, 3, 4])
        val i = set_intersection(a, b)  # {2, 3}
    """
    var result = {}
    for k in a.keys():
        if b.contains_key(k):
            result[k] = a[k]
    result

fn set_difference(a, b):
    """Difference of two sets - elements in A but not in B.

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([2, 3, 4])
        val d = set_difference(a, b)  # {1}
    """
    var result = {}
    for k in a.keys():
        if not b.contains_key(k):
            result[k] = a[k]
    result

fn set_symmetric_difference(a, b):
    """Symmetric difference - elements in A or B but not in both.

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([2, 3, 4])
        val sd = set_symmetric_difference(a, b)  # {1, 4}
    """
    var result = {}
    for k in a.keys():
        if not b.contains_key(k):
            result[k] = a[k]
    for k in b.keys():
        if not a.contains_key(k):
            result[k] = b[k]
    result

# ============================================================================
# Set Predicates
# ============================================================================

fn set_is_subset(a, b) -> bool:
    """Check if A is a subset of B (all elements of A are in B).

    Example:
        val a = set_from_array([1, 2])
        val b = set_from_array([1, 2, 3])
        set_is_subset(a, b)  # true
    """
    for k in a.keys():
        if not b.contains_key(k):
            return false
    true

fn set_is_superset(a, b) -> bool:
    """Check if A is a superset of B (all elements of B are in A).

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([1, 2])
        set_is_superset(a, b)  # true
    """
    set_is_subset(b, a)

fn set_is_disjoint(a, b) -> bool:
    """Check if two sets have no elements in common.

    Example:
        val a = set_from_array([1, 2])
        val b = set_from_array([3, 4])
        set_is_disjoint(a, b)  # true
    """
    for k in a.keys():
        if b.contains_key(k):
            return false
    true

fn set_equals(a, b) -> bool:
    """Check if two sets are equal (same elements).

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([3, 2, 1])
        set_equals(a, b)  # true
    """
    if set_size(a) != set_size(b):
        return false
    set_is_subset(a, b)

# ============================================================================
# Set Transformations
# ============================================================================

fn set_map(s, mapper):
    """Map a function over all elements, creating a new set.

    Example:
        val s = set_from_array([1, 2, 3])
        val doubled = set_map(s, \x: x * 2)  # {2, 4, 6}
    """
    var result = set_new()
    for k in s.keys():
        val mapped = mapper(s[k])
        result = set_add(result, mapped)
    result

fn set_filter(s, predicate):
    """Filter set elements by predicate, creating a new set.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val evens = set_filter(s, \x: x % 2 == 0)  # {2, 4}
    """
    var result = set_new()
    for k in s.keys():
        if predicate(s[k]):
            result = set_add(result, s[k])
    result

fn set_partition(s, predicate):
    """Partition set into two sets based on predicate.
    Returns tuple (matching_set, non_matching_set).

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val parts = set_partition(s, \x: x % 2 == 0)
        # parts[0] = {2, 4}, parts[1] = {1, 3, 5}
    """
    var matching = set_new()
    var non_matching = set_new()
    for k in s.keys():
        if predicate(s[k]):
            matching = set_add(matching, s[k])
        else:
            non_matching = set_add(non_matching, s[k])
    (matching, non_matching)

# ============================================================================
# Set Conversion
# ============================================================================

fn set_to_array(s):
    """Convert set to array. Order is not guaranteed.

    Example:
        val s = set_from_array([3, 1, 2])
        val arr = set_to_array(s)  # [1, 2, 3] or any order
    """
    var result = []
    for k in s.keys():
        result.push(s[k])
    result

fn set_to_list(s):
    """Convert set to list. Order is not guaranteed.

    Example:
        val s = set_from_array([3, 1, 2])
        val list = set_to_list(s)
    """
    set_to_array(s)

fn set_to_sorted_array(s):
    """Convert set to sorted array.
    Uses built-in sort() which works for comparable types.

    Example:
        val s = set_from_array([3, 1, 2])
        val arr = set_to_sorted_array(s)  # [1, 2, 3]
    """
    var arr = set_to_array(s)
    arr.sort()
    arr

# ============================================================================
# Multi-element Operations
# ============================================================================

fn set_add_all(s, items):
    """Add multiple elements to the set. Returns new set.

    Example:
        var s = set_new()
        s = set_add_all(s, [1, 2, 3])
        set_size(s)  # 3
    """
    var result = s
    for item in items:
        result = set_add(result, item)
    result

fn set_remove_all(s, items):
    """Remove multiple elements from the set. Returns new set.

    Example:
        var s = set_from_array([1, 2, 3, 4, 5])
        s = set_remove_all(s, [2, 4])
        # s now contains {1, 3, 5}
    """
    var result = s
    for item in items:
        result = set_remove(result, item)
    result

fn set_retain_all(s, items):
    """Retain only the specified elements. Returns new set.
    Equivalent to intersection with items.

    Example:
        var s = set_from_array([1, 2, 3, 4, 5])
        s = set_retain_all(s, [2, 3, 6])
        # s now contains {2, 3}
    """
    val items_set = set_from_array(items)
    set_intersection(s, items_set)

# ============================================================================
# Advanced Set Operations
# ============================================================================

fn set_powerset(s):
    """Generate the powerset (set of all subsets).
    Returns array of sets.

    Warning: Size grows exponentially (2^n). Use with small sets.

    Example:
        val s = set_from_array([1, 2])
        val ps = set_powerset(s)
        # [{}, {1}, {2}, {1, 2}]
    """
    val elements = set_to_array(s)
    var subsets = [set_new()]

    for elem in elements:
        var new_subsets = []
        for subset in subsets:
            var new_subset = set_add(subset, elem)
            new_subsets.push(new_subset)
        for new_subset in new_subsets:
            subsets.push(new_subset)

    subsets

fn set_cartesian_product(a, b):
    """Compute Cartesian product of two sets.
    Returns set of tuples (pairs).

    Example:
        val a = set_from_array([1, 2])
        val b = set_from_array(["x", "y"])
        val prod = set_cartesian_product(a, b)
        # {(1, "x"), (1, "y"), (2, "x"), (2, "y")}
    """
    var result = set_new()
    for k1 in a.keys():
        for k2 in b.keys():
            val pair = (a[k1], b[k2])
            result = set_add(result, pair)
    result

fn set_comprehension(source, predicate, mapper):
    """Set comprehension: {mapper(x) | x <- source if predicate(x)}.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val comp = set_comprehension(s, \x: x % 2 == 0, \x: x * x)
        # {4, 16} - squares of even numbers
    """
    var result = set_new()
    for k in source.keys():
        if predicate(source[k]):
            val mapped = mapper(source[k])
            result = set_add(result, mapped)
    result

# ============================================================================
# Iteration Operations
# ============================================================================

fn set_foreach(s, action):
    """Execute action for each element in the set.

    Example:
        val s = set_from_array([1, 2, 3])
        set_foreach(s, \x: print("{x}"))
    """
    for k in s.keys():
        action(s[k])
    nil

fn set_reduce(s, initial, reducer):
    """Reduce set to a single value using reducer function.

    Example:
        val s = set_from_array([1, 2, 3, 4])
        val sum = set_reduce(s, 0, \acc, x: acc + x)  # 10
    """
    var acc = initial
    for k in s.keys():
        acc = reducer(acc, s[k])
    acc

fn set_any(s, predicate) -> bool:
    """Check if any element satisfies the predicate.

    Example:
        val s = set_from_array([1, 2, 3, 4])
        set_any(s, \x: x > 3)  # true
    """
    for k in s.keys():
        if predicate(s[k]):
            return true
    false

fn set_all(s, predicate) -> bool:
    """Check if all elements satisfy the predicate.

    Example:
        val s = set_from_array([2, 4, 6, 8])
        set_all(s, \x: x % 2 == 0)  # true
    """
    for k in s.keys():
        if not predicate(s[k]):
            return false
    true

fn set_count(s, predicate) -> i64:
    """Count elements that satisfy the predicate.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        set_count(s, \x: x % 2 == 0)  # 2
    """
    var count = 0
    for k in s.keys():
        if predicate(s[k]):
            count = count + 1
    count

fn set_find(s, predicate):
    """Find first element satisfying predicate. Returns nil if not found.

    Note: Order is not guaranteed in sets.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val found = set_find(s, \x: x > 3)  # Could be 4 or 5
    """
    for k in s.keys():
        if predicate(s[k]):
            return s[k]
    nil

# ============================================================================
# Set Copying
# ============================================================================

fn set_copy(s):
    """Create a shallow copy of the set.

    Example:
        val s1 = set_from_array([1, 2, 3])
        val s2 = set_copy(s1)
        set_equals(s1, s2)  # true
    """
    var result = {}
    for k in s.keys():
        result[k] = s[k]
    result

fn set_clone(s):
    """Alias for set_copy.

    Example:
        val s2 = set_clone(s1)
    """
    set_copy(s)

# ============================================================================
# Set Utility Operations
# ============================================================================

fn set_min(s):
    """Find minimum element in set. Returns nil for empty set.

    Example:
        val s = set_from_array([3, 1, 4, 1, 5])
        set_min(s)  # 1
    """
    val arr = set_to_array(s)
    if arr.len() == 0:
        return nil
    var min_val = arr[0]
    var i = 1
    while i < arr.len():
        if arr[i] < min_val:
            min_val = arr[i]
        i = i + 1
    min_val

fn set_max(s):
    """Find maximum element in set. Returns nil for empty set.

    Example:
        val s = set_from_array([3, 1, 4, 1, 5])
        set_max(s)  # 5
    """
    val arr = set_to_array(s)
    if arr.len() == 0:
        return nil
    var max_val = arr[0]
    var i = 1
    while i < arr.len():
        if arr[i] > max_val:
            max_val = arr[i]
        i = i + 1
    max_val

fn set_sum(s):
    """Sum all numeric elements in set.

    Example:
        val s = set_from_array([1, 2, 3, 4])
        set_sum(s)  # 10
    """
    set_reduce(s, 0, \acc, x: acc + x)

fn set_product(s):
    """Multiply all numeric elements in set.

    Example:
        val s = set_from_array([2, 3, 4])
        set_product(s)  # 24
    """
    set_reduce(s, 1, \acc, x: acc * x)

# ============================================================================
# Set Display
# ============================================================================

fn set_to_string(s) -> text:
    """Convert set to string representation.

    Example:
        val s = set_from_array([1, 2, 3])
        set_to_string(s)  # "{1, 2, 3}" (order may vary)
    """
    val arr = set_to_sorted_array(s)
    if arr.len() == 0:
        return "{}"

    var result = "{"
    var i = 0
    while i < arr.len():
        if i > 0:
            result = result + ", "
        result = result + "{arr[i]}"
        i = i + 1
    result + "}"

# ============================================================================
# Convenience Functions
# ============================================================================

fn set_pop(s):
    """Remove and return an arbitrary element from the set.
    Returns tuple (element, new_set) or (nil, s) if empty.

    Example:
        var s = set_from_array([1, 2, 3])
        val result = set_pop(s)
        val elem = result[0]
        s = result[1]
    """
    val keys = s.keys()
    if keys.len() == 0:
        return (nil, s)

    val first_key = keys[0]
    val elem = s[first_key]
    val new_set = set_remove(s, elem)
    (elem, new_set)

fn set_sample(s):
    """Get an arbitrary element from the set without removing it.
    Returns nil if empty.

    Example:
        val s = set_from_array([1, 2, 3])
        val elem = set_sample(s)  # Could be 1, 2, or 3
    """
    val keys = s.keys()
    if keys.len() == 0:
        return nil
    s[keys[0]]

fn set_split_at(s, n: i64):
    """Split set into two sets at position n.
    Returns tuple (first_n_elements_set, rest_set).

    Note: Order is not guaranteed.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val parts = set_split_at(s, 3)
        # parts[0] has 3 elements, parts[1] has 2
    """
    val arr = set_to_array(s)
    if n >= arr.len():
        return (s, set_new())
    if n <= 0:
        return (set_new(), s)

    var first_part = set_new()
    var second_part = set_new()
    var i = 0
    while i < arr.len():
        if i < n:
            first_part = set_add(first_part, arr[i])
        else:
            second_part = set_add(second_part, arr[i])
        i = i + 1
    (first_part, second_part)

# ============================================================================
# Examples and Usage
# ============================================================================

fn _example_basic_usage():
    """Example: Basic set operations"""
    # Create a set
    var s = set_new()
    s = set_add(s, 1)
    s = set_add(s, 2)
    s = set_add(s, 3)
    s = set_add(s, 2)  # Duplicate ignored

    print("Size: {set_size(s)}")  # 3
    print("Contains 2: {set_contains(s, 2)}")  # true
    print("Contains 5: {set_contains(s, 5)}")  # false

    # Remove element
    s = set_remove(s, 2)
    print("After removing 2: {set_to_string(s)}")

fn _example_set_algebra():
    """Example: Set algebra operations"""
    val a = set_from_array([1, 2, 3, 4])
    val b = set_from_array([3, 4, 5, 6])

    print("Union: {set_to_string(set_union(a, b))}")
    print("Intersection: {set_to_string(set_intersection(a, b))}")
    print("Difference A-B: {set_to_string(set_difference(a, b))}")
    print("Symmetric diff: {set_to_string(set_symmetric_difference(a, b))}")

fn _example_transformations():
    """Example: Set transformations"""
    val s = set_from_array([1, 2, 3, 4, 5])

    # Map: square all numbers
    val squared = set_map(s, \x: x * x)
    print("Squared: {set_to_string(squared)}")

    # Filter: keep only even numbers
    val evens = set_filter(s, \x: x % 2 == 0)
    print("Evens: {set_to_string(evens)}")

    # Partition: separate even and odd
    val parts = set_partition(s, \x: x % 2 == 0)
    print("Even partition: {set_to_string(parts[0])}")
    print("Odd partition: {set_to_string(parts[1])}")

fn _example_advanced():
    """Example: Advanced operations"""
    val s = set_from_array([1, 2, 3])

    # Powerset
    val ps = set_powerset(s)
    print("Powerset size: {ps.len()}")  # 2^3 = 8

    # Cartesian product
    val colors = set_from_array(["red", "blue"])
    val sizes = set_from_array(["S", "M"])
    val combos = set_cartesian_product(colors, sizes)
    print("Combinations: {set_size(combos)}")  # 4

    # Set comprehension
    val numbers = set_from_array([1, 2, 3, 4, 5, 6])
    val result = set_comprehension(numbers, \x: x % 2 == 0, \x: x * x)
    print("Squares of evens: {set_to_string(result)}")  # {4, 16, 36}


# FILE: src/std/skiplist_utils.spl
# Size: 31141 bytes, Lines: 1105

# Skip List Probabilistic Data Structure Utilities
#
# This module provides a comprehensive implementation of skip lists, a probabilistic
# data structure that provides O(log n) expected time for search, insert, and delete
# operations without the complexity of balancing trees.
#
# Skip lists use randomization to maintain balance through multiple levels of linked
# lists, where each level acts as an "express lane" for the levels below it.
#
# Key features:
# - Standard skip list for sorted sets
# - Skip list map for key-value pairs
# - Index-based access (O(log n) by index)
# - Range queries
# - Set operations (union, intersection, difference)
# - No rebalancing needed (probabilistic balance)
#
# Typical performance (expected):
# - Search: O(log n)
# - Insert: O(log n)
# - Delete: O(log n)
# - Space: O(n) with 1.33n to 2n nodes depending on probability
#
# Structure visualization:
# Level 3:  HEAD -------------------------> 30 ----------> NIL
# Level 2:  HEAD -------> 10 -------------> 30 ----------> NIL
# Level 1:  HEAD -------> 10 --> 20 ------> 30 --> 40 ---> NIL
# Level 0:  HEAD -> 5 -> 10 -> 20 -> 25 -> 30 -> 40 -> 50 -> NIL

# =============================================================================
# TYPES - Type Definitions and Constants
# =============================================================================

# Default maximum level for skip list (supports up to 2^16 = 65536 elements at p=0.5)
val DEFAULT_MAX_LEVEL = 16

# Default probability for level promotion (0.5 = coin flip)
val DEFAULT_PROBABILITY = 0.5

# Alternative probability for better space efficiency
val CONSERVATIVE_PROBABILITY = 0.25

# Sentinel value for nil node pointers
val NIL_NODE = -1

# Global state for random number generator
var rng_seed = 1234567890

# Node: (value: i64, forward: list of node indices, level: i64)
# Forward list contains indices into the nodes array, NIL_NODE for end

# SkipList: (nodes: list of nodes, head_idx: i64, max_level: i64,
#            current_level: i64, probability: f64, size: i64)

# SkipListMap: (keys: skiplist, entries: list of (key_hash, key, value))
# We use a simple hash for ordering, but store full key for lookup

# =============================================================================
# TYPES - Internal Node Accessors
# =============================================================================

fn create_node(value: i64, level: i64) -> tuple:
    var forward = []
    var i = 0
    while i <= level:
        forward = forward + [NIL_NODE]
        i = i + 1
    (value, forward, level)

fn get_node_value(node: tuple) -> i64:
    var v = node[0]
    v

fn get_node_forward(node: tuple) -> list:
    var f = node[1]
    f

fn get_node_level(node: tuple) -> i64:
    var l = node[2]
    l

fn set_node_forward_at(node: tuple, level: i64, target: i64) -> tuple:
    var value = get_node_value(node)
    var forward = get_node_forward(node)
    var node_level = get_node_level(node)
    var new_forward = []
    var i = 0
    while i < forward.len():
        if i == level:
            new_forward = new_forward + [target]
        else:
            var existing = forward[i]
            new_forward = new_forward + [existing]
        i = i + 1
    (value, new_forward, node_level)

fn get_node_forward_at(node: tuple, level: i64) -> i64:
    var forward = get_node_forward(node)
    var target = forward[level]
    target

# =============================================================================
# TYPES - Internal SkipList Accessors
# =============================================================================

fn sl_get_nodes(skiplist: tuple) -> list:
    var n = skiplist[0]
    n

fn sl_get_head_idx(skiplist: tuple) -> i64:
    var h = skiplist[1]
    h

fn sl_get_max_level(skiplist: tuple) -> i64:
    var m = skiplist[2]
    m

fn sl_get_current_level(skiplist: tuple) -> i64:
    var c = skiplist[3]
    c

fn sl_get_probability(skiplist: tuple) -> f64:
    var p = skiplist[4]
    p

fn sl_get_size(skiplist: tuple) -> i64:
    var s = skiplist[5]
    s

fn sl_set_nodes(skiplist: tuple, nodes: list) -> tuple:
    var head_idx = sl_get_head_idx(skiplist)
    var max_level = sl_get_max_level(skiplist)
    var current_level = sl_get_current_level(skiplist)
    var probability = sl_get_probability(skiplist)
    var size = sl_get_size(skiplist)
    (nodes, head_idx, max_level, current_level, probability, size)

fn sl_set_current_level(skiplist: tuple, level: i64) -> tuple:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var max_level = sl_get_max_level(skiplist)
    var probability = sl_get_probability(skiplist)
    var size = sl_get_size(skiplist)
    (nodes, head_idx, max_level, level, probability, size)

fn sl_set_size(skiplist: tuple, new_size: i64) -> tuple:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var max_level = sl_get_max_level(skiplist)
    var current_level = sl_get_current_level(skiplist)
    var probability = sl_get_probability(skiplist)
    (nodes, head_idx, max_level, current_level, probability, new_size)

# =============================================================================
# TYPES - Internal SkipListMap Accessors
# =============================================================================

fn slm_get_keys(map: tuple) -> tuple:
    var k = map[0]
    k

fn slm_get_entries(map: tuple) -> list:
    var e = map[1]
    e

fn slm_set_keys(map: tuple, keys: tuple) -> tuple:
    var entries = slm_get_entries(map)
    (keys, entries)

fn slm_set_entries(map: tuple, entries: list) -> tuple:
    var keys = slm_get_keys(map)
    (keys, entries)

# =============================================================================
# CREATE - Skip List Creation and Initialization
# =============================================================================

fn create_skiplist() -> tuple:
    create_skiplist_with_params(DEFAULT_MAX_LEVEL, DEFAULT_PROBABILITY)

fn create_skiplist_with_max_level(max_level: i64) -> tuple:
    create_skiplist_with_params(max_level, DEFAULT_PROBABILITY)

fn create_skiplist_with_probability(probability: f64) -> tuple:
    create_skiplist_with_params(DEFAULT_MAX_LEVEL, probability)

fn create_skiplist_with_params(max_level: i64, probability: f64) -> tuple:
    var head = create_node(-999999999, max_level)
    var nodes = [head]
    var head_idx = 0
    var current_level = 0
    var size = 0
    (nodes, head_idx, max_level, current_level, probability, size)

fn create_skiplist_map() -> tuple:
    var keys = create_skiplist()
    var entries = []
    (keys, entries)

fn sl_from_list(values: list) -> tuple:
    var result = create_skiplist()
    sl_insert_many(result, values)

# =============================================================================
# CREATE - Random Number Generation (for level generation)
# =============================================================================

fn set_random_seed(seed: i64):
    var global_seed = rng_seed
    global_seed = seed
    rng_seed = global_seed

fn next_random() -> i64:
    var seed = rng_seed
    var a = 1103515245
    var c = 12345
    var m = 2147483648
    var next = ((seed * a) + c) % m
    rng_seed = next
    next

fn random_float() -> f64:
    var r = next_random()
    var m = 2147483648.0
    var rf = r
    rf / m

fn random_level(max_level: i64, probability: f64) -> i64:
    var level = 0
    while random_float() < probability:
        if level >= max_level:
            return level
        level = level + 1
    level

fn should_increase_level(probability: f64) -> i64:
    var r = random_float()
    if r < probability:
        1
    else:
        0

# =============================================================================
# INSERT - Insertion Operations
# =============================================================================

fn sl_insert(skiplist: tuple, value: i64) -> tuple:
    var nodes = sl_get_nodes(skiplist)
    var current_level = sl_get_current_level(skiplist)
    var max_level = sl_get_max_level(skiplist)
    var probability = sl_get_probability(skiplist)
    var size = sl_get_size(skiplist)

    # Check if already exists
    var exists_idx = sl_search(skiplist, value)
    if exists_idx != NIL_NODE:
        return skiplist

    # Find update path
    var update = sl_find_update_path(skiplist, value)

    # Generate random level
    var new_level = random_level(max_level, probability)

    # Update current level if necessary
    var updated_level = current_level
    if new_level > current_level:
        var i = current_level + 1
        while i <= new_level:
            var head_idx = sl_get_head_idx(skiplist)
            var new_update = []
            var j = 0
            while j <= max_level:
                if j == i:
                    new_update = new_update + [head_idx]
                else:
                    var existing = update[j]
                    new_update = new_update + [existing]
                j = j + 1
            update = new_update
            i = i + 1
        updated_level = new_level

    # Create new node
    var new_node = create_node(value, new_level)
    var new_idx = nodes.len()
    var updated_nodes = nodes + [new_node]

    # Update forward pointers
    var level = 0
    while level <= new_level:
        var pred_idx = update[level]
        var pred = updated_nodes[pred_idx]
        var next_idx = get_node_forward_at(pred, level)

        # Set new node's forward pointer
        var updated_new_node = set_node_forward_at(new_node, level, next_idx)
        var temp_nodes = []
        var k = 0
        while k < updated_nodes.len():
            if k == new_idx:
                temp_nodes = temp_nodes + [updated_new_node]
            else:
                var existing_node = updated_nodes[k]
                temp_nodes = temp_nodes + [existing_node]
            k = k + 1
        updated_nodes = temp_nodes
        new_node = updated_new_node

        # Update predecessor's forward pointer
        var updated_pred = set_node_forward_at(pred, level, new_idx)
        var temp_nodes2 = []
        var m = 0
        while m < updated_nodes.len():
            if m == pred_idx:
                temp_nodes2 = temp_nodes2 + [updated_pred]
            else:
                var existing_node2 = updated_nodes[m]
                temp_nodes2 = temp_nodes2 + [existing_node2]
            m = m + 1
        updated_nodes = temp_nodes2

        level = level + 1

    var result = sl_set_nodes(skiplist, updated_nodes)
    result = sl_set_current_level(result, updated_level)
    result = sl_set_size(result, size + 1)
    result

fn sl_insert_many(skiplist: tuple, values: list) -> tuple:
    var result = skiplist
    var i = 0
    while i < values.len():
        var v = values[i]
        result = sl_insert(result, v)
        i = i + 1
    result

fn slm_put(map: tuple, key: text, value: text) -> tuple:
    var hash = hash_string(key)
    var keys = slm_get_keys(map)
    var entries = slm_get_entries(map)

    var entry_idx = slm_find_entry(map, key)

    if entry_idx >= 0:
        var new_entries = []
        var i = 0
        while i < entries.len():
            if i == entry_idx:
                new_entries = new_entries + [(hash, key, value)]
            else:
                var existing = entries[i]
                new_entries = new_entries + [existing]
            i = i + 1
        return slm_set_entries(map, new_entries)

    var updated_keys = sl_insert(keys, hash)
    var new_entry = (hash, key, value)
    var updated_entries = entries + [new_entry]

    var result = slm_set_keys(map, updated_keys)
    result = slm_set_entries(result, updated_entries)
    result

# =============================================================================
# SEARCH - Search and Lookup Operations
# =============================================================================

fn sl_find_update_path(skiplist: tuple, value: i64) -> list:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var current_level = sl_get_current_level(skiplist)
    var max_level = sl_get_max_level(skiplist)

    var update = []
    var i = 0
    while i <= max_level:
        update = update + [NIL_NODE]
        i = i + 1

    var current_idx = head_idx
    var level = current_level

    while level >= 0:
        var current_node = nodes[current_idx]
        var next_idx = get_node_forward_at(current_node, level)

        while next_idx != NIL_NODE:
            var next_node = nodes[next_idx]
            var next_value = get_node_value(next_node)
            if next_value >= value:
                break
            current_idx = next_idx
            current_node = nodes[current_idx]
            next_idx = get_node_forward_at(current_node, level)

        var new_update = []
        var j = 0
        while j <= max_level:
            if j == level:
                new_update = new_update + [current_idx]
            else:
                var existing = update[j]
                new_update = new_update + [existing]
            j = j + 1
        update = new_update

        level = level - 1

    update

fn sl_search(skiplist: tuple, value: i64) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var update = sl_find_update_path(skiplist, value)
    var pred_idx = update[0]
    var pred = nodes[pred_idx]
    var next_idx = get_node_forward_at(pred, 0)

    if next_idx != NIL_NODE:
        var next_node = nodes[next_idx]
        var next_value = get_node_value(next_node)
        if next_value == value:
            return next_idx

    NIL_NODE

fn sl_contains(skiplist: tuple, value: i64) -> i64:
    var idx = sl_search(skiplist, value)
    if idx != NIL_NODE:
        1
    else:
        0

fn sl_find_closest(skiplist: tuple, value: i64) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var update = sl_find_update_path(skiplist, value)
    var pred_idx = update[0]
    var pred = nodes[pred_idx]
    var next_idx = get_node_forward_at(pred, 0)

    if next_idx != NIL_NODE:
        var next_node = nodes[next_idx]
        var next_value = get_node_value(next_node)
        if next_value == value:
            return next_value

    var head_idx = sl_get_head_idx(skiplist)
    if pred_idx != head_idx:
        var pred_value = get_node_value(pred)
        return pred_value

    0

fn sl_min(skiplist: tuple) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var head = nodes[head_idx]
    var first_idx = get_node_forward_at(head, 0)

    if first_idx != NIL_NODE:
        var first_node = nodes[first_idx]
        var first_value = get_node_value(first_node)
        return first_value

    0

fn sl_max(skiplist: tuple) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var current_level = sl_get_current_level(skiplist)

    var current_idx = head_idx
    var level = current_level

    while level >= 0:
        var current_node = nodes[current_idx]
        var next_idx = get_node_forward_at(current_node, level)

        while next_idx != NIL_NODE:
            current_idx = next_idx
            current_node = nodes[current_idx]
            next_idx = get_node_forward_at(current_node, level)

        level = level - 1

    if current_idx != head_idx:
        var last_node = nodes[current_idx]
        var last_value = get_node_value(last_node)
        return last_value

    0

fn sl_first(skiplist: tuple) -> i64:
    sl_min(skiplist)

fn sl_last(skiplist: tuple) -> i64:
    sl_max(skiplist)

fn sl_get_at(skiplist: tuple, index: i64) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var head = nodes[head_idx]
    var current_idx = get_node_forward_at(head, 0)

    var i = 0
    while current_idx != NIL_NODE:
        if i == index:
            var current_node = nodes[current_idx]
            var current_value = get_node_value(current_node)
            return current_value

        current_idx = get_node_forward_at(nodes[current_idx], 0)
        i = i + 1

    0

fn sl_index_of(skiplist: tuple, value: i64) -> i64:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var head = nodes[head_idx]
    var current_idx = get_node_forward_at(head, 0)

    var index = 0
    while current_idx != NIL_NODE:
        var current_node = nodes[current_idx]
        var current_value = get_node_value(current_node)

        if current_value == value:
            return index

        current_idx = get_node_forward_at(current_node, 0)
        index = index + 1

    -1

fn sl_range(skiplist: tuple, min_val: i64, max_val: i64) -> list:
    var nodes = sl_get_nodes(skiplist)
    var update = sl_find_update_path(skiplist, min_val)
    var pred_idx = update[0]
    var pred = nodes[pred_idx]
    var current_idx = get_node_forward_at(pred, 0)

    var result = []

    while current_idx != NIL_NODE:
        var current_node = nodes[current_idx]
        var current_value = get_node_value(current_node)

        if current_value > max_val:
            break

        if current_value >= min_val:
            result = result + [current_value]

        current_idx = get_node_forward_at(current_node, 0)

    result

fn sl_range_count(skiplist: tuple, min_val: i64, max_val: i64) -> i64:
    var range_list = sl_range(skiplist, min_val, max_val)
    range_list.len()

fn sl_greater_than(skiplist: tuple, value: i64) -> list:
    var max_value = 2147483647
    sl_range(skiplist, value + 1, max_value)

fn sl_less_than(skiplist: tuple, value: i64) -> list:
    var min_value = -2147483648
    sl_range(skiplist, min_value, value - 1)

fn sl_greater_or_equal(skiplist: tuple, value: i64) -> list:
    var max_value = 2147483647
    sl_range(skiplist, value, max_value)

fn sl_less_or_equal(skiplist: tuple, value: i64) -> list:
    var min_value = -2147483648
    sl_range(skiplist, min_value, value)

fn hash_string(s: text) -> i64:
    var hash = 0
    var i = 0
    var len = s.len()

    while i < len:
        var code = 0
        if i < len:
            code = hash * 31
        hash = code + i
        i = i + 1

    if hash < 0:
        hash = 0 - hash

    hash

fn slm_find_entry(map: tuple, key: text) -> i64:
    var hash = hash_string(key)
    var entries = slm_get_entries(map)
    var i = 0

    while i < entries.len():
        var entry = entries[i]
        var entry_hash = entry[0]
        var entry_key = entry[1]

        if entry_hash == hash:
            if entry_key == key:
                return i

        i = i + 1

    -1

fn slm_get(map: tuple, key: text) -> text:
    var entry_idx = slm_find_entry(map, key)

    if entry_idx >= 0:
        var entries = slm_get_entries(map)
        var entry = entries[entry_idx]
        var value = entry[2]
        return value

    ""

fn slm_contains_key(map: tuple, key: text) -> i64:
    var entry_idx = slm_find_entry(map, key)
    if entry_idx >= 0:
        1
    else:
        0

fn slm_keys(map: tuple) -> list:
    var entries = slm_get_entries(map)
    var result = []
    var i = 0

    while i < entries.len():
        var entry = entries[i]
        var key = entry[1]
        result = result + [key]
        i = i + 1

    result

fn slm_values(map: tuple) -> list:
    var entries = slm_get_entries(map)
    var result = []
    var i = 0

    while i < entries.len():
        var entry = entries[i]
        var value = entry[2]
        result = result + [value]
        i = i + 1

    result

fn slm_entries(map: tuple) -> list:
    var entries = slm_get_entries(map)
    var result = []
    var i = 0

    while i < entries.len():
        var entry = entries[i]
        var key = entry[1]
        var value = entry[2]
        result = result + [(key, value)]
        i = i + 1

    result

# =============================================================================
# DELETE - Deletion Operations
# =============================================================================

fn sl_delete(skiplist: tuple, value: i64) -> tuple:
    var nodes = sl_get_nodes(skiplist)
    var current_level = sl_get_current_level(skiplist)
    var size = sl_get_size(skiplist)
    var max_level = sl_get_max_level(skiplist)

    # Find update path
    var update = sl_find_update_path(skiplist, value)
    var pred_idx = update[0]
    var pred = nodes[pred_idx]
    var target_idx = get_node_forward_at(pred, 0)

    if target_idx == NIL_NODE:
        return skiplist

    var target_node = nodes[target_idx]
    var target_value = get_node_value(target_node)
    if target_value != value:
        return skiplist

    # Update forward pointers
    var updated_nodes = nodes
    var level = 0
    var target_level = get_node_level(target_node)

    while level <= target_level:
        var pred_idx2 = update[level]
        var pred2 = updated_nodes[pred_idx2]
        var target_next = get_node_forward_at(target_node, level)
        var updated_pred = set_node_forward_at(pred2, level, target_next)

        var temp_nodes = []
        var k = 0
        while k < updated_nodes.len():
            if k == pred_idx2:
                temp_nodes = temp_nodes + [updated_pred]
            else:
                var existing_node = updated_nodes[k]
                temp_nodes = temp_nodes + [existing_node]
            k = k + 1
        updated_nodes = temp_nodes

        level = level + 1

    # Update current level if necessary
    var head_idx = sl_get_head_idx(skiplist)
    var head = updated_nodes[head_idx]
    var updated_level = current_level
    while updated_level > 0:
        var next_idx = get_node_forward_at(head, updated_level)
        if next_idx != NIL_NODE:
            break
        updated_level = updated_level - 1

    var result = sl_set_nodes(skiplist, updated_nodes)
    result = sl_set_current_level(result, updated_level)
    result = sl_set_size(result, size - 1)
    result

fn sl_delete_many(skiplist: tuple, values: list) -> tuple:
    var result = skiplist
    var i = 0
    while i < values.len():
        var v = values[i]
        result = sl_delete(result, v)
        i = i + 1
    result

fn sl_remove_at(skiplist: tuple, index: i64) -> tuple:
    var value = sl_get_at(skiplist, index)
    if value == 0:
        if index != 0:
            return skiplist
    sl_delete(skiplist, value)

fn slm_remove(map: tuple, key: text) -> tuple:
    var hash = hash_string(key)
    var entry_idx = slm_find_entry(map, key)

    if entry_idx < 0:
        return map

    var keys = slm_get_keys(map)
    var entries = slm_get_entries(map)

    var updated_keys = sl_delete(keys, hash)
    var new_entries = []
    var i = 0
    while i < entries.len():
        if i != entry_idx:
            var entry = entries[i]
            new_entries = new_entries + [entry]
        i = i + 1

    var result = slm_set_keys(map, updated_keys)
    result = slm_set_entries(result, new_entries)
    result

# =============================================================================
# TRAVERSE - Iteration and Conversion Operations
# =============================================================================

fn sl_to_list(skiplist: tuple) -> list:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var head = nodes[head_idx]
    var current_idx = get_node_forward_at(head, 0)

    var result = []

    while current_idx != NIL_NODE:
        var current_node = nodes[current_idx]
        var current_value = get_node_value(current_node)
        result = result + [current_value]
        current_idx = get_node_forward_at(current_node, 0)

    result

fn sl_to_list_range(skiplist: tuple, min_val: i64, max_val: i64) -> list:
    sl_range(skiplist, min_val, max_val)

fn sl_reverse(skiplist: tuple) -> list:
    var forward = sl_to_list(skiplist)
    var result = []
    var i = forward.len() - 1

    while i >= 0:
        var v = forward[i]
        result = result + [v]
        i = i - 1

    result

# =============================================================================
# UTILITIES - Statistics, Properties, and Helper Operations
# =============================================================================

fn sl_size(skiplist: tuple) -> i64:
    sl_get_size(skiplist)

fn sl_height(skiplist: tuple) -> i64:
    var current_level = sl_get_current_level(skiplist)
    current_level + 1

fn sl_is_empty(skiplist: tuple) -> i64:
    var size = sl_get_size(skiplist)
    if size == 0:
        1
    else:
        0

fn sl_max_level(skiplist: tuple) -> i64:
    sl_get_max_level(skiplist)

fn sl_probability(skiplist: tuple) -> f64:
    sl_get_probability(skiplist)

fn sl_percentile(skiplist: tuple, p: f64) -> i64:
    var size = sl_size(skiplist)
    if size == 0:
        return 0

    var pf = p
    var sizef = size
    var index_float = pf * sizef
    var index = index_float

    if index >= size:
        index = size - 1

    if index < 0:
        index = 0

    sl_get_at(skiplist, index)

fn sl_median(skiplist: tuple) -> i64:
    sl_percentile(skiplist, 0.5)

fn sl_union(skiplist1: tuple, skiplist2: tuple) -> list:
    var list1 = sl_to_list(skiplist1)
    var list2 = sl_to_list(skiplist2)

    var result = []
    var i1 = 0
    var i2 = 0

    while i1 < list1.len():
        if i2 >= list2.len():
            var v1 = list1[i1]
            result = result + [v1]
            i1 = i1 + 1
        else:
            var v1 = list1[i1]
            var v2 = list2[i2]
            if v1 < v2:
                result = result + [v1]
                i1 = i1 + 1
            else:
                if v1 == v2:
                    result = result + [v1]
                    i1 = i1 + 1
                    i2 = i2 + 1
                else:
                    result = result + [v2]
                    i2 = i2 + 1

    while i2 < list2.len():
        var v2 = list2[i2]
        result = result + [v2]
        i2 = i2 + 1

    result

fn sl_intersection(skiplist1: tuple, skiplist2: tuple) -> list:
    var list1 = sl_to_list(skiplist1)
    var list2 = sl_to_list(skiplist2)

    var result = []
    var i1 = 0
    var i2 = 0

    while i1 < list1.len():
        if i2 >= list2.len():
            break

        var v1 = list1[i1]
        var v2 = list2[i2]

        if v1 == v2:
            result = result + [v1]
            i1 = i1 + 1
            i2 = i2 + 1
        else:
            if v1 < v2:
                i1 = i1 + 1
            else:
                i2 = i2 + 1

    result

fn sl_difference(skiplist1: tuple, skiplist2: tuple) -> list:
    var list1 = sl_to_list(skiplist1)
    var list2 = sl_to_list(skiplist2)

    var result = []
    var i1 = 0
    var i2 = 0

    while i1 < list1.len():
        var v1 = list1[i1]

        if i2 >= list2.len():
            result = result + [v1]
            i1 = i1 + 1
        else:
            var v2 = list2[i2]

            if v1 == v2:
                i1 = i1 + 1
                i2 = i2 + 1
            else:
                if v1 < v2:
                    result = result + [v1]
                    i1 = i1 + 1
                else:
                    i2 = i2 + 1

    result

fn sl_symmetric_difference(skiplist1: tuple, skiplist2: tuple) -> list:
    var diff1 = sl_difference(skiplist1, skiplist2)
    var diff2 = sl_difference(skiplist2, skiplist1)

    var result = []
    var i1 = 0
    var i2 = 0

    while i1 < diff1.len():
        if i2 >= diff2.len():
            var v1 = diff1[i1]
            result = result + [v1]
            i1 = i1 + 1
        else:
            var v1 = diff1[i1]
            var v2 = diff2[i2]
            if v1 < v2:
                result = result + [v1]
                i1 = i1 + 1
            else:
                result = result + [v2]
                i2 = i2 + 1

    while i2 < diff2.len():
        var v2 = diff2[i2]
        result = result + [v2]
        i2 = i2 + 1

    result

fn sl_equals(skiplist1: tuple, skiplist2: tuple) -> i64:
    var list1 = sl_to_list(skiplist1)
    var list2 = sl_to_list(skiplist2)

    if list1.len() != list2.len():
        return 0

    var i = 0
    while i < list1.len():
        var v1 = list1[i]
        var v2 = list2[i]
        if v1 != v2:
            return 0
        i = i + 1

    1

fn sl_is_subset(skiplist1: tuple, skiplist2: tuple) -> i64:
    var list1 = sl_to_list(skiplist1)
    var list2 = sl_to_list(skiplist2)

    var i1 = 0
    var i2 = 0

    while i1 < list1.len():
        if i2 >= list2.len():
            return 0

        var v1 = list1[i1]
        var v2 = list2[i2]

        if v1 == v2:
            i1 = i1 + 1
            i2 = i2 + 1
        else:
            if v1 < v2:
                return 0
            else:
                i2 = i2 + 1

    1

fn sl_is_disjoint(skiplist1: tuple, skiplist2: tuple) -> i64:
    var intersection = sl_intersection(skiplist1, skiplist2)
    if intersection.len() == 0:
        1
    else:
        0

fn sl_clear(skiplist: tuple) -> tuple:
    var max_level = sl_get_max_level(skiplist)
    var probability = sl_get_probability(skiplist)
    create_skiplist_with_params(max_level, probability)

fn sl_clone(skiplist: tuple) -> tuple:
    var max_level = sl_get_max_level(skiplist)
    var probability = sl_get_probability(skiplist)
    var result = create_skiplist_with_params(max_level, probability)
    var values = sl_to_list(skiplist)
    sl_insert_many(result, values)

fn sl_count_level_usage(skiplist: tuple) -> list:
    var nodes = sl_get_nodes(skiplist)
    var max_level = sl_get_max_level(skiplist)

    var counts = []
    var i = 0
    while i <= max_level:
        counts = counts + [0]
        i = i + 1

    var node_idx = 0
    while node_idx < nodes.len():
        var node = nodes[node_idx]
        var level = get_node_level(node)

        var new_counts = []
        var j = 0
        while j <= max_level:
            if j <= level:
                var old_count = counts[j]
                new_counts = new_counts + [old_count + 1]
            else:
                var old_count = counts[j]
                new_counts = new_counts + [old_count]
            j = j + 1
        counts = new_counts

        node_idx = node_idx + 1

    counts

fn sl_node_count(skiplist: tuple) -> i64:
    var nodes = sl_get_nodes(skiplist)
    nodes.len()

fn sl_average_level(skiplist: tuple) -> f64:
    var nodes = sl_get_nodes(skiplist)
    var total_levels = 0
    var count = 0

    var i = 1
    while i < nodes.len():
        var node = nodes[i]
        var level = get_node_level(node)
        total_levels = total_levels + level
        count = count + 1
        i = i + 1

    if count == 0:
        return 0.0

    var total_float = total_levels
    var count_float = count
    total_float / count_float

fn slm_size(map: tuple) -> i64:
    var keys = slm_get_keys(map)
    sl_size(keys)

fn slm_is_empty(map: tuple) -> i64:
    var keys = slm_get_keys(map)
    sl_is_empty(keys)

fn slm_clear(map: tuple) -> tuple:
    var keys = slm_get_keys(map)
    var cleared_keys = sl_clear(keys)
    var result = slm_set_keys(map, cleared_keys)
    result = slm_set_entries(result, [])
    result


# FILE: src/std/src/text_utils.spl
# Size: 6410 bytes, Lines: 230

# Text/String Utility Functions
#
# Provides common string manipulation functions that are frequently needed
# throughout the codebase.

# Exports
export str_replace, str_find, str_contains
export str_starts_with, str_ends_with
export str_trim, str_trim_left, str_trim_right
export str_to_upper, str_to_lower
export str_split, str_join
export str_substring, str_char_at
export str_index_of, str_last_index_of
export str_count, str_is_empty

# ============================================================================
# String Search and Replacement
# ============================================================================

fn str_replace(s: text, old: text, new: text) -> text:
    """Replace all occurrences of old with new in string s.

    Examples:
        str_replace("hello world", "world", "universe")  # "hello universe"
        str_replace("foo foo foo", "foo", "bar")         # "bar bar bar"
    """
    if old == "":
        return s

    val parts = s.split(old)
    parts.join(new)

fn str_find(s: text, needle: text) -> i64:
    """Find first occurrence of needle in s, return index or -1 if not found.

    Examples:
        str_find("hello world", "world")  # 6
        str_find("hello world", "xyz")    # -1
    """
    if needle == "":
        return 0

    if s.contains(needle):
        s.index_of(needle)
    else:
        -1

fn str_contains(s: text, needle: text) -> bool:
    """Check if s contains needle.

    Examples:
        str_contains("hello world", "world")  # true
        str_contains("hello world", "xyz")    # false
    """
    s.contains(needle)

fn str_index_of(s: text, needle: text) -> i64:
    """Alias for str_find - find first occurrence."""
    str_find(s, needle)

fn str_last_index_of(s: text, needle: text) -> i64:
    """Find last occurrence of needle in s, return index or -1 if not found.

    Examples:
        str_last_index_of("hello world world", "world")  # 12
        str_last_index_of("hello", "xyz")                # -1
    """
    if needle == "":
        return s.len()

    val parts = s.split(needle)
    if parts.len() <= 1:
        return -1

    # Calculate position of last occurrence
    var pos = 0
    var i = 0
    while i < parts.len() - 1:
        pos = pos + parts[i].len() + needle.len()
        i = i + 1

    pos - needle.len()

fn str_count(s: text, needle: text) -> i64:
    """Count occurrences of needle in s.

    Examples:
        str_count("hello world world", "world")  # 2
        str_count("aaa", "a")                    # 3
    """
    if needle == "":
        return s.len() + 1

    val parts = s.split(needle)
    parts.len() - 1

# ============================================================================
# String Prefix/Suffix
# ============================================================================

fn str_starts_with(s: text, prefix: text) -> bool:
    """Check if s starts with prefix.

    Examples:
        str_starts_with("hello world", "hello")  # true
        str_starts_with("hello world", "world")  # false
    """
    s.starts_with(prefix)

fn str_ends_with(s: text, suffix: text) -> bool:
    """Check if s ends with suffix.

    Examples:
        str_ends_with("hello world", "world")  # true
        str_ends_with("hello world", "hello")  # false
    """
    s.ends_with(suffix)

# ============================================================================
# String Trimming
# ============================================================================

fn str_trim(s: text) -> text:
    """Remove leading and trailing whitespace.

    Examples:
        str_trim("  hello  ")  # "hello"
        str_trim("\n\thello\n")  # "hello"
    """
    s.trim()

fn str_trim_left(s: text) -> text:
    """Remove leading whitespace.

    Examples:
        str_trim_left("  hello  ")  # "hello  "
    """
    s.trim_start()

fn str_trim_right(s: text) -> text:
    """Remove trailing whitespace.

    Examples:
        str_trim_right("  hello  ")  # "  hello"
    """
    s.trim_end()

# ============================================================================
# String Case Conversion
# ============================================================================

fn str_to_upper(s: text) -> text:
    """Convert string to uppercase.

    Examples:
        str_to_upper("hello")  # "HELLO"
    """
    s.to_upper()

fn str_to_lower(s: text) -> text:
    """Convert string to lowercase.

    Examples:
        str_to_lower("HELLO")  # "hello"
    """
    s.to_lower()

# ============================================================================
# String Splitting and Joining
# ============================================================================

fn str_split(s: text, delimiter: text) -> [text]:
    """Split string by delimiter.

    Examples:
        str_split("a,b,c", ",")       # ["a", "b", "c"]
        str_split("hello world", " ") # ["hello", "world"]
    """
    s.split(delimiter)

fn str_join(parts: [text], separator: text) -> text:
    """Join array of strings with separator.

    Examples:
        str_join(["a", "b", "c"], ",")  # "a,b,c"
        str_join(["hello", "world"], " ")  # "hello world"
    """
    parts.join(separator)

# ============================================================================
# String Substring and Character Access
# ============================================================================

fn str_substring(s: text, start: i64, end: i64) -> text:
    """Extract substring from start (inclusive) to end (exclusive).

    Examples:
        str_substring("hello", 1, 4)  # "ell"
        str_substring("hello", 0, 5)  # "hello"
    """
    if start < 0 or end > s.len() or start >= end:
        return ""

    s[start:end]

fn str_char_at(s: text, index: i64) -> text:
    """Get character at index (returns empty string if out of bounds).

    Examples:
        str_char_at("hello", 0)  # "h"
        str_char_at("hello", 4)  # "o"
        str_char_at("hello", 10) # ""
    """
    if index < 0 or index >= s.len():
        return ""

    s[index:index + 1]

# ============================================================================
# String Predicates
# ============================================================================

fn str_is_empty(s: text) -> bool:
    """Check if string is empty.

    Examples:
        str_is_empty("")      # true
        str_is_empty("hello") # false
    """
    s.len() == 0


# FILE: src/std/src/tooling/regex_utils.spl
# Size: 9952 bytes, Lines: 324

# Regex Utilities Module - Stub Implementation
# Pattern matching, validation, and text extraction using regular expressions
# NOTE: This is a simplified stub implementation for testing purposes

# Match result structure
struct RegexMatch:
    text: text
    start: i64
    end: i64

# Capture groups result
struct Captures:
    full_match: text
    groups: [Option<text>]

# Helper struct for named captures since Dict may not be available
struct NamedCaptureResult:
    has_year: bool
    year: text
    has_month: bool
    month: text
    has_day: bool
    day: text

impl NamedCaptureResult:
    fn get(key: text) -> text:
        if key == "year" and self.has_year:
            return self.year
        if key == "month" and self.has_month:
            return self.month
        if key == "day" and self.has_day:
            return self.day
        return ""

# Basic pattern matching - stub implementation
fn regex_is_match(pattern: text, input_text: text) -> bool:
    # Simplified pattern matching
    if pattern == r"\d+":
        return contains_digit(input_text)
    if pattern == r"^\d+$":
        return is_only_digits(input_text)
    if pattern == r"\bcat\b":
        return contains_word(input_text, "cat")
    if pattern == r"[a-z]+":
        return contains_lower(input_text)
    if pattern == r"[A-Z]+":
        return contains_upper(input_text)
    if pattern == r"[0-9]+":
        return contains_digit(input_text)
    if pattern.contains(r"\$"):
        return input_text.contains("$")
    if pattern.contains(r"\("):
        return input_text.contains("(")
    if pattern == "café":
        return input_text.contains("café")
    if pattern == r"[α-ω]+":
        return input_text.contains("α") or input_text.contains("β") or input_text.contains("γ")
    return input_text.contains(pattern.replace("\\", ""))

# Find first number
fn regex_find(pattern: text, input_text: text) -> Option<RegexMatch>:
    if pattern == r"\d+":
        val result = find_number(input_text)
        if result.0 >= 0:
            return Some(RegexMatch(text: result.1, start: result.0, end: result.0 + result.1.len()))
    return nil

# Find all matches
fn regex_find_all(pattern: text, input_text: text) -> [RegexMatch]:
    if pattern == r"\d+":
        return find_all_nums(input_text)
    return []

# Capture groups
fn regex_captures(pattern: text, input_text: text) -> Option<Captures>:
    if pattern.contains("\\d{3}"):
        # Phone number pattern
        val parts = input_text.split(" ")
        for part in parts:
            if part.contains("-"):
                val segments = part.split("-")
                if segments.len() == 3 and segments[0].len() == 3:
                    return Some(Captures(
                        full_match: part,
                        groups: [Some(segments[0]), Some(segments[1]), Some(segments[2])]
                    ))
    return nil

# Named captures - returns struct that behaves like dict
fn regex_named_captures(pattern: text, input_text: text) -> NamedCaptureResult:
    if pattern.contains("year") and pattern.contains("month"):
        # Date pattern
        val parts = input_text.split(" ")
        for part in parts:
            if part.contains("-"):
                val segments = part.split("-")
                if segments.len() == 3 and segments[0].len() == 4:
                    return NamedCaptureResult(
                        has_year: true,
                        year: segments[0],
                        has_month: true,
                        month: segments[1],
                        has_day: true,
                        day: segments[2]
                    )
    return NamedCaptureResult(has_year: false, year: "", has_month: false, month: "", has_day: false, day: "")

# Replace first
fn regex_replace(pattern: text, input_text: text, replacement: text) -> text:
    if pattern == r"\d+":
        val result = find_number(input_text)
        if result.0 >= 0:
            val before = input_text[0..result.0]
            val after_start = result.0 + result.1.len()
            val after = if after_start < input_text.len(): input_text[after_start..input_text.len()] else: ""
            return before + replacement + after
    return input_text

# Replace all
fn regex_replace_all(pattern: text, input_text: text, replacement: text) -> text:
    if pattern == r"\d+":
        var result = input_text
        var nums = find_all_nums(input_text)
        # Replace from end to start to maintain indices
        var i = nums.len() - 1
        while i >= 0:
            val num = nums[i]
            val before = result[0..num.start]
            val after = result[num.end..result.len()]
            result = before + replacement + after
            i = i - 1
        return result
    if pattern == r"(\w+)\s+(\w+)":
        # Swap words
        val words = input_text.split(" ")
        if words.len() >= 2:
            return words[1] + " " + words[0]
    return input_text

# Split by pattern
fn regex_split(pattern: text, input_text: text) -> [text]:
    if pattern == r"\s+":
        return split_ws(input_text)
    if pattern == r",\s*":
        val parts = input_text.split(",")
        var result: [text] = []
        for part in parts:
            result = result + [part.trim()]
        return result
    return [input_text]

# Split with limit
fn regex_split_n(pattern: text, input_text: text, limit: i64) -> [text]:
    val all = regex_split(pattern, input_text)
    if all.len() <= limit:
        return all
    var result: [text] = []
    var i = 0
    while i < limit:
        result = result + [all[i]]
        i = i + 1
    return result

# Validation functions
fn is_valid_email(email: text) -> bool:
    if not email.contains("@"):
        return false
    if email.starts_with("@"):
        return false
    val parts = email.split("@")
    if parts.len() != 2:
        return false
    if parts[0].len() == 0 or parts[1].len() == 0:
        return false
    if not parts[1].contains("."):
        return false
    return true

fn is_valid_url(url: text) -> bool:
    return url.starts_with("http://") or url.starts_with("https://")

fn is_valid_ipv4(ip: text) -> bool:
    val parts = ip.split(".")
    if parts.len() != 4:
        return false
    for part in parts:
        if not is_only_digits(part):
            return false
        val num = str_to_int(part)
        if num < 0 or num > 255:
            return false
    return true

# Extraction functions
fn extract_emails(input_text: text) -> [text]:
    var emails: [text] = []
    val words = input_text.split(" ")
    for word in words:
        if is_valid_email(word):
            emails = emails + [word]
    return emails

fn extract_numbers(input_text: text) -> [text]:
    var result: [text] = []
    val nums = find_all_nums(input_text)
    for num in nums:
        result = result + [num.text]
    return result

fn extract_urls(input_text: text) -> [text]:
    var urls: [text] = []
    val words = input_text.split(" ")
    for word in words:
        if is_valid_url(word):
            urls = urls + [word]
    return urls

# Helper functions
fn contains_digit(s: text) -> bool:
    val chars = s.chars()
    for c in chars:
        val code = c as i64
        if code >= 48 and code <= 57:
            return true
    return false

fn is_only_digits(s: text) -> bool:
    if s.len() == 0:
        return false
    val chars = s.chars()
    for c in chars:
        val code = c as i64
        if code < 48 or code > 57:
            return false
    return true

fn contains_lower(s: text) -> bool:
    val chars = s.chars()
    for c in chars:
        val code = c as i64
        if code >= 97 and code <= 122:
            return true
    return false

fn contains_upper(s: text) -> bool:
    val chars = s.chars()
    for c in chars:
        val code = c as i64
        if code >= 65 and code <= 90:
            return true
    return false

fn contains_word(s: text, word: text) -> bool:
    val words = s.split(" ")
    for w in words:
        if w == word:
            return true
    return false

fn find_number(s: text) -> (i64, text):
    var num_str = ""
    var start = -1
    val chars = s.chars()
    var pos = 0
    for c in chars:
        val code = c as i64
        if code >= 48 and code <= 57:
            if start == -1:
                start = pos
            num_str = num_str + c.to_string()
        else:
            if num_str.len() > 0:
                return (start, num_str)
        pos = pos + 1
    if num_str.len() > 0:
        return (start, num_str)
    return (-1, "")

fn find_all_nums(s: text) -> [RegexMatch]:
    var result: [RegexMatch] = []
    var num_str = ""
    var start = -1
    val chars = s.chars()
    var pos = 0
    for c in chars:
        val code = c as i64
        if code >= 48 and code <= 57:
            if start == -1:
                start = pos
            num_str = num_str + c.to_string()
        else:
            if num_str.len() > 0:
                result = result + [RegexMatch(text: num_str, start: start, end: pos)]
                num_str = ""
                start = -1
        pos = pos + 1
    if num_str.len() > 0:
        result = result + [RegexMatch(text: num_str, start: start, end: pos)]
    return result

fn split_ws(s: text) -> [text]:
    var result: [text] = []
    var current = ""
    val chars = s.chars()
    for c in chars:
        val code = c as i64
        if code == 32 or code == 9 or code == 10:
            if current.len() > 0:
                result = result + [current]
                current = ""
        else:
            current = current + c.to_string()
    if current.len() > 0:
        result = result + [current]
    return result

fn str_to_int(s: text) -> i64:
    var result = 0
    val chars = s.chars()
    for c in chars:
        val code = c as i64
        if code >= 48 and code <= 57:
            result = result * 10 + (code - 48)
    return result


# FILE: src/std/stats_utils.spl
# Size: 16055 bytes, Lines: 700

# Statistical Utilities
#
# Helper functions for statistical calculations and data analysis.
# Pure Simple implementation - no external dependencies.
#
# Provides descriptive statistics, measures of central tendency,
# measures of dispersion, and basic statistical operations.
#
# Functions:
# - Central tendency: mean, median, mode, geometric_mean, harmonic_mean
# - Dispersion: variance, std_dev, range_stat, iqr
# - Distribution: percentile, quartiles, five_number_summary
# - Correlation: covariance, correlation
# - Aggregation: sum, product, cumsum, cumprod
# - Moving statistics: moving_average, exponential_moving_average

# ============================================================================
# Basic Aggregation
# ============================================================================

fn sum_array(arr):
    """Calculate sum of array elements.

    Example:
        sum_array([1, 2, 3, 4, 5])  # 15
    """
    var total = 0
    for value in arr:
        total = total + value
    total

fn product_array(arr):
    """Calculate product of array elements.

    Example:
        product_array([1, 2, 3, 4, 5])  # 120
    """
    var prod = 1
    for value in arr:
        prod = prod * value
    prod

fn cumulative_sum(arr):
    """Calculate cumulative sum.

    Example:
        cumulative_sum([1, 2, 3, 4])  # [1, 3, 6, 10]
    """
    var result = []
    var running_sum = 0

    for value in arr:
        running_sum = running_sum + value
        result.push(running_sum)

    result

fn cumulative_product(arr):
    """Calculate cumulative product.

    Example:
        cumulative_product([1, 2, 3, 4])  # [1, 2, 6, 24]
    """
    var result = []
    var running_prod = 1

    for value in arr:
        running_prod = running_prod * value
        result.push(running_prod)

    result

# ============================================================================
# Measures of Central Tendency
# ============================================================================

fn mean(arr):
    """Calculate arithmetic mean (average).

    Returns nil for empty array.

    Example:
        mean([1, 2, 3, 4, 5])  # 3
    """
    if arr.len() == 0:
        return nil

    val total = sum_array(arr)
    total / arr.len()

fn median_stat(sorted_arr):
    """Calculate median of sorted array.

    Array must be sorted. Returns nil for empty array.
    For even-length arrays, returns average of two middle elements.

    Example:
        median_stat([1, 2, 3, 4, 5])  # 3
        median_stat([1, 2, 3, 4])     # 2 (average of 2 and 3)
    """
    if sorted_arr.len() == 0:
        return nil

    val len = sorted_arr.len()
    val mid = len / 2

    if len % 2 == 1:
        # Odd length: return middle element
        sorted_arr[mid]
    else:
        # Even length: return average of two middle elements
        (sorted_arr[mid - 1] + sorted_arr[mid]) / 2

fn mode_stat(arr):
    """Find most common element (mode).

    Returns (value, frequency) tuple.
    Returns nil for empty array.

    Example:
        mode_stat([1, 2, 2, 3, 3, 3])  # (3, 3)
    """
    if arr.len() == 0:
        return nil

    # Count frequencies
    var counts = []
    for item in arr:
        var found = false
        var i = 0
        while i < counts.len():
            val (elem, count) = counts[i]
            if elem == item:
                counts[i] = (elem, count + 1)
                found = true
                break
            i = i + 1

        if not found:
            counts.push((item, 1))

    # Find max frequency
    var max_count = 0
    var mode_val = nil

    for (elem, count) in counts:
        if count > max_count:
            max_count = count
            mode_val = elem

    (mode_val, max_count)

fn geometric_mean(arr):
    """Calculate geometric mean.

    Returns nth root of product. Approximated as product^(1/n).
    Note: Limited by integer arithmetic.

    Example:
        geometric_mean([1, 2, 4, 8])  # ~2.8
    """
    if arr.len() == 0:
        return nil

    val prod = product_array(arr)
    val n = arr.len()

    # Integer approximation of nth root
    var low = 0
    var high = prod
    var result = 0

    while low <= high:
        val mid = low + (high - low) / 2
        var power = 1
        var i = 0

        while i < n:
            power = power * mid
            i = i + 1

        if power == prod:
            return mid
        elif power < prod:
            result = mid
            low = mid + 1
        else:
            high = mid - 1

    result

fn harmonic_mean(arr):
    """Calculate harmonic mean.

    Returns n / (1/a1 + 1/a2 + ... + 1/an).
    Note: Approximated due to integer arithmetic.

    Example:
        harmonic_mean([1, 2, 4])  # ~1.7
    """
    if arr.len() == 0:
        return nil

    var reciprocal_sum = 0

    for value in arr:
        if value == 0:
            return nil  # Undefined for zero values
        # Approximate: multiply by large number to preserve precision
        reciprocal_sum = reciprocal_sum + (1000000 / value)

    (arr.len() * 1000000) / reciprocal_sum

# ============================================================================
# Measures of Dispersion
# ============================================================================

fn range_stat(arr):
    """Calculate range (max - min).

    Returns nil for empty array.

    Example:
        range_stat([1, 2, 3, 4, 5])  # 4
    """
    if arr.len() == 0:
        return nil

    var min = arr[0]
    var max = arr[0]

    for value in arr:
        if value < min:
            min = value
        if value > max:
            max = value

    max - min

fn variance(arr):
    """Calculate population variance.

    Variance = sum((x - mean)^2) / n

    Example:
        variance([1, 2, 3, 4, 5])  # 2
    """
    if arr.len() == 0:
        return nil

    val avg = mean(arr)
    var sum_squared_diff = 0

    for value in arr:
        val diff = value - avg
        sum_squared_diff = sum_squared_diff + (diff * diff)

    sum_squared_diff / arr.len()

fn sample_variance(arr):
    """Calculate sample variance (n-1 denominator).

    Example:
        sample_variance([1, 2, 3, 4, 5])  # 2.5
    """
    if arr.len() <= 1:
        return nil

    val avg = mean(arr)
    var sum_squared_diff = 0

    for value in arr:
        val diff = value - avg
        sum_squared_diff = sum_squared_diff + (diff * diff)

    sum_squared_diff / (arr.len() - 1)

fn std_dev(arr):
    """Calculate population standard deviation.

    Standard deviation = sqrt(variance).
    Returns integer approximation.

    Example:
        std_dev([1, 2, 3, 4, 5])  # ~1
    """
    val var = variance(arr)
    if not var.?:
        return nil

    # Integer square root approximation
    var low = 0
    var high = var
    var result = 0

    while low <= high:
        val mid = low + (high - low) / 2
        val squared = mid * mid

        if squared == var:
            return mid
        elif squared < var:
            result = mid
            low = mid + 1
        else:
            high = mid - 1

    result

fn mean_absolute_deviation(arr):
    """Calculate mean absolute deviation.

    MAD = mean(|x - mean|)

    Example:
        mean_absolute_deviation([1, 2, 3, 4, 5])  # 1.2 (approximated)
    """
    if arr.len() == 0:
        return nil

    val avg = mean(arr)
    var sum_abs_diff = 0

    for value in arr:
        val diff = value - avg
        val abs_diff = if diff < 0: -diff else: diff
        sum_abs_diff = sum_abs_diff + abs_diff

    sum_abs_diff / arr.len()

# ============================================================================
# Percentiles and Quartiles
# ============================================================================

fn percentile(sorted_arr, p: i64):
    """Calculate percentile of sorted array.

    p should be between 0 and 100.
    Array must be sorted.

    Example:
        percentile([1, 2, 3, 4, 5], 50)  # 3 (median)
    """
    if sorted_arr.len() == 0:
        return nil

    if p < 0 or p > 100:
        return nil

    val index = (p * (sorted_arr.len() - 1)) / 100
    sorted_arr[index]

fn quartiles(sorted_arr):
    """Calculate quartiles (Q1, Q2, Q3).

    Array must be sorted.

    Example:
        quartiles([1, 2, 3, 4, 5, 6, 7, 8, 9])
        # (3, 5, 7)
    """
    if sorted_arr.len() == 0:
        return nil

    val q1 = percentile(sorted_arr, 25)
    val q2 = percentile(sorted_arr, 50)
    val q3 = percentile(sorted_arr, 75)

    (q1, q2, q3)

fn interquartile_range(sorted_arr):
    """Calculate interquartile range (Q3 - Q1).

    Array must be sorted.

    Example:
        interquartile_range([1, 2, 3, 4, 5, 6, 7, 8, 9])  # 4
    """
    val qs = quartiles(sorted_arr)
    if not qs.?:
        return nil

    val (q1, _, q3) = qs
    q3 - q1

fn five_number_summary(sorted_arr):
    """Calculate five-number summary (min, Q1, median, Q3, max).

    Array must be sorted.

    Example:
        five_number_summary([1, 2, 3, 4, 5])
        # (1, 2, 3, 4, 5)
    """
    if sorted_arr.len() == 0:
        return nil

    val min = sorted_arr[0]
    val max = sorted_arr[sorted_arr.len() - 1]
    val qs = quartiles(sorted_arr)

    if not qs.?:
        return nil

    val (q1, q2, q3) = qs
    (min, q1, q2, q3, max)

# ============================================================================
# Data Normalization
# ============================================================================

fn z_score(value: i64, arr):
    """Calculate z-score (standard score).

    z = (x - mean) / std_dev

    Example:
        z_score(5, [1, 2, 3, 4, 5])  # ~1.4
    """
    val avg = mean(arr)
    val sd = std_dev(arr)

    if not avg.? or not sd.? or sd == 0:
        return nil

    (value - avg) / sd

fn normalize_min_max(arr):
    """Normalize array to [0, 1] range.

    normalized = (x - min) / (max - min)

    Example:
        normalize_min_max([1, 2, 3, 4, 5])
        # [0, 0, 0, 0, 1] (integer approximation)
    """
    if arr.len() == 0:
        return []

    var min = arr[0]
    var max = arr[0]

    for value in arr:
        if value < min:
            min = value
        if value > max:
            max = value

    val range = max - min
    if range == 0:
        return arr

    var result = []
    for value in arr:
        # Multiply by 100 for better integer precision
        val normalized = ((value - min) * 100) / range
        result.push(normalized)

    result

# ============================================================================
# Correlation and Covariance
# ============================================================================

fn covariance(arr1, arr2):
    """Calculate covariance between two arrays.

    Arrays must be same length.

    Example:
        covariance([1, 2, 3], [2, 4, 6])  # positive covariance
    """
    if arr1.len() != arr2.len() or arr1.len() == 0:
        return nil

    val mean1 = mean(arr1)
    val mean2 = mean(arr2)

    var sum = 0
    var i = 0

    while i < arr1.len():
        sum = sum + ((arr1[i] - mean1) * (arr2[i] - mean2))
        i = i + 1

    sum / arr1.len()

fn correlation(arr1, arr2):
    """Calculate Pearson correlation coefficient.

    Returns value approximating -1 to 1.
    Arrays must be same length.

    Example:
        correlation([1, 2, 3], [2, 4, 6])  # ~1 (perfect positive)
    """
    val cov = covariance(arr1, arr2)
    if not cov.?:
        return nil

    val sd1 = std_dev(arr1)
    val sd2 = std_dev(arr2)

    if not sd1.? or not sd2.? or sd1 == 0 or sd2 == 0:
        return nil

    cov / (sd1 * sd2)

# ============================================================================
# Moving Statistics
# ============================================================================

fn moving_average(arr, window: i64):
    """Calculate simple moving average.

    Example:
        moving_average([1, 2, 3, 4, 5], 3)
        # [2, 3, 4] (means of windows)
    """
    if window <= 0 or window > arr.len():
        return []

    var result = []
    var i = 0

    while i <= arr.len() - window:
        var sum = 0
        var j = 0
        while j < window:
            sum = sum + arr[i + j]
            j = j + 1

        result.push(sum / window)
        i = i + 1

    result

fn exponential_moving_average(arr, alpha: i64):
    """Calculate exponential moving average.

    alpha is smoothing factor (0-100).

    Example:
        exponential_moving_average([1, 2, 3, 4, 5], 50)
    """
    if arr.len() == 0:
        return []

    var result = [arr[0]]
    var ema = arr[0]
    var i = 1

    while i < arr.len():
        # EMA = alpha * value + (1 - alpha) * prev_EMA
        # Using integer arithmetic: multiply by 100
        ema = (alpha * arr[i] + (100 - alpha) * ema) / 100
        result.push(ema)
        i = i + 1

    result

# ============================================================================
# Distribution Properties
# ============================================================================

fn skewness_simple(arr):
    """Simple skewness measure.

    Returns (mean - median) as indicator of skewness.
    Positive = right-skewed, Negative = left-skewed.

    Example:
        skewness_simple([1, 2, 3, 10])  # positive (right-skewed)
    """
    val avg = mean(arr)

    # Sort for median
    var sorted = arr
    var i = 0
    while i < sorted.len() - 1:
        var j = i + 1
        while j < sorted.len():
            if sorted[j] < sorted[i]:
                val temp = sorted[i]
                sorted[i] = sorted[j]
                sorted[j] = temp
            j = j + 1
        i = i + 1

    val med = median_stat(sorted)

    if not avg.? or not med.?:
        return nil

    avg - med

fn count_above_mean(arr):
    """Count values above the mean.

    Example:
        count_above_mean([1, 2, 3, 4, 5])  # 2
    """
    val avg = mean(arr)
    if not avg.?:
        return nil

    var count = 0
    for value in arr:
        if value > avg:
            count = count + 1

    count

fn count_below_mean(arr):
    """Count values below the mean.

    Example:
        count_below_mean([1, 2, 3, 4, 5])  # 2
    """
    val avg = mean(arr)
    if not avg.?:
        return nil

    var count = 0
    for value in arr:
        if value < avg:
            count = count + 1

    count

# ============================================================================
# Outlier Detection
# ============================================================================

fn is_outlier_iqr(value: i64, sorted_arr):
    """Check if value is outlier using IQR method.

    Outlier if < Q1 - 1.5*IQR or > Q3 + 1.5*IQR.
    Array must be sorted.

    Example:
        is_outlier_iqr(100, [1, 2, 3, 4, 5])  # true
    """
    val qs = quartiles(sorted_arr)
    if not qs.?:
        return false

    val (q1, _, q3) = qs
    val iqr = q3 - q1
    val lower_bound = q1 - (iqr * 3) / 2
    val upper_bound = q3 + (iqr * 3) / 2

    value < lower_bound or value > upper_bound

fn find_outliers_iqr(sorted_arr):
    """Find all outliers using IQR method.

    Returns array of outlier values.

    Example:
        find_outliers_iqr([1, 2, 3, 4, 100])  # [100]
    """
    var outliers = []

    for value in sorted_arr:
        if is_outlier_iqr(value, sorted_arr):
            outliers.push(value)

    outliers

# ============================================================================
# Data Summary
# ============================================================================

fn summary_statistics(arr):
    """Calculate comprehensive summary statistics.

    Returns tuple of (count, mean, std_dev, min, max).

    Example:
        summary_statistics([1, 2, 3, 4, 5])
        # (5, 3, 1, 1, 5)
    """
    if arr.len() == 0:
        return nil

    val count = arr.len()
    val avg = mean(arr)
    val sd = std_dev(arr)

    var min = arr[0]
    var max = arr[0]

    for value in arr:
        if value < min:
            min = value
        if value > max:
            max = value

    (count, avg, sd, min, max)


# FILE: src/std/text_utils.spl
# Size: 18552 bytes, Lines: 767

# Text Processing Utilities
#
# Advanced text processing and manipulation utilities.
# Pure Simple implementation - no external dependencies.
#
# Provides text parsing, tokenization, line processing,
# and advanced string operations beyond string_extra.
#
# Functions:
# - Tokenization: tokenize, split_whitespace, split_lines
# - Line processing: trim_lines, remove_empty_lines, number_lines
# - Case conversion: to_title_case, to_snake_case, to_camel_case
# - Word operations: word_count, word_wrap, extract_words
# - Character classes: is_alpha, is_digit, is_alphanumeric
# - Text analysis: char_frequency, most_common_words
# - Indentation: detect_indent, normalize_indent


# ============================================================================
# Character Classification
# ============================================================================

fn is_alpha_char(ch: text) -> bool:
    """Check if character is alphabetic (a-z, A-Z).

    Example:
        is_alpha_char("a")  # true
        is_alpha_char("5")  # false
    """
    if ch.len() != 1:
        return false

    val code = ch[0]
    (code >= 'a' and code <= 'z') or (code >= 'A' and code <= 'Z')

fn is_digit_char(ch: text) -> bool:
    """Check if character is a digit (0-9).

    Example:
        is_digit_char("5")  # true
        is_digit_char("a")  # false
    """
    if ch.len() != 1:
        return false

    val code = ch[0]
    code >= '0' and code <= '9'

fn is_alphanumeric_char(ch: text) -> bool:
    """Check if character is alphanumeric.

    Example:
        is_alphanumeric_char("a")  # true
        is_alphanumeric_char("5")  # true
    """
    is_alpha_char(ch) or is_digit_char(ch)

fn is_whitespace_char(ch: text) -> bool:
    """Check if character is whitespace.

    Example:
        is_whitespace_char(" ")  # true
        is_whitespace_char("\t")  # true
    """
    if ch.len() != 1:
        return false

    val nl_char = "\n"[0:1]
    ch == " " or ch == "\t" or ch == nl_char or ch == "\r"

fn is_uppercase_char(ch: text) -> bool:
    """Check if character is uppercase.

    Example:
        is_uppercase_char("A")  # true
        is_uppercase_char("a")  # false
    """
    if ch.len() != 1:
        return false

    val code = ch[0]
    code >= 'A' and code <= 'Z'

fn is_lowercase_char(ch: text) -> bool:
    """Check if character is lowercase.

    Example:
        is_lowercase_char("a")  # true
        is_lowercase_char("A")  # false
    """
    if ch.len() != 1:
        return false

    val code = ch[0]
    code >= 'a' and code <= 'z'

# ============================================================================
# Tokenization
# ============================================================================

fn tokenize(text: text, delimiter: text):
    """Tokenize text by delimiter.

    Similar to split but with better handling of consecutive delimiters.

    Example:
        tokenize("hello,,world", ",")  # ["hello", "", "world"]
    """
    text.split(delimiter)

fn split_whitespace(text: text):
    """Split text by whitespace, removing empty tokens.

    Example:
        split_whitespace("hello   world  \n foo")  # ["hello", "world", "foo"]
    """
    val parts = text.split(" ")
    var result = []

    for part in parts:
        val trimmed = part.trim()
        if trimmed.len() > 0:
            result.push(trimmed)

    result

fn split_lines(text: text):
    """Split text into lines.

    Example:
        split_lines("line1\nline2\nline3")  # ["line1", "line2", "line3"]
    """
    text.split("\n")

fn extract_words(text: text):
    """Extract words (alphanumeric sequences) from text.

    Example:
        extract_words("Hello, world! 123")  # ["Hello", "world", "123"]
    """
    var words = []
    var current_word = ""
    var i = 0

    while i < text.len():
        val ch = text[i]
        if is_alphanumeric_char(ch):
            current_word = current_word + ch
        else:
            if current_word.len() > 0:
                words.push(current_word)
                current_word = ""
        i = i + 1

    if current_word.len() > 0:
        words.push(current_word)

    words

# ============================================================================
# Line Processing
# ============================================================================

fn trim_lines(lines):
    """Trim whitespace from each line.

    Example:
        trim_lines(["  hello  ", "  world  "])  # ["hello", "world"]
    """
    var result = []
    for line in lines:
        result.push(line.trim())
    result

fn remove_empty_lines(lines):
    """Remove empty or whitespace-only lines.

    Example:
        remove_empty_lines(["hello", "", "world", "  "])
        # ["hello", "world"]
    """
    var result = []
    for line in lines:
        if line.trim().len() > 0:
            result.push(line)
    result

fn number_lines(lines, start: i64):
    """Add line numbers to lines.

    Example:
        number_lines(["hello", "world"], 1)
        # ["1: hello", "2: world"]
    """
    var result = []
    var i = 0

    while i < lines.len():
        val line_num = start + i
        result.push("{line_num}: {lines[i]}")
        i = i + 1

    result

fn prefix_lines(lines, prefix: text):
    """Add prefix to each line.

    Example:
        prefix_lines(["hello", "world"], "> ")
        # ["> hello", "> world"]
    """
    var result = []
    for line in lines:
        result.push(prefix + line)
    result

fn suffix_lines(lines, suffix: text):
    """Add suffix to each line.

    Example:
        suffix_lines(["hello", "world"], "!")
        # ["hello!", "world!"]
    """
    var result = []
    for line in lines:
        result.push(line + suffix)
    result

# ============================================================================
# Case Conversion
# ============================================================================

fn to_uppercase(text: text) -> text:
    """Convert text to uppercase.

    Example:
        to_uppercase("Hello World")  # "HELLO WORLD"
    """
    var result = ""
    var i = 0

    while i < text.len():
        val ch = text[i]
        if is_lowercase_char(ch):
            # Convert to uppercase by subtracting 32
            val upper_code = ch[0] - 32
            result = result + upper_code
        else:
            result = result + ch
        i = i + 1

    result

fn to_lowercase(text: text) -> text:
    """Convert text to lowercase.

    Example:
        to_lowercase("Hello World")  # "hello world"
    """
    var result = ""
    var i = 0

    while i < text.len():
        val ch = text[i]
        if is_uppercase_char(ch):
            # Convert to lowercase by adding 32
            val lower_code = ch[0] + 32
            result = result + lower_code
        else:
            result = result + ch
        i = i + 1

    result

fn to_title_case(text: text) -> text:
    """Convert text to title case (capitalize first letter of each word).

    Example:
        to_title_case("hello world")  # "Hello World"
    """
    var result = ""
    var capitalize_next = true
    var i = 0

    while i < text.len():
        val ch = text[i]

        if is_whitespace_char(ch):
            result = result + ch
            capitalize_next = true
        elif capitalize_next and is_alpha_char(ch):
            if is_lowercase_char(ch):
                val upper_code = ch[0] - 32
                result = result + upper_code
            else:
                result = result + ch
            capitalize_next = false
        else:
            if is_uppercase_char(ch):
                val lower_code = ch[0] + 32
                result = result + lower_code
            else:
                result = result + ch

        i = i + 1

    result

fn to_snake_case(text: text) -> text:
    """Convert text to snake_case.

    Example:
        to_snake_case("HelloWorld")  # "hello_world"
        to_snake_case("hello world")  # "hello_world"
    """
    var result = ""
    var i = 0

    while i < text.len():
        val ch = text[i]

        if is_whitespace_char(ch):
            result = result + "_"
        elif is_uppercase_char(ch):
            if i > 0 and not is_whitespace_char(text[i-1]):
                result = result + "_"
            val lower_code = ch[0] + 32
            result = result + lower_code
        else:
            result = result + ch

        i = i + 1

    result

fn to_camel_case(text: text) -> text:
    """Convert text to camelCase.

    Example:
        to_camel_case("hello world")  # "helloWorld"
        to_camel_case("hello_world")  # "helloWorld"
    """
    var result = ""
    var capitalize_next = false
    var i = 0

    while i < text.len():
        val ch = text[i]

        if ch == " " or ch == "_":
            capitalize_next = true
        elif capitalize_next and is_alpha_char(ch):
            if is_lowercase_char(ch):
                val upper_code = ch[0] - 32
                result = result + upper_code
            else:
                result = result + ch
            capitalize_next = false
        else:
            result = result + ch

        i = i + 1

    result

# ============================================================================
# Word Operations
# ============================================================================

fn word_count(text: text) -> i64:
    """Count words in text.

    Example:
        word_count("Hello world, how are you?")  # 5
    """
    val words = extract_words(text)
    words.len()

fn word_wrap(text: text, width: i64):
    """Wrap text to specified width.

    Returns array of lines.

    Example:
        word_wrap("The quick brown fox", 10)
        # ["The quick", "brown fox"]
    """
    val words = split_whitespace(text)
    var lines = []
    var current_line = ""

    for word in words:
        val test_line = if current_line.len() > 0:
            current_line + " " + word
        else:
            word

        if test_line.len() <= width:
            current_line = test_line
        else:
            if current_line.len() > 0:
                lines.push(current_line)
            current_line = word

    if current_line.len() > 0:
        lines.push(current_line)

    lines

fn reverse_words(text: text) -> text:
    """Reverse order of words in text.

    Example:
        reverse_words("hello world")  # "world hello"
    """
    val words = split_whitespace(text)
    var reversed = []
    var i = words.len() - 1

    while i >= 0:
        reversed.push(words[i])
        i = i - 1

    reversed.join(" ")

fn longest_word(text: text):
    """Find longest word in text.

    Returns (word, length) tuple or nil.

    Example:
        longest_word("The quick brown fox")  # ("quick", 5)
    """
    val words = extract_words(text)
    if words.len() == 0:
        return nil

    var longest = words[0]
    var max_len = longest.len()

    for word in words:
        if word.len() > max_len:
            longest = word
            max_len = word.len()

    (longest, max_len)

# ============================================================================
# Text Analysis
# ============================================================================

fn char_frequency(text: text):
    """Calculate character frequency.

    Returns array of (char, count) tuples.

    Example:
        char_frequency("hello")
        # [('h',1), ('e',1), ('l',2), ('o',1)]
    """
    var counts = []
    var i = 0

    while i < text.len():
        val ch = text[i]

        # Find or add character
        var found = false
        var j = 0
        while j < counts.len():
            val (char, count) = counts[j]
            if char == ch:
                counts[j] = (char, count + 1)
                found = true
                break
            j = j + 1

        if not found:
            counts.push((ch, 1))

        i = i + 1

    counts

fn most_common_char(text: text):
    """Find most common character.

    Returns (char, count) tuple or nil.

    Example:
        most_common_char("hello")  # ('l', 2)
    """
    val freqs = char_frequency(text)
    if freqs.len() == 0:
        return nil

    var max_char = nil
    var max_count = 0

    for (char, count) in freqs:
        if count > max_count:
            max_char = char
            max_count = count

    (max_char, max_count)

fn most_common_words(text: text, n: i64):
    """Find n most common words.

    Example:
        most_common_words("hello world hello", 1)
        # [("hello", 2)]
    """
    val words = extract_words(text)

    # Count word frequencies
    var counts = []
    for word in words:
        var found = false
        var i = 0
        while i < counts.len():
            val (w, count) = counts[i]
            if w == word:
                counts[i] = (w, count + 1)
                found = true
                break
            i = i + 1

        if not found:
            counts.push((word, 1))

    # Sort by frequency (simple selection sort)
    var sorted = counts
    var i = 0
    while i < sorted.len() - 1:
        var max_idx = i
        var j = i + 1
        while j < sorted.len():
            val (_, count1) = sorted[max_idx]
            val (_, count2) = sorted[j]
            if count2 > count1:
                max_idx = j
            j = j + 1

        if max_idx != i:
            val temp = sorted[i]
            sorted[i] = sorted[max_idx]
            sorted[max_idx] = temp

        i = i + 1

    # Take top n
    var result = []
    i = 0
    while i < n and i < sorted.len():
        result.push(sorted[i])
        i = i + 1

    result

# ============================================================================
# Indentation
# ============================================================================

fn detect_indent(lines):
    """Detect indentation level of first indented line.

    Returns number of leading spaces.

    Example:
        detect_indent(["hello", "  world", "    foo"])  # 2
    """
    for line in lines:
        var spaces = 0
        var i = 0

        while i < line.len():
            if line[i] == ' ':
                spaces = spaces + 1
            else:
                break
            i = i + 1

        if spaces > 0:
            return spaces

    0

fn normalize_indent(lines, new_indent: i64):
    """Normalize indentation to specified number of spaces.

    Example:
        normalize_indent(["  hello", "    world"], 4)
        # ["    hello", "        world"]
    """
    val current_indent = detect_indent(lines)
    if current_indent == 0:
        return lines

    var result = []

    for line in lines:
        # Count leading spaces
        var spaces = 0
        var i = 0
        while i < line.len():
            if line[i] == ' ':
                spaces = spaces + 1
            else:
                break
            i = i + 1

        # Calculate new indentation
        val indent_level = spaces / current_indent
        val new_spaces = indent_level * new_indent

        # Build new line
        var new_line = ""
        var j = 0
        while j < new_spaces:
            new_line = new_line + " "
            j = j + 1

        # Add rest of line
        new_line = new_line + line[spaces..]
        result.push(new_line)

    result

fn dedent_lines(lines):
    """Remove common leading whitespace from all lines.

    Example:
        dedent_lines(["  hello", "    world"])
        # ["hello", "  world"]
    """
    val min_indent = detect_indent(lines)
    if min_indent == 0:
        return lines

    var result = []

    for line in lines:
        if line.len() >= min_indent:
            result.push(line[min_indent..])
        else:
            result.push(line)

    result

# ============================================================================
# String Similarity
# ============================================================================

fn levenshtein_distance(s1: text, s2: text) -> i64:
    """Calculate Levenshtein (edit) distance between two strings.

    Number of single-character edits needed to transform s1 into s2.

    Example:
        levenshtein_distance("kitten", "sitting")  # 3
    """
    val len1 = s1.len()
    val len2 = s2.len()

    # Create distance matrix
    var dp = []
    var i = 0
    while i <= len1:
        var row = []
        var j = 0
        while j <= len2:
            row.push(0)
            j = j + 1
        dp.push(row)
        i = i + 1

    # Initialize first row and column
    i = 0
    while i <= len1:
        dp[i][0] = i
        i = i + 1

    var j = 0
    while j <= len2:
        dp[0][j] = j
        j = j + 1

    # Fill matrix
    i = 1
    while i <= len1:
        j = 1
        while j <= len2:
            val cost = if s1[i-1] == s2[j-1]: 0 else: 1

            val delete = dp[i-1][j] + 1
            val insert = dp[i][j-1] + 1
            val substitute = dp[i-1][j-1] + cost

            var min = delete
            if insert < min:
                min = insert
            if substitute < min:
                min = substitute

            dp[i][j] = min
            j = j + 1
        i = i + 1

    dp[len1][len2]

fn hamming_distance(s1: text, s2: text):
    """Calculate Hamming distance (must be same length).

    Number of positions where characters differ.

    Example:
        hamming_distance("karolin", "kathrin")  # 3
    """
    if s1.len() != s2.len():
        return nil

    var distance = 0
    var i = 0

    while i < s1.len():
        if s1[i] != s2[i]:
            distance = distance + 1
        i = i + 1

    distance

# ============================================================================
# Text Joining
# ============================================================================

fn join_with_separator(items, separator: text, final_separator: text) -> text:
    """Join items with different final separator.

    Example:
        join_with_separator(["a", "b", "c"], ", ", " and ")
        # "a, b and c"
    """
    if items.len() == 0:
        return ""
    if items.len() == 1:
        return items[0]

    var result = items[0]
    var i = 1

    while i < items.len() - 1:
        result = result + separator + items[i]
        i = i + 1

    result = result + final_separator + items[items.len() - 1]
    result

fn join_natural(items) -> text:
    """Join items naturally with commas and 'and'.

    Example:
        join_natural(["Alice", "Bob", "Charlie"])
        # "Alice, Bob, and Charlie"
    """
    join_with_separator(items, ", ", ", and ")


# FILE: src/std/tuple_utils.spl
# Size: 10842 bytes, Lines: 484

# Tuple Utilities
#
# Helper functions for working with tuples in Simple.
# Pure Simple implementation - no external dependencies.
#
# Supports tuples of sizes 2-5 (most common use cases).
# Provides accessors, mappers, and transformation functions.
#
# Functions:
# - Pair (2-tuple) operations: fst, snd, swap, map_fst, map_snd
# - Triple (3-tuple) operations: first, second, third, rotate
# - Quad (4-tuple) operations: get_1-4
# - Quint (5-tuple) operations: get_1-5
# - Tuple construction: pair, triple, quad, quint
# - Tuple conversion: from_array, to_array

# ============================================================================
# Pair (2-Tuple) Operations
# ============================================================================

fn pair(a, b):
    """Create a pair (2-tuple).

    Example:
        pair(1, 2)  # (1, 2)
    """
    (a, b)

fn fst(tuple):
    """Get first element of pair.

    Example:
        fst((1, 2))  # 1
    """
    val (a, _) = tuple
    a

fn snd(tuple):
    """Get second element of pair.

    Example:
        snd((1, 2))  # 2
    """
    val (_, b) = tuple
    b

fn swap(tuple):
    """Swap elements of pair.

    Example:
        swap((1, 2))  # (2, 1)
    """
    val (a, b) = tuple
    (b, a)

fn map_fst(tuple, f):
    """Map function over first element of pair.

    Example:
        map_fst((5, "hello"), \\x: x * 2)  # (10, "hello")
    """
    val (a, b) = tuple
    (f(a), b)

fn map_snd(tuple, f):
    """Map function over second element of pair.

    Example:
        map_snd((5, "hello"), \\s: s.upper())  # (5, "HELLO")
    """
    val (a, b) = tuple
    (a, f(b))

fn map_both(tuple, f, g):
    """Map functions over both elements of pair.

    Example:
        map_both((5, 10), \\x: x * 2, \\y: y + 1)  # (10, 11)
    """
    val (a, b) = tuple
    (f(a), g(b))

fn uncurry(f, tuple):
    """Convert curried function application to tuple application.

    Example:
        val add = \\a, b: a + b
        uncurry(add, (2, 3))  # 5
    """
    val (a, b) = tuple
    f(a, b)

fn curry(f):
    """Convert tuple-taking function to curried function.

    Example:
        val tuple_add = \\t: fst(t) + snd(t)
        val curried = curry(tuple_add)
        curried(2, 3)  # 5
    """
    \\a, b: f((a, b))

# ============================================================================
# Triple (3-Tuple) Operations
# ============================================================================

fn triple(a, b, c):
    """Create a triple (3-tuple).

    Example:
        triple(1, 2, 3)  # (1, 2, 3)
    """
    (a, b, c)

fn first(tuple):
    """Get first element of triple.

    Example:
        first((1, 2, 3))  # 1
    """
    val (a, _, _) = tuple
    a

fn second(tuple):
    """Get second element of triple.

    Example:
        second((1, 2, 3))  # 2
    """
    val (_, b, _) = tuple
    b

fn third(tuple):
    """Get third element of triple.

    Example:
        third((1, 2, 3))  # 3
    """
    val (_, _, c) = tuple
    c

fn rotate_left_3(tuple):
    """Rotate triple left: (a,b,c) -> (b,c,a).

    Example:
        rotate_left_3((1, 2, 3))  # (2, 3, 1)
    """
    val (a, b, c) = tuple
    (b, c, a)

fn rotate_right_3(tuple):
    """Rotate triple right: (a,b,c) -> (c,a,b).

    Example:
        rotate_right_3((1, 2, 3))  # (3, 1, 2)
    """
    val (a, b, c) = tuple
    (c, a, b)

fn map_first(tuple, f):
    """Map function over first element of triple.

    Example:
        map_first((5, 10, 15), \\x: x * 2)  # (10, 10, 15)
    """
    val (a, b, c) = tuple
    (f(a), b, c)

fn map_second(tuple, f):
    """Map function over second element of triple.

    Example:
        map_second((5, 10, 15), \\x: x * 2)  # (5, 20, 15)
    """
    val (a, b, c) = tuple
    (a, f(b), c)

fn map_third(tuple, f):
    """Map function over third element of triple.

    Example:
        map_third((5, 10, 15), \\x: x * 2)  # (5, 10, 30)
    """
    val (a, b, c) = tuple
    (a, b, f(c))

# ============================================================================
# Quad (4-Tuple) Operations
# ============================================================================

fn quad(a, b, c, d):
    """Create a quad (4-tuple).

    Example:
        quad(1, 2, 3, 4)  # (1, 2, 3, 4)
    """
    (a, b, c, d)

fn get_1(tuple):
    """Get 1st element of 4-tuple or larger.

    Example:
        get_1((1, 2, 3, 4))  # 1
    """
    val (a, _, _, _) = tuple
    a

fn get_2(tuple):
    """Get 2nd element of 4-tuple or larger.

    Example:
        get_2((1, 2, 3, 4))  # 2
    """
    val (_, b, _, _) = tuple
    b

fn get_3(tuple):
    """Get 3rd element of 4-tuple or larger.

    Example:
        get_3((1, 2, 3, 4))  # 3
    """
    val (_, _, c, _) = tuple
    c

fn get_4(tuple):
    """Get 4th element of 4-tuple or larger.

    Example:
        get_4((1, 2, 3, 4))  # 4
    """
    val (_, _, _, d) = tuple
    d

fn map_at_1(tuple, f):
    """Map function at position 1 of 4-tuple.

    Example:
        map_at_1((5, 10, 15, 20), \\x: x * 2)  # (10, 10, 15, 20)
    """
    val (a, b, c, d) = tuple
    (f(a), b, c, d)

fn map_at_2(tuple, f):
    """Map function at position 2 of 4-tuple.

    Example:
        map_at_2((5, 10, 15, 20), \\x: x * 2)  # (5, 20, 15, 20)
    """
    val (a, b, c, d) = tuple
    (a, f(b), c, d)

fn map_at_3(tuple, f):
    """Map function at position 3 of 4-tuple.

    Example:
        map_at_3((5, 10, 15, 20), \\x: x * 2)  # (5, 10, 30, 20)
    """
    val (a, b, c, d) = tuple
    (a, b, f(c), d)

fn map_at_4(tuple, f):
    """Map function at position 4 of 4-tuple.

    Example:
        map_at_4((5, 10, 15, 20), \\x: x * 2)  # (5, 10, 15, 40)
    """
    val (a, b, c, d) = tuple
    (a, b, c, f(d))

# ============================================================================
# Quint (5-Tuple) Operations
# ============================================================================

fn quint(a, b, c, d, e):
    """Create a quint (5-tuple).

    Example:
        quint(1, 2, 3, 4, 5)  # (1, 2, 3, 4, 5)
    """
    (a, b, c, d, e)

fn get_5(tuple):
    """Get 5th element of 5-tuple.

    Example:
        get_5((1, 2, 3, 4, 5))  # 5
    """
    val (_, _, _, _, e) = tuple
    e

fn map_at_5(tuple, f):
    """Map function at position 5 of 5-tuple.

    Example:
        map_at_5((1, 2, 3, 4, 5), \\x: x * 2)  # (1, 2, 3, 4, 10)
    """
    val (a, b, c, d, e) = tuple
    (a, b, c, d, f(e))

# ============================================================================
# Tuple Construction from Arrays
# ============================================================================

fn pair_from_array(arr):
    """Create pair from array of length 2.

    Returns Some((a, b)) if length is 2, nil otherwise.

    Example:
        pair_from_array([1, 2])  # Some((1, 2))
        pair_from_array([1])     # nil
    """
    if arr.len() == 2:
        Some((arr[0], arr[1]))
    else:
        nil

fn triple_from_array(arr):
    """Create triple from array of length 3.

    Returns Some((a, b, c)) if length is 3, nil otherwise.

    Example:
        triple_from_array([1, 2, 3])  # Some((1, 2, 3))
    """
    if arr.len() == 3:
        Some((arr[0], arr[1], arr[2]))
    else:
        nil

fn quad_from_array(arr):
    """Create quad from array of length 4.

    Returns Some((a, b, c, d)) if length is 4, nil otherwise.
    """
    if arr.len() == 4:
        Some((arr[0], arr[1], arr[2], arr[3]))
    else:
        nil

fn quint_from_array(arr):
    """Create quint from array of length 5.

    Returns Some((a, b, c, d, e)) if length is 5, nil otherwise.
    """
    if arr.len() == 5:
        Some((arr[0], arr[1], arr[2], arr[3], arr[4]))
    else:
        nil

# ============================================================================
# Tuple Conversion to Arrays
# ============================================================================

fn pair_to_array(tuple):
    """Convert pair to array.

    Example:
        pair_to_array((1, 2))  # [1, 2]
    """
    val (a, b) = tuple
    [a, b]

fn triple_to_array(tuple):
    """Convert triple to array.

    Example:
        triple_to_array((1, 2, 3))  # [1, 2, 3]
    """
    val (a, b, c) = tuple
    [a, b, c]

fn quad_to_array(tuple):
    """Convert quad to array.

    Example:
        quad_to_array((1, 2, 3, 4))  # [1, 2, 3, 4]
    """
    val (a, b, c, d) = tuple
    [a, b, c, d]

fn quint_to_array(tuple):
    """Convert quint to array.

    Example:
        quint_to_array((1, 2, 3, 4, 5))  # [1, 2, 3, 4, 5]
    """
    val (a, b, c, d, e) = tuple
    [a, b, c, d, e]

# ============================================================================
# Tuple Comparison
# ============================================================================

fn pair_equals(tuple1, tuple2):
    """Check if two pairs are equal.

    Example:
        pair_equals((1, 2), (1, 2))  # true
        pair_equals((1, 2), (1, 3))  # false
    """
    val (a1, b1) = tuple1
    val (a2, b2) = tuple2
    a1 == a2 and b1 == b2

fn triple_equals(tuple1, tuple2):
    """Check if two triples are equal.

    Example:
        triple_equals((1, 2, 3), (1, 2, 3))  # true
    """
    val (a1, b1, c1) = tuple1
    val (a2, b2, c2) = tuple2
    a1 == a2 and b1 == b2 and c1 == c2

# ============================================================================
# Tuple Utility Functions
# ============================================================================

fn dup(value):
    """Create a pair with the same value twice.

    Example:
        dup(5)  # (5, 5)
    """
    (value, value)

fn triplicate(value):
    """Create a triple with the same value three times.

    Example:
        triplicate(5)  # (5, 5, 5)
    """
    (value, value, value)

fn split_at(arr, index: i64):
    """Split array at index into two parts (tuple of arrays).

    Example:
        split_at([1, 2, 3, 4, 5], 2)  # ([1, 2], [3, 4, 5])
    """
    var left = []
    var right = []

    var i = 0
    while i < index and i < arr.len():
        left.push(arr[i])
        i = i + 1

    while i < arr.len():
        right.push(arr[i])
        i = i + 1

    (left, right)

fn both(predicate, tuple):
    """Check if predicate is true for both elements of pair.

    Example:
        both(\\x: x > 0, (1, 2))  # true
        both(\\x: x > 0, (1, -1))  # false
    """
    val (a, b) = tuple
    predicate(a) and predicate(b)

fn either(predicate, tuple):
    """Check if predicate is true for either element of pair.

    Example:
        either(\\x: x > 0, (1, -1))  # true
        either(\\x: x > 0, (-1, -2))  # false
    """
    val (a, b) = tuple
    predicate(a) or predicate(b)

fn merge(tuple, combiner):
    """Merge pair into single value using combiner function.

    Example:
        merge((2, 3), \\a, b: a + b)  # 5
    """
    val (a, b) = tuple
    combiner(a, b)


# FILE: src/std/udp_utils.spl
# Size: 23475 bytes, Lines: 715

# UDP Socket Utilities Module
# Comprehensive UDP datagram operations and socket management
#
# This module provides UDP socket utilities focusing on protocol logic
# and datagram operations without actual system socket implementation.

# ============================================================================
# Core Data Structures
# ============================================================================

# UDP Socket representation
# Fields: address (text), port (i64), state (text), broadcast_enabled (i64),
#         recv_buffer_size (i64), send_buffer_size (i64)
class UdpSocket:
    address: text
    port: i64
    state: text
    broadcast_enabled: i64
    recv_buffer_size: i64
    send_buffer_size: i64
    multicast_ttl: i64
    multicast_groups: text

# Datagram representation (tuple-based for runtime compatibility)
# Format: (src_addr, src_port, dst_addr, dst_port, payload)
# Using class for better structure
class Datagram:
    src_addr: text
    src_port: i64
    dst_addr: text
    dst_port: i64
    payload: text

# Socket state constants
fn socket_state_unbound() -> text:
    "UNBOUND"

fn socket_state_bound() -> text:
    "BOUND"

fn socket_state_closed() -> text:
    "CLOSED"

# Maximum datagram size (65,507 bytes: 65,535 - 8 byte UDP header - 20 byte IP header)
fn max_datagram_size() -> i64:
    65507

# Maximum port number
fn max_port_number() -> i64:
    65535

# Minimum port number (well-known ports start at 0)
fn min_port_number() -> i64:
    0

# Default buffer sizes
fn default_recv_buffer_size() -> i64:
    65536

fn default_send_buffer_size() -> i64:
    65536

# Default multicast TTL
fn default_multicast_ttl() -> i64:
    1

# ============================================================================
# Socket Creation and Initialization
# ============================================================================

fn create_udp_socket() -> UdpSocket:
    # Create a new UDP socket in unbound state
    val socket = UdpSocket(
        address: "",
        port: 0,
        state: socket_state_unbound(),
        broadcast_enabled: 0,
        recv_buffer_size: default_recv_buffer_size(),
        send_buffer_size: default_send_buffer_size(),
        multicast_ttl: default_multicast_ttl(),
        multicast_groups: ""
    )
    socket

fn create_udp_socket_with_buffer_sizes(recv_size: i64, send_size: i64) -> UdpSocket:
    # Create a new UDP socket with custom buffer sizes
    val socket = UdpSocket(
        address: "",
        port: 0,
        state: socket_state_unbound(),
        broadcast_enabled: 0,
        recv_buffer_size: recv_size,
        send_buffer_size: send_size,
        multicast_ttl: default_multicast_ttl(),
        multicast_groups: ""
    )
    socket

# ============================================================================
# Socket Operations
# ============================================================================

fn bind_socket(socket: UdpSocket, address: text, port: i64) -> UdpSocket:
    # Bind socket to address and port
    val new_state = socket_state_bound()
    val bound_socket = UdpSocket(
        address: address,
        port: port,
        state: new_state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: socket.multicast_groups
    )
    bound_socket

fn close_socket(socket: UdpSocket) -> UdpSocket:
    # Close the socket
    val new_state = socket_state_closed()
    val closed_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: new_state,
        broadcast_enabled: 0,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: ""
    )
    closed_socket

fn is_socket_bound(socket: UdpSocket) -> i64:
    # Check if socket is bound
    val bound_state = socket_state_bound()
    val result = socket.state == bound_state
    if result:
        1
    else:
        0

fn is_socket_closed(socket: UdpSocket) -> i64:
    # Check if socket is closed
    val closed_state = socket_state_closed()
    val result = socket.state == closed_state
    if result:
        1
    else:
        0

fn get_socket_address(socket: UdpSocket) -> text:
    # Get socket's bound address
    socket.address

fn get_socket_port(socket: UdpSocket) -> i64:
    # Get socket's bound port
    socket.port

# ============================================================================
# Datagram Creation and Access
# ============================================================================

fn create_datagram(src_addr: text, src_port: i64, dst_addr: text, dst_port: i64, payload: text) -> Datagram:
    # Create a new datagram
    val datagram = Datagram(
        src_addr: src_addr,
        src_port: src_port,
        dst_addr: dst_addr,
        dst_port: dst_port,
        payload: payload
    )
    datagram

fn get_datagram_src_addr(datagram: Datagram) -> text:
    # Get source address from datagram
    datagram.src_addr

fn get_datagram_src_port(datagram: Datagram) -> i64:
    # Get source port from datagram
    datagram.src_port

fn get_datagram_dst_addr(datagram: Datagram) -> text:
    # Get destination address from datagram
    datagram.dst_addr

fn get_datagram_dst_port(datagram: Datagram) -> i64:
    # Get destination port from datagram
    datagram.dst_port

fn get_datagram_payload(datagram: Datagram) -> text:
    # Get payload from datagram
    datagram.payload

fn get_datagram_size(datagram: Datagram) -> i64:
    # Calculate datagram size (payload length + 8 byte UDP header)
    val payload_size = datagram.payload.len()
    val total_size = payload_size + 8
    total_size

# ============================================================================
# Port Validation
# ============================================================================

fn is_valid_port(port: i64) -> i64:
    # Check if port number is valid (0-65535)
    val min_port = min_port_number()
    val max_port = max_port_number()
    val is_valid = port >= min_port and port <= max_port
    if is_valid:
        1
    else:
        0

fn is_well_known_port(port: i64) -> i64:
    # Check if port is in well-known range (0-1023)
    val is_valid = port >= 0 and port <= 1023
    if is_valid:
        1
    else:
        0

fn is_registered_port(port: i64) -> i64:
    # Check if port is in registered range (1024-49151)
    val is_valid = port >= 1024 and port <= 49151
    if is_valid:
        1
    else:
        0

fn is_dynamic_port(port: i64) -> i64:
    # Check if port is in dynamic/private range (49152-65535)
    val is_valid = port >= 49152 and port <= 65535
    if is_valid:
        1
    else:
        0

# ============================================================================
# Address Validation
# ============================================================================

fn is_ipv4_address(address: text) -> i64:
    # Simple IPv4 address validation (contains dots)
    val has_dots = address.contains(".")
    if has_dots:
        1
    else:
        0

fn is_ipv6_address(address: text) -> i64:
    # Simple IPv6 address validation (contains colons)
    val has_colons = address.contains(":")
    if has_colons:
        1
    else:
        0

fn is_multicast_ipv4(address: text) -> i64:
    # Check if IPv4 address is multicast (224.0.0.0 to 239.255.255.255)
    val starts_with_224 = address.starts_with("224.")
    val starts_with_239 = address.starts_with("239.")
    val starts_with_225 = address.starts_with("225.")
    val starts_with_226 = address.starts_with("226.")
    val starts_with_227 = address.starts_with("227.")
    val starts_with_228 = address.starts_with("228.")
    val starts_with_229 = address.starts_with("229.")
    val starts_with_230 = address.starts_with("230.")
    val starts_with_231 = address.starts_with("231.")
    val starts_with_232 = address.starts_with("232.")
    val starts_with_233 = address.starts_with("233.")
    val starts_with_234 = address.starts_with("234.")
    val starts_with_235 = address.starts_with("235.")
    val starts_with_236 = address.starts_with("236.")
    val starts_with_237 = address.starts_with("237.")
    val starts_with_238 = address.starts_with("238.")

    val is_multicast = starts_with_224 or starts_with_225 or starts_with_226 or starts_with_227
    val is_multicast2 = is_multicast or starts_with_228 or starts_with_229 or starts_with_230
    val is_multicast3 = is_multicast2 or starts_with_231 or starts_with_232 or starts_with_233
    val is_multicast4 = is_multicast3 or starts_with_234 or starts_with_235 or starts_with_236
    val is_multicast5 = is_multicast4 or starts_with_237 or starts_with_238 or starts_with_239

    if is_multicast5:
        1
    else:
        0

fn is_broadcast_address(address: text) -> i64:
    # Check if address is broadcast address (255.255.255.255)
    val is_broadcast = address == "255.255.255.255"
    if is_broadcast:
        1
    else:
        0

fn is_loopback_address(address: text) -> i64:
    # Check if address is loopback (127.x.x.x for IPv4, ::1 for IPv6)
    val is_ipv4_loopback = address.starts_with("127.")
    val is_ipv6_loopback = address == "::1"
    val is_loopback = is_ipv4_loopback or is_ipv6_loopback
    if is_loopback:
        1
    else:
        0

fn is_any_address(address: text) -> i64:
    # Check if address is any address (0.0.0.0 for IPv4, :: for IPv6)
    val is_ipv4_any = address == "0.0.0.0"
    val is_ipv6_any = address == "::"
    val is_any = is_ipv4_any or is_ipv6_any
    if is_any:
        1
    else:
        0

# ============================================================================
# Datagram Validation
# ============================================================================

fn is_valid_datagram_size(size: i64) -> i64:
    # Check if datagram size is within limits
    val max_size = max_datagram_size()
    val is_valid = size > 0 and size <= max_size
    if is_valid:
        1
    else:
        0

fn validate_datagram(datagram: Datagram) -> i64:
    # Validate datagram structure and size
    val size = get_datagram_size(datagram)
    val size_valid = is_valid_datagram_size(size)
    val src_port_valid = is_valid_port(datagram.src_port)
    val dst_port_valid = is_valid_port(datagram.dst_port)
    val all_valid = size_valid == 1 and src_port_valid == 1 and dst_port_valid == 1
    if all_valid:
        1
    else:
        0

fn calculate_datagram_checksum(datagram: Datagram) -> i64:
    # Calculate simple checksum for datagram (sum of payload bytes mod 65536)
    val payload = datagram.payload
    val payload_len = payload.len()
    var checksum = 0
    var i = 0

    while i < payload_len:
        val byte_val = payload.char_code_at(i)
        checksum = checksum + byte_val
        i = i + 1

    val final_checksum = checksum % 65536
    final_checksum

# ============================================================================
# Socket Options
# ============================================================================

fn enable_broadcast(socket: UdpSocket) -> UdpSocket:
    # Enable broadcast on socket
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: 1,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: socket.multicast_groups
    )
    new_socket

fn disable_broadcast(socket: UdpSocket) -> UdpSocket:
    # Disable broadcast on socket
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: 0,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: socket.multicast_groups
    )
    new_socket

fn is_broadcast_enabled(socket: UdpSocket) -> i64:
    # Check if broadcast is enabled
    socket.broadcast_enabled

fn set_recv_buffer_size(socket: UdpSocket, size: i64) -> UdpSocket:
    # Set receive buffer size
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: socket.multicast_groups
    )
    new_socket

fn set_send_buffer_size(socket: UdpSocket, size: i64) -> UdpSocket:
    # Set send buffer size
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: socket.multicast_groups
    )
    new_socket

fn get_recv_buffer_size(socket: UdpSocket) -> i64:
    # Get receive buffer size
    socket.recv_buffer_size

fn get_send_buffer_size(socket: UdpSocket) -> i64:
    # Get send buffer size
    socket.send_buffer_size

# ============================================================================
# Multicast Operations
# ============================================================================

fn set_multicast_ttl(socket: UdpSocket, ttl: i64) -> UdpSocket:
    # Set multicast TTL
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: ttl,
        multicast_groups: socket.multicast_groups
    )
    new_socket

fn get_multicast_ttl(socket: UdpSocket) -> i64:
    # Get multicast TTL
    socket.multicast_ttl

fn join_multicast_group(socket: UdpSocket, group_addr: text) -> UdpSocket:
    # Join a multicast group
    val current_groups = socket.multicast_groups
    val new_groups = current_groups + group_addr + ","
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: new_groups
    )
    new_socket

fn leave_multicast_group(socket: UdpSocket, group_addr: text) -> UdpSocket:
    # Leave a multicast group
    val current_groups = socket.multicast_groups
    val search_pattern = group_addr + ","
    val new_groups = current_groups.replace(search_pattern, "")
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: new_groups
    )
    new_socket

fn is_in_multicast_group(socket: UdpSocket, group_addr: text) -> i64:
    # Check if socket is in multicast group
    val groups = socket.multicast_groups
    val search_pattern = group_addr + ","
    val is_member = groups.contains(search_pattern)
    if is_member:
        1
    else:
        0

fn get_multicast_groups(socket: UdpSocket) -> text:
    # Get list of multicast groups
    socket.multicast_groups

# ============================================================================
# Message Fragmentation
# ============================================================================

fn needs_fragmentation(payload: text) -> i64:
    # Check if payload needs fragmentation
    val payload_size = payload.len()
    val max_size = max_datagram_size()
    val header_size = 8
    val max_payload_size = max_size - header_size
    val needs_frag = payload_size > max_payload_size
    if needs_frag:
        1
    else:
        0

fn calculate_fragment_count(payload: text, fragment_size: i64) -> i64:
    # Calculate number of fragments needed
    val payload_size = payload.len()
    val count = payload_size / fragment_size
    val remainder = payload_size % fragment_size
    val has_remainder = remainder > 0
    if has_remainder:
        count + 1
    else:
        count

fn create_fragment(payload: text, offset: i64, length: i64) -> text:
    # Create a fragment from payload
    val fragment = payload.substring(offset, offset + length)
    fragment

fn get_max_payload_size() -> i64:
    # Get maximum payload size for single datagram
    val max_size = max_datagram_size()
    val header_size = 8
    val max_payload = max_size - header_size
    max_payload

# ============================================================================
# Utility Functions
# ============================================================================

fn format_socket_info(socket: UdpSocket) -> text:
    # Format socket information as string
    val addr_part = "Address: " + socket.address
    val port_part = "Port: " + socket.port.to_text()
    val state_part = "State: " + socket.state
    val broadcast_text = if socket.broadcast_enabled == 1: "enabled" else: "disabled"
    val broadcast_part = "Broadcast: " + broadcast_text
    val info = addr_part + ", " + port_part + ", " + state_part + ", " + broadcast_part
    info

fn format_datagram_info(datagram: Datagram) -> text:
    # Format datagram information as string
    val src_part = "Source: " + datagram.src_addr + ":" + datagram.src_port.to_text()
    val dst_part = "Destination: " + datagram.dst_addr + ":" + datagram.dst_port.to_text()
    val size = get_datagram_size(datagram)
    val size_part = "Size: " + size.to_text()
    val info = src_part + ", " + dst_part + ", " + size_part
    info

fn parse_address_port(address_port: text) -> text:
    # Parse address:port string and return address part
    val parts = address_port.split(":")
    val addr = parts.get(0)
    addr

fn parse_port_from_address(address_port: text) -> i64:
    # Parse address:port string and return port part
    val parts = address_port.split(":")
    val port_text = parts.get(1)
    val port = port_text.to_int()
    port

fn create_address_port(address: text, port: i64) -> text:
    # Create address:port string
    val port_text = port.to_text()
    val address_port = address + ":" + port_text
    address_port

# ============================================================================
# Send and Receive Simulation
# ============================================================================

fn can_send_datagram(socket: UdpSocket, datagram: Datagram) -> i64:
    # Check if socket can send datagram
    val is_bound = is_socket_bound(socket)
    val is_valid = validate_datagram(datagram)
    val size = get_datagram_size(datagram)
    val send_buf_size = socket.send_buffer_size
    val fits_in_buffer = size <= send_buf_size
    val can_send = is_bound == 1 and is_valid == 1 and fits_in_buffer
    if can_send:
        1
    else:
        0

fn can_receive_datagram(socket: UdpSocket, datagram: Datagram) -> i64:
    # Check if socket can receive datagram
    val is_bound = is_socket_bound(socket)
    val is_valid = validate_datagram(datagram)
    val size = get_datagram_size(datagram)
    val recv_buf_size = socket.recv_buffer_size
    val fits_in_buffer = size <= recv_buf_size
    val can_recv = is_bound == 1 and is_valid == 1 and fits_in_buffer
    if can_recv:
        1
    else:
        0

fn can_send_broadcast(socket: UdpSocket, datagram: Datagram) -> i64:
    # Check if socket can send broadcast datagram
    val dst_addr = datagram.dst_addr
    val is_broadcast_addr = is_broadcast_address(dst_addr)
    val broadcast_enabled = socket.broadcast_enabled
    val can_send_bc = is_broadcast_addr == 1 and broadcast_enabled == 1
    if can_send_bc:
        1
    else:
        0

fn can_send_multicast(socket: UdpSocket, datagram: Datagram) -> i64:
    # Check if socket can send multicast datagram
    val dst_addr = datagram.dst_addr
    val is_multicast = is_multicast_ipv4(dst_addr)
    val is_bound = is_socket_bound(socket)
    val can_send_mc = is_multicast == 1 and is_bound == 1
    if can_send_mc:
        1
    else:
        0

# ============================================================================
# Additional Utility Functions
# ============================================================================

fn get_socket_endpoint(socket: UdpSocket) -> text:
    # Get socket endpoint as address:port
    val endpoint = create_address_port(socket.address, socket.port)
    endpoint

fn get_datagram_source(datagram: Datagram) -> text:
    # Get datagram source as address:port
    val source = create_address_port(datagram.src_addr, datagram.src_port)
    source

fn get_datagram_destination(datagram: Datagram) -> text:
    # Get datagram destination as address:port
    val destination = create_address_port(datagram.dst_addr, datagram.dst_port)
    destination

fn create_reply_datagram(original: Datagram, reply_payload: text) -> Datagram:
    # Create a reply datagram by swapping source and destination
    val reply = Datagram(
        src_addr: original.dst_addr,
        src_port: original.dst_port,
        dst_addr: original.src_addr,
        dst_port: original.src_port,
        payload: reply_payload
    )
    reply

fn get_payload_size(datagram: Datagram) -> i64:
    # Get payload size only (without UDP header)
    val payload_size = datagram.payload.len()
    payload_size

fn is_empty_payload(datagram: Datagram) -> i64:
    # Check if datagram has empty payload
    val payload_size = get_payload_size(datagram)
    val is_empty = payload_size == 0
    if is_empty:
        1
    else:
        0

fn compare_datagrams(datagram1: Datagram, datagram2: Datagram) -> i64:
    # Compare two datagrams for equality
    val src_addr_eq = datagram1.src_addr == datagram2.src_addr
    val src_port_eq = datagram1.src_port == datagram2.src_port
    val dst_addr_eq = datagram1.dst_addr == datagram2.dst_addr
    val dst_port_eq = datagram1.dst_port == datagram2.dst_port
    val payload_eq = datagram1.payload == datagram2.payload

    val eq1 = src_addr_eq and src_port_eq
    val eq2 = eq1 and dst_addr_eq
    val eq3 = eq2 and dst_port_eq
    val eq4 = eq3 and payload_eq

    if eq4:
        1
    else:
        0

fn clone_datagram(datagram: Datagram) -> Datagram:
    # Create a copy of datagram
    val clone = Datagram(
        src_addr: datagram.src_addr,
        src_port: datagram.src_port,
        dst_addr: datagram.dst_addr,
        dst_port: datagram.dst_port,
        payload: datagram.payload
    )
    clone

fn clone_socket(socket: UdpSocket) -> UdpSocket:
    # Create a copy of socket
    val clone = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: socket.multicast_groups
    )
    clone


# FILE: src/std/validation_utils.spl
# Size: 3955 bytes, Lines: 135

# Validation Utilities Module
#
# Common validation predicates for data validation tasks.
# Provides simple checks for numbers, strings, and ranges.
#
# Categories:
# - Number validation: is_positive, is_negative, is_non_negative, is_zero
# - Range validation: is_in_range, is_outside_range
# - String validation: is_not_empty, is_empty
# - Divisibility: is_divisible, is_multiple_of
#
# All functions are pure Simple - no external dependencies required.

# ============================================================================
# Exports
# ============================================================================

export is_positive, is_negative, is_non_negative, is_zero
export is_in_range, is_outside_range
export is_not_empty, is_empty
export is_divisible, is_multiple_of

# ============================================================================
# Number Validation
# ============================================================================

fn is_positive(x: i64) -> bool:
    """Check if number is strictly positive (> 0).

    Example:
        is_positive(5)   # true
        is_positive(0)   # false
        is_positive(-5)  # false
    """
    x > 0

fn is_negative(x: i64) -> bool:
    """Check if number is strictly negative (< 0).

    Example:
        is_negative(-5)  # true
        is_negative(0)   # false
        is_negative(5)   # false
    """
    x < 0

fn is_non_negative(x: i64) -> bool:
    """Check if number is non-negative (>= 0).

    Example:
        is_non_negative(0)   # true
        is_non_negative(5)   # true
        is_non_negative(-5)  # false
    """
    x >= 0

fn is_zero(x: i64) -> bool:
    """Check if number is zero.

    Example:
        is_zero(0)   # true
        is_zero(5)   # false
        is_zero(-5)  # false
    """
    x == 0

# ============================================================================
# Range Validation
# ============================================================================

fn is_in_range(x: i64, min_val: i64, max_val: i64) -> bool:
    """Check if number is in range [min, max] (inclusive).

    Example:
        is_in_range(x=5, min_val=0, max_val=10)   # true
        is_in_range(x=-1, min_val=0, max_val=10)  # false
        is_in_range(x=11, min_val=0, max_val=10)  # false
    """
    x >= min_val and x <= max_val

fn is_outside_range(x: i64, min_val: i64, max_val: i64) -> bool:
    """Check if number is outside range [min, max].

    Example:
        is_outside_range(x=-1, min_val=0, max_val=10)  # true
        is_outside_range(x=11, min_val=0, max_val=10)  # true
        is_outside_range(x=5, min_val=0, max_val=10)   # false
    """
    x < min_val or x > max_val

# ============================================================================
# String Validation
# ============================================================================

fn is_not_empty(s: text) -> bool:
    """Check if string is not empty.

    Example:
        is_not_empty("hello")  # true
        is_not_empty("")       # false
    """
    s.len() > 0

fn is_empty(s: text) -> bool:
    """Check if string is empty.

    Example:
        is_empty("")       # true
        is_empty("hello")  # false
    """
    s.len() == 0

# ============================================================================
# Divisibility Validation
# ============================================================================

fn is_divisible(x: i64, divisor: i64) -> bool:
    """Check if x is divisible by divisor (x % divisor == 0).

    Example:
        is_divisible(x=10, divisor=2)  # true
        is_divisible(x=10, divisor=3)  # false
    """
    if divisor == 0:
        return false
    x % divisor == 0

fn is_multiple_of(x: i64, factor: i64) -> bool:
    """Check if x is a multiple of factor (same as is_divisible).

    Example:
        is_multiple_of(x=15, factor=3)  # true
        is_multiple_of(x=15, factor=4)  # false
    """
    is_divisible(x, factor)


