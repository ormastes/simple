# Simple Language Grammar - Core Tier

> **Core tier**: The Simple-in-Simple compiler (`src/core/`). Includes seed tier
> plus additional language features for self-hosting.

*Generated by `bin/simple grammar-doc` from `doc/spec/grammar/tier_keywords.sdn`.*

---

## Keywords

| Keyword | Category | Tier | Description | Example |
|---------|----------|------|-------------|---------|
| `fn` | declarations | seed | Function definition | `fn square(x: i64) -> i64: x * x` |
| `val` | declarations | seed | Immutable binding | `val name = "Alice"` |
| `var` | declarations | seed | Mutable binding | `var count = 0` |
| `struct` | declarations | seed | Struct definition | `struct Point: x: i64; y: i64` |
| `enum` | declarations | seed | Enum definition | `enum Color: Red; Green; Blue` |
| `class` | declarations | seed | Class definition (struct with methods) | `class Dog: name: text` |
| `impl` | declarations | seed | Method implementation block | `impl Point: fn len(): ...` |
| `extern` | declarations | seed | External function declaration (FFI) | `extern fn rt_print(s: text)` |
| `use` | declarations | seed | Module import | `use std.math.{sqrt, abs}` |
| `export` | declarations | seed | Symbol export | `export my_fn, MyType` |
| `import` | declarations | seed | Module import (deprecated, use use) |  |
| `trait` | declarations | core | Trait definition | `trait Printable: fn print():` |
| `pub` | declarations | core | Public visibility modifier |  |
| `static` | declarations | seed | Static method or binding |  |
| `me` | declarations | seed | Mutable self method |  |
| `type` | declarations | core | Type alias |  |
| `implements` | declarations | core | Trait implementation declaration |  |
| `const` | declarations | core | Compile-time constant |  |
| `asm` | declarations | seed | Inline assembly block |  |
| `if` | control_flow | seed | Conditional branch | `if x > 0: print "positive"` |
| `elif` | control_flow | seed | Else-if branch |  |
| `else` | control_flow | seed | Else branch |  |
| `for` | control_flow | seed | For loop | `for item in items: print item` |
| `while` | control_flow | seed | While loop |  |
| `match` | control_flow | seed | Pattern match expression | `match value: case 1: ...` |
| `case` | control_flow | seed | Match arm |  |
| `return` | control_flow | seed | Return from function | `return result` |
| `break` | control_flow | seed | Break out of loop |  |
| `continue` | control_flow | seed | Skip to next iteration |  |
| `in` | control_flow | seed | Membership / iteration operator |  |
| `loop` | control_flow | core | Infinite loop |  |
| `pass` | control_flow | seed | No-op placeholder |  |
| `pass_todo` | control_flow | seed | Unimplemented placeholder (TODO) |  |
| `pass_do_nothing` | control_flow | seed | Intentional no-op |  |
| `pass_dn` | control_flow | seed | Alias for pass_do_nothing |  |
| `and` | control_flow | seed | Logical AND | `if a and b: ...` |
| `or` | control_flow | seed | Logical OR |  |
| `not` | control_flow | seed | Logical NOT |  |
| `self` | control_flow | seed | Current instance reference |  |
| `is` | control_flow | core | Type check operator |  |
| `as` | control_flow | core | Type cast operator |  |
| `from` | control_flow | core | Import source specifier |  |
| `async` | control_flow | core | Async function modifier | `async fn fetch():` |
| `await` | control_flow | core | Await async expression |  |
| `yield` | control_flow | core | Yield from generator |  |
| `spawn` | control_flow | core | Spawn actor/task | `spawn worker()` |
| `true` | expressions | seed | Boolean true literal | `val done = true` |
| `false` | expressions | seed | Boolean false literal |  |
| `nil` | expressions | seed | Null/none value | `var result = nil` |
| `super` | expressions | seed | Parent module reference |  |
| `Some` | expressions | seed | Option type wrapper |  |
| `Ok` | expressions | seed | Result success wrapper |  |
| `Err` | expressions | seed | Result error wrapper |  |
| `None` | expressions | seed | Option empty value |  |

## Operators

| Operator | Symbol | Tier |
|----------|--------|------|
| plus | `+` | seed |
| minus | `-` | seed |
| star | `*` | seed |
| slash | `/` | seed |
| percent | `%` | seed |
| star_star | `**` | core |
| shl | `<<` | core |
| shr | `>>` | core |
| eq | `==` | seed |
| not_eq | `!=` | seed |
| lt | `<` | seed |
| gt | `>` | seed |
| lt_eq | `<=` | seed |
| gt_eq | `>=` | seed |
| assign | `=` | seed |
| plus_eq | `+=` | seed |
| minus_eq | `-=` | seed |
| star_eq | `*=` | seed |
| slash_eq | `/=` | seed |
| percent_eq | `%=` | seed |
| walrus | `:=` | core |
| ampersand | `&` | core |
| pipe | `|` | core |
| caret | `^` | core |
| tilde | `~` | core |
| question | `?` | core |
| question_dot | `?.` | core |
| question_question | `??` | core |
| dot_question | `.?` | core |
| pipe_forward | `|>` | core |
| compose | `>>` | core |
| dot_dot | `..` | seed |
| dot_dot_eq | `..=` | core |

## Constructs

| Construct | Tier |
|-----------|------|
| string_interpolation | seed |
| raw_string | seed |
| range_expr | seed |
| array_literal | seed |
| struct_constructor | seed |
| when_block | seed |
| cfg_attribute | seed |
| lambda | core |
| generic_syntax | core |
| optional_chaining | core |
| null_coalesce | core |
| walrus_binding | core |
| pipe_forward_expr | core |
| compose_expr | core |
| power_op | core |

## Assembly Capabilities

| Capability | Kind | Tier | Description |
|------------|------|------|-------------|
| asm_single_line | clang-depend | seed | Single-line asm statement (`asm "nop"`) |
| asm_indented_block | clang-depend | seed | Indented asm block (`asm:\n    "nop"`) |
| asm_braced_block | clang-depend | seed | Braced asm block (`asm nop`) |
| asm_match | clang-depend | seed | Target-conditional asm (`asm match: case [x86_64]: ...`) |
| asm_assert | clang-depend | seed | Target assertion (`asm assert [x86_64, linux]`) |

## Low-Level Features

| Feature | Tier | Description |
|---------|------|-------------|
| union_type_operator | core | Union type operator (`A | B | C`) |
| volatile_asm | seed | Volatile asm via C passthrough |

---

**Summary:** 54 keywords, 33 operators, 15 constructs

## Conditional Compilation (Platform/CPU)

Core parser supports source-level conditional directives:

- `#if <condition>`
- `#elif <condition>`
- `#else`
- `#endif`

Optional trailing `:` is accepted on hash directives (for example `#if linux:` and `#else:`).

Core also supports annotation-based conditionals:

- `@when(condition): ... @elif(...) ... @else ... @end`
- `@cfg(condition)` and `@cfg("key", "value")` on declarations

### Supported condition atoms

- OS: `win`, `windows`, `linux`, `mac`, `macos`, `darwin`, `freebsd`, `openbsd`, `netbsd`, `android`, `unix`
- CPU/arch: `x86_64`, `amd64`, `x64`, `x86`, `i386`, `i686`, `aarch64`, `arm64`, `riscv64`, `riscv32`, `arm`, `ppc64le`
- Key/value: `os=linux`, `platform=windows`, `arch=x86_64`, `cpu=arm64`
- Boolean: `true`, `false`, `and`/`&&`, `or`/`||`, `not`/`!`
- Build: `debug`, `release`, `compiled`, `interpreter`

### Target override environment variables

- `SIMPLE_TARGET_OS`
- `SIMPLE_TARGET_ARCH`
- `SIMPLE_TARGET_CPU`

`@when(...)` annotations in core interpreter evaluate platform/CPU predicates.
`@cfg(...)` annotations work identically for per-declaration conditionals.
Full compiler frontend (`src/compiler/frontend.spl`) uses the same core preprocessor path for `#if/#elif/#else/#endif`.

## Binary Completeness Gaps (2026-02-20)

> Hand-maintained status notes. Generated tables above are unchanged.
> See also `[asm_capabilities]` and `[low_level_features]` in `tier_keywords.sdn`.

### Clang-Depend Gaps (text passthrough — clang encodes)

| Capability | Current core behavior | Status |
|---|---|---|
| `asm` text passthrough (single-line, block, braced) | **Working** — `parser.spl:1578-1649`, `c_codegen.spl:508-518` | Done |
| `asm match: case [target]:` | **Working** — target eval via C preprocessor | Done |
| `asm assert [target]` | **Working** — emits `static_assert` | Done |

### Compiler-Depend Gaps (compiler understands operands/registers)

| Capability | Current core behavior | Status |
|---|---|---|
| `asm` with `in(reg)`/`out(reg)` operands | Not supported — requires `src/compiler/inline_asm.spl` (full only) | Full-tier only |
| `asm` clobber lists | Not supported — requires register allocation | Full-tier only |
| `asm` target validation (per-arch) | Not supported — requires instruction tables | Full-tier only |

### Other Low-Level Gaps

| Capability | Current core behavior | Evidence |
|---|---|---|
| `union` declarations (C-style layout) | Only union *type operator* (`A | B | C`); no declaration keyword path | `parser.spl:317` |
| Stable union lowering/storage | Registered union types collapse to `TYPE_UNION`, C mapping dynamic `SplValue` | `types.spl:475` |
| `bitfield` declarations | Not present in core; classified as full-tier | `tier_keywords.sdn:35` |
| `@packed`/`@repr`/`@align` attributes | Not in core parser; full compiler defines them | `parser_types.spl:105` |
| Type alias semantics | Parsed then discarded at module level | `parser.spl:2535` |
| Trait dispatch/bounds | Trait blocks parsed through struct path, no dedicated lowering | `parser.spl:2505` |
| Custom payload blocks (`sh{}`, `sql{}`) | No core AST custom-block variant; full AST has `CustomBlock` | `parser_types.spl:519` |

### Minimum Additions Needed In Core

1. Add declaration grammar and lowering for `bitfield`, `union`, and packed/repr/aligned data layout.
2. Add parser+AST support for custom payload blocks so backend-specific blocks survive frontend passes.
3. Add ABI and placement attributes (`@link_section`, `@callconv`, `@naked`, `@interrupt`).
4. Expand core low-level type surface beyond `i64`, `f64`, `text`, `bool` for deterministic binary interfaces.

### Tier Boundaries — What Core Should NOT Support

- Multiple backends — core always → C → clang
- GPU syntax (`<<<`/`>>>`) — requires CUDA/GPU dispatch
- Broadcasting ops (`.+`, `.-`, `.*`, `./`) — requires tensor system
- Math blocks (`m{ x^2 }`) — requires math DSL parser
- MDSOC/pointcuts — requires aspect system
- Full monomorphization — requires generic specialization engine
- `asm` operand constraints — requires register allocation (full-tier only)
- Comprehensions — requires desugaring pipeline

### Cross-Tier Blocker To Track

- Full compiler monomorphization still marks full union support as incomplete (`src/compiler_shared/monomorphize/util.spl:240`), so seed/core union work should align with that upstream completion.
