# Simple Language Grammar - Core Tier

> **Core tier**: The Simple-in-Simple compiler (`src/compiler_core/`). Includes seed tier
> plus additional language features for self-hosting.

*Generated by `bin/simple grammar-doc` from `doc/spec/grammar/tier_keywords.sdn`.*

---

## Keywords

| Keyword | Category | Tier | Description | Example |
|---------|----------|------|-------------|---------|
| `fn` | declarations | seed | Function definition | `fn square(x: i64) -> i64: x * x` |
| `val` | declarations | seed | Immutable binding | `val name = "Alice"` |
| `var` | declarations | seed | Mutable binding | `var count = 0` |
| `struct` | declarations | seed | Struct definition | `struct Point: x: i64; y: i64` |
| `enum` | declarations | seed | Enum definition | `enum Color: Red; Green; Blue` |
| `class` | declarations | seed | Class definition (struct with methods) | `class Dog: name: text` |
| `impl` | declarations | seed | Method implementation block | `impl Point: fn len(): ...` |
| `extern` | declarations | seed | External function declaration (FFI) | `extern fn rt_print(s: text)` |
| `use` | declarations | seed | Module import | `use std.math.{sqrt, abs}` |
| `export` | declarations | seed | Symbol export | `export my_fn, MyType` |
| `import` | declarations | seed | Module import (deprecated, use use) |  |
| `trait` | declarations | core | Trait definition | `trait Printable: fn print():` |
| `pub` | declarations | core | Public visibility modifier |  |
| `static` | declarations | core | Static method or binding |  |
| `me` | declarations | core | Mutable self method |  |
| `type` | declarations | core | Type alias |  |
| `asm` | declarations | core | Inline assembly block |  |
| `implements` | declarations | core | Trait implementation declaration |  |
| `if` | control_flow | seed | Conditional branch | `if x > 0: print "positive"` |
| `elif` | control_flow | seed | Else-if branch |  |
| `else` | control_flow | seed | Else branch |  |
| `for` | control_flow | seed | For loop | `for item in items: print item` |
| `while` | control_flow | seed | While loop |  |
| `match` | control_flow | seed | Pattern match expression | `match value: case 1: ...` |
| `case` | control_flow | seed | Match arm |  |
| `return` | control_flow | seed | Return from function | `return result` |
| `break` | control_flow | seed | Break out of loop |  |
| `continue` | control_flow | seed | Skip to next iteration |  |
| `in` | control_flow | seed | Membership / iteration operator |  |
| `loop` | control_flow | core | Infinite loop |  |
| `pass` | control_flow | core | No-op placeholder |  |
| `pass_todo` | control_flow | core | Unimplemented placeholder (TODO) |  |
| `pass_do_nothing` | control_flow | core | Intentional no-op |  |
| `pass_dn` | control_flow | core | Alias for pass_do_nothing |  |
| `and` | control_flow | core | Logical AND | `if a and b: ...` |
| `or` | control_flow | core | Logical OR |  |
| `not` | control_flow | core | Logical NOT |  |
| `self` | control_flow | core | Current instance reference |  |
| `is` | control_flow | core | Type check operator |  |
| `async` | control_flow | core | Async function modifier | `async fn fetch():` |
| `await` | control_flow | core | Await async expression |  |
| `yield` | control_flow | core | Yield from generator |  |
| `spawn` | control_flow | core | Spawn actor/task | `spawn worker()` |
| `true` | expressions | seed | Boolean true literal | `val done = true` |
| `false` | expressions | seed | Boolean false literal |  |
| `nil` | expressions | seed | Null/none value | `var result = nil` |

## Operators

| Operator | Symbol | Tier |
|----------|--------|------|
| plus | `+` | seed |
| minus | `-` | seed |
| star | `*` | seed |
| slash | `/` | seed |
| percent | `%` | seed |
| star_star | `**` | core |
| shl | `<<` | core |
| shr | `>>` | core |
| eq | `==` | seed |
| not_eq | `!=` | seed |
| lt | `<` | seed |
| gt | `>` | seed |
| lt_eq | `<=` | seed |
| gt_eq | `>=` | seed |
| assign | `=` | seed |
| plus_eq | `+=` | seed |
| minus_eq | `-=` | seed |
| star_eq | `*=` | seed |
| slash_eq | `/=` | seed |
| percent_eq | `%=` | seed |
| walrus | `:=` | core |
| ampersand | `&` | core |
| pipe | `|` | core |
| caret | `^` | core |
| tilde | `~` | core |
| question | `?` | core |
| question_dot | `?.` | core |
| question_question | `??` | core |
| dot_question | `.?` | core |
| pipe_forward | `|>` | core |
| compose | `>>` | core |
| dot_dot | `..` | seed |
| dot_dot_eq | `..=` | core |

## Constructs

| Construct | Tier |
|-----------|------|
| string_interpolation | seed |
| raw_string | seed |
| range_expr | seed |
| array_literal | seed |
| struct_constructor | seed |
| lambda | core |
| generic_syntax | core |
| optional_chaining | core |
| null_coalesce | core |
| walrus_binding | core |
| pipe_forward_expr | core |
| compose_expr | core |
| power_op | core |

---

**Summary:** 46 keywords, 33 operators, 13 constructs

## Conditional Compilation (Platform/CPU)

Core parser supports source-level conditional directives:

- `#if <condition>`
- `#elif <condition>`
- `#else`
- `#endif`

Optional trailing `:` is accepted on hash directives (for example `#if linux:` and `#else:`).

Core also supports annotation-based conditionals:

- `@when(condition): ... @elif(...) ... @else ... @end`
- `@cfg(condition)` and `@cfg("key", "value")` on declarations

### Supported condition atoms

- OS: `win`, `windows`, `linux`, `mac`, `macos`, `darwin`, `freebsd`, `openbsd`, `netbsd`, `android`, `unix`
- CPU/arch: `x86_64`, `amd64`, `x64`, `x86`, `i386`, `i686`, `aarch64`, `arm64`, `riscv64`, `riscv32`, `arm`, `ppc64le`
- Key/value: `os=linux`, `platform=windows`, `arch=x86_64`, `cpu=arm64`
- Boolean: `true`, `false`, `and`/`&&`, `or`/`||`, `not`/`!`
- Build: `debug`, `release`, `compiled`, `interpreter`

### Target override environment variables

- `SIMPLE_TARGET_OS`
- `SIMPLE_TARGET_ARCH`
- `SIMPLE_TARGET_CPU`

`@when(...)` annotations in core interpreter evaluate platform/CPU predicates.
`@cfg(...)` annotations work identically for per-declaration conditionals.
Full compiler frontend (`src/compiler/frontend.spl`) uses the same core preprocessor path for `#if/#elif/#else/#endif`.

## Binary Completeness Gaps (2026-02-18)

> Hand-maintained status notes. Generated tables above are unchanged.

### Current Core Limitations For "Generate Any Binary"

| Capability needed for low-level complete binaries | Current core behavior | Evidence |
|---|---|---|
| Inline asm as real IR/codegen input | `asm` is tokenized, but module parser skips asm blocks | `src/compiler_core/tokens.spl:46`, `src/compiler_core/parser.spl:2549` |
| `union` declarations with explicit layout | Only union *type operator* (`A | B | C`) exists; no `union` declaration keyword path | `src/compiler_core/parser.spl:317`, `src/compiler_core/tokens.spl:329` |
| Stable union lowering/storage model | Registered union types collapse to `TYPE_UNION`, and C mapping becomes dynamic `SplValue` | `src/compiler_core/types.spl:475`, `src/compiler_core/types.spl:350` |
| `bitfield` declarations | Not present in core token/keyword path; classified as full-tier | `src/compiler_core/tokens.spl:329`, `doc/spec/grammar/tier_keywords.sdn:35` |
| Packed/layout attributes (`@packed`, `@repr`, `@align`) | Not represented in core parser pipeline; full compiler parser types define them | `src/compiler_shared/parser_types.spl:105`, `src/compiler_shared/parser_types.spl:120` |
| Type alias semantics | Parsed then discarded at module level | `src/compiler_core/parser.spl:2535` |
| Trait semantics | Trait blocks are parsed through struct path, not dedicated trait lowering | `src/compiler_core/parser.spl:2505` |
| Generic custom blocks (`sh{}`, `sql{}`, `asm{}`-style payloads) | No core AST/custom-block expression variant; full AST includes `CustomBlock` | `src/compiler_shared/parser_types.spl:519` |

### Minimum Additions Needed In Core

1. Add declaration grammar and lowering for `bitfield`, `union`, and packed/repr/aligned data layout.
2. Replace asm-skip behavior with full parse -> AST -> lowering -> backend emission for inline asm.
3. Add parser+AST support for custom payload blocks so backend-specific blocks can survive frontend passes.
4. Add ABI and placement attributes needed for real binaries (`@link_section`, `@addr_space`, `@callconv`, `@naked`, `@interrupt`) by aligning with full modules:
`src/compiler/link_attrs.spl:1`, `src/compiler/attributes.spl:3`, `src/compiler/callconv_bridge.spl:1`.
5. Expand core low-level type surface beyond the current narrow primitive set used in `parser_parse_type` (`i64`, `f64`, `text`, `bool`) for deterministic binary interfaces (`src/compiler_core/parser.spl:233`).

### Cross-Tier Blocker To Track

- Full compiler monomorphization still marks full union support as incomplete (`src/compiler_shared/monomorphize/util.spl:240`, `src/compiler_shared/monomorphize/util.spl:505`), so seed/core union work should align with that upstream completion.
