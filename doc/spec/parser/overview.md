# Simple Language Lexer and Parser Specification

> **⚠️ Design Document Notice**
>
> This document describes the TreeSitter grammar specification for Simple.
> It is a **design document**, not the actual implementation.
> The actual parser is implemented in Rust at `src/parser/src/`.
> This specification serves as reference for what a TreeSitter grammar would provide.

## Overview

This document specifies the complete lexer and parser implementation for the Simple programming language using Tree-sitter with GLR (Generalized LR) parsing for optimal performance. The implementation consists of:

1. **Tree-sitter Grammar** (`grammar.js`) - Complete GLR grammar definition
2. **External Scanner** (`scanner.c`) - Indentation and context-sensitive token handling
3. **Rust Bindings** - Integration code for embedding in Rust applications
4. **Token Specification** - Complete lexical token definitions

This specification is split into multiple files:

| File | Content |
|------|---------|
| [lexer_parser.md](lexer_parser.md) | Overview and Token Specification |
| [lexer_parser_grammar.md](lexer_parser_grammar.md) | Tree-sitter Grammar (`grammar.js`) |
| [lexer_parser_scanner.md](lexer_parser_scanner.md) | External Scanner and Rust Bindings |
| [lexer_parser_integration.md](lexer_parser_integration.md) | Parser Integration, AST Visitor, Queries, Examples |

---

## Token Specification

### Reserved Keywords

```
# Type & Structure Keywords
struct      class       enum        trait       actor
impl        fn          let         mut         immut
type        where       as          in          is
Constructor

# Control Flow
if          else        elif        match       case
for         while       loop        break       continue
return      yield       with

# Memory & Ownership
new         move        ref         self        Self

# Concurrency
spawn       send        receive     on          state

# Effects & Modifiers
async       await       extern      static
pub         priv        const       global

# Logical & Values
and         or          not         true        false        nil

# Special
context     macro       handle_pool gen_code

# Module System
mod         use         export      common      auto
import      crate       profile     feature
```

### Operators and Punctuation

```
# Arithmetic
+       -       *       /       %       **

# Comparison
==      !=      <       >       <=      >=

# Assignment & Update
=       ->      <-

# Logical (symbolic alternatives)
&&      ||      !

# Bitwise
&       |       ^       ~       <<      >>

# Punctuation
(       )       [       ]       {       }
:       ;       ,       .       ..      ...
@       #       \       ?       _

# Pointer Type Prefixes (in type context)
&       *       -       +
```

### Literals

| Type | Pattern | Examples |
|------|---------|----------|
| Integer | `[0-9][0-9_]*` | `42`, `1_000_000` |
| Hex Integer | `0x[0-9a-fA-F_]+` | `0xFF`, `0x1A_2B` |
| Binary Integer | `0b[01_]+` | `0b1010`, `0b1111_0000` |
| Octal Integer | `0o[0-7_]+` | `0o755`, `0o777` |
| Float | `[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?` | `3.14`, `1.0e-10` |
| String | `"([^"\\]|\\.)*"` | `"hello"`, `"line\n"` |
| Raw String | `r"[^"]*"` | `r"no\escape"` |
| Char | `'([^'\\]|\\.)'` | `'a'`, `'\n'` |
| Symbol/Atom | `:[a-zA-Z_][a-zA-Z0-9_]*` | `:ok`, `:error` |

### Identifiers

```
# Regular identifier
[a-zA-Z_][a-zA-Z0-9_]*

# Type identifier (starts with uppercase by convention)
[A-Z][a-zA-Z0-9_]*
```

### Comments

```
# Line comment - extends to end of line
# This is a comment

# Block comment (if supported)
/* Multi-line
   comment */
```

### Whitespace and Indentation

- Significant indentation (Python-style)
- INDENT and DEDENT tokens generated by external scanner
- NEWLINE token separates statements
- Spaces preferred over tabs (4 spaces = 1 indent level)

---

## Summary

This specification provides a complete lexer and parser implementation for the Simple language:

| Component | Purpose |
|-----------|---------|
| `grammar.js` | Complete GLR grammar with 100+ rules |
| `scanner.c` | External scanner for indentation handling |
| `lib.rs` | Rust bindings and language function |
| `parser.rs` | High-level parsing API with error handling |
| `visitor.rs` | AST visitor pattern for tree traversal |
| `highlights.scm` | Syntax highlighting queries |
| `locals.scm` | Scope and reference tracking |
| `indents.scm` | Auto-indentation rules |

The GLR approach provides fast, robust parsing with excellent error recovery, making it suitable for both batch compilation and interactive IDE use.

See other files for full implementation details:
- [Grammar](lexer_parser_grammar.md)
- [Scanner & Bindings](lexer_parser_scanner.md)
- [Integration & Queries](lexer_parser_integration.md)
