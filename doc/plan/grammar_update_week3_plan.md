# Grammar Update - Week 3 Plan: HIR Integration

**Date:** 2026-02-07
**Milestone:** HIR Integration for Async/Await
**Estimated Duration:** 1 week (5 days)
**Dependencies:** Week 1 ✅, Week 2 ✅

---

## Overview

Week 3 integrates async/await with the HIR (High-level Intermediate Representation) layer, adding proper type checking, type lowering, and error diagnostics for Future<T> types and async functions.

**Current State (Week 2):**
```simple
# Generated by desugaring:
fn fetch() -> Future<text>:
    Future.from_generator(\state, waker: poll_fetch(state, waker))

enum FetchState: ...
fn poll_fetch(...): ...
```

**Target State (Week 3):**
```
# HIR with proper types:
- Future<text> lowered to HIR type
- Type checking validates state machine correctness
- Error messages for mismatched Future types
- Optimized HIR representation
```

---

## Goals

### Primary Deliverables

1. **Future<T> Type Lowering** (200-300 lines)
   - Lower Future<T> to HIR representation
   - Handle generic type parameters
   - Preserve type information through pipeline

2. **Async Type Checking** (300-400 lines)
   - Validate async function return types
   - Check state machine type consistency
   - Verify poll function signatures

3. **Error Diagnostics** (200-300 lines)
   - Clear error messages for type mismatches
   - Helpful suggestions for common mistakes
   - Source location tracking

4. **HIR Optimization** (100-200 lines)
   - Dead code elimination in states
   - Constant propagation
   - Inline small state machines

5. **Test Suite** (30-40 tests)
   - Type lowering tests
   - Type checking tests
   - Error diagnostic tests
   - Optimization tests

6. **Documentation** (800-1000 lines)
   - HIR integration design
   - Type system extension
   - Error message catalog
   - Completion report

### Success Criteria

- ✅ Future<T> types correctly lowered to HIR
- ✅ Type checking catches common errors
- ✅ Clear, actionable error messages
- ✅ No performance regression
- ✅ All tests passing (100%)

---

## Architecture

### HIR Type System Extension

**Current HIR Types:**
```rust
enum HIRType:
    Int(i64)
    Float(f64)
    Bool
    Text
    Unit
    Generic(name, args)
    Function(params, return)
    ...
```

**Extension for Future:**
```simple
# Future<T> as generic type
HIRType.Generic("Future", [T])

# Specialized Future types
Future<text> → HIRType.Generic("Future", [HIRType.Text])
Future<i64> → HIRType.Generic("Future", [HIRType.Int])
Future<()> → HIRType.Generic("Future", [HIRType.Unit])
```

### Type Lowering Pipeline

```
AST Type (Future<text>)
    ↓
Type Lowering
    ↓
HIR Type (Generic("Future", [Text]))
    ↓
Type Checking
    ↓
Validated HIR
    ↓
MIR Generation
```

---

## Implementation Plan

### Phase 1: Future<T> Type Lowering (Day 1, 8 hours)

**Goal:** Lower Future<T> types from AST to HIR

**Tasks:**

1. **HIR Type Extension** (2 hours)
   - Add Future type handling to HIR type lowering
   - Support nested generic types
   - Handle type parameter substitution

2. **Type Lowering Logic** (4 hours)
   - Lower `TypeKind.Generic("Future", [T])` to HIR
   - Preserve type parameters through pipeline
   - Handle recursive type lowering

3. **Tests** (2 hours)
   - Test simple Future types (Future<i64>, Future<text>)
   - Test nested types (Future<Result<T, E>>)
   - Test type parameter substitution

**Files:**
- `src/compiler/hir/type_lower.spl` (MODIFY, +100 lines)
- `test/compiler/hir_future_type_spec.spl` (NEW, 10 tests)

**Output:**
```simple
struct FutureLowering:
    """Handles lowering of Future<T> types to HIR."""

    fn lower_future_type(ast_type: Type) -> HIRType:
        """Lower Future<T> AST type to HIR representation."""
```

### Phase 2: Async Type Checking (Day 2, 8 hours)

**Goal:** Validate async function types and state machines

**Tasks:**

1. **Return Type Checking** (3 hours)
   - Verify async fn returns Future<T>
   - Check T matches function body type
   - Validate state enum types

2. **State Machine Validation** (3 hours)
   - Check poll function signature
   - Verify state transitions preserve types
   - Validate Ready/Pending types

3. **Tests** (2 hours)
   - Test return type validation
   - Test state machine type checking
   - Test error detection

**Files:**
- `src/compiler/hir/async_check.spl` (NEW, ~300 lines)
- `test/compiler/hir_async_check_spec.spl` (NEW, 12 tests)

**Checks:**
```simple
# Check 1: Async function return type
async fn fetch() -> text:  # OK
    ...

async fn fetch() -> Future<text>:  # ERROR: already wrapped
    ...

# Check 2: State machine consistency
fn poll_fetch(state: FetchState, waker: Waker) -> (FetchState, Poll<text>):
    # State transitions must preserve types
```

### Phase 3: Error Diagnostics (Day 3, 8 hours)

**Goal:** Clear, actionable error messages

**Tasks:**

1. **Error Types** (2 hours)
   - Define error kinds for async/await
   - Source location tracking
   - Suggestion generation

2. **Error Messages** (4 hours)
   - Type mismatch messages
   - Missing Future wrapper
   - Invalid state transitions
   - Helpful suggestions

3. **Tests** (2 hours)
   - Test error message quality
   - Test suggestion accuracy
   - Test source location tracking

**Files:**
- `src/compiler/hir/async_errors.spl` (NEW, ~200 lines)
- `test/compiler/hir_async_errors_spec.spl` (NEW, 10 tests)

**Example Errors:**
```
error[E0701]: async function must return Future<T>
  --> example.spl:3:1
   |
3  | async fn fetch() -> text:
   |                     ^^^^ expected Future<text>, found text
   |
   = help: change return type to Future<text>
   = note: async functions automatically wrap return values

error[E0702]: mismatched types in state transition
  --> generated/poll_fetch.spl:12:5
   |
12 |     (State1(a: "not_i64"), Poll.Pending)
   |              ^^^^^^^^^^ expected i64, found text
   |
   = note: state field 'a' has type i64
```

### Phase 4: HIR Optimization (Day 4, 8 hours)

**Goal:** Optimize generated state machines

**Tasks:**

1. **Dead State Elimination** (3 hours)
   - Remove unreachable states
   - Simplify state transitions
   - Merge equivalent states

2. **Constant Propagation** (3 hours)
   - Propagate constants across states
   - Evaluate constant expressions
   - Reduce state size

3. **Tests** (2 hours)
   - Test optimization correctness
   - Test performance improvements
   - Verify semantics preservation

**Files:**
- `src/compiler/hir/async_optimize.spl` (NEW, ~150 lines)
- `test/compiler/hir_async_optimize_spec.spl` (NEW, 8 tests)

**Optimizations:**
```simple
# Before:
fn poll(state):
    match state:
        case State0:
            val x = 42  # constant
            (State1(x: x), Pending)
        case State1(x):
            (State1(x: x), Ready(x))

# After:
fn poll(state):
    match state:
        case State0:
            (State1, Pending)  # x eliminated
        case State1:
            (State1, Ready(42))  # constant propagated
```

### Phase 5: Documentation & Testing (Day 5, 8 hours)

**Goal:** Complete documentation and final testing

**Tasks:**

1. **Design Documentation** (3 hours)
   - HIR type system extension
   - Type checking algorithm
   - Optimization passes
   - Error handling

2. **Integration Testing** (3 hours)
   - End-to-end type checking
   - Full pipeline verification
   - Error recovery testing
   - Performance benchmarks

3. **Completion Report** (2 hours)
   - Week 3 summary
   - Test results
   - Performance metrics
   - Known limitations

**Files:**
- `doc/design/async_hir_integration.md` (NEW, ~600 lines)
- `doc/report/grammar_update_week3_complete.md` (NEW, ~800 lines)
- `test/compiler/async_hir_integration_spec.spl` (NEW, 10 tests)

---

## Detailed Implementation

### Future<T> Type Lowering

**Algorithm:**

```simple
fn lower_future_type(ast_type: Type) -> HIRType:
    """Lower Future<T> from AST to HIR.

    Input: Type(kind: Generic("Future", [inner_type]))
    Output: HIRType.Generic("Future", [lowered_inner])
    """
    match ast_type.kind:
        case TypeKind.Generic(name, args):
            if name == "Future":
                # Lower inner type recursively
                val lowered_args = args.map(\t: lower_type(t))
                return HIRType.Generic("Future", lowered_args)
            else:
                # Handle other generics
                ...
        case _:
            # Non-generic types
            lower_type(ast_type)
```

**Type Substitution:**

```simple
# Generic function with Future:
fn fetch<T>(url: text) -> Future<T>:
    ...

# When called with T = User:
fetch<User>(url)  # Returns Future<User>

# HIR representation:
HIRType.Generic("Future", [HIRType.Named("User")])
```

### Async Type Checking

**Validation Rules:**

1. **Return Type:** `async fn f() -> T` must have `T = inferred or unit`
   - Transformed to: `fn f() -> Future<T>`
   - Check: desugared function returns `Future<...>`

2. **State Enum Types:**
   - Each state variant fields must match live variables
   - Future field must be `Future<...>`
   - All states must have same enum type

3. **Poll Function:**
   - Signature: `(StateEnum, Waker) -> (StateEnum, Poll<T>)`
   - Return type T must match async function return
   - State transitions must preserve types

**Type Checking Algorithm:**

```simple
fn check_async_function(func: Function, state_enum: Enum, poll_fn: Function):
    """Validate async function type consistency.

    Checks:
    1. func.return_type == Future<T>
    2. state_enum has correct variant types
    3. poll_fn signature matches
    4. T in poll_fn matches T in func
    """

    # Extract T from Future<T>
    val inner_type = extract_future_inner(func.return_type)

    # Check poll function return type
    val poll_return = poll_fn.return_type  # (StateEnum, Poll<T>)
    val poll_inner = extract_poll_inner(poll_return)

    if inner_type != poll_inner:
        error("Type mismatch: async fn returns Future<{inner_type}>, \
               but poll returns Poll<{poll_inner}>")

    # Check state enum variants
    for variant in state_enum.variants:
        check_variant_types(variant, func)
```

### Error Diagnostics

**Error Catalog:**

| Code | Error | Suggestion |
|------|-------|------------|
| E0701 | Async fn doesn't return Future | Change return type or remove async |
| E0702 | Type mismatch in state field | Check live variable types |
| E0703 | Invalid state transition | State types must match |
| E0704 | Poll function signature wrong | Check (State, Waker) -> (State, Poll<T>) |
| E0705 | Future type parameter mismatch | Inner types must match |

**Error Message Format:**

```
error[E0701]: async function must return Future<T>
  --> src/example.spl:5:20
   |
5  | async fn fetch() -> text:
   |                     ^^^^ expected Future<text>, found text
   |
   = help: async functions automatically wrap return values in Future
   = note: change return type to Future<text>, or remove 'async' keyword
   = suggestion:
   |
5  | fn fetch() -> text:
   |    ~~~~~~~~~~~~
```

### HIR Optimization Passes

**1. Dead State Elimination:**

Identify and remove unreachable states:

```simple
# Before:
enum State:
    State0
    State1
    State2  # Never reached

fn poll(state):
    match state:
        case State0: (State1, Pending)
        case State1: (State1, Ready(...))
        case State2: ...  # Dead code

# After:
enum State:
    State0
    State1

fn poll(state):
    match state:
        case State0: (State1, Pending)
        case State1: (State1, Ready(...))
```

**2. Constant Propagation:**

Propagate constants across state transitions:

```simple
# Before:
case State0:
    val x = 42
    (State1(x: x), Pending)

case State1(x):
    (State1(x: x), Ready(x + 10))

# After:
case State0:
    (State1, Pending)

case State1:
    (State1, Ready(52))  # 42 + 10 computed at compile time
```

**3. State Merging:**

Merge equivalent states:

```simple
# Before:
case State1(a):
    (State2(a: a), Pending)

case State2(a):
    (State2(a: a), Ready(a))

# After: Merge State1 and State2 (both just hold 'a')
case State1(a):
    (State1(a: a), Ready(a))
```

---

## Testing Strategy

### Unit Tests (30 tests)

**Type Lowering (10 tests):**
- Simple Future types
- Nested generics
- Type parameter substitution
- Error cases

**Type Checking (12 tests):**
- Return type validation
- State enum validation
- Poll function validation
- Type consistency checks

**Error Diagnostics (8 tests):**
- Error message content
- Source location accuracy
- Suggestion quality
- Error recovery

### Integration Tests (10 tests)

**End-to-End (6 tests):**
- Full async function compilation
- Type checking in pipeline
- Error reporting
- Generated code correctness

**Optimization (4 tests):**
- Dead state elimination
- Constant propagation
- State merging
- Performance improvements

---

## Performance Targets

### Compilation Time

- Type lowering: < 1ms per Future type
- Type checking: < 5ms per async function
- Optimization: < 10ms per state machine
- Total overhead: < 20ms per async function

### Memory Usage

- HIR type representation: ~100 bytes per Future type
- Type checking state: ~500 bytes per function
- Peak memory: +2x during type checking
- After GC: Same as before

### Code Quality

- Generated HIR should be optimal
- No redundant states
- Constants should be evaluated
- Dead code eliminated

---

## Known Limitations

### 1. Generic Future Types

**Current:** Future<T> where T is concrete
**Not Supported:** Generic async functions with type parameters
**Example:**
```simple
async fn fetch<T>() -> T:  # Not yet supported
    ...
```
**Future:** Generic type parameter tracking

### 2. Complex Control Flow

**Current:** Linear state machines
**Not Supported:** Branches, loops, early returns
**Future:** Control flow graph integration (deferred to later)

### 3. Error Recovery

**Current:** Stop at first error
**Not Supported:** Continue checking after errors
**Future:** Better error recovery and multiple error reporting

---

## Success Metrics

**Code Quality:**
- All functions type-safe
- Clear separation of concerns
- Reusable components

**Test Coverage:**
- 100% pass rate (40 tests)
- Edge cases covered
- Error paths tested

**Performance:**
- No regression vs Week 2
- Optimization measurable
- Memory efficient

**Documentation:**
- Complete design docs
- All functions documented
- Examples provided

---

## Timeline

| Day | Phase | Deliverable | Status |
|-----|-------|-------------|--------|
| 1 | Future Type Lowering | type_lower.spl + tests | ⏳ Planned |
| 2 | Async Type Checking | async_check.spl + tests | ⏳ Planned |
| 3 | Error Diagnostics | async_errors.spl + tests | ⏳ Planned |
| 4 | HIR Optimization | async_optimize.spl + tests | ⏳ Planned |
| 5 | Documentation | Design docs + completion report | ⏳ Planned |

**Total Estimate:** 5 days (40 hours)

---

## Dependencies

**Week 1 Complete:**
- ✅ Parser support for async/await
- ✅ AST representation

**Week 2 Complete:**
- ✅ State machine generation
- ✅ Desugaring pipeline

**External Dependencies:**
- HIR type system (existing)
- Type checker infrastructure (existing)
- Error reporting system (existing)

---

## Risks & Mitigation

**Risk 1: HIR complexity**
- Mitigation: Start simple, add complexity incrementally

**Risk 2: Type system integration**
- Mitigation: Reuse existing generic type infrastructure

**Risk 3: Error message quality**
- Mitigation: User testing, iterate on messages

**Risk 4: Performance**
- Mitigation: Profile early, optimize as needed

---

## Next Steps (Week 4)

After Week 3 completion:
- Performance benchmarking
- Error message polish
- Example programs
- User documentation
- Final testing

---

**Plan Status:** Draft
**Review Date:** 2026-02-07
**Implementation Start:** Ready to begin
