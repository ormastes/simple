# Pattern Analysis Tests
# Tests for exhaustiveness checking and pattern analysis

use spec.*

describe "Exhaustiveness checking":
    it "detects non-exhaustive enum matches":
        enum Color:
            Red
            Green
            Blue

        # This should warn/error - missing Blue case
        # (In compiled mode, exhaustiveness is checked)
        fn match_color(c: Color) -> i64:
            match c:
                Color.Red => 1
                Color.Green => 2
                # Missing Blue - non-exhaustive!
                _ => 0

        result = match_color(Color.Red)
        expect(result).to_equal(1)

    it "accepts exhaustive enum matches":
        enum Status:
            Success
            Failure
            Pending

        fn match_status(s: Status) -> str:
            match s:
                Status.Success => "ok"
                Status.Failure => "fail"
                Status.Pending => "wait"

        result = match_status(Status.Success)
        expect(result).to_equal("ok")

    it "accepts matches with catch-all":
        enum Result:
            Ok(i64)
            Err(str)

        fn handle_result(r: Result) -> i64:
            match r:
                Result.Ok(val) => val
                _ => -1  # Catch-all covers Err

        result = handle_result(Result.Ok(42))
        expect(result).to_equal(42)

    it "handles or-patterns in exhaustiveness":
        enum TrafficLight:
            Red
            Yellow
            Green

        fn can_go(light: TrafficLight) -> bool:
            match light:
                TrafficLight.Red | TrafficLight.Yellow => false
                TrafficLight.Green => true

        expect(can_go(TrafficLight.Green)).to_be_true()
        expect(can_go(TrafficLight.Red)).to_be_false()
