/**
Generator Utilities

Generators are lazy sequences that produce values on demand.
They are created with `generator(\: ...)` and consumed with `next()`.

Basic Generator:
```sdoctest
>>> let gen = generator(\: yield 42)
>>> next(gen)
42
```

Multiple Yields:
```sdoctest
>>> let gen = generator(\: [yield 1, yield 2, yield 3])
>>> let a = next(gen)
>>> let b = next(gen)
>>> let c = next(gen)
>>> a + b + c
6
```

Generator with Captured Variables:
```sdoctest
>>> let base = 100
>>> let gen = generator(\: [yield base, yield (base + 1)])
>>> next(gen) + next(gen)
201
```
*/

/**
Collect all values from a generator into a list

```sdoctest
>>> let gen = generator(\: [yield 1, yield 2, yield 3])
>>> collect(gen)
[1, 2, 3]
```
*/
fn collect(gen) -> List:
    let result = []
    while true:
        let val = next(gen)
        if val == nil:
            break
        result.push(val)
    return result

/**
Take at most n values from a generator

```sdoctest
>>> let gen = generator(\: [yield 1, yield 2, yield 3, yield 4, yield 5])
>>> take(gen, 3)
[1, 2, 3]
```
*/
fn take(gen, n: Int) -> List:
    let result = []
    let i = 0
    while i < n:
        let val = next(gen)
        if val == nil:
            break
        result.push(val)
        i += 1
    return result

/**
Create a generator that yields values from start to end (exclusive)

```sdoctest
>>> let gen = range_gen(0, 5)
>>> collect(gen)
[0, 1, 2, 3, 4]
```
*/
fn range_gen(start: Int, end: Int):
    return generator(\:
        let i = start
        while i < end:
            yield i
            i += 1
    )

/**
Create a generator that maps a function over another generator

```sdoctest
>>> let gen = generator(\: [yield 1, yield 2, yield 3])
>>> let doubled = map_gen(gen, \x: x * 2)
>>> collect(doubled)
[2, 4, 6]
```
*/
fn map_gen(gen, f):
    return generator(\:
        while true:
            let val = next(gen)
            if val == nil:
                break
            yield f(val)
    )

/**
Create a generator that filters values from another generator

```sdoctest
>>> let gen = generator(\: [yield 1, yield 2, yield 3, yield 4])
>>> let evens = filter_gen(gen, \x: x % 2 == 0)
>>> collect(evens)
[2, 4]
```
*/
fn filter_gen(gen, pred):
    return generator(\:
        while true:
            let val = next(gen)
            if val == nil:
                break
            if pred(val):
                yield val
    )

/**
Zip two generators together

```sdoctest
>>> let gen1 = generator(\: [yield 1, yield 2])
>>> let gen2 = generator(\: [yield "a", yield "b"])
>>> collect(zip_gen(gen1, gen2))
[(1, "a"), (2, "b")]
```
*/
fn zip_gen(gen1, gen2):
    return generator(\:
        while true:
            let a = next(gen1)
            let b = next(gen2)
            if a == nil or b == nil:
                break
            yield (a, b)
    )
