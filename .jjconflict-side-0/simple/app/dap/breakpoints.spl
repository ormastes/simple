# Breakpoint Management
# Handles breakpoint storage and verification

import dap.protocol as protocol

# Breakpoint entry with metadata
class BreakpointEntry:
    id: Int
    source_path: String
    line: Int
    condition: Option<String>
    hit_condition: Option<String>
    verified: Bool
    hit_count: Int

    fn new(id: Int, source_path: String, line: Int) -> BreakpointEntry:
        BreakpointEntry(
            id: id,
            source_path: source_path,
            line: line,
            condition: None,
            hit_condition: None,
            verified: true,  # For now, always verify
            hit_count: 0
        )

    fn with_condition(self, condition: String) -> BreakpointEntry:
        BreakpointEntry(
            id: self.id,
            source_path: self.source_path,
            line: self.line,
            condition: Some(condition),
            hit_condition: self.hit_condition,
            verified: self.verified,
            hit_count: self.hit_count
        )

    fn to_protocol_breakpoint(self) -> protocol.Breakpoint:
        protocol.Breakpoint.new(self.id, self.verified, self.line)

# Breakpoint manager
class BreakpointManager:
    breakpoints: Dict<String, List<BreakpointEntry>>  # source_path -> breakpoints
    next_id: Int

    fn new() -> BreakpointManager:
        BreakpointManager(
            breakpoints: {},
            next_id: 1
        )

    # Set breakpoints for a source file
    fn set_breakpoints(self, source_path: String, source_breakpoints: List<protocol.SourceBreakpoint>) -> List<BreakpointEntry>:
        # Clear existing breakpoints for this file
        self.breakpoints.remove(source_path)

        # Create new breakpoint entries
        let mut entries = []

        for source_bp in source_breakpoints:
            let id = self.next_id
            self.next_id = self.next_id + 1

            let mut entry = BreakpointEntry.new(id, source_path, source_bp.line)

            # Add condition if present
            match source_bp.condition:
                case Some(cond):
                    entry = entry.with_condition(cond)
                case None:
                    pass

            entries.push(entry)

        # Store breakpoints
        self.breakpoints[source_path] = entries

        entries

    # Clear all breakpoints for a source file
    fn clear_breakpoints(self, source_path: String):
        self.breakpoints.remove(source_path)

    # Get breakpoints for a source file
    fn get_breakpoints(self, source_path: String) -> List<BreakpointEntry>:
        match self.breakpoints.get(source_path):
            case Some(bps):
                bps
            case None:
                []

    # Check if execution should stop at a line
    fn should_stop_at_line(self, source_path: String, line: Int) -> Option<BreakpointEntry>:
        let breakpoints = self.get_breakpoints(source_path)

        for bp in breakpoints:
            if bp.line == line:
                # TODO: Check condition if present
                # For now, always stop
                return Some(bp)

        None

    # Increment hit count for a breakpoint
    fn increment_hit_count(self, breakpoint_id: Int):
        for (source_path, bps) in self.breakpoints.items():
            for bp in bps:
                if bp.id == breakpoint_id:
                    bp.hit_count = bp.hit_count + 1
                    return

    # Get total breakpoint count
    fn count(self) -> Int:
        let mut total = 0
        for (_, bps) in self.breakpoints.items():
            total = total + bps.len()
        total
