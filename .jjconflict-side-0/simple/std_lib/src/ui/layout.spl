# Layout - Layout Widgets (Column, Row, Stack, Container, Grid)
#
# Provides composable layout widgets using the builder pattern.
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.element.*
use ui.widget.*

# Column - Vertical flex container
pub struct Column:
    children: Array[Box[Widget]]
    spacing: i32
    align: Align
    padding: EdgeInsets

impl Column:
    # Create a new column
    pub fn new() -> Column:
        return Column {
            children: [],
            spacing: 0,
            align: Align::Start,
            padding: EdgeInsets::zero()
        }

    # Set spacing between children
    pub fn spacing(self, px: i32) -> Column:
        self.spacing = px
        return self

    # Set cross-axis alignment
    pub fn align(self, align: Align) -> Column:
        self.align = align
        return self

    # Set padding
    pub fn padding(self, insets: EdgeInsets) -> Column:
        self.padding = insets
        return self

    # Add a child widget
    pub fn child(self, widget: impl Widget) -> Column:
        self.children.push(Box::new(widget))
        return self

    # Add multiple children
    pub fn children(self, widgets: Array[Box[Widget]]) -> Column:
        for widget in widgets:
            self.children.push(widget)
        return self

impl Widget for Column:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Column)
            .with_class("flex flex-col")

        # Apply alignment
        let align_items = match self.align:
            case Align::Start: "flex-start"
            case Align::Center: "center"
            case Align::End: "flex-end"
            case Align::Stretch: "stretch"

        elem = elem
            .with_style("display", "flex")
            .with_style("flex-direction", "column")
            .with_style("align-items", align_items)

        # Apply spacing
        if self.spacing > 0:
            elem = elem.with_style("gap", &f"{self.spacing}px")

        # Apply padding
        if not (self.padding.top == 0 and self.padding.right == 0 and
                self.padding.bottom == 0 and self.padding.left == 0):
            elem = elem.with_style("padding", &self.padding.to_css())

        # Build children
        let mut child_ctx = ctx.with_parent(id)
        for child in &self.children:
            let child_node = child.build(&mut child_ctx)
            elem = elem.with_child(child_node.to_element())

        return WidgetNode::new(elem)

# Row - Horizontal flex container
pub struct Row:
    children: Array[Box[Widget]]
    spacing: i32
    justify: Justify
    align: Align
    padding: EdgeInsets

impl Row:
    # Create a new row
    pub fn new() -> Row:
        return Row {
            children: [],
            spacing: 0,
            justify: Justify::Start,
            align: Align::Center,
            padding: EdgeInsets::zero()
        }

    # Set spacing between children
    pub fn spacing(self, px: i32) -> Row:
        self.spacing = px
        return self

    # Set main-axis justification
    pub fn justify(self, justify: Justify) -> Row:
        self.justify = justify
        return self

    # Set cross-axis alignment
    pub fn align(self, align: Align) -> Row:
        self.align = align
        return self

    # Set padding
    pub fn padding(self, insets: EdgeInsets) -> Row:
        self.padding = insets
        return self

    # Add a child widget
    pub fn child(self, widget: impl Widget) -> Row:
        self.children.push(Box::new(widget))
        return self

    # Add multiple children
    pub fn children(self, widgets: Array[Box[Widget]]) -> Row:
        for widget in widgets:
            self.children.push(widget)
        return self

impl Widget for Row:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Row)
            .with_class("flex flex-row")

        # Apply justification
        let justify_content = match self.justify:
            case Justify::Start: "flex-start"
            case Justify::Center: "center"
            case Justify::End: "flex-end"
            case Justify::SpaceBetween: "space-between"
            case Justify::SpaceAround: "space-around"
            case Justify::SpaceEvenly: "space-evenly"

        # Apply alignment
        let align_items = match self.align:
            case Align::Start: "flex-start"
            case Align::Center: "center"
            case Align::End: "flex-end"
            case Align::Stretch: "stretch"

        elem = elem
            .with_style("display", "flex")
            .with_style("flex-direction", "row")
            .with_style("justify-content", justify_content)
            .with_style("align-items", align_items)

        # Apply spacing
        if self.spacing > 0:
            elem = elem.with_style("gap", &f"{self.spacing}px")

        # Apply padding
        if not (self.padding.top == 0 and self.padding.right == 0 and
                self.padding.bottom == 0 and self.padding.left == 0):
            elem = elem.with_style("padding", &self.padding.to_css())

        # Build children
        let mut child_ctx = ctx.with_parent(id)
        for child in &self.children:
            let child_node = child.build(&mut child_ctx)
            elem = elem.with_child(child_node.to_element())

        return WidgetNode::new(elem)

# Stack - Layered/absolute positioned container
pub struct Stack:
    children: Array[Box[Widget]]
    alignment: Alignment

impl Stack:
    # Create a new stack
    pub fn new() -> Stack:
        return Stack {
            children: [],
            alignment: Alignment::TopLeft
        }

    # Set alignment for children
    pub fn alignment(self, alignment: Alignment) -> Stack:
        self.alignment = alignment
        return self

    # Add a child widget
    pub fn child(self, widget: impl Widget) -> Stack:
        self.children.push(Box::new(widget))
        return self

    # Add multiple children
    pub fn children(self, widgets: Array[Box[Widget]]) -> Stack:
        for widget in widgets:
            self.children.push(widget)
        return self

impl Widget for Stack:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Div)
            .with_class("stack")
            .with_style("position", "relative")

        # Build children with absolute positioning
        let mut child_ctx = ctx.with_parent(id)
        for child in &self.children:
            let child_node = child.build(&mut child_ctx)
            let mut child_elem = child_node.to_element()

            # Apply absolute positioning
            child_elem = child_elem.with_style("position", "absolute")

            # Apply alignment
            match self.alignment:
                case Alignment::TopLeft:
                    child_elem = child_elem
                        .with_style("top", "0")
                        .with_style("left", "0")
                case Alignment::TopCenter:
                    child_elem = child_elem
                        .with_style("top", "0")
                        .with_style("left", "50%")
                        .with_style("transform", "translateX(-50%)")
                case Alignment::TopRight:
                    child_elem = child_elem
                        .with_style("top", "0")
                        .with_style("right", "0")
                case Alignment::CenterLeft:
                    child_elem = child_elem
                        .with_style("top", "50%")
                        .with_style("left", "0")
                        .with_style("transform", "translateY(-50%)")
                case Alignment::Center:
                    child_elem = child_elem
                        .with_style("top", "50%")
                        .with_style("left", "50%")
                        .with_style("transform", "translate(-50%, -50%)")
                case Alignment::CenterRight:
                    child_elem = child_elem
                        .with_style("top", "50%")
                        .with_style("right", "0")
                        .with_style("transform", "translateY(-50%)")
                case Alignment::BottomLeft:
                    child_elem = child_elem
                        .with_style("bottom", "0")
                        .with_style("left", "0")
                case Alignment::BottomCenter:
                    child_elem = child_elem
                        .with_style("bottom", "0")
                        .with_style("left", "50%")
                        .with_style("transform", "translateX(-50%)")
                case Alignment::BottomRight:
                    child_elem = child_elem
                        .with_style("bottom", "0")
                        .with_style("right", "0")

            elem = elem.with_child(child_elem)

        return WidgetNode::new(elem)

# Container - Box with padding, margin, and decoration
pub struct Container:
    child: Option[Box[Widget]]
    padding: EdgeInsets
    margin: EdgeInsets
    width: Option[i32]
    height: Option[i32]
    background_color: Option[Color]
    border_radius: Option[i32]
    border_width: Option[i32]
    border_color: Option[Color]

impl Container:
    # Create a new container
    pub fn new() -> Container:
        return Container {
            child: None,
            padding: EdgeInsets::zero(),
            margin: EdgeInsets::zero(),
            width: None,
            height: None,
            background_color: None,
            border_radius: None,
            border_width: None,
            border_color: None
        }

    # Set child widget
    pub fn child(self, widget: impl Widget) -> Container:
        self.child = Some(Box::new(widget))
        return self

    # Set padding
    pub fn padding(self, insets: EdgeInsets) -> Container:
        self.padding = insets
        return self

    # Set margin
    pub fn margin(self, insets: EdgeInsets) -> Container:
        self.margin = insets
        return self

    # Set width
    pub fn width(self, width: i32) -> Container:
        self.width = Some(width)
        return self

    # Set height
    pub fn height(self, height: i32) -> Container:
        self.height = Some(height)
        return self

    # Set background color
    pub fn background(self, color: Color) -> Container:
        self.background_color = Some(color)
        return self

    # Set border radius
    pub fn border_radius(self, radius: i32) -> Container:
        self.border_radius = Some(radius)
        return self

    # Set border
    pub fn border(self, width: i32, color: Color) -> Container:
        self.border_width = Some(width)
        self.border_color = Some(color)
        return self

impl Widget for Container:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Div)
            .with_class("container")

        # Apply padding
        if not (self.padding.top == 0 and self.padding.right == 0 and
                self.padding.bottom == 0 and self.padding.left == 0):
            elem = elem.with_style("padding", &self.padding.to_css())

        # Apply margin
        if not (self.margin.top == 0 and self.margin.right == 0 and
                self.margin.bottom == 0 and self.margin.left == 0):
            elem = elem.with_style("margin", &self.margin.to_css())

        # Apply width/height
        if let Some(w) = self.width:
            elem = elem.with_style("width", &f"{w}px")
        if let Some(h) = self.height:
            elem = elem.with_style("height", &f"{h}px")

        # Apply background color
        if let Some(color) = &self.background_color:
            elem = elem.with_style("background-color", &color.to_css())

        # Apply border radius
        if let Some(radius) = self.border_radius:
            elem = elem.with_style("border-radius", &f"{radius}px")

        # Apply border
        if let Some(width) = self.border_width:
            if let Some(color) = &self.border_color:
                elem = elem.with_style("border", &f"{width}px solid {color.to_css()}")

        # Build child
        if let Some(child) = &self.child:
            let mut child_ctx = ctx.with_parent(id)
            let child_node = child.build(&mut child_ctx)
            elem = elem.with_child(child_node.to_element())

        return WidgetNode::new(elem)

# Grid - CSS Grid container
pub struct Grid:
    children: Array[Box[Widget]]
    columns: u32
    rows: Option[u32]
    gap: i32
    column_gap: Option[i32]
    row_gap: Option[i32]

impl Grid:
    # Create a new grid with specified columns
    pub fn new(columns: u32) -> Grid:
        return Grid {
            children: [],
            columns: columns,
            rows: None,
            gap: 0,
            column_gap: None,
            row_gap: None
        }

    # Set number of rows
    pub fn rows(self, rows: u32) -> Grid:
        self.rows = Some(rows)
        return self

    # Set gap (both column and row)
    pub fn gap(self, gap: i32) -> Grid:
        self.gap = gap
        return self

    # Set column gap
    pub fn column_gap(self, gap: i32) -> Grid:
        self.column_gap = Some(gap)
        return self

    # Set row gap
    pub fn row_gap(self, gap: i32) -> Grid:
        self.row_gap = Some(gap)
        return self

    # Add a child widget
    pub fn child(self, widget: impl Widget) -> Grid:
        self.children.push(Box::new(widget))
        return self

    # Add multiple children
    pub fn children(self, widgets: Array[Box[Widget]]) -> Grid:
        for widget in widgets:
            self.children.push(widget)
        return self

impl Widget for Grid:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let mut elem = Element::new(id, ElementKind::Grid)
            .with_class("grid")
            .with_style("display", "grid")
            .with_style("grid-template-columns", &f"repeat({self.columns}, 1fr)")

        # Apply rows if specified
        if let Some(rows) = self.rows:
            elem = elem.with_style("grid-template-rows", &f"repeat({rows}, 1fr)")

        # Apply gap
        let col_gap = self.column_gap.unwrap_or(self.gap)
        let row_gap = self.row_gap.unwrap_or(self.gap)

        if col_gap > 0:
            elem = elem.with_style("column-gap", &f"{col_gap}px")
        if row_gap > 0:
            elem = elem.with_style("row-gap", &f"{row_gap}px")

        # Build children
        let mut child_ctx = ctx.with_parent(id)
        for child in &self.children:
            let child_node = child.build(&mut child_ctx)
            elem = elem.with_child(child_node.to_element())

        return WidgetNode::new(elem)

# Spacer - Flexible space filler
pub struct Spacer:
    flex: f64

impl Spacer:
    # Create a flexible spacer (default flex = 1.0)
    pub fn new() -> Spacer:
        return Spacer { flex: 1.0 }

    # Create a spacer with specific flex value
    pub fn flex(flex: f64) -> Spacer:
        return Spacer { flex: flex }

impl Widget for Spacer:
    fn build(self, ctx: &mut BuildContext) -> WidgetNode:
        let id = ctx.alloc_id()
        let elem = Element::new(id, ElementKind::Div)
            .with_class("spacer")
            .with_style("flex", &f"{self.flex}")

        return WidgetNode::new(elem)
