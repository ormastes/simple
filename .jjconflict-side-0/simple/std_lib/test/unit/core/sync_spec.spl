# Synchronization Primitives Tests
# Tests for Atomic, Mutex, RwLock, and Semaphore

use spec.*
use core.sync.*

describe "Atomic[T]":
    it "provides atomic load and store":
        atom = Atomic(42)
        expect(atom.load()).to_equal(42)

        atom.store(100)
        expect(atom.load()).to_equal(100)

    it "supports atomic swap":
        atom = Atomic(10)
        old = atom.swap(20)

        expect(old).to_equal(10)
        expect(atom.load()).to_equal(20)

    it "supports compare_and_swap":
        atom = Atomic(5)

        # Successful CAS
        success, val = atom.compare_and_swap(5, 10)
        expect(success).to_be_true()
        expect(val).to_equal(5)
        expect(atom.load()).to_equal(10)

        # Failed CAS
        success, val = atom.compare_and_swap(5, 15)
        expect(success).to_be_false()
        expect(val).to_equal(10)
        expect(atom.load()).to_equal(10)

    it "supports fetch_add":
        atom = Atomic(0)

        old = atom.fetch_add(5)
        expect(old).to_equal(0)
        expect(atom.load()).to_equal(5)

        old = atom.fetch_add(3)
        expect(old).to_equal(5)
        expect(atom.load()).to_equal(8)

    it "supports fetch_sub":
        atom = Atomic(10)

        old = atom.fetch_sub(3)
        expect(old).to_equal(10)
        expect(atom.load()).to_equal(7)


describe "Mutex[T]":
    it "provides mutual exclusion":
        mutex = Mutex(42)

        with mutex.lock() as guard:
            expect(guard.value).to_equal(42)
            guard.value = 100

        # Lock should be released

    it "supports try_lock":
        mutex = Mutex(10)

        # First try_lock should succeed
        guard1 = mutex.try_lock()
        expect(guard1).to_be_some()

        # Second try_lock should fail (already locked)
        guard2 = mutex.try_lock()
        expect(guard2).to_be_none()

    it "returns inner value":
        mutex = Mutex(42)
        value = mutex.into_inner()
        expect(value).to_equal(42)


describe "RwLock[T]":
    it "allows multiple readers":
        rwlock = RwLock([1, 2, 3])

        # Multiple read locks can coexist
        guard1 = rwlock.read()
        guard2 = rwlock.read()

        expect(guard1.value).to_equal([1, 2, 3])
        expect(guard2.value).to_equal([1, 2, 3])

    it "provides exclusive write access":
        rwlock = RwLock(0)

        with rwlock.write() as guard:
            guard.value = 42

        with rwlock.read() as guard:
            expect(guard.value).to_equal(42)

    it "supports try_read and try_write":
        rwlock = RwLock(10)

        # try_read should succeed
        read_guard = rwlock.try_read()
        expect(read_guard).to_be_some()

        # try_write should fail (readers present)
        write_guard = rwlock.try_write()
        expect(write_guard).to_be_none()


describe "Semaphore":
    it "limits concurrent access":
        sem = Semaphore(3)

        # Can acquire up to 3 permits
        sem.acquire()
        sem.acquire()
        sem.acquire()

        # Permits should be exhausted
        expect(sem.permits.load()).to_equal(0)

        sem.release()
        expect(sem.permits.load()).to_equal(1)

    it "works as context manager":
        sem = Semaphore(2)

        with sem:
            expect(sem.permits.load()).to_equal(1)

        expect(sem.permits.load()).to_equal(2)
