/-
  Generated_Lookups.lean - Auto-generated Lean lookup functions

  Module: TypeInferenceCompile
  Generated by: verification.lean.auto_gen

  DO NOT EDIT: This file is auto-generated. Changes will be overwritten.
-/

import TypeInferenceCompile.Generated_Types

-- ════════════════════════════════════════════════════════════════
-- Environment Type Aliases
-- ════════════════════════════════════════════════════════════════

-- Type environment mapping class names to definitions
def ClassEnv := List (String × ClassDef)

-- Field environment mapping variable names to types
def FieldEnv := List (String × Ty)

-- Trait environment
def TraitEnv := List (String × TraitDef)

-- Implementation registry
def ImplRegistry := List TraitImpl

-- Binding registry at package scope
def BindingRegistry := List InterfaceBinding

-- ════════════════════════════════════════════════════════════════
-- Class Lookup Functions
-- ════════════════════════════════════════════════════════════════

-- Look up a class definition
def lookupClass (env : ClassEnv) (name : String) : Option ClassDef :=
  env.find? (fun (n, _) => n == name) |>.map (·.2)

-- Look up a field type in a class
def lookupField (cls : ClassDef) (fieldName : String) : Option Ty :=
  cls.fields.find? (fun f => f.name == fieldName) |>.map (·.ty)

-- Look up a method in a class
def lookupMethod (cls : ClassDef) (methodName : String) : Option MethodDef :=
  cls.methods.find? (fun m => m.name == methodName)

-- ════════════════════════════════════════════════════════════════
-- Trait Lookup Functions
-- ════════════════════════════════════════════════════════════════

-- Look up a trait definition
def lookupTrait (env : TraitEnv) (name : String) : Option TraitDef :=
  env.find? (fun (n, _) => n == name) |>.map (·.2)

-- Look up a method in a trait
def lookupTraitMethod (trait : TraitDef) (methodName : String) : Option TraitMethod :=
  trait.methods.find? (fun m => m.name == methodName)

-- Find trait implementation for a given type
def findImpl (registry : ImplRegistry) (traitName : String) (forType : Ty) : Option TraitImpl :=
  registry.find? (fun impl =>
    impl.trait_name == traitName && impl.for_type == forType
  )

-- Check if a type implements a trait
def implementsTrait (registry : ImplRegistry) (ty : Ty) (traitName : String) : Bool :=
  findImpl registry traitName ty |>.isSome

-- Resolve associated type for a trait implementation
def resolveAssocType (impl : TraitImpl) (assocName : String) : Option Ty :=
  impl.assoc_type_bindings.find? (fun a => a.name == assocName) |>.map (·.ty)

-- ════════════════════════════════════════════════════════════════
-- Binding Lookup Functions (Static Polymorphism)
-- ════════════════════════════════════════════════════════════════

-- Look up binding for a trait
def lookupBinding (registry : BindingRegistry) (traitName : String) : Option InterfaceBinding :=
  registry.find? (fun b => b.trait_name == traitName)

-- Check if binding is valid (impl_type actually implements the trait)
def isValidBinding (implRegistry : ImplRegistry) (binding : InterfaceBinding) : Bool :=
  implementsTrait implRegistry binding.impl_type binding.trait_name

-- Check all bindings are valid
def checkBindingsValid (implRegistry : ImplRegistry) (bindings : BindingRegistry) : Bool :=
  bindings.all (fun b => isValidBinding implRegistry b)

-- Get dispatch mode for a trait
-- KEY SEMANTIC: Default is Dynamic, Static only when binding exists
def getDispatchMode (bindings : BindingRegistry) (traitName : String) : DispatchMode :=
  match lookupBinding bindings traitName with
  | some _ => DispatchMode.static
  | none => DispatchMode.dynamic

-- Resolve trait type based on dispatch mode
-- Static: returns bound implementation type
-- Dynamic: returns DynTrait representation
def resolveTraitTypeWithMode (bindings : BindingRegistry) (traitName : String) : Ty × DispatchMode :=
  match lookupBinding bindings traitName with
  | some binding => (binding.impl_type, DispatchMode.static)
  | none => (Ty.named ("dyn " ++ traitName), DispatchMode.dynamic)

-- Resolve trait type through binding
-- If a binding exists, return the bound implementation type
-- Otherwise, return the original trait type (for dynamic dispatch)
def resolveTraitType (bindings : BindingRegistry) (traitName : String) (originalTy : Ty) : Ty :=
  match lookupBinding bindings traitName with
  | some binding => binding.impl_type
  | none => originalTy

-- Resolve method dispatch for static polymorphism
-- Returns: implementation type if binding exists, otherwise none
def resolveDispatch (bindings : BindingRegistry) (implRegistry : ImplRegistry)
    (traitName : String) (_callSiteTy : Ty) : Option Ty :=
  match lookupBinding bindings traitName with
  | some binding =>
      -- bind is always static: monomorphize to the implementation type
      if implementsTrait implRegistry binding.impl_type traitName then
        some binding.impl_type
      else
        none
  | none =>
      -- No binding: cannot use static dispatch
      none

-- Check trait bounds are satisfied
def checkTraitBounds (registry : ImplRegistry) (bounds : List (Ty × String)) : Bool :=
  bounds.all (fun (ty, traitName) =>
    implementsTrait registry ty traitName
  )
