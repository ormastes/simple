/-
  Generated_Theorems.lean - Auto-generated Lean theorems

  Module: TypeInferenceCompile
  Generated by: verification.lean.auto_gen

  DO NOT EDIT: This file is auto-generated. Changes will be overwritten.

  All proofs are complete - NO sorry or axiom.
-/

import Generated_Types
import Generated_Lookups

-- ════════════════════════════════════════════════════════════════
-- Empty Lookup Theorems
-- ════════════════════════════════════════════════════════════════

/-- lookupClass returns None for empty environment -/
theorem lookupClass_empty (name : String) :
    lookupClass [] name = none := rfl

/-- lookupField returns None for empty fields -/
theorem lookupField_empty (cls : ClassDef) (fieldName : String) :
    cls.fields = [] →
    lookupField cls fieldName = none := by
  intro h
  unfold lookupField
  simp [h]

/-- lookupMethod returns None for empty methods -/
theorem lookupMethod_empty (cls : ClassDef) (methodName : String) :
    cls.methods = [] →
    lookupMethod cls methodName = none := by
  intro h
  unfold lookupMethod
  simp [h]

/-- lookupTrait returns None for empty environment -/
theorem lookupTrait_empty (name : String) :
    lookupTrait [] name = none := rfl

/-- lookupTraitMethod returns None for empty methods -/
theorem lookupTraitMethod_empty (trait : TraitDef) (methodName : String) :
    trait.methods = [] →
    lookupTraitMethod trait methodName = none := by
  intro h
  unfold lookupTraitMethod
  simp [h]

/-- findImpl returns None for empty registry -/
theorem findImpl_empty (traitName : String) (forType : Ty) :
    findImpl [] traitName forType = none := rfl

/-- implementsTrait is false for empty registry -/
theorem implementsTrait_empty (ty : Ty) (traitName : String) :
    implementsTrait [] ty traitName = false := rfl

/-- resolveAssocType returns None for empty bindings -/
theorem resolveAssocType_empty (impl : TraitImpl) (assocName : String) :
    impl.assoc_type_bindings = [] →
    resolveAssocType impl assocName = none := by
  intro h
  unfold resolveAssocType
  simp [h]

/-- lookupBinding returns None for empty registry -/
theorem lookupBinding_empty (traitName : String) :
    lookupBinding [] traitName = none := rfl

/-- Empty trait bounds are always satisfied -/
theorem empty_bounds_satisfied (registry : ImplRegistry) :
    checkTraitBounds registry [] = true := rfl

/-- Single bound satisfaction reduces to implementsTrait -/
theorem single_bound_satisfaction (registry : ImplRegistry) (ty : Ty) (traitName : String) :
    checkTraitBounds registry [(ty, traitName)] = implementsTrait registry ty traitName := by
  unfold checkTraitBounds
  simp

-- ════════════════════════════════════════════════════════════════
-- Determinism Theorems
-- ════════════════════════════════════════════════════════════════

/-- lookupClass is deterministic -/
theorem lookupClass_deterministic (env : ClassEnv) (name : String) (c1 c2 : ClassDef) :
    lookupClass env name = some c1 →
    lookupClass env name = some c2 →
    c1 = c2 := by
  intro h1 h2
  rw [h1] at h2
  cases h2
  rfl

/-- lookupField is deterministic -/
theorem lookupField_deterministic (cls : ClassDef) (fieldName : String) (ty1 ty2 : Ty) :
    lookupField cls fieldName = some ty1 →
    lookupField cls fieldName = some ty2 →
    ty1 = ty2 := by
  intro h1 h2
  rw [h1] at h2
  cases h2
  rfl

/-- lookupMethod is deterministic -/
theorem lookupMethod_deterministic (cls : ClassDef) (methodName : String) (m1 m2 : MethodDef) :
    lookupMethod cls methodName = some m1 →
    lookupMethod cls methodName = some m2 →
    m1 = m2 := by
  intro h1 h2
  rw [h1] at h2
  cases h2
  rfl

/-- lookupTrait is deterministic -/
theorem lookupTrait_deterministic (env : TraitEnv) (name : String) (t1 t2 : TraitDef) :
    lookupTrait env name = some t1 →
    lookupTrait env name = some t2 →
    t1 = t2 := by
  intro h1 h2
  rw [h1] at h2
  cases h2
  rfl

/-- lookupTraitMethod is deterministic -/
theorem lookupTraitMethod_deterministic (trait : TraitDef) (methodName : String) (m1 m2 : TraitMethod) :
    lookupTraitMethod trait methodName = some m1 →
    lookupTraitMethod trait methodName = some m2 →
    m1 = m2 := by
  intro h1 h2
  rw [h1] at h2
  cases h2
  rfl

/-- findImpl is deterministic -/
theorem findImpl_deterministic (registry : ImplRegistry) (traitName : String) (forType : Ty) (i1 i2 : TraitImpl) :
    findImpl registry traitName forType = some i1 →
    findImpl registry traitName forType = some i2 →
    i1 = i2 := by
  intro h1 h2
  rw [h1] at h2
  cases h2
  rfl

/-- resolveAssocType is deterministic -/
theorem resolveAssocType_deterministic (impl : TraitImpl) (assocName : String) (ty1 ty2 : Ty) :
    resolveAssocType impl assocName = some ty1 →
    resolveAssocType impl assocName = some ty2 →
    ty1 = ty2 := by
  intro h1 h2
  rw [h1] at h2
  cases h2
  rfl

/-- lookupBinding is deterministic -/
theorem lookupBinding_deterministic (registry : BindingRegistry) (traitName : String) (b1 b2 : InterfaceBinding) :
    lookupBinding registry traitName = some b1 →
    lookupBinding registry traitName = some b2 →
    b1 = b2 := by
  intro h1 h2
  rw [h1] at h2
  cases h2
  rfl

/-- resolveDispatch is deterministic -/
theorem resolveDispatch_deterministic (bindings : BindingRegistry) (implRegistry : ImplRegistry)
    (traitName : String) (ty : Ty) (implTy1 implTy2 : Ty) :
    resolveDispatch bindings implRegistry traitName ty = some implTy1 →
    resolveDispatch bindings implRegistry traitName ty = some implTy2 →
    implTy1 = implTy2 := by
  intro h1 h2
  rw [h1] at h2
  cases h2
  rfl

-- ════════════════════════════════════════════════════════════════
-- Dispatch Mode Theorems
-- ════════════════════════════════════════════════════════════════

/-- Default dispatch is Dynamic -/
theorem default_dispatch_is_dynamic (bindings : BindingRegistry) (traitName : String) :
    lookupBinding bindings traitName = none →
    getDispatchMode bindings traitName = DispatchMode.dynamic := by
  intro h
  unfold getDispatchMode
  rw [h]

/-- Binding implies Static dispatch -/
theorem binding_implies_static (bindings : BindingRegistry) (traitName : String)
    (binding : InterfaceBinding) :
    lookupBinding bindings traitName = some binding →
    getDispatchMode bindings traitName = DispatchMode.static := by
  intro h
  unfold getDispatchMode
  rw [h]

/-- Dispatch mode is deterministic (function of bindings) -/
theorem dispatch_mode_deterministic (bindings : BindingRegistry) (traitName : String) :
    getDispatchMode bindings traitName = getDispatchMode bindings traitName := by
  rfl

/-- Valid bindings imply implementation exists -/
theorem valid_binding_impl_exists (implRegistry : ImplRegistry) (binding : InterfaceBinding) :
    isValidBinding implRegistry binding = true →
    implementsTrait implRegistry binding.impl_type binding.trait_name = true := by
  intro h
  unfold isValidBinding at h
  exact h

-- ════════════════════════════════════════════════════════════════
-- Trait Bound Theorems
-- ════════════════════════════════════════════════════════════════

/-- Trait bound satisfaction for single bound -/
theorem trait_bound_satisfaction (registry : ImplRegistry) (ty : Ty) (traitName : String) :
    implementsTrait registry ty traitName = true →
    checkTraitBounds registry [(ty, traitName)] = true := by
  intro h
  unfold checkTraitBounds
  simp [h]

/-- Nested bounds propagate -/
theorem nested_bounds_propagate (registry : ImplRegistry) (_ty : Ty)
    (innerBounds outerBounds : List (Ty × String)) :
    checkTraitBounds registry innerBounds = true →
    checkTraitBounds registry outerBounds = true →
    checkTraitBounds registry (innerBounds ++ outerBounds) = true := by
  intro h1 h2
  unfold checkTraitBounds at *
  simp [List.all_append, h1, h2]

/-- Conflicting bounds allowed if both satisfied -/
theorem conflicting_bounds_allowed (registry : ImplRegistry) (ty : Ty)
    (trait1 trait2 : String) :
    implementsTrait registry ty trait1 = true →
    implementsTrait registry ty trait2 = true →
    checkTraitBounds registry [(ty, trait1), (ty, trait2)] = true := by
  intro h1 h2
  unfold checkTraitBounds
  simp [h1, h2]
