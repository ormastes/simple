# Divide-and-conquer leak test
# Calls each compilation phase separately with memory markers

extern fn rt_cli_get_args() -> [str]
extern fn rt_process_get_rss_kb() -> i64

use compiler.driver.driver.{CompilerDriver}
use compiler.driver.driver_types.{CompileOptions, CompileOptions__default, CompileMode, CompileResult}

fn print_mem(label: text):
    val rss = rt_process_get_rss_kb()
    val rss_mb = rss / 1024
    print "[MEM] {label}: {rss_mb}MB"

fn main() -> i64:
    print_mem("after imports")

    val options = CompileOptions__default()
    options.input_files = ["/tmp/test_minimal.spl"]
    options.mode = CompileMode.Aot
    options.output_file = Some("/tmp/test_out.cpp")
    options.backend = "c"
    options.verbose = false

    val driver = CompilerDriver__create(options)
    print_mem("after driver create")

    # Phase 1: Load sources
    print "=== Phase 1: Load sources ==="
    if not driver.load_sources_impl():
        print "Phase 1 FAILED"
        return 1
    print_mem("after phase 1")

    # Phase 2: Parse
    print "=== Phase 2: Parse ==="
    if not driver.parse_all_impl():
        print "Phase 2 FAILED"
        return 1
    print_mem("after phase 2")

    # Phase 3: Lower to HIR + resolve + type check
    print "=== Phase 3: HIR lower + resolve ==="
    if not driver.lower_and_check_impl():
        print "Phase 3 FAILED"
        return 1
    print_mem("after phase 3")

    # Phase 4: Monomorphization
    print "=== Phase 4: Monomorphize ==="
    if not driver.monomorphize_impl():
        print "Phase 4 FAILED"
        return 1
    print_mem("after phase 4")

    # Phase 5a: Lower to MIR
    print "=== Phase 5a: MIR lowering ==="
    if not driver.lower_to_mir():
        print "Phase 5a FAILED"
        return 1
    print_mem("after phase 5a MIR")

    # Phase 5b: Borrow check
    print "=== Phase 5b: Borrow check ==="
    if not driver.borrow_check():
        print "Phase 5b FAILED"
        return 1
    print_mem("after phase 5b borrow")

    # Phase 5c: Async processing
    print "=== Phase 5c: Async ==="
    val async_sms = driver.process_async()
    print_mem("after phase 5c async")

    # Phase 5d: MIR optimization
    print "=== Phase 5d: MIR optimization ==="
    val opt_config = driver.get_optimization_config()
    driver.optimize_mir(opt_config)
    print_mem("after phase 5d optimize")

    # Phase 5e: C codegen
    print "=== Phase 5e: C codegen ==="
    val output = "/tmp/test_out.cpp"
    val result = driver.compile_to_c(output)
    print_mem("after phase 5e C codegen")

    match result:
        case CompileResult.Success(_):
            print "SUCCESS"
            0
        case _:
            print "FAILED"
            1
