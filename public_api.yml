# Auto-generated public API specification
# Generated by: smh_coverage --scan-source
# 
# For Integration Tests: public functions on class/struct
# For System Tests: class/struct methods

public_functions:
  simple_common:
    - new
    - is_valid
    - into_inner
    - downgrade(&self) -> WeakPtr
    - upgrade(&self) -> Option
    - alloc(&self, value: T) -> Handle
    - resolve(&self) -> Option
    - get(&self, path: &Path) -> Option
    - insert(&self, path: &Path, module: Arc
    - remove
    - modules(&self) -> Vec
    - cache(&self) -> &ModuleCache
    - load(&self, path: &Path) -> Result
    - load_with_resolver
    - unload
    - reload(&self, path: &Path) -> Result
    - reload_with_resolver
    - borrow_state_valid
    - gc_state_safe
    - gc_state_verify_safe
    - take_exclusive
    - take_shared
    - release_shared
    - release_exclusive
    - gc_allocate
    - gc_borrow
    - gc_release
    - gc_collect_safe
  simple_compiler:
    - lower(module: &Module) -> LowerResult
    - lower_generator
    - lower_async
    - is_async
    - pipeline_safe
    - append_safe(a: Vec
    - wait_detected
    - nogc
    - nogc_append(a: Vec
    - nogc_singleton
    - apply_hybrid_transform
    - needs_hybrid_support(func: &MirFunction, non_compilable: &HashSet
    - new
    - with_contract_mode
    - with_refined_types(mut self, refined_types: &'a std::collections::HashMap
    - with_type_registry
    - contract_mode
    - state
    - lower_module(mut self, hir: &'a HirModule) -> MirLowerResult
    - lower_to_mir(hir: &HirModule) -> MirLowerResult
    - lower_to_mir_with_mode(hir: &HirModule, contract_mode: ContractMode) -> MirLowerResult
    - type_id_to_cranelift
    - type_id_size
    - type_to_cranelift
    - create_isa_and_flags
    - create_host_isa_and_flags
    - with_module(module: M) -> BackendResult
    - with_module_and_target(mut module: M, target: Target) -> BackendResult
    - target
    - declare_runtime_functions
    - ensure_body_stub(&mut self) -> BackendResult
    - declare_functions(&mut self, functions: &[MirFunction]) -> BackendResult
    - compile_function(&mut self, func: &MirFunction) -> BackendResult
    - compile_all_functions(&mut self, mir: &MirModule) -> BackendResult
    - create_body_stub
    - declare_functions
    - build_mir_signature
    - get_func_block_addr
    - get_body_kind(inst: &MirInst) -> Option
    - expand_with_outlined(mir: &MirModule) -> Vec
    - compile_gpu_global_id
    - compile_gpu_local_id
    - compile_gpu_group_id
    - compile_gpu_global_size
    - compile_gpu_local_size
    - compile_gpu_num_groups
    - compile_gpu_barrier
    - compile_gpu_mem_fence
    - compile_gpu_atomic
    - compile_gpu_shared_alloc
    - compile_simple_function
    - compile_binop_function
    - compile_conditional_function
    - compile_instruction
    - compile_function_body
    - native_fs_read(args: &[Value]) -> Result
    - native_fs_write(args: &[Value]) -> Result
    - native_fs_append(args: &[Value]) -> Result
    - native_fs_create_dir(args: &[Value]) -> Result
    - native_fs_remove_file(args: &[Value]) -> Result
    - native_fs_remove_dir(args: &[Value]) -> Result
    - native_fs_rename(args: &[Value]) -> Result
    - native_fs_copy(args: &[Value]) -> Result
    - native_fs_metadata(args: &[Value]) -> Result
    - native_fs_read_dir(args: &[Value]) -> Result
    - native_fs_open(args: &[Value]) -> Result
    - native_file_read(args: &[Value]) -> Result
    - native_file_write(args: &[Value]) -> Result
    - native_file_flush(args: &[Value]) -> Result
    - native_file_seek(args: &[Value]) -> Result
    - native_file_sync(args: &[Value]) -> Result
    - native_file_close(args: &[Value]) -> Result
    - native_stdin(_args: &[Value]) -> Result
    - native_stdout(_args: &[Value]) -> Result
    - native_stderr(_args: &[Value]) -> Result
    - native_is_tty(args: &[Value]) -> Result
    - native_enable_raw_mode(args: &[Value]) -> Result
    - native_enable_raw_mode(_args: &[Value]) -> Result
    - native_disable_raw_mode(args: &[Value]) -> Result
    - native_disable_raw_mode(_args: &[Value]) -> Result
    - native_get_term_size(args: &[Value]) -> Result
    - native_get_term_size(_args: &[Value]) -> Result
    - native_term_write(args: &[Value]) -> Result
    - native_term_read(args: &[Value]) -> Result
    - native_term_read_timeout(args: &[Value]) -> Result
    - native_term_flush(args: &[Value]) -> Result
    - native_term_poll(args: &[Value]) -> Result
    - native_term_poll(_args: &[Value]) -> Result
    - levenshtein_distance
    - find_similar
    - suggest_name
    - format_suggestion
    - create_test_project
    - has_script_statements
    - extract_module_capabilities(module: &Module) -> Option
    - extract_function_effects(module: &Module) -> Vec
    - check_import_compatibility
    - load_module_with_imports
    - load_module_with_imports_validated
    - analyze(mut self) -> Vec
    - table
    - table_mut
    - is_generic_function
    - is_generic_struct
    - is_generic_class
    - get_generic_function(&self, name: &str) -> Option
    - specialize_function_call
    - process_pending
    - monomorphize_module
    - type_uses_param
    - infer_concrete_type(expr: &Expr, type_context: &HashMap
    - ast_type_to_concrete
    - concrete_to_ast_type
    - generate_smf_bytes(return_value: i32, gc: Option
    - generate_smf_bytes_for_target
    - generate_smf_from_object_for_target
    - generate_smf_from_object(object_code: &[u8], gc: Option
    - get_value
    - get_user_id
    - set_active
    - raw_bytes
    - get_name
    - find_value
    - native_tcp_bind_interp(args: &[Value]) -> Result
    - native_tcp_accept_interp(args: &[Value]) -> Result
    - native_tcp_connect_interp(args: &[Value]) -> Result
    - native_tcp_connect_timeout_interp(args: &[Value]) -> Result
    - native_tcp_read_interp(args: &[Value]) -> Result
    - native_tcp_write_interp(args: &[Value]) -> Result
    - native_tcp_flush_interp(args: &[Value]) -> Result
    - native_tcp_shutdown_interp(args: &[Value]) -> Result
    - native_tcp_close_interp(args: &[Value]) -> Result
    - native_tcp_set_nodelay_interp(args: &[Value]) -> Result
    - native_tcp_set_read_timeout_interp(args: &[Value]) -> Result
    - native_tcp_set_write_timeout_interp(args: &[Value]) -> Result
    - native_tcp_get_nodelay_interp(args: &[Value]) -> Result
    - native_tcp_peek_interp(args: &[Value]) -> Result
    - native_udp_bind_interp(args: &[Value]) -> Result
    - native_udp_connect_interp(args: &[Value]) -> Result
    - native_udp_recv_from_interp(args: &[Value]) -> Result
    - native_udp_recv_interp(args: &[Value]) -> Result
    - native_udp_send_to_interp(args: &[Value]) -> Result
    - native_udp_send_interp(args: &[Value]) -> Result
    - native_udp_set_broadcast_interp(args: &[Value]) -> Result
    - native_udp_set_ttl_interp(args: &[Value]) -> Result
    - native_udp_close_interp(args: &[Value]) -> Result
    - native_udp_peek_from_interp(args: &[Value]) -> Result
    - native_udp_peek_interp(args: &[Value]) -> Result
    - native_udp_peer_addr_interp(args: &[Value]) -> Result
    - native_udp_set_multicast_loop_interp(args: &[Value]) -> Result
    - native_udp_set_multicast_ttl_interp(args: &[Value]) -> Result
    - native_udp_set_read_timeout_interp(args: &[Value]) -> Result
    - native_udp_set_write_timeout_interp(args: &[Value]) -> Result
    - native_udp_get_broadcast_interp(args: &[Value]) -> Result
    - native_udp_get_ttl_interp(args: &[Value]) -> Result
    - native_udp_join_multicast_v4_interp(args: &[Value]) -> Result
    - native_udp_leave_multicast_v4_interp(args: &[Value]) -> Result
    - native_udp_join_multicast_v6_interp(args: &[Value]) -> Result
    - native_udp_leave_multicast_v6_interp(args: &[Value]) -> Result
    - native_http_send_interp(args: &[Value]) -> Result
    - analyze_module(items: &[Node]) -> HashMap
    - analyze_function
    - compilable_builtins() -> HashSet
    - is_inlinable
    - register_compiled_fn
    - unregister_compiled_fn
    - is_function_compiled
    - init_interpreter_state
    - clear_interpreter_state
    - call_interp_function(name: &str, args: Vec
    - eval_expr_with_state(expr: &Expr) -> Result
    - set_interp_var
    - get_interp_var(name: &str) -> Option
    - register_expr_for_eval
    - clear_expr_registry
    - init_interpreter_handlers
    - is_blocking_operation
    - is_io_operation
    - is_fs_operation
    - is_net_operation
    - has_side_effects
    - check_async_violation(operation: &str) -> Result
    - check_pure_violation(operation: &str) -> Result
    - check_effect_violations(operation: &str) -> Result
    - set_current_effects(effects: &[Effect]) -> HashSet
    - restore_effects(effects: HashSet
    - has_effect
    - compute
    - value_to_runtime
    - runtime_to_value
    - evaluate_module(items: &[Node]) -> Result
    - init_coverage() -> Arc
    - get_global_coverage() -> Option
    - is_coverage_enabled
    - get_coverage_output_path
    - save_global_coverage() -> Result
  simple_dependency_tracker:
    - effective_visibility
    - effective_visibility_with_glob
    - visibility_meet
    - ancestor_visibility
    - to_file_path
    - to_dir_path
    - resolve
    - well_formed
    - resolve_on_disk(root: &Path, mp: &ModPath) -> std::io::Result
    - is_auto_imported
    - auto_imported_macros
    - glob_import(manifest: &MacroDirManifest, exports: &MacroExports) -> Vec
    - explicit_import(exports: &MacroExports, name: &str) -> Option
    - combine_exports
  simple_driver:
    - analyze_source(path: &Path) -> std::io::Result
    - analyze_source_str(base: &Path, content: &str) -> (Vec
    - current_mtime
    - watch(entry: &Path, verbose: bool) -> Result
    - run_repl
    - run_tests
    - print_summary
    - parse_test_args
    - watch_tests(options: TestOptions) -> Result
    - is_definition_like
    - parse_doctest_text(content: &str, source: impl AsRef
    - parse_markdown_doctests(content: &str, source: impl AsRef
    - parse_spl_doctests(content: &str, source: impl AsRef
    - discover_doctests(path: &Path) -> std::io::Result
    - run_examples(examples: &[DoctestExample]) -> Vec
    - build_source
    - append_to_prelude
    - run_main(module: &LoadedModule) -> Result
    - run_code(code: &str, args: &[String], stdin: &str) -> Result
    - run_jit(code: &str) -> Result
    - discover_tests(test_root: &Path) -> Vec
    - run_test_file
    - run_all_tests(test_root: &Path, filter: Option
  simple_embedded:
    - current_exception
    - in_handler_mode
    - primask
    - critical_section
    - enable
    - disable
    - is_enabled
    - set_pending
    - clear_pending
    - is_pending
    - is_active
    - set_priority
    - get_priority
    - set_system_priority
    - disable_all
    - restore
    - configure
    - enable_interrupt
    - disable_interrupt
    - current
    - reload_value
    - has_wrapped
    - calibration() -> Option
    - configure_frequency(cpu_freq_hz: u32, tick_freq_hz: u32) -> Option
    - delay_cycles
    - in_machine_mode
    - read_mstatus
    - read_mie
    - read_mip
    - read_mcause
    - read_mepc
    - read_mtvec
    - read_cycle
    - read_time
    - read_instret
    - plic() -> Option
    - clint() -> Option
    - delay_us
    - delay_ms
    - heap_stats
    - set_panic_hook
    - generate_intel_hex
    - generate_srec
    - extract_cortex_m_entry(code: &[u8]) -> Option
    - extract_riscv_entry
    - clear
    - push
    - pop(&mut self) -> Option
    - as_slice
    - as_mut_slice
    - extend_from_slice
    - new
    - push(&mut self, value: T) -> Result
    - get(&self, index: usize) -> Option
    - get_mut(&mut self, index: usize) -> Option
    - alloc(&mut self) -> Option
    - free
    - free_count
    - used_count
    - alloc(&mut self, size: usize, align: usize) -> Option
    - alloc_val
    - reset
    - used
    - remaining
  simple_gpu:
    - id
    - len
    - is_empty
    - size_bytes
    - usage
    - upload(&mut self, data: &[T]) -> GpuResult
    - upload_range(&mut self, data: &[T], offset: usize) -> GpuResult
    - download(&self) -> GpuResult
    - download_range(&self, offset: usize, len: usize) -> GpuResult
    - fill
    - copy_from(&mut self, src: &Buffer
    - data
    - data_mut
    - new
    - load
    - store
    - atomic_add
    - parallel_reduce
    - parallel_scan
    - parallel_map
    - analyze_divergence
    - analyze_memory_access
    - get_backend() -> Box
    - get_backend_by_type(backend: GpuBackend) -> Option
    - devices() -> Vec
    - default_device() -> GpuResult
    - gpu_available
    - backend_available
  simple_loader:
    - hash_name
    - apply_relocations
    - default_free(mem: ExecutableMemory) -> std::io::Result
    - check_unix_result(result: i32) -> std::io::Result
    - check_windows_result(result: i32) -> std::io::Result
    - align_size
    - get_page_size
    - new
    - with_capacity
    - len
    - is_empty
    - active_count
    - allocate
    - free
    - get(&self, idx: TableIndex) -> Option
    - get_mut(&mut self, idx: TableIndex) -> Option
    - set
    - iter(&self) -> impl Iterator
    - as_slice
    - as_ptr
    - find_stub() -> Option
    - create_executable
    - settlement_main
    - crc32
    - extract_resource
    - list_resources
    - build_for_targets
    - is_compatible
    - is_native
    - native_target
    - supported_compile_targets() -> Vec
    - supported_execute_targets() -> Vec
  simple_mock_helper:
    - init_test_level
    - init_test_level_named
    - get_test_level
    - try_get_test_level() -> Option
    - get_test_level_name() -> Option
    - assert_test_level
    - assert_mocks_allowed
    - assert_mocks_forbidden
    - validate_test_config
    - init_mocks_for_only
    - init_mocks_for_only_default
    - init_mocks_for_system
    - check_mock_use_from
    - try_check_mock_use_from
    - are_mocks_enabled
    - is_policy_initialized
    - get_allowed_patterns() -> Option
    - load_llvm_cov_export
    - load_public_api_spec
    - compute_class_coverage(cov: &LlvmCovExport, api: &PublicApiSpec) -> Vec
    - print_class_coverage_table(results: &[ClassCoverage], type_filter: Option
    - parse_llvm_cov_export(json: &str) -> anyhow::Result
    - parse_public_api_spec(yaml: &str) -> anyhow::Result
    - print_coverage_summary
    - scan_directory(root: &Path) -> anyhow::Result
    - generate_yaml
    - write_yaml(api: &ScannedApi, path: &Path) -> anyhow::Result
    - merge_with_existing
  simple_native_loader:
    - create_runtime_provider
    - default_runtime_provider() -> Arc
    - static_provider() -> Arc
  simple_parser:
    - new
    - tokenize(&mut self) -> Vec
    - next_token
    - generate
    - with_mode
    - parse(&mut self) -> Result
  simple_pkg:
    - init_project(dir: &Path, name: Option
    - cache_info() -> PkgResult
    - cache_list() -> PkgResult
    - cache_clean() -> PkgResult
    - cache_clean_git() -> PkgResult
    - format_size
    - install_dependencies(dir: &Path) -> PkgResult
    - deps_dir
    - list_installed(project_dir: &Path) -> PkgResult
    - list_dependencies(dir: &Path) -> PkgResult
    - dependency_tree(dir: &Path) -> PkgResult
    - format_tree
    - add_dependency(dir: &Path, name: &str, options: AddOptions) -> PkgResult
    - remove_dependency(dir: &Path, name: &str, dev: bool) -> PkgResult
    - setup_test_project
    - cleanup_test_project
    - setup_with_path_dep
    - setup_two_path_deps
    - setup_transitive_deps
    - update_all(dir: &Path) -> PkgResult
    - update_package(dir: &Path, name: &str) -> PkgResult
    - resolve(manifest: &Manifest, project_dir: &Path) -> PkgResult
  simple_runtime:
    - spawn_actor
    - send_to(id: usize, msg: Message) -> Result
    - join_actor(id: usize) -> Result
    - register_unique_root
    - unregister_unique_root
    - get_unique_roots() -> Vec
    - unique_root_count
    - register_shared_root
    - unregister_shared_root
    - get_shared_roots() -> Vec
    - shared_root_count
    - validate_heap_obj(val: RuntimeValue, expected: HeapObjectType) -> Option
    - get_typed_ptr
    - get_typed_ptr_mut
    - rt_capture_stdout_stop
    - rt_capture_stderr_stop
    - rt_get_captured_stdout
    - rt_get_captured_stderr
    - rt_clear_captured_stdout
    - rt_clear_captured_stderr
    - rt_is_stdout_capturing
    - rt_is_stderr_capturing
    - set_work_item_state
    - get_work_item_state
    - execute_kernel_1d
    - execute_kernel_3d
    - get_device_count() -> CudaResult
    - new
    - resolve
    - reject
    - state
    - is_settled
    - wait(&self) -> Result
    - try_get(&self) -> Option
    - executor
    - configure_async_mode
    - configure_worker_count
    - spawn
    - poll_one
    - poll_all
    - pending_count
    - is_manual_mode
  simple_simd:
    - preferred_width
    - simd_available
    - has_avx
    - has_avx2
    - has_avx512
    - has_fma
    - has_neon
    - process_f32_array
    - process_f32_array_x8
    - dot_product_f32
    - sum_f32
    - max_f32(data: &[f32]) -> Option
    - min_f32(data: &[f32]) -> Option
    - scale_f32
    - add_scalar_f32
    - add_arrays_f32
    - mul_arrays_f32
    - fma_arrays_f32
    - count_greater_than_f32
    - clamp_f32
    - normalize_f32
  simple_type:
    - lean_infer(expr: &LeanExpr) -> Option
    - infer_deterministic
    - infer_simple(expr: &LeanExpr) -> Option
    - to_simple_expr(expr: &Expr) -> Option
    - infer_pure(expr: &Expr) -> Option
    - check(items: &[Node]) -> Result
  simple_ui:
    - hydrate(manifest: &HydrationManifest) -> Result
    - new
    - tokenize(&mut self) -> Vec
    - next_token
    - parse(&mut self) -> Result
    - diff_children
    - diff_text(node_id: NodeId, old: &str, new: &str) -> Option
    - diff_attrs
    - render_to_html
    - serialize_manifest
    - deserialize_manifest(_json: &str) -> Option

types:
  simple_common::AbiVersion:
    methods: [is_compatible_with, from_u32, to_u32]
  simple_common::ActorHandle:
    methods: [new, id, send(&self, msg: Message) -> Result, recv(&self) -> Result, recv_timeout(&self, timeout: std::time::Duration) -> Result, try_recv(&self) -> Result, join(&self) -> Result, is_running, is_joined, inbox_sender(&self) -> mpsc::Sender]
  simple_common::ActorLifecycle:
    methods: [is_running, is_joined, join(&mut self) -> Result]
  simple_common::BorrowState:
    methods: [new, is_valid, to_valid(&self) -> Option, take_exclusive, take_shared, release_exclusive, release_shared]
  simple_common::ConfigEnv:
    methods: [new, from_args, from_env, from_env_with_prefix, get(&self, key: &str) -> Option, get_or, set, contains, remove(&mut self, key: &str) -> Option, get_int(&self, key: &str) -> Option, get_int_or, get_bool(&self, key: &str) -> Option, get_bool_or, keys(&self) -> impl Iterator, iter(&self) -> impl Iterator, len, is_empty, merge, with_env, with_env_prefix, with_args]
  simple_common::GcState:
    methods: [new, is_safe, allocate, borrow, release, collect_safe, counts, live(&self) -> &std::collections::HashSet, borrowed(&self) -> &std::collections::HashSet]
  simple_common::GcStateTracker:
    methods: [new, is_safe, allocate, borrow, release, collect_safe, counts]
  simple_common::GcStateVerify:
    methods: [new, is_safe, allocate, borrow, release, collect_safe]
  simple_common::Handle:
    methods: []
  simple_common::HandlePool:
    methods: []
  simple_common::ManualGc:
    methods: [new, alloc, alloc_shared, alloc_handle, live, collect]
  simple_common::Message:
    methods: []
  simple_common::ModuleCache:
    methods: []
  simple_common::ModuleRegistry:
    methods: []
  simple_common::Nat:
    methods: [new, get, pred, succ, is_zero]
  simple_common::PointerSize:
    methods: []
  simple_common::Shared:
    methods: []
  simple_common::Target:
    methods: [is_host, parse(s: &str) -> Result]
  simple_common::TargetArch:
    methods: []
  simple_common::TargetConfig:
    methods: [is_host]
  simple_common::TargetOS:
    methods: []
  simple_common::TargetParseError:
    methods: []
  simple_common::ThreadSpawner:
    methods: [new]
  simple_common::Unique:
    methods: []
  simple_common::ValidBorrowState:
    methods: [from_state(state: &BorrowState) -> Option, to_state, take_exclusive(self) -> Option, take_shared(self) -> Option, release_exclusive, release_shared, is_unborrowed, is_exclusive, is_shared, shared_count]
  simple_common::WeakPtr:
    methods: []
  simple_compiler::$name:
    methods: [new, from_arc(arc: Arc, inner(&self) -> std::sync::RwLockReadGuard, get_arc(&self) -> Arc]
  simple_compiler::AsyncEffect:
    methods: []
  simple_compiler::AsyncLowering:
    methods: []
  simple_compiler::AsyncState:
    methods: []
  simple_compiler::BackendError:
    methods: []
  simple_compiler::BackendKind:
    methods: [for_target, force_cranelift, force_llvm]
  simple_compiler::BackendSettings:
    methods: [aot, aot_for_target, jit, with_target, with_opt_level]
  simple_compiler::BinOp:
    methods: []
  simple_compiler::BindingStep:
    methods: []
  simple_compiler::BlockBuildError:
    methods: []
  simple_compiler::BlockBuildState:
    methods: [new, is_open, is_sealed, id, instructions, terminator(&self) -> Option]
  simple_compiler::BlockBuilder:
    methods: [new, state, is_open, is_sealed, id, push(&mut self, inst: MirInst) -> Result, seal(&mut self, terminator: Terminator) -> Result, seal_with_jump_if_open, finalize(self) -> Result, finalize_or_unreachable]
  simple_compiler::BlockId:
    methods: []
  simple_compiler::BlockState:
    methods: [is_open, is_sealed]
  simple_compiler::BodyKind:
    methods: []
  simple_compiler::BorrowMutValue:
    methods: [inner_mut(&self) -> std::sync::RwLockWriteGuard]
  simple_compiler::BridgeValue:
    methods: [float, string, symbol, error, as_float]
  simple_compiler::BuiltinClass:
    methods: [from_name(name: &str) -> Option, as_str, matches]
  simple_compiler::BuiltinFunc:
    methods: [effect, from_name(name: &str) -> Option, name]
  simple_compiler::CallSiteAnalyzer:
    methods: []
  simple_compiler::CallTarget:
    methods: [name, effect, is_async, is_nogc, is_net, is_fs, is_unsafe, from_name]
  simple_compiler::CaptureMode:
    methods: []
  simple_compiler::CapturedVar:
    methods: []
  simple_compiler::ChannelValue:
    methods: [new, with_buffer, send(&self, value: Value) -> Result, recv(&self) -> Result, try_recv(&self) -> Option]
  simple_compiler::ChildModule:
    methods: []
  simple_compiler::ClassName:
    methods: [new(name: impl Into, as_str]
  simple_compiler::ClassType:
    methods: [from_name, is_builtin, is_range]
  simple_compiler::Codegen:
    methods: [new() -> CodegenResult, for_target(target: Target) -> CodegenResult, target, compile_module(mut self, mir: &MirModule) -> CodegenResult, get_object_code(self) -> Vec]
  simple_compiler::CodegenBackend:
    methods: []
  simple_compiler::CompilabilityStatus:
    methods: [is_compilable, reasons, merge]
  simple_compiler::CompileError:
    methods: [io(message: impl Into, parse(message: impl Into, semantic(message: impl Into, codegen(message: impl Into, lint(message: impl Into, runtime(message: impl Into, semantic_with_context(message: impl Into, runtime_with_context(message: impl Into, parse_with_context(message: impl Into, io_with_context(message: impl Into, codegen_with_context(message: impl Into, context(&self) -> Option, message, to_diagnostic, format_with_source]
  simple_compiler::CompiledFn:
    methods: []
  simple_compiler::CompiledFnSignature:
    methods: []
  simple_compiler::CompilerPipeline:
    methods: [new() -> Result, with_gc(gc: Arc, with_project(project: ProjectContext) -> Result, with_gc_and_project, set_project, project(&self) -> Option, set_lint_config, lint_config(&self) -> Option, lint_diagnostics, take_lint_diagnostics(&mut self) -> Vec, has_lint_errors, has_lint_warnings, set_contract_mode, contract_mode, compile(&mut self, source_path: &Path, out: &Path) -> Result, compile_with_project_detection, compile_source_to_memory(&mut self, source: &str) -> Result, compile_native(&mut self, source_path: &Path, out: &Path) -> Result, compile_source_to_memory_native, compile_source_to_memory_for_target]
  simple_compiler::ConcreteType:
    methods: []
  simple_compiler::Config::
    methods: []
  simple_compiler::ContractContext:
    methods: []
  simple_compiler::ContractKind:
    methods: []
  simple_compiler::ContractMode:
    methods: [from_str(s: &str) -> Option, as_str, has_rich_diagnostics, checks_all]
  simple_compiler::CoverageCollector:
    methods: [new, new_for_test, record_line, record_function_call, record_ffi_call, merge, save_to_file, load_from_file, stats, lines_for_file(&self, file: &Path) -> Option, is_line_executed, function_call_count, ffi_call_count, has_data, validate_minimum_coverage, was_function_called, was_file_executed, executed_files(&self) -> Vec, called_functions(&self) -> Vec, file_coverage_percentage, summary_report]
  simple_compiler::CoverageStats:
    methods: []
  simple_compiler::DataSectionKind:
    methods: [is_readonly, to_section_type, to_flags]
  simple_compiler::Dimension:
    methods: [base, mul, div, pow, is_dimensionless, from_unit_expr]
  simple_compiler::DirectoryManifest:
    methods: [to_tracker_visibility_manifest, to_tracker_macro_manifest, is_child_public, capabilities_are_subset_of, effective_capabilities(&self, parent: &[Capability]) -> Vec, validate_function_effects]
  simple_compiler::Effect:
    methods: [is_async, is_nogc, is_pure, is_net, is_fs, is_unsafe, to_async, from_ast_effect, name]
  simple_compiler::EffectSet:
    methods: [new, push, is_pipeline_safe, is_nogc, append, append_preserving_safety, append_preserving_nogc, effects, is_empty, is_pure, has_net, has_fs, has_unsafe, effect_kinds(&self) -> Vec, to_async(&self) -> Vec]
  simple_compiler::EnumTypeName:
    methods: [new(name: impl Into, as_str]
  simple_compiler::ErrorContext:
    methods: [new, with_span, with_secondary(mut self, span: Span, label: impl Into, with_file(mut self, file: impl Into, with_source(mut self, source: impl Into, with_code(mut self, code: impl Into, with_note(mut self, note: impl Into, with_help(mut self, help: impl Into]
  simple_compiler::ExecutionMode:
    methods: [is_actor, is_generator, is_context, actor_inbox(&self) -> Option, actor_outbox(&self) -> Option, generator_yields_mut(&mut self) -> Option, take_generator_yields(&mut self) -> Vec, context_object(&self) -> Option]
  simple_compiler::FStringPart:
    methods: []
  simple_compiler::FallbackReason:
    methods: []
  simple_compiler::FieldLayout:
    methods: []
  simple_compiler::FunctionContext:
    methods: [new, add_local, lookup(&self, name: &str) -> Option, is_postcondition_binding, is_error_binding]
  simple_compiler::FutureState:
    methods: []
  simple_compiler::FutureValue:
    methods: [new, resolved, rejected, poll, await_result(&self) -> Result, is_ready, state]
  simple_compiler::GeneratorLowering:
    methods: []
  simple_compiler::GeneratorState:
    methods: []
  simple_compiler::GeneratorValue:
    methods: [new_with_values(values: Vec, next(&self) -> Option, is_done, collect_remaining(&self) -> Vec]
  simple_compiler::GpuAtomicOp:
    methods: []
  simple_compiler::GpuComputeCapability:
    methods: [ptx_version, llvm_cpu]
  simple_compiler::GpuIntrinsicKind:
    methods: []
  simple_compiler::GpuMemoryScope:
    methods: []
  simple_compiler::HirContract:
    methods: [is_empty]
  simple_compiler::HirContractClause:
    methods: []
  simple_compiler::HirExpr:
    methods: [substitute_local, substitute_self_with_result]
  simple_compiler::HirExprKind:
    methods: [substitute_local, substitute_self_with_result]
  simple_compiler::HirFunction:
    methods: [is_public]
  simple_compiler::HirModule:
    methods: [new, get_type_invariant(&self, type_name: &str) -> Option, get_refined_type(&self, type_name: &str) -> Option, check_subtype, check_refinement]
  simple_compiler::HirOverflowBehavior:
    methods: []
  simple_compiler::HirRefinedType:
    methods: [try_const_eval(&self, value: &HirExpr) -> Option]
  simple_compiler::HirStmt:
    methods: []
  simple_compiler::HirType:
    methods: [signed_int, unsigned_int]
  simple_compiler::HirTypeInvariant:
    methods: []
  simple_compiler::HirUnitConstraints:
    methods: []
  simple_compiler::HybridStats:
    methods: [from_module(module: &MirModule, non_compilable: &HashSet]
  simple_compiler::InstrContext:
    methods: []
  simple_compiler::JitCompiler:
    methods: [new() -> JitResult, with_provider(provider: Arc, new_static() -> JitResult, compile_module(&mut self, mir: &MirModule) -> JitResult, get_function_ptr(&self, name: &str) -> Option]
  simple_compiler::LayoutRegistry:
    methods: [new, register, get(&self, type_id: TypeId) -> Option, get_by_name(&self, name: &str) -> Option]
  simple_compiler::LintChecker:
    methods: [new, with_config, diagnostics, take_diagnostics(&mut self) -> Vec, has_errors, has_warnings, check_module]
  simple_compiler::LintConfig:
    methods: [new, set_level, get_level, apply_attributes, child]
  simple_compiler::LintDiagnostic:
    methods: [new, with_suggestion, is_error, is_warning, format]
  simple_compiler::LintLevel:
    methods: [from_str(s: &str) -> Option]
  simple_compiler::LintName:
    methods: [as_str, from_str(s: &str) -> Option, default_level]
  simple_compiler::LlvmBackend:
    methods: [new(target: Target) -> Result, with_coverage, coverage_enabled, target, get_target_triple, pointer_width, create_module(&self, name: &str) -> Result, create_module(&self, _name: &str) -> Result, create_function_signature, get_ir(&self) -> Result, verify(&self) -> Result, compile_function(&self, func: &MirFunction) -> Result, compile_function(&self, _func: &MirFunction) -> Result, emit_object(&self, _module: &MirModule) -> Result]
  simple_compiler::LlvmGpuBackend:
    methods: [new() -> Result, with_compute_capability(cc: GpuComputeCapability) -> Result, with_debug_info, get_target_triple, create_kernel_module(&self, name: &str) -> Result, create_kernel_module(&self, _name: &str) -> Result, create_kernel_function, emit_thread_id, emit_block_id, emit_block_dim, emit_grid_dim, emit_global_id, emit_barrier(&self, builder: &Builder, emit_mem_fence, emit_shared_alloc, get_ir(&self) -> Result, emit_ptx(&self) -> Result, verify(&self) -> Result]
  simple_compiler::LlvmType:
    methods: []
  simple_compiler::LocalKind:
    methods: [is_parameter, is_local]
  simple_compiler::LocalVar:
    methods: [is_mutable]
  simple_compiler::LoopContext:
    methods: []
  simple_compiler::LowerError:
    methods: []
  simple_compiler::Lowerer:
    methods: [new, is_pure_function, lower_module(mut self, ast_module: &Module) -> LowerResult]
  simple_compiler::LowererState:
    methods: [is_idle, is_lowering, try_current_block(&self) -> MirLowerResult, current_block, try_func_mut(&mut self) -> MirLowerResult, try_loop_stack(&self) -> MirLowerResult, try_loop_stack_mut(&mut self) -> MirLowerResult, try_set_current_block(&mut self, block: BlockId) -> MirLowerResult, loop_depth]
  simple_compiler::ManualHandleValue:
    methods: [new, resolve_inner(&self) -> Option]
  simple_compiler::ManualSharedValue:
    methods: [new, inner, into_inner, downgrade(&self) -> ManualWeak]
  simple_compiler::ManualUniqueValue:
    methods: [new, inner, into_inner, inner_mut]
  simple_compiler::ManualWeakValue:
    methods: [new_from_shared, upgrade_inner(&self) -> Option]
  simple_compiler::MatcherValue:
    methods: [matches]
  simple_compiler::MethodLookupResult:
    methods: [is_callable, is_missing_hook]
  simple_compiler::MirBlock:
    methods: [new, from_builder(builder: BlockBuilder) -> Result, is_sealed, effects, is_async, is_nogc]
  simple_compiler::MirFunction:
    methods: [new, new_from_bool, is_public, outlined_name, compute_live_ins(&self) -> HashMap, new_vreg, new_block, block(&self, id: BlockId) -> Option, block_mut(&mut self, id: BlockId) -> Option, retain_reachable_from, effects, is_async, is_nogc]
  simple_compiler::MirInst:
    methods: [is_async, is_nogc, dest(&self) -> Option, uses(&self) -> Vec]
  simple_compiler::MirLiteral:
    methods: []
  simple_compiler::MirLocal:
    methods: [is_arg]
  simple_compiler::MirLowerError:
    methods: []
  simple_compiler::MirLowerer:
    methods: []
  simple_compiler::MirModule:
    methods: [new]
  simple_compiler::MirPattern:
    methods: []
  simple_compiler::MockCallRecord:
    methods: []
  simple_compiler::MockMethodConfig:
    methods: []
  simple_compiler::MockValue:
    methods: [new, new_spy, when_method, with_args(&self, matchers: Vec, returns, returns_once, record_call(&self, method: &str, args: Vec, get_return_value, was_called, call_count, was_called_with, get_calls(&self, method: &str) -> Vec, reset]
  simple_compiler::ModuleResolver:
    methods: [new, single_file, with_features(mut self, features: HashSet, with_profiles(mut self, profiles: HashMap, project_root, source_root, is_feature_enabled, get_profile(&self, name: &str) -> Option, resolve(&self, path: &ModulePath, from_file: &Path) -> ResolveResult, load_manifest(&mut self, dir_path: &Path) -> ResolveResult, load_manifest_with_capability_check, get_exports(&self, resolved: &ResolvedModule) -> ResolveResult, get_common_uses(&self, file_path: &Path) -> Vec, get_auto_imports(&self, _module_path: &ModulePath) -> Vec, record_import, check_circular_dependencies(&self) -> ResolveResult, import_graph, project_symbols_mut, project_symbols, to_tracker_mod_path(path: &ModulePath) -> Option, filter_glob_import, effective_visibility, ancestor_visibility]
  simple_compiler::MonomorphizationTable:
    methods: [new, request_function, request_struct, request_class, has_pending, pop_pending_function(&mut self) -> Option, pop_pending_struct(&mut self) -> Option, pop_pending_class(&mut self) -> Option, mark_processed, add_specialized_function, add_specialized_struct, add_specialized_class, get_specialized_function(&self, key: &SpecializationKey) -> Option, specialized_functions, specialized_structs(&self) -> impl Iterator, specialized_classes(&self) -> impl Iterator]
  simple_compiler::Monomorphizer:
    methods: []
  simple_compiler::NeighborDirection:
    methods: []
  simple_compiler::NogcInstr:
    methods: []
  simple_compiler::OptionVariant:
    methods: [from_name(name: &str) -> Option, as_str]
  simple_compiler::OutlinedBody:
    methods: []
  simple_compiler::ParallelBackend:
    methods: []
  simple_compiler::PatternBinding:
    methods: []
  simple_compiler::PointerKind:
    methods: []
  simple_compiler::ProjectContext:
    methods: [new(root: PathBuf) -> Result, single_file, detect(file_path: &Path) -> Result, is_feature_enabled, get_profile(&self, name: &str) -> Option, main_file, lint_config]
  simple_compiler::ResolvedModule:
    methods: []
  simple_compiler::ResultVariant:
    methods: [from_name(name: &str) -> Option, as_str]
  simple_compiler::RuntimeFuncSpec:
    methods: [build_signature]
  simple_compiler::Signedness:
    methods: [is_signed, is_unsigned]
  simple_compiler::SmfRelocation:
    methods: []
  simple_compiler::SmfSection:
    methods: []
  simple_compiler::SmfSymbol:
    methods: []
  simple_compiler::SmfWriteError:
    methods: []
  simple_compiler::SmfWriter:
    methods: [new, add_string, add_code_section(&mut self, name: &str, code: Vec, add_data_section(&mut self, name: &str, data: Vec, add_rodata_section(&mut self, name: &str, data: Vec, add_mutable_data_section(&mut self, name: &str, data: Vec, add_symbol, add_relocation, write, from_object_code(object_code: &[u8], mir: &MirModule) -> SmfWriteResult]
  simple_compiler::SpecialEnumKind:
    methods: [from_names(enum_name: &str, variant: &str) -> Option, is_option, is_result]
  simple_compiler::SpecialEnumType:
    methods: [from_name(name: &str) -> Option, as_str]
  simple_compiler::SpecializationKey:
    methods: [new(name: impl Into, mangled_name]
  simple_compiler::StructLayout:
    methods: [new, field_offset(&self, index: usize) -> Option, field_offset_by_name(&self, name: &str) -> Option, field_index(&self, name: &str) -> Option]
  simple_compiler::SubtypeResult:
    methods: []
  simple_compiler::Terminator:
    methods: [is_sealed, is_branching, uses(&self) -> Vec, successors(&self) -> Vec]
  simple_compiler::ThreadPoolValue:
    methods: [new]
  simple_compiler::TypeId:
    methods: [is_known, is_unknown]
  simple_compiler::TypeIdAllocator:
    methods: [new, with_start, alloc, peek_next]
  simple_compiler::TypeRegistry:
    methods: [new, register, allocator, register_named, get(&self, id: TypeId) -> Option, get_array_element(&self, id: TypeId) -> Option, lookup(&self, name: &str) -> Option, register_alias, is_snapshot_safe, get_type_name(&self, type_id: TypeId) -> Option]
  simple_compiler::UnaryOp:
    methods: []
  simple_compiler::UnitOverflowBehavior:
    methods: []
  simple_compiler::VReg:
    methods: []
  simple_compiler::Value:
    methods: [as_int(&self) -> Result, as_float(&self) -> Result, to_key_string, truthy, to_display_string, deref_pointer, type_name, matches_type, some, none, ok, err]
  simple_compiler::VariantName:
    methods: [new(name: impl Into, as_str]
  simple_compiler::super::LlvmBackend:
    methods: [map_type(&self, ty: &TypeId) -> Result]
  simple_dependency_tracker::AutoImport:
    methods: [new(from_module: impl Into]
  simple_dependency_tracker::CyclicDependencyError:
    methods: []
  simple_dependency_tracker::DirManifest:
    methods: [new(name: impl Into, is_child_public, is_exported, add_child, add_export]
  simple_dependency_tracker::EffectiveVisibility:
    methods: []
  simple_dependency_tracker::FileKind:
    methods: []
  simple_dependency_tracker::FileSystem:
    methods: [new, from_paths(paths: impl IntoIterator, add_file(&mut self, path: impl Into, exists, from_directory(root: &Path) -> std::io::Result]
  simple_dependency_tracker::ImportEdge:
    methods: []
  simple_dependency_tracker::ImportGraph:
    methods: [new, add_module(&mut self, module: impl Into, add_import(&mut self, from: impl Into, add_use(&mut self, from: impl Into, imports_of(&self, module: &str) -> impl Iterator, imported_by(&self, module: &str) -> Vec, modules(&self) -> impl Iterator, all_edges, check_cycles(&self) -> Result, topological_order(&self) -> Option, transitive_imports(&self, module: &str) -> HashSet]
  simple_dependency_tracker::ImportKind:
    methods: []
  simple_dependency_tracker::MacroDirManifest:
    methods: [new(name: impl Into, add_auto_import]
  simple_dependency_tracker::MacroExports:
    methods: [new, add_non_macro, add_macro, add, is_well_formed]
  simple_dependency_tracker::MacroSymbol:
    methods: [new(module_path: impl Into, value(module_path: impl Into, macro_def(module_path: impl Into]
  simple_dependency_tracker::ModDecl:
    methods: [new(name: impl Into, public(name: impl Into, private(name: impl Into]
  simple_dependency_tracker::ModPath:
    methods: [new(segments: Vec, parse(path: &str) -> Option, segments, is_absolute, without_crate_prefix(&self) -> Option]
  simple_dependency_tracker::ModuleContents:
    methods: [new, add_symbol, symbol_visibility(&self, sym: &SymbolId) -> Option]
  simple_dependency_tracker::ProjectSymbols:
    methods: [new, get_or_create, get(&self, module_path: &str) -> Option, get_mut(&mut self, module_path: &str) -> Option, lookup_qualified(&self, qualified_name: &str) -> Option, module_paths(&self) -> impl Iterator, all_tables(&self) -> impl Iterator]
  simple_dependency_tracker::ResolutionResult:
    methods: []
  simple_dependency_tracker::Segment:
    methods: [new(name: impl Into, name]
  simple_dependency_tracker::SymKind:
    methods: [is_macro]
  simple_dependency_tracker::Symbol:
    methods: [new(name: impl Into, public(name: impl Into, private(name: impl Into]
  simple_dependency_tracker::SymbolConflictError:
    methods: []
  simple_dependency_tracker::SymbolEntry:
    methods: [local, imported, aliased, is_public, with_source_file]
  simple_dependency_tracker::SymbolId:
    methods: [new(name: impl Into]
  simple_dependency_tracker::SymbolKind:
    methods: [is_macro, to_sym_kind]
  simple_dependency_tracker::SymbolTable:
    methods: [new(module_path: impl Into, define(&mut self, entry: SymbolEntry) -> Result, define_or_replace, lookup(&self, name: &str) -> Option, all_symbols(&self) -> impl Iterator, public_symbols(&self) -> impl Iterator, local_symbols(&self) -> impl Iterator, macros(&self) -> impl Iterator, public_non_macros(&self) -> impl Iterator, public_macros(&self) -> impl Iterator, contains, len, is_empty, remove(&mut self, name: &str) -> Option]
  simple_dependency_tracker::Visibility:
    methods: [is_public, is_private]
  simple_driver::BuildCache:
    methods: [load, save, update, get(&self, source: &Path) -> Option, dependents_of(&self, path: &Path) -> Vec]
  simple_driver::BuildEvent:
    methods: []
  simple_driver::BuildMetadata:
    methods: [to_commit_message]
  simple_driver::BuildMode:
    methods: []
  simple_driver::BuildState:
    methods: [new, with_commit, mark_compilation_success, set_test_results, add_event]
  simple_driver::DepInfo:
    methods: []
  simple_driver::DoctestExample:
    methods: []
  simple_driver::DoctestResult:
    methods: []
  simple_driver::DoctestStatus:
    methods: []
  simple_driver::ExecCore:
    methods: [with_gc, with_gc_and_provider(gc: GcRuntime, provider: Arc, new, with_provider(provider: Arc, new_no_gc, new_with_gc_logging, provider(&self) -> &Arc, collect_gc, compile_source(&self, source: &str, out: &Path) -> Result, compile_source_for_target, compile_to_memory(&self, source: &str) -> Result, compile_to_memory_for_target, compile_to_memory_native(&self, source: &str) -> Result, compile_file(&self, path: &Path, out: &Path) -> Result, load_module(&self, path: &Path) -> Result, load_module_from_memory(&self, bytes: &[u8]) -> Result, run_source(&self, source: &str) -> Result, run_source_in_memory(&self, source: &str) -> Result, run_source_native(&self, source: &str) -> Result, run_source_in_memory_native(&self, source: &str) -> Result, run_smf_from_memory(&self, bytes: &[u8]) -> Result, run_smf(&self, path: &Path) -> Result, run_file(&self, path: &Path) -> Result, run_file_interpreted(&self, path: &Path) -> Result]
  simple_driver::Expected:
    methods: []
  simple_driver::Interpreter:
    methods: [new, new_no_gc, run(&self, code: &str, config: RunConfig) -> Result, run_file, run_with_stdin(&self, code: &str, stdin: &str) -> Result, run_simple(&self, code: &str) -> Result, run_in_memory(&self, code: &str) -> Result, run_with_capture(&self, code: &str) -> Result, run_in_memory_with_capture(&self, code: &str) -> Result, runner, gc(&self) -> Option]
  simple_driver::JJConnector:
    methods: [new(repo_root: impl Into, init(&self) -> io::Result, current_commit_id(&self) -> io::Result, describe_with_state(&self, state: &BuildState) -> io::Result, store_state(&self, state: BuildState) -> io::Result, load_current_states(&self) -> io::Result, has_successful_build(&self) -> io::Result, has_all_tests_passing(&self) -> io::Result, repo_root, state_store]
  simple_driver::JjStateManager:
    methods: [new() -> Result, new_with_path(repo_path: PathBuf) -> Result, is_enabled, snapshot_build_success, snapshot_test_success, get_last_working_state(&self) -> Result]
  simple_driver::MessageFormatter:
    methods: [success, failure, progress, info]
  simple_driver::OutputFormat:
    methods: []
  simple_driver::RunConfig:
    methods: []
  simple_driver::RunResult:
    methods: []
  simple_driver::Runner:
    methods: [new, with_gc_runtime, new_no_gc, new_with_gc_logging, gc(&self) -> Arc, gc_runtime(&self) -> Option, run_file(&self, path: &Path) -> Result, run_file_interpreted(&self, path: &Path) -> Result, run_smf(&self, path: &Path) -> Result, run_smf_from_memory(&self, bytes: &[u8]) -> Result, compile_to_smf(&self, source: &str, out: &Path) -> Result, compile_to_smf_for_target, compile_to_memory(&self, source: &str) -> Result, run_source(&self, source: &str) -> Result, run_source_in_memory(&self, source: &str) -> Result, run_source_native(&self, source: &str) -> Result, run_source_in_memory_native(&self, source: &str) -> Result]
  simple_driver::RunningType:
    methods: []
  simple_driver::SimpleTestFile:
    methods: [to_test_name]
  simple_driver::SimpleTestResult:
    methods: [is_success, summary]
  simple_driver::StateStore:
    methods: [new(store_path: impl Into, default_path, init(&self) -> io::Result, store(&self, state: BuildState) -> io::Result, load_all(&self) -> io::Result, load_for_commit(&self, commit_id: &str) -> io::Result, latest(&self) -> io::Result, clear(&self) -> io::Result]
  simple_driver::TestCategory:
    methods: [from_path]
  simple_driver::TestFailure:
    methods: []
  simple_driver::TestFileResult:
    methods: []
  simple_driver::TestLevel:
    methods: []
  simple_driver::TestMetadata:
    methods: [to_commit_message]
  simple_driver::TestOptions:
    methods: []
  simple_driver::TestRunResult:
    methods: [success]
  simple_embedded::Arena:
    methods: []
  simple_embedded::BumpAllocator:
    methods: []
  simple_embedded::Clint:
    methods: [trigger_soft_interrupt, clear_soft_interrupt, soft_interrupt_pending, read_mtime, read_mtimecmp, write_mtimecmp, set_timer, set_timer_us, set_timer_ms, clear_timer, timer_freq, ticks_to_us, us_to_ticks]
  simple_embedded::ClintConfig:
    methods: []
  simple_embedded::CoopScheduler:
    methods: [add_task(&mut self, func: fn() -> bool) -> Option, remove_task, tick, run, active_tasks]
  simple_embedded::CoopTask:
    methods: []
  simple_embedded::CortexM:
    methods: []
  simple_embedded::CriticalSection:
    methods: [enter]
  simple_embedded::EmbeddedArch:
    methods: []
  simple_embedded::EmbeddedRuntime:
    methods: [is_initialized]
  simple_embedded::Exception:
    methods: [from_number(n: u8) -> Option, is_external, to_irq(n: u8) -> Option]
  simple_embedded::Fixed32:
    methods: []
  simple_embedded::HexRecordType:
    methods: []
  simple_embedded::Irq:
    methods: []
  simple_embedded::MemoryLayout:
    methods: []
  simple_embedded::MemoryPool:
    methods: []
  simple_embedded::MemoryRegion:
    methods: []
  simple_embedded::MemorySection:
    methods: []
  simple_embedded::MemoryType:
    methods: []
  simple_embedded::OutputFormat:
    methods: []
  simple_embedded::PanicStrategy:
    methods: []
  simple_embedded::Plic:
    methods: [set_priority, get_priority, is_pending, enable, disable, is_enabled, set_threshold, get_threshold, claim, complete]
  simple_embedded::PlicConfig:
    methods: []
  simple_embedded::Riscv:
    methods: []
  simple_embedded::RuntimeConfig:
    methods: []
  simple_embedded::SettlementHeaderMin:
    methods: [is_valid, from_bytes(bytes: &[u8]) -> Option]
  simple_embedded::StaticBuffer:
    methods: []
  simple_embedded::StaticVec:
    methods: []
  simple_embedded::SysTickConfig:
    methods: []
  simple_embedded::SystemException:
    methods: []
  simple_embedded::TaskId:
    methods: []
  simple_embedded::TaskState:
    methods: []
  simple_embedded::TeardownConfig:
    methods: []
  simple_embedded::TeardownResult:
    methods: []
  simple_embedded::TeardownSection:
    methods: []
  simple_embedded::VariantConfig:
    methods: []
  simple_embedded::VectorTable:
    methods: []
  simple_gpu::AccessPattern:
    methods: []
  simple_gpu::AccessPatternType:
    methods: [efficiency]
  simple_gpu::BankConflict:
    methods: []
  simple_gpu::Buffer:
    methods: []
  simple_gpu::BufferUsage:
    methods: [storage, uniform, staging]
  simple_gpu::CompiledKernel:
    methods: [new, kernel, metadata, is_compiled]
  simple_gpu::Context:
    methods: [new(device: Device) -> GpuResult, default_context() -> GpuResult, device, alloc, alloc_with_usage, alloc_upload, map, compile_kernel(&self, kernel: &Kernel) -> GpuResult, launch, launch_1d, sync(&self) -> GpuResult, execute_software, execute_on_buffers, execute_binary]
  simple_gpu::CudaBackend:
    methods: [new]
  simple_gpu::Device:
    methods: [software, memory_mb, supports_f64, shared_memory_size, supports_atomics]
  simple_gpu::DeviceCapabilities:
    methods: []
  simple_gpu::DivergenceAnalysis:
    methods: [none, has_divergence]
  simple_gpu::DivergentBranch:
    methods: []
  simple_gpu::GpuAttribute:
    methods: []
  simple_gpu::GpuBackend:
    methods: [is_available]
  simple_gpu::GpuError:
    methods: []
  simple_gpu::GpuEvent:
    methods: []
  simple_gpu::GpuIntrinsic:
    methods: [name, return_type, is_sync, is_atomic]
  simple_gpu::Kernel:
    methods: [new(name: impl Into, name, add_param, add_storage_buffer, add_uniform_buffer, add_scalar, params, set_source(&mut self, source: impl Into, source(&self) -> Option, set_work_group_size, work_group_size(&self) -> Option, add_shared_memory, shared_memory]
  simple_gpu::KernelMetadata:
    methods: []
  simple_gpu::KernelParam:
    methods: []
  simple_gpu::KernelParamType:
    methods: []
  simple_gpu::MappedBuffer:
    methods: []
  simple_gpu::MemcpyKind:
    methods: []
  simple_gpu::MemoryAnalysis:
    methods: [optimal, is_efficient]
  simple_gpu::MemoryAnalysisConfig:
    methods: []
  simple_gpu::MemoryOrder:
    methods: []
  simple_gpu::MemoryScope:
    methods: []
  simple_gpu::OptimizationHints:
    methods: [compute_bound, memory_bound, reduction]
  simple_gpu::ParallelConfig:
    methods: [with_threads, single_threaded]
  simple_gpu::RocmBackend:
    methods: [new]
  simple_gpu::SharedMemory:
    methods: []
  simple_gpu::SharedMemoryDecl:
    methods: []
  simple_gpu::SoftwareBackend:
    methods: [new]
  simple_gpu::WorkGroupBarrier:
    methods: [new, wait, group_size]
  simple_gpu::WorkGroupExecutor:
    methods: [new, with_config, execute, execute_1d]
  simple_gpu::WorkItemState:
    methods: [new, new_1d, global_id_linear]
  simple_lib::TermNative:
    methods: [load() -> Result, add(&self, a: i64, b: i64) -> Option, strlen(&self, s: &str) -> Option]
  simple_loader::$type:
    methods: [new]
  simple_loader::Arch:
    methods: [from_u8(value: u8) -> Option, from_target_arch, to_target_arch, is_32bit, is_64bit]
  simple_loader::ArchValidator:
    methods: [new, for_target, allow_any_platform, allow_cross_arch, validate_smf, validate_settlement, validate_target, host]
  simple_loader::BuildError:
    methods: []
  simple_loader::BuildOptions:
    methods: [current_arch, executable, settlement_file]
  simple_loader::CiConfig:
    methods: [new, with_target, with_all_64bit, include_tests, to_github_actions]
  simple_loader::CrossCompileError:
    methods: []
  simple_loader::CrossTestResults:
    methods: [new, record_pass, record_fail(&mut self, target: Target, message: impl Into, record_skip(&mut self, target: Target, reason: impl Into, all_passed, passed_count, failed_count, skipped_count, summary, assert_all_passed]
  simple_loader::DependencyEntry:
    methods: []
  simple_loader::ExecutableMemory:
    methods: [as_ptr, as_mut_ptr, size]
  simple_loader::ExportedSymbol:
    methods: []
  simple_loader::FuncTableEntry:
    methods: [is_valid]
  simple_loader::FunctionTable:
    methods: [new, with_capacity, allocate, mark_tombstone, free, get_code_ptr(&self, idx: TableIndex) -> Option, get_entry(&self, idx: TableIndex) -> Option, iter_valid(&self) -> impl Iterator]
  simple_loader::GlobalTable:
    methods: [new, with_capacity, allocate, free, get_data_ptr(&self, idx: TableIndex) -> Option, get_entry(&self, idx: TableIndex) -> Option]
  simple_loader::GlobalTableEntry:
    methods: []
  simple_loader::ImportedSymbol:
    methods: []
  simple_loader::IndirectionTable:
    methods: []
  simple_loader::LinkResult:
    methods: []
  simple_loader::LoadError:
    methods: []
  simple_loader::LoadedModule:
    methods: [get_function, entry_point, is_reloadable, source_hash, exports(&self) -> Vec]
  simple_loader::LoadedNativeLib:
    methods: [from_static, load_shared(name: String, path: &Path) -> Result, load_shared(name: String, _path: &Path) -> Result, load_system(name: String) -> Result, get_symbol(&mut self, name: &str) -> Option, get_symbol(&mut self, _name: &str) -> Option, is_static, is_shared, is_system]
  simple_loader::LoadedPackage:
    methods: []
  simple_loader::LoadedSettlement:
    methods: [entry_point(&self) -> Option, get_function(&self, idx: TableIndex) -> Option, get_global(&self, idx: TableIndex) -> Option]
  simple_loader::ManifestSection:
    methods: [to_bytes(&self) -> Vec, from_bytes(bytes: &[u8]) -> Option]
  simple_loader::ModuleHandle:
    methods: [is_valid, as_usize]
  simple_loader::ModuleLoader:
    methods: [new, load(&self, path: &Path) -> Result, load_with_resolver, load_from_memory(&self, bytes: &[u8]) -> Result, load_from_memory_with_resolver]
  simple_loader::ModuleRegistry:
    methods: [new, load, unload, reload, resolve_symbol(&self, name: &str) -> Option]
  simple_loader::ModuleTableEntry:
    methods: []
  simple_loader::NativeHandle:
    methods: [is_valid, as_usize]
  simple_loader::NativeLibBuilder:
    methods: [new, build(&self) -> Result]
  simple_loader::NativeLibConfig:
    methods: [new(name: impl Into, source(mut self, path: impl Into, sources(mut self, paths: impl IntoIterator, include_dir(mut self, path: impl Into, link(mut self, lib: impl Into, lib_dir(mut self, path: impl Into, cflags(mut self, flags: impl IntoIterator, ldflags(mut self, flags: impl IntoIterator, static_lib, shared_lib, output_dir(mut self, path: impl Into, output_file]
  simple_loader::NativeLibEntry:
    methods: [is_static, is_shared, is_system]
  simple_loader::NativeLibManager:
    methods: [new, add_static, add_shared(&mut self, name: &str, path: &Path) -> Result, add_system(&mut self, name: &str) -> Result, get(&self, handle: NativeHandle) -> Option, get_mut(&mut self, handle: NativeHandle) -> Option, get_by_name(&self, name: &str) -> Option, resolve_symbol(&mut self, name: &str) -> Option, resolve_symbol_in(&mut self, handle: NativeHandle, name: &str) -> Option, len, is_empty, iter(&self) -> impl Iterator]
  simple_loader::NativeLibSpec:
    methods: [name, lib_type]
  simple_loader::PackageError:
    methods: []
  simple_loader::PackageOptions:
    methods: [executable, library]
  simple_loader::PackageReader:
    methods: [new, load, load_from_bytes(&self, bytes: &[u8]) -> Result, load_from_reader, load_trailer, load_manifest]
  simple_loader::PackageTrailer:
    methods: [new, is_valid, has_resources, has_manifest, resources_compressed, has_stdlib, is_standalone, from_bytes(bytes: &[u8]) -> Option, read_from, to_bytes, write_to]
  simple_loader::PackageWriter:
    methods: [new, with_options, build, build_to_file, build_to_vec]
  simple_loader::Platform:
    methods: [from_u8(value: u8) -> Option, from_target_os, to_target_os]
  simple_loader::PosixAllocator:
    methods: []
  simple_loader::Protection:
    methods: [is_readable, is_writable, is_executable]
  simple_loader::RelocationType:
    methods: []
  simple_loader::ResourceEntry:
    methods: []
  simple_loader::SectionType:
    methods: []
  simple_loader::Settlement:
    methods: [new, with_defaults(allocator: Arc, add_module(&mut self, module: &LoadedModule) -> Result, add_module_with_linking, remove_module(&mut self, handle: ModuleHandle) -> Result, resolve_symbol(&mut self, name: &str) -> Option, resolve_symbol_with_index(&self, name: &str) -> Option, get_dependencies(&self, handle: ModuleHandle) -> Vec, get_dependents(&self, handle: ModuleHandle) -> Vec, can_remove, replace_module, linker, linker_mut, get_module(&self, handle: ModuleHandle) -> Option, get_module_by_name(&self, name: &str) -> Option, add_native_lib(&mut self, spec: NativeLibSpec) -> Result, resolve_native_symbol(&mut self, name: &str) -> Option, entry_point(&self) -> Option, get_function(&self, idx: TableIndex) -> Option, get_global(&self, idx: TableIndex) -> Option, code_base, data_base, module_count, function_count, global_count, native_lib_count, is_reloadable, is_executable, code_fragmentation, data_fragmentation, compact(&mut self) -> Result, to_header, modules(&self) -> impl Iterator, code_region_slice, data_region_slice, func_table_slice, global_table_slice, type_table_slice, iter_modules(&self) -> impl Iterator, native_libs, entry_point_indices]
  simple_loader::SettlementBuilder:
    methods: [new, with_options, build_to_file, build_to_vec(&self, settlement: &Settlement) -> Result]
  simple_loader::SettlementConfig:
    methods: []
  simple_loader::SettlementError:
    methods: []
  simple_loader::SettlementHeader:
    methods: [new, is_valid, is_executable, is_reloadable, has_natives, is_compressed, has_debug, from_bytes(bytes: &[u8]) -> Option, to_bytes, read_from, write_to]
  simple_loader::SettlementLinker:
    methods: [new, register_exports, extract_imports(&self, module: &LoadedModule) -> Vec, link_module, create_resolver(&self) -> impl Fn(&str) -> Option, resolve_symbol(&self, name: &str) -> Option, resolve_symbol_with_index(&self, name: &str) -> Option, get_dependents(&self, handle: ModuleHandle) -> Vec, get_dependencies(&self, handle: ModuleHandle) -> Vec, can_remove, unregister_module, update_exports, get_export(&self, name: &str) -> Option, check_dependency_cycle(&self, start: ModuleHandle) -> Option, exports(&self) -> impl Iterator, export_count]
  simple_loader::SettlementModule:
    methods: []
  simple_loader::SlotAllocator:
    methods: [new, base, slot_size, total_slots, free_slots, used_slots, slots_needed, slot_to_addr, addr_to_slot(&self, addr: *const u8) -> Option, is_occupied, allocate(&mut self, slots_needed: usize) -> Option, allocate_bytes(&mut self, size: usize) -> Option, free, get_memory, free_ranges(&self) -> Vec, occupied_ranges(&self) -> Vec, fragmentation, defragment_plan(&self) -> Vec, apply_defragment]
  simple_loader::SlotRange:
    methods: [new, end, contains, overlaps]
  simple_loader::SmfHeader:
    methods: [read, is_executable, is_reloadable, has_debug_info, target_arch(&self) -> Option, target_os(&self) -> Option, is_compatible_arch, new_for_target]
  simple_loader::SmfRelocation:
    methods: []
  simple_loader::SmfSection:
    methods: [name_str, is_executable, is_writable]
  simple_loader::SmfSymbol:
    methods: []
  simple_loader::StartupError:
    methods: []
  simple_loader::StartupLoader:
    methods: [new, with_allocator(allocator: Arc, load, load_from_self() -> Result]
  simple_loader::SymbolBinding:
    methods: []
  simple_loader::SymbolTable:
    methods: [new(symbols: Vec, lookup(&self, name: &str) -> Option, symbol_name, exports(&self) -> impl Iterator]
  simple_loader::SymbolType:
    methods: []
  simple_loader::TableIndex:
    methods: [is_valid, as_usize]
  simple_loader::TargetFixture:
    methods: [new, x86_64_linux, aarch64_linux, x86_64_windows, aarch64_macos, riscv64_linux, all_64bit() -> Vec, mock_smf_header, mock_settlement_header, is_host, can_execute]
  simple_loader::TestMatrix:
    methods: [new, minimal, comprehensive, with_target, with_os, targets, operating_systems, fixtures(&self) -> Vec, iter(&self) -> impl Iterator]
  simple_loader::TestOutcome:
    methods: []
  simple_loader::Toolchain:
    methods: [host, for_target(target: Target) -> Option, is_available, with_sysroot(mut self, sysroot: impl Into, with_cflags(mut self, flags: impl IntoIterator, with_ldflags(mut self, flags: impl IntoIterator, linker]
  simple_loader::ToolchainRegistry:
    methods: [new, register_host, register, detect_available, get(&self, target: Target) -> Option, has_target, available_targets(&self) -> Vec]
  simple_loader::TypeTable:
    methods: [new, with_capacity, allocate, free, get_type_ptr(&self, idx: TableIndex) -> Option, get_layout_hash(&self, idx: TableIndex) -> Option, get_entry(&self, idx: TableIndex) -> Option]
  simple_loader::TypeTableEntry:
    methods: []
  simple_loader::ValidationError:
    methods: []
  simple_loader::ValidationResult:
    methods: [ok, is_ok, is_err, summary]
  simple_loader::ValidationWarning:
    methods: []
  simple_loader::WindowsAllocator:
    methods: []
  simple_mock_helper::ClassCoverage:
    methods: [coverage_percent]
  simple_mock_helper::CoverageAnalyzer:
    methods: [new, from_files, generate_system_report, generate_integration_report, generate_merged_report, generate_all_reports]
  simple_mock_helper::CoverageMetrics:
    methods: [new, add]
  simple_mock_helper::CoverageSource:
    methods: []
  simple_mock_helper::CoverageSummary:
    methods: [from_results, coverage_percent, meets_threshold]
  simple_mock_helper::CoverageType:
    methods: []
  simple_mock_helper::ExtendedCoverageReport:
    methods: [new, meets_threshold, to_json(&self) -> serde_json::Result, write_json]
  simple_mock_helper::ExtendedCoverageSummary:
    methods: []
  simple_mock_helper::FileCoverage:
    methods: []
  simple_mock_helper::FunctionCoverage:
    methods: []
  simple_mock_helper::LlvmCovData:
    methods: []
  simple_mock_helper::LlvmCovExport:
    methods: []
  simple_mock_helper::LlvmFunction:
    methods: []
  simple_mock_helper::MethodCoverage:
    methods: []
  simple_mock_helper::MockCheckResult:
    methods: []
  simple_mock_helper::PublicApiSpec:
    methods: []
  simple_mock_helper::PublicTypeSpec:
    methods: []
  simple_mock_helper::ScannedApi:
    methods: []
  simple_mock_helper::ScannedType:
    methods: []
  simple_mock_helper::TestCheckResult:
    methods: [pass, fail(errors: Vec, expect_pass]
  simple_mock_helper::TestLevel:
    methods: [allows_mocks, hal_only, env_mocks, name]
  simple_mock_helper::TypeCoverage:
    methods: []
  simple_mock_helper::TypeMethodSummary:
    methods: []
  simple_mock_helper::UncoveredItem:
    methods: []
  simple_mock_helper::UncoveredSummary:
    methods: []
  simple_native_loader::ChainedProvider:
    methods: [new, from_providers(providers: Vec, add(&mut self, provider: Arc, add_front(&mut self, provider: Arc, remove(&mut self, index: usize) -> Option, providers(&self) -> &[Arc, is_empty, len, find_provider_for(&self, symbol: &str) -> Option]
  simple_native_loader::DynLoadError:
    methods: []
  simple_native_loader::DynamicSymbolProvider:
    methods: [load(path: &Path) -> Result, load_default() -> Result, default_library_name, library_path, clear_cache]
  simple_native_loader::LoadError:
    methods: []
  simple_native_loader::LoadedModule:
    methods: [get_function, entry_point]
  simple_native_loader::ModuleLoader:
    methods: [new, load(&self, path: &Path) -> Result, load_with_resolver]
  simple_native_loader::RuntimeLoadMode:
    methods: [default_for_profile, with_fallback_paths(paths: Vec]
  simple_native_loader::StaticSymbolProvider:
    methods: [new]
  simple_parser::ActorDef:
    methods: []
  simple_parser::Argument:
    methods: []
  simple_parser::AssignOp:
    methods: []
  simple_parser::AssignmentStmt:
    methods: []
  simple_parser::AssociatedTypeDef:
    methods: []
  simple_parser::AssociatedTypeImpl:
    methods: []
  simple_parser::Attribute:
    methods: []
  simple_parser::AutoImportStmt:
    methods: []
  simple_parser::BinOp:
    methods: []
  simple_parser::BinaryArithmeticOp:
    methods: []
  simple_parser::BinaryArithmeticRule:
    methods: []
  simple_parser::BitfieldConstant:
    methods: []
  simple_parser::BitfieldDef:
    methods: []
  simple_parser::BitfieldField:
    methods: []
  simple_parser::Block:
    methods: []
  simple_parser::BoundsAtom:
    methods: []
  simple_parser::BoundsBlock:
    methods: []
  simple_parser::BoundsCase:
    methods: []
  simple_parser::BoundsKind:
    methods: []
  simple_parser::BoundsPattern:
    methods: []
  simple_parser::BreakStmt:
    methods: []
  simple_parser::Capability:
    methods: [from_name(name: &str) -> Option, name, from_effect(effect: &Effect) -> Option]
  simple_parser::ClassDef:
    methods: [is_snapshot]
  simple_parser::CommonUseStmt:
    methods: []
  simple_parser::CompoundUnitDef:
    methods: []
  simple_parser::ConstStmt:
    methods: []
  simple_parser::ContextStmt:
    methods: []
  simple_parser::ContinueStmt:
    methods: []
  simple_parser::ContractBlock:
    methods: [is_empty, requires, ensures]
  simple_parser::ContractClause:
    methods: []
  simple_parser::Decorator:
    methods: []
  simple_parser::Diagnostic:
    methods: [error(message: impl Into, warning(message: impl Into, with_code(mut self, code: impl Into, with_file(mut self, file: impl Into, with_label(mut self, span: Span, message: impl Into, with_secondary_label(mut self, span: Span, message: impl Into, with_note(mut self, note: impl Into, with_help(mut self, help: impl Into, format, format_plain]
  simple_parser::Diagnostics:
    methods: [new, push, error(&mut self, message: impl Into, warning(&mut self, message: impl Into, has_errors, error_count, warning_count, format, format_multi_file, by_file(&self) -> std::collections::HashMap, for_file(&self, path: &str) -> Vec, iter(&self) -> impl Iterator, is_empty, len]
  simple_parser::DocComment:
    methods: [new]
  simple_parser::DocItem:
    methods: []
  simple_parser::DocItemKind:
    methods: []
  simple_parser::Effect:
    methods: [from_decorator_name(name: &str) -> Option, decorator_name]
  simple_parser::EnumDef:
    methods: []
  simple_parser::EnumVariant:
    methods: []
  simple_parser::ExportUseStmt:
    methods: []
  simple_parser::Expr:
    methods: []
  simple_parser::ExternDef:
    methods: []
  simple_parser::FStringPart:
    methods: []
  simple_parser::FStringToken:
    methods: []
  simple_parser::Field:
    methods: []
  simple_parser::ForStmt:
    methods: []
  simple_parser::FunctionDef:
    methods: [is_pure, is_async, has_io, has_net, has_fs, has_unsafe, has_effects, has_simd_decorator]
  simple_parser::HandlePoolDef:
    methods: []
  simple_parser::IfStmt:
    methods: []
  simple_parser::ImplBlock:
    methods: []
  simple_parser::ImportTarget:
    methods: []
  simple_parser::InvariantBlock:
    methods: []
  simple_parser::Label:
    methods: [primary(span: Span, message: impl Into, secondary(span: Span, message: impl Into]
  simple_parser::LambdaParam:
    methods: []
  simple_parser::LetStmt:
    methods: []
  simple_parser::Lexer:
    methods: []
  simple_parser::LoopStmt:
    methods: []
  simple_parser::MacroArg:
    methods: []
  simple_parser::MacroBody:
    methods: []
  simple_parser::MacroDef:
    methods: []
  simple_parser::MacroInvocation:
    methods: []
  simple_parser::MacroParam:
    methods: []
  simple_parser::MacroPattern:
    methods: []
  simple_parser::MacroToken:
    methods: []
  simple_parser::MatchArm:
    methods: []
  simple_parser::MatchStmt:
    methods: []
  simple_parser::ModDecl:
    methods: []
  simple_parser::Module:
    methods: []
  simple_parser::ModuleDocs:
    methods: [to_markdown, to_html]
  simple_parser::ModulePath:
    methods: [new(segments: Vec]
  simple_parser::MoveMode:
    methods: [is_move]
  simple_parser::Mutability:
    methods: [is_mutable]
  simple_parser::Node:
    methods: []
  simple_parser::NumericSuffix:
    methods: []
  simple_parser::OverflowBehavior:
    methods: []
  simple_parser::Parameter:
    methods: []
  simple_parser::ParseError:
    methods: [syntax_error(message: impl Into, syntax_error_with_span(message: impl Into, unexpected_token, missing_token(expected: impl Into, span(&self) -> Option, to_diagnostic, format_with_source]
  simple_parser::Parser:
    methods: []
  simple_parser::ParserMode:
    methods: []
  simple_parser::Pattern:
    methods: []
  simple_parser::PointerKind:
    methods: []
  simple_parser::RangeBound:
    methods: [is_inclusive, is_exclusive]
  simple_parser::RefinementType:
    methods: []
  simple_parser::ReprType:
    methods: [new, from_str(s: &str) -> Option, to_string]
  simple_parser::RequiresCapabilitiesStmt:
    methods: []
  simple_parser::ReturnStmt:
    methods: []
  simple_parser::SelfMode:
    methods: [should_skip_self]
  simple_parser::Severity:
    methods: [name, color]
  simple_parser::SourceRegistry:
    methods: [new, add(&mut self, path: impl Into, get(&self, path: &str) -> Option, contains, files(&self) -> impl Iterator, len, is_empty]
  simple_parser::Span:
    methods: [new]
  simple_parser::StaticStmt:
    methods: []
  simple_parser::StorageClass:
    methods: [is_shared]
  simple_parser::StructDef:
    methods: [is_snapshot]
  simple_parser::Token:
    methods: [new]
  simple_parser::TokenKind:
    methods: []
  simple_parser::TraitDef:
    methods: []
  simple_parser::Type:
    methods: []
  simple_parser::TypeAliasDef:
    methods: []
  simple_parser::UnaryArithmeticOp:
    methods: []
  simple_parser::UnaryArithmeticRule:
    methods: []
  simple_parser::UnaryOp:
    methods: []
  simple_parser::UnitArithmetic:
    methods: []
  simple_parser::UnitDef:
    methods: []
  simple_parser::UnitExpr:
    methods: []
  simple_parser::UnitFamilyDef:
    methods: []
  simple_parser::UnitReprConstraints:
    methods: []
  simple_parser::UnitVariant:
    methods: []
  simple_parser::UnitWithRepr:
    methods: []
  simple_parser::UseStmt:
    methods: []
  simple_parser::Visibility:
    methods: [is_public]
  simple_parser::WhereBound:
    methods: []
  simple_parser::WhileStmt:
    methods: []
  simple_parser::WithStmt:
    methods: []
  simple_pkg::AddOptions:
    methods: []
  simple_pkg::Cache:
    methods: [new() -> PkgResult, at, default_cache_dir() -> PkgResult, root, git_dir, registry_dir, packages_dir, init(&self) -> PkgResult, git_repo_path, package_path, has_git_repo, has_package, clean(&self) -> PkgResult, clean_git(&self) -> PkgResult, size(&self) -> PkgResult, list_packages(&self) -> PkgResult]
  simple_pkg::CacheInfo:
    methods: []
  simple_pkg::Conflict:
    methods: []
  simple_pkg::Dependency:
    methods: [version, git, path, version_str(&self) -> Option, is_path, is_git, get_path(&self) -> Option, get_git(&self) -> Option]
  simple_pkg::DependencyDetail:
    methods: []
  simple_pkg::DependencyGraph:
    methods: [new, add, get(&self, name: &str) -> Option, contains, package_names(&self) -> impl Iterator, packages(&self) -> impl Iterator, len, is_empty, dependencies(&self, name: &str) -> Option, topological_order(&self) -> PkgResult, has_cycle, transitive_deps(&self, name: &str) -> HashSet, dependents(&self, name: &str) -> Vec]
  simple_pkg::InstallResult:
    methods: []
  simple_pkg::InstalledPackage:
    methods: []
  simple_pkg::LinkType:
    methods: []
  simple_pkg::LinkedPackage:
    methods: []
  simple_pkg::Linker:
    methods: [new, deps_dir, init(&self) -> PkgResult, link_path(&self, name: &str, source_path: &Path) -> PkgResult, link_cached(&self, name: &str, cache_path: &Path) -> PkgResult, unlink(&self, name: &str) -> PkgResult, clean(&self) -> PkgResult, list(&self) -> PkgResult, is_linked]
  simple_pkg::LockFile:
    methods: [load(path: &Path) -> PkgResult, parse(content: &str) -> PkgResult, save(&self, path: &Path) -> PkgResult, find_package(&self, name: &str) -> Option, add_package, remove_package(&mut self, name: &str) -> Option, is_empty, package_names(&self) -> Vec, dependency_graph(&self) -> HashMap]
  simple_pkg::LockedPackage:
    methods: [from_path, from_git(name: &str, version: &str, url: &str, rev: Option, is_path, is_git, get_path(&self) -> Option, get_git_url(&self) -> Option]
  simple_pkg::Manifest:
    methods: [load(path: &Path) -> PkgResult, parse(content: &str) -> PkgResult, save(&self, path: &Path) -> PkgResult, new, add_dependency, remove_dependency(&mut self, name: &str) -> Option, has_dependency]
  simple_pkg::Package:
    methods: []
  simple_pkg::PackageSource:
    methods: []
  simple_pkg::PkgError:
    methods: []
  simple_pkg::RegistryConfig:
    methods: []
  simple_pkg::ResolvedPackage:
    methods: [is_path, is_registry, is_git, absolute_path(&self) -> Option]
  simple_pkg::ResolvedSource:
    methods: []
  simple_pkg::TreeNode:
    methods: []
  simple_pkg::UpdateResult:
    methods: []
  simple_pkg::Version:
    methods: [new, parse(version: &str) -> PkgResult, major, minor, patch]
  simple_pkg::VersionReq:
    methods: [any, parse(req: &str) -> PkgResult, matches, is_any]
  simple_runtime::AsyncMode:
    methods: []
  simple_runtime::ContractViolationKind:
    methods: [from_i64(kind: i64) -> Option, name]
  simple_runtime::CudaDevice:
    methods: [new(ordinal: i32) -> CudaResult, new(_ordinal: i32) -> CudaResult, name, compute_capability, max_threads_per_block, warp_size, load_ptx(&self, ptx: &str) -> CudaResult, load_ptx(&self, _ptx: &str) -> CudaResult, malloc(&self, size: usize) -> CudaResult, malloc(&self, _size: usize) -> CudaResult, synchronize(&self) -> CudaResult]
  simple_runtime::CudaDevicePtr:
    methods: [as_ptr, size, copy_from_host, copy_to_host]
  simple_runtime::CudaError:
    methods: []
  simple_runtime::CudaKernel:
    methods: [name, launch, launch_1d]
  simple_runtime::CudaModule:
    methods: [get_kernel(&mut self, name: &str) -> CudaResult, get_kernel(&mut self, _name: &str) -> CudaResult]
  simple_runtime::FutureExecutor:
    methods: [new, default_executor, set_worker_count, mode, set_mode, start, submit, poll_one, poll_all, pending_count, shutdown]
  simple_runtime::GcLogEvent:
    methods: []
  simple_runtime::GcLogEventKind:
    methods: []
  simple_runtime::GcRuntime:
    methods: [new, with_options(options: GcOptions, log: Option, with_logger, verbose_stdout, heap(&self) -> &Arc, heap_bytes, allocate, collect]
  simple_runtime::GclessAllocator:
    methods: [new]
  simple_runtime::GpuWorkItemState:
    methods: []
  simple_runtime::HeapHeader:
    methods: [new]
  simple_runtime::HeapObjectType:
    methods: []
  simple_runtime::HttpRequestData:
    methods: []
  simple_runtime::IsolatedThreadHandle:
    methods: []
  simple_runtime::NetError:
    methods: []
  simple_runtime::NoGcAllocator:
    methods: [new]
  simple_runtime::Promise:
    methods: []
  simple_runtime::PromiseState:
    methods: []
  simple_runtime::RuntimeActor:
    methods: []
  simple_runtime::RuntimeArray:
    methods: []
  simple_runtime::RuntimeBarrier:
    methods: []
  simple_runtime::RuntimeChannel:
    methods: []
  simple_runtime::RuntimeChannelReceiver:
    methods: []
  simple_runtime::RuntimeChannelSender:
    methods: []
  simple_runtime::RuntimeClosure:
    methods: []
  simple_runtime::RuntimeContractViolation:
    methods: [new(kind: ContractViolationKind, func_name: &str, message: Option, func_name, message(&self) -> Option, format]
  simple_runtime::RuntimeDict:
    methods: []
  simple_runtime::RuntimeEnum:
    methods: []
  simple_runtime::RuntimeFuture:
    methods: []
  simple_runtime::RuntimeGenerator:
    methods: []
  simple_runtime::RuntimeHandle:
    methods: []
  simple_runtime::RuntimeMutex:
    methods: []
  simple_runtime::RuntimeObject:
    methods: []
  simple_runtime::RuntimeRwLock:
    methods: []
  simple_runtime::RuntimeSemaphore:
    methods: []
  simple_runtime::RuntimeShared:
    methods: []
  simple_runtime::RuntimeString:
    methods: []
  simple_runtime::RuntimeTuple:
    methods: []
  simple_runtime::RuntimeUnique:
    methods: []
  simple_runtime::RuntimeValue:
    methods: [from_int, as_int, from_float, as_float, as_heap_ptr, heap_type(self) -> Option, truthy, deep_copy, type_name]
  simple_runtime::RuntimeWeak:
    methods: []
  simple_runtime::ScheduledSpawner:
    methods: [new]
  simple_runtime::Task:
    methods: []
  simple_simd::CraneliftSimdType:
    methods: [from_simd_type(simd_type: &SimdType) -> Option, bit_width]
  simple_simd::F32x4:
    methods: [new, splat, zero, extract, with, load, store, sum, product, min_element, max_element, min, max, abs, sqrt, recip, floor, ceil, round, fma, lt, le, gt, eq, select, shuffle, x, y, z, w, gather, scatter]
  simple_simd::F32x8:
    methods: [new, splat, zero, extract, load, store, sum]
  simple_simd::F64x2:
    methods: [new, splat, zero, extract, load, store, sum, sqrt, abs]
  simple_simd::F64x4:
    methods: []
  simple_simd::I32x4:
    methods: [new, splat, zero, extract, with, load, store, sum, min_element, max_element, min, max, abs, lt, eq, select]
  simple_simd::I32x8:
    methods: []
  simple_simd::I64x2:
    methods: [new, splat, zero, extract, load, store, sum]
  simple_simd::I64x4:
    methods: []
  simple_simd::LaneCount:
    methods: [as_usize]
  simple_simd::Mask32x4:
    methods: [new, all_true, all_false, all, any, none, test]
  simple_simd::Mask32x8:
    methods: []
  simple_simd::SimdElementType:
    methods: [size_bytes, is_float, is_signed]
  simple_simd::SimdFeatures:
    methods: [detect, has_simd, has_256bit, has_512bit, preferred_f32_width, preferred_f64_width, preferred_i32_width]
  simple_simd::SimdInstruction:
    methods: [new, result_type]
  simple_simd::SimdOp:
    methods: []
  simple_simd::SimdType:
    methods: [new(element: SimdElementType, lanes: LaneCount) -> Option, size_bytes]
  simple_type::LeanExpr:
    methods: []
  simple_type::LeanTy:
    methods: []
  simple_type::Substitution:
    methods: [new, get(&self, id: usize) -> Option, insert, compose]
  simple_type::Type:
    methods: [apply_subst, contains_var]
  simple_type::TypeChecker:
    methods: [new, fresh_var, instantiate, generalize, unify(&mut self, t1: &Type, t2: &Type) -> Result, resolve, ast_type_to_type, type_matches_union, types_compatible, infer_expr(&mut self, expr: &Expr) -> Result, check_items(&mut self, items: &[Node]) -> Result]
  simple_type::TypeError:
    methods: []
  simple_type::TypeScheme:
    methods: [mono, poly(vars: Vec]
  simple_ui::Attribute:
    methods: []
  simple_ui::AttributeValue:
    methods: []
  simple_ui::BinOp:
    methods: [precedence]
  simple_ui::Binding:
    methods: []
  simple_ui::BindingInfo:
    methods: []
  simple_ui::BindingType:
    methods: []
  simple_ui::BlockId:
    methods: []
  simple_ui::BorderChars:
    methods: []
  simple_ui::BorderStyle:
    methods: [chars]
  simple_ui::Cell:
    methods: []
  simple_ui::ChildSnapshot:
    methods: []
  simple_ui::ClientBlock:
    methods: []
  simple_ui::ControlNode:
    methods: []
  simple_ui::Element:
    methods: [new]
  simple_ui::EmbedNode:
    methods: []
  simple_ui::EventInfo:
    methods: []
  simple_ui::Expr:
    methods: []
  simple_ui::FillNode:
    methods: []
  simple_ui::ForNode:
    methods: []
  simple_ui::HydrateStrategy:
    methods: [from_str(s: &str) -> Option]
  simple_ui::HydratedState:
    methods: [from_manifest, get(&self, field: &str) -> Option, set]
  simple_ui::HydrationError:
    methods: []
  simple_ui::HydrationManifest:
    methods: [new]
  simple_ui::HydrationResult:
    methods: []
  simple_ui::IfNode:
    methods: []
  simple_ui::InitIR:
    methods: []
  simple_ui::InitInstr:
    methods: []
  simple_ui::Layout:
    methods: []
  simple_ui::LetNode:
    methods: []
  simple_ui::LexerMode:
    methods: []
  simple_ui::NativeWindow:
    methods: [new, resize, width, height, set_pixel, fill_rect, get_framebuffer]
  simple_ui::NodeId:
    methods: [new]
  simple_ui::NodeKind:
    methods: []
  simple_ui::OutputNode:
    methods: []
  simple_ui::ParseError:
    methods: []
  simple_ui::PatchOp:
    methods: []
  simple_ui::PatchOpKind:
    methods: []
  simple_ui::PatchSet:
    methods: [new, push, is_empty, len]
  simple_ui::Reg:
    methods: []
  simple_ui::RenderBlock:
    methods: []
  simple_ui::RenderIR:
    methods: [new, alloc_reg, alloc_block, add_block]
  simple_ui::RenderInstr:
    methods: []
  simple_ui::ScreenBuffer:
    methods: [new, resize, set_cell, get_cell(&self, x: usize, y: usize) -> Option, flush(&mut self, writer: &mut dyn Write) -> io::Result, clear_dirty, mark_all_dirty]
  simple_ui::ServerBlock:
    methods: []
  simple_ui::SlotNode:
    methods: []
  simple_ui::Span:
    methods: [new, merge]
  simple_ui::StateDecl:
    methods: []
  simple_ui::StateField:
    methods: []
  simple_ui::Statement:
    methods: []
  simple_ui::Subtree:
    methods: [new, element(tag: &str, attrs: Vec, text]
  simple_ui::SubtreeKind:
    methods: []
  simple_ui::SubtreeNode:
    methods: [element(tag: &str, attrs: Vec, text, with_id]
  simple_ui::SuiLexer:
    methods: []
  simple_ui::SuiParser:
    methods: []
  simple_ui::SuiTemplate:
    methods: [new]
  simple_ui::SuiToken:
    methods: [new]
  simple_ui::SuiTokenKind:
    methods: [is_block_open, is_block_close, keyword_from_str(s: &str) -> Option]
  simple_ui::TemplateIR:
    methods: [new, alloc_id, add_node]
  simple_ui::TemplateIRNode:
    methods: []
  simple_ui::TemplateKind:
    methods: []
  simple_ui::TemplateNode:
    methods: []
  simple_ui::Terminator:
    methods: []
  simple_ui::TextNode:
    methods: []
  simple_ui::TuiContext:
    methods: [new, alloc_id, focus_next, focus_prev]
  simple_ui::TuiError:
    methods: []
  simple_ui::TuiNode:
    methods: []
  simple_ui::TuiNodeKind:
    methods: []
  simple_ui::TuiRenderer:
    methods: [new, with_theme, init(&mut self) -> Result, cleanup(&mut self) -> Result, render(&mut self, ctx: &TuiContext) -> Result, handle_key]
  simple_ui::TuiTheme:
    methods: []
  simple_ui::TypeExpr:
    methods: []
  simple_ui::UnaryOp:
    methods: []
