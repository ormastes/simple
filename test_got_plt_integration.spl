# GOT/PLT Integration Test
# Tests the complete workflow of building GOT/PLT and integrating with ELF writer

use compiler.backend.native.got_plt_builder.{GotPltBuilder, create_got_section_data, create_plt_section_data}
use compiler.backend.native.elf_writer.{elf_writer_x86_64, elf_add_section, new_got_section, new_plt_section, new_text_section, write_elf64}

print "GOT/PLT Integration Test"
print "========================\n"

# Phase 1: Build GOT/PLT entries for common libc functions
print "Phase 1: Building GOT/PLT entries..."
var builder = GotPltBuilder(
    got_entries: [],
    plt_entries: [],
    got_size: 0,
    plt_size: 0,
    next_got_offset: 0,
    next_plt_index: 0
)

# Add some common libc functions
val printf_idx = builder.add_symbol("printf")
val malloc_idx = builder.add_symbol("malloc")
val free_idx = builder.add_symbol("free")
val memcpy_idx = builder.add_symbol("memcpy")

print "  Added 4 symbols to GOT/PLT"
print "  - printf: PLT index {printf_idx}"
print "  - malloc: PLT index {malloc_idx}"
print "  - free: PLT index {free_idx}"
print "  - memcpy: PLT index {memcpy_idx}"

# Verify deduplication
val printf_idx2 = builder.add_symbol("printf")
if printf_idx2 == printf_idx:
    print "  ✓ Deduplication works (printf reused)"
else:
    print "  ✗ Deduplication failed"

# Phase 2: Generate section data
print "\nPhase 2: Generating section data..."
val got_data = create_got_section_data(builder)
val plt_data = create_plt_section_data(builder)

print "  GOT section: {got_data.len()} bytes (expected: {builder.get_got_size()})"
print "  PLT section: {plt_data.len()} bytes (expected: {builder.get_plt_size() + 16})"  # +16 for PLT[0]

if got_data.len() == builder.get_got_size():
    print "  ✓ GOT size correct"
else:
    print "  ✗ GOT size mismatch"

# PLT includes PLT[0] (16 bytes) + entries
val expected_plt = 16 + builder.get_plt_size()
if plt_data.len() == expected_plt:
    print "  ✓ PLT size correct"
else:
    print "  ✗ PLT size mismatch (got {plt_data.len()}, expected {expected_plt})"

# Phase 3: Create ELF sections
print "\nPhase 3: Creating ELF sections..."
val got_section = new_got_section(got_data)
val plt_section = new_plt_section(plt_data)

print "  ✓ Created .got section ({got_section.name})"
print "  ✓ Created .plt section ({plt_section.name})"

# Phase 4: Build minimal ELF file
print "\nPhase 4: Building ELF file..."
var elf_writer = elf_writer_x86_64()

# Add a minimal .text section (just a ret instruction)
val text_data = [0xc3]  # ret
val text_section = new_text_section(text_data)
elf_writer = elf_add_section(elf_writer, text_section)

# Add GOT and PLT sections
elf_writer = elf_add_section(elf_writer, got_section)
elf_writer = elf_add_section(elf_writer, plt_section)

print "  ✓ Added .text section"
print "  ✓ Added .got section"
print "  ✓ Added .plt section"

# Phase 5: Generate ELF bytes
print "\nPhase 5: Generating ELF binary..."
val elf_bytes = write_elf64(elf_writer)

print "  ELF file size: {elf_bytes.len()} bytes"

# Verify ELF magic number
if elf_bytes.len() >= 4:
    val magic_ok = elf_bytes[0] == 0x7F and elf_bytes[1] == 0x45 and elf_bytes[2] == 0x4C and elf_bytes[3] == 0x46
    if magic_ok:
        print "  ✓ ELF magic number correct"
    else:
        print "  ✗ ELF magic number invalid"
else:
    print "  ✗ ELF file too small"

# Summary
print "\n" + "=" * 50
print "Integration Test Summary"
print "=" * 50
print "GOT entries: {builder.get_got_entries().len()}"
print "PLT entries: {builder.get_plt_entries().len()}"
print "GOT size: {builder.get_got_size()} bytes"
print "PLT size: {builder.get_plt_size()} bytes (entries only)"
print "Total PLT: {plt_data.len()} bytes (including PLT[0])"
print "ELF output: {elf_bytes.len()} bytes"
print "\n✓ All integration tests passed!"
