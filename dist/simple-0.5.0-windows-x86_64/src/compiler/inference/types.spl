# Shared Type Representation
#
# Core type system types shared across compiler, loader, and linker.
# This is the canonical type representation for the inference engine.

# ============================================================================
# Type Variable IDs
# ============================================================================

struct TypeVarId:
    """Unique identifier for a type variable."""
    id: i64

impl TypeVarId:
    fn eq(other: TypeVarId) -> bool:
        self.id == other.id

    fn to_text() -> text:
        "t{self.id}"

struct SkolemId:
    """Rigid type variable (from forall quantification)."""
    id: i64

struct DeferredTypeId:
    """Type deferred to link-time resolution."""
    id: i64

# ============================================================================
# Type
# ============================================================================

enum Type:
    """Unified type representation for inference.

    Used by compiler (compile-time), loader (load-time), and linker (link-time).
    """
    # Primitives
    Int(bits: i32, signed: bool)
    Float(bits: i32)
    Bool
    Str
    Nil
    Unit

    # Inference-related
    Var(id: TypeVarId)                  # Unresolved type variable
    Skolem(id: SkolemId)               # Rigid type variable (from forall)

    # Compound types
    Function(params: [Type], ret: Type)
    Array(elem: Type, size: i64?)
    Tuple(elements: [Type])
    Optional(inner: Type)
    Result(ok: Type, err: Type)

    # User-defined
    Struct(name: text, fields: [Field], type_params: [Type])
    Enum(name: text, variants: [Variant], type_params: [Type])
    Class(name: text, type_params: [Type])

    # Named types
    Named(name: text)                  # Struct/class/enum by name
    Union(types: [Type])              # Union type (T1 | T2)
    Dict(key: Type, value: Type)      # Dict<K, V>

    # References
    Borrow(inner: Type)               # &T
    BorrowMut(inner: Type)            # &mut T

    # Generic
    Generic(base: text, args: [Type])
    TypeParam(name: text)              # Uninstantiated parameter

    # Advanced
    DynTrait(name: text)              # dyn Trait (dynamic dispatch)
    ConstKeySet(keys: [text])         # Compile-time string key set
    DependentKeys(source: text)       # Reference to FString keys
    Constructor(target: text, args: [Type]) # Type constructor
    Simd(lanes: i64, element: Type)   # SIMD vector type

    # Deferred (for link-time inference)
    Deferred(id: DeferredTypeId, constraints: [Constraint], fallback: Type?)

struct Field:
    """Struct/class field."""
    name: text
    ty: Type

struct Variant:
    """Enum variant."""
    name: text
    fields: [Field]

# ============================================================================
# Constraints
# ============================================================================

enum Constraint:
    """Type constraint for deferred resolution."""
    Eq(Type, Type)                     # t1 == t2
    HasField(text, Type)              # type has field with given type
    Callable(params: [Type], ret: Type) # type is callable
    Subtype(sub: Type, super_: Type)  # sub <: super

# ============================================================================
# Type Scheme (Polymorphism)
# ============================================================================

struct TypeScheme:
    """Polymorphic type scheme: forall vars. ty"""
    vars: [TypeVarId]
    ty: Type

impl TypeScheme:
    static fn mono(ty: Type) -> TypeScheme:
        TypeScheme(vars: [], ty: ty)

    static fn poly(vars: [TypeVarId], ty: Type) -> TypeScheme:
        TypeScheme(vars: vars, ty: ty)

    fn is_mono() -> bool:
        self.vars.is_empty()

# ============================================================================
# Type Environment
# ============================================================================

class TypeEnv:
    """Scoped type environment for inference."""
    scopes: [Dict<text, TypeScheme>]

impl TypeEnv:
    static fn empty() -> TypeEnv:
        TypeEnv(scopes: [{}])

    me push_scope():
        self.scopes = self.scopes.push({})

    me pop_scope():
        if self.scopes.len() > 1:
            self.scopes = self.scopes[0:self.scopes.len() - 1]

    me bind(name: text, ty: Type):
        val scope = self.scopes[self.scopes.len() - 1]
        scope[name] = TypeScheme.mono(ty)

    me bind_scheme(name: text, scheme: TypeScheme):
        val scope = self.scopes[self.scopes.len() - 1]
        scope[name] = scheme

    fn lookup(name: text) -> TypeScheme?:
        # Search from innermost scope
        var i = self.scopes.len() - 1
        while i >= 0:
            val scope = self.scopes[i]
            if scope.contains(name):
                return Some(scope[name])
            i = i - 1
        nil

# ============================================================================
# Errors
# ============================================================================

enum UnifyError:
    CannotUnify(Type, Type)
    InfiniteType(TypeVarId, Type)
    ArityMismatch(i64, i64)

enum InferError:
    UnifyError(UnifyError)
    Undefined(text)
    NotCallable(Type)
    FieldNotFound(text, Type)

export Type, TypeVarId, SkolemId, DeferredTypeId
export Field, Variant, Constraint, TypeScheme, TypeEnv
export UnifyError, InferError
