# x86/x86_64 Inline Assembly Backend
#
# Generates x86/x86_64 assembly from inline asm blocks.

use compiler.inline_asm.{InlineAsm, AsmOperand, AsmRegister, AsmOption}
use std.common.target.{TargetArch}

# ===========================================================================
# x86 Register Allocation
# ===========================================================================

class X86RegisterAllocator:
    """Allocates x86 registers for inline assembly."""
    arch: TargetArch
    used_regs: Dict<text, bool>

impl X86RegisterAllocator:
    static fn new(arch: TargetArch) -> X86RegisterAllocator:
        X86RegisterAllocator(
            arch: arch,
            used_regs: {}
        )

    fn allocate_reg(reg: AsmRegister, size: i32) -> text:
        # Map register to appropriate size
        match (reg, size, self.arch):
            # 64-bit registers (x86_64)
            case (AsmRegister.Rax, 8, TargetArch.X86_64): "rax"
            case (AsmRegister.Rbx, 8, TargetArch.X86_64): "rbx"
            case (AsmRegister.Rcx, 8, TargetArch.X86_64): "rcx"
            case (AsmRegister.Rdx, 8, TargetArch.X86_64): "rdx"

            # 32-bit registers
            case (AsmRegister.Rax, 4, _): "eax"
            case (AsmRegister.Rbx, 4, _): "ebx"
            case (AsmRegister.Rcx, 4, _): "ecx"
            case (AsmRegister.Rdx, 4, _): "edx"

            # 16-bit registers
            case (AsmRegister.Rax, 2, _): "ax"
            case (AsmRegister.Rbx, 2, _): "bx"
            case (AsmRegister.Rcx, 2, _): "cx"
            case (AsmRegister.Rdx, 2, _): "dx"

            # 8-bit registers
            case (AsmRegister.Rax, 1, _): "al"
            case (AsmRegister.Rbx, 1, _): "bl"
            case (AsmRegister.Rcx, 1, _): "cx"
            case (AsmRegister.Rdx, 1, _): "dl"

            # Any register - allocate automatically
            case (AsmRegister.Any, sz, _):
                self.allocate_any(sz)

            case _:
                reg.to_string()

    fn allocate_any(size: i32) -> text:
        # Try to allocate a free register
        val candidates = if size == 8:
            ["rax", "rbx", "rcx", "rdx", "rsi", "rdi"]
        elif size == 4:
            ["eax", "ebx", "ecx", "edx", "esi", "edi"]
        elif size == 2:
            ["ax", "bx", "cx", "dx"]
        else:
            ["al", "bl", "cl", "dl"]

        for candidate in candidates:
            if not self.used_regs.contains(candidate):
                self.used_regs[candidate] = true
                return candidate

        # All registers used - return first
        candidates[0]

    fn mark_used(reg: text):
        me.used_regs[reg] = true

# ===========================================================================
# x86 Assembly Generator
# ===========================================================================

class X86AsmGenerator:
    """Generates x86/x86_64 assembly."""
    arch: TargetArch
    allocator: X86RegisterAllocator

impl X86AsmGenerator:
    static fn new(arch: TargetArch) -> X86AsmGenerator:
        X86AsmGenerator(
            arch: arch,
            allocator: X86RegisterAllocator.new(arch)
        )

    fn generate(asm: InlineAsm) -> text:
        var code = ""

        # Add Intel or AT&T syntax directive
        code = code + "  .intel_syntax noprefix\n"

        # Process operands
        var input_regs: [text] = []
        var output_regs: [text] = []

        for operand in asm.operands:
            match operand:
                case AsmOperand.Input(reg, expr):
                    val reg_name = self.allocator.allocate_reg(reg, 8)
                    input_regs.push(reg_name)
                    # TODO: Load expr into reg

                case AsmOperand.Output(reg, var_name):
                    val reg_name = self.allocator.allocate_reg(reg, 8)
                    output_regs.push(reg_name)
                    # TODO: Store reg into var

                case AsmOperand.InOut(reg, expr):
                    val reg_name = self.allocator.allocate_reg(reg, 8)
                    input_regs.push(reg_name)
                    output_regs.push(reg_name)

        # Generate assembly instructions
        for inst in asm.template:
            # Substitute register placeholders
            var line = inst
            for i in 0..input_regs.len():
                line = line.replace("{{i}}", input_regs[i])
            for i in 0..output_regs.len():
                line = line.replace("{{i}}", output_regs[i])

            code = code + "  {line}\n"

        # Add clobber list as comment
        if asm.clobbers.len() > 0:
            val clobbers_str = asm.clobbers.join(", ")
            code = code + "  # clobbers: {clobbers_str}\n"

        # Back to AT&T syntax if needed
        code = code + "  .att_syntax\n"

        code

# ===========================================================================
# x86-Specific Instructions
# ===========================================================================

# Common x86 instruction helpers
fn cli() -> InlineAsm:
    """Clear interrupts (disable interrupts)."""
    var asm = InlineAsm.new(["cli"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn sti() -> InlineAsm:
    """Set interrupts (enable interrupts)."""
    var asm = InlineAsm.new(["sti"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn hlt() -> InlineAsm:
    """Halt processor."""
    var asm = InlineAsm.new(["hlt"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn nop() -> InlineAsm:
    """No operation."""
    InlineAsm.new(["nop"], Span.default())

fn rdmsr(msr: i32) -> InlineAsm:
    """Read model-specific register."""
    var asm = InlineAsm.new(["rdmsr"], Span.default())
    asm.add_option(AsmOption.Volatile)
    # Input: ecx = MSR number
    # Output: edx:eax = MSR value
    asm

fn wrmsr(msr: i32, value: i64) -> InlineAsm:
    """Write model-specific register."""
    var asm = InlineAsm.new(["wrmsr"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn cpuid() -> InlineAsm:
    """CPU identification."""
    var asm = InlineAsm.new(["cpuid"], Span.default())
    asm.add_option(AsmOption.Volatile)
    # Input: eax = function number
    # Output: eax, ebx, ecx, edx = results
    asm.add_clobber("eax")
    asm.add_clobber("ebx")
    asm.add_clobber("ecx")
    asm.add_clobber("edx")
    asm

fn inb(port: i32) -> InlineAsm:
    """Input byte from I/O port."""
    var asm = InlineAsm.new(["in al, dx"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn outb(port: i32, value: i32) -> InlineAsm:
    """Output byte to I/O port."""
    var asm = InlineAsm.new(["out dx, al"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn inw(port: i32) -> InlineAsm:
    """Input word from I/O port."""
    var asm = InlineAsm.new(["in ax, dx"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn outw(port: i32, value: i32) -> InlineAsm:
    """Output word to I/O port."""
    var asm = InlineAsm.new(["out dx, ax"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn inl(port: i32) -> InlineAsm:
    """Input long from I/O port."""
    var asm = InlineAsm.new(["in eax, dx"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn outl(port: i32, value: i32) -> InlineAsm:
    """Output long to I/O port."""
    var asm = InlineAsm.new(["out dx, eax"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

# Memory barriers
fn mfence() -> InlineAsm:
    """Memory fence (full)."""
    InlineAsm.new(["mfence"], Span.default())

fn lfence() -> InlineAsm:
    """Load fence."""
    InlineAsm.new(["lfence"], Span.default())

fn sfence() -> InlineAsm:
    """Store fence."""
    InlineAsm.new(["sfence"], Span.default())

# Atomic operations
fn lock_prefix() -> text:
    "lock"

fn xchg(ptr: text, value: text) -> InlineAsm:
    """Atomic exchange."""
    InlineAsm.new(["lock xchg [{ptr}], {value}"], Span.default())

fn cmpxchg(ptr: text, old: text, new: text) -> InlineAsm:
    """Compare and exchange."""
    InlineAsm.new(["lock cmpxchg [{ptr}], {new}"], Span.default())

# Control register access
fn read_cr0() -> InlineAsm:
    """Read CR0."""
    var asm = InlineAsm.new(["mov rax, cr0"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn write_cr0(value: i64) -> InlineAsm:
    """Write CR0."""
    var asm = InlineAsm.new(["mov cr0, rax"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn read_cr3() -> InlineAsm:
    """Read CR3 (page directory base)."""
    var asm = InlineAsm.new(["mov rax, cr3"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn write_cr3(value: i64) -> InlineAsm:
    """Write CR3 (flush TLB)."""
    var asm = InlineAsm.new(["mov cr3, rax"], Span.default())
    asm.add_option(AsmOption.Volatile)
    asm

fn Span.default() -> Span:
    # TODO: Return proper default span
    Span(file: "", start: 0, end: 0)

# ===========================================================================
# Exports
# ===========================================================================

export X86RegisterAllocator, X86AsmGenerator
export cli, sti, hlt, nop
export rdmsr, wrmsr, cpuid
export inb, outb, inw, outw, inl, outl
export mfence, lfence, sfence
export lock_prefix, xchg, cmpxchg
export read_cr0, write_cr0, read_cr3, write_cr3
