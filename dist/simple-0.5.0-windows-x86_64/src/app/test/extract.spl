#!/usr/bin/env simple
# Extract testable code examples from Category B specs to _spec.spl files
# Keep original .md files as architectural reference
# Migrated from script/build/extract_tests_from_spec.py

use app.io
use app.utils.colors (success, error, warning, info)
use app.utils.parsing (extract_section, split_lines)

export main, extract_tests, extract_all_category_b

# Category B files: Extract examples, keep reference docs
val CATEGORY_B_FILES = [
    ("functions.md", "functions_spec.spl"),
    ("traits.md", "traits_spec.spl"),
    ("memory.md", "memory_spec.spl"),
    ("modules.md", "modules_spec.spl"),
    ("data_structures.md", "data_structures_spec.spl"),
    ("concurrency.md", "concurrency_spec.spl"),
    ("macro.md", "macro_spec.spl"),
    ("metaprogramming.md", "metaprogramming_spec.spl")
]

struct ExtractOptions:
    dry_run: bool
    verbose: bool

struct SpecMetadata:
    title: text
    status: text
    feature_ids: text

struct CodeExample:
    section: text
    context: text
    code: text
    line_num: i64

fn main():
    val args = get_args()

    if args.len() == 0:
        print_usage()
        exit(1)

    # Check for flags
    var dry_run = false
    var verbose = false
    var all_mode = false
    var input_md = ""
    var output_spl = ""

    for arg in args:
        if arg == "--all":
            all_mode = true
        elif arg == "--dry-run":
            dry_run = true
        elif arg == "--verbose" or arg == "-v":
            verbose = true
        elif arg.starts_with("--"):
            print error("Unknown flag: {arg}")
            exit(1)
        elif input_md.len() == 0:
            input_md = arg
        elif output_spl.len() == 0:
            output_spl = arg

    val options = ExtractOptions(dry_run: dry_run, verbose: verbose)

    if all_mode:
        val (success_count, total) = extract_all_category_b("doc/spec", "tests/specs", options)
        if success_count == total:
            exit(0)
        else:
            exit(1)
    elif input_md.len() > 0 and output_spl.len() > 0:
        val result = extract_tests(input_md, output_spl, options)
        if result:
            exit(0)
        else:
            exit(1)
    else:
        print_usage()
        exit(1)

fn print_usage():
    print "Extract test cases from Category B spec markdown files"
    print ""
    print "Usage:"
    print "  extract <input.md> <output.spl>     # Extract from single file"
    print "  extract --all                       # Extract from all Category B files"
    print "  extract --all --dry-run             # Preview without writing"
    print "  extract --all --verbose             # Show detailed info"
    print ""
    print "Examples:"
    print "  extract doc/spec/functions.md tests/specs/functions_spec.spl"
    print "  extract --all --verbose"

fn extract_tests(input_md: text, output_spl: text, options: ExtractOptions) -> bool:
    """Extract test cases from markdown spec to _spec.spl file"""

    if not file_exists(input_md):
        print error("Input file not found: {input_md}")
        return false

    val content = file_read(input_md)

    # Extract components
    val metadata = extract_metadata(content)
    val examples = extract_code_examples(content)

    # Generate output
    val spl_content = generate_spec_spl(input_md, metadata, examples)

    # Print info
    val dry_run_prefix = if options.dry_run: "[DRY RUN] " else: ""
    print ""
    print "{dry_run_prefix}Extracting: {path_basename(input_md)}"
    print "  → Output: {output_spl}"
    print "  Status: {metadata.status}"
    print "  Code examples: {examples.len()}"

    if options.verbose:
        print "  Title: {metadata.title}"
        if examples.len() > 0:
            print "  Example sections:"
            val section_counts = count_sections(examples)
            for pair in section_counts.take(5):
                val section = pair.0
                val count = pair.1
                print "    - {section}: {count}"

    # Write output
    if not options.dry_run:
        # Create parent directory
        val parent_dir = get_parent_dir(output_spl)
        if not is_dir(parent_dir):
            dir_create(parent_dir, recursive: true)

        file_write(output_spl, spl_content)
        print success("  ✅ Created: {output_spl}")
    else:
        print "  [DRY RUN] Would create: {output_spl}"
        if options.verbose:
            print ""
            print "--- Preview (first 40 lines) ---"
            val lines = spl_content.split("\n")
            for i in 0..40:
                if i < lines.len():
                    print lines[i]
            print "--- End preview ---"
            print ""

    true

fn extract_all_category_b(base_dir: text, output_dir: text, options: ExtractOptions) -> (i64, i64):
    """Extract tests from all Category B files"""

    val total = CATEGORY_B_FILES.len()
    var success_count = 0

    print ""
    print "============================================================"
    print "Extracting tests from {total} Category B files"
    print "============================================================"

    for pair in CATEGORY_B_FILES:
        val md_file = pair.0
        val spl_file = pair.1
        val input_path = "{base_dir}/{md_file}"
        val output_path = "{output_dir}/{spl_file}"

        if extract_tests(input_path, output_path, options):
            success_count = success_count + 1

    print ""
    print "============================================================"
    val mode_str = if options.dry_run: "preview" else: "complete"
    print "Extraction {mode_str}: {success_count}/{total} successful"
    print "============================================================"
    print ""

    (success_count, total)

fn extract_metadata(content: text) -> SpecMetadata:
    """Extract metadata from markdown"""

    # Get title (first # heading)
    var title = ""
    val lines = split_lines(content)
    for line in lines:
        if line.starts_with("# "):
            title = line.substring(2, line.len()).trim()
            break

    # Find status
    var status = "Reference"
    val status_marker = "**Status:**"
    val status_idx = content.find(status_marker)
    if status_idx >= 0:
        val status_start = status_idx + status_marker.len()
        val status_end = content.find("\n", status_start)
        if status_end > status_start:
            status = content.substring(status_start, status_end).trim()

    # Find feature IDs
    var feature_ids = ""
    val feature_marker = "**Feature ID"
    val feature_idx = content.find(feature_marker)
    if feature_idx >= 0:
        val feature_end = content.find("\n", feature_idx)
        if feature_end > feature_idx:
            val feature_line = content.substring(feature_idx, feature_end)
            val colon_idx = feature_line.find(":")
            if colon_idx >= 0:
                feature_ids = feature_line.substring(colon_idx + 1, feature_line.len()).trim()

    SpecMetadata(title: title, status: status, feature_ids: feature_ids)

fn extract_code_examples(content: text) -> [CodeExample]:
    """Extract code blocks with context"""
    var examples = []

    # Split by sections (##)
    val sections = split_by_sections(content)

    for section_info in sections:
        val section_name = section_info.0
        val section_text = section_info.1

        # Find all ```simple code blocks
        val code_blocks = extract_code_blocks(section_text)

        for code_info in code_blocks:
            val code = code_info.0
            val position = code_info.1

            # Skip empty blocks
            if code.trim().len() < 5:
                continue

            # Get context (paragraph before code)
            val context = extract_context_before(section_text, position)

            # Estimate line number
            val line_num = count_newlines(section_text, position) + 1

            val example = CodeExample(
                section: section_name,
                context: context,
                code: code,
                line_num: line_num
            )
            examples = examples + [example]

    examples

fn split_by_sections(content: text) -> [(text, text)]:
    """Split markdown by ## sections"""
    var sections = []
    val lines = split_lines(content)
    var current_name = "General"
    var current_lines = []

    for line in lines:
        if line.starts_with("## "):
            # Save previous section
            if current_lines.len() > 0:
                val section_text = current_lines.join("\n")
                sections = sections + [(current_name, section_text)]

            # Start new section
            current_name = line.substring(3, line.len()).trim()
            current_lines = []
        else:
            current_lines = current_lines + [line]

    # Save last section
    if current_lines.len() > 0:
        val section_text = current_lines.join("\n")
        sections = sections + [(current_name, section_text)]

    sections

fn extract_code_blocks(text: text) -> [(text, i64)]:
    """Find all ```simple code blocks, return (code, position)"""
    var blocks = []
    var i = 0

    while i < text.len():
        val block_start = text.find("```simple", i)
        if block_start < 0:
            break

        val code_start = block_start + 9  # Length of "```simple"
        val block_end = text.find("```", code_start)
        if block_end < 0:
            break

        val code = text.substring(code_start, block_end).trim()
        blocks = blocks + [(code, block_start)]
        i = block_end + 3

    blocks

fn extract_context_before(text: text, position: i64) -> text:
    """Get context paragraph before position"""
    val before = text.substring(0, position)
    val paragraphs = before.split("\n\n")

    # Get last non-header paragraph
    for i in (paragraphs.len() - 1)..(-1):
        if i >= 0 and i < paragraphs.len():
            val para = paragraphs[i].trim()
            if para.len() > 10 and not para.starts_with("#"):
                # Clean up markdown formatting
                var clean = para.replace("**", "")
                clean = clean.replace("*", "")
                return clean

    ""

fn count_newlines(text: text, until_pos: i64) -> i64:
    """Count newlines up to position"""
    var count = 0
    for i in 0..until_pos:
        if i < text.len() and text[i] == '\n':
            count = count + 1
    count

fn generate_spec_spl(md_path: text, metadata: SpecMetadata, examples: [CodeExample]) -> text:
    """Generate _spec.spl with extracted test cases"""

    val topic = path_basename(md_path).replace(".md", "").replace("_", "-")
    val filename = path_basename(md_path)

    var output = []

    # Header
    output = output + ["\"\"\""]
    output = output + ["# {metadata.title} - Test Specification"]
    output = output + [""]
    output = output + ["**Status:** {metadata.status}"]
    output = output + ["**Feature IDs:** {metadata.feature_ids}"]
    output = output + ["**Source:** {filename}"]
    output = output + ["**Type:** Extracted Examples (Category B)"]
    output = output + [""]
    output = output + ["## Overview"]
    output = output + [""]
    output = output + ["This file contains executable test cases extracted from {filename}."]
    output = output + ["The original specification file remains as architectural reference documentation."]
    output = output + [""]
    output = output + ["**Note:** This is a test extraction file. For complete specification text,"]
    output = output + ["design rationale, and architecture, see doc/spec/{filename}"]
    output = output + [""]
    output = output + ["## Extracted Test Cases"]
    output = output + [""]
    output = output + ["{examples.len()} test cases extracted covering:"]
    output = output + ["- Core functionality examples"]
    output = output + ["- Edge cases and validation"]
    output = output + ["- Integration patterns"]
    output = output + ["\"\"\""]
    output = output + [""]

    # Generate test cases
    if examples.len() > 0:
        for i in 0..examples.len():
            val example = examples[i]
            val test_num = i + 1

            # Test header
            output = output + ["## Test: {example.section} (Line ~{example.line_num})"]
            output = output + [""]

            if example.context.len() > 20:
                val context_short = if example.context.len() > 100:
                    example.context.substring(0, 100) + "..."
                else:
                    example.context
                output = output + ["\"\"\""]
                output = output + [context_short]
                output = output + ["\"\"\""]

            # Code
            if example.code.contains("test ") or example.code.trim().starts_with("fn "):
                # Already structured, use as-is
                output = output + [example.code]
            else:
                # Wrap in test function
                val test_name = sanitize_test_name(example.section, test_num)
                output = output + ["test \"{test_name}\":"]

                # Indent code
                val code_lines = split_lines(example.code)
                for line in code_lines:
                    if line.trim().len() > 0:
                        output = output + ["    {line}"]
                    else:
                        output = output + [""]
                output = output + ["    assert_compiles()"]

            output = output + [""]
    else:
        output = output + ["# No testable code examples found"]
        output = output + [""]
        output = output + ["test \"placeholder\":"]
        output = output + ["    \"\"\""]
        output = output + ["    Placeholder test - add test cases as implementation progresses."]
        output = output + ["    \"\"\""]
        output = output + ["    assert_compiles()"]

    output.join("\n")

fn sanitize_test_name(section: text, num: i64) -> text:
    """Create valid test name from section"""
    var name = section.lower()
    name = name.replace(" ", "_")
    name = name.replace("-", "_")
    # Remove special characters (simple approach)
    var clean = ""
    for i in 0..name.len():
        val ch = name[i]
        if (ch >= 'a' and ch <= 'z') or (ch >= '0' and ch <= '9') or ch == '_':
            clean = clean + "{ch}"
    "{clean}_{num}"

fn count_sections(examples: [CodeExample]) -> [(text, i64)]:
    """Count examples per section, return sorted pairs"""
    var counts = {}
    for example in examples:
        val section = example.section
        val current = counts.get(section, 0)
        counts[section] = current + 1

    var pairs = []
    for key in counts.keys():
        pairs = pairs + [(key, counts[key])]
    pairs

fn get_parent_dir(path: text) -> text:
    """Get parent directory from path"""
    val last_slash = path.rfind("/")
    if last_slash > 0:
        path.substring(0, last_slash)
    else:
        "."
