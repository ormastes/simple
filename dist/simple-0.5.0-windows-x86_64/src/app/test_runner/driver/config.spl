# Test Runner Driver Configuration
#
# Configuration for embedded test execution.
# Parses command-line arguments and config files.

# =========================================================================
# Run Configuration
# =========================================================================

class RunConfig:
    # Target configuration
    loader_type: i32           # 0=QEMU, 1=OpenOCD, 2=JLink, 3=Serial
    target_arch: text          # x86, arm, riscv32, etc.
    binary_path: text          # Path to test binary

    # Transport configuration
    transport_type: i32        # 0=stdio, 1=serial, 2=tcp, 3=file
    transport_path: text       # Port/address/path for transport

    # Timeouts
    timeout_ms: i64            # Overall timeout
    test_timeout_ms: i64       # Per-test timeout

    # Output configuration
    format_type: i32           # 0=simple, 1=verbose, 2=doc, 3=json, 4=junit
    color_output: bool         # Use ANSI colors
    verbose: bool              # Verbose output

    # SMF configuration (for string interning)
    smf_root: text             # Path to SMF files

    # Extra arguments
    extra_args: text           # Additional loader arguments

fn RunConfig_default() -> RunConfig:
    RunConfig(
        loader_type: 0,         # QEMU
        target_arch: "x86",
        binary_path: "",
        transport_type: 0,      # stdio
        transport_path: "",
        timeout_ms: 30000,
        test_timeout_ms: 5000,
        format_type: 0,         # simple
        color_output: true,
        verbose: false,
        smf_root: "",
        extra_args: ""
    )

fn RunConfig_qemu(binary: text, arch: text) -> RunConfig:
    var config = RunConfig_default()
    config.binary_path = binary
    config.target_arch = arch
    config

fn RunConfig_qemu_verbose(binary: text, arch: text) -> RunConfig:
    var config = RunConfig_qemu(binary, arch)
    config.verbose = true
    config.format_type = 1  # verbose
    config

impl RunConfig:
    me set_timeout(timeout_ms: i64):
        self.timeout_ms = timeout_ms

    me set_test_timeout(timeout_ms: i64):
        self.test_timeout_ms = timeout_ms

    me set_format(format_type: i32):
        self.format_type = format_type

    me set_verbose(verbose: bool):
        self.verbose = verbose
        if verbose:
            self.format_type = 1

    me set_color(color: bool):
        self.color_output = color

    me set_smf_root(path: text):
        self.smf_root = path

    fn is_qemu() -> bool:
        self.loader_type == 0

    fn is_verbose() -> bool:
        self.verbose

    fn has_smf() -> bool:
        self.smf_root != ""

# =========================================================================
# Command Line Parsing
# =========================================================================

class ArgParser:
    args: [text]
    index: i32
    config: RunConfig
    errors: [text]

fn ArgParser_create(args: [text]) -> ArgParser:
    ArgParser(
        args: args,
        index: 0,
        config: RunConfig_default(),
        errors: []
    )

impl ArgParser:
    fn has_next() -> bool:
        self.index < self.args.len() as i32

    me next() -> text:
        if self.has_next():
            val arg = self.args[self.index]
            self.index = self.index + 1
            arg
        else:
            ""

    me peek() -> text:
        if self.has_next():
            self.args[self.index]
        else:
            ""

    me parse() -> RunConfig:
        while self.has_next():
            val arg = self.next()

            if arg == "--binary" or arg == "-b":
                self.config.binary_path = self.next()
            elif arg == "--arch" or arg == "-a":
                self.config.target_arch = self.next()
            elif arg == "--timeout" or arg == "-t":
                self.config.timeout_ms = parse_i64(self.next())
            elif arg == "--test-timeout":
                self.config.test_timeout_ms = parse_i64(self.next())
            elif arg == "--format" or arg == "-f":
                self.config.format_type = parse_format(self.next())
            elif arg == "--verbose" or arg == "-v":
                self.config.verbose = true
                self.config.format_type = 1
            elif arg == "--no-color":
                self.config.color_output = false
            elif arg == "--smf-root":
                self.config.smf_root = self.next()
            elif arg == "--loader":
                self.config.loader_type = parse_loader(self.next())
            elif arg == "--transport":
                self.config.transport_type = parse_transport(self.next())
            elif arg == "--transport-path":
                self.config.transport_path = self.next()
            elif arg == "--help" or arg == "-h":
                print_help()
            elif arg.starts_with("-"):
                self.errors.push("Unknown option: {arg}")
            else:
                # Positional argument = binary path
                if self.config.binary_path == "":
                    self.config.binary_path = arg

        self.config

    fn has_errors() -> bool:
        self.errors.len() > 0

    fn get_errors() -> [text]:
        self.errors

# =========================================================================
# Parse Helpers
# =========================================================================

fn parse_i64(s: text) -> i64:
    # Simple integer parsing
    var result: i64 = 0
    for c in s:
        if c >= '0' and c <= '9':
            result = result * 10 + (c.to_i32() - 48) as i64
    result

fn parse_format(s: text) -> i32:
    if s == "simple" or s == "0":
        0
    elif s == "verbose" or s == "1":
        1
    elif s == "doc" or s == "2":
        2
    elif s == "json" or s == "3":
        3
    elif s == "junit" or s == "4":
        4
    else:
        0  # Default to simple

fn parse_loader(s: text) -> i32:
    if s == "qemu" or s == "0":
        0
    elif s == "openocd" or s == "1":
        1
    elif s == "jlink" or s == "2":
        2
    elif s == "serial" or s == "3":
        3
    else:
        0  # Default to QEMU

fn parse_transport(s: text) -> i32:
    if s == "stdio" or s == "0":
        0
    elif s == "serial" or s == "1":
        1
    elif s == "tcp" or s == "2":
        2
    elif s == "file" or s == "3":
        3
    else:
        0  # Default to stdio

# =========================================================================
# Help Text
# =========================================================================

fn print_help():
    print "Embedded Test Runner"
    print ""
    print "Usage: simple test-embedded [OPTIONS] <BINARY>"
    print ""
    print "Options:"
    print "  -b, --binary <PATH>      Path to test binary"
    print "  -a, --arch <ARCH>        Target architecture (x86, arm, riscv32)"
    print "  -t, --timeout <MS>       Overall timeout in milliseconds (default: 30000)"
    print "      --test-timeout <MS>  Per-test timeout in milliseconds (default: 5000)"
    print "  -f, --format <FORMAT>    Output format (simple, verbose, doc, json, junit)"
    print "  -v, --verbose            Enable verbose output"
    print "      --no-color           Disable colored output"
    print "      --smf-root <PATH>    Path to SMF files for string interning"
    print "      --loader <TYPE>      Loader type (qemu, openocd, jlink, serial)"
    print "      --transport <TYPE>   Transport type (stdio, serial, tcp, file)"
    print "      --transport-path <P> Transport path (port, address, or file path)"
    print "  -h, --help               Show this help message"
    print ""
    print "Examples:"
    print "  simple test-embedded test.elf"
    print "  simple test-embedded --arch=arm --loader=openocd firmware.elf"
    print "  simple test-embedded --verbose --timeout=60000 test.elf"

# =========================================================================
# Config Validation
# =========================================================================

fn validate_config(config: RunConfig) -> [text]:
    var errors: [text] = []

    if config.binary_path == "":
        errors.push("Binary path is required")

    if config.timeout_ms <= 0:
        errors.push("Timeout must be positive")

    if config.test_timeout_ms <= 0:
        errors.push("Test timeout must be positive")

    errors
