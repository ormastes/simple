# Test Runner Host Parser
#
# Parses protocol messages from embedded target and updates test results.
# Uses streaming parser to handle partial messages.

# =========================================================================
# Host Parser State
# =========================================================================

class HostParser:
    buffer: [i32]              # Incoming byte buffer
    string_table: StringInternTable
    results: TestResults
    current_suite: text
    verbose: bool

fn HostParser_create() -> HostParser:
    HostParser(
        buffer: [],
        string_table: StringInternTable_empty(),
        results: TestResults_empty(),
        current_suite: "",
        verbose: false
    )

fn HostParser_verbose() -> HostParser:
    HostParser(
        buffer: [],
        string_table: StringInternTable_empty(),
        results: TestResults_empty(),
        current_suite: "",
        verbose: true
    )

impl HostParser:
    # Feed bytes to parser
    me feed(data: [i32]):
        for b in data:
            self.buffer.push(b)
        self.process_buffer()

    # Feed single byte
    me feed_byte(b: i32):
        self.buffer.push(b)
        self.process_buffer()

    # Process buffered data
    me process_buffer():
        while self.buffer.len() >= 5:  # PROTO_HEADER_SIZE
            # Check magic (0xAB)
            if self.buffer[0] != 0xAB:
                self.buffer.remove(0)
                continue

            # Check version (0x01)
            if self.buffer[1] != 0x01:
                self.buffer.remove(0)
                continue

            # Get message type and payload length
            val msg_type = self.buffer[2]
            val payload_len = decode_u16(self.buffer[3], self.buffer[4])

            # Check if we have full message
            val total_len = 5 + payload_len
            if self.buffer.len() < total_len as i64:
                return  # Wait for more data

            # Extract payload
            var payload: [i32] = []
            for i in 5..total_len:
                payload.push(self.buffer[i])

            # Remove processed bytes
            for _ in 0..total_len:
                self.buffer.remove(0)

            # Handle message
            self.handle_message(msg_type, payload)

    # Handle parsed message
    me handle_message(msg_type: i32, payload: [i32]):
        if msg_type == 0x01:        # MSG_READY
            self.handle_ready(payload)
        elif msg_type == 0x10:      # MSG_SUITE_START
            self.handle_suite_start(payload)
        elif msg_type == 0x11:      # MSG_SUITE_END
            self.handle_suite_end(payload)
        elif msg_type == 0x20:      # MSG_TEST_START
            self.handle_test_start(payload)
        elif msg_type == 0x21:      # MSG_TEST_PASS
            self.handle_test_pass(payload)
        elif msg_type == 0x22:      # MSG_TEST_FAIL
            self.handle_test_fail(payload)
        elif msg_type == 0x23:      # MSG_TEST_SKIP
            self.handle_test_skip(payload)
        elif msg_type == 0x24:      # MSG_TEST_TIMEOUT
            self.handle_test_timeout(payload)
        elif msg_type == 0x30:      # MSG_LOG
            self.handle_log(payload)
        elif msg_type == 0x40:      # MSG_ASSERT_FAIL
            self.handle_assert_fail(payload)
        elif msg_type == 0xFF:      # MSG_COMPLETE
            self.handle_complete(payload)

    me handle_ready(payload: [i32]):
        if payload.len() >= 8:
            val version = decode_u32(payload[0], payload[1], payload[2], payload[3])
            val test_count = decode_u32(payload[4], payload[5], payload[6], payload[7])
            if self.verbose:
                print "[HOST] Client ready: version={version}, tests={test_count}"

    me handle_suite_start(payload: [i32]):
        if payload.len() >= 4:
            val suite_id = decode_u32(payload[0], payload[1], payload[2], payload[3])
            self.current_suite = self.string_table.get(suite_id)
            if self.verbose:
                print "[HOST] Suite start: {self.current_suite}"

    me handle_suite_end(payload: [i32]):
        if self.verbose:
            print "[HOST] Suite end: {self.current_suite}"
        self.current_suite = ""

    me handle_test_start(payload: [i32]):
        if payload.len() >= 4:
            val test_id = decode_u32(payload[0], payload[1], payload[2], payload[3])
            if self.verbose:
                val name = self.string_table.get(test_id)
                print "[....] {name}"

    me handle_test_pass(payload: [i32]):
        if payload.len() >= 8:
            val test_id = decode_u32(payload[0], payload[1], payload[2], payload[3])
            val duration = decode_u32(payload[4], payload[5], payload[6], payload[7])
            val name = self.string_table.get(test_id)

            self.results.add_test_result(2, duration as i64)  # TEST_STATUS_PASSED

            if self.verbose:
                print "[PASS] {name} ({duration}ms)"
            else:
                print "[PASS] {name}"

    me handle_test_fail(payload: [i32]):
        if payload.len() >= 20:
            val test_id = decode_u32(payload[0], payload[1], payload[2], payload[3])
            val duration = decode_u32(payload[4], payload[5], payload[6], payload[7])
            val msg_handle = decode_u32(payload[8], payload[9], payload[10], payload[11])
            val file_handle = decode_u32(payload[12], payload[13], payload[14], payload[15])
            val line = decode_u32(payload[16], payload[17], payload[18], payload[19])

            val name = self.string_table.get(test_id)
            val message = self.string_table.get(msg_handle)
            val file = self.string_table.get(file_handle)

            self.results.add_test_result(3, duration as i64)  # TEST_STATUS_FAILED

            print "[FAIL] {name} ({duration}ms)"
            if message != "" and message != "#{msg_handle}":
                print "       Error: {message}"
            if file != "" and file != "#{file_handle}":
                print "       at {file}:{line}"

    me handle_test_skip(payload: [i32]):
        if payload.len() >= 4:
            val test_id = decode_u32(payload[0], payload[1], payload[2], payload[3])
            val name = self.string_table.get(test_id)

            self.results.add_test_result(4, 0)  # TEST_STATUS_SKIPPED

            print "[SKIP] {name}"

    me handle_test_timeout(payload: [i32]):
        if payload.len() >= 8:
            val test_id = decode_u32(payload[0], payload[1], payload[2], payload[3])
            val duration = decode_u32(payload[4], payload[5], payload[6], payload[7])
            val name = self.string_table.get(test_id)

            self.results.add_test_result(5, duration as i64)  # TEST_STATUS_TIMEOUT

            print "[TIME] {name} ({duration}ms)"

    me handle_log(payload: [i32]):
        if payload.len() >= 4:
            val msg_handle = decode_u32(payload[0], payload[1], payload[2], payload[3])
            val message = self.string_table.get(msg_handle)
            print "[LOG]  {message}"

    me handle_assert_fail(payload: [i32]):
        if payload.len() >= 16:
            val test_id = decode_u32(payload[0], payload[1], payload[2], payload[3])
            val msg_handle = decode_u32(payload[4], payload[5], payload[6], payload[7])
            val file_handle = decode_u32(payload[8], payload[9], payload[10], payload[11])
            val line = decode_u32(payload[12], payload[13], payload[14], payload[15])

            val message = self.string_table.get(msg_handle)
            val file = self.string_table.get(file_handle)

            print "       Assertion failed: {message}"
            if file != "" and file != "#{file_handle}":
                print "       at {file}:{line}"

    me handle_complete(payload: [i32]):
        if payload.len() >= 16:
            val total = decode_u32(payload[0], payload[1], payload[2], payload[3])
            val passed = decode_u32(payload[4], payload[5], payload[6], payload[7])
            val failed = decode_u32(payload[8], payload[9], payload[10], payload[11])
            val skipped = decode_u32(payload[12], payload[13], payload[14], payload[15])

            print ""
            print "=========================================="
            print "  Summary: {passed}/{total} passed, {failed} failed"
            if skipped > 0:
                print "  Skipped: {skipped}"
            print "=========================================="

    # Add string to intern table (for loading from SMF or receiving from target)
    me add_string(handle: i32, value: text):
        self.string_table.add(handle, value)

    fn get_results() -> TestResults:
        self.results

    fn is_success() -> bool:
        self.results.is_success()

    fn pending_bytes() -> i32:
        self.buffer.len() as i32

# =========================================================================
# Helper Functions (duplicated for standalone use)
# =========================================================================

fn decode_u16(b0: i32, b1: i32) -> i32:
    b0 | (b1 << 8)

fn decode_u32(b0: i32, b1: i32, b2: i32, b3: i32) -> i32:
    b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

# =========================================================================
# Type Definitions (from core module)
# =========================================================================

class StringInternEntry:
    handle: i32
    value: text

fn StringInternEntry_create(handle: i32, value: text) -> StringInternEntry:
    StringInternEntry(handle: handle, value: value)

class StringInternTable:
    entries: [StringInternEntry]
    next_handle: i32

fn StringInternTable_empty() -> StringInternTable:
    StringInternTable(entries: [], next_handle: 1)

impl StringInternTable:
    fn get(handle: i32) -> text:
        for entry in self.entries:
            if entry.handle == handle:
                return entry.value
        "#{handle}"

    me add(handle: i32, value: text):
        self.entries.push(StringInternEntry_create(handle, value))
        if handle >= self.next_handle:
            self.next_handle = handle + 1

class TestResults:
    total: i32
    passed: i32
    failed: i32
    skipped: i32
    timeout: i32
    crashed: i32
    duration_ms: i64
    start_time_ms: i64
    end_time_ms: i64

fn TestResults_empty() -> TestResults:
    TestResults(
        total: 0,
        passed: 0,
        failed: 0,
        skipped: 0,
        timeout: 0,
        crashed: 0,
        duration_ms: 0,
        start_time_ms: 0,
        end_time_ms: 0
    )

impl TestResults:
    fn is_success() -> bool:
        self.failed == 0 and self.timeout == 0 and self.crashed == 0

    me add_test_result(status: i32, duration: i64):
        self.total = self.total + 1
        self.duration_ms = self.duration_ms + duration

        if status == 2:         # PASSED
            self.passed = self.passed + 1
        elif status == 3:       # FAILED
            self.failed = self.failed + 1
        elif status == 4:       # SKIPPED
            self.skipped = self.skipped + 1
        elif status == 5:       # TIMEOUT
            self.timeout = self.timeout + 1
        elif status == 6:       # CRASHED
            self.crashed = self.crashed + 1
