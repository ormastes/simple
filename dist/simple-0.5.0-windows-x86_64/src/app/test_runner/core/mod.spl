# Test Runner Core Module
#
# Shared functionality for host and embedded test runners.
#
# Submodules:
#   - constants: Status codes, message types, format codes
#   - types: TestCase, TestSuite, TestResults, StringInternTable
#   - protocol: Binary protocol encoding/decoding
#   - format: Output formatting functions

# Import all submodules
# Note: In Simple, we use the submodule files directly
# This file serves as documentation and potential re-exports

# =========================================================================
# Quick Reference
# =========================================================================
#
# Constants (from constants.spl):
#   TEST_STATUS_* - Test execution states
#   MSG_* - Protocol message types
#   FORMAT_* - Output format styles
#   LOADER_* - Target loader types
#   TRANSPORT_* - Communication transport types
#
# Types (from types.spl):
#   TestCase - Individual test information
#   TestSuite - Collection of tests
#   TestResults - Aggregate results
#   StringInternEntry - Interned string entry
#   StringInternTable - String interning table
#
# Protocol (from protocol.spl):
#   ProtocolMessage - Encodes messages for transmission
#   ProtocolParser - Parses received bytes into messages
#   ParsedMessage - Decoded message with payload
#   *Payload - Typed payload decoders (ReadyPayload, etc.)
#
# Format (from format.spl):
#   format_status - Status to string
#   format_duration - Duration formatting
#   format_test_line - Test result line
#   format_summary_* - Summary formatting
#   format_json_* - JSON output
#   format_doc_* - RSpec-style output

# =========================================================================
# Example Usage
# =========================================================================
#
# # Create a test case
# val tc = TestCase.create(1, "should work", "Parser")
#
# # Create protocol message
# val msg = ProtocolMessage.test_pass(1, 42)
# val bytes = msg.encode()
#
# # Parse incoming data
# var parser = ProtocolParser.create()
# parser.feed(bytes)
# if parser.has_messages():
#     val parsed = parser.pop_message()
#     if parsed.msg_type == MSG_TEST_PASS:
#         val payload = TestPassPayload.decode(parsed.payload)
#         print "Test {payload.test_id} passed in {payload.duration_ms}ms"
#
# # Format output
# val line = format_test_line("should work", "Parser", TEST_STATUS_PASSED, 42)
# print line  # "[PASS] Parser :: should work (42ms)"
