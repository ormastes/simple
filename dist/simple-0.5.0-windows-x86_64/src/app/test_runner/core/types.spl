# Test Runner Core Types
#
# Core types shared by host and client test runners.
#
# Constants Reference (define inline where needed):
#   TEST_STATUS_PENDING=0, RUNNING=1, PASSED=2, FAILED=3, SKIPPED=4, TIMEOUT=5, CRASHED=6

# =========================================================================
# Test Case
# =========================================================================

class TestCase:
    id: i32                     # Unique ID (handle for embedded)
    name: text                  # Test name
    suite: text                 # Parent suite name
    status: i32                 # TEST_STATUS_* constant
    duration_ms: i64            # Execution time in milliseconds
    message: text               # Failure message (if failed)
    file: text                  # Source file path
    line: i32                   # Source line number

impl TestCase:
    fn is_pending() -> bool:
        self.status == 0        # TEST_STATUS_PENDING

    fn is_running() -> bool:
        self.status == 1        # TEST_STATUS_RUNNING

    fn is_passed() -> bool:
        self.status == 2        # TEST_STATUS_PASSED

    fn is_failed() -> bool:
        self.status == 3        # TEST_STATUS_FAILED

    fn is_skipped() -> bool:
        self.status == 4        # TEST_STATUS_SKIPPED

    fn is_timeout() -> bool:
        self.status == 5        # TEST_STATUS_TIMEOUT

    fn is_crashed() -> bool:
        self.status == 6        # TEST_STATUS_CRASHED

    fn is_complete() -> bool:
        self.status >= 2        # PASSED or later

    fn full_name() -> text:
        if self.suite == "":
            self.name
        else:
            "{self.suite} :: {self.name}"

fn TestCase_create(id: i32, name: text, suite: text) -> TestCase:
    TestCase(
        id: id,
        name: name,
        suite: suite,
        status: 0,              # TEST_STATUS_PENDING
        duration_ms: 0,
        message: "",
        file: "",
        line: 0
    )

fn TestCase_with_location(id: i32, name: text, suite: text, file: text, line: i32) -> TestCase:
    TestCase(
        id: id,
        name: name,
        suite: suite,
        status: 0,
        duration_ms: 0,
        message: "",
        file: file,
        line: line
    )

# =========================================================================
# Test Suite
# =========================================================================

class TestSuite:
    name: text                  # Suite name (e.g., "Parser Tests")
    file: text                  # Source file path
    test_count: i32             # Total number of tests
    passed_count: i32           # Number passed
    failed_count: i32           # Number failed
    skipped_count: i32          # Number skipped
    timeout_count: i32          # Number timed out
    duration_ms: i64            # Total execution time

impl TestSuite:
    fn is_passed() -> bool:
        self.failed_count == 0 and self.timeout_count == 0

    me add_passed(duration: i64):
        self.test_count = self.test_count + 1
        self.passed_count = self.passed_count + 1
        self.duration_ms = self.duration_ms + duration

    me add_failed(duration: i64):
        self.test_count = self.test_count + 1
        self.failed_count = self.failed_count + 1
        self.duration_ms = self.duration_ms + duration

    me add_skipped():
        self.test_count = self.test_count + 1
        self.skipped_count = self.skipped_count + 1

    me add_timeout(duration: i64):
        self.test_count = self.test_count + 1
        self.timeout_count = self.timeout_count + 1
        self.duration_ms = self.duration_ms + duration

    fn success_rate() -> f64:
        if self.test_count == 0:
            100.0
        else:
            val executed = self.test_count - self.skipped_count
            if executed == 0:
                100.0
            else:
                (self.passed_count as f64 / executed as f64) * 100.0

fn TestSuite_create(name: text, file: text) -> TestSuite:
    TestSuite(
        name: name,
        file: file,
        test_count: 0,
        passed_count: 0,
        failed_count: 0,
        skipped_count: 0,
        timeout_count: 0,
        duration_ms: 0
    )

# =========================================================================
# Test Results (Aggregate)
# =========================================================================

class TestResults:
    total: i32                  # Total tests
    passed: i32                 # Passed tests
    failed: i32                 # Failed tests
    skipped: i32                # Skipped tests
    timeout: i32                # Timed out tests
    crashed: i32                # Crashed tests
    duration_ms: i64            # Total execution time
    start_time_ms: i64          # Start timestamp
    end_time_ms: i64            # End timestamp

impl TestResults:
    fn is_success() -> bool:
        self.failed == 0 and self.timeout == 0 and self.crashed == 0

    fn executed_count() -> i32:
        self.total - self.skipped

    fn success_rate() -> f64:
        val executed = self.executed_count()
        if executed == 0:
            100.0
        else:
            (self.passed as f64 / executed as f64) * 100.0

    fn failure_rate() -> f64:
        val executed = self.executed_count()
        if executed == 0:
            0.0
        else:
            ((self.failed + self.timeout + self.crashed) as f64 / executed as f64) * 100.0

    me add_test_result(status: i32, duration: i64):
        self.total = self.total + 1
        self.duration_ms = self.duration_ms + duration

        if status == 2:         # PASSED
            self.passed = self.passed + 1
        elif status == 3:       # FAILED
            self.failed = self.failed + 1
        elif status == 4:       # SKIPPED
            self.skipped = self.skipped + 1
        elif status == 5:       # TIMEOUT
            self.timeout = self.timeout + 1
        elif status == 6:       # CRASHED
            self.crashed = self.crashed + 1

    me merge(other: TestResults):
        self.total = self.total + other.total
        self.passed = self.passed + other.passed
        self.failed = self.failed + other.failed
        self.skipped = self.skipped + other.skipped
        self.timeout = self.timeout + other.timeout
        self.crashed = self.crashed + other.crashed
        self.duration_ms = self.duration_ms + other.duration_ms

fn TestResults_empty() -> TestResults:
    TestResults(
        total: 0,
        passed: 0,
        failed: 0,
        skipped: 0,
        timeout: 0,
        crashed: 0,
        duration_ms: 0,
        start_time_ms: 0,
        end_time_ms: 0
    )

# =========================================================================
# String Intern Entry (for embedded)
# =========================================================================

class StringInternEntry:
    handle: i32                 # Unique handle
    value: text                 # String value

fn StringInternEntry_create(handle: i32, value: text) -> StringInternEntry:
    StringInternEntry(handle: handle, value: value)

# =========================================================================
# String Intern Table (for embedded)
# =========================================================================

class StringInternTable:
    entries: [StringInternEntry]
    next_handle: i32

impl StringInternTable:
    fn has_entries() -> bool:
        self.entries.len() > 0

    fn get(handle: i32) -> text:
        for entry in self.entries:
            if entry.handle == handle:
                return entry.value
        # Return handle as string if not found
        "#{handle}"

    me intern(value: text) -> i32:
        # Check if already interned
        for entry in self.entries:
            if entry.value == value:
                return entry.handle

        # Add new entry
        val handle = self.next_handle
        self.next_handle = self.next_handle + 1
        self.entries.push(StringInternEntry_create(handle, value))
        handle

    me add(handle: i32, value: text):
        # Add with explicit handle (for loading from file)
        self.entries.push(StringInternEntry_create(handle, value))
        if handle >= self.next_handle:
            self.next_handle = handle + 1

fn StringInternTable_empty() -> StringInternTable:
    StringInternTable(entries: [], next_handle: 1)
