# Pure Simple Tensor - Core tensor implementation
#
# Provides N-dimensional array storage with flat array layout
# Zero external dependencies - pure Simple implementation

# ============================================================================
# PureTensor<T> - N-dimensional array
# ============================================================================

class PureTensor<T>:
    """Pure Simple tensor with flat array storage."""
    data: [T]       # Flat array storage
    shape: [i64]    # Dimension sizes
    strides: [i64]  # Memory layout strides

    fn numel() -> i64:
        """Get total number of elements."""
        var total = 1
        for dim in self.shape:
            total = total * dim
        total

    static fn zeros(shape: [i64]) -> PureTensor<f64>:
        """Create tensor filled with zeros."""
        var numel = 1
        for dim in shape:
            numel = numel * dim
        var data: [f64] = []
        var i = 0
        while i < numel:
            data.push(0.0)
            i = i + 1
        PureTensor(data: data, shape: shape, strides: compute_strides(shape))

    static fn ones(shape: [i64]) -> PureTensor<f64>:
        """Create tensor filled with ones."""
        var numel = 1
        for dim in shape:
            numel = numel * dim
        var data: [f64] = []
        var i = 0
        while i < numel:
            data.push(1.0)
            i = i + 1
        PureTensor(data: data, shape: shape, strides: compute_strides(shape))

    static fn from_data(data: [T], shape: [i64]) -> PureTensor<T>:
        """Create tensor from data array."""
        PureTensor(data: data, shape: shape, strides: compute_strides(shape))

    static fn randn(shape: [i64]) -> PureTensor<f64>:
        """Create tensor with random values."""
        var numel = 1
        for dim in shape:
            numel = numel * dim
        var data: [f64] = []
        var i = 0
        while i < numel:
            val rand = ((i * 2654435761) % 1000000) / 1000000.0
            data.push(rand - 0.5)
            i = i + 1
        PureTensor(data: data, shape: shape, strides: compute_strides(shape))

    fn get(indices: [i64]) -> T:
        """Get element at multi-dimensional index."""
        var offset = 0
        var i = 0
        while i < indices.len():
            offset = offset + indices[i] * self.strides[i]
            i = i + 1
        self.data[offset]

    fn set(indices: [i64], value: T):
        """Set element at multi-dimensional index."""
        var offset = 0
        var i = 0
        while i < indices.len():
            offset = offset + indices[i] * self.strides[i]
            i = i + 1
        self.data[offset] = value

fn compute_strides(shape: [i64]) -> [i64]:
    """Compute strides for C-contiguous layout."""
    var strides: [i64] = []
    var stride = 1
    var i = shape.len() - 1
    while i >= 0:
        strides.insert(0, stride)
        stride = stride * shape[i]
        i = i - 1
    strides

# ============================================================================
# Factory Functions (Workaround for interpreter limitation)
# ============================================================================
# TODO: Remove these once interpreter supports static methods on generic types
# These are module-level factory functions that work around the limitation
# that PureTensor<T>.from_data() doesn't work in the interpreter.

fn tensor_from_data(data: [f64], shape: [i64]) -> PureTensor<f64>:
    """Create f64 tensor from data array.

    Workaround for: PureTensor.from_data(data, shape)
    """
    PureTensor(data: data, shape: shape, strides: compute_strides(shape))

fn tensor_from_data_i64(data: [i64], shape: [i64]) -> PureTensor<i64>:
    """Create i64 tensor from data array.

    Workaround for: PureTensor.from_data(data, shape)
    """
    PureTensor(data: data, shape: shape, strides: compute_strides(shape))

fn tensor_zeros(shape: [i64]) -> PureTensor<f64>:
    """Create tensor filled with zeros.

    Workaround for: PureTensor.zeros(shape)
    """
    var numel = 1
    for dim in shape:
        numel = numel * dim
    var data: [f64] = []
    var i = 0
    while i < numel:
        data.push(0.0)
        i = i + 1
    PureTensor(data: data, shape: shape, strides: compute_strides(shape))

fn tensor_ones(shape: [i64]) -> PureTensor<f64>:
    """Create tensor filled with ones.

    Workaround for: PureTensor.ones(shape)
    """
    var numel = 1
    for dim in shape:
        numel = numel * dim
    var data: [f64] = []
    var i = 0
    while i < numel:
        data.push(1.0)
        i = i + 1
    PureTensor(data: data, shape: shape, strides: compute_strides(shape))

fn tensor_randn(shape: [i64]) -> PureTensor<f64>:
    """Create tensor with random values.

    Workaround for: PureTensor.randn(shape)
    """
    var numel = 1
    for dim in shape:
        numel = numel * dim
    var data: [f64] = []
    var i = 0
    while i < numel:
        val rand = ((i * 2654435761) % 1000000) / 1000000.0
        data.push(rand - 0.5)
        i = i + 1
    PureTensor(data: data, shape: shape, strides: compute_strides(shape))

export PureTensor, compute_strides
export tensor_from_data, tensor_from_data_i64, tensor_zeros, tensor_ones, tensor_randn
