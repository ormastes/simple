# MIR JSON Serialization - Bootstrap-Compatible Version
#
# Simplified implementation using only basic Simple syntax.

use mir_data.*

# ============================================================================
# Type Serialization
# ============================================================================

fn serialize_mir_type(t: MirType) -> text:
    """Serialize MIR type to JSON."""
    val k = t.kind

    # Use match for all type kinds
    match k:
        # Primitives
        case I8: "\"I8\""
        case I16: "\"I16\""
        case I32: "\"I32\""
        case I64: "\"I64\""
        case U8: "\"U8\""
        case U16: "\"U16\""
        case U32: "\"U32\""
        case U64: "\"U64\""
        case F32: "\"F32\""
        case F64: "\"F64\""
        case Bool: "\"Bool\""
        case Char: "\"Char\""
        case Unit: "\"Unit\""
        case Never: "\"Never\""

        # Pointers and references
        case Ptr(pointee, mutable):
            val p = serialize_mir_type(pointee)
            val m = if mutable: "true" else: "false"
            "{\"Ptr\":{\"pointee\":{p},\"mutable\":{m}}}"

        case Ref(referent, mutable):
            val r = serialize_mir_type(referent)
            val m = if mutable: "true" else: "false"
            "{\"Ref\":{\"referent\":{r},\"mutable\":{m}}}"

        case FuncPtr(signature):
            val sig = serialize_mir_signature(signature)
            "{\"FuncPtr\":{sig}}"

        # Aggregates
        case Array(element, size):
            val e = serialize_mir_type(element)
            "{\"Array\":{\"element\":{e},\"size\":{size}}}"

        case Slice(element):
            val e = serialize_mir_type(element)
            "{\"Slice\":{e}}"

        case Tuple(elements):
            var elems = "["
            var first = true
            for elem in elements:
                if not first:
                    elems = "{elems},"
                elems = "{elems}{serialize_mir_type(elem)}"
                first = false
            elems = "{elems}]"
            "{\"Tuple\":{elems}}"

        case Struct(symbol):
            "{\"Struct\":{symbol.id}}"

        case Enum(symbol):
            "{\"Enum\":{symbol.id}}"

        # Special types
        case Opaque(name):
            "{\"Opaque\":\"{escape_json_string(name)}\"}"

        # Async types
        case Promise(inner):
            val i = serialize_mir_type(inner)
            "{\"Promise\":{i}}"

        case Generator(yieldType, returnType):
            val y = serialize_mir_type(yieldType)
            val r = serialize_mir_type(returnType)
            "{\"Generator\":{\"yield\":{y},\"return\":{r}}}"

        case ActorType(message):
            val m = serialize_mir_type(message)
            "{\"ActorType\":{m}}"

        # Catch-all for any missing types
        case _:
            "\"UnknownType\""

# ============================================================================
# Constant Value Serialization
# ============================================================================

fn serialize_const_value(c: MirConstValue) -> text:
    """Serialize constant value to JSON."""
    match c:
        case Int(n):
            "{n}"
        case Float(f):
            "{f}"
        case Bool(b):
            if b: "true" else: "false"
        case Str(s):
            "\"{escape_json_string(s)}\""
        case Zero:
            "\"Zero\""
        case _:
            "null"

# ============================================================================
# Operation Serialization
# ============================================================================

fn serialize_binop(op: MirBinOp) -> text:
    """Serialize binary operation."""
    match op:
        case Add: "\"Add\""
        case Sub: "\"Sub\""
        case Mul: "\"Mul\""
        case Div: "\"Div\""
        case Rem: "\"Rem\""
        case Pow: "\"Pow\""
        case MatMul: "\"MatMul\""
        case BitAnd: "\"BitAnd\""
        case BitOr: "\"BitOr\""
        case BitXor: "\"BitXor\""
        case Shl: "\"Shl\""
        case Shr: "\"Shr\""
        case Eq: "\"Eq\""
        case Ne: "\"Ne\""
        case Lt: "\"Lt\""
        case Le: "\"Le\""
        case Gt: "\"Gt\""
        case Ge: "\"Ge\""
        case BroadcastAdd: "\"BroadcastAdd\""
        case BroadcastSub: "\"BroadcastSub\""
        case BroadcastMul: "\"BroadcastMul\""
        case BroadcastDiv: "\"BroadcastDiv\""
        case BroadcastPow: "\"BroadcastPow\""
        case Offset: "\"Offset\""
        case _: "\"Other\""

fn serialize_unaryop(op: MirUnaryOp) -> text:
    """Serialize unary operation."""
    match op:
        case Neg: "\"Neg\""
        case Not: "\"Not\""
        case BitNot: "\"BitNot\""
        case Transpose: "\"Transpose\""
        case _: "\"Other\""

fn serialize_aggregate_kind(kind: AggregateKind) -> text:
    """Serialize aggregate kind to JSON."""
    match kind:
        case Array(elemType):
            val t = serialize_mir_type(elemType)
            "{\"Array\":{t}}"
        case Tuple:
            "\"Tuple\""
        case Struct(symbol):
            "{\"Struct\":{symbol.id}}"
        case Enum(symbol, variant):
            "{\"Enum\":{\"symbol\":{symbol.id},\"variant\":{variant}}}"

# ============================================================================
# Operand Serialization
# ============================================================================

fn serialize_operand(op: MirOperand) -> text:
    """Serialize operand to JSON."""
    val k = op.kind

    match k:
        case Copy(local):
            "{\"Copy\":{local.id}}"
        case Move(local):
            "{\"Move\":{local.id}}"
        case Const(value, mtype):
            val vj = serialize_const_value(value)
            val tj = serialize_mir_type(mtype)
            "{\"Const\":{\"value\":{vj},\"type\":{tj}}}"

# ============================================================================
# Terminator Serialization
# ============================================================================

fn serialize_mir_terminator(term: MirTerminator) -> text:
    """Serialize terminator to JSON."""
    match term:
        case Goto(target):
            "{\"Goto\":{target.id}}"

        case Return(maybeVal):
            if maybeVal.?:
                val v = serialize_operand(maybeVal.unwrap())
                "{\"Return\":{v}}"
            else:
                "{\"Return\":null}"

        case If(cond, thenBlock, elseBlock):
            val c = serialize_operand(cond)
            "{\"If\":{\"cond\":{c},\"then\":{thenBlock.id},\"else\":{elseBlock.id}}}"

        case Switch(value, targets, defaultBlock):
            val v = serialize_operand(value)
            var cases = "["
            var first = true
            for switchCase in targets:
                if not first:
                    cases = "{cases},"
                cases = "{cases}{\"value\":{switchCase.value},\"target\":{switchCase.target.id}}"
                first = false
            cases = "{cases}]"
            "{\"Switch\":{\"value\":{v},\"targets\":{cases},\"default\":{defaultBlock.id}}}"

        case CallTerminator(maybeDest, func, args, normal, maybeUnwind):
            val f = serialize_operand(func)
            var argsStr = "["
            var firstArg = true
            for arg in args:
                if not firstArg:
                    argsStr = "{argsStr},"
                argsStr = "{argsStr}{serialize_operand(arg)}"
                firstArg = false
            argsStr = "{argsStr}]"

            val destStr = if maybeDest.?: "{maybeDest.unwrap().id}" else: "null"
            val unwindStr = if maybeUnwind.?: "{maybeUnwind.unwrap().id}" else: "null"

            "{\"CallTerminator\":{\"dest\":{destStr},\"func\":{f},\"args\":{argsStr},\"normal\":{normal.id},\"unwind\":{unwindStr}}}"

        case Unreachable:
            "\"Unreachable\""

        case Abort(msg):
            "{\"Abort\":\"{escape_json_string(msg)}\"}"

        case _:
            "\"UnknownTerminator\""

# ============================================================================
# Instruction Serialization
# ============================================================================

fn serialize_mir_inst_kind(inst: MirInstKind) -> text:
    """Serialize instruction kind to JSON."""
    match inst:
        case Const(dest, value, mtype):
            val v = serialize_const_value(value)
            val t = serialize_mir_type(mtype)
            "{\"Const\":{\"dest\":{dest.id},\"value\":{v},\"type\":{t}}}"

        case Copy(dest, src):
            "{\"Copy\":{\"dest\":{dest.id},\"src\":{src.id}}}"

        case Move(dest, src):
            "{\"Move\":{\"dest\":{dest.id},\"src\":{src.id}}}"

        case BinOp(dest, op, left, right):
            val opstr = serialize_binop(op)
            val l = serialize_operand(left)
            val r = serialize_operand(right)
            "{\"BinOp\":{\"dest\":{dest.id},\"op\":{opstr},\"left\":{l},\"right\":{r}}}"

        case UnaryOp(dest, op, operand):
            val opstr = serialize_unaryop(op)
            val o = serialize_operand(operand)
            "{\"UnaryOp\":{\"dest\":{dest.id},\"op\":{opstr},\"operand\":{o}}}"

        case Alloc(dest, mtype):
            val t = serialize_mir_type(mtype)
            "{\"Alloc\":{\"dest\":{dest.id},\"type\":{t}}}"

        case Load(dest, ptr):
            val p = serialize_operand(ptr)
            "{\"Load\":{\"dest\":{dest.id},\"ptr\":{p}}}"

        case Store(ptr, value):
            val p = serialize_operand(ptr)
            val v = serialize_operand(value)
            "{\"Store\":{\"ptr\":{p},\"value\":{v}}}"

        case Call(maybeDest, func, args):
            val f = serialize_operand(func)
            var argsStr = "["
            var firstArg = true
            for arg in args:
                if not firstArg:
                    argsStr = "{argsStr},"
                argsStr = "{argsStr}{serialize_operand(arg)}"
                firstArg = false
            argsStr = "{argsStr}]"

            if maybeDest.?:
                "{\"Call\":{\"dest\":{maybeDest.unwrap().id},\"func\":{f},\"args\":{argsStr}}}"
            else:
                "{\"Call\":{\"dest\":null,\"func\":{f},\"args\":{argsStr}}}"

        case GetField(dest, base, field):
            val b = serialize_operand(base)
            "{\"GetField\":{\"dest\":{dest.id},\"base\":{b},\"field\":{field}}}"

        case SetField(base, field, value):
            val b = serialize_operand(base)
            val v = serialize_operand(value)
            "{\"SetField\":{\"base\":{b},\"field\":{field},\"value\":{v}}}"

        case Aggregate(dest, kind, operands):
            val k = serialize_aggregate_kind(kind)
            var ops = "["
            var first = true
            for op in operands:
                if not first:
                    ops = "{ops},"
                ops = "{ops}{serialize_operand(op)}"
                first = false
            ops = "{ops}]"
            "{\"Aggregate\":{\"dest\":{dest.id},\"kind\":{k},\"operands\":{ops}}}"

        case Cast(dest, operand, targetType):
            val o = serialize_operand(operand)
            val t = serialize_mir_type(targetType)
            "{\"Cast\":{\"dest\":{dest.id},\"operand\":{o},\"target\":{t}}}"

        case Bitcast(dest, operand, targetType):
            val o = serialize_operand(operand)
            val t = serialize_mir_type(targetType)
            "{\"Bitcast\":{\"dest\":{dest.id},\"operand\":{o},\"target\":{t}}}"

        case CallIndirect(maybeDest, ptr, args, signature):
            val p = serialize_operand(ptr)
            val sig = serialize_mir_signature(signature)
            var argsStr = "["
            var firstArg = true
            for arg in args:
                if not firstArg:
                    argsStr = "{argsStr},"
                argsStr = "{argsStr}{serialize_operand(arg)}"
                firstArg = false
            argsStr = "{argsStr}]"

            if maybeDest.?:
                "{\"CallIndirect\":{\"dest\":{maybeDest.unwrap().id},\"ptr\":{p},\"args\":{argsStr},\"signature\":{sig}}}"
            else:
                "{\"CallIndirect\":{\"dest\":null,\"ptr\":{p},\"args\":{argsStr},\"signature\":{sig}}}"

        case Intrinsic(maybeDest, name, args):
            var argsStr = "["
            var firstArg = true
            for arg in args:
                if not firstArg:
                    argsStr = "{argsStr},"
                argsStr = "{argsStr}{serialize_operand(arg)}"
                firstArg = false
            argsStr = "{argsStr}]"

            if maybeDest.?:
                "{\"Intrinsic\":{\"dest\":{maybeDest.unwrap().id},\"name\":\"{escape_json_string(name)}\",\"args\":{argsStr}}}"
            else:
                "{\"Intrinsic\":{\"dest\":null,\"name\":\"{escape_json_string(name)}\",\"args\":{argsStr}}}"

        case GetElementPtr(dest, base, indices):
            val b = serialize_operand(base)
            var idxs = "["
            var first = true
            for idx in indices:
                if not first:
                    idxs = "{idxs},"
                idxs = "{idxs}{serialize_operand(idx)}"
                first = false
            idxs = "{idxs}]"
            "{\"GetElementPtr\":{\"dest\":{dest.id},\"base\":{b},\"indices\":{idxs}}}"

        case CheckedBinOp(dest, op, left, right):
            val opstr = serialize_binop(op)
            val l = serialize_operand(left)
            val r = serialize_operand(right)
            "{\"CheckedBinOp\":{\"dest\":{dest.id},\"op\":{opstr},\"left\":{l},\"right\":{r}}}"

        case Nop:
            "\"Nop\""

        case DebugValue(local, name):
            "{\"DebugValue\":{\"local\":{local.id},\"name\":\"{escape_json_string(name)}\"}}"

        case _:
            "\"UnsupportedInst\""

# ============================================================================
# Block Serialization
# ============================================================================

fn serialize_mir_block(block: MirBlock) -> text:
    """Serialize block to JSON."""
    var json = "{"
    json = "{json}\"id\":{block.id.id},"

    if block.label.?:
        json = "{json}\"label\":\"{escape_json_string(block.label.unwrap())}\","
    else:
        json = "{json}\"label\":null,"

    # Instructions
    json = "{json}\"instructions\":["
    var firstInst = true
    for inst in block.instructions:
        if not firstInst:
            json = "{json},"
        json = "{json}{serialize_mir_inst_kind(inst.kind)}"
        firstInst = false
    json = "{json}],"

    # Terminator
    json = "{json}\"terminator\":{serialize_mir_terminator(block.terminator)}"
    json = "{json}}"
    json

# ============================================================================
# Signature Serialization
# ============================================================================

fn serialize_mir_signature(sig: MirSignature) -> text:
    """Serialize function signature to JSON."""
    var json = "{"

    # Params
    json = "{json}\"params\":["
    var firstParam = true
    for param in sig.params:
        if not firstParam:
            json = "{json},"
        json = "{json}{serialize_mir_type(param)}"
        firstParam = false
    json = "{json}],"

    # Return type
    json = "{json}\"return_type\":{serialize_mir_type(sig.return_type)},"

    # Variadic
    val variadicStr = if sig.is_variadic: "true" else: "false"
    json = "{json}\"is_variadic\":{variadicStr}"

    json = "{json}}"
    json

# ============================================================================
# Local Serialization
# ============================================================================

fn serialize_mir_local(local: MirLocal) -> text:
    """Serialize local variable to JSON."""
    var json = "{"
    json = "{json}\"id\":{local.id.id},"

    if local.name.?:
        json = "{json}\"name\":\"{escape_json_string(local.name.unwrap())}\","
    else:
        json = "{json}\"name\":null,"

    json = "{json}\"type\":{serialize_mir_type(local.type_)},"

    # Kind
    val kindJson = match local.kind:
        case Arg(index): "{\"Arg\":{index}}"
        case Var: "\"Var\""
        case Temp: "\"Temp\""
        case Return: "\"Return\""

    json = "{json}\"kind\":{kindJson}"
    json = "{json}}"
    json

# ============================================================================
# Function Serialization
# ============================================================================

fn serialize_mir_function(func: MirFunction) -> text:
    """Serialize MIR function to JSON."""
    var json = "{"
    json = "{json}\"symbol\":{func.symbol.id},"
    json = "{json}\"name\":\"{escape_json_string(func.name)}\","
    json = "{json}\"signature\":{serialize_mir_signature(func.signature)},"

    # Locals
    json = "{json}\"locals\":["
    var firstLocal = true
    for local in func.locals:
        if not firstLocal:
            json = "{json},"
        json = "{json}{serialize_mir_local(local)}"
        firstLocal = false
    json = "{json}],"

    # Blocks
    json = "{json}\"blocks\":["
    var firstBlock = true
    for block in func.blocks:
        if not firstBlock:
            json = "{json},"
        json = "{json}{serialize_mir_block(block)}"
        firstBlock = false
    json = "{json}],"

    json = "{json}\"entry_block\":{func.entry_block.id}"
    json = "{json}}"
    json

# ============================================================================
# Utility Functions
# ============================================================================

fn escape_json_string(s: text) -> text:
    """Escape string for JSON."""
    var result = ""
    for i in 0..s.len():
        val c = s[i:i+1]
        if c == "\"":
            result = "{result}\\\""
        else:
            if c == "\\":
                result = "{result}\\\\"
            else:
                if c == "\n":
                    result = "{result}\\n"
                else:
                    if c == "\r":
                        result = "{result}\\r"
                    else:
                        if c == "\t":
                            result = "{result}\\t"
                        else:
                            result = "{result}{c}"
    result

# ============================================================================
# Exports
# ============================================================================

export serialize_mir_function, serialize_mir_type, serialize_const_value
export serialize_mir_inst_kind, serialize_mir_terminator, serialize_operand
export serialize_binop, serialize_unaryop, serialize_aggregate_kind, escape_json_string
export serialize_mir_signature, serialize_mir_local, serialize_mir_block
