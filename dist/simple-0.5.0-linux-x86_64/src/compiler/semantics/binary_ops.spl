# Binary Operation Semantics
#
# Unified binary operation semantics for Simple language.
# This module defines the semantic rules for all binary operations.
# Both interpreter and codegen must follow these rules for consistency.
#
# Port of rust/compiler/src/semantics/binary_ops.rs (375 lines)

export BinaryOpResult, BinaryOpSemantics

use parser.ast (BinOp)

# ============================================================================
# Result Type
# ============================================================================

enum BinaryOpResult:
    Int(i64)                # Integer result
    Float(f64)              # Float result
    Bool(bool)              # Boolean result
    String(text)            # String result (for concatenation)
    Error(text)             # Error occurred

impl BinaryOpResult:
    static fn int(v: i64) -> BinaryOpResult:
        BinaryOpResult.Int(v)

    static fn float(v: f64) -> BinaryOpResult:
        BinaryOpResult.Float(v)

    static fn bool(v: bool) -> BinaryOpResult:
        BinaryOpResult.Bool(v)

    static fn string(v: text) -> BinaryOpResult:
        BinaryOpResult.String(v)

    static fn error(msg: text) -> BinaryOpResult:
        BinaryOpResult.Error(msg)

    fn is_error() -> bool:
        match self:
            case Error(_): true
            case _: false

# ============================================================================
# Binary Operation Semantics
# ============================================================================

struct BinaryOpSemantics

impl BinaryOpSemantics:
    # ========================================================================
    # Integer Operations
    # ========================================================================

    static fn eval_int_int(op: BinOp, left: i64, right: i64) -> BinaryOpResult:
        """Perform binary operation on two integers."""
        match op:
            # Arithmetic (wrapping semantics - no panic on overflow)
            case Add: BinaryOpResult.int(left.wrapping_add(right))
            case Sub: BinaryOpResult.int(left.wrapping_sub(right))
            case Mul: BinaryOpResult.int(left.wrapping_mul(right))
            case Div:
                if right == 0:
                    BinaryOpResult.error("division by zero")
                else:
                    BinaryOpResult.int(left / right)
            case Mod:
                if right == 0:
                    BinaryOpResult.error("modulo by zero")
                else:
                    BinaryOpResult.int(left % right)
            case Pow: BinaryOpResult.int(Self.int_pow(left, right))

            # Comparison
            case Eq: BinaryOpResult.bool(left == right)
            case NotEq: BinaryOpResult.bool(left != right)
            case Lt: BinaryOpResult.bool(left < right)
            case LtEq: BinaryOpResult.bool(left <= right)
            case Gt: BinaryOpResult.bool(left > right)
            case GtEq: BinaryOpResult.bool(left >= right)

            # Bitwise
            case BitAnd: BinaryOpResult.int(left & right)
            case BitOr: BinaryOpResult.int(left | right)
            case BitXor: BinaryOpResult.int(left ^ right)
            case ShiftLeft: BinaryOpResult.int(left << (right as u32))
            case ShiftRight: BinaryOpResult.int(left >> (right as u32))

            # Logical (short-circuit handled at call site)
            case And: BinaryOpResult.bool(left != 0 and right != 0)
            case AndSuspend: BinaryOpResult.bool(left != 0 and right != 0)
            case Or: BinaryOpResult.bool(left != 0 or right != 0)
            case OrSuspend: BinaryOpResult.bool(left != 0 or right != 0)

            case _: BinaryOpResult.error("unsupported int operation: {op}")

    static fn int_pow(base: i64, exp: i64) -> i64:
        """Integer power using exponentiation by squaring.

        CRITICAL: O(log n) algorithm - do not change to O(n).
        Uses wrapping multiplication to match Rust semantics.
        """
        # Negative exponent: integer division rounds down to 0
        if exp < 0:
            return 0

        var result: i64 = 1
        var base = base
        var exp = exp as u64

        # Exponentiation by squaring: O(log n)
        while exp > 0:
            # If exp is odd, multiply result by base
            if (exp & 1) == 1:
                result = result.wrapping_mul(base)
            # Square the base and halve the exponent
            exp = exp >> 1
            base = base.wrapping_mul(base)

        result

    # ========================================================================
    # Float Operations
    # ========================================================================

    static fn eval_float_float(op: BinOp, left: f64, right: f64) -> BinaryOpResult:
        """Perform binary operation on two floats."""
        match op:
            # Arithmetic (float div allows 0 - produces inf/nan)
            case Add: BinaryOpResult.float(left + right)
            case Sub: BinaryOpResult.float(left - right)
            case Mul: BinaryOpResult.float(left * right)
            case Div: BinaryOpResult.float(left / right)
            case Mod: BinaryOpResult.float(left % right)
            case Pow: BinaryOpResult.float(left.powf(right))

            # Comparison
            case Eq: BinaryOpResult.bool(left == right)
            case NotEq: BinaryOpResult.bool(left != right)
            case Lt: BinaryOpResult.bool(left < right)
            case LtEq: BinaryOpResult.bool(left <= right)
            case Gt: BinaryOpResult.bool(left > right)
            case GtEq: BinaryOpResult.bool(left >= right)

            # Logical
            case And: BinaryOpResult.bool(left != 0.0 and right != 0.0)
            case AndSuspend: BinaryOpResult.bool(left != 0.0 and right != 0.0)
            case Or: BinaryOpResult.bool(left != 0.0 or right != 0.0)
            case OrSuspend: BinaryOpResult.bool(left != 0.0 or right != 0.0)

            case _: BinaryOpResult.error("unsupported float operation: {op}")

    # ========================================================================
    # Mixed Type Operations (int/float promotion)
    # ========================================================================

    static fn eval_int_float(op: BinOp, left: i64, right: f64) -> BinaryOpResult:
        """Perform operation with int left, float right.
        Promotes int to float.
        """
        Self.eval_float_float(op, left as f64, right)

    static fn eval_float_int(op: BinOp, left: f64, right: i64) -> BinaryOpResult:
        """Perform operation with float left, int right.
        Promotes int to float.
        """
        Self.eval_float_float(op, left, right as f64)

    # ========================================================================
    # String Operations
    # ========================================================================

    static fn eval_string_string(op: BinOp, left: text, right: text) -> BinaryOpResult:
        """Perform binary operation on strings."""
        match op:
            case Add: BinaryOpResult.string("{left}{right}")
            case Eq: BinaryOpResult.bool(left == right)
            case NotEq: BinaryOpResult.bool(left != right)
            case Lt: BinaryOpResult.bool(left < right)
            case LtEq: BinaryOpResult.bool(left <= right)
            case Gt: BinaryOpResult.bool(left > right)
            case GtEq: BinaryOpResult.bool(left >= right)
            case _: BinaryOpResult.error("unsupported string operation: {op}")

    static fn eval_string_int(op: BinOp, left: text, right: i64) -> BinaryOpResult:
        """String repetition: "ab" * 3 = "ababab"."""
        match op:
            case Mul:
                if right < 0:
                    BinaryOpResult.string("")
                else:
                    BinaryOpResult.string(left.repeat(right as usize))
            case _: BinaryOpResult.error("unsupported string*int operation: {op}")

    # ========================================================================
    # Boolean Operations
    # ========================================================================

    static fn eval_bool_bool(op: BinOp, left: bool, right: bool) -> BinaryOpResult:
        """Perform binary operation on booleans."""
        match op:
            case And: BinaryOpResult.bool(left and right)
            case AndSuspend: BinaryOpResult.bool(left and right)
            case Or: BinaryOpResult.bool(left or right)
            case OrSuspend: BinaryOpResult.bool(left or right)
            case Eq: BinaryOpResult.bool(left == right)
            case NotEq: BinaryOpResult.bool(left != right)
            # Boolean ordering: false < true
            case Lt: BinaryOpResult.bool(not left and right)
            case LtEq: BinaryOpResult.bool(not left or right)
            case Gt: BinaryOpResult.bool(left and not right)
            case GtEq: BinaryOpResult.bool(left or not right)
            case _: BinaryOpResult.error("unsupported bool operation: {op}")

    # ========================================================================
    # Short-Circuit Evaluation Helpers
    # ========================================================================

    static fn is_short_circuit(op: BinOp) -> bool:
        """Check if an operation requires short-circuit evaluation."""
        op in [BinOp.And, BinOp.AndSuspend, BinOp.Or, BinOp.OrSuspend]

    static fn short_circuit_and_result(left_truthy: bool) -> bool?:
        """For short-circuit AND: if left is falsy, result is false (don't eval right).

        Returns:
        - Some(false) if left is falsy (short-circuit, don't evaluate right)
        - None if left is truthy (must evaluate right)
        """
        if not left_truthy:
            Some(false)
        else:
            None

    static fn short_circuit_or_result(left_truthy: bool) -> bool?:
        """For short-circuit OR: if left is truthy, result is true (don't eval right).

        Returns:
        - Some(true) if left is truthy (short-circuit, don't evaluate right)
        - None if left is falsy (must evaluate right)
        """
        if left_truthy:
            Some(true)
        else:
            None
