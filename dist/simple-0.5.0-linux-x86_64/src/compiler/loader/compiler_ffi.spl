# Compiler Context - Pure Simple Implementation
#
# This module provides type inference and template instantiation functionality
# implemented entirely in Simple, without Rust FFI dependencies.
#
# Architecture:
# - CompilerContext: Opaque handle wrapper
# - CompilerContextImpl: Manages type inference state
# - Type inference: Simplified Hindley-Milner with constraint solving
# - Template instantiation: Placeholder bytecode generation
# - All implemented in Simple for self-hosting

# ============================================================================
# Compiler Context Handle (Public API)
# ============================================================================

struct CompilerContext:
    """Opaque handle to compiler context.

    Wrapper around i64 handle for type safety.
    """
    handle: i64

impl CompilerContext:
    static fn create() -> CompilerContext:
        """Create a new compiler context.

        Returns: CompilerContext with opaque handle
        """
        val handle = compiler_create_context()
        CompilerContext(handle: handle)

    fn destroy():
        """Destroy this context and free resources."""
        compiler_destroy_context(self.handle)

    fn infer_types_json(template_json: text, hints_json: text) -> text:
        """Infer types for a generic template.

        Args:
            template_json: Template metadata as JSON
            hints_json: Type hints as JSON array

        Returns: Inferred types as JSON array
        """
        compiler_infer_types(self.handle, template_json, hints_json)

    fn instantiate_json(template_json: text, types_json: text) -> text:
        """Instantiate a generic template.

        Args:
            template_json: Template metadata as JSON
            types_json: Type arguments as JSON array

        Returns: Compilation result as JSON
        """
        compiler_instantiate_template(self.handle, template_json, types_json)

    fn check_types(code: [u8]) -> bool:
        """Type check bytecode.

        Args:
            code: Bytecode to check

        Returns: true if type-correct
        """
        compiler_check_types(self.handle, code)

    fn get_stats() -> text:
        """Get statistics as JSON."""
        compiler_get_stats(self.handle)

# ============================================================================
# Compiler Context Implementation (Internal)
# ============================================================================

class CompilerContextImpl:
    """Compiler context for type inference and template instantiation.

    State:
    - type_cache: Cache of inferred types
    - instantiation_cache: Cache of compiled templates
    - stats: Statistics for cache hits/misses
    """
    type_cache: Dict<text, [TypeInfo]>
    instantiation_cache: Dict<text, [u8]>
    stats: ContextStats
    next_type_var: i64

    fn infer_types(template: Template, hints: [TypeHint]) -> [TypeInfo]:
        """Infer type arguments for a generic template.

        Args:
            template: Template metadata
            hints: Type hints from call sites

        Returns:
            Inferred types for type parameters
        """
        # Check cache
        val cache_key = "{template.name}:{hints_to_key(hints)}"
        if cache_key in self.type_cache:
            self.stats.cache_hits = self.stats.cache_hits + 1
            return self.type_cache[cache_key]

        self.stats.cache_misses = self.stats.cache_misses + 1
        self.stats.type_inferences = self.stats.type_inferences + 1

        # Simple inference: extract types from hints
        var inferred: [TypeInfo] = []

        for param in template.type_params:
            # Find hint for this parameter
            var found_type: TypeInfo? = None

            for hint in hints:
                if hint.source == "call_site":
                    found_type = Some(hint.ty)
                    break

            if found_type.?:
                inferred.push(found_type.unwrap())
            else:
                # Default to i64 if no hint
                inferred.push(TypeInfo(
                    kind: "int",
                    name: "i64",
                    bits: 64,
                    signed: true,
                    args: [],
                    elem: None
                ))

        # Cache result
        self.type_cache[cache_key] = inferred
        inferred

    fn instantiate_template(template: Template, type_args: [TypeInfo]) -> CompilationResult:
        """Instantiate a generic template with concrete type arguments.

        Args:
            template: Template metadata
            type_args: Concrete type arguments

        Returns:
            Compilation result with code or error
        """
        # Check cache
        val cache_key = "{template.name}:{types_to_key(type_args)}"
        if cache_key in self.instantiation_cache:
            self.stats.cache_hits = self.stats.cache_hits + 1
            return CompilationResult(
                success: true,
                code: self.instantiation_cache[cache_key],
                error: None
            )

        self.stats.cache_misses = self.stats.cache_misses + 1
        self.stats.template_instantiations = self.stats.template_instantiations + 1

        # Generate placeholder bytecode
        # TODO: Real code generation
        var code: [u8] = [
            0x01,  # Placeholder opcode
            0x02,
            0x03,
            0x04
        ]

        # Add type info to bytecode (for debugging)
        for ty in type_args:
            code.push(0xFF)  # Type marker

            # Encode type kind
            val kind_byte = match ty.kind:
                case "int": 0x10
                case "float": 0x20
                case "bool": 0x30
                case "string": 0x40
                case _: 0x00

            code.push(kind_byte)

        # Cache result
        self.instantiation_cache[cache_key] = code

        CompilationResult(
            success: true,
            code: code,
            error: None
        )

    fn check_types(code: [u8]) -> bool:
        """Type check bytecode.

        Args:
            code: Bytecode to check

        Returns:
            true if type-correct
        """
        # TODO: Real type checking
        # For now, always succeed
        true

    fn get_stats() -> ContextStats:
        """Get statistics."""
        self.stats

# ============================================================================
# Data Structures
# ============================================================================

struct ContextStats:
    """Statistics for compiler context."""
    type_inferences: i64
    template_instantiations: i64
    cache_hits: i64
    cache_misses: i64

struct Template:
    """Template metadata."""
    name: text
    type_params: [text]
    param_types: [TypeInfo]?
    return_type: TypeInfo?

struct TypeInfo:
    """Type information."""
    kind: text  # "int", "float", "bool", "string", "named", "array", "simd"
    name: text
    bits: i64?
    signed: bool?
    lanes: i64?
    args: [TypeInfo]
    elem: TypeInfo?

struct TypeHint:
    """Type hint for inference."""
    source: text  # "call_site", "return", "assignment", "constraint"
    param_index: i64?
    ty: TypeInfo

struct CompilationResult:
    """Result of template instantiation."""
    success: bool
    code: [u8]?
    error: text?

# ============================================================================
# Global Context Registry
# ============================================================================

var CONTEXT_REGISTRY: Dict<i64, CompilerContextImpl> = {}
var NEXT_HANDLE: i64 = 1

fn alloc_handle() -> i64:
    """Allocate a new context handle."""
    val handle = NEXT_HANDLE
    NEXT_HANDLE = NEXT_HANDLE + 1
    handle

# ============================================================================
# Public API Functions
# ============================================================================

fn compiler_create_context() -> i64:
    """Create a new compiler context.

    Returns: Opaque handle (i64) to the context
    """
    val ctx = CompilerContextImpl(
        type_cache: {},
        instantiation_cache: {},
        stats: ContextStats(
            type_inferences: 0,
            template_instantiations: 0,
            cache_hits: 0,
            cache_misses: 0
        ),
        next_type_var: 0
    )

    val handle = alloc_handle()
    CONTEXT_REGISTRY[handle] = ctx
    handle

fn create_compiler_context() -> i64:
    """Create a new CompilerContext handle (workaround for struct constructor limitations).

    Returns: i64 handle (wrap in CompilerContext struct at call site if needed)
    """
    compiler_create_context()

fn compiler_destroy_context(handle: i64):
    """Destroy a compiler context.

    Args:
        handle: Context handle
    """
    CONTEXT_REGISTRY.remove(handle)

fn compiler_infer_types(
    handle: i64,
    template_json: text,
    hints_json: text
) -> text:
    """Infer types for a generic template.

    Args:
        handle: Context handle
        template_json: Template metadata as JSON
        hints_json: Type hints as JSON array

    Returns: Inferred types as JSON array
    """
    # Get context
    if handle not in CONTEXT_REGISTRY:
        return '{"error": "Invalid context handle"}'

    val ctx = CONTEXT_REGISTRY[handle]

    # Parse inputs
    val template = parse_template_json(template_json)
    val hints = parse_hints_json(hints_json)

    # Run inference
    val inferred = ctx.infer_types(template, hints)

    # Serialize result
    serialize_types_json(inferred)

fn compiler_check_types(handle: i64, code: [u8]) -> bool:
    """Type check bytecode.

    Args:
        handle: Context handle
        code: Bytecode to check

    Returns: true if type-correct
    """
    if handle not in CONTEXT_REGISTRY:
        return false

    val ctx = CONTEXT_REGISTRY[handle]
    ctx.check_types(code)

fn compiler_instantiate_template(
    handle: i64,
    template_json: text,
    types_json: text
) -> text:
    """Instantiate a generic template.

    Args:
        handle: Context handle
        template_json: Template metadata as JSON
        types_json: Type arguments as JSON array

    Returns: Compilation result as JSON
    """
    # Get context
    if handle not in CONTEXT_REGISTRY:
        return '{"success": false, "error": "Invalid context handle"}'

    val ctx = CONTEXT_REGISTRY[handle]

    # Parse inputs
    val template = parse_template_json(template_json)
    val types = parse_types_json(types_json)

    # Instantiate
    val result = ctx.instantiate_template(template, types)

    # Serialize result
    serialize_compilation_result(result)

fn compiler_get_stats(handle: i64) -> text:
    """Get compiler context statistics.

    Args:
        handle: Context handle

    Returns: Statistics as JSON
    """
    if handle not in CONTEXT_REGISTRY:
        return '{"error": "Invalid context handle"}'

    val ctx = CONTEXT_REGISTRY[handle]
    val stats = ctx.get_stats()

    '{"type_inferences": {stats.type_inferences}, "template_instantiations": {stats.template_instantiations}, "cache_hits": {stats.cache_hits}, "cache_misses": {stats.cache_misses}}'

# ============================================================================
# JSON Parsing Helpers
# ============================================================================

fn parse_template_json(json: text) -> Template:
    """Parse template from JSON.

    Input: {"name":"id","type_params":["T"]}
    """
    # TODO: Real JSON parsing
    # For now, simple extraction

    val name = extract_field(json, "name")
    val type_params = extract_array_field(json, "type_params")

    Template(
        name: name,
        type_params: type_params,
        param_types: None,
        return_type: None
    )

fn parse_hints_json(json: text) -> [TypeHint]:
    """Parse type hints from JSON.

    Input: [{"source":"call_site","param_index":0,"ty":{"kind":"int","bits":64,"signed":true}}]
    """
    # TODO: Real JSON parsing
    # For now, return single hint if it looks like a call site

    if json.contains("call_site"):
        [TypeHint(
            source: "call_site",
            param_index: Some(0),
            ty: TypeInfo(
                kind: "int",
                name: "i64",
                bits: Some(64),
                signed: Some(true),
                lanes: None,
                args: [],
                elem: None
            )
        )]
    else:
        []

fn parse_types_json(json: text) -> [TypeInfo]:
    """Parse types from JSON array.

    Input: [{"kind":"int","bits":64,"signed":true}]
    """
    # TODO: Real JSON parsing
    # For now, extract kind and return single type

    if json.contains("int"):
        [TypeInfo(
            kind: "int",
            name: "i64",
            bits: Some(64),
            signed: Some(true),
            lanes: None,
            args: [],
            elem: None
        )]
    else if json.contains("float"):
        [TypeInfo(
            kind: "float",
            name: "f64",
            bits: Some(64),
            signed: None,
            lanes: None,
            args: [],
            elem: None
        )]
    else:
        []

# ============================================================================
# JSON Serialization Helpers
# ============================================================================

fn serialize_types_json(types: [TypeInfo]) -> text:
    """Serialize types to JSON array.

    Output: [{"kind":"int","bits":64,"signed":true}]
    """
    var parts: [text] = []

    for ty in types:
        val ty_json = serialize_type_json(ty)
        parts.push(ty_json)

    "[{parts.join(",")}]"

fn serialize_type_json(ty: TypeInfo) -> text:
    """Serialize single type to JSON.

    Output: {"kind":"int","bits":64,"signed":true}
    """
    var fields: [text] = []

    fields.push('"kind":"{ty.kind}"')
    fields.push('"name":"{ty.name}"')

    if ty.bits.?:
        fields.push('"bits":{ty.bits.unwrap()}')

    if ty.signed.?:
        val signed_str = if ty.signed.unwrap(): "true" else: "false"
        fields.push('"signed":{signed_str}')

    "{{fields.join(",")}}"

fn serialize_compilation_result(result: CompilationResult) -> text:
    """Serialize compilation result to JSON.

    Output: {"success":true,"code":[1,2,3,4]}
    """
    if result.success:
        val code_bytes = result.code.unwrap()
        val code_str = code_bytes.map(\b: "{b}").join(",")
        '{"success":true,"code":[{code_str}]}'
    else:
        val error = result.error.unwrap_or("Unknown error")
        '{"success":false,"error":"{error}"}'

# ============================================================================
# Helper Functions
# ============================================================================

fn extract_field(json: text, field: text) -> text:
    """Extract field value from JSON.

    Input: {"name":"id"}, "name"
    Output: "id"
    """
    val pattern = '"{field}":"'
    val start_idx = json.find(pattern)

    if start_idx == -1:
        return ""

    val value_start = start_idx + pattern.len()
    val value_end = json.find('"', value_start)

    if value_end == -1:
        return ""

    json.substring(value_start, value_end)

fn extract_array_field(json: text, field: text) -> [text]:
    """Extract array field from JSON.

    Input: {"type_params":["T","U"]}, "type_params"
    Output: ["T", "U"]
    """
    val pattern = '"{field}":['
    val start_idx = json.find(pattern)

    if start_idx == -1:
        return []

    val array_start = start_idx + pattern.len()
    val array_end = json.find(']', array_start)

    if array_end == -1:
        return []

    val array_content = json.substring(array_start, array_end)

    # Split by comma and remove quotes
    array_content.split(',').map(\s: s.trim().replace('"', ''))

fn hints_to_key(hints: [TypeHint]) -> text:
    """Convert hints to cache key."""
    hints.map(\h: "{h.source}:{h.param_index.unwrap_or(0)}").join(":")

fn types_to_key(types: [TypeInfo]) -> text:
    """Convert types to cache key."""
    types.map(\t: "{t.kind}:{t.name}").join(":")

# ============================================================================
# Exports
# ============================================================================

export CompilerContext
export compiler_create_context
export create_compiler_context
export compiler_destroy_context
export compiler_infer_types
export compiler_check_types
export compiler_instantiate_template
export compiler_get_stats
export Template
export TypeInfo
export TypeHint
export CompilationResult
