# Compiler Error Types
#
# Comprehensive error handling for the Simple compiler.
# Port of rust/compiler/src/error.rs (1789 lines)
#
# Provides error types, diagnostic context, and error factory functions.

from error_codes import {*}  # Import all error codes
from parser_types import {Span}

export CompileError, ErrorContext, Severity
export error_factory  # Module containing all factory functions

# ============================================================================
# Error Severity
# ============================================================================

enum Severity:
    Error
    Warning
    Note
    Help

impl Severity:
    fn to_string() -> text:
        match self:
            Error: "error"
            Warning: "warning"
            Note: "note"
            Help: "help"

# ============================================================================
# Error Context
# ============================================================================

class ErrorContext:
    """Rich diagnostic context for errors with spans, labels, and suggestions."""

    span: Span?
    secondary_spans: [(Span, text)]
    file: text?
    source: text?
    code: text?
    notes: [text]
    help: [text]

impl ErrorContext:
    static fn empty() -> ErrorContext:
        """Create a new empty error context."""
        ErrorContext(
            span: None,
            secondary_spans: [],
            file: None,
            source: None,
            code: None,
            notes: [],
            help: []
        )

    fn with_span(span: Span) -> ErrorContext:
        """Set the primary span."""
        var ctx = self
        ctx.span = Some(span)
        ctx

    fn with_secondary(span: Span, label: text) -> ErrorContext:
        """Add a secondary span with a label."""
        var ctx = self
        ctx.secondary_spans.push((span, label))
        ctx

    fn with_file(file: text) -> ErrorContext:
        """Set the file path."""
        var ctx = self
        ctx.file = Some(file)
        ctx

    fn with_source(source: text) -> ErrorContext:
        """Set the source code."""
        var ctx = self
        ctx.source = Some(source)
        ctx

    fn with_code(code: text) -> ErrorContext:
        """Set the error code."""
        var ctx = self
        ctx.code = Some(code)
        ctx

    fn with_note(note: text) -> ErrorContext:
        """Add a note."""
        var ctx = self
        ctx.notes.push(note)
        ctx

    fn with_help(help: text) -> ErrorContext:
        """Add a help suggestion."""
        var ctx = self
        ctx.help.push(help)
        ctx

# ============================================================================
# Compile Error Enum
# ============================================================================

enum CompileError:
    """Compilation errors with optional rich context."""

    # Simple variants (message only)
    Io(text)
    Parse(text)
    Semantic(text)
    Codegen(text)
    Lint(text)
    Runtime(text)

    # Special variants
    TryError(Value)                              # Error from ? operator
    InterruptedByUser                            # Ctrl-C
    GhostError(text)                             # Ghost code verification

    # Execution limit variants
    ExecutionLimitExceeded(limit: i64, message: text)
    StackOverflow(depth: i64, limit: i64, function_name: text)
    TimeoutExceeded(timeout_secs: i64)

    # Rich variants with context
    IoWithContext(message: text, context: ErrorContext)
    ParseWithContext(message: text, context: ErrorContext)
    SemanticWithContext(message: text, context: ErrorContext)
    CodegenWithContext(message: text, context: ErrorContext)
    LintWithContext(message: text, context: ErrorContext)
    RuntimeWithContext(message: text, context: ErrorContext)

impl CompileError:
    # ========================================================================
    # Constructor functions for simple variants
    # ========================================================================

    static fn io(message: text) -> CompileError:
        """Create an I/O error with just a message."""
        CompileError.Io(message)

    static fn parse(message: text) -> CompileError:
        """Create a parse error with just a message."""
        CompileError.Parse(message)

    static fn semantic(message: text) -> CompileError:
        """Create a semantic error with just a message."""
        CompileError.Semantic(message)

    static fn codegen(message: text) -> CompileError:
        """Create a codegen error with just a message."""
        CompileError.Codegen(message)

    static fn lint(message: text) -> CompileError:
        """Create a lint error with just a message."""
        CompileError.Lint(message)

    static fn runtime(message: text) -> CompileError:
        """Create a runtime error with just a message."""
        CompileError.Runtime(message)

    # ========================================================================
    # Constructor functions for rich variants
    # ========================================================================

    static fn io_with_context(message: text, context: ErrorContext) -> CompileError:
        """Create an I/O error with rich context."""
        CompileError.IoWithContext(message, context)

    static fn parse_with_context(message: text, context: ErrorContext) -> CompileError:
        """Create a parse error with rich context."""
        CompileError.ParseWithContext(message, context)

    static fn semantic_with_context(message: text, context: ErrorContext) -> CompileError:
        """Create a semantic error with rich context."""
        CompileError.SemanticWithContext(message, context)

    static fn codegen_with_context(message: text, context: ErrorContext) -> CompileError:
        """Create a codegen error with rich context."""
        CompileError.CodegenWithContext(message, context)

    static fn lint_with_context(message: text, context: ErrorContext) -> CompileError:
        """Create a lint error with rich context."""
        CompileError.LintWithContext(message, context)

    static fn runtime_with_context(message: text, context: ErrorContext) -> CompileError:
        """Create a runtime error with rich context."""
        CompileError.RuntimeWithContext(message, context)

    # ========================================================================
    # Special constructors
    # ========================================================================

    static fn contract_violation(message: text) -> CompileError:
        """Create a contract violation error."""
        val ctx = ErrorContext.empty().with_code(CONTRACT_PRECONDITION_FAILED)
        CompileError.RuntimeWithContext(message, ctx)

    static fn execution_limit_exceeded(limit: i64, message: text) -> CompileError:
        """Create an execution limit exceeded error."""
        CompileError.ExecutionLimitExceeded(limit, message)

    static fn stack_overflow(depth: i64, limit: i64, function_name: text) -> CompileError:
        """Create a stack overflow error."""
        CompileError.StackOverflow(depth, limit, function_name)

    static fn timeout_exceeded(timeout_secs: i64) -> CompileError:
        """Create a timeout exceeded error."""
        CompileError.TimeoutExceeded(timeout_secs)

    static fn interrupted_by_user() -> CompileError:
        """Create an interrupted by user error (Ctrl-C)."""
        CompileError.InterruptedByUser

    static fn try_error(value: Value) -> CompileError:
        """Create a try error (? operator propagation)."""
        CompileError.TryError(value)

    static fn ghost_error(message: text) -> CompileError:
        """Create a ghost code verification error."""
        CompileError.GhostError(message)

    # ========================================================================
    # Utility methods
    # ========================================================================

    fn message() -> text:
        """Get the error message."""
        match self:
            Io(msg): msg
            Parse(msg): msg
            Semantic(msg): msg
            Codegen(msg): msg
            Lint(msg): msg
            Runtime(msg): msg
            GhostError(msg): msg
            TryError(_): "try error (? operator)"
            InterruptedByUser: "interrupted by user"
            ExecutionLimitExceeded(_, msg): msg
            StackOverflow(depth, limit, func): "stack overflow: recursion depth {depth} exceeded limit {limit} in function '{func}'"
            TimeoutExceeded(secs): "timeout: execution exceeded {secs} second limit"
            IoWithContext(msg, _): msg
            ParseWithContext(msg, _): msg
            SemanticWithContext(msg, _): msg
            CodegenWithContext(msg, _): msg
            LintWithContext(msg, _): msg
            RuntimeWithContext(msg, _): msg

    fn context() -> ErrorContext?:
        """Get the error context if this is a rich variant."""
        match self:
            IoWithContext(_, ctx): Some(ctx)
            ParseWithContext(_, ctx): Some(ctx)
            SemanticWithContext(_, ctx): Some(ctx)
            CodegenWithContext(_, ctx): Some(ctx)
            LintWithContext(_, ctx): Some(ctx)
            RuntimeWithContext(_, ctx): Some(ctx)
            _: None

    fn severity() -> Severity:
        """Get the error severity."""
        match self:
            Lint(_): Severity.Warning
            LintWithContext(_, _): Severity.Warning
            _: Severity.Error

# ============================================================================
# Error Factory Module
# ============================================================================

module error_factory:
    """Factory functions for creating common error types."""

    # ========================================================================
    # Module/Import Errors
    # ========================================================================

    fn module_not_found(module_name: text) -> CompileError:
        """Error when a module cannot be found."""
        val ctx = ErrorContext.empty().with_code(MODULE_NOT_FOUND)
        CompileError.semantic_with_context("Module '{module_name}' not found", ctx)

    fn module_not_found_with_paths(module_name: text, paths: [text]) -> CompileError:
        """Error when a module cannot be found, with search paths."""
        val paths_str = paths.map(\p: "  - {p}").join("\n")
        CompileError.semantic("Module '{module_name}' not found. Searched paths:\n{paths_str}")

    fn failed_to_read_file(path: text, error: text) -> CompileError:
        """Error when a file cannot be read."""
        CompileError.semantic("failed to read {path}: {error}")

    fn failed_to_parse_file(filename: text, error: text) -> CompileError:
        """Error when a file fails to parse."""
        CompileError.semantic("failed to parse {filename}: {error}")

    fn capability_violation(module_name: text, child_caps: text, parent_caps: text) -> CompileError:
        """Error when module capabilities are not a subset of parent capabilities."""
        CompileError.semantic("module '{module_name}' declares capabilities [{child_caps}] which are not a subset of parent capabilities [{parent_caps}]")

    # ========================================================================
    # Argument/Type Errors
    # ========================================================================

    fn argument_type_mismatch(index: i64, expected: text, found: text) -> CompileError:
        """Error when a function argument has an unexpected type."""
        CompileError.semantic("argument {index} must be {expected}, found {found}")

    fn argument_count_mismatch(expected: i64, found: i64) -> CompileError:
        """Error when a function receives the wrong number of arguments."""
        val ctx = ErrorContext.empty().with_code(ARGUMENT_COUNT_MISMATCH)
        CompileError.semantic_with_context("expected {expected} argument(s), found {found}", ctx)

    fn func_expects_args(func_name: text, expected: i64, found: i64) -> CompileError:
        """Error when a function expects a specific number of arguments."""
        CompileError.semantic("{func_name} expects {expected} argument(s), got {found}")

    fn func_expects_at_least(func_name: text, min: i64, found: i64) -> CompileError:
        """Error when a function expects at least N arguments."""
        CompileError.semantic("{func_name} expects at least {min} argument(s), got {found}")

    fn func_expects_type_at(func_name: text, expected_type: text, index: i64) -> CompileError:
        """Error when a function argument has the wrong type (with func name)."""
        CompileError.semantic("{func_name} expects {expected_type} argument at position {index}")

    fn missing_argument(name: text) -> CompileError:
        """Error when a required argument is missing."""
        CompileError.semantic("missing required argument: {name}")

    fn argument_must_be(index: i64, expected_type: text) -> CompileError:
        """Error when an argument must be a specific type."""
        CompileError.semantic("argument {index} must be {expected_type}")

    fn expects_lambda(operation: text) -> CompileError:
        """Error when an operation expects a lambda argument."""
        CompileError.semantic("{operation} expects lambda argument")

    fn const_binding_wrong_type(name: text, expected: text, found: text) -> CompileError:
        """Error when a const binding has wrong type."""
        CompileError.semantic("Const binding '{name}' is not {expected}: {found}")

    fn const_binding_not_found(name: text) -> CompileError:
        """Error when a const binding is not found."""
        CompileError.semantic("Const binding '{name}' not found")

    # ========================================================================
    # Macro Errors
    # ========================================================================

    fn unknown_macro(name: text) -> CompileError:
        """Error when an unknown macro is invoked."""
        CompileError.semantic("unknown macro: {name}!")

    fn macro_used_before_definition(name: text) -> CompileError:
        """Error when a macro is used before its definition."""
        CompileError.semantic("macro '{name}' used before definition")

    fn macro_invocation_failed(name: text, reason: text) -> CompileError:
        """Error when a macro invocation fails."""
        CompileError.semantic("macro '{name}' invocation failed: {reason}")

    fn panic_macro(message: text) -> CompileError:
        """Error when a panic! macro is invoked."""
        CompileError.semantic("panic: {message}")

    fn assertion_failed(left: text, right: text) -> CompileError:
        """Error when an assertion fails."""
        CompileError.semantic("assertion failed: {left} != {right}")

    fn unit_assertion_failed(error: text) -> CompileError:
        """Error when a unit assertion fails."""
        CompileError.semantic("unit assertion failed: {error}")

    fn invalid_unit_type(type_name: text) -> CompileError:
        """Error when a type is not a valid unit type."""
        CompileError.semantic("assert_unit: '{type_name}' is not a registered unit type (family or compound unit)")

    # ========================================================================
    # Type/Name Resolution Errors
    # ========================================================================

    fn type_not_found(type_name: text) -> CompileError:
        """Error when a type is not found."""
        val ctx = ErrorContext.empty().with_code(UNDEFINED_TYPE)
        CompileError.semantic_with_context("type '{type_name}' not found in this scope", ctx)

    fn variable_not_found(var_name: text) -> CompileError:
        """Error when a variable is not found."""
        val ctx = ErrorContext.empty().with_code(UNDEFINED_VARIABLE)
        CompileError.semantic_with_context("cannot find variable '{var_name}' in this scope", ctx)

    fn function_not_found(func_name: text) -> CompileError:
        """Error when a function is not found."""
        val ctx = ErrorContext.empty().with_code(UNDEFINED_FUNCTION)
        CompileError.semantic_with_context("cannot find function '{func_name}' in this scope", ctx)

    fn method_not_found(method_name: text, type_name: text) -> CompileError:
        """Error when a method is not found on a type."""
        val ctx = ErrorContext.empty().with_code(UNKNOWN_METHOD)
        CompileError.semantic_with_context("no method named '{method_name}' found for type '{type_name}'", ctx)

    fn field_not_found(field_name: text, type_name: text) -> CompileError:
        """Error when a field is not found on a struct/class."""
        val ctx = ErrorContext.empty().with_code(UNDEFINED_FIELD)
        CompileError.semantic_with_context("no field named '{field_name}' found on type '{type_name}'", ctx)

    # ========================================================================
    # Type Errors
    # ========================================================================

    fn type_mismatch(expected: text, found: text) -> CompileError:
        """Error when types don't match."""
        val ctx = ErrorContext.empty().with_code(TYPE_MISMATCH)
        CompileError.semantic_with_context("expected type {expected}, found {found}", ctx)

    fn invalid_operation(op: text, type_name: text) -> CompileError:
        """Error when an operation is invalid for a type."""
        val ctx = ErrorContext.empty().with_code(INVALID_OPERATION)
        CompileError.semantic_with_context("cannot apply operator '{op}' to type '{type_name}'", ctx)

    fn not_callable(type_name: text) -> CompileError:
        """Error when trying to call a non-callable type."""
        val ctx = ErrorContext.empty().with_code(NOT_CALLABLE)
        CompileError.semantic_with_context("type '{type_name}' is not callable", ctx)

    # ========================================================================
    # Control Flow Errors
    # ========================================================================

    fn break_outside_loop() -> CompileError:
        """Error when break is used outside a loop."""
        val ctx = ErrorContext.empty().with_code(BREAK_OUTSIDE_LOOP)
        CompileError.semantic_with_context("'break' outside of a loop", ctx)

    fn continue_outside_loop() -> CompileError:
        """Error when continue is used outside a loop."""
        val ctx = ErrorContext.empty().with_code(CONTINUE_OUTSIDE_LOOP)
        CompileError.semantic_with_context("'continue' outside of a loop", ctx)

    fn return_outside_function() -> CompileError:
        """Error when return is used outside a function."""
        val ctx = ErrorContext.empty().with_code(RETURN_OUTSIDE_FUNCTION)
        CompileError.semantic_with_context("'return' outside of a function", ctx)

    fn yield_outside_generator() -> CompileError:
        """Error when yield is used outside a generator."""
        val ctx = ErrorContext.empty().with_code(YIELD_OUTSIDE_GENERATOR)
        CompileError.semantic_with_context("'yield' outside of a generator", ctx)

    # ========================================================================
    # Pattern Errors
    # ========================================================================

    fn invalid_pattern(pattern_str: text, reason: text) -> CompileError:
        """Error when a pattern is invalid."""
        val ctx = ErrorContext.empty().with_code(INVALID_PATTERN)
        CompileError.semantic_with_context("invalid pattern {pattern_str}: {reason}", ctx)

    fn inconsistent_bindings(pattern_str: text) -> CompileError:
        """Error when pattern bindings are inconsistent."""
        val ctx = ErrorContext.empty().with_code(INCONSISTENT_BINDINGS)
        CompileError.semantic_with_context("inconsistent bindings in pattern {pattern_str}", ctx)

    # ========================================================================
    # Trait/Impl Errors
    # ========================================================================

    fn missing_trait_method(trait_name: text, method_name: text) -> CompileError:
        """Error when a required trait method is missing."""
        val ctx = ErrorContext.empty().with_code(MISSING_TRAIT_METHOD)
        CompileError.semantic_with_context("missing required method '{method_name}' for trait '{trait_name}'", ctx)

    fn duplicate_method(method_name: text, type_name: text) -> CompileError:
        """Error when a method is defined multiple times."""
        val ctx = ErrorContext.empty().with_code(DUPLICATE_METHOD)
        CompileError.semantic_with_context("duplicate definition of method '{method_name}' for type '{type_name}'", ctx)

    fn conflicting_trait_bounds(type_param: text) -> CompileError:
        """Error when trait bounds conflict."""
        val ctx = ErrorContext.empty().with_code(CONFLICTING_TRAIT_BOUNDS)
        CompileError.semantic_with_context("conflicting trait bounds for type parameter '{type_param}'", ctx)

    # ========================================================================
    # Codegen Errors
    # ========================================================================

    fn unsupported_feature(feature: text) -> CompileError:
        """Error when a language feature is not yet supported in codegen."""
        val ctx = ErrorContext.empty().with_code(UNSUPPORTED_FEATURE)
        CompileError.codegen_with_context("unsupported feature: {feature}", ctx)

    fn ffi_error(message: text) -> CompileError:
        """Error in FFI operations."""
        val ctx = ErrorContext.empty().with_code(FFI_ERROR)
        CompileError.codegen_with_context("FFI error: {message}", ctx)

    # ========================================================================
    # Runtime Errors
    # ========================================================================

    fn division_by_zero() -> CompileError:
        """Error when dividing by zero."""
        val ctx = ErrorContext.empty().with_code(DIVIDE_BY_ZERO)
        CompileError.runtime_with_context("division by zero", ctx)

    fn index_out_of_bounds(index: i64, length: i64) -> CompileError:
        """Error when array index is out of bounds."""
        val ctx = ErrorContext.empty().with_code(INDEX_OUT_OF_BOUNDS)
        CompileError.runtime_with_context("index {index} out of bounds for length {length}", ctx)

    fn null_pointer_dereference() -> CompileError:
        """Error when dereferencing a null pointer."""
        val ctx = ErrorContext.empty().with_code(NULL_DEREFERENCE)
        CompileError.runtime_with_context("null pointer dereference", ctx)
