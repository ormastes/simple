# Incremental Compilation
#
# Hash-based change detection and dependency-aware recompilation.
# Tracks content hashes, modification times, and dependency edges
# to minimize recompilation work.
#
# Port of rust/compiler/src/incremental.rs (410 lines)

export FileHash, IncrementalState, IncrementalConfig

# ============================================================================
# Types
# ============================================================================

struct FileHash:
    path: text
    content_hash: i64
    mtime_ms: i64

struct IncrementalConfig:
    """Configuration for incremental compilation."""
    enabled: bool
    cache_dir: text?
    max_staleness_ms: i64   # Max age before forcing recompile

impl IncrementalConfig:
    static fn default_config() -> IncrementalConfig:
        IncrementalConfig(enabled: true, cache_dir: nil, max_staleness_ms: 3600000)

    static fn disabled() -> IncrementalConfig:
        IncrementalConfig(enabled: false, cache_dir: nil, max_staleness_ms: 0)

# ============================================================================
# Incremental State
# ============================================================================

class IncrementalState:
    """Tracks file hashes and dependencies for change detection."""
    file_hashes: {text: FileHash}
    dependencies: {text: [text]}    # file -> files it depends on
    dependents: {text: [text]}      # file -> files that depend on it
    dirty_files: [text]

impl IncrementalState:
    static fn create() -> IncrementalState:
        IncrementalState(file_hashes: {}, dependencies: {},
                         dependents: {}, dirty_files: [])

    me register_file(path: text, content: text):
        extern fn rt_hash_text(t: text) -> i64
        extern fn rt_time_millis() -> i64
        # TODO: Replace direct FFI call with wrapper (hash_text) from app.io or compiler.ffi
        val hash = FileHash(path: path, content_hash: rt_hash_text(content),
                            # TODO: Replace direct FFI call with wrapper (time_millis) from app.io or compiler.ffi
                            mtime_ms: rt_time_millis())
        # Check if content changed
        if self.file_hashes.contains_key(path):
            val old = self.file_hashes[path]
            if old.content_hash != hash.content_hash:
                self.mark_dirty(path)
        self.file_hashes[path] = hash

    me add_dependency(from_file: text, to_file: text):
        """Record that from_file depends on to_file."""
        if not self.dependencies.contains_key(from_file):
            self.dependencies[from_file] = []
        val deps = self.dependencies[from_file]
        if not deps.contains(to_file):
            self.dependencies[from_file] = deps.push(to_file)

        # Track reverse dependency
        if not self.dependents.contains_key(to_file):
            self.dependents[to_file] = []
        val rev_deps = self.dependents[to_file]
        if not rev_deps.contains(from_file):
            self.dependents[to_file] = rev_deps.push(from_file)

    me mark_dirty(path: text):
        """Mark a file and its transitive dependents as dirty."""
        if self.dirty_files.contains(path):
            return
        self.dirty_files = self.dirty_files.push(path)

        # Cascade to dependents
        if self.dependents.contains_key(path):
            for dep in self.dependents[path]:
                self.mark_dirty(dep)

    fn is_dirty(path: text) -> bool:
        self.dirty_files.contains(path)

    fn get_dirty_files() -> [text]:
        self.dirty_files

    me clear_dirty():
        self.dirty_files = []

    fn needs_recompile(path: text) -> bool:
        """Check if a file needs recompilation."""
        if not self.file_hashes.contains_key(path):
            return true
        self.dirty_files.contains(path)

    me reset():
        self.file_hashes = {}
        self.dependencies = {}
        self.dependents = {}
        self.dirty_files = []
