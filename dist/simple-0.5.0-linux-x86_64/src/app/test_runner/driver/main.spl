# Test Runner Driver Main
#
# Main entry point for embedded test execution.
# Orchestrates loader, transport, and parser.

# =========================================================================
# Test Runner
# =========================================================================

class TestRunner:
    config: RunConfig
    loader: Loader
    transport: Transport
    parser: HostParser
    started: bool
    completed: bool

fn TestRunner_create(config: RunConfig) -> TestRunner:
    # Create loader config
    val loader_config = LoaderConfig(
        loader_type: config.loader_type,
        binary_path: config.binary_path,
        target_arch: config.target_arch,
        timeout_ms: config.timeout_ms,
        extra_args: config.extra_args
    )

    # Create transport config
    val transport_config = TransportConfig(
        transport_type: config.transport_type,
        path: config.transport_path,
        baudrate: 115200,
        timeout_ms: config.timeout_ms
    )

    # Create components
    val loader = Loader_create(loader_config)
    val transport = Transport_create(transport_config)
    val parser = if config.verbose:
        HostParser_verbose()
    else:
        HostParser_create()

    TestRunner(
        config: config,
        loader: loader,
        transport: transport,
        parser: parser,
        started: false,
        completed: false
    )

impl TestRunner:
    # Run all tests
    me run() -> i32:
        # Validate configuration
        val errors = validate_config(self.config)
        if errors.len() > 0:
            for err in errors:
                print "Error: {err}"
            return 1

        # Print header
        if self.config.verbose:
            self.print_header()

        # Start loader (launches QEMU or connects to target)
        val loader_result = self.loader.start()
        if not loader_result.success:
            print "Failed to start loader: {loader_result.error_message}"
            return 1

        self.started = true

        # Connect transport
        if not self.transport.connect():
            print "Failed to connect transport: {self.transport.get_error()}"
            self.loader.stop()
            return 1

        # Load SMF strings if available
        if self.config.has_smf():
            self.load_smf_strings()

        # Main loop: read from transport, feed to parser
        self.run_loop()

        # Cleanup
        self.transport.disconnect()
        self.loader.stop()

        # Return exit code
        if self.parser.is_success():
            0
        else:
            1

    me run_loop():
        # Simulated loop - real implementation would use async I/O
        # For now, just mark as completed
        self.completed = true

        # In real implementation:
        # while not self.completed:
        #     val data = self.transport.read_timeout(100)
        #     if data.len() > 0:
        #         self.parser.feed(data)
        #     # Check for completion message
        #     # Check for timeout

    me load_smf_strings():
        # Load interned strings from SMF files
        # In real implementation, would read SMF format
        if self.config.verbose:
            print "[INFO] Loading strings from {self.config.smf_root}"

    me print_header():
        print "=================================================="
        print "      Embedded Test Runner"
        print "=================================================="
        print "Binary:    {self.config.binary_path}"
        print "Arch:      {self.config.target_arch}"
        print "Loader:    {loader_name(self.config.loader_type)}"
        print "Timeout:   {self.config.timeout_ms}ms"
        print "=================================================="
        print ""

    fn get_results() -> TestResults:
        self.parser.get_results()

    fn is_success() -> bool:
        self.parser.is_success()

# =========================================================================
# Helper Functions
# =========================================================================

fn loader_name(loader_type: i32) -> text:
    if loader_type == 0:
        "QEMU"
    elif loader_type == 1:
        "OpenOCD"
    elif loader_type == 2:
        "J-Link"
    elif loader_type == 3:
        "Serial"
    else:
        "Unknown"

# =========================================================================
# Entry Point
# =========================================================================

fn run_embedded_tests(args: [text]) -> i32:
    # Parse arguments
    var parser = ArgParser_create(args)
    val config = parser.parse()

    # Check for parse errors
    if parser.has_errors():
        for err in parser.get_errors():
            print "Error: {err}"
        return 1

    # Create and run test runner
    var runner = TestRunner_create(config)
    runner.run()

# =========================================================================
# Type Definitions (from other modules)
# =========================================================================

# From config.spl
class RunConfig:
    loader_type: i32
    target_arch: text
    binary_path: text
    transport_type: i32
    transport_path: text
    timeout_ms: i64
    test_timeout_ms: i64
    format_type: i32
    color_output: bool
    verbose: bool
    smf_root: text
    extra_args: text

impl RunConfig:
    fn has_smf() -> bool:
        self.smf_root != ""

class ArgParser:
    args: [text]
    index: i32
    config: RunConfig
    errors: [text]

fn ArgParser_create(args: [text]) -> ArgParser:
    ArgParser(
        args: args,
        index: 0,
        config: RunConfig(
            loader_type: 0,
            target_arch: "x86",
            binary_path: "",
            transport_type: 0,
            transport_path: "",
            timeout_ms: 30000,
            test_timeout_ms: 5000,
            format_type: 0,
            color_output: true,
            verbose: false,
            smf_root: "",
            extra_args: ""
        ),
        errors: []
    )

impl ArgParser:
    fn has_next() -> bool:
        self.index < self.args.len() as i32

    me next() -> text:
        if self.has_next():
            val arg = self.args[self.index]
            self.index = self.index + 1
            arg
        else:
            ""

    me parse() -> RunConfig:
        while self.has_next():
            val arg = self.next()
            if arg == "--binary" or arg == "-b":
                self.config.binary_path = self.next()
            elif arg == "--arch" or arg == "-a":
                self.config.target_arch = self.next()
            elif arg == "--verbose" or arg == "-v":
                self.config.verbose = true
            elif arg.starts_with("-"):
                self.errors.push("Unknown option: {arg}")
            else:
                if self.config.binary_path == "":
                    self.config.binary_path = arg
        self.config

    fn has_errors() -> bool:
        self.errors.len() > 0

    fn get_errors() -> [text]:
        self.errors

fn validate_config(config: RunConfig) -> [text]:
    var errors: [text] = []
    if config.binary_path == "":
        errors.push("Binary path is required")
    errors

# From host/loader.spl
class LoaderConfig:
    loader_type: i32
    binary_path: text
    target_arch: text
    timeout_ms: i64
    extra_args: text

class LoaderResult:
    success: bool
    process_id: i32
    transport_path: text
    error_message: text

fn LoaderResult_failure(msg: text) -> LoaderResult:
    LoaderResult(success: false, process_id: 0, transport_path: "", error_message: msg)

fn LoaderResult_success(pid: i32, transport: text) -> LoaderResult:
    LoaderResult(success: true, process_id: pid, transport_path: transport, error_message: "")

class Loader:
    config: LoaderConfig
    result: LoaderResult
    running: bool

fn Loader_create(config: LoaderConfig) -> Loader:
    Loader(config: config, result: LoaderResult_failure("Not started"), running: false)

impl Loader:
    me start() -> LoaderResult:
        # Simulated start
        if self.config.binary_path == "":
            self.result = LoaderResult_failure("No binary path")
        else:
            self.result = LoaderResult_success(12345, "stdio")
            self.running = true
        self.result

    me stop():
        self.running = false

# From host/transport.spl
class TransportConfig:
    transport_type: i32
    path: text
    baudrate: i32
    timeout_ms: i64

class Transport:
    config: TransportConfig
    buffer: [i32]
    connected: bool
    error: text

fn Transport_create(config: TransportConfig) -> Transport:
    Transport(config: config, buffer: [], connected: false, error: "")

impl Transport:
    me connect() -> bool:
        self.connected = true
        true

    me disconnect():
        self.connected = false

    fn get_error() -> text:
        self.error

# From host/parser.spl
class StringInternEntry:
    handle: i32
    value: text

class StringInternTable:
    entries: [StringInternEntry]
    next_handle: i32

fn StringInternTable_empty() -> StringInternTable:
    StringInternTable(entries: [], next_handle: 1)

class TestResults:
    total: i32
    passed: i32
    failed: i32
    skipped: i32
    timeout: i32
    crashed: i32
    duration_ms: i64
    start_time_ms: i64
    end_time_ms: i64

fn TestResults_empty() -> TestResults:
    TestResults(total: 0, passed: 0, failed: 0, skipped: 0, timeout: 0, crashed: 0, duration_ms: 0, start_time_ms: 0, end_time_ms: 0)

impl TestResults:
    fn is_success() -> bool:
        self.failed == 0 and self.timeout == 0 and self.crashed == 0

class HostParser:
    buffer: [i32]
    string_table: StringInternTable
    results: TestResults
    current_suite: text
    verbose: bool

fn HostParser_create() -> HostParser:
    HostParser(buffer: [], string_table: StringInternTable_empty(), results: TestResults_empty(), current_suite: "", verbose: false)

fn HostParser_verbose() -> HostParser:
    HostParser(buffer: [], string_table: StringInternTable_empty(), results: TestResults_empty(), current_suite: "", verbose: true)

impl HostParser:
    fn is_success() -> bool:
        self.results.is_success()

    fn get_results() -> TestResults:
        self.results
