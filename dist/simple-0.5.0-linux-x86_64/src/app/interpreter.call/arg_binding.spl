# Argument Binding
#
# Bind function arguments to parameters with support for:
# - Positional arguments
# - Named/keyword arguments
# - Default values
# - Pattern destructuring
# - Variadic (*args)
# Port of rust/compiler/src/interpreter_call/core/arg_binding.rs

from ..core import {Interpreter, Value, InterpreterError}
from ..expr import {evaluate}
from ..control.match import {bind_pattern}

export bind_args, bind_named_args

# Bind arguments to function parameters
fn bind_args(interp: Interpreter, params: [ParamDef], args: [Value],
             named_args: Dict<text, Value>) -> Result<(), InterpreterError>:
    var positional_idx = 0

    for param in params:
        # Skip 'self' parameter (already bound by caller)
        if param.name == "self":
            continue

        # Check if this param was provided as a named arg
        if named_args.has(param.name):
            interp.env.define(param.name, named_args[param.name])
            continue

        # Check if we have a positional argument
        if positional_idx < args.len():
            # If param has a pattern, use pattern binding
            if param.pattern.?:
                bind_pattern(interp, param.pattern.unwrap(), args[positional_idx])
            else:
                interp.env.define(param.name, args[positional_idx])
            positional_idx = positional_idx + 1
            continue

        # Check for default value
        if param.default_value.?:
            val default = evaluate(interp, param.default_value.unwrap())?
            interp.env.define(param.name, default)
            continue

        # Check if variadic (*args)
        if param.is_variadic:
            val remaining = args[positional_idx..]
            interp.env.define(param.name, Value.array(remaining))
            positional_idx = args.len()
            continue

        # Missing required argument
        return Err(InterpreterError.ArityError(
            "missing required argument '{param.name}'"))

    # Check for extra positional arguments
    if positional_idx < args.len() and not params.any(\p: p.is_variadic):
        return Err(InterpreterError.ArityError(
            "too many arguments: expected {params.len()}, got {args.len()}"))

    Ok(())

# Bind only named arguments (for keyword-only functions)
fn bind_named_args(interp: Interpreter, params: [ParamDef],
                   named_args: Dict<text, Value>) -> Result<(), InterpreterError>:
    for param in params:
        if param.name == "self":
            continue
        if named_args.has(param.name):
            interp.env.define(param.name, named_args[param.name])
        elif param.default_value.?:
            val default = evaluate(interp, param.default_value.unwrap())?
            interp.env.define(param.name, default)
        else:
            return Err(InterpreterError.ArityError(
                "missing required named argument '{param.name}'"))
    Ok(())
