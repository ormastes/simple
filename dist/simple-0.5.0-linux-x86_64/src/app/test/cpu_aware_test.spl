#!/usr/bin/env simple
# CPU-aware test runner
# Automatically throttles test parallelism when system CPU usage is high
# Migrated from script/build/cpu-aware-test.sh
#
# Usage: cpu_aware_test [test-args...]
# Example: cpu_aware_test --workspace
#          cpu_aware_test -p simple-driver

use app.io
use app.utils.colors (success, error, warning, info)

export main, cpu_aware_test

struct TestConfig:
    cpu_threshold: i64
    throttled_threads: i64
    test_args: [text]

fn main():
    val args = get_args()
    val config = load_config(args)
    cpu_aware_test(config)

fn load_config(test_args: [text]) -> TestConfig:
    """Load configuration from environment and simple.test.toml"""

    # Default values
    var threshold = 70
    var threads = 1

    # Read from environment variables
    val env_threshold = env_get("CPU_THROTTLE_THRESHOLD")
    if env_threshold.len() > 0:
        threshold = env_threshold.parse_int().unwrap_or(70)

    val env_threads = env_get("CPU_THROTTLE_THREADS")
    if env_threads.len() > 0:
        threads = env_threads.parse_int().unwrap_or(1)

    # Read from simple.test.toml if available
    if file_exists("simple.test.toml"):
        val content = file_read("simple.test.toml")
        val lines = content.split("\n")

        for line in lines:
            if line.starts_with("threshold"):
                val value = extract_toml_value(line)
                if value.len() > 0:
                    threshold = value.parse_int().unwrap_or(threshold)
            elif line.starts_with("throttled_threads"):
                val value = extract_toml_value(line)
                if value.len() > 0:
                    threads = value.parse_int().unwrap_or(threads)

    TestConfig(
        cpu_threshold: threshold,
        throttled_threads: threads,
        test_args: test_args
    )

fn cpu_aware_test(config: TestConfig):
    """Run tests with CPU-aware throttling"""

    # Check CPU usage
    val cpu_usage = get_cpu_usage()

    print "Current CPU usage: {cpu_usage}% (threshold: {config.cpu_threshold}%)"

    var env_vars = []

    if cpu_usage >= config.cpu_threshold:
        print warning("CPU usage exceeds threshold. Throttling to {config.throttled_threads} thread(s).")
        env_vars = env_vars + ["RUST_TEST_THREADS={config.throttled_threads}"]
        env_vars = env_vars + ["RAYON_NUM_THREADS={config.throttled_threads}"]
    else:
        print success("CPU usage OK. Running with full parallelism.")

    # Build cargo test command
    var args = ["test"] + config.test_args
    val args_str = args.join(" ")

    print "Running: cargo {args_str}"
    print "---"

    # Set environment and run cargo test
    if env_vars.len() > 0:
        val env_str = env_vars.join(" ")
        val cmd = "{env_str} cargo {args_str}"
        val result = shell(cmd)
        exit(result.exit_code)
    else:
        val (_, _, code) = process_run("cargo", args)
        exit(code)

fn get_cpu_usage() -> i64:
    """Get current CPU usage percentage"""

    # Read /proc/stat twice with delay
    val stat1 = read_proc_stat()
    val (_, _, _) = process_run("sleep", ["0.5"])
    val stat2 = read_proc_stat()

    # Calculate usage
    val idle_diff = stat2.idle - stat1.idle
    val total_diff = stat2.total - stat1.total

    if total_diff == 0:
        return 0

    val usage = (total_diff - idle_diff) * 100 / total_diff
    usage

struct CpuStat:
    total: i64
    idle: i64

fn read_proc_stat() -> CpuStat:
    """Read CPU stats from /proc/stat"""

    val content = file_read("/proc/stat")
    val lines = content.split("\n")

    if lines.len() == 0:
        return CpuStat(total: 0, idle: 0)

    val cpu_line = lines[0]
    val parts = cpu_line.split(" ")

    # Parse: cpu user nice system idle iowait irq softirq
    # Skip first entry (cpu label) and empty strings
    var values = []
    for i in 1..parts.len():
        val part = parts[i].trim()
        if part.len() > 0:
            val num = part.parse_int().unwrap_or(0)
            values = values + [num]

    if values.len() < 7:
        return CpuStat(total: 0, idle: 0)

    val user = values[0]
    val nice = values[1]
    val system = values[2]
    val idle = values[3]
    val iowait = values[4]
    val irq = values[5]
    val softirq = values[6]

    val total = user + nice + system + idle + iowait + irq + softirq

    CpuStat(total: total, idle: idle)

fn extract_toml_value(line: text) -> text:
    """Extract value from TOML line (key = value)"""
    val eq_idx = line.find("=")
    if eq_idx < 0:
        return ""

    val value = line.substring(eq_idx + 1, line.len()).trim()
    value
