# Test Database Extended - Full Implementation
#
# Extended TestDatabase with complete feature set:
# - 8 tables (strings, files, suites, tests, counters, timing, timing_runs, changes)
# - StringInterner integration
# - Statistical analysis
# - Flaky test detection
# - Run management
#
# This extends the basic test.spl implementation.

use lib.database.core.{SdnDatabase, SdnTable, SdnRow}
use lib.database.stats.{Stats, is_flaky, update_baseline, is_significant_change}
use app.io.{rt_timestamp_now, rt_getpid, hostname, file_exists}

# ============================================================================
# StringInterner (for string deduplication)
# ============================================================================

class StringInterner:
    next_id: i64
    str_to_id: Dict<text, i64>
    id_to_str: Dict<i64, text>

    static fn empty() -> StringInterner:
        StringInterner(
            next_id: 0,
            str_to_id: {},
            id_to_str: {}
        )

    # Get or create string ID
    me intern(s: text) -> i64:
        if self.str_to_id.contains_key(s):
            return self.str_to_id[s]

        val id = self.next_id
        self.str_to_id[s] = id
        self.id_to_str[id] = s
        self.next_id = self.next_id + 1
        id

    # Get string by ID
    fn get(id: i64) -> text?:
        self.id_to_str.get(id)

    # Get all strings for serialization
    fn all_strings() -> [(i64, text)]:
        var result: [(i64, text)] = []
        for id in self.id_to_str.keys():
            val str_opt = self.id_to_str.get(id)
            if str_opt.?:
                result.push((id, str_opt?))
        result

# ============================================================================
# Extended Structs
# ============================================================================

struct FileRecord:
    file_id: i64
    path_str: i64  # String ID

struct SuiteRecord:
    suite_id: i64
    file_id: i64
    name_str: i64  # String ID

struct TestRecord:
    test_id: i64
    suite_id: i64
    name_str: i64      # String ID
    category_str: i64   # String ID
    status_str: i64     # String ID
    tags_str: i64       # String ID
    description_str: i64  # String ID
    valid: bool

struct CounterRecord:
    test_id: i64
    total_runs: i64
    passed: i64
    failed: i64
    crashed: i64
    timed_out: i64
    flaky_count: i64
    consecutive_passes: i64

struct TimingSummary:
    test_id: i64
    mean: f64
    p50: f64
    p90: f64
    p95: f64
    p99: f64
    iqr: f64
    has_baseline: bool
    baseline_p50: f64
    baseline_updated_at: text
    last_10_runs: text  # JSON array of recent timings

struct TimingRun:
    timing_run_id: i64
    test_id: i64
    duration_ms: f64
    run_id: text
    timestamp: text

struct ChangeEvent:
    change_id: i64
    test_id: i64
    timestamp: text
    event_type: text  # "status_change", "became_flaky", "baseline_update"
    from_status: text
    to_status: text
    description: text

struct RunRecord:
    run_id: text
    start_time: text
    end_time: text
    pid: i64
    hostname: text
    status: text
    test_count: i64
    passed: i64
    failed: i64
    crashed: i64
    timed_out: i64

struct TestInfo:
    test_name: text
    file_path: text
    suite_name: text
    category: text
    status: text
    valid: bool
    mean_duration: f64
    p50_duration: f64
    total_runs: i64
    passed: i64
    failed: i64
    is_flaky: bool

# ============================================================================
# Factory Functions
# ============================================================================

fn create_test_database_extended(path: text) -> TestDatabaseExtended:
    TestDatabaseExtended.create(path)

fn load_test_database_extended(path: text) -> TestDatabaseExtended?:
    val db_opt = SdnDatabase.load(path)
    if not db_opt.?:
        return None

    var db = db_opt?
    var interner = StringInterner.empty()

    # Load strings table to rebuild interner
    val strings_table_opt = db.get_table("strings")
    if strings_table_opt.?:
        val strings_table = strings_table_opt?
        for row in strings_table.valid_rows():
            val id = row.get("id")?.parse_i64()?
            val value = row.get("value")?
            interner.str_to_id[value] = id
            interner.id_to_str[id] = value
            if id >= interner.next_id:
                interner.next_id = id + 1

    Some(TestDatabaseExtended(
        db: db,
        interner: interner,
        next_file_id: 0,
        next_suite_id: 0,
        next_test_id: 0,
        next_timing_run_id: 0,
        next_change_id: 0
    ))

fn migrate_from_dual_file(
    stable_path: text,
    volatile_path: text,
    target_path: text
) -> bool:
    # Load stable database (files, suites, tests)
    val stable_db_opt = SdnDatabase.load(stable_path)
    if not stable_db_opt.?:
        return false

    # Load volatile database (counters, timing, runs)
    val volatile_db_opt = SdnDatabase.load(volatile_path)
    if not volatile_db_opt.?:
        return false

    # Create new unified database
    var target_db = create_test_database_extended(target_path)

    # Migrate stable data (strings, files, suites, tests)
    val stable_db = stable_db_opt?

    # Copy strings table
    val strings_opt = stable_db.get_table("strings")
    if strings_opt.?:
        target_db.db.set_table("strings", strings_opt?)

    # Copy files table
    val files_opt = stable_db.get_table("files")
    if files_opt.?:
        target_db.db.set_table("files", files_opt?)

    # Copy suites table
    val suites_opt = stable_db.get_table("suites")
    if suites_opt.?:
        target_db.db.set_table("suites", suites_opt?)

    # Copy tests table
    val tests_opt = stable_db.get_table("tests")
    if tests_opt.?:
        target_db.db.set_table("tests", tests_opt?)

    # Migrate volatile data (counters, timing, timing_runs, changes, test_runs)
    val volatile_db = volatile_db_opt?

    # Copy counters table
    val counters_opt = volatile_db.get_table("counters")
    if counters_opt.?:
        target_db.db.set_table("counters", counters_opt?)

    # Copy timing table
    val timing_opt = volatile_db.get_table("timing")
    if timing_opt.?:
        target_db.db.set_table("timing", timing_opt?)

    # Copy timing_runs table
    val timing_runs_opt = volatile_db.get_table("timing_runs")
    if timing_runs_opt.?:
        target_db.db.set_table("timing_runs", timing_runs_opt?)

    # Copy changes table
    val changes_opt = volatile_db.get_table("changes")
    if changes_opt.?:
        target_db.db.set_table("changes", changes_opt?)

    # Copy test_runs table
    val test_runs_opt = volatile_db.get_table("test_runs")
    if test_runs_opt.?:
        target_db.db.set_table("test_runs", test_runs_opt?)

    # Rebuild StringInterner from strings table
    val strings_table_opt = target_db.db.get_table("strings")
    if strings_table_opt.?:
        val strings_table = strings_table_opt?
        for row in strings_table.valid_rows():
            val id_opt = row.get("id")?.parse_i64()
            val value_opt = row.get("value")
            if id_opt.? and value_opt.?:
                val id = id_opt?
                val value = value_opt?
                target_db.interner.str_to_id[value] = id
                target_db.interner.id_to_str[id] = value
                if id >= target_db.interner.next_id:
                    target_db.interner.next_id = id + 1

    # Save unified database
    target_db.save()

fn load_with_migration(base_path: text) -> TestDatabaseExtended?:
    # Try loading unified file first
    val unified_path = "{base_path}.sdn"
    if file_exists(unified_path):
        return load_test_database_extended(unified_path)

    # Check if old dual-file format exists
    val stable_path = "{base_path}_stable.sdn"
    val volatile_path = "{base_path}_runs.sdn"

    if file_exists(stable_path) and file_exists(volatile_path):
        # Migrate from dual-file to single-file
        val success = migrate_from_dual_file(stable_path, volatile_path, unified_path)
        if not success:
            return None

        # Load the migrated database
        return load_test_database_extended(unified_path)

    # No database found
    None

# ============================================================================
# Extended TestDatabase
# ============================================================================

class TestDatabaseExtended:
    db: SdnDatabase
    interner: StringInterner
    next_file_id: i64
    next_suite_id: i64
    next_test_id: i64
    next_timing_run_id: i64
    next_change_id: i64

    # Create extended database with all tables
    static fn create(path: text) -> TestDatabaseExtended:
        var db = SdnDatabase.new(path)

        # Table 1: strings
        val strings_table = SdnTable.new("strings", ["id", "value"])
        db.set_table("strings", strings_table)

        # Table 2: files
        val files_table = SdnTable.new("files", ["file_id", "path_str"])
        db.set_table("files", files_table)

        # Table 3: suites
        val suites_table = SdnTable.new("suites", ["suite_id", "file_id", "name_str"])
        db.set_table("suites", suites_table)

        # Table 4: tests
        val tests_table = SdnTable.new("tests", [
            "test_id", "suite_id", "name_str", "category_str",
            "status_str", "tags_str", "description_str", "valid"
        ])
        db.set_table("tests", tests_table)

        # Table 5: counters
        val counters_table = SdnTable.new("counters", [
            "test_id", "total_runs", "passed", "failed", "crashed",
            "timed_out", "flaky_count", "consecutive_passes"
        ])
        db.set_table("counters", counters_table)

        # Table 6: timing
        val timing_table = SdnTable.new("timing", [
            "test_id", "mean", "p50", "p90", "p95", "p99", "iqr",
            "has_baseline", "baseline_p50", "baseline_updated_at", "last_10_runs"
        ])
        db.set_table("timing", timing_table)

        # Table 7: timing_runs
        val timing_runs_table = SdnTable.new("timing_runs", [
            "timing_run_id", "test_id", "duration_ms", "run_id", "timestamp"
        ])
        db.set_table("timing_runs", timing_runs_table)

        # Table 8: changes
        val changes_table = SdnTable.new("changes", [
            "change_id", "test_id", "timestamp", "event_type",
            "from_status", "to_status", "description"
        ])
        db.set_table("changes", changes_table)

        # Also add test_runs table (from base implementation)
        val runs_table = SdnTable.new("test_runs", [
            "run_id", "start_time", "end_time", "pid", "hostname",
            "status", "test_count", "passed", "failed", "crashed", "timed_out", "valid"
        ])
        db.set_table("test_runs", runs_table)

        TestDatabaseExtended(
            db: db,
            interner: StringInterner.empty(),
            next_file_id: 0,
            next_suite_id: 0,
            next_test_id: 0,
            next_timing_run_id: 0,
            next_change_id: 0
        )

    # ========================================================================
    # Core Helper Methods
    # ========================================================================

    # Get or create file record
    me get_or_create_file(path: text) -> i64:
        val path_id = self.interner.intern(path)

        # Check if file exists
        val files_table = self.db.get_table("files")?
        for row in files_table.rows:
            val row_path_str = row.get_i64("path_str")?
            if row_path_str == path_id:
                return row.get_i64("file_id")?

        # Create new file
        val file_id = self.next_file_id
        self.next_file_id = self.next_file_id + 1

        var files_table_mut = self.db.get_table_mut("files")?
        val row = SdnRow.empty()
        row.set("file_id", "{file_id}")
        row.set("path_str", "{path_id}")
        files_table_mut.add_row(row)
        self.db.set_table("files", files_table_mut)

        file_id

    # Get or create suite record
    me get_or_create_suite(file_path: text, suite_name: text) -> i64:
        val file_id = self.get_or_create_file(file_path)
        val name_id = self.interner.intern(suite_name)

        # Check if suite exists
        val suites_table = self.db.get_table("suites")?
        for row in suites_table.rows:
            val row_file_id = row.get_i64("file_id")?
            val row_name_str = row.get_i64("name_str")?
            if row_file_id == file_id and row_name_str == name_id:
                return row.get_i64("suite_id")?

        # Create new suite
        val suite_id = self.next_suite_id
        self.next_suite_id = self.next_suite_id + 1

        var suites_table_mut = self.db.get_table_mut("suites")?
        val row = SdnRow.empty()
        row.set("suite_id", "{suite_id}")
        row.set("file_id", "{file_id}")
        row.set("name_str", "{name_id}")
        suites_table_mut.add_row(row)
        self.db.set_table("suites", suites_table_mut)

        suite_id

    # Get or create test record
    me get_or_create_test(suite_id: i64, test_name: text) -> i64:
        val name_id = self.interner.intern(test_name)

        # Check if test exists
        val tests_table = self.db.get_table("tests")?
        for row in tests_table.rows:
            val row_suite_id = row.get_i64("suite_id")?
            val row_name_str = row.get_i64("name_str")?
            if row_suite_id == suite_id and row_name_str == name_id:
                return row.get_i64("test_id")?

        # Create new test
        val test_id = self.next_test_id
        self.next_test_id = self.next_test_id + 1

        var tests_table_mut = self.db.get_table_mut("tests")?
        val row = SdnRow.empty()
        row.set("test_id", "{test_id}")
        row.set("suite_id", "{suite_id}")
        row.set("name_str", "{name_id}")
        row.set("category_str", "0")  # Default category
        row.set("status_str", "{self.interner.intern("unknown")}")
        row.set("tags_str", "0")
        row.set("description_str", "0")
        row.set("valid", "true")
        tests_table_mut.add_row(row)
        self.db.set_table("tests", tests_table_mut)

        test_id

    # ========================================================================
    # Test Result Tracking
    # ========================================================================

    # Main method: Update test result and statistics
    me update_test_result(
        file_path: text,
        suite_name: text,
        test_name: text,
        status: text,
        duration_ms: f64,
        run_id: text
    ):
        # 1. Get or create hierarchy
        val test_id = self.get_or_create_test(
            self.get_or_create_suite(file_path, suite_name),
            test_name
        )

        # 2. Update counter
        self.update_counter(test_id, status)

        # 3. Update timing
        self.update_timing(test_id, duration_ms)

        # 4. Add timing run
        self.add_timing_run(test_id, duration_ms, run_id)

    # Update counter for test
    me update_counter(test_id: i64, status: text):
        var counters_table = self.db.get_table_mut("counters")?

        # Find existing counter
        var found = false
        var counter_row = SdnRow.empty()
        for row in counters_table.rows:
            if row.get_i64("test_id")? == test_id:
                counter_row = row
                found = true
                break

        if not found:
            # Create new counter
            counter_row.set("test_id", "{test_id}")
            counter_row.set("total_runs", "1")
            counter_row.set("passed", if status == "passed": "1" else: "0")
            counter_row.set("failed", if status == "failed": "1" else: "0")
            counter_row.set("crashed", if status == "crashed": "1" else: "0")
            counter_row.set("timed_out", if status == "timed_out": "1" else: "0")
            counter_row.set("flaky_count", "0")
            counter_row.set("consecutive_passes", if status == "passed": "1" else: "0")
            counters_table.add_row(counter_row)
        else:
            # Update existing counter
            val total = counter_row.get_i64("total_runs")? + 1
            counter_row.set("total_runs", "{total}")

            if status == "passed":
                val passed = counter_row.get_i64("passed")? + 1
                val consec = counter_row.get_i64("consecutive_passes")? + 1
                counter_row.set("passed", "{passed}")
                counter_row.set("consecutive_passes", "{consec}")
            else:
                counter_row.set("consecutive_passes", "0")

                if status == "failed":
                    val failed = counter_row.get_i64("failed")? + 1
                    counter_row.set("failed", "{failed}")
                elif status == "crashed":
                    val crashed = counter_row.get_i64("crashed")? + 1
                    counter_row.set("crashed", "{crashed}")
                elif status == "timed_out":
                    val timed = counter_row.get_i64("timed_out")? + 1
                    counter_row.set("timed_out", "{timed}")

            counters_table.update_row("{test_id}", counter_row)

        self.db.set_table("counters", counters_table)

    # Update timing statistics for test
    me update_timing(test_id: i64, duration_ms: f64):
        # Collect recent timing runs
        val recent_runs = self.collect_timing_runs(test_id, 100)  # Last 100 runs

        if recent_runs.len() == 0:
            return

        # Compute statistics
        val stats = Stats.from_values(recent_runs)

        # Get or create timing record
        var timing_table = self.db.get_table_mut("timing")?
        var found = false
        var timing_row = SdnRow.empty()

        for row in timing_table.rows:
            if row.get_i64("test_id")? == test_id:
                timing_row = row
                found = true
                break

        # Update statistics
        timing_row.set("test_id", "{test_id}")
        timing_row.set("mean", "{stats.mean}")
        timing_row.set("p50", "{stats.p50}")
        timing_row.set("p90", "{stats.p90}")
        timing_row.set("p95", "{stats.p95}")
        timing_row.set("p99", "{stats.p99}")
        timing_row.set("iqr", "{stats.iqr}")

        # Store last 10 runs as JSON-like string
        val last_10 = if recent_runs.len() > 10:
            recent_runs[recent_runs.len() - 10:]
        else:
            recent_runs
        val last_10_str = "[{last_10.join(",")}]"
        timing_row.set("last_10_runs", last_10_str)

        # Update baseline if significant change or no baseline
        val has_baseline = timing_row.get("has_baseline")? == "true"
        if not has_baseline:
            timing_row.set("has_baseline", "true")
            timing_row.set("baseline_p50", "{stats.p50}")
            timing_row.set("baseline_updated_at", "{rt_timestamp_now()}")
        else:
            val baseline = timing_row.get("baseline_p50")?.to_float()
            if is_significant_change(baseline, stats.p50, 20.0):  # 20% threshold
                val new_baseline = update_baseline(baseline, stats.p50, 0.3)
                timing_row.set("baseline_p50", "{new_baseline}")
                timing_row.set("baseline_updated_at", "{rt_timestamp_now()}")

        if found:
            timing_table.update_row("{test_id}", timing_row)
        else:
            timing_table.add_row(timing_row)

        self.db.set_table("timing", timing_table)

    # Add timing run record
    me add_timing_run(test_id: i64, duration_ms: f64, run_id: text):
        var timing_runs_table = self.db.get_table_mut("timing_runs")?

        val timing_run_id = self.next_timing_run_id
        self.next_timing_run_id = self.next_timing_run_id + 1

        val row = SdnRow.empty()
        row.set("timing_run_id", "{timing_run_id}")
        row.set("test_id", "{test_id}")
        row.set("duration_ms", "{duration_ms}")
        row.set("run_id", run_id)
        row.set("timestamp", "{rt_timestamp_now()}")

        timing_runs_table.add_row(row)
        self.db.set_table("timing_runs", timing_runs_table)

    # Collect timing runs for a test (most recent N)
    fn collect_timing_runs(test_id: i64, max_count: i64) -> [f64]:
        val timing_runs_table = self.db.get_table("timing_runs")?
        var timings: [f64] = []

        for row in timing_runs_table.rows:
            if row.get_i64("test_id")? == test_id:
                val duration_str = row.get("duration_ms")?
                val duration = duration_str.to_float()
                timings.push(duration)

        # Return most recent max_count
        if timings.len() > max_count:
            timings[timings.len() - max_count:]
        else:
            timings

    # ========================================================================
    # Flaky Test Detection
    # ========================================================================

    # Check if test is flaky
    fn is_flaky_test(test_id: i64) -> bool:
        val recent_runs = self.collect_timing_runs(test_id, 10)
        if recent_runs.len() < 3:
            return false  # Need at least 3 runs

        is_flaky(recent_runs, 0.5)  # 50% CV threshold

    # ========================================================================
    # Run Management
    # ========================================================================

    # Start new test run
    me start_run() -> text:
        val run_id = "run_{rt_timestamp_now()}"

        var runs_table = self.db.get_table_mut("test_runs")?
        val row = SdnRow.empty()
        row.set("run_id", run_id)
        row.set("start_time", "{rt_timestamp_now()}")
        row.set("end_time", "")
        row.set("pid", "{rt_getpid()}")
        row.set("hostname", hostname())
        row.set("status", "running")
        row.set("test_count", "0")
        row.set("passed", "0")
        row.set("failed", "0")
        row.set("crashed", "0")
        row.set("timed_out", "0")
        row.set("valid", "true")

        runs_table.add_row(row)
        self.db.set_table("test_runs", runs_table)

        run_id

    # Complete test run
    me complete_run(
        run_id: text,
        test_count: i64,
        passed: i64,
        failed: i64,
        timed_out: i64
    ):
        var runs_table = self.db.get_table_mut("test_runs")?

        for row in runs_table.rows:
            if row.get("run_id")? == run_id:
                row.set("end_time", "{rt_timestamp_now()}")
                row.set("status", "completed")
                row.set("test_count", "{test_count}")
                row.set("passed", "{passed}")
                row.set("failed", "{failed}")
                row.set("timed_out", "{timed_out}")
                runs_table.update_row(run_id, row)
                break

        self.db.set_table("test_runs", runs_table)

    # Cleanup stale runs (running > max_age_hours)
    me cleanup_stale_runs(max_age_hours: i64) -> i64:
        val now = rt_timestamp_now()
        val max_age_micros = max_age_hours * 3600 * 1000000
        var cleaned = 0

        var runs_table = self.db.get_table_mut("test_runs")?
        for row in runs_table.rows:
            if row.get("status")? == "running":
                val start_time = row.get("start_time")?.to_int_or(0)
                val age = now - start_time
                if age > max_age_micros:
                    row.set("status", "crashed")
                    row.set("end_time", "{now}")
                    runs_table.update_row(row.get("run_id")?, row)
                    cleaned = cleaned + 1

        self.db.set_table("test_runs", runs_table)
        cleaned

    # Prune old runs (keep only N most recent)
    me prune_runs(keep_count: i64) -> i64:
        val runs_table = self.db.get_table("test_runs")?
        var all_runs: [(text, i64)] = []  # (run_id, start_time)

        for row in runs_table.rows:
            val run_id = row.get("run_id")?
            val start_time = row.get("start_time")?.to_int_or(0)
            all_runs.push((run_id, start_time))

        # Sort by start_time descending (most recent first)
        all_runs.sort_by(\a, b: b.1 - a.1)

        # Delete old runs
        var deleted = 0
        if all_runs.len() > keep_count:
            var runs_table_mut = self.db.get_table_mut("test_runs")?
            var i = keep_count
            while i < all_runs.len():
                runs_table_mut.delete_row(all_runs[i].0)
                deleted = deleted + 1
                i = i + 1
            self.db.set_table("test_runs", runs_table_mut)

        deleted

    # ========================================================================
    # Query Methods
    # ========================================================================

    # Get file ID by path
    fn get_file_id(path: text) -> i64?:
        val path_id = self.interner.intern(path)
        val files_table = self.db.get_table("files")?

        for row in files_table.valid_rows():
            val path_str = row.get("path_str")?.parse_i64()?
            if path_str == path_id:
                return row.get("file_id")?.parse_i64()

        None

    # Get suite ID by file path and suite name
    fn get_suite_id(file_path: text, suite_name: text) -> i64?:
        val file_id = self.get_file_id(file_path)?
        val name_id = self.interner.intern(suite_name)
        val suites_table = self.db.get_table("suites")?

        for row in suites_table.valid_rows():
            val row_file_id = row.get("file_id")?.parse_i64()?
            val name_str = row.get("name_str")?.parse_i64()?
            if row_file_id == file_id and name_str == name_id:
                return row.get("suite_id")?.parse_i64()

        None

    # Get test ID by file path, suite name, and test name
    fn get_test_id(file_path: text, suite_name: text, test_name: text) -> i64?:
        val suite_id = self.get_suite_id(file_path, suite_name)?
        val name_id = self.interner.intern(test_name)
        val tests_table = self.db.get_table("tests")?

        for row in tests_table.valid_rows():
            val row_suite_id = row.get("suite_id")?.parse_i64()?
            val name_str = row.get("name_str")?.parse_i64()?
            if row_suite_id == suite_id and name_str == name_id:
                return row.get("test_id")?.parse_i64()

        None

    # Get counter by test ID
    fn get_counter(test_id: i64) -> CounterRecord?:
        val counters_table = self.db.get_table("counters")?

        for row in counters_table.valid_rows():
            val row_test_id = row.get("test_id")?.parse_i64()?
            if row_test_id == test_id:
                return Some(CounterRecord(
                    test_id: test_id,
                    total_runs: row.get("total_runs")?.parse_i64()?,
                    passed: row.get("passed")?.parse_i64()?,
                    failed: row.get("failed")?.parse_i64()?,
                    crashed: row.get("crashed")?.parse_i64()?,
                    timed_out: row.get("timed_out")?.parse_i64()?,
                    flaky_count: row.get("flaky_count")?.parse_i64()?,
                    consecutive_passes: row.get("consecutive_passes")?.parse_i64()?
                ))

        None

    # Get timing summary by test ID
    fn get_timing_summary(test_id: i64) -> TimingSummary?:
        val timing_table = self.db.get_table("timing")?

        for row in timing_table.valid_rows():
            val row_test_id = row.get("test_id")?.parse_i64()?
            if row_test_id == test_id:
                return Some(TimingSummary(
                    test_id: test_id,
                    mean: row.get("mean")?.parse_f64()?,
                    p50: row.get("p50")?.parse_f64()?,
                    p90: row.get("p90")?.parse_f64()?,
                    p95: row.get("p95")?.parse_f64()?,
                    p99: row.get("p99")?.parse_f64()?,
                    iqr: row.get("iqr")?.parse_f64()?,
                    has_baseline: row.get("has_baseline")? == "true",
                    baseline_p50: row.get("baseline_p50")?.parse_f64()?,
                    baseline_updated_at: row.get("baseline_updated_at")?,
                    last_10_runs: row.get("last_10_runs")?
                ))

        None

    # List test runs
    fn list_runs(status_filter: text) -> [RunRecord]:
        var result: [RunRecord] = []
        val runs_table_opt = self.db.get_table("test_runs")
        if not runs_table_opt.?:
            return result

        val runs_table = runs_table_opt?
        for row in runs_table.valid_rows():
            val status = row.get("status")?
            if status_filter != "" and status != status_filter:
                continue

            val record = RunRecord(
                run_id: row.get("run_id")?,
                start_time: row.get("start_time")?,
                end_time: row.get("end_time")?,
                pid: row.get("pid")?.parse_i64()?,
                hostname: row.get("hostname")?,
                status: status,
                test_count: row.get("test_count")?.parse_i64()?,
                passed: row.get("passed")?.parse_i64()?,
                failed: row.get("failed")?.parse_i64()?,
                crashed: row.get("crashed")?.parse_i64()?,
                timed_out: row.get("timed_out")?.parse_i64()?
            )
            result.push(record)

        result

    # ========================================================================
    # Documentation Query Methods
    # ========================================================================

    # Get all test information (for doc generation)
    fn all_test_info() -> [TestInfo]:
        var result: [TestInfo] = []
        val tests_table = self.db.get_table("tests")?

        for test_row in tests_table.valid_rows():
            val test_id = test_row.get("test_id")?.parse_i64()?
            val suite_id = test_row.get("suite_id")?.parse_i64()?
            val name_str = test_row.get("name_str")?.parse_i64()?
            val category_str = test_row.get("category_str")?.parse_i64()?
            val status_str = test_row.get("status_str")?.parse_i64()?

            # Get test name
            val test_name = self.interner.get(name_str) ?? ""

            # Get suite name and file path
            val (file_path, suite_name) = self.get_suite_info(suite_id) ?? ("", "")

            # Get category
            val category = self.interner.get(category_str) ?? "uncategorized"

            # Get status
            val status = self.interner.get(status_str) ?? "unknown"

            # Get valid flag
            val valid = test_row.get("valid")? == "true"

            # Get timing info
            val (mean, p50) = self.get_test_timing(test_id) ?? (0.0, 0.0)

            # Get counter info
            val (total_runs, passed, failed) = self.get_test_counts(test_id) ?? (0, 0, 0)

            # Check if flaky
            val is_flaky = self.is_flaky_test(test_id)

            result.push(TestInfo(
                test_name: test_name,
                file_path: file_path,
                suite_name: suite_name,
                category: category,
                status: status,
                valid: valid,
                mean_duration: mean,
                p50_duration: p50,
                total_runs: total_runs,
                passed: passed,
                failed: failed,
                is_flaky: is_flaky
            ))

        result

    # Get tests filtered by status
    fn tests_by_status(status_filter: text) -> [TestInfo]:
        val all_tests = self.all_test_info()
        all_tests.filter(\t: t.status == status_filter)

    # Count tests by status
    fn test_count_by_status() -> (i64, i64, i64, i64):
        val all_tests = self.all_test_info()
        var total = all_tests.len()
        var passed = 0
        var failed = 0
        var skipped = 0

        for t in all_tests:
            if t.status == "passed":
                passed = passed + 1
            elif t.status == "failed":
                failed = failed + 1
            elif t.status == "skipped" or t.status == "ignored":
                skipped = skipped + 1

        (total, passed, failed, skipped)

    # Get list of flaky test names
    fn flaky_test_names() -> [text]:
        val all_tests = self.all_test_info()
        var result: [text] = []

        for t in all_tests:
            if t.is_flaky:
                result.push(t.test_name)

        result

    # Helper: Get suite info (file_path, suite_name)
    fn get_suite_info(suite_id: i64) -> (text, text)?:
        val suites_table = self.db.get_table("suites")?

        for row in suites_table.valid_rows():
            val row_suite_id = row.get("suite_id")?.parse_i64()?
            if row_suite_id == suite_id:
                val file_id = row.get("file_id")?.parse_i64()?
                val name_str = row.get("name_str")?.parse_i64()?

                # Get file path
                val file_path = self.get_file_path(file_id) ?? ""

                # Get suite name
                val suite_name = self.interner.get(name_str) ?? ""

                return Some((file_path, suite_name))

        None

    # Helper: Get file path by ID
    fn get_file_path(file_id: i64) -> text?:
        val files_table = self.db.get_table("files")?

        for row in files_table.valid_rows():
            val row_file_id = row.get("file_id")?.parse_i64()?
            if row_file_id == file_id:
                val path_str = row.get("path_str")?.parse_i64()?
                return self.interner.get(path_str)

        None

    # Helper: Get test timing (mean, p50)
    fn get_test_timing(test_id: i64) -> (f64, f64)?:
        val timing_table = self.db.get_table("timing")?

        for row in timing_table.valid_rows():
            val row_test_id = row.get("test_id")?.parse_i64()?
            if row_test_id == test_id:
                val mean = row.get("mean")?.parse_f64()?
                val p50 = row.get("p50")?.parse_f64()?
                return Some((mean, p50))

        None

    # Helper: Get test counts (total_runs, passed, failed)
    fn get_test_counts(test_id: i64) -> (i64, i64, i64)?:
        val counters_table = self.db.get_table("counters")?

        for row in counters_table.valid_rows():
            val row_test_id = row.get("test_id")?.parse_i64()?
            if row_test_id == test_id:
                val total_runs = row.get("total_runs")?.parse_i64()?
                val passed = row.get("passed")?.parse_i64()?
                val failed = row.get("failed")?.parse_i64()?
                return Some((total_runs, passed, failed))

        None

    # Save database
    me save() -> bool:
        # First, save string interner to strings table
        var strings_table = self.db.get_table_mut("strings")?
        strings_table.clear()
        for (id, value) in self.interner.all_strings():
            val row = SdnRow.empty()
            row.set("id", "{id}")
            row.set("value", value)
            strings_table.add_row(row)
        self.db.set_table("strings", strings_table)

        # Save database
        self.db.save()

export StringInterner
export FileRecord, SuiteRecord, TestRecord, CounterRecord
export TimingSummary, TimingRun, ChangeEvent, RunRecord, TestInfo
export TestDatabaseExtended
export create_test_database_extended, load_test_database_extended
export migrate_from_dual_file, load_with_migration
