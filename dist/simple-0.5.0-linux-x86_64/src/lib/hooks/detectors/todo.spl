# TODO Detector
# Parses doc/todo/todo_db.sdn and filters high-priority items

export TodoSummary, detect_todos, get_priority_value

# TODO summary
struct TodoSummary:
    total: i64
    p0_count: i64
    p1_count: i64
    p2_count: i64
    p3_count: i64
    high_priority_items: [TodoItem]

# TODO item
struct TodoItem:
    id: i64
    keyword: text
    area: text
    priority: text
    description: text
    file: text
    line: i64

# Detect high-priority TODOs
fn detect_todos(db_path: text, priority_threshold: i64) -> TodoSummary:
    val summary = TodoSummary(
        total: 0,
        p0_count: 0,
        p1_count: 0,
        p2_count: 0,
        p3_count: 0,
        high_priority_items: []
    )

    # Check if DB exists
    if not file_exists(db_path):
        return summary

    # Parse SDN file
    val content = file_read(db_path)
    val items = parse_todo_db(content)

    # Count by priority
    var p0 = 0
    var p1 = 0
    var p2 = 0
    var p3 = 0
    var high_priority = []

    for item in items:
        val priority_value = get_priority_value(item.priority)

        if priority_value == 0:
            p0 = p0 + 1
        else if priority_value == 1:
            p1 = p1 + 1
        else if priority_value == 2:
            p2 = p2 + 1
        else if priority_value == 3:
            p3 = p3 + 1

        # Add to high priority list if meets threshold
        if priority_value <= priority_threshold:
            high_priority.push(item)

    TodoSummary(
        total: items.len(),
        p0_count: p0,
        p1_count: p1,
        p2_count: p2,
        p3_count: p3,
        high_priority_items: high_priority
    )

# Parse TODO database SDN format
fn parse_todo_db(content: text) -> [TodoItem]:
    var items = []
    val lines = content.split("\n")

    var in_table = false
    var columns = []

    for line in lines:
        val trimmed = line.trim()

        # Skip comments and empty lines
        if trimmed.starts_with("#") or trimmed.len() == 0:
            continue

        # Parse table header
        if trimmed.contains("|") and trimmed.starts_with("todos"):
            val parts = trimmed.split("|")
            if parts.len() >= 2:
                columns = parts[1].split(",").map(\c: c.trim())
                in_table = true
            continue

        # Parse table row
        if in_table:
            if not trimmed.contains(","):
                in_table = false
                continue

            val values = parse_row_values(trimmed)
            if values.len() >= 7:
                val item = TodoItem(
                    id: parse_i64_safe(values[0]),
                    keyword: clean_value(values[1]),
                    area: clean_value(values[2]),
                    priority: clean_value(values[3]),
                    description: clean_value(values[4]),
                    file: clean_value(values[5]),
                    line: parse_i64_safe(values[6])
                )
                items.push(item)

    items

# Parse row values (handles quoted strings with commas)
fn parse_row_values(row: text) -> [text]:
    var values = []
    var current = ""
    var in_quotes = false

    for i in 0..row.len():
        val ch = row[i:i+1]

        if ch == "\"":
            in_quotes = not in_quotes
        else if ch == "," and not in_quotes:
            values.push(current.trim())
            current = ""
        else:
            current = current + ch

    # Add last value
    if current.len() > 0:
        values.push(current.trim())

    values

# Clean value (remove quotes, unescape)
fn clean_value(value: text) -> text:
    var result = value.trim()

    # Remove surrounding quotes
    if result.starts_with("\"") and result.ends_with("\""):
        result = result[1:-1]

    result

# Parse i64 safely
fn parse_i64_safe(value: text) -> i64:
    val cleaned = clean_value(value)
    val parsed = cleaned.parse_i64()
    if parsed.?:
        parsed.unwrap()
    else:
        0

# Get priority numeric value
fn get_priority_value(priority: text) -> i64:
    if priority == "P0":
        0
    else if priority == "P1":
        1
    else if priority == "P2":
        2
    else if priority == "P3":
        3
    else:
        99  # Unknown priority

# Format TODO summary for display
fn format_summary(summary: TodoSummary) -> text:
    if summary.total == 0:
        return "No TODOs found"

    var result = "TODOs: {summary.total} total\n"
    result = result + "  P0 (critical): {summary.p0_count}\n"
    result = result + "  P1 (high): {summary.p1_count}\n"
    result = result + "  P2 (medium): {summary.p2_count}\n"
    result = result + "  P3 (low): {summary.p3_count}\n"

    if summary.high_priority_items.len() > 0:
        result = result + "\nHigh Priority Items:\n"
        for item in summary.high_priority_items:
            result = result + "  [{item.priority}] {item.description} ({item.file}:{item.line})\n"

    result

# Helper functions
fn file_exists(path: text) -> bool:
    val result = shell("test -f '{path}' && echo yes || echo no")
    result.trim() == "yes"

fn file_read(path: text) -> text:
    shell("cat '{path}'")

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn shell(cmd: text) -> text:
    val (stdout, stderr, exit_code) = rt_process_run("sh", ["-c", cmd])
    if exit_code == 0:
        stdout
    else:
        ""
