# Bitfield MIR Lowering
#
# Lowers bitfield field access to efficient bit manipulation operations.
#
# Bitfield field read:  (value >> offset) & mask
# Bitfield field write: (value & ~shifted_mask) | ((new_val & mask) << offset)

use mir_data.*
use bitfield (Bitfield, BitfieldField)
use hir_types (HirType)

export BitfieldMirLower
export is_bitfield_type, lower_bitfield_get, lower_bitfield_set

# Check if a type is a bitfield type
fn is_bitfield_type(type_: HirType) -> bool:
    # TODO: Implement proper type checking
    # For now, check if type name contains "bitfield" or matches known pattern
    val type_name = type_.to_text()
    type_name.contains("Bitfield") or type_name.contains("Flags") or type_name.contains("Control")

# Get bitfield metadata for a type
fn get_bitfield_info(type_: HirType) -> Bitfield?:
    # TODO: Look up bitfield in symbol table
    # For now, return None to indicate not a bitfield
    nil

struct BitfieldMirLower:
    """Helper for lowering bitfield operations to MIR."""
    builder: MirBuilder

impl BitfieldMirLower:
    static fn new(builder: MirBuilder) -> BitfieldMirLower:
        BitfieldMirLower(builder: builder)

    fn lower_get(base: LocalId, field: BitfieldField) -> LocalId:
        """Lower bitfield field read to MIR bit operations.

        Generates: (value >> offset) & mask
        """
        val offset = field.bit_offset
        val mask = field.repr.mask()

        # Create temporary for shifted value
        val shifted = if offset == 0:
            # No shift needed
            base
        else:
            # value >> offset
            val offset_const = self.builder.emit_const_int(offset)
            self.builder.emit_binop(
                MirBinOp.Shr,
                mir_operand_copy(base),
                mir_operand_copy(offset_const),
                MirType.i64()
            )

        # (shifted) & mask
        val mask_const = self.builder.emit_const_int(mask)
        self.builder.emit_binop(
            MirBinOp.BitAnd,
            mir_operand_copy(shifted),
            mir_operand_copy(mask_const),
            MirType.i64()
        )

    fn lower_set(base: LocalId, field: BitfieldField, new_value: LocalId) -> LocalId:
        """Lower bitfield field write to MIR bit operations.

        Generates: (value & ~shifted_mask) | ((new_val & mask) << offset)
        """
        val offset = field.bit_offset
        val mask = field.repr.mask()
        val shifted_mask = mask << offset

        # Step 1: Clear the field bits in original value
        # value & ~shifted_mask
        val clear_mask_const = self.builder.emit_const_int(~shifted_mask)
        val cleared = self.builder.emit_binop(
            MirBinOp.BitAnd,
            mir_operand_copy(base),
            mir_operand_copy(clear_mask_const),
            MirType.i64()
        )

        # Step 2: Mask the new value
        # new_val & mask
        val mask_const = self.builder.emit_const_int(mask)
        val masked_new = self.builder.emit_binop(
            MirBinOp.BitAnd,
            mir_operand_copy(new_value),
            mir_operand_copy(mask_const),
            MirType.i64()
        )

        # Step 3: Shift the masked new value
        # (new_val & mask) << offset
        val shifted_new = if offset == 0:
            masked_new
        else:
            val offset_const = self.builder.emit_const_int(offset)
            self.builder.emit_binop(
                MirBinOp.Shl,
                mir_operand_copy(masked_new),
                mir_operand_copy(offset_const),
                MirType.i64()
            )

        # Step 4: Combine cleared original with shifted new value
        # (value & ~shifted_mask) | (shifted_new)
        self.builder.emit_binop(
            MirBinOp.BitOr,
            mir_operand_copy(cleared),
            mir_operand_copy(shifted_new),
            MirType.i64()
        )

# Helper function for lowering bitfield get from HIR
fn lower_bitfield_get(
    builder: MirBuilder,
    base: LocalId,
    field_name: text,
    bitfield: Bitfield
) -> LocalId:
    """Lower bitfield field read operation."""
    val field = bitfield.get_field(field_name)
    if not field.?:
        # Field not found, return base (error will be caught elsewhere)
        return base

    val f = field.unwrap()
    val lowerer = BitfieldMirLower(builder: builder)
    lowerer.lower_get(base, f)

# Helper function for lowering bitfield set from HIR
fn lower_bitfield_set(
    builder: MirBuilder,
    base: LocalId,
    field_name: text,
    bitfield: Bitfield,
    new_value: LocalId
) -> LocalId:
    """Lower bitfield field write operation."""
    val field = bitfield.get_field(field_name)
    if not field.?:
        # Field not found, return base (error will be caught elsewhere)
        return base

    val f = field.unwrap()
    val lowerer = BitfieldMirLower(builder: builder)
    lowerer.lower_set(base, f, new_value)

# ============================================================================
# Exports
# ============================================================================

export BitfieldMirLower
export is_bitfield_type, get_bitfield_info
export lower_bitfield_get, lower_bitfield_set
