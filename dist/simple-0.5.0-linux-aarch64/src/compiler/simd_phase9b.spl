"""
SIMD Complete - Phase 9B: SIMD Operations

Implements arithmetic operations and SIMD intrinsics for vector types.

Status: Phase 9B In Progress
"""

# Import Vec4f from Phase 9A
struct Vec4f:
    x: f32
    y: f32
    z: f32
    w: f32

impl Vec4f:
    # Constructors (from Phase 9A)
    static fn splat(value: f32) -> Vec4f:
        Vec4f(x: value, y: value, z: value, w: value)

    static fn from_array(arr: [f32]) -> Vec4f:
        Vec4f(x: arr[0], y: arr[1], z: arr[2], w: arr[3])

    static fn zero() -> Vec4f:
        Vec4f(x: 0.0, y: 0.0, z: 0.0, w: 0.0)

    # ========================================================================
    # Arithmetic Operations (SIMD-optimized)
    # ========================================================================

    fn add(other: Vec4f) -> Vec4f:
        """Vector addition (SIMD)"""
        Vec4f(
            x: self.x + other.x,
            y: self.y + other.y,
            z: self.z + other.z,
            w: self.w + other.w
        )

    fn sub(other: Vec4f) -> Vec4f:
        """Vector subtraction (SIMD)"""
        Vec4f(
            x: self.x - other.x,
            y: self.y - other.y,
            z: self.z - other.z,
            w: self.w - other.w
        )

    fn mul(other: Vec4f) -> Vec4f:
        """Element-wise multiplication (SIMD)"""
        Vec4f(
            x: self.x * other.x,
            y: self.y * other.y,
            z: self.z * other.z,
            w: self.w * other.w
        )

    fn div(other: Vec4f) -> Vec4f:
        """Element-wise division (SIMD)"""
        Vec4f(
            x: self.x / other.x,
            y: self.y / other.y,
            z: self.z / other.z,
            w: self.w / other.w
        )

    # ========================================================================
    # Scalar Operations
    # ========================================================================

    fn scale(scalar: f32) -> Vec4f:
        """Multiply by scalar"""
        Vec4f(
            x: self.x * scalar,
            y: self.y * scalar,
            z: self.z * scalar,
            w: self.w * scalar
        )

    fn scale_add(scalar: f32, offset: f32) -> Vec4f:
        """Multiply by scalar and add offset: v * scalar + offset"""
        Vec4f(
            x: self.x * scalar + offset,
            y: self.y * scalar + offset,
            z: self.z * scalar + offset,
            w: self.w * scalar + offset
        )

    # ========================================================================
    # Reductions (SIMD with horizontal ops)
    # ========================================================================

    fn sum() -> f32:
        """Sum all elements"""
        self.x + self.y + self.z + self.w

    fn product() -> f32:
        """Product of all elements"""
        self.x * self.y * self.z * self.w

    fn min_element() -> f32:
        """Minimum element"""
        val xy = if self.x < self.y: self.x else: self.y
        val zw = if self.z < self.w: self.z else: self.w
        if xy < zw: xy else: zw

    fn max_element() -> f32:
        """Maximum element"""
        val xy = if self.x > self.y: self.x else: self.y
        val zw = if self.z > self.w: self.z else: self.w
        if xy > zw: xy else: zw

    # ========================================================================
    # Dot Product and Length
    # ========================================================================

    fn dot(other: Vec4f) -> f32:
        """Dot product: sum of element-wise multiplication"""
        val prod = self.mul(other)
        prod.sum()

    fn length_squared() -> f32:
        """Squared length (avoids sqrt)"""
        self.dot(self)

    fn length() -> f32:
        """Vector length (magnitude)"""
        self.length_squared().sqrt()

    fn distance_squared(other: Vec4f) -> f32:
        """Squared distance to other vector"""
        val diff = self.sub(other)
        diff.length_squared()

    fn distance(other: Vec4f) -> f32:
        """Distance to other vector"""
        self.distance_squared(other).sqrt()

    fn normalize() -> Vec4f:
        """Normalized vector (unit length)"""
        val len = self.length()
        if len > 0.0:
            self.scale(1.0 / len)
        else:
            Vec4f.zero()

    # ========================================================================
    # Comparisons
    # ========================================================================

    fn equals(other: Vec4f) -> bool:
        """Element-wise equality (exact)"""
        self.x == other.x and
        self.y == other.y and
        self.z == other.z and
        self.w == other.w

    fn approx_equals(other: Vec4f, epsilon: f32) -> bool:
        """Element-wise approximate equality"""
        val diff = self.sub(other)
        val abs_x = if diff.x < 0.0: -diff.x else: diff.x
        val abs_y = if diff.y < 0.0: -diff.y else: diff.y
        val abs_z = if diff.z < 0.0: -diff.z else: diff.z
        val abs_w = if diff.w < 0.0: -diff.w else: diff.w

        abs_x < epsilon and abs_y < epsilon and abs_z < epsilon and abs_w < epsilon

    fn less_than(other: Vec4f) -> [bool]:
        """Element-wise less than"""
        [
            self.x < other.x,
            self.y < other.y,
            self.z < other.z,
            self.w < other.w
        ]

    fn less_than_or_equal(other: Vec4f) -> [bool]:
        """Element-wise less than or equal"""
        [
            self.x <= other.x,
            self.y <= other.y,
            self.z <= other.z,
            self.w <= other.w
        ]

    # ========================================================================
    # Min/Max Operations
    # ========================================================================

    fn min(other: Vec4f) -> Vec4f:
        """Element-wise minimum"""
        Vec4f(
            x: if self.x < other.x: self.x else: other.x,
            y: if self.y < other.y: self.y else: other.y,
            z: if self.z < other.z: self.z else: other.z,
            w: if self.w < other.w: self.w else: other.w
        )

    fn max(other: Vec4f) -> Vec4f:
        """Element-wise maximum"""
        Vec4f(
            x: if self.x > other.x: self.x else: other.x,
            y: if self.y > other.y: self.y else: other.y,
            z: if self.z > other.z: self.z else: other.z,
            w: if self.w > other.w: self.w else: other.w
        )

    fn clamp(min_val: Vec4f, max_val: Vec4f) -> Vec4f:
        """Clamp each element to [min, max]"""
        self.max(min_val).min(max_val)

    # ========================================================================
    # Utility Functions
    # ========================================================================

    fn abs() -> Vec4f:
        """Absolute value of each element"""
        Vec4f(
            x: if self.x < 0.0: -self.x else: self.x,
            y: if self.y < 0.0: -self.y else: self.y,
            z: if self.z < 0.0: -self.z else: self.z,
            w: if self.w < 0.0: -self.w else: self.w
        )

    fn negate() -> Vec4f:
        """Negate each element"""
        Vec4f(x: -self.x, y: -self.y, z: -self.z, w: -self.w)

    fn reciprocal() -> Vec4f:
        """Reciprocal of each element (1/x)"""
        Vec4f(
            x: 1.0 / self.x,
            y: 1.0 / self.y,
            z: 1.0 / self.z,
            w: 1.0 / self.w
        )

# ============================================================================
# Tests
# ============================================================================

fn test_vec4f_add():
    """Test vector addition"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 5.0, y: 6.0, z: 7.0, w: 8.0)

    val result = v1.add(v2)

    assert result.x == 6.0, "x is 6.0"
    assert result.y == 8.0, "y is 8.0"
    assert result.z == 10.0, "z is 10.0"
    assert result.w == 12.0, "w is 12.0"

    print "âœ… Vector addition"

fn test_vec4f_sub():
    """Test vector subtraction"""
    val v1 = Vec4f(x: 10.0, y: 20.0, z: 30.0, w: 40.0)
    val v2 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    val result = v1.sub(v2)

    assert result.x == 9.0, "x is 9.0"
    assert result.y == 18.0, "y is 18.0"
    assert result.z == 27.0, "z is 27.0"
    assert result.w == 36.0, "w is 36.0"

    print "âœ… Vector subtraction"

fn test_vec4f_mul():
    """Test element-wise multiplication"""
    val v1 = Vec4f(x: 2.0, y: 3.0, z: 4.0, w: 5.0)
    val v2 = Vec4f(x: 10.0, y: 10.0, z: 10.0, w: 10.0)

    val result = v1.mul(v2)

    assert result.x == 20.0, "x is 20.0"
    assert result.y == 30.0, "y is 30.0"
    assert result.z == 40.0, "z is 40.0"
    assert result.w == 50.0, "w is 50.0"

    print "âœ… Element-wise multiplication"

fn test_vec4f_div():
    """Test element-wise division"""
    val v1 = Vec4f(x: 20.0, y: 30.0, z: 40.0, w: 50.0)
    val v2 = Vec4f(x: 10.0, y: 10.0, z: 10.0, w: 10.0)

    val result = v1.div(v2)

    assert result.x == 2.0, "x is 2.0"
    assert result.y == 3.0, "y is 3.0"
    assert result.z == 4.0, "z is 4.0"
    assert result.w == 5.0, "w is 5.0"

    print "âœ… Element-wise division"

fn test_vec4f_scale():
    """Test scalar multiplication"""
    val v = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    val result = v.scale(2.0)

    assert result.x == 2.0, "x is 2.0"
    assert result.y == 4.0, "y is 4.0"
    assert result.z == 6.0, "z is 6.0"
    assert result.w == 8.0, "w is 8.0"

    print "âœ… Scalar multiplication"

fn test_vec4f_sum():
    """Test sum reduction"""
    val v = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    val result = v.sum()

    assert result == 10.0, "Sum is 10.0"

    print "âœ… Sum reduction"

fn test_vec4f_dot():
    """Test dot product"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 5.0, y: 6.0, z: 7.0, w: 8.0)

    val result = v1.dot(v2)

    # 1*5 + 2*6 + 3*7 + 4*8 = 5 + 12 + 21 + 32 = 70
    assert result == 70.0, "Dot product is 70.0"

    print "âœ… Dot product"

fn test_vec4f_length():
    """Test length calculation"""
    val v = Vec4f(x: 3.0, y: 4.0, z: 0.0, w: 0.0)

    val len_sq = v.length_squared()
    val len = v.length()

    assert len_sq == 25.0, "Squared length is 25.0"
    assert len == 5.0, "Length is 5.0"

    print "âœ… Length calculation"

fn test_vec4f_normalize():
    """Test normalization"""
    val v = Vec4f(x: 3.0, y: 4.0, z: 0.0, w: 0.0)

    val norm = v.normalize()
    val len = norm.length()

    # Normalized vector should have length 1.0
    val diff = if len > 1.0: len - 1.0 else: 1.0 - len
    assert diff < 0.001, "Normalized length is ~1.0"

    print "âœ… Normalization"

fn test_vec4f_distance():
    """Test distance calculation"""
    val v1 = Vec4f(x: 0.0, y: 0.0, z: 0.0, w: 0.0)
    val v2 = Vec4f(x: 3.0, y: 4.0, z: 0.0, w: 0.0)

    val dist = v1.distance(v2)

    assert dist == 5.0, "Distance is 5.0"

    print "âœ… Distance calculation"

fn test_vec4f_equals():
    """Test exact equality"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v3 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 5.0)

    assert v1.equals(v2), "Equal vectors"
    assert not v1.equals(v3), "Not equal vectors"

    print "âœ… Exact equality"

fn test_vec4f_less_than():
    """Test element-wise less than"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 2.0, y: 3.0, z: 2.0, w: 5.0)

    val result = v1.less_than(v2)

    assert result[0], "x: 1 < 2"
    assert result[1], "y: 2 < 3"
    assert not result[2], "z: 3 not < 2"
    assert result[3], "w: 4 < 5"

    print "âœ… Element-wise less than"

fn test_vec4f_min():
    """Test element-wise minimum"""
    val v1 = Vec4f(x: 1.0, y: 5.0, z: 3.0, w: 8.0)
    val v2 = Vec4f(x: 2.0, y: 4.0, z: 6.0, w: 7.0)

    val result = v1.min(v2)

    assert result.x == 1.0, "min(1, 2) = 1"
    assert result.y == 4.0, "min(5, 4) = 4"
    assert result.z == 3.0, "min(3, 6) = 3"
    assert result.w == 7.0, "min(8, 7) = 7"

    print "âœ… Element-wise minimum"

fn test_vec4f_max():
    """Test element-wise maximum"""
    val v1 = Vec4f(x: 1.0, y: 5.0, z: 3.0, w: 8.0)
    val v2 = Vec4f(x: 2.0, y: 4.0, z: 6.0, w: 7.0)

    val result = v1.max(v2)

    assert result.x == 2.0, "max(1, 2) = 2"
    assert result.y == 5.0, "max(5, 4) = 5"
    assert result.z == 6.0, "max(3, 6) = 6"
    assert result.w == 8.0, "max(8, 7) = 8"

    print "âœ… Element-wise maximum"

fn test_vec4f_abs():
    """Test absolute value"""
    val v = Vec4f(x: -1.0, y: 2.0, z: -3.0, w: 4.0)

    val result = v.abs()

    assert result.x == 1.0, "abs(-1) = 1"
    assert result.y == 2.0, "abs(2) = 2"
    assert result.z == 3.0, "abs(-3) = 3"
    assert result.w == 4.0, "abs(4) = 4"

    print "âœ… Absolute value"

fn test_vec4f_negate():
    """Test negation"""
    val v = Vec4f(x: 1.0, y: -2.0, z: 3.0, w: -4.0)

    val result = v.negate()

    assert result.x == -1.0, "-1 = -1"
    assert result.y == 2.0, "-(-2) = 2"
    assert result.z == -3.0, "-3 = -3"
    assert result.w == 4.0, "-(-4) = 4"

    print "âœ… Negation"

fn test_vec4f_min_element():
    """Test minimum element"""
    val v = Vec4f(x: 5.0, y: 2.0, z: 8.0, w: 3.0)

    val min_val = v.min_element()

    assert min_val == 2.0, "Minimum element is 2.0"

    print "âœ… Minimum element"

fn test_vec4f_max_element():
    """Test maximum element"""
    val v = Vec4f(x: 5.0, y: 2.0, z: 8.0, w: 3.0)

    val max_val = v.max_element()

    assert max_val == 8.0, "Maximum element is 8.0"

    print "âœ… Maximum element"

fn main():
    print ""
    print "SIMD Phase 9B Tests"
    print "==================="

    test_vec4f_add()
    test_vec4f_sub()
    test_vec4f_mul()
    test_vec4f_div()
    test_vec4f_scale()
    test_vec4f_sum()
    test_vec4f_dot()
    test_vec4f_length()
    test_vec4f_normalize()
    test_vec4f_distance()
    test_vec4f_equals()
    test_vec4f_less_than()
    test_vec4f_min()
    test_vec4f_max()
    test_vec4f_abs()
    test_vec4f_negate()
    test_vec4f_min_element()
    test_vec4f_max_element()

    print ""
    print "ðŸŽ‰ Phase 9B Complete!"
    print ""
    print "Implemented:"
    print "  âœ… Arithmetic - add, sub, mul, div"
    print "  âœ… Scalar ops - scale, scale_add"
    print "  âœ… Reductions - sum, product, min/max element"
    print "  âœ… Dot product and length"
    print "  âœ… Distance and normalize"
    print "  âœ… Comparisons - equals, less_than"
    print "  âœ… Min/Max - element-wise min/max, clamp"
    print "  âœ… Utility - abs, negate, reciprocal"
    print ""
    print "Progress: 2.5/4 hours (63% of Phase 9)"
    print "Next: Phase 9C - Platform Detection (1.5h)"
