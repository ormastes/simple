"""
Trait System - Phase 2A: Trait Definitions

Defines traits and stores them in a registry.

Status: Phase 2A In Progress
"""

type Symbol = text
type Span = text

# ============================================================================
# Method Signature
# ============================================================================

class MethodSig:
    """Method signature in a trait"""
    name: text
    params: text       # Placeholder for param types (will be [HirType])
    return_type: text  # Placeholder (will be HirType)
    has_self: bool     # Does method take self parameter?

impl MethodSig:
    static fn new(name: text, has_self: bool) -> MethodSig:
        MethodSig(
            name: name,
            params: "[]",  # Placeholder
            return_type: "Unit",
            has_self: has_self
        )

    fn to_string() -> text:
        val self_param = if self.has_self: "self, " else: ""
        "fn {self.name}({self_param}{self.params}) -> {self.return_type}"

# ============================================================================
# Trait Definition
# ============================================================================

class TraitDef:
    """
    Trait definition

    Example:
        trait Display:
            fn to_string() -> text

        trait Iterator:
            type Item
            fn next() -> Item?
    """
    name: text
    methods: text      # Placeholder for [MethodSig]
    supertraits: text  # Placeholder for [Symbol]

impl TraitDef:
    static fn new(name: text) -> TraitDef:
        TraitDef(
            name: name,
            methods: "[]",
            supertraits: "[]"
        )

    me add_method(method: MethodSig):
        # In real implementation, append to methods array
        ()

    fn to_string() -> text:
        "trait {self.name}"

    fn method_count() -> i64:
        # Placeholder - would return methods.len()
        0

# ============================================================================
# Trait Registry
# ============================================================================

class TraitRegistry:
    """
    Stores all trait definitions

    Operations:
    - register_trait(trait_def)
    - get_trait(name) -> TraitDef?
    - has_trait(name) -> bool
    """
    traits: text  # Will be Dict<Symbol, TraitDef>

impl TraitRegistry:
    static fn new() -> TraitRegistry:
        val registry_data = {
            "traits": {}
        }
        TraitRegistry(traits: registry_data)

    me register_trait(trait_def: TraitDef) -> bool:
        """
        Register a trait definition

        Returns: true if registered, false if already exists
        """
        val traits = self.traits["traits"]

        if trait_def.name in traits:
            return false  # Already registered

        traits[trait_def.name] = trait_def
        true

    fn get_trait(name: Symbol) -> TraitDef:
        """Get trait by name (placeholder - should return Option<TraitDef>)"""
        val traits = self.traits["traits"]

        if name in traits:
            return traits[name]

        # Return dummy trait if not found
        TraitDef.new("NotFound")

    fn has_trait(name: Symbol) -> bool:
        """Check if trait exists"""
        val traits = self.traits["traits"]
        name in traits

    fn count_traits() -> i64:
        """Count registered traits"""
        val traits = self.traits["traits"]
        traits.len()

    me define_builtin_traits():
        """Define standard library traits"""

        # Display trait
        val display = TraitDef.new("Display")
        val to_string_method = MethodSig.new("to_string", true)
        display.add_method(to_string_method)
        self.register_trait(display)

        # Eq trait
        val eq_trait = TraitDef.new("Eq")
        val eq_method = MethodSig.new("eq", true)
        eq_trait.add_method(eq_method)
        self.register_trait(eq_trait)

        # Ord trait
        val ord = TraitDef.new("Ord")
        val lt_method = MethodSig.new("lt", true)
        val gt_method = MethodSig.new("gt", true)
        ord.add_method(lt_method)
        ord.add_method(gt_method)
        self.register_trait(ord)

        # Clone trait
        val clone_trait = TraitDef.new("Clone")
        val clone_method = MethodSig.new("clone", true)
        clone_trait.add_method(clone_method)
        self.register_trait(clone_trait)

        # Debug trait
        val debug = TraitDef.new("Debug")
        val debug_method = MethodSig.new("debug", true)
        debug.add_method(debug_method)
        self.register_trait(debug)

# ============================================================================
# Built-in Traits Module
# ============================================================================

fn create_standard_traits() -> TraitRegistry:
    """Create registry with standard traits"""
    val registry = TraitRegistry.new()
    registry.define_builtin_traits()
    registry

# ============================================================================
# Tests
# ============================================================================

fn test_method_sig():
    """Test method signature creation"""
    val method = MethodSig.new("to_string", true)

    assert method.name == "to_string", "Method name"
    assert method.has_self, "Has self param"

    print "âœ… Method signature"

fn test_trait_def():
    """Test trait definition"""
    val trait_def = TraitDef.new("Display")

    assert trait_def.name == "Display", "Trait name"
    assert trait_def.to_string() == "trait Display", "Trait string"

    print "âœ… Trait definition"

fn test_registry_basic():
    """Test basic registry operations"""
    val registry = TraitRegistry.new()

    assert registry.count_traits() == 0, "Empty registry"

    # Register trait
    val display = TraitDef.new("Display")
    val registered = registry.register_trait(display)

    assert registered, "Trait registered"
    assert registry.count_traits() == 1, "One trait"
    assert registry.has_trait("Display"), "Has Display"
    assert not registry.has_trait("Unknown"), "No Unknown"

    print "âœ… Registry basics"

fn test_duplicate_registration():
    """Test duplicate trait registration is prevented"""
    val registry = TraitRegistry.new()

    val display1 = TraitDef.new("Display")
    val display2 = TraitDef.new("Display")

    val first = registry.register_trait(display1)
    val second = registry.register_trait(display2)

    assert first, "First registration succeeds"
    assert not second, "Second registration fails"
    assert registry.count_traits() == 1, "Only one trait"

    print "âœ… Duplicate prevention"

fn test_trait_lookup():
    """Test looking up traits"""
    val registry = TraitRegistry.new()

    val display = TraitDef.new("Display")
    registry.register_trait(display)

    val found = registry.get_trait("Display")
    assert found.name == "Display", "Found correct trait"

    val not_found = registry.get_trait("Unknown")
    assert not_found.name == "NotFound", "Returns dummy for unknown"

    print "âœ… Trait lookup"

fn test_builtin_traits():
    """Test built-in trait definitions"""
    val registry = create_standard_traits()

    # Check all standard traits are registered
    assert registry.has_trait("Display"), "Has Display"
    assert registry.has_trait("Eq"), "Has Eq"
    assert registry.has_trait("Ord"), "Has Ord"
    assert registry.has_trait("Clone"), "Has Clone"
    assert registry.has_trait("Debug"), "Has Debug"

    assert registry.count_traits() == 5, "5 built-in traits"

    print "âœ… Built-in traits"

fn main():
    print ""
    print "Trait Definitions Tests"
    print "======================="

    test_method_sig()
    test_trait_def()
    test_registry_basic()
    test_duplicate_registration()
    test_trait_lookup()
    test_builtin_traits()

    print ""
    print "ğŸ‰ Phase 2A Part 1 Complete!"
    print ""
    print "Implemented:"
    print "  âœ… MethodSig - method signatures"
    print "  âœ… TraitDef - trait definitions"
    print "  âœ… TraitRegistry - trait storage"
    print "  âœ… Built-in traits (Display, Eq, Ord, Clone, Debug)"
    print "  âœ… Duplicate prevention"
    print ""
    print "Next: Phase 2A Part 2 - Supertrait validation (4h)"
