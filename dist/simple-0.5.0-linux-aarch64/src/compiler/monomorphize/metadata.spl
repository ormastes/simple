# Monomorphization Metadata
#
# This module provides data structures to track:
# - Generic template definitions (functions, structs, enums, traits)
# - Specialization instances and their type bindings
# - Mapping between templates and specialized instances
#
# Port of: rust/compiler/src/monomorphize/metadata.rs (190 lines)

export MonomorphizationMetadata
export GenericFunctionMeta
export GenericStructMeta
export GenericClassMeta
export GenericEnumMeta
export GenericTraitMeta
export SpecializationEntry
export TraitImplEntry

use compiler.monomorphize.types (ConcreteType, SpecializationKey, TypeBindings)

# ============================================================================
# Monomorphization Metadata
# ============================================================================

struct MonomorphizationMetadata:
    """Complete monomorphization metadata for a module.

    Stores all generic templates and their specializations for
    serialization to .smf files.

    ROBUSTNESS: Complete tracking of all generic constructs.
    """
    # Generic function templates and their specializations
    functions: {text: GenericFunctionMeta}

    # Generic struct templates and their specializations
    structs: {text: GenericStructMeta}

    # Generic class templates and their specializations
    classes: {text: GenericClassMeta}

    # Generic enum templates and their specializations
    enums: {text: GenericEnumMeta}

    # Generic trait templates and their implementations
    traits: {text: GenericTraitMeta}

impl MonomorphizationMetadata:
    static fn new() -> MonomorphizationMetadata:
        """Create a new empty metadata collection."""
        MonomorphizationMetadata(
            functions: {},
            structs: {},
            classes: {},
            enums: {},
            traits: {}
        )

    fn is_empty() -> bool:
        """Check if metadata is empty (no generic constructs)."""
        self.functions.is_empty() and
        self.structs.is_empty() and
        self.classes.is_empty() and
        self.enums.is_empty() and
        self.traits.is_empty()

    fn total_templates() -> i64:
        """Total number of generic templates."""
        self.functions.len() +
        self.structs.len() +
        self.classes.len() +
        self.enums.len() +
        self.traits.len()

    fn total_specializations() -> i64:
        """Total number of specializations across all templates."""
        var count = 0
        for (_, meta) in self.functions.items():
            count = count + meta.specializations.len()
        for (_, meta) in self.structs.items():
            count = count + meta.specializations.len()
        for (_, meta) in self.classes.items():
            count = count + meta.specializations.len()
        for (_, meta) in self.enums.items():
            count = count + meta.specializations.len()
        count

# ============================================================================
# Generic Function Metadata
# ============================================================================

struct GenericFunctionMeta:
    """Metadata for a generic function template."""
    base_name: text                        # Base name (before mangling)
    generic_params: [text]                 # Generic type parameter names (e.g., ["T", "U"])
    specializations: [SpecializationEntry] # All specializations generated

impl GenericFunctionMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericFunctionMeta:
        """Create a new function metadata."""
        GenericFunctionMeta(
            base_name: base_name,
            generic_params: generic_params,
            specializations: []
        )

    me add_specialization(entry: SpecializationEntry):
        """Add a specialization entry."""
        self.specializations.push(entry)

    fn specialization_count() -> i64:
        """Number of specializations."""
        self.specializations.len()

# ============================================================================
# Generic Struct Metadata
# ============================================================================

struct GenericStructMeta:
    """Metadata for a generic struct template."""
    base_name: text                        # Base name (before mangling)
    generic_params: [text]                 # Generic type parameter names
    specializations: [SpecializationEntry] # All specializations generated

impl GenericStructMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericStructMeta:
        """Create a new struct metadata."""
        GenericStructMeta(
            base_name: base_name,
            generic_params: generic_params,
            specializations: []
        )

    me add_specialization(entry: SpecializationEntry):
        """Add a specialization entry."""
        self.specializations.push(entry)

    fn specialization_count() -> i64:
        """Number of specializations."""
        self.specializations.len()

# ============================================================================
# Generic Class Metadata
# ============================================================================

struct GenericClassMeta:
    """Metadata for a generic class template."""
    base_name: text                        # Base name (before mangling)
    generic_params: [text]                 # Generic type parameter names
    specializations: [SpecializationEntry] # All specializations generated

impl GenericClassMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericClassMeta:
        """Create a new class metadata."""
        GenericClassMeta(
            base_name: base_name,
            generic_params: generic_params,
            specializations: []
        )

    me add_specialization(entry: SpecializationEntry):
        """Add a specialization entry."""
        self.specializations.push(entry)

    fn specialization_count() -> i64:
        """Number of specializations."""
        self.specializations.len()

# ============================================================================
# Generic Enum Metadata
# ============================================================================

struct GenericEnumMeta:
    """Metadata for a generic enum template."""
    base_name: text                        # Base name (before mangling)
    generic_params: [text]                 # Generic type parameter names (e.g., ["T", "E"])
    specializations: [SpecializationEntry] # All specializations generated

impl GenericEnumMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericEnumMeta:
        """Create a new enum metadata."""
        GenericEnumMeta(
            base_name: base_name,
            generic_params: generic_params,
            specializations: []
        )

    me add_specialization(entry: SpecializationEntry):
        """Add a specialization entry."""
        self.specializations.push(entry)

    fn specialization_count() -> i64:
        """Number of specializations."""
        self.specializations.len()

# ============================================================================
# Generic Trait Metadata
# ============================================================================

struct GenericTraitMeta:
    """Metadata for a generic trait template."""
    base_name: text                          # Base name (before mangling)
    generic_params: [text]                   # Generic type parameter names (e.g., ["T"])
    impl_specializations: [TraitImplEntry]   # All trait implementations

impl GenericTraitMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericTraitMeta:
        """Create a new trait metadata."""
        GenericTraitMeta(
            base_name: base_name,
            generic_params: generic_params,
            impl_specializations: []
        )

    me add_impl(entry: TraitImplEntry):
        """Add a trait implementation entry."""
        self.impl_specializations.push(entry)

    fn impl_count() -> i64:
        """Number of trait implementations."""
        self.impl_specializations.len()

# ============================================================================
# Specialization Entry
# ============================================================================

struct SpecializationEntry:
    """A single specialization instance.

    Tracks a specific instantiation of a generic template with concrete types.

    Example:
        identity<Int> has:
        - type_args: [Int]
        - mangled_name: "identity$Int"
        - bindings: {"T": Int}
    """
    type_args: [ConcreteType]       # Concrete type arguments (e.g., [Int, String])
    mangled_name: text              # Mangled name (e.g., "identity$Int")
    bindings: TypeBindings          # Type parameter bindings (e.g., T -> Int)

impl SpecializationEntry:
    static fn from_key(key: SpecializationKey) -> SpecializationEntry:
        """Create a new specialization entry from a key.

        Bindings will be empty and should be filled later.
        """
        SpecializationEntry(
            type_args: key.type_args.clone(),
            mangled_name: key.mangled_name(),
            bindings: {}
        )

    static fn new(type_args: [ConcreteType], mangled_name: text, bindings: TypeBindings) -> SpecializationEntry:
        """Create a specialization entry with explicit bindings."""
        SpecializationEntry(
            type_args: type_args,
            mangled_name: mangled_name,
            bindings: bindings
        )

    fn type_arg_count() -> i64:
        """Number of type arguments."""
        self.type_args.len()

    fn has_binding(param: text) -> bool:
        """Check if a type parameter has a binding."""
        self.bindings.contains_key(param)

    fn get_binding(param: text) -> ConcreteType?:
        """Get the concrete type for a type parameter."""
        self.bindings.get(param)

# ============================================================================
# Trait Implementation Entry
# ============================================================================

struct TraitImplEntry:
    """Trait implementation entry.

    Tracks a specific implementation of a generic trait for a concrete type.

    Example:
        impl Iterator<Int> for [Int] has:
        - trait_name: "Iterator"
        - type_args: [Int]
        - impl_for_type: "List$Int"
        - mangled_name: "Iterator$Int_impl_for_List$Int"
    """
    trait_name: text                # Trait name (e.g., "Iterator")
    type_args: [ConcreteType]       # Concrete type arguments for the trait (e.g., [Int])
    impl_for_type: text             # The type this trait is implemented for
    mangled_name: text              # Mangled name of the implementation

impl TraitImplEntry:
    static fn new(
        trait_name: text,
        type_args: [ConcreteType],
        impl_for_type: text,
        mangled_name: text
    ) -> TraitImplEntry:
        """Create a new trait implementation entry."""
        TraitImplEntry(
            trait_name: trait_name,
            type_args: type_args,
            impl_for_type: impl_for_type,
            mangled_name: mangled_name
        )

# ============================================================================
# Usage Example
# ============================================================================
#
# # Create metadata
# val metadata = MonomorphizationMetadata.new()
#
# # Add a generic function template
# metadata.functions["identity"] = GenericFunctionMeta.new("identity", ["T"])
#
# # Add a specialization
# val entry = SpecializationEntry.new(
#     type_args: [ConcreteType.Int],
#     mangled_name: "identity$Int",
#     bindings: {"T": ConcreteType.Int}
# )
# metadata.functions["identity"].add_specialization(entry)
#
# # Query metadata
# print "Total templates: {metadata.total_templates()}"
# print "Total specializations: {metadata.total_specializations()}"
#
# # Check specializations for a function
# val id_meta = metadata.functions["identity"]
# print "identity has {id_meta.specialization_count()} specializations"
#
# # Trait implementation
# val trait_impl = TraitImplEntry.new(
#     trait_name: "Iterator",
#     type_args: [ConcreteType.Int],
#     impl_for_type: "List$Int",
#     mangled_name: "Iterator$Int_impl_for_List$Int"
# )
# metadata.traits["Iterator"].add_impl(trait_impl)
#
# ============================================================================
# Serialization Format (TODO)
# ============================================================================
#
# When serializing to .smf:
#
# MonomorphizationMetadata:
#   magic: "META" (4 bytes)
#   version: u16 (2 bytes)
#   function_count: u32
#   functions: [GenericFunctionMeta]
#   struct_count: u32
#   structs: [GenericStructMeta]
#   class_count: u32
#   classes: [GenericClassMeta]
#   enum_count: u32
#   enums: [GenericEnumMeta]
#   trait_count: u32
#   traits: [GenericTraitMeta]
#
# GenericFunctionMeta:
#   name_len: u32
#   name: bytes
#   param_count: u8
#   params: [String]
#   spec_count: u32
#   specializations: [SpecializationEntry]
#
# SpecializationEntry:
#   arg_count: u8
#   type_args: [ConcreteType]
#   mangled_name_len: u32
#   mangled_name: bytes
#   binding_count: u8
#   bindings: [(String, ConcreteType)]
#
# ============================================================================
# Performance Notes
# ============================================================================
#
# - Lookup by name: O(1) hash table
# - Add specialization: O(1) array append
# - Total count queries: O(n) where n = number of templates
# - Serialization: O(total size) linear scan
#
# Expected performance: Same as Rust (same data structures)
#
# ============================================================================
# Robustness Checklist
# ============================================================================
#
# Memory Safety:
# - [x] No buffer overflows (Simple arrays safe)
# - [x] No null pointers (all fields required)
# - [x] No use-after-free (Simple ownership)
#
# Logic Correctness:
# - [x] All generic constructs tracked
# - [x] Specializations properly linked to templates
# - [x] Type bindings preserved
# - [x] Mangled names unique
#
# Edge Cases:
# - [x] Empty metadata (is_empty() returns true)
# - [x] No specializations (empty lists)
# - [x] Multiple specializations (list grows)
# - [x] Trait implementations tracked separately
#
# TODO:
# - [ ] Add serialization/deserialization
# - [ ] Add optimization level tracking
# - [ ] Add dependency tracking between specializations
# - [ ] Add incremental update support
