# Linker Script Generator
#
# Generates GNU LD linker scripts from board SDN definitions.
#
# Usage:
#   simple linker-gen boards/qemu_x86.sdn -o build/linker.ld

from parser import {
    parse_board, BoardConfig, MemoryRegion, Section,
    QemuConfig, MultibootConfig, ParseError
}

export generate_linker_script, LinkerGenError, main

# Error types
enum LinkerGenError:
    ParseError(error: ParseError)
    IoError(message: text)
    ValidationError(message: text)

impl LinkerGenError:
    fn message() -> text:
        match self:
            case LinkerGenError.ParseError(e): e.message()
            case LinkerGenError.IoError(msg): "I/O error: {msg}"
            case LinkerGenError.ValidationError(msg): "Validation error: {msg}"

# Generate GNU LD linker script from board config
fn generate_linker_script(board: BoardConfig) -> text:
    var lines: [text] = []

    # Header comment
    lines.push("/* Linker script generated for: {board.name} */")
    lines.push("/* Target: {board.target} */")
    lines.push("/* Architecture: {board.arch} */")
    if board.description != "":
        lines.push("/* {board.description} */")
    lines.push("")

    # Entry point
    lines.push("ENTRY({board.entry})")
    lines.push("")

    # Memory regions
    lines.push("MEMORY")
    lines.push("{")
    for region in board.memory:
        val perms = region.permissions_str()
        val origin_hex = format_hex(region.origin)
        val comment = if region.description != "": " /* {region.description} */" else: ""
        lines.push("    {region.name} ({perms}) : ORIGIN = {origin_hex}, LENGTH = {region.length_str()}{comment}")
    lines.push("}")
    lines.push("")

    # Symbols for BSS and stack
    lines.push("/* Provide default symbols */")
    lines.push("PROVIDE(__stack_size = 64K);")
    lines.push("")

    # Sections
    lines.push("SECTIONS")
    lines.push("{")

    for section in board.sections:
        generate_section(lines, section)
        lines.push("")

    # Add common end symbols
    lines.push("    /* End of image */")
    lines.push("    _end = .;")
    lines.push("    PROVIDE(end = .);")
    lines.push("")

    # Discard sections
    lines.push("    /DISCARD/ : {")
    lines.push("        *(.comment)")
    lines.push("        *(.note*)")
    lines.push("        *(.eh_frame*)")
    lines.push("    }")

    lines.push("}")
    lines.push("")

    lines.join("\n")

# Generate a single section
fn generate_section(lines: mut [text], section: Section):
    var section_line = "    {section.name}"

    # Address specification
    if section.address.?:
        section_line = section_line + " {format_hex(section.address.unwrap())}"

    section_line = section_line + " :"
    lines.push(section_line)
    lines.push("    {")

    # Alignment
    if section.align > 1:
        lines.push("        . = ALIGN({section.align});")

    # Section start symbol
    val symbol_name = section.name.replace(".", "_")
    lines.push("        __{symbol_name}_start = .;")

    # Input sections
    for input_pattern in section.input:
        if section.keep:
            lines.push("        KEEP({input_pattern})")
        else:
            lines.push("        {input_pattern}")

    # Fixed size for sections like stack
    if section.size.?:
        lines.push("        . = . + {section.size.unwrap()};")

    # Section end symbol
    lines.push("        __{symbol_name}_end = .;")

    lines.push("    } > {section.memory}")

    # AT() for load address if different from VMA (not implemented yet)

# Format number as hexadecimal
fn format_hex(n: i64) -> text:
    if n == 0:
        return "0x0"

    var result = ""
    var value = n
    while value > 0:
        val digit = value % 16
        val ch = if digit < 10: ('0'.to_int() + digit).to_char() else: ('A'.to_int() + digit - 10).to_char()
        result = ch + result
        value = value / 16
    "0x{result}"

# Main entry point
fn main(args: [text]) -> i64:
    if args.len() < 1:
        print_usage()
        return 1

    var board_file: text = ""
    var output_file: text = ""
    var verbose = false
    var i = 0

    while i < args.len():
        val arg = args[i]
        match arg:
            case "-o" | "--output":
                if i + 1 >= args.len():
                    print "Error: -o requires an argument"
                    return 1
                output_file = args[i + 1]
                i = i + 2
            case "-v" | "--verbose":
                verbose = true
                i = i + 1
            case "-h" | "--help":
                print_usage()
                return 0
            case _:
                if arg.starts_with("-"):
                    print "Error: Unknown option: {arg}"
                    return 1
                board_file = arg
                i = i + 1

    if board_file == "":
        print "Error: No board file specified"
        print_usage()
        return 1

    # Parse board file
    val result = parse_board(board_file)
    match result:
        case Err(e):
            print "Error: {e.message()}"
            return 1
        case Ok(board):
            if verbose:
                print "Parsed board: {board.name}"
                print "  Arch: {board.arch}"
                print "  Target: {board.target}"
                print "  Memory regions: {board.memory.len()}"
                print "  Sections: {board.sections.len()}"
                print "  Entry: {board.entry}"

            # Generate linker script
            val script = generate_linker_script(board)

            if output_file == "":
                # Print to stdout
                print script
            else:
                # Write to file
                extern fn rt_file_write_text(path: text, content: text) -> bool
                if not rt_file_write_text(output_file, script):
                    print "Error: Failed to write to {output_file}"
                    return 1
                if verbose:
                    print "Wrote linker script to: {output_file}"

            return 0

fn print_usage():
    print "Usage: simple linker-gen <board.sdn> [-o <output.ld>]"
    print ""
    print "Generate GNU LD linker script from board definition."
    print ""
    print "Options:"
    print "  -o, --output <file>   Write output to file (default: stdout)"
    print "  -v, --verbose         Show verbose output"
    print "  -h, --help            Show this help"
    print ""
    print "Example:"
    print "  simple linker-gen boards/qemu_x86.sdn -o build/linker.ld"
