# Test Runner Host Loader
#
# Binary loader interface for loading test binaries to targets.
# Implementations for QEMU, OpenOCD, J-Link, Serial.
#
# Loader Types:
#   LOADER_QEMU=0, LOADER_OPENOCD=1, LOADER_JLINK=2, LOADER_SERIAL=3

# =========================================================================
# Loader Configuration
# =========================================================================

class LoaderConfig:
    loader_type: i32           # LOADER_* constant
    binary_path: text          # Path to test binary
    target_arch: text          # "x86", "arm", "riscv32", etc.
    timeout_ms: i64            # Overall timeout
    extra_args: text           # Additional loader-specific arguments

fn LoaderConfig_qemu(binary: text, arch: text) -> LoaderConfig:
    LoaderConfig(
        loader_type: 0,         # LOADER_QEMU
        binary_path: binary,
        target_arch: arch,
        timeout_ms: 30000,
        extra_args: ""
    )

fn LoaderConfig_qemu_with_timeout(binary: text, arch: text, timeout_ms: i64) -> LoaderConfig:
    LoaderConfig(
        loader_type: 0,         # LOADER_QEMU
        binary_path: binary,
        target_arch: arch,
        timeout_ms: timeout_ms,
        extra_args: ""
    )

fn LoaderConfig_openocd(binary: text, config_file: text) -> LoaderConfig:
    LoaderConfig(
        loader_type: 1,         # LOADER_OPENOCD
        binary_path: binary,
        target_arch: "arm",
        timeout_ms: 60000,
        extra_args: config_file
    )

fn LoaderConfig_jlink(binary: text, device: text) -> LoaderConfig:
    LoaderConfig(
        loader_type: 2,         # LOADER_JLINK
        binary_path: binary,
        target_arch: "arm",
        timeout_ms: 60000,
        extra_args: device
    )

fn LoaderConfig_serial(port: text, baudrate: text) -> LoaderConfig:
    LoaderConfig(
        loader_type: 3,         # LOADER_SERIAL
        binary_path: "",
        target_arch: "",
        timeout_ms: 30000,
        extra_args: "{port}:{baudrate}"
    )

# =========================================================================
# Loader Result
# =========================================================================

class LoaderResult:
    success: bool
    process_id: i32            # Process ID (for QEMU, etc.)
    transport_path: text       # Transport path (e.g., "stdio", socket path)
    error_message: text

fn LoaderResult_success(pid: i32, transport: text) -> LoaderResult:
    LoaderResult(
        success: true,
        process_id: pid,
        transport_path: transport,
        error_message: ""
    )

fn LoaderResult_failure(message: text) -> LoaderResult:
    LoaderResult(
        success: false,
        process_id: 0,
        transport_path: "",
        error_message: message
    )

# =========================================================================
# Loader Interface
# =========================================================================

class Loader:
    config: LoaderConfig
    result: LoaderResult
    running: bool

fn Loader_create(config: LoaderConfig) -> Loader:
    Loader(
        config: config,
        result: LoaderResult_failure("Not started"),
        running: false
    )

impl Loader:
    # Start the loader
    me start() -> LoaderResult:
        if self.config.loader_type == 0:
            self.result = qemu_start(self.config)
        elif self.config.loader_type == 1:
            self.result = openocd_start(self.config)
        elif self.config.loader_type == 2:
            self.result = jlink_start(self.config)
        elif self.config.loader_type == 3:
            self.result = serial_start(self.config)
        else:
            self.result = LoaderResult_failure("Unknown loader type")

        if self.result.success:
            self.running = true
        self.result

    # Stop the loader
    me stop():
        if self.running:
            if self.config.loader_type == 0:
                qemu_stop(self.result.process_id)
            elif self.config.loader_type == 1:
                openocd_stop(self.result.process_id)
            elif self.config.loader_type == 2:
                jlink_stop(self.result.process_id)
            # Serial doesn't need stopping
            self.running = false

    # Wait for loader to finish
    fn wait(timeout_ms: i64) -> i32:
        if self.config.loader_type == 0:
            qemu_wait(self.result.process_id, timeout_ms)
        else:
            0

    fn is_running() -> bool:
        self.running

    fn get_transport() -> text:
        self.result.transport_path

    fn get_error() -> text:
        self.result.error_message

# =========================================================================
# QEMU Loader Implementation
# =========================================================================

use lib.qemu.{QemuArch, QemuConfig, QemuInstance}

# Store QEMU instance per PID for tracking
var qemu_instances: Dict<i32, QemuInstance> = {}
var next_mock_pid: i32 = 10000

fn qemu_start(config: LoaderConfig) -> LoaderResult:
    # Check if binary exists
    if config.binary_path == "":
        return LoaderResult_failure("No binary path specified")

    # Parse architecture
    val arch = QemuArch.from_string(config.target_arch)

    # Create QEMU config for test runner
    var qemu_config = QemuConfig.for_test_runner(arch, config.binary_path)
    qemu_config.timeout_ms = config.timeout_ms

    # Parse extra args if provided
    if config.extra_args != "":
        val args_list = config.extra_args.split(" ").filter(\s: s.len() > 0)
        qemu_config.extra_args = args_list

    # Start QEMU instance
    val result = QemuInstance.start(qemu_config)
    match result:
        case Ok(instance):
            # Convert PID string to int for tracking
            val pid_int = parse_pid(instance.get_pid())

            # Store instance for later
            qemu_instances[pid_int] = instance

            LoaderResult_success(pid_int, "stdio")

        case Err(msg):
            LoaderResult_failure(msg)

fn qemu_stop(pid: i32):
    # Find and stop the QEMU instance
    if qemu_instances.contains(pid):
        var instance = qemu_instances[pid]
        instance.stop()
        qemu_instances.remove(pid)

fn qemu_wait(pid: i32, timeout_ms: i64) -> i32:
    # Find and wait for the QEMU instance
    if qemu_instances.contains(pid):
        val instance = qemu_instances[pid]
        val result = instance.wait_exit(timeout_ms)
        match result:
            case Ok(exit_code):
                exit_code
            case Err(_):
                124  # Timeout exit code
    else:
        0  # Already exited

fn parse_pid(pid_str: text) -> i32:
    var result: i32 = 0
    for c in pid_str:
        if c >= '0' and c <= '9':
            result = result * 10 + (c.to_i32() - 48)
    result

# =========================================================================
# OpenOCD Loader Implementation (stub)
# =========================================================================

fn openocd_start(config: LoaderConfig) -> LoaderResult:
    # Would start OpenOCD and flash binary
    LoaderResult_failure("OpenOCD loader not implemented")

fn openocd_stop(pid: i32):
    pass

# =========================================================================
# J-Link Loader Implementation (stub)
# =========================================================================

fn jlink_start(config: LoaderConfig) -> LoaderResult:
    # Would use J-Link Commander to flash
    LoaderResult_failure("J-Link loader not implemented")

fn jlink_stop(pid: i32):
    pass

# =========================================================================
# Serial Loader Implementation (stub)
# =========================================================================

fn serial_start(config: LoaderConfig) -> LoaderResult:
    # Would open serial port
    LoaderResult_failure("Serial loader not implemented")

# =========================================================================
# Exit Code Interpretation
# =========================================================================

use lib.qemu.{ExitCodeResult, interpret_exit_code}

fn qemu_exit_code_to_result(exit_code: i32) -> ExitCodeResult:
    # Use unified exit code interpretation
    # Most test binaries use debug-exit device
    interpret_exit_code(exit_code, true)
