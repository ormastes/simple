# Test Runner Host Transport
#
# Communication transport for receiving test results from target.
# Supports stdio, serial port, TCP socket, and file transports.
#
# Transport Types:
#   TRANSPORT_STDIO=0, TRANSPORT_SERIAL=1, TRANSPORT_TCP=2, TRANSPORT_FILE=3

# =========================================================================
# Transport Configuration
# =========================================================================

class TransportConfig:
    transport_type: i32        # TRANSPORT_* constant
    path: text                 # Port path, socket address, or file path
    baudrate: i32              # For serial
    timeout_ms: i64            # Read timeout

fn TransportConfig_stdio() -> TransportConfig:
    TransportConfig(
        transport_type: 0,      # TRANSPORT_STDIO
        path: "",
        baudrate: 0,
        timeout_ms: 30000
    )

fn TransportConfig_serial(port: text, baudrate: i32) -> TransportConfig:
    TransportConfig(
        transport_type: 1,      # TRANSPORT_SERIAL
        path: port,
        baudrate: baudrate,
        timeout_ms: 30000
    )

fn TransportConfig_tcp(address: text) -> TransportConfig:
    TransportConfig(
        transport_type: 2,      # TRANSPORT_TCP
        path: address,
        baudrate: 0,
        timeout_ms: 30000
    )

fn TransportConfig_file(path: text) -> TransportConfig:
    TransportConfig(
        transport_type: 3,      # TRANSPORT_FILE
        path: path,
        baudrate: 0,
        timeout_ms: 0           # No timeout for file
    )

# =========================================================================
# Transport Interface
# =========================================================================

class Transport:
    config: TransportConfig
    buffer: [i32]              # Read buffer
    connected: bool
    error: text

fn Transport_create(config: TransportConfig) -> Transport:
    Transport(
        config: config,
        buffer: [],
        connected: false,
        error: ""
    )

fn Transport_stdio() -> Transport:
    Transport_create(TransportConfig_stdio())

fn Transport_serial(port: text, baudrate: i32) -> Transport:
    Transport_create(TransportConfig_serial(port, baudrate))

fn Transport_tcp(address: text) -> Transport:
    Transport_create(TransportConfig_tcp(address))

fn Transport_file(path: text) -> Transport:
    Transport_create(TransportConfig_file(path))

impl Transport:
    # Connect/open the transport
    me connect() -> bool:
        if self.config.transport_type == 0:
            # STDIO is always connected
            self.connected = true
            true
        elif self.config.transport_type == 1:
            # Would open serial port
            self.error = "Serial transport not implemented"
            false
        elif self.config.transport_type == 2:
            # Would open TCP connection
            self.error = "TCP transport not implemented"
            false
        elif self.config.transport_type == 3:
            # Would open file
            self.connected = true  # Simulate for now
            true
        else:
            self.error = "Unknown transport type"
            false

    # Disconnect/close
    me disconnect():
        self.connected = false

    # Read available bytes
    me read() -> [i32]:
        if not self.connected:
            return []

        # Would read from actual transport
        # For now, return empty (real implementation uses FFI)
        []

    # Read with timeout
    me read_timeout(timeout_ms: i64) -> [i32]:
        # Would implement timeout logic
        self.read()

    # Feed data manually (for testing)
    me feed(data: [i32]):
        for b in data:
            self.buffer.push(b)

    # Get buffered data
    fn get_buffer() -> [i32]:
        self.buffer

    # Clear buffer
    me clear_buffer():
        self.buffer = []

    fn is_connected() -> bool:
        self.connected

    fn get_error() -> text:
        self.error

# =========================================================================
# Buffered Transport (with protocol parsing)
# =========================================================================

class BufferedTransport:
    transport: Transport
    read_buffer: [i32]

fn BufferedTransport_create(transport: Transport) -> BufferedTransport:
    BufferedTransport(
        transport: transport,
        read_buffer: []
    )

impl BufferedTransport:
    me connect() -> bool:
        self.transport.connect()

    me disconnect():
        self.transport.disconnect()

    # Read and buffer data
    me poll():
        val data = self.transport.read()
        for b in data:
            self.read_buffer.push(b)

    # Feed data manually (for testing)
    me feed(data: [i32]):
        for b in data:
            self.read_buffer.push(b)

    # Get all buffered data
    fn get_data() -> [i32]:
        self.read_buffer

    # Clear buffer
    me clear():
        self.read_buffer = []

    # Read specific number of bytes (blocking)
    me read_bytes(count: i32) -> [i32]:
        # Would block until enough data available
        var result: [i32] = []
        var i = 0
        while i < count and i < self.read_buffer.len() as i32:
            result.push(self.read_buffer[i])
            i = i + 1
        result

    fn available() -> i32:
        self.read_buffer.len() as i32

    fn is_connected() -> bool:
        self.transport.is_connected()
