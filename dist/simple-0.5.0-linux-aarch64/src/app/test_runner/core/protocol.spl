# Test Runner Binary Protocol
#
# Binary protocol for embedded test communication.
#
# Message format:
#   [u8]  Magic (0xAB)
#   [u8]  Version (0x01)
#   [u8]  Message type
#   [u16] Payload length (little-endian)
#   [...]  Payload (depends on type)

# =========================================================================
# Protocol Constants Reference (use inline values)
# =========================================================================
#
# PROTO_MAGIC=0xAB, PROTO_VERSION=0x01, PROTO_HEADER_SIZE=5
#
# Message types:
#   MSG_READY=0x01, MSG_SUITE_START=0x10, MSG_SUITE_END=0x11
#   MSG_TEST_START=0x20, MSG_TEST_PASS=0x21, MSG_TEST_FAIL=0x22
#   MSG_TEST_SKIP=0x23, MSG_TEST_TIMEOUT=0x24, MSG_LOG=0x30
#   MSG_ASSERT_FAIL=0x40, MSG_COMPLETE=0xFF

# =========================================================================
# Byte Encoding/Decoding
# =========================================================================

fn encode_u16(value: i32) -> [i32]:
    [value & 0xFF, (value >> 8) & 0xFF]

fn decode_u16(b0: i32, b1: i32) -> i32:
    b0 | (b1 << 8)

fn encode_u32(value: i32) -> [i32]:
    [value & 0xFF, (value >> 8) & 0xFF, (value >> 16) & 0xFF, (value >> 24) & 0xFF]

fn decode_u32(b0: i32, b1: i32, b2: i32, b3: i32) -> i32:
    b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

fn encode_i64_as_u32(value: i64) -> [i32]:
    # Encode low 32 bits only
    val low = value as i32
    encode_u32(low)

# =========================================================================
# Protocol Message
# =========================================================================

class ProtocolMessage:
    msg_type: i32
    payload: [i32]

impl ProtocolMessage:
    static fn create(msg_type: i32, payload: [i32]) -> ProtocolMessage:
        ProtocolMessage(msg_type: msg_type, payload: payload)

    static fn ready(client_version: i32, test_count: i32) -> ProtocolMessage:
        var payload: [i32] = []
        for b in encode_u32(client_version):
            payload.push(b)
        for b in encode_u32(test_count):
            payload.push(b)
        ProtocolMessage(msg_type: 0x01, payload: payload)  # MSG_READY

    static fn suite_start(suite_id: i32) -> ProtocolMessage:
        ProtocolMessage(msg_type: 0x10, payload: encode_u32(suite_id))  # MSG_SUITE_START

    static fn suite_end(suite_id: i32) -> ProtocolMessage:
        ProtocolMessage(msg_type: 0x11, payload: encode_u32(suite_id))  # MSG_SUITE_END

    static fn test_start(test_id: i32) -> ProtocolMessage:
        ProtocolMessage(msg_type: 0x20, payload: encode_u32(test_id))  # MSG_TEST_START

    static fn test_pass(test_id: i32, duration_ms: i32) -> ProtocolMessage:
        var payload: [i32] = []
        for b in encode_u32(test_id):
            payload.push(b)
        for b in encode_u32(duration_ms):
            payload.push(b)
        ProtocolMessage(msg_type: 0x21, payload: payload)  # MSG_TEST_PASS

    static fn test_fail(test_id: i32, duration_ms: i32, msg_handle: i32, file_handle: i32, line: i32) -> ProtocolMessage:
        var payload: [i32] = []
        for b in encode_u32(test_id):
            payload.push(b)
        for b in encode_u32(duration_ms):
            payload.push(b)
        for b in encode_u32(msg_handle):
            payload.push(b)
        for b in encode_u32(file_handle):
            payload.push(b)
        for b in encode_u32(line):
            payload.push(b)
        ProtocolMessage(msg_type: 0x22, payload: payload)  # MSG_TEST_FAIL

    static fn test_skip(test_id: i32) -> ProtocolMessage:
        ProtocolMessage(msg_type: 0x23, payload: encode_u32(test_id))  # MSG_TEST_SKIP

    static fn test_timeout(test_id: i32, duration_ms: i32) -> ProtocolMessage:
        var payload: [i32] = []
        for b in encode_u32(test_id):
            payload.push(b)
        for b in encode_u32(duration_ms):
            payload.push(b)
        ProtocolMessage(msg_type: 0x24, payload: payload)  # MSG_TEST_TIMEOUT

    static fn log(msg_handle: i32) -> ProtocolMessage:
        ProtocolMessage(msg_type: 0x30, payload: encode_u32(msg_handle))  # MSG_LOG

    static fn assert_fail(test_id: i32, msg_handle: i32, file_handle: i32, line: i32) -> ProtocolMessage:
        var payload: [i32] = []
        for b in encode_u32(test_id):
            payload.push(b)
        for b in encode_u32(msg_handle):
            payload.push(b)
        for b in encode_u32(file_handle):
            payload.push(b)
        for b in encode_u32(line):
            payload.push(b)
        ProtocolMessage(msg_type: 0x40, payload: payload)  # MSG_ASSERT_FAIL

    static fn complete(total: i32, passed: i32, failed: i32, skipped: i32) -> ProtocolMessage:
        var payload: [i32] = []
        for b in encode_u32(total):
            payload.push(b)
        for b in encode_u32(passed):
            payload.push(b)
        for b in encode_u32(failed):
            payload.push(b)
        for b in encode_u32(skipped):
            payload.push(b)
        ProtocolMessage(msg_type: 0xFF, payload: payload)  # MSG_COMPLETE

    fn payload_len() -> i32:
        self.payload.len() as i32

    fn encode() -> [i32]:
        var bytes: [i32] = []
        # Header
        bytes.push(0xAB)  # PROTO_MAGIC
        bytes.push(0x01)  # PROTO_VERSION
        bytes.push(self.msg_type)
        for b in encode_u16(self.payload_len()):
            bytes.push(b)
        # Payload
        for b in self.payload:
            bytes.push(b)
        bytes

    fn encode_to_text() -> text:
        var result = ""
        for b in self.encode():
            result = result + b.to_char()
        result

# =========================================================================
# Protocol Parser (streaming)
# =========================================================================

class ParsedMessage:
    msg_type: i32
    payload: [i32]
    valid: bool

impl ParsedMessage:
    static fn invalid() -> ParsedMessage:
        ParsedMessage(msg_type: 0, payload: [], valid: false)

    static fn create(msg_type: i32, payload: [i32]) -> ParsedMessage:
        ParsedMessage(msg_type: msg_type, payload: payload, valid: true)

class ProtocolParser:
    buffer: [i32]
    messages: [ParsedMessage]

impl ProtocolParser:
    static fn create() -> ProtocolParser:
        ProtocolParser(buffer: [], messages: [])

    me feed(data: [i32]):
        for b in data:
            self.buffer.push(b)
        self.process_buffer()

    me feed_byte(b: i32):
        self.buffer.push(b)
        self.process_buffer()

    me process_buffer():
        while self.buffer.len() >= 5:  # PROTO_HEADER_SIZE
            # Check magic
            if self.buffer[0] != 0xAB:  # PROTO_MAGIC
                # Skip invalid byte
                self.buffer.remove(0)
                continue

            # Check version
            if self.buffer[1] != 0x01:  # PROTO_VERSION
                self.buffer.remove(0)
                continue

            # Get message type and length
            val msg_type = self.buffer[2]
            val payload_len = decode_u16(self.buffer[3], self.buffer[4])

            # Check if we have full message
            val total_len = 5 + payload_len  # PROTO_HEADER_SIZE + payload_len
            if self.buffer.len() < total_len as i64:
                return  # Wait for more data

            # Extract payload
            var payload: [i32] = []
            for i in 5..total_len:  # PROTO_HEADER_SIZE..total_len
                payload.push(self.buffer[i])

            # Remove processed bytes
            for _ in 0..total_len:
                self.buffer.remove(0)

            # Add parsed message
            self.messages.push(ParsedMessage.create(msg_type, payload))

    fn has_messages() -> bool:
        self.messages.len() > 0

    me pop_message() -> ParsedMessage:
        if self.messages.len() == 0:
            ParsedMessage.invalid()
        else:
            val msg = self.messages[0]
            self.messages.remove(0)
            msg

    fn pending_bytes() -> i32:
        self.buffer.len() as i32

# =========================================================================
# Message Payload Decoders
# =========================================================================

class ReadyPayload:
    client_version: i32
    test_count: i32
    valid: bool

impl ReadyPayload:
    static fn decode(payload: [i32]) -> ReadyPayload:
        if payload.len() < 8:
            ReadyPayload(client_version: 0, test_count: 0, valid: false)
        else:
            ReadyPayload(
                client_version: decode_u32(payload[0], payload[1], payload[2], payload[3]),
                test_count: decode_u32(payload[4], payload[5], payload[6], payload[7]),
                valid: true
            )

class TestPassPayload:
    test_id: i32
    duration_ms: i32
    valid: bool

impl TestPassPayload:
    static fn decode(payload: [i32]) -> TestPassPayload:
        if payload.len() < 8:
            TestPassPayload(test_id: 0, duration_ms: 0, valid: false)
        else:
            TestPassPayload(
                test_id: decode_u32(payload[0], payload[1], payload[2], payload[3]),
                duration_ms: decode_u32(payload[4], payload[5], payload[6], payload[7]),
                valid: true
            )

class TestFailPayload:
    test_id: i32
    duration_ms: i32
    msg_handle: i32
    file_handle: i32
    line: i32
    valid: bool

impl TestFailPayload:
    static fn decode(payload: [i32]) -> TestFailPayload:
        if payload.len() < 20:
            TestFailPayload(test_id: 0, duration_ms: 0, msg_handle: 0, file_handle: 0, line: 0, valid: false)
        else:
            TestFailPayload(
                test_id: decode_u32(payload[0], payload[1], payload[2], payload[3]),
                duration_ms: decode_u32(payload[4], payload[5], payload[6], payload[7]),
                msg_handle: decode_u32(payload[8], payload[9], payload[10], payload[11]),
                file_handle: decode_u32(payload[12], payload[13], payload[14], payload[15]),
                line: decode_u32(payload[16], payload[17], payload[18], payload[19]),
                valid: true
            )

class CompletePayload:
    total: i32
    passed: i32
    failed: i32
    skipped: i32
    valid: bool

impl CompletePayload:
    static fn decode(payload: [i32]) -> CompletePayload:
        if payload.len() < 16:
            CompletePayload(total: 0, passed: 0, failed: 0, skipped: 0, valid: false)
        else:
            CompletePayload(
                total: decode_u32(payload[0], payload[1], payload[2], payload[3]),
                passed: decode_u32(payload[4], payload[5], payload[6], payload[7]),
                failed: decode_u32(payload[8], payload[9], payload[10], payload[11]),
                skipped: decode_u32(payload[12], payload[13], payload[14], payload[15]),
                valid: true
            )
