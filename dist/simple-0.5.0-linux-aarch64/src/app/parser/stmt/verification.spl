# Statement Parser - Verification Module
#
# Parsing for verification constructs: Lean blocks, proof hints, calculational proofs,
# and Gherkin BDD DSL (feature, scenario, examples, step definitions).
# Extracted from statements.spl (Lean Blocks and Gherkin DSL sections)

from token import {Span, Token, TokenKind}
from ast import {Node, Block, Expr,
                 LeanBlock, ProofHintStmt, CalcStmt, CalcStep,
                 Argument}
from error import {ParseError}

export VerificationParser

impl Parser:
    # ========================================================================
    # Lean Verification
    # ========================================================================

    # Parse lean import block: lean import "path" or lean import "path" { code }
    fn parse_lean_import_block(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.advance()  # consume "lean"
        self.expect(TokenKind.Import)

        val import_path = match self.current.kind:
            TokenKind.String(s):
                self.advance()
                s
            TokenKind.RawString(s):
                self.advance()
                s
            _: return Err(ParseError.syntax_error_with_span(
                "expected string literal for import path", self.current.span))

        # Check for optional inline code block
        val code = if self.check_custom_block("lean"):
            val payload = self.get_custom_block_payload()
            self.advance()
            payload
        else:
            ""

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.LeanBlock(LeanBlock(
            span: span,
            import_path: Some(import_path),
            code: code,
        )))

    # Parse lean custom block as node: lean{...}
    fn parse_lean_custom_block_as_node(self) -> Result<Node, ParseError>:
        val span = self.current.span
        if self.check_custom_block("lean"):
            val code = self.get_custom_block_payload()
            self.advance()
            Ok(Node.LeanBlock(LeanBlock(
                span: span,
                import_path: None,
                code: code,
            )))
        else:
            Err(ParseError.syntax_error_with_span(
                "expected lean{...} custom block", self.current.span))

    # Parse lean hint: lean hint: "tactic"
    fn parse_lean_hint(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.advance()  # consume "lean"
        self.expect_ident_value("hint")
        self.expect(TokenKind.Colon)

        val hint = match self.current.kind:
            TokenKind.String(s):
                self.advance()
                s
            TokenKind.RawString(s):
                self.advance()
                s
            _: return Err(ParseError.syntax_error_with_span(
                "expected string literal for lean hint tactic", self.current.span))

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.ProofHint(ProofHintStmt(span: span, hint: hint)))

    # Parse calculational proof block: calc: steps...
    fn parse_calc(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect_ident_value("calc")
        self.expect(TokenKind.Colon)
        self.expect(TokenKind.Newline)
        self.expect(TokenKind.Indent)

        var steps = []

        # First expression (no leading ==)
        val first_expr_span = self.current.span
        val first_expr = self.parse_expression()
        val first_just = self.parse_calc_justification()

        steps.append(CalcStep(
            span: Span(first_expr_span.start, self.previous.span.end, first_expr_span.line, first_expr_span.column),
            expr: first_expr,
            justification: first_just,
        ))

        if self.check(TokenKind.Newline):
            self.advance()

        # Subsequent steps: == expr (optional by: "justification")
        while not self.check(TokenKind.Dedent) and not self.is_at_end():
            val step_span = self.current.span
            if not self.check(TokenKind.Eq):
                break
            self.advance()  # consume ==

            val expr = self.parse_expression()
            val just = self.parse_calc_justification()

            steps.append(CalcStep(
                span: Span(step_span.start, self.previous.span.end, step_span.line, step_span.column),
                expr: expr,
                justification: just,
            ))

            if self.check(TokenKind.Newline):
                self.advance()

        if self.check(TokenKind.Dedent):
            self.advance()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Calc(CalcStmt(span: span, steps: steps)))

    # Parse optional justification: by: "reason"
    fn parse_calc_justification(self) -> Option<String>:
        val is_by = self.check(TokenKind.By) or self.check_ident("by")
        if is_by:
            self.advance()
            self.expect(TokenKind.Colon)
            match self.current.kind:
                TokenKind.String(s):
                    self.advance()
                    Some(s)
                TokenKind.RawString(s):
                    self.advance()
                    Some(s)
                _: self.error("expected string literal for calc justification")
        else:
            None

    # ========================================================================
    # Gherkin BDD DSL
    # ========================================================================

    # Parse feature: feature Name: block
    fn parse_feature(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Feature)

        val name = self.parse_gherkin_description()
        self.expect(TokenKind.Colon)
        val block = self.parse_block()

        # Generate: feature("Name", do_block)
        val call_expr = Expr.Call(
            callee: Expr.Identifier("feature"),
            args: [
                Argument(label: None, value: Expr.String(name)),
                Argument(label: None, value: Expr.DoBlock(block.statements)),
            ],
        )
        Ok(Node.Expression(call_expr))

    # Parse scenario: scenario Name: block
    fn parse_scenario(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Scenario)

        # Check for outline modifier
        val fn_name = if self.check(TokenKind.Outline):
            self.advance()
            "scenario_outline"
        else:
            "scenario"

        val name = self.parse_gherkin_description()
        self.expect(TokenKind.Colon)
        val block = self.parse_block()

        val call_expr = Expr.Call(
            callee: Expr.Identifier(fn_name),
            args: [
                Argument(label: None, value: Expr.String(name)),
                Argument(label: None, value: Expr.DoBlock(block.statements)),
            ],
        )
        Ok(Node.Expression(call_expr))

    # Parse examples table: examples name: block
    fn parse_examples(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Examples)

        val name = self.parse_gherkin_name()
        self.expect(TokenKind.Colon)
        val block = self.parse_block()

        val rows_expr = self.block_to_array_expr(block, start_span)

        val call_expr = Expr.Call(
            callee: Expr.Identifier("examples"),
            args: [
                Argument(label: None, value: Expr.String(name)),
                Argument(label: None, value: rows_expr),
            ],
        )
        Ok(Node.Expression(call_expr))

    # Parse step keywords: given/when/then/and_then pattern: body
    fn parse_step_ref_as_node(self) -> Result<Node, ParseError>:
        val start_span = self.current.span

        val fn_name = match self.current.kind:
            TokenKind.Given: "given"
            TokenKind.When: "when"
            TokenKind.Then: "then"
            TokenKind.AndThen: "and_then"
            _: return Err(ParseError.unexpected_token(
                "given, when, then, or and_then",
                "{self.current.kind}", self.current.span))
        self.advance()

        val pattern = self.parse_step_pattern_as_string()
        self.expect(TokenKind.Colon)

        # Optional body block
        val body_expr = if self.check(TokenKind.Newline):
            self.advance()
            if self.check(TokenKind.Indent):
                self.advance()
                val block = self.parse_block_body()
                Expr.DoBlock(block.statements)
            else:
                Expr.Nil
        else:
            Expr.Nil

        val call_expr = Expr.Call(
            callee: Expr.Identifier(fn_name),
            args: [
                Argument(label: None, value: Expr.String(pattern)),
                Argument(label: None, value: body_expr),
            ],
        )
        Ok(Node.Expression(call_expr))

    # Parse gherkin name (identifier or string)
    fn parse_gherkin_name(self) -> String:
        match self.current.kind:
            TokenKind.Identifier(name, _):
                self.advance()
                name
            TokenKind.String(s):
                self.advance()
                s
            _: self.error("expected name")

    # Parse step pattern as string
    fn parse_step_pattern_as_string(self) -> String:
        var parts = []
        while not self.check(TokenKind.Colon) and not self.is_at_end():
            if self.check(TokenKind.Lt):
                self.advance()
                val name = self.expect_identifier()
                self.expect(TokenKind.Gt)
                parts.append("<{name}>")
            elif self.is_identifier():
                parts.append(self.expect_identifier())
            elif self.is_integer():
                parts.append("{self.current_integer()}")
                self.advance()
            elif self.is_string():
                parts.append(self.current_string())
                self.advance()
            elif self.is_keyword_for_pattern():
                parts.append(self.current.lexeme)
                self.advance()
            else:
                break
        parts.join(" ")

    # Parse description text until colon
    fn parse_gherkin_description(self) -> String:
        var parts = []
        while not self.check(TokenKind.Colon) and not self.is_at_end():
            if self.is_identifier():
                parts.append(self.expect_identifier())
            elif self.is_integer():
                parts.append("{self.current_integer()}")
                self.advance()
            elif self.is_string():
                parts.append(self.current_string())
                self.advance()
            elif self.is_keyword_for_pattern():
                parts.append(self.current.lexeme)
                self.advance()
            else:
                break
        parts.join(" ")

    # Check if current token is a keyword usable in step patterns
    fn is_keyword_for_pattern(self) -> Bool:
        match self.current.kind:
            TokenKind.Is: true
            TokenKind.In: true
            TokenKind.To: true
            TokenKind.Not: true
            TokenKind.And: true
            TokenKind.Or: true
            TokenKind.If: true
            TokenKind.For: true
            TokenKind.While: true
            TokenKind.With: true
            TokenKind.New: true
            TokenKind.Result: true
            TokenKind.True: true
            TokenKind.False: true
            TokenKind.Nil: true
            TokenKind.As: true
            TokenKind.From: true
            TokenKind.Type: true
            TokenKind.Return: true
            _: false

    # Convert block statements to array expression
    fn block_to_array_expr(self, block: Block, span: Span) -> Expr:
        val elements = []
        for stmt in block.statements:
            match stmt:
                Node.Expression(expr): elements.append(expr)
                _: ()
        Expr.Array(elements)
