# i18n Expressions
#
# Parses internationalization (i18n) string literals and templates.

from token import {TokenKind}
from ast import {Expr, FStringPart}
from error import {ParseError}

impl Parser:

    fn parse_i18n_literal() -> Expr:
        match self.current.kind:
            TokenKind.I18nString(name, default_text):
                self.advance()
                if self.check(TokenKind.LBrace):
                    val args = self.parse_i18n_args()
                    Expr.I18nTemplate(name: name, parts: [FStringPart.Literal(default_text)], args: args)
                else:
                    Expr.I18nString(name: name, default_text: default_text)
            TokenKind.I18nFString(name, parts):
                self.advance()
                val parsed_parts = self.parse_fstring_parts(parts)
                if self.check(TokenKind.LBrace):
                    val args = self.parse_i18n_args()
                    Expr.I18nTemplate(name: name, parts: parsed_parts, args: args)
                else:
                    Expr.I18nTemplate(name: name, parts: parsed_parts, args: [])
            _:
                raise ParseError.unexpected_token("i18n literal",
                    "{self.current.kind}", self.current.span)

    fn parse_i18n_args() -> [(text, Expr)]:
        self.expect(TokenKind.LBrace)
        var args = []
        while not self.check(TokenKind.RBrace):
            val key = self.expect_identifier()
            self.expect(TokenKind.Colon)
            val value = self.parse_expression()
            args.push((key, value))
            if not self.check(TokenKind.RBrace):
                self.expect(TokenKind.Comma)
        self.expect(TokenKind.RBrace)
        args
