# MCP (Model Context Protocol) Server for Simple Language
# Provides LLM-friendly code representation via the MCP protocol
#
# Usage:
#   simple mcp server              # Start MCP server (stdio mode)
#   simple mcp server --debug      # Start with debug logging
#   simple mcp <file.spl>          # Generate MCP preview (CLI mode)
#   simple mcp read <file.spl>     # Read file in MCP mode
#   simple mcp expand <file> <sym> # Expand specific symbol
#   simple mcp json <file.spl>     # Generate JSON output

# I/O imports
use app.io.mod (file_read, get_args, exit, shell, cwd)

# MCP modules
use app.mcp.resources
use app.mcp.prompts
use app.mcp.bugdb_resource

struct ShellResult:
    exit_code: Int
    stdout: String?
    stderr: String?

# Brace helpers (avoid f-string interpolation issues)
fn LB() -> String:
    123 as char

fn RB() -> String:
    125 as char

fn Q() -> String:
    "\""

# Option unwrap helper
fn unwrap_idx(opt: Option<Int>) -> Int:
    match opt:
        case Some(i):
            return i
        case None:
            return -1

fn unwrap_str(result: Result<String, String>) -> String:
    match result:
        case Ok(s):
            return s
        case Err(_):
            return ""

# Skip program name and script path to get clean args
fn get_clean_args(all_args: [String]) -> [String]:
    var args = []
    var start_idx = 1
    # If second arg is the script path (ends with .spl), skip it too
    if all_args.len() > 1 and all_args[1].ends_with(".spl"):
        start_idx = 2
    var i = start_idx
    while i < all_args.len():
        args = args + [all_args[i]]
        i = i + 1
    args

# Main entry point
fn main():
    val raw_args = get_args()
    val args = get_clean_args(raw_args)

    if args.len() < 1:
        print_usage()
        exit(1)

    val command = args[0]

    if command == "--help" or command == "-h":
        print_usage()
        exit(0)

    elif command == "server":
        val debug_mode = has_flag(args, "--debug")
        start_server(debug_mode)

    elif command == "read":
        handle_read(args)

    elif command == "expand":
        handle_expand(args)

    elif command == "search":
        handle_search(args)

    elif command == "json":
        handle_json(args)

    else:
        handle_default_read(args)

# Print usage information
fn print_usage():
    print("MCP (Model Context Protocol) Server for Simple Language")
    print("")
    print("Usage:")
    print("  simple mcp server [--debug]          # Start MCP server (stdio)")
    print("  simple mcp <file.spl>                # Generate MCP outline")
    print("  simple mcp read <file.spl>           # Read file in MCP mode")
    print("  simple mcp expand <file.spl> <sym>   # Expand specific symbol")
    print("  simple mcp search <query>            # Search for symbols")
    print("  simple mcp json <file.spl> [--meta]  # Generate JSON output")
    print("")
    print("Server Mode:")
    print("  The server mode implements the Model Context Protocol over stdio.")
    print("  It can be used with MCP-compatible clients like Claude Code.")
    print("")
    print("Options:")
    print("  --help, -h          Show this help message")
    print("  --debug             Enable debug logging (server mode)")
    print("  --all               Show private symbols too")
    print("  --meta              Include metadata in JSON output")
    print("  --expand=<what>     What to expand: signature|body|all")
    print("  --show-coverage     Display test coverage overlays")
    print("")
    print("Examples:")
    print("  simple mcp server                    # Start MCP server")
    print("  simple mcp user.spl")
    print("  simple mcp expand user.spl User")
    print("  simple mcp json user.spl --meta")

# --- MCP JSON-RPC Server (stdio) ---

fn start_server(debug_mode: Bool):
    if debug_mode:
        debug_log("MCP server starting in debug mode")

    # Initialize resource and prompt managers
    val project_root = get_current_dir()
    val resource_mgr = resources.ResourceManager.create(project_root)
    val prompt_mgr = prompts.PromptManager.create(project_root)

    if debug_mode:
        debug_log("Initialized with project root: " + project_root)

    # Send nothing until we get initialize request
    var running = true
    while running:
        val line = read_stdin_message()
        if line == "":
            running = false
        else:
            val response = handle_jsonrpc(line, debug_mode, resource_mgr, prompt_mgr)
            if response != "":
                write_stdout_message(response)

fn debug_log(msg: String):
    eprint("DEBUG: " + msg)

fn read_stdin_message() -> String:
    # Read Content-Length header
    var header = input()
    if header == "":
        return ""

    # Strip trailing \r if present
    if header.ends_with("\r"):
        header = header.substring(0, header.len() - 1)

    # Parse content length
    var content_length = 0
    if header.starts_with("Content-Length:"):
        val len_str = header.replace("Content-Length:", "").trim()
        content_length = len_str.to_int()

    if content_length == 0:
        return ""

    # Skip blank line after headers
    input()

    # Read body (JSON-RPC body is typically one line)
    val body = input()
    body

fn write_stdout_message(body: String):
    var header = "Content-Length: "
    header = header + body.len().to_string()
    header = header + "\r\n\r\n"
    print_raw(header)
    print_raw(body)

fn handle_jsonrpc(body: String, debug_mode: Bool, resource_mgr: resources.ResourceManager, prompt_mgr: prompts.PromptManager) -> String:
    if debug_mode:
        debug_log("Request: " + body)

    # Simple JSON parsing for method extraction
    val method = extract_json_string(body, "method")
    val id = extract_json_value(body, "id")

    if method == "initialize":
        return make_initialize_response(id)
    elif method == "initialized":
        return ""  # Notification, no response
    elif method == "shutdown":
        return make_result_response(id, "null")
    elif method == "exit":
        exit(0)
        return ""
    elif method == "tools/list":
        return make_tools_list_response(id)
    elif method == "tools/call":
        val tool_name = extract_nested_string(body, "params", "name")
        return handle_tool_call(id, tool_name, body, debug_mode)
    elif method == "resources/list":
        return handle_resources_list(id, resource_mgr, debug_mode)
    elif method == "resources/read":
        val uri = extract_nested_string(body, "params", "uri")
        return handle_resources_read(id, uri, resource_mgr, debug_mode)
    elif method == "resources/templates/list":
        return handle_resources_templates_list(id, resource_mgr, debug_mode)
    elif method == "prompts/list":
        return handle_prompts_list(id, prompt_mgr, debug_mode)
    elif method == "prompts/get":
        val prompt_name = extract_nested_string(body, "params", "name")
        return handle_prompts_get(id, prompt_name, body, prompt_mgr, debug_mode)
    elif method == "logging/setLevel":
        val level = extract_nested_string(body, "params", "level")
        if debug_mode:
            debug_log("Log level set to: " + level)
        return make_result_response(id, "null")
    else:
        if debug_mode:
            debug_log("Unknown method: " + method)
        return make_error_response(id, -32601, "Method not found: " + method)

fn jp(key: String, val_str: String) -> String:
    var r = Q()
    r = r + key
    r = r + Q()
    r = r + ":"
    r = r + val_str
    r

fn js(s: String) -> String:
    var r = Q()
    r = r + s
    r = r + Q()
    r

fn jo1(pair: String) -> String:
    var r = LB()
    r = r + pair
    r = r + RB()
    r

fn jo2(p1: String, p2: String) -> String:
    var r = LB()
    r = r + p1
    r = r + ","
    r = r + p2
    r = r + RB()
    r

fn jo3(p1: String, p2: String, p3: String) -> String:
    var r = LB()
    r = r + p1
    r = r + ","
    r = r + p2
    r = r + ","
    r = r + p3
    r = r + RB()
    r

fn make_initialize_response(id: String) -> String:
    # Server info with instructions for MCPSearch
    var server_info = LB()
    server_info = server_info + jp("name", js("simple-mcp"))
    server_info = server_info + ","
    server_info = server_info + jp("version", js("2.0.0"))
    server_info = server_info + ","
    val instructions = "Search for Simple MCP tools when the user asks about Simple language source code, bugs, tests, or features. Provides code reading (read_code, list_files, search_code, file_info), bug tracking (bugdb_get, bugdb_add, bugdb_update), feature tracking, and test result tools."
    server_info = server_info + jp("instructions", js(instructions))
    server_info = server_info + RB()

    # Capabilities: tools, resources, prompts, logging
    var caps = LB()
    caps = caps + jp("tools", jo1(""))
    caps = caps + ","
    caps = caps + jp("resources", jo1(""))
    caps = caps + ","
    caps = caps + jp("prompts", jo1(""))
    caps = caps + ","
    caps = caps + jp("logging", jo1(""))
    caps = caps + RB()
    val result = jo3(jp("protocolVersion", js("2025-06-18")), jp("capabilities", caps), jp("serverInfo", server_info))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_tool_schema(name: String, desc: String, prop_name: String, prop_desc: String, required: Bool, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val prop = jo2(jp("type", js("string")), jp("description", js(prop_desc)))
    val props = jo1(jp(prop_name, prop))
    var req_arr = "[]"
    if required:
        req_arr = "[" + js(prop_name) + "]"
    val schema = jo3(jp("type", js("object")), jp("properties", props), jp("required", req_arr))

    # Build annotations object
    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro)
    annot = annot + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest)
    annot = annot + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp)
    annot = annot + ","
    annot = annot + jp("openWorldHint", "false")
    annot = annot + RB()

    # Return tool schema with annotations
    var result = LB()
    result = result + jp("name", js(name))
    result = result + ","
    result = result + jp("description", js(desc))
    result = result + ","
    result = result + jp("inputSchema", schema)
    result = result + ","
    result = result + jp("annotations", annot)
    result = result + RB()
    result

fn make_tools_list_response(id: String) -> String:
    # Tool annotations: (read_only, destructive, idempotent)
    val t1 = make_tool_schema("read_code", "Read a Simple language source file", "path", "File path", true, true, false, true)
    val t2 = make_tool_schema("list_files", "List Simple language files in a directory", "path", "Directory path", false, true, false, true)
    val t3 = make_tool_schema("search_code", "Search for code patterns", "query", "Search query", true, true, false, true)
    val t4 = make_tool_schema("file_info", "Get file information", "path", "File path", true, true, false, true)
    # Bug database tools
    val t5 = make_tool_schema("bugdb_get", "Get bug by ID", "id", "Bug ID", true, true, false, true)
    val t6 = make_tool_schema("bugdb_add", "Add new bug", "bug", "Bug JSON", true, false, false, false)
    val t7 = make_tool_schema("bugdb_update", "Update existing bug", "id", "Bug ID", true, false, false, true)

    var tools = "["
    tools = tools + t1
    tools = tools + ","
    tools = tools + t2
    tools = tools + ","
    tools = tools + t3
    tools = tools + ","
    tools = tools + t4
    tools = tools + ","
    tools = tools + t5
    tools = tools + ","
    tools = tools + t6
    tools = tools + ","
    tools = tools + t7
    tools = tools + "]"
    val result = jo1(jp("tools", tools))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_tool_call(id: String, tool_name: String, body: String, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Tool call: " + tool_name)

    if tool_name == "read_code":
        val path = extract_nested_string(body, "arguments", "path")
        val content = read_file_safe(path)
        val escaped = escape_json(content)
        return make_tool_result(id, escaped)

    elif tool_name == "list_files":
        val path = extract_nested_string(body, "arguments", "path")
        var dir = path
        if dir == "":
            dir = "."
        val listing = list_spl_files(dir)
        val escaped = escape_json(listing)
        return make_tool_result(id, escaped)

    elif tool_name == "search_code":
        val query = extract_nested_string(body, "arguments", "query")
        val results = search_files(query)
        val escaped = escape_json(results)
        return make_tool_result(id, escaped)

    elif tool_name == "file_info":
        val path = extract_nested_string(body, "arguments", "path")
        val info = get_file_info(path)
        val escaped = escape_json(info)
        return make_tool_result(id, escaped)

    elif tool_name == "bugdb_get":
        val bug_id = extract_nested_string(body, "arguments", "id")
        val result = bugdb_resource.get_bug_by_id("doc/bug/bug_db.sdn", bug_id)
        return make_tool_result(id, result)

    elif tool_name == "bugdb_add":
        val bug_json = extract_nested_string(body, "arguments", "bug")
        val result = bugdb_resource.add_bug_from_json("doc/bug/bug_db.sdn", bug_json)
        return make_tool_result(id, result)

    elif tool_name == "bugdb_update":
        val bug_id = extract_nested_string(body, "arguments", "id")
        val bug_json = extract_nested_string(body, "arguments", "updates")
        val result = bugdb_resource.update_bug_from_json("doc/bug/bug_db.sdn", bug_id, bug_json)
        return make_tool_result(id, result)

    else:
        return make_error_response(id, -32602, "Unknown tool: " + tool_name)

fn make_tool_result(id: String, content: String) -> String:
    val text_obj = jo2(jp("type", js("text")), jp("text", js(content)))
    val result = jo1(jp("content", "[" + text_obj + "]"))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_result_response(id: String, result: String) -> String:
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_error_response(id: String, code: Int, message: String) -> String:
    val err = jo2(jp("code", code.to_string()), jp("message", js(escape_json(message))))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("error", err))

# --- Tool implementations ---

fn read_file_safe(path: String) -> String:
    val content = file_read(path)
    if content == "":
        return "Error: could not read file: " + path
    content

fn list_spl_files(dir: String) -> String:
    val result = shell("find " + dir + " -name '*.spl' -type f | sort")
    if result.exit_code == 0:
        return result.stdout ?? "No .spl files found"
    "Error listing files in " + dir

fn search_files(query: String) -> String:
    val result = shell("grep -rn '" + query + "' --include='*.spl' . 2>/dev/null | head -50")
    if result.exit_code == 0:
        return result.stdout ?? "No matches found"
    "No matches found for: " + query

fn get_file_info(path: String) -> String:
    val content = file_read(path)
    if content == "":
        return "Error: could not read file: " + path
    val lines = content.split("\n")
    var line_count = lines.len()
    var fn_count = 0
    var class_count = 0
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("fn ") or trimmed.starts_with("me ") or trimmed.starts_with("static fn "):
            fn_count = fn_count + 1
        elif trimmed.starts_with("class ") or trimmed.starts_with("struct "):
            class_count = class_count + 1
    "File: " + path + "\\nLines: " + line_count.to_string() + "\\nFunctions: " + fn_count.to_string() + "\\nClasses/Structs: " + class_count.to_string()

# --- JSON helpers (minimal, no library dependency) ---

fn extract_json_string(json: String, key: String) -> String:
    val search = Q() + key + Q() + ":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:
        return ""
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    if trimmed.starts_with(Q()):
        val rest = trimmed.substring(1)
        val end = unwrap_idx(rest.index_of(Q()))
        if end >= 0:
            return rest.substring(0, end)
    ""

fn extract_json_value(json: String, key: String) -> String:
    val search = Q() + key + Q() + ":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:
        return "null"
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    # Read until comma, closing brace, or end
    var end = 0
    for ch in trimmed:
        if ch == "," or ch == RB() or ch == "]":
            break
        end = end + 1
    trimmed.substring(0, end).trim()

fn extract_nested_string(json: String, outer_key: String, inner_key: String) -> String:
    val search = Q() + outer_key + Q() + ":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:

# main()  # Rest of file commented for debugging
