# Text replacement and pattern matching utilities
# Provides regex-like patterns and bulk text transformations

use app.io

export find_pattern, find_all_patterns, replace_pattern, replace_all
export extract_function_name, extract_identifiers
export count_matches, has_pattern

# Find first occurrence of pattern in text
fn find_pattern(text: text, pattern: text) -> (bool, i64, i64):
    """Find pattern in text, returns (found, start, end)"""
    val idx = text.find(pattern)
    if idx >= 0:
        (true, idx, idx + pattern.len())
    else:
        (false, -1, -1)

# Find all occurrences of pattern
fn find_all_patterns(text: text, pattern: text) -> [(i64, i64)]:
    """Find all occurrences of pattern, returns list of (start, end) positions"""
    var results = []
    var search_from = 0
    var remaining = text

    while remaining.len() > 0:
        val idx = remaining.find(pattern)
        if idx >= 0:
            val abs_start = search_from + idx
            val abs_end = abs_start + pattern.len()
            results = results + [(abs_start, abs_end)]
            search_from = abs_end
            remaining = text.substring(search_from, text.len())
        else:
            break

    results

# Replace first occurrence of pattern
fn replace_pattern(text: text, pattern: text, replacement: text) -> text:
    """Replace first occurrence of pattern with replacement"""
    val idx = text.find(pattern)
    if idx >= 0:
        val before = text.substring(0, idx)
        val after = text.substring(idx + pattern.len(), text.len())
        before + replacement + after
    else:
        text

# Replace all occurrences of pattern
fn replace_all(text: text, pattern: text, replacement: text) -> text:
    """Replace all occurrences of pattern with replacement"""
    var result = text
    var modified = true

    # Keep replacing until no more matches
    while modified:
        val new_result = replace_pattern(result, pattern, replacement)
        modified = new_result != result
        result = new_result

    result

# Extract function name from function definition
fn extract_function_name(line: text) -> text:
    """Extract function name from 'fn name(...' or 'extern fn name(...'"""
    var trimmed = line.trim()

    # Remove 'extern' if present
    if trimmed.starts_with("extern "):
        trimmed = trimmed.substring(7, trimmed.len()).trim()

    # Check for 'fn name('
    if trimmed.starts_with("fn "):
        trimmed = trimmed.substring(3, trimmed.len()).trim()

        # Find the opening parenthesis
        val paren_idx = trimmed.find("(")
        if paren_idx > 0:
            return trimmed.substring(0, paren_idx).trim()

    ""

# Extract all identifiers (simple: words starting with letter/underscore)
fn extract_identifiers(line: text) -> [text]:
    """Extract identifier-like tokens from line"""
    var identifiers = []
    var current = ""
    var in_identifier = false

    for i in 0..line.len():
        val ch = line[i]
        val is_alphanum = (ch >= 'a' and ch <= 'z') or
                          (ch >= 'A' and ch <= 'Z') or
                          (ch >= '0' and ch <= '9') or
                          ch == '_'

        if is_alphanum:
            current = current + "{ch}"
            in_identifier = true
        else:
            if in_identifier and current.len() > 0:
                # Check if starts with letter or underscore
                val first = current[0]
                if (first >= 'a' and first <= 'z') or
                   (first >= 'A' and first <= 'Z') or
                   first == '_':
                    identifiers = identifiers + [current]
            current = ""
            in_identifier = false

    # Add final identifier if we ended in one
    if in_identifier and current.len() > 0:
        val first = current[0]
        if (first >= 'a' and first <= 'z') or
           (first >= 'A' and first <= 'Z') or
           first == '_':
            identifiers = identifiers + [current]

    identifiers

# Count number of matches in text
fn count_matches(text: text, pattern: text) -> i64:
    """Count how many times pattern appears in text"""
    val matches = find_all_patterns(text, pattern)
    matches.len()

# Check if text contains pattern
fn has_pattern(text: text, pattern: text) -> bool:
    """Check if text contains pattern"""
    text.contains(pattern)
