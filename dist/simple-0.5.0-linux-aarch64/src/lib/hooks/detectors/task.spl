# Task Detector
# Parses doc/task/task_db.sdn and filters pending tasks

export TaskSummary, detect_tasks, format_summary

# Task summary
struct TaskSummary:
    total: i64
    pending: i64
    in_progress: i64
    incomplete_tasks: [TaskItem]

# Task item
struct TaskItem:
    id: text
    subject: text
    status: text
    owner: text

# Detect incomplete tasks
fn detect_tasks(db_path: text) -> TaskSummary:
    val summary = TaskSummary(
        total: 0,
        pending: 0,
        in_progress: 0,
        incomplete_tasks: []
    )

    if not file_exists(db_path):
        return summary

    val content = file_read(db_path)
    val items = parse_task_db(content)

    var pending = 0
    var in_progress = 0
    var incomplete = []

    for item in items:
        if item.status == "pending":
            pending = pending + 1
            incomplete.push(item)
        else if item.status == "in_progress":
            in_progress = in_progress + 1
            incomplete.push(item)

    TaskSummary(
        total: items.len(),
        pending: pending,
        in_progress: in_progress,
        incomplete_tasks: incomplete
    )

# Parse task database
fn parse_task_db(content: text) -> [TaskItem]:
    var items = []
    val lines = content.split("\n")
    var in_table = false

    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("#") or trimmed.len() == 0:
            continue

        if trimmed.contains("|") and trimmed.starts_with("tasks"):
            in_table = true
            continue

        if in_table:
            if not trimmed.contains(","):
                in_table = false
                continue

            val values = parse_row_values(trimmed)
            if values.len() >= 4:
                val item = TaskItem(
                    id: clean_value(values[0]),
                    subject: clean_value(values[1]),
                    status: clean_value(values[2]),
                    owner: clean_value(values[3])
                )
                items.push(item)

    items

# Parse row values
fn parse_row_values(row: text) -> [text]:
    var values = []
    var current = ""
    var in_quotes = false

    for i in 0..row.len():
        val ch = row[i:i+1]
        if ch == "\"":
            in_quotes = not in_quotes
        else if ch == "," and not in_quotes:
            values.push(current.trim())
            current = ""
        else:
            current = current + ch

    if current.len() > 0:
        values.push(current.trim())

    values

# Clean value
fn clean_value(value: text) -> text:
    var result = value.trim()
    if result.starts_with("\"") and result.ends_with("\""):
        result = result[1:-1]
    result

# Format summary
fn format_summary(summary: TaskSummary) -> text:
    if summary.total == 0:
        return "No tasks found"

    var result = "Tasks: {summary.total} total\n"
    result = result + "  Pending: {summary.pending}\n"
    result = result + "  In Progress: {summary.in_progress}\n"

    if summary.incomplete_tasks.len() > 0:
        result = result + "\nIncomplete Tasks:\n"
        for item in summary.incomplete_tasks:
            val owner = if item.owner.len() > 0: " ({item.owner})" else: ""
            result = result + "  [{item.status}] {item.subject}{owner}\n"

    result

# Helper functions
fn file_exists(path: text) -> bool:
    val result = shell("test -f '{path}' && echo yes || echo no")
    result.trim() == "yes"

fn file_read(path: text) -> text:
    shell("cat '{path}'")

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn shell(cmd: text) -> text:
    val (stdout, stderr, exit_code) = rt_process_run("sh", ["-c", cmd])
    if exit_code == 0: stdout else: ""
