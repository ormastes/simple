# Definition Parser - Impl Blocks
#
# Parsing for:
# - impl Type: methods...
# - impl Trait for Type: methods...
# - Associated type implementations
# - Interface bindings (static polymorphism)

from token import {Span, TokenKind}
from ast import {Node, ImplBlock, AssociatedTypeImpl, InterfaceBinding, FunctionDef,
                 Type, Visibility, Attribute, Effect, Parameter, Mutability}
from error import {ParseError}

export ImplParser

# ============================================================================
# Impl
# ============================================================================

fn parse_impl(self) -> Result<Node, ParseError>:
    self.parse_impl_with_attrs([])

fn parse_impl_with_attrs(self, attributes: [Attribute]) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Impl)

    val generic_params = self.parse_generic_params_as_strings()
    val first_type = self.parse_type()

    val (trait_name, trait_type_params, target_type) = if self.check(TokenKind.For):
        self.advance()
        val target = self.parse_type()
        match first_type:
            Type.Simple(name): (Some(name), [], target)
            Type.Generic(name, args): (Some(name), args, target)
            _: self.error("expected simple trait name")
    else:
        (None, [], first_type)

    val where_clause = self.parse_where_clause()
    val (associated_types, methods) = self.parse_indented_impl_body()

    Ok(Node.Impl(ImplBlock(
        span: self.make_span(start_span),
        attributes: attributes,
        generic_params: generic_params,
        target_type: target_type,
        trait_name: trait_name,
        trait_type_params: trait_type_params,
        where_clause: where_clause,
        associated_types: associated_types,
        methods: methods,
    )))

# ============================================================================
# Impl Body
# ============================================================================

# Parse impl body: associated type impls and methods (supports empty impl)
fn parse_indented_impl_body(self) -> ([AssociatedTypeImpl], [FunctionDef]):
    self.expect(TokenKind.Colon)

    if not self.check(TokenKind.Newline):
        self.error("expected newline after impl block colon")
    self.advance()

    # Empty impl: no indent after newline
    if not self.check(TokenKind.Indent):
        return ([], [])
    self.advance()

    var associated_types = []
    var methods = []

    while not self.check(TokenKind.Dedent) and not self.is_at_end():
        self.skip_newlines()
        if self.check(TokenKind.Dedent):
            break

        # Skip standalone docstrings
        if self.check_string() or self.check_fstring():
            self.advance()
            self.skip_newlines()
            continue

        # Associated type impl: type Item = i64
        if self.check(TokenKind.Type):
            associated_types.append(self.parse_associated_type_impl())
        else:
            # Parse optional decorators
            var decorators = []
            while self.check(TokenKind.At):
                decorators.append(self.parse_decorator())
                self.skip_newlines()

            val visibility = if self.check(TokenKind.Pub):
                self.advance()
                Visibility.Public
            else:
                Visibility.Private

            var is_static = if self.check(TokenKind.Static):
                self.advance()
                true
            else:
                false

            # Deprecated var fn syntax
            val is_var_fn = if self.check(TokenKind.Var) and self.peek_is(TokenKind.Fn):
                self.emit_deprecation_warning(
                    "Deprecated: `var fn` syntax",
                    "Replace `var fn method()` with `me method()`",
                    None,
                )
                self.advance()
                true
            else:
                false

            val item = if self.check(TokenKind.Async):
                self.parse_async_function()
            else:
                self.parse_function()

            match item:
                Node.Function(f):
                    f.visibility = visibility
                    if is_var_fn:
                        f.is_me_method = true
                    f.decorators = f.decorators.merge(decorators)

                    # Implicit static for constructor names
                    if not is_static and not f.is_me_method and is_constructor_name(f.name):
                        is_static = true

                    f.is_static = is_static

                    # Auto-inject self for instance methods
                    if not is_static and (f.params.is_empty() or f.params[0].name != "self"):
                        val self_param = Parameter(
                            span: f.span,
                            name: "self",
                            ty: None,
                            default: None,
                            mutability: Mutability.Immutable,
                            inject: false,
                            variadic: false,
                            call_site_label: None,
                        )
                        f.params.insert(0, self_param)
                    methods.append(f)
                _: ()

    self.consume_dedent()
    (associated_types, methods)

# ============================================================================
# Associated Type Implementation
# ============================================================================

# Parse associated type impl: type Item = i64
fn parse_associated_type_impl(self) -> AssociatedTypeImpl:
    val start_span = self.current.span
    self.expect(TokenKind.Type)
    val name = self.expect_identifier()
    self.expect(TokenKind.Assign)
    val ty = self.parse_type()

    if self.check(TokenKind.Newline):
        self.advance()

    AssociatedTypeImpl(
        span: self.make_span(start_span),
        name: name,
        ty: ty,
    )

# ============================================================================
# Interface Binding (Static Polymorphism)
# ============================================================================

# Parse: bind Interface = ImplType
fn parse_interface_binding(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Bind)
    val interface_name = self.expect_identifier()
    self.expect(TokenKind.Assign)
    val impl_type = self.parse_type()

    Ok(Node.InterfaceBinding(InterfaceBinding(
        span: self.make_span(start_span),
        interface_name: interface_name,
        impl_type: impl_type,
        doc_comment: None,
    )))
