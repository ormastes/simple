# Test Database Compatibility Layer
#
# Wraps unified lib.database.test_extended with custom test_db_core API
# for backward compatibility during migration.
#
# This allows test runner to use unified library without changing all call sites.
# Once migration is complete, call sites can be updated to use unified API directly.

use lib.database.test_extended.{
    TestDatabaseExtended,
    load_test_database_extended,
    load_with_migration,
    RunRecord,
    TestInfo
}
use test_db_types.{TestStatus, status_to_str}

# ============================================================================
# Compatibility Wrapper
# ============================================================================

class TestDatabase:
    db: TestDatabaseExtended
    current_run_id: text

    # Load from default path with auto-migration
    static fn load() -> Result<TestDatabase, text>:
        val db_opt = load_with_migration("doc/test/test_db")
        if not db_opt.?:
            return Err("Failed to load test database")

        Ok(TestDatabase(
            db: db_opt?,
            current_run_id: ""
        ))

    # Save database
    fn save() -> Result<(), text>:
        val success = self.db.save()
        if success:
            Ok(())
        else:
            Err("Failed to save database")

    # Update test result (custom API)
    me update_test_result(
        test_name: text,
        test_file: text,
        suite_name: text,
        category: text,            # Ignored in unified implementation (derived from path)
        status: TestStatus,
        duration_ms: f64
    ):
        # Convert TestStatus enum to string
        val status_str = status_to_str(status)

        # Call unified API
        # Note: unified API uses file_path as base for hierarchy
        # custom API has separate test_name and test_file
        # For compatibility, use test_name as the actual test name
        self.db.update_test_result(
            test_file,
            suite_name,
            test_name,
            status_str,
            duration_ms,
            self.current_run_id
        )

    # Start run tracking
    me start_run() -> text:
        val run_id = self.db.start_run()
        self.current_run_id = run_id
        run_id

    # Complete run
    me complete_run(run_id: text, test_count: i64, passed: i64, failed: i64, timed_out: i64):
        self.db.complete_run(run_id, test_count, passed, failed, timed_out)

    # Cleanup stale runs
    me cleanup_stale_runs(max_age_hours: i64):
        val _deleted = self.db.cleanup_stale_runs(max_age_hours)
        # Custom API returns void, unified returns count - discard result
        ()

    # Prune old runs
    me prune_runs(keep_count: i64):
        val _deleted = self.db.prune_runs(keep_count)
        # Custom API returns void, unified returns count - discard result
        ()

    # List test runs
    fn list_runs(status_filter: text) -> [RunRecord]:
        self.db.list_runs(status_filter)

    # ========================================================================
    # Documentation Query Methods
    # ========================================================================

    # Get all test information
    fn all_test_info() -> [TestInfo]:
        self.db.all_test_info()

    # Get tests by status
    fn tests_by_status(status: text) -> [TestInfo]:
        self.db.tests_by_status(status)

    # Get test counts (total, passed, failed, skipped)
    fn test_count_by_status() -> (i64, i64, i64, i64):
        self.db.test_count_by_status()

    # Get flaky test names
    fn flaky_test_names() -> [text]:
        self.db.flaky_test_names()

# ============================================================================
# Helper Functions
# ============================================================================

fn micros_to_rfc3339(micros: i64) -> text:
    # Convert microseconds to RFC3339 timestamp
    # For now, simple conversion (can be improved with proper time formatting)
    val secs = micros / 1000000
    "{secs}"

# ============================================================================
# Exports
# ============================================================================

export TestDatabase
export RunRecord, TestInfo
export micros_to_rfc3339
