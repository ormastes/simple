# Class Instantiation
#
# Constructor dispatch, field initialization, mixin injection.
# Port of rust/compiler/src/interpreter_call/core/class_instantiation.rs

from ..core import {Interpreter, Value, InterpreterError}
from ..expr import {evaluate}

export instantiate_class

# Instantiate a class with positional and/or named arguments
fn instantiate_class(interp: Interpreter, class_name: text, class_def: ClassDef,
                     args: [Value], named_args: Dict<text, Value>) -> Result<Value, InterpreterError>:
    var fields = {}

    # Bind fields from class definition
    val field_defs = class_def.fields
    var positional_idx = 0

    for field_def in field_defs:
        # Check named args first
        if named_args.has(field_def.name):
            fields[field_def.name] = named_args[field_def.name]
            continue

        # Then positional args
        if positional_idx < args.len():
            fields[field_def.name] = args[positional_idx]
            positional_idx = positional_idx + 1
            continue

        # Then default value
        if field_def.default_value.?:
            val default = evaluate(interp, field_def.default_value.unwrap())?
            fields[field_def.name] = default
            continue

        # Missing required field
        return Err(InterpreterError.TypeError(
            "missing required field '{field_def.name}' for {class_name}"))

    # Create the object
    val obj = Value.object(class_name, fields)

    # Check for __init__ method and call it if present
    val init_method = interp.find_method(class_name, "__init__")
    if init_method.?:
        # Call __init__ with the remaining arguments
        val remaining_args = args[positional_idx..]
        interp.env.push_scope()
        interp.env.define("self", obj)
        for (name, value) in fields:
            interp.env.define(name, value)

        # Bind init params
        val init_params = init_method.unwrap().params
        var init_idx = 0
        for param in init_params:
            if param.name == "self": continue
            if init_idx < remaining_args.len():
                interp.env.define(param.name, remaining_args[init_idx])
                init_idx = init_idx + 1
            elif named_args.has(param.name):
                interp.env.define(param.name, named_args[param.name])

        val init_result = interp.eval_block(init_method.unwrap().body)
        interp.env.pop_scope()

        # Return the (potentially modified) self
        match init_result:
            case Ok(_):
                # __init__ may have modified self via mutations
                Ok(obj)
            case Err(e):
                Err(e)
    else:
        Ok(obj)
