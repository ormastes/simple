# Call Rewriter - Source-Level Static Call Transformation
#
# Rewrites Type.method(args) calls to TypeName__method(args) in source text.
# Works at the text level (not AST) for compatibility with the current runtime.
#
# Patterns handled:
#   Type.method()                -> Type__method()
#   Type.method(a, b)            -> Type__method(a, b)
#   Type.method(Other.factory()) -> Type__method(Other__factory())
#   val x = Type.method()        -> val x = Type__method()
#
# NOT rewritten (preserved):
#   obj.method()                 -> obj.method()      (instance method, lowercase receiver)
#   self.field                   -> self.field         (self access)
#   module.function()            -> module.function()  (module access, handled by runtime)
#   "string".method()            -> "string".method()  (literal method)
#   result.ok.?                  -> result.ok.?        (existence check)
#
# NOTE: This module runs on the Rust runtime, so it MUST NOT use static fn.

export rewrite_static_calls

# Known type names collected during desugaring pass
# This will be populated by scanning for class/struct/enum definitions
# and for static methods that were hoisted in pass 1.

# Main entry: rewrite static method calls in source text
fn rewrite_static_calls(source: text) -> text:
    # First, collect all type names from the source
    val type_names = collect_type_names(source)

    # Also collect hoisted function names (TypeName__method patterns)
    val hoisted_names = collect_hoisted_names(source)

    # Extract type names from hoisted names
    for name in hoisted_names:
        val parts = name.split("__")
        if parts.len() >= 2:
            val tn = parts[0]
            if not type_names.contains(tn):
                type_names.push(tn)

    # Now rewrite lines
    val lines = source.split("\n")
    var result_lines = []
    for line in lines:
        val rewritten = rewrite_line(line, type_names)
        result_lines.push(rewritten)

    result_lines.join("\n")

# ================================================================
# Type Name Collection
# ================================================================

fn collect_type_names(source: text) -> [text]:
    var names = []
    val lines = source.split("\n")

    for line in lines:
        val trimmed = line.trim()

        # class Name:
        if trimmed.starts_with("class "):
            val name = extract_def_name(trimmed, 6)
            if name != "" and is_type_name(name):
                if not names.contains(name):
                    names.push(name)

        # struct Name:
        elif trimmed.starts_with("struct "):
            val name = extract_def_name(trimmed, 7)
            if name != "" and is_type_name(name):
                if not names.contains(name):
                    names.push(name)

        # enum Name:
        elif trimmed.starts_with("enum "):
            val name = extract_def_name(trimmed, 5)
            if name != "" and is_type_name(name):
                if not names.contains(name):
                    names.push(name)

        # impl Name:
        elif trimmed.starts_with("impl "):
            val name = extract_impl_type_name(trimmed)
            if name != "" and is_type_name(name):
                if not names.contains(name):
                    names.push(name)

    # Add common built-in type names
    val builtins = ["Option", "Result", "Some", "None", "Ok", "Err",
                    "String", "Array", "Dict", "Set", "Tuple",
                    "Path", "File", "Dir",
                    "PrettyConfig", "PrettyPrinter",
                    "ModuleState", "Interpreter",
                    "TensorSuffix", "DbConfig"]
    for b in builtins:
        if not names.contains(b):
            names.push(b)

    names

fn collect_hoisted_names(source: text) -> [text]:
    var names = []
    val lines = source.split("\n")

    for line in lines:
        val trimmed = line.trim()
        # Look for "fn TypeName__method_name(" pattern
        if trimmed.starts_with("fn "):
            val rest = trimmed[3:]
            val fn_name = extract_word(rest)
            if fn_name.contains("__"):
                if not names.contains(fn_name):
                    names.push(fn_name)

    names

fn extract_def_name(trimmed: text, offset: i64) -> text:
    val rest = trimmed[offset:]
    extract_word(rest)

fn extract_impl_type_name(trimmed: text) -> text:
    # "impl Name:" or "impl Trait for Name:" or "impl Name<T>:"
    var s = trimmed[5:]  # skip "impl "

    # Check for "Trait for Type" pattern
    val for_idx = find_substring(s, " for ")
    if for_idx >= 0:
        s = s[for_idx + 5:]

    val name = extract_word(s)
    strip_generics_simple(name)

fn extract_word(s: text) -> text:
    var word = ""
    var ci = 0
    val slen = s.len()
    while ci < slen:
        val ch = s[ci:ci + 1]
        if is_ident_char(ch):
            word = word + ch
            ci = ci + 1
        else:
            break
    word

fn strip_generics_simple(name: text) -> text:
    var ci = 0
    val nlen = name.len()
    while ci < nlen:
        val ch = name[ci:ci + 1]
        if ch == "<":
            return name[0:ci]
        ci = ci + 1
    name

fn is_ident_char(ch: text) -> bool:
    if ch.len() != 1:
        return false
    val c = ch
    (c >= "a" and c <= "z") or (c >= "A" and c <= "Z") or (c >= "0" and c <= "9") or c == "_"

# Check if a name looks like a type name (starts with uppercase)
fn is_type_name(name: text) -> bool:
    if name.len() == 0:
        return false
    val first = name[0:1]
    first >= "A" and first <= "Z"

fn find_substring(s: text, sub: text) -> i64:
    val slen = s.len()
    val sublen = sub.len()
    if sublen > slen:
        return -1
    var ci = 0
    while ci <= slen - sublen:
        val chunk = s[ci:ci + sublen]
        if chunk == sub:
            return ci
        ci = ci + 1
    -1

# ================================================================
# Line Rewriting
# ================================================================

# Rewrite a single line: replace Type.method( with Type__method(
fn rewrite_line(line: text, type_names: [text]) -> text:
    val trimmed = line.trim()

    # Skip comments
    if trimmed.starts_with("#"):
        return line

    # Skip string-only lines (simple heuristic)
    if trimmed.starts_with("\"\"\""):
        return line

    # Skip import/use/export lines
    if trimmed.starts_with("use ") or trimmed.starts_with("from ") or trimmed.starts_with("export ") or trimmed.starts_with("import "):
        return line

    # Skip impl/class/struct/enum definitions (the headers themselves)
    if trimmed.starts_with("impl ") or trimmed.starts_with("class ") or trimmed.starts_with("struct ") or trimmed.starts_with("enum "):
        return line

    # Skip static fn definitions (they were already hoisted)
    if trimmed.starts_with("static fn ") or trimmed.starts_with("static me "):
        return line

    # Rewrite Type.method patterns for each known type
    var result = line
    for type_name in type_names:
        result = rewrite_type_calls(result, type_name)

    result

# Rewrite all occurrences of TypeName.method( to TypeName__method( in a line
fn rewrite_type_calls(line: text, type_name: text) -> text:
    val pattern = "{type_name}."
    val plen = pattern.len()
    val llen = line.len()

    if llen < plen:
        return line

    var result = ""
    var ci = 0

    while ci < llen:
        # Check if we're inside a string literal (simple check)
        if is_in_string_context(line, ci):
            result = result + line[ci:ci + 1]
            ci = ci + 1
            continue

        # Check for pattern match
        val remaining = llen - ci
        if remaining >= plen:
            val chunk = line[ci:ci + plen]
            if chunk == pattern:
                # Verify this is a static call context:
                # - Previous char must not be an ident char (avoid matching obj_TypeName.method)
                # - Next char must be an ident char (method name follows)
                val prev_ok = if ci == 0: true
                              else: not is_ident_char(line[ci - 1:ci])
                val after_dot_idx = ci + plen
                val next_ok = if after_dot_idx < llen: is_ident_char(line[after_dot_idx:after_dot_idx + 1])
                              else: false

                if prev_ok and next_ok:
                    # Extract the method name after the dot
                    val method_name = extract_word(line[after_dot_idx:])

                    # Skip if this looks like a field access (no parens after method)
                    val after_method_idx = after_dot_idx + method_name.len()
                    val has_paren = after_method_idx < llen and line[after_method_idx:after_method_idx + 1] == "("

                    if has_paren and method_name != "":
                        # This is a static method call: TypeName.method(
                        # Rewrite to TypeName__method(
                        result = result + "{type_name}__{method_name}"
                        ci = after_method_idx
                        continue

        result = result + line[ci:ci + 1]
        ci = ci + 1

    result

# Simple check if position is inside a string literal
# This is a heuristic - counts unescaped quotes before position
fn is_in_string_context(line: text, pos: i64) -> bool:
    var quote_count = 0
    var ci = 0
    while ci < pos:
        val ch = line[ci:ci + 1]
        if ch == "\"" and (ci == 0 or line[ci - 1:ci] != "\\"):
            quote_count = quote_count + 1
        ci = ci + 1
    # Odd number of quotes means we're inside a string
    quote_count % 2 == 1
