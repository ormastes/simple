# Test Runner Client Output
#
# Send protocol messages via serial/semihosting for embedded targets.
#
# Protocol Constants Reference:
#   PROTO_MAGIC=0xAB, PROTO_VERSION=0x01
#   MSG_READY=0x01, MSG_TEST_START=0x20, MSG_TEST_PASS=0x21
#   MSG_TEST_FAIL=0x22, MSG_TEST_SKIP=0x23, MSG_COMPLETE=0xFF

# =========================================================================
# Byte Encoding (duplicated for standalone embedded use)
# =========================================================================

fn encode_u32(value: i32) -> [i32]:
    [value & 0xFF, (value >> 8) & 0xFF, (value >> 16) & 0xFF, (value >> 24) & 0xFF]

fn encode_u16(value: i32) -> [i32]:
    [value & 0xFF, (value >> 8) & 0xFF]

# =========================================================================
# Output Backend (abstract - platform implements)
# =========================================================================

# Output backend type
# 0 = Serial (x86 COM1)
# 1 = ARM Semihosting
# 2 = RISC-V Semihosting
# 3 = Memory Buffer (for testing)

class OutputBackend:
    backend_type: i32
    buffer: [i32]           # For memory buffer backend

fn OutputBackend_serial() -> OutputBackend:
    OutputBackend(backend_type: 0, buffer: [])

fn OutputBackend_memory() -> OutputBackend:
    OutputBackend(backend_type: 3, buffer: [])

impl OutputBackend:
    me write_byte(b: i32):
        if self.backend_type == 0:
            # Serial output - would use platform-specific code
            # For now, collect in buffer for testing
            self.buffer.push(b)
        elif self.backend_type == 3:
            # Memory buffer
            self.buffer.push(b)
        # Other backends would have platform-specific implementations

    me write_bytes(bytes: [i32]):
        for b in bytes:
            self.write_byte(b)

    fn get_buffer() -> [i32]:
        self.buffer

    me clear_buffer():
        self.buffer = []

# =========================================================================
# Protocol Message Sender
# =========================================================================

class MessageSender:
    backend: OutputBackend

fn MessageSender_create(backend: OutputBackend) -> MessageSender:
    MessageSender(backend: backend)

fn MessageSender_serial() -> MessageSender:
    MessageSender(backend: OutputBackend_serial())

fn MessageSender_memory() -> MessageSender:
    MessageSender(backend: OutputBackend_memory())

impl MessageSender:
    me send_message(msg_type: i32, payload: [i32]):
        # Send header
        self.backend.write_byte(0xAB)  # PROTO_MAGIC
        self.backend.write_byte(0x01)  # PROTO_VERSION
        self.backend.write_byte(msg_type)

        # Payload length (u16 little-endian)
        val len_bytes = encode_u16(payload.len() as i32)
        self.backend.write_bytes(len_bytes)

        # Send payload
        self.backend.write_bytes(payload)

    me send_ready(test_count: i32):
        var payload: [i32] = []
        # Version (u32)
        for b in encode_u32(1):
            payload.push(b)
        # Test count (u32)
        for b in encode_u32(test_count):
            payload.push(b)
        self.send_message(0x01, payload)  # MSG_READY

    me send_suite_start(suite_id: i32):
        self.send_message(0x10, encode_u32(suite_id))  # MSG_SUITE_START

    me send_suite_end(suite_id: i32):
        self.send_message(0x11, encode_u32(suite_id))  # MSG_SUITE_END

    me send_test_start(test_id: i32):
        self.send_message(0x20, encode_u32(test_id))  # MSG_TEST_START

    me send_test_pass(test_id: i32, duration_ms: i32):
        var payload: [i32] = []
        for b in encode_u32(test_id):
            payload.push(b)
        for b in encode_u32(duration_ms):
            payload.push(b)
        self.send_message(0x21, payload)  # MSG_TEST_PASS

    me send_test_fail(test_id: i32, duration_ms: i32, msg_handle: i32, file_handle: i32, line: i32):
        var payload: [i32] = []
        for b in encode_u32(test_id):
            payload.push(b)
        for b in encode_u32(duration_ms):
            payload.push(b)
        for b in encode_u32(msg_handle):
            payload.push(b)
        for b in encode_u32(file_handle):
            payload.push(b)
        for b in encode_u32(line):
            payload.push(b)
        self.send_message(0x22, payload)  # MSG_TEST_FAIL

    me send_test_skip(test_id: i32):
        self.send_message(0x23, encode_u32(test_id))  # MSG_TEST_SKIP

    me send_test_timeout(test_id: i32, duration_ms: i32):
        var payload: [i32] = []
        for b in encode_u32(test_id):
            payload.push(b)
        for b in encode_u32(duration_ms):
            payload.push(b)
        self.send_message(0x24, payload)  # MSG_TEST_TIMEOUT

    me send_log(msg_handle: i32):
        self.send_message(0x30, encode_u32(msg_handle))  # MSG_LOG

    me send_assert_fail(test_id: i32, msg_handle: i32, file_handle: i32, line: i32):
        var payload: [i32] = []
        for b in encode_u32(test_id):
            payload.push(b)
        for b in encode_u32(msg_handle):
            payload.push(b)
        for b in encode_u32(file_handle):
            payload.push(b)
        for b in encode_u32(line):
            payload.push(b)
        self.send_message(0x40, payload)  # MSG_ASSERT_FAIL

    me send_complete(total: i32, passed: i32, failed: i32, skipped: i32):
        var payload: [i32] = []
        for b in encode_u32(total):
            payload.push(b)
        for b in encode_u32(passed):
            payload.push(b)
        for b in encode_u32(failed):
            payload.push(b)
        for b in encode_u32(skipped):
            payload.push(b)
        self.send_message(0xFF, payload)  # MSG_COMPLETE

    # For testing: get raw bytes sent
    fn get_sent_bytes() -> [i32]:
        self.backend.get_buffer()

    me clear_sent_bytes():
        self.backend.clear_buffer()
