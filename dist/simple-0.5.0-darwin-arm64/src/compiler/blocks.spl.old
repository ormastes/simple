# Block Resolution System
#
# Resolves custom blocks (math, shell, sql, etc.) in source code.

use lexer.Span

# Block value types

# Value of a resolved block.
enum BlockValue:
    Math(expr: text)
    Shell(cmd: text)
    Sql(query: text)
    Regex(pattern: text)
    Html(content: text)
    Json(data: text)
    Custom(name: text, content: text)
    Error(message: text)

    fn to_text() -> text:
        match self:
            case BlockValue.Math(e):
                "m[{e}]"
            case BlockValue.Shell(c):
                "$[{c}]"
            case BlockValue.Sql(q):
                "sql[{q}]"
            case BlockValue.Regex(p):
                "r[{p}]"
            case BlockValue.Html(h):
                "html[{h}]"
            case BlockValue.Json(d):
                "json[{d}]"
            case BlockValue.Custom(n, c):
                "{n}[{c}]"
            case BlockValue.Error(m):
                "<error: {m}>"

struct ResolvedBlock:
    """A resolved block with its value and location."""
    value: BlockValue
    span: Span
    source: text

struct ResolvedModule:
    """Module with all blocks resolved."""
    blocks: [ResolvedBlock]
    diagnostics: [BlockDiagnostic]

struct BlockDiagnostic:
    """Diagnostic from block resolution."""
    message: text
    span: Span
    is_error: bool

    fn is_error() -> bool:
        self.is_error

class BlockResolver:
    """Resolves blocks in source code."""
    file: text
    module: text

    static fn new() -> BlockResolver:
        BlockResolver(file: "", module: "")

    fn with_file(path: text) -> BlockResolver:
        BlockResolver(file: path, module: self.module)

    fn with_module(name: text) -> BlockResolver:
        BlockResolver(file: self.file, module: name)

    fn resolve(outline: Any) -> (ResolvedModule, [BlockDiagnostic]):
        # Placeholder - return empty resolved module
        val resolved = ResolvedModule(blocks: [], diagnostics: [])
        (resolved, [])

class BlockRegistry:
    """Registry of block handlers."""
    handlers: Dict<text, fn(text) -> BlockValue>

    static fn default() -> BlockRegistry:
        val reg = BlockRegistry(handlers: {})
        reg.handlers["m"] = \content: BlockValue.Math(content)
        reg.handlers["$"] = \content: BlockValue.Shell(content)
        reg.handlers["sql"] = \content: BlockValue.Sql(content)
        reg.handlers["r"] = \content: BlockValue.Regex(content)
        reg.handlers["html"] = \content: BlockValue.Html(content)
        reg.handlers["json"] = \content: BlockValue.Json(content)
        reg

fn block_registry() -> BlockRegistry:
    """Get the global block registry."""
    BlockRegistry.default()

fn resolve_blocks(source: text, file: text) -> ResolvedModule:
    """Resolve all blocks in source code."""
    val resolver = BlockResolver.new().with_file(file)
    val (resolved, _) = resolver.resolve(source)
    resolved

# Export BlockValue for blocks.value.BlockValue import pattern
# (module system handles this automatically)
