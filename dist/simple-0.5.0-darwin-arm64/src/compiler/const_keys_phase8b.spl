"""
Const Keys - Phase 8B: ConstKeySet Type

Implements type system support for const key sets.

Status: Phase 8B In Progress
"""

type Symbol = text

# ============================================================================
# HirType Extensions for Const Keys
# ============================================================================

enum HirType:
    """
    Extended type system with const key support

    New variants:
    - ConstKeySet: Compile-time known keys from string template
    - DependentKeys: Runtime-determined keys from variable
    """
    # Core types
    Int
    Float
    Bool
    Str
    Unit

    # Collection types
    Array(elem_ty: HirType)
    Dict(key_ty: HirType, val_ty: HirType)

    # Const key types (NEW)
    ConstKeySet(keys: [Symbol])      # Compile-time known keys
    DependentKeys(source: Symbol)    # Runtime-determined keys

    # Generic types
    TypeVar(name: Symbol)
    Generic(base: Symbol, args: [HirType])

impl HirType:
    # ========================================================================
    # Const Key Type Predicates
    # ========================================================================

    fn is_const_key_set() -> bool:
        """Check if type is ConstKeySet"""
        match self:
            case ConstKeySet(_): true
            case _: false

    fn is_dependent_keys() -> bool:
        """Check if type is DependentKeys"""
        match self:
            case DependentKeys(_): true
            case _: false

    fn has_const_keys() -> bool:
        """Check if type has compile-time known keys"""
        self.is_const_key_set()

    # ========================================================================
    # Key Extraction
    # ========================================================================

    fn get_keys() -> [Symbol]:
        """
        Get keys if ConstKeySet, empty otherwise

        Returns:
            List of keys for ConstKeySet
            Empty list for other types
        """
        match self:
            case ConstKeySet(keys): keys
            case _: []

    fn get_key_count() -> i64:
        """Count number of keys"""
        val keys = self.get_keys()
        keys.len()

    fn has_key(key: Symbol) -> bool:
        """Check if specific key exists"""
        val keys = self.get_keys()
        key in keys

    # ========================================================================
    # Type Equality with Const Keys
    # ========================================================================

    fn equals(other: HirType) -> bool:
        """
        Check type equality including const keys

        ConstKeySet equality:
            - Keys must match exactly (order matters)
            - Use structural equality for key lists
        """
        match (self, other):
            case (Int, Int): true
            case (Float, Float): true
            case (Bool, Bool): true
            case (Str, Str): true
            case (Unit, Unit): true

            case (Array(e1), Array(e2)):
                e1.equals(e2)

            case (Dict(k1, v1), Dict(k2, v2)):
                k1.equals(k2) and v1.equals(v2)

            case (ConstKeySet(keys1), ConstKeySet(keys2)):
                self.keys_equal(keys1, keys2)

            case (DependentKeys(s1), DependentKeys(s2)):
                s1 == s2

            case (TypeVar(n1), TypeVar(n2)):
                n1 == n2

            case (Generic(b1, args1), Generic(b2, args2)):
                b1 == b2 and self.args_equal(args1, args2)

            case _: false

    fn keys_equal(keys1: [Symbol], keys2: [Symbol]) -> bool:
        """Check if two key lists are equal"""
        if keys1.len() != keys2.len():
            return false

        var i = 0
        while i < keys1.len():
            if keys1[i] != keys2[i]:
                return false
            i = i + 1

        true

    fn args_equal(args1: [HirType], args2: [HirType]) -> bool:
        """Check if two type argument lists are equal"""
        if args1.len() != args2.len():
            return false

        var i = 0
        while i < args1.len():
            if not args1[i].equals(args2[i]):
                return false
            i = i + 1

        true

    # ========================================================================
    # String Representation
    # ========================================================================

    fn to_string() -> text:
        """String representation including const keys"""
        match self:
            case Int: "i64"
            case Float: "f64"
            case Bool: "bool"
            case Str: "text"
            case Unit: "()"

            case Array(elem_ty):
                "[{elem_ty.to_string()}]"

            case Dict(key_ty, val_ty):
                "Dict<{key_ty.to_string()}, {val_ty.to_string()}>"

            case ConstKeySet(keys):
                val keys_str = self.format_keys(keys)
                "ConstKeySet<[{keys_str}]>"

            case DependentKeys(source):
                "DependentKeys<{source}>"

            case TypeVar(name):
                name

            case Generic(base, args):
                val args_str = self.format_type_args(args)
                "{base}<{args_str}>"

    fn format_keys(keys: [Symbol]) -> text:
        """Format key list for display"""
        if keys.len() == 0:
            return ""

        var result = "\"{keys[0]}\""
        var i = 1
        while i < keys.len():
            result = result + ", \"{keys[i]}\""
            i = i + 1

        result

    fn format_type_args(args: [HirType]) -> text:
        """Format type argument list"""
        if args.len() == 0:
            return ""

        var result = args[0].to_string()
        var i = 1
        while i < args.len():
            result = result + ", " + args[i].to_string()
            i = i + 1

        result

# ============================================================================
# Template Type Inference
# ============================================================================

class TemplateTypeInference:
    """
    Infer ConstKeySet type for string templates

    Algorithm:
    1. Check if string literal contains {key} patterns
    2. Extract keys using KeyExtractor
    3. Return ConstKeySet if keys found, Str otherwise
    """

impl TemplateTypeInference:
    static fn infer_template(value: text) -> HirType:
        """
        Infer type of string literal

        Returns:
            ConstKeySet if template (has keys)
            Str if plain string (no keys)
        """
        val keys = KeyExtractor.extract_keys(value)

        if keys.len() > 0:
            HirType.ConstKeySet(keys: keys)
        else:
            HirType.Str

    static fn is_template(value: text) -> bool:
        """Check if string is a template"""
        val keys = KeyExtractor.extract_keys(value)
        keys.len() > 0

    static fn extract_keys_from_str(value: text) -> [Symbol]:
        """Extract keys from string literal"""
        KeyExtractor.extract_keys(value)

# Import KeyExtractor from Phase 8A
class KeyExtractor:
    """Key extraction from Phase 8A"""

    static fn extract_keys(tmpl: text) -> [Symbol]:
        var keys = []
        var in_brace = false
        var current_key = ""
        var i = 0

        while i < tmpl.len():
            val char = tmpl[i..i+1]

            if char == "{":
                in_brace = true
                current_key = ""
            elif char == "}":
                if in_brace and current_key.len() > 0:
                    keys.push(current_key)
                in_brace = false
                current_key = ""
            elif in_brace:
                current_key = current_key + char

            i = i + 1

        keys

# ============================================================================
# Tests
# ============================================================================

fn test_const_key_set_type():
    """Test ConstKeySet type creation"""
    val ty = HirType.ConstKeySet(keys: ["name", "age"])

    assert ty.is_const_key_set(), "Is ConstKeySet"
    assert not ty.is_dependent_keys(), "Not DependentKeys"
    assert ty.has_const_keys(), "Has const keys"

    print "âœ… ConstKeySet type creation"

fn test_get_keys():
    """Test key extraction from type"""
    val ty = HirType.ConstKeySet(keys: ["x", "y", "z"])
    val keys = ty.get_keys()

    assert keys.len() == 3, "Three keys"
    assert keys[0] == "x", "First key is x"
    assert keys[1] == "y", "Second key is y"
    assert keys[2] == "z", "Third key is z"

    print "âœ… Get keys from type"

fn test_get_keys_empty():
    """Test get_keys on non-ConstKeySet types"""
    val str_ty = HirType.Str
    val keys = str_ty.get_keys()

    assert keys.len() == 0, "No keys for Str type"

    print "âœ… Get keys empty for non-ConstKeySet"

fn test_has_key():
    """Test key membership check"""
    val ty = HirType.ConstKeySet(keys: ["name", "email"])

    assert ty.has_key("name"), "Has name"
    assert ty.has_key("email"), "Has email"
    assert not ty.has_key("age"), "Doesn't have age"

    print "âœ… Has key check"

fn test_key_count():
    """Test key counting"""
    val ty1 = HirType.ConstKeySet(keys: [])
    val ty2 = HirType.ConstKeySet(keys: ["a"])
    val ty3 = HirType.ConstKeySet(keys: ["a", "b", "c"])

    assert ty1.get_key_count() == 0, "Zero keys"
    assert ty2.get_key_count() == 1, "One key"
    assert ty3.get_key_count() == 3, "Three keys"

    print "âœ… Key count"

fn test_type_equality_const_key_set():
    """Test ConstKeySet type equality"""
    val ty1 = HirType.ConstKeySet(keys: ["name", "age"])
    val ty2 = HirType.ConstKeySet(keys: ["name", "age"])
    val ty3 = HirType.ConstKeySet(keys: ["age", "name"])  # Different order
    val ty4 = HirType.ConstKeySet(keys: ["name"])  # Different keys

    assert ty1.equals(ty2), "Same keys, same order: equal"
    assert not ty1.equals(ty3), "Same keys, different order: not equal"
    assert not ty1.equals(ty4), "Different keys: not equal"

    print "âœ… ConstKeySet type equality"

fn test_type_equality_other():
    """Test type equality for other types"""
    val int_ty = HirType.Int
    val str_ty = HirType.Str
    val arr_ty = HirType.Array(elem_ty: HirType.Int)

    assert int_ty.equals(HirType.Int), "Int equals Int"
    assert not int_ty.equals(str_ty), "Int not equals Str"
    assert arr_ty.equals(HirType.Array(elem_ty: HirType.Int)), "Array equals"

    print "âœ… Type equality for other types"

fn test_infer_template_with_keys():
    """Test inference for template with keys"""
    val tmpl = "Hello {name}, you are {age} years old"
    val ty = TemplateTypeInference.infer_template(tmpl)

    assert ty.is_const_key_set(), "Is ConstKeySet"
    val keys = ty.get_keys()
    assert keys.len() == 2, "Two keys"
    assert keys[0] == "name", "First key is name"
    assert keys[1] == "age", "Second key is age"

    print "âœ… Infer template with keys"

fn test_infer_plain_string():
    """Test inference for plain string (no keys)"""
    val plain = "Hello world"
    val ty = TemplateTypeInference.infer_template(plain)

    assert not ty.is_const_key_set(), "Not ConstKeySet"
    assert ty.equals(HirType.Str), "Is Str type"

    print "âœ… Infer plain string"

fn test_is_template():
    """Test template detection"""
    val tmpl = "User {id} has {points} points"
    val plain = "No keys here"

    assert TemplateTypeInference.is_template(tmpl), "Is template"
    assert not TemplateTypeInference.is_template(plain), "Not template"

    print "âœ… Template detection"

fn test_const_key_set_to_string():
    """Test string representation"""
    val ty1 = HirType.ConstKeySet(keys: ["name", "age"])
    val ty2 = HirType.ConstKeySet(keys: [])

    val str1 = ty1.to_string()
    val str2 = ty2.to_string()

    assert str1 == "ConstKeySet<[\"name\", \"age\"]>", "String with keys"
    assert str2 == "ConstKeySet<[]>", "String with no keys"

    print "âœ… ConstKeySet to_string"

fn test_dependent_keys_type():
    """Test DependentKeys type"""
    val ty = HirType.DependentKeys(source: "user_input")

    assert ty.is_dependent_keys(), "Is DependentKeys"
    assert not ty.is_const_key_set(), "Not ConstKeySet"
    assert not ty.has_const_keys(), "No const keys"

    val str_repr = ty.to_string()
    assert str_repr == "DependentKeys<user_input>", "String representation"

    print "âœ… DependentKeys type"

fn main():
    print ""
    print "Const Keys Phase 8B Tests"
    print "========================="

    test_const_key_set_type()
    test_get_keys()
    test_get_keys_empty()
    test_has_key()
    test_key_count()
    test_type_equality_const_key_set()
    test_type_equality_other()
    test_infer_template_with_keys()
    test_infer_plain_string()
    test_is_template()
    test_const_key_set_to_string()
    test_dependent_keys_type()

    print ""
    print "ðŸŽ‰ Phase 8B Complete!"
    print ""
    print "Implemented:"
    print "  âœ… HirType.ConstKeySet - compile-time key tracking"
    print "  âœ… HirType.DependentKeys - runtime key tracking"
    print "  âœ… is_const_key_set() - type predicate"
    print "  âœ… get_keys() - key extraction from type"
    print "  âœ… has_key() - key membership check"
    print "  âœ… Type equality - ConstKeySet comparison"
    print "  âœ… TemplateTypeInference - infer type from string"
    print "  âœ… Type string representation"
    print ""
    print "Progress: 4/6 hours (67% of Phase 8)"
    print "Next: Phase 8C - Key Validation (2h)"
