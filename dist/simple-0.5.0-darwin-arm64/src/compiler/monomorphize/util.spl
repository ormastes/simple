# Type Conversion Utilities for Monomorphization
#
# This module provides utilities for converting between AST types and ConcreteTypes:
# - AST → ConcreteType: Substitute type parameters during specialization
# - ConcreteType → AST: Convert back for code generation
# - Type parameter usage checking
# - Expression type inference
#
# Port of: rust/compiler/src/monomorphize/util.rs (362 lines)

export type_uses_param
export infer_concrete_type
export ast_type_to_concrete
export concrete_to_ast_type

use parser.ast (Type, Expr, PointerKind, ReferenceCapability)
use compiler.monomorphize.types (ConcreteType, PointerKind as ConcretePointerKind, TypeBindings)

# ============================================================================
# Type Parameter Usage Check
# ============================================================================

fn type_uses_param(ty: Type, param: text) -> bool:
    """Check if a type directly uses a type parameter.

    Examples:
        type_uses_param(Simple("T"), "T") -> true
        type_uses_param(Simple("Int"), "T") -> false
        type_uses_param(Generic("List", [Simple("T")]), "T") -> true
        type_uses_param(Array(Simple("Int")), "T") -> false

    ROBUSTNESS: Recursively checks all nested types.
    """
    match ty:
        Type.Simple(name):
            name == param

        Type.Generic(name, args):
            # Check both the name and all type arguments
            if name == param:
                return true
            for arg in args:
                if type_uses_param(arg, param):
                    return true
            false

        Type.Array(element, _):
            type_uses_param(element, param)

        Type.Tuple(elems):
            for elem in elems:
                if type_uses_param(elem, param):
                    return true
            false

        Type.Function(params, ret):
            # Check all parameters
            for p in params:
                if type_uses_param(p, param):
                    return true
            # Check return type
            if val Some(r) = ret:
                return type_uses_param(r, param)
            false

        Type.Optional(inner):
            type_uses_param(inner, param)

        Type.Pointer(_, inner):
            type_uses_param(inner, param)

        _:
            # Other type forms don't contain type parameters
            false

# ============================================================================
# Expression Type Inference
# ============================================================================

fn infer_concrete_type(expr: Expr, type_context: {text: ConcreteType}) -> ConcreteType?:
    """Infer the concrete type of an expression.

    Uses literal values and type context to determine the concrete type.

    Examples:
        infer_concrete_type(Integer(42), {}) -> Some(Int)
        infer_concrete_type(String("hello"), {}) -> Some(String)
        infer_concrete_type(Identifier("x"), {"x": Int}) -> Some(Int)

    ROBUSTNESS:
    - Returns None for complex expressions
    - Uses type_context for identifier lookup
    - Infers array element type from first element
    """
    match expr:
        Expr.Integer(_) | Expr.TypedInteger(_, _):
            Some(ConcreteType.Int)

        Expr.Float(_) | Expr.TypedFloat(_, _):
            Some(ConcreteType.Float)

        Expr.Bool(_):
            Some(ConcreteType.Bool)

        Expr.String(_) | Expr.TypedString(_, _) | Expr.FString(_):
            Some(ConcreteType.String)

        Expr.Nil:
            Some(ConcreteType.Nil)

        Expr.Identifier(name):
            type_context.get(name)

        Expr.Array(elems):
            # Infer from first element
            if val Some(first) = elems.first():
                if val Some(elem_ty) = infer_concrete_type(first, type_context):
                    return Some(ConcreteType.Array(elem_ty))
            None

        _:
            # Complex expressions - type inference not implemented
            None

# ============================================================================
# AST Type to Concrete Type Conversion
# ============================================================================

fn ast_type_to_concrete(ty: Type, bindings: TypeBindings) -> ConcreteType:
    """Convert an AST type to a ConcreteType.

    Substitutes type parameters using bindings and converts to a concrete
    representation suitable for monomorphization.

    Examples:
        # Primitive types
        ast_type_to_concrete(Simple("Int"), {}) -> Int

        # Type parameter substitution
        ast_type_to_concrete(Simple("T"), {"T": Int}) -> Int

        # Generic specialization
        ast_type_to_concrete(
            Generic("List", [Simple("T")]),
            {"T": Int}
        ) -> Specialized("List", [Int])

        # Nested types
        ast_type_to_concrete(
            Array(Simple("T")),
            {"T": String}
        ) -> Array(String)

    ROBUSTNESS:
    - All AST type variants handled
    - Recursive substitution for nested types
    - Primitive type normalization (i32/i64 -> Int)
    - Pointer kind to capability mapping
    """
    match ty:
        Type.Simple(name):
            # Check if it's a type parameter binding
            if val Some(concrete) = bindings.get(name):
                return concrete

            # Check for primitive types
            match name:
                "Int" | "i32" | "i64" | "i8" | "i16":
                    ConcreteType.Int
                "Float" | "f32" | "f64":
                    ConcreteType.Float
                "Bool" | "bool":
                    ConcreteType.Bool
                "String" | "str" | "text":
                    ConcreteType.String
                "Nil" | "nil" | "()":
                    ConcreteType.Nil
                _:
                    # Named type (struct, class, enum)
                    ConcreteType.Named(name)

        Type.Generic(name, args):
            # Check if the name itself is a type parameter
            if val Some(concrete) = bindings.get(name):
                return concrete

            # Convert all type arguments recursively
            var concrete_args: [ConcreteType] = []
            for arg in args:
                concrete_args.push(ast_type_to_concrete(arg, bindings))

            ConcreteType.Specialized(name, concrete_args)

        Type.Tuple(elems):
            var concrete_elems: [ConcreteType] = []
            for elem in elems:
                concrete_elems.push(ast_type_to_concrete(elem, bindings))
            ConcreteType.Tuple(concrete_elems)

        Type.Array(element, _):
            # Size is ignored for monomorphization (runtime info)
            val elem_ty = ast_type_to_concrete(element, bindings)
            ConcreteType.Array(elem_ty)

        Type.Function(params, ret):
            var param_types: [ConcreteType] = []
            for param in params:
                param_types.push(ast_type_to_concrete(param, bindings))

            val ret_ty = match ret:
                Some(r): ast_type_to_concrete(r, bindings)
                None: ConcreteType.Nil

            ConcreteType.Function(param_types, ret_ty)

        Type.Optional(inner):
            val inner_ty = ast_type_to_concrete(inner, bindings)
            ConcreteType.Optional(inner_ty)

        Type.Pointer(kind, inner):
            # Convert pointer kind
            val concrete_kind = ast_pointer_kind_to_concrete(kind)

            # Derive capability from pointer kind:
            # - Unique: Isolated (owns the data, no aliasing)
            # - BorrowMut/RawMut: Exclusive (mutable access)
            # - Others: Shared (immutable access)
            val capability = match concrete_kind:
                ConcretePointerKind.Unique:
                    ReferenceCapability.Isolated
                ConcretePointerKind.BorrowMut | ConcretePointerKind.RawMut:
                    ReferenceCapability.Exclusive
                _:
                    ReferenceCapability.Shared

            val inner_ty = ast_type_to_concrete(inner, bindings)
            ConcreteType.Pointer(concrete_kind, capability, inner_ty)

        Type.Union(types):
            # For unions, take the first type
            # TODO: Full union support (would need ConcreteType.Union variant)
            if val Some(first) = types.first():
                ast_type_to_concrete(first, bindings)
            else:
                ConcreteType.Nil

        Type.Constructor(target, _):
            # Constructor types are used for factory patterns
            # Extract the target type
            ast_type_to_concrete(target, bindings)

        Type.Simd(lanes, element):
            # SIMD types are specialized arrays
            # Lanes count is runtime info, we only care about element type
            val elem_ty = ast_type_to_concrete(element, bindings)
            ConcreteType.Array(elem_ty)

        Type.Capability(inner, _):
            # Capability is a compile-time wrapper, unwrap to get inner type
            ast_type_to_concrete(inner, bindings)

        Type.DynTrait(trait_name):
            # dyn Trait - represents a trait object (fat pointer)
            ConcreteType.Named("dyn_{trait_name}")

        Type.UnitWithRepr(name, _):
            # Unit with repr - treat as a named unit type
            ConcreteType.Named(name)

        Type.SelfType:
            # Self return type - treat as Self (enclosing type)
            ConcreteType.Named("Self")

        Type.TypeBinding(_, value):
            # Type binding - extract the bound value type
            ast_type_to_concrete(value, bindings)

        Type.ConstKeySet(keys):
            # Const key set for format string templates
            ConcreteType.Named("const_keys({keys.join(',')})")

        Type.DependentKeys(source):
            # Dependent keys from a source expression
            ConcreteType.Named("{source}.keys")

        _:
            # Unknown type form - treat as named type
            ConcreteType.Named("Unknown")

# ============================================================================
# Concrete Type to AST Type Conversion
# ============================================================================

fn concrete_to_ast_type(concrete: ConcreteType) -> Type:
    """Convert a ConcreteType back to an AST Type.

    Used for code generation after monomorphization.

    Examples:
        concrete_to_ast_type(Int) -> Simple("Int")
        concrete_to_ast_type(Array(String)) -> Array(Simple("String"), None)
        concrete_to_ast_type(Specialized("List", [Int])) -> Simple("List")

    ROBUSTNESS:
    - All ConcreteType variants handled
    - Pointer capability is ignored (derived from kind in AST)
    - Specialized types collapse to named types (already monomorphized)
    """
    match concrete:
        ConcreteType.Int:
            Type.Simple("Int")

        ConcreteType.Float:
            Type.Simple("Float")

        ConcreteType.Bool:
            Type.Simple("Bool")

        ConcreteType.String:
            Type.Simple("String")

        ConcreteType.Nil:
            Type.Simple("Nil")

        ConcreteType.Named(name):
            Type.Simple(name)

        ConcreteType.Array(elem):
            val elem_ty = concrete_to_ast_type(elem)
            Type.Array(elem_ty, None)

        ConcreteType.Tuple(elems):
            var ast_elems: [Type] = []
            for elem in elems:
                ast_elems.push(concrete_to_ast_type(elem))
            Type.Tuple(ast_elems)

        ConcreteType.Dict(key, value):
            val key_ty = concrete_to_ast_type(key)
            val value_ty = concrete_to_ast_type(value)
            Type.Generic("Dict", [key_ty, value_ty])

        ConcreteType.Function(params, ret):
            var param_types: [Type] = []
            for param in params:
                param_types.push(concrete_to_ast_type(param))

            val ret_ty = concrete_to_ast_type(ret)
            Type.Function(param_types, Some(ret_ty))

        ConcreteType.Optional(inner):
            val inner_ty = concrete_to_ast_type(inner)
            Type.Optional(inner_ty)

        ConcreteType.Pointer(kind, _, inner):
            # Note: Capability is preserved in ConcreteType for monomorphization,
            # but AST Pointer doesn't have a capability field - it's derived from kind
            val ast_kind = concrete_pointer_kind_to_ast(kind)
            val inner_ty = concrete_to_ast_type(inner)
            Type.Pointer(ast_kind, inner_ty)

        ConcreteType.Specialized(name, _):
            # Specialized types are already monomorphized
            # Collapse to the mangled name (Simple type)
            Type.Simple(name)

# ============================================================================
# Pointer Kind Conversion Helpers
# ============================================================================

fn ast_pointer_kind_to_concrete(kind: PointerKind) -> ConcretePointerKind:
    """Convert AST PointerKind to ConcretePointerKind."""
    match kind:
        PointerKind.Unique: ConcretePointerKind.Unique
        PointerKind.Shared: ConcretePointerKind.Shared
        PointerKind.Weak: ConcretePointerKind.Weak
        PointerKind.Handle: ConcretePointerKind.Handle
        PointerKind.Borrow: ConcretePointerKind.Borrow
        PointerKind.BorrowMut: ConcretePointerKind.BorrowMut
        PointerKind.RawConst: ConcretePointerKind.RawConst
        PointerKind.RawMut: ConcretePointerKind.RawMut

fn concrete_pointer_kind_to_ast(kind: ConcretePointerKind) -> PointerKind:
    """Convert ConcretePointerKind to AST PointerKind."""
    match kind:
        ConcretePointerKind.Unique: PointerKind.Unique
        ConcretePointerKind.Shared: PointerKind.Shared
        ConcretePointerKind.Weak: PointerKind.Weak
        ConcretePointerKind.Handle: PointerKind.Handle
        ConcretePointerKind.Borrow: PointerKind.Borrow
        ConcretePointerKind.BorrowMut: PointerKind.BorrowMut
        ConcretePointerKind.RawConst: PointerKind.RawConst
        ConcretePointerKind.RawMut: PointerKind.RawMut

# ============================================================================
# Usage Examples
# ============================================================================
#
# # Check if a type uses a parameter
# val uses_t = type_uses_param(Type.Generic("List", [Type.Simple("T")]), "T")
# print "Uses T: {uses_t}"  # true
#
# # Infer type from expression
# val type_ctx = {"x": ConcreteType.Int}
# val inferred = infer_concrete_type(Expr.Identifier("x"), type_ctx)
# print "Inferred: {inferred}"  # Some(Int)
#
# # Convert AST type to concrete
# val bindings = {"T": ConcreteType.String}
# val concrete = ast_type_to_concrete(
#     Type.Generic("List", [Type.Simple("T")]),
#     bindings
# )
# print "Concrete: {concrete}"  # Specialized("List", [String])
#
# # Convert concrete back to AST
# val ast_ty = concrete_to_ast_type(ConcreteType.Array(ConcreteType.Int))
# print "AST: {ast_ty}"  # Array(Simple("Int"), None)
#
# ============================================================================
# Type Conversion Matrix
# ============================================================================
#
# AST Type Form            | ConcreteType                  | Notes
# -------------------------|-------------------------------|------------------
# Simple("Int")            | Int                           | Primitive
# Simple("T")              | bindings["T"]                 | Type param
# Simple("User")           | Named("User")                 | Named type
# Generic("List", [T])     | Specialized("List", [T])      | Generic
# Array(T, size)           | Array(T)                      | Size ignored
# Tuple([T, U])            | Tuple([T, U])                 | Direct
# Function([T], U)         | Function([T], U)              | Direct
# Optional(T)              | Optional(T)                   | Direct
# Pointer(kind, T)         | Pointer(kind, cap, T)         | Cap derived
# Union([T, U])            | T (first)                     | TODO: full union
# Constructor(T, args)     | T (extract target)            | Factory pattern
# Simd(lanes, T)           | Array(T)                      | SIMD as array
# Capability(T, cap)       | T (unwrap)                    | Compile-time
# DynTrait(name)           | Named("dyn_{name}")           | Trait object
# UnitWithRepr(name, repr) | Named(name)                   | Unit type
# SelfType                 | Named("Self")                 | Self reference
# TypeBinding(_, T)        | T (extract value)             | Type binding
# ConstKeySet(keys)        | Named("const_keys(...)")      | Format string
# DependentKeys(source)    | Named("{source}.keys")        | Key extraction
#
# ============================================================================
# Pointer Kind to Capability Mapping
# ============================================================================
#
# Pointer Kind     | Capability | Rationale
# -----------------|------------|------------------------------------------
# Unique           | Isolated   | Owns the data, no aliasing
# Shared           | Shared     | Multiple readers, no writers
# Weak             | Shared     | Non-owning, no mutation
# Handle           | Shared     | Opaque external resource
# Borrow           | Shared     | Temporary immutable reference
# BorrowMut        | Exclusive  | Temporary mutable reference
# RawConst         | Shared     | Raw pointer (unsafe, const)
# RawMut           | Exclusive  | Raw pointer (unsafe, mutable)
#
# ============================================================================
# Performance Notes
# ============================================================================
#
# - type_uses_param: O(depth) where depth = type nesting level
# - infer_concrete_type: O(1) for literals, O(depth) for arrays
# - ast_type_to_concrete: O(depth) recursive traversal
# - concrete_to_ast_type: O(depth) recursive traversal
#
# Expected performance: Same as Rust (same algorithms, recursive traversal)
#
# ============================================================================
# Robustness Checklist
# ============================================================================
#
# Type Coverage:
# - [x] All AST type variants handled
# - [x] All ConcreteType variants handled
# - [x] All primitive type aliases (i32/i64/f32/f64/str)
# - [x] All pointer kinds (8 kinds)
# - [x] All capabilities (Shared/Exclusive/Isolated)
#
# Logic Correctness:
# - [x] Type parameter substitution works
# - [x] Nested type conversion is recursive
# - [x] Primitive type normalization
# - [x] Pointer kind to capability derivation
# - [x] Bidirectional conversion (AST ↔ Concrete)
#
# Edge Cases:
# - [x] Empty type arguments (returns base name)
# - [x] Unbound type parameters (treated as named types)
# - [x] Unknown AST type forms (treated as "Unknown")
# - [x] Union with no types (returns Nil)
# - [x] Array with no elements (returns None for inference)
#
# Memory Safety:
# - [x] No buffer overflows (Simple arrays safe)
# - [x] No null pointers (Option<T> pattern)
# - [x] No use-after-free (Simple ownership)
#
# TODO:
# - [ ] Full union type support (ConcreteType.Union variant)
# - [ ] More complete type inference (beyond literals)
# - [ ] Type validation (well-formedness checks)
#
