# Memory Leak Finder - Core Types
#
# Data structures for leak detection and reporting.

# Test type enum
enum TestType:
    Simple
    SDoctest
    Rust
    All

# Convert TestType to string
fn test_type_to_string(t: TestType) -> text:
    match t:
        case TestType.Simple: "simple"
        case TestType.SDoctest: "sdoctest"
        case TestType.Rust: "rust"
        case TestType.All: "all"

# Parse TestType from string
fn test_type_from_string(s: text) -> Option<TestType>:
    match s.lower():
        case "simple": Some(TestType.Simple)
        case "sdoctest": Some(TestType.SDoctest)
        case "rust": Some(TestType.Rust)
        case "all": Some(TestType.All)
        case _: nil

# Configuration for leak finder
class LeakFinderConfig:
    test_type: TestType
    threshold_kb: i64
    consecutive_count: i32
    timeout_seconds: i32
    output_file: Option<text>
    verbose: bool
    stop_on_leak: bool
    test_pattern: Option<text>

# Create default configuration
fn default_config() -> LeakFinderConfig:
    LeakFinderConfig(
        test_type: TestType.All,
        threshold_kb: 500000,      # 500MB default
        consecutive_count: 5,
        timeout_seconds: 120,
        output_file: nil,
        verbose: false,
        stop_on_leak: false,
        test_pattern: nil
    )

# Result of a single test run
class TestRunResult:
    test_file: text
    memory_before_kb: i64
    memory_after_kb: i64
    diff_kb: i64
    status: text              # "ok", "timeout", "failed"
    duration_ms: i64

impl TestRunResult:
    fn is_ok() -> bool:
        self.status == "ok"

    fn is_timeout() -> bool:
        self.status == "timeout"

    fn is_failed() -> bool:
        self.status == "failed"

    fn memory_consumed() -> bool:
        self.diff_kb < 0

    fn memory_consumed_kb() -> i64:
        if self.diff_kb < 0:
            -self.diff_kb
        else:
            0

# A detected memory leak entry
class LeakEntry:
    test_file: text
    consecutive_count: i32
    growth_kb: i64
    first_test_index: i32     # Index of first test in leak sequence

impl LeakEntry:
    fn format() -> text:
        "{self.test_file}: {self.consecutive_count} consecutive growth ({self.growth_kb} KB total)"

# Complete leak report
class LeakReport:
    timestamp: text
    test_type: text
    total_tests: i32
    baseline_memory_kb: i64
    final_memory_kb: i64
    leaks: [LeakEntry]
    test_runs: [TestRunResult]

# Create empty leak report
fn empty_report(test_type: text) -> LeakReport:
    LeakReport(
        timestamp: "",
        test_type: test_type,
        total_tests: 0,
        baseline_memory_kb: 0,
        final_memory_kb: 0,
        leaks: [],
        test_runs: []
    )

impl LeakReport:
    fn has_leaks() -> bool:
        self.leaks.len() > 0

    fn leak_count() -> i32:
        self.leaks.len() as i32

    fn total_growth_kb() -> i64:
        self.baseline_memory_kb - self.final_memory_kb

# Export types and functions
export TestType
export test_type_to_string, test_type_from_string, default_config, empty_report
