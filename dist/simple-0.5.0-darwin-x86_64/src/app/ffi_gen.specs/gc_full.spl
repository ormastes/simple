# Garbage Collector Module - Full Specification
#
# Complete specification for generating gc.rs with:
# - GC initialization
# - Memory allocation functions (using bdwgc-alloc)
# - Collection control
# - Unit tests
#
# Usage: simple ffi-gen --gen-module specs/gc_full.spl

use app.ffi_gen.types*
use app.ffi_gen.module_gen (ModuleBuilder)

# ============================================================================
# Module Specification
# ============================================================================

fn gc_module() -> ModuleSpec:
    var builder = ModuleBuilder.start("gc")
        .doc("Garbage Collector FFI\n\nUses Boehm-Demers-Weiser GC (bdwgc) as the garbage collector.\nThis is a conservative, portable GC used by many language runtimes.")

    # Imports
    builder = builder
        .add_import_items("std::alloc", ["GlobalAlloc", "Layout"])

    # GC functions
    builder = builder
        .add_fn(fn_rt_gc_init())
        .add_fn(fn_rt_gc_malloc())
        .add_fn(fn_rt_gc_malloc_atomic())
        .add_fn(fn_rt_gc_collect())
        .add_fn(fn_rt_gc_get_heap_size())
        .add_fn(fn_rt_gc_get_free_bytes())

    # Tests (ignored since bdwgc has issues in test environment)
    builder = builder
        .add_test(test_gc_malloc())
        .add_test(test_gc_malloc_atomic())

    builder.build()

# ============================================================================
# GC Functions
# ============================================================================

fn fn_rt_gc_init() -> FFIFnSpec:
    var spec = FFIFnSpec.extern_c("rt_gc_init", [], "()",
        "// bdwgc initializes automatically on first allocation\n" +
        "// This is a no-op but kept for API compatibility"
    )
    spec.doc = "Initialize the GC"
    spec

fn fn_rt_gc_malloc() -> FFIFnSpec:
    var spec = FFIFnSpec.unsafe_extern_c("rt_gc_malloc",
        [FFIParamSpec.simple("size", "usize")],
        "*mut u8",
        "if size == 0 {\n" +
        "    return std::ptr::null_mut();\n" +
        "}\n" +
        "\n" +
        "let layout = Layout::from_size_align_unchecked(size, 8);\n" +
        "bdwgc_alloc::Allocator.alloc(layout)"
    )
    spec.doc = "Allocate memory (GC-managed)"
    spec

fn fn_rt_gc_malloc_atomic() -> FFIFnSpec:
    var spec = FFIFnSpec.unsafe_extern_c("rt_gc_malloc_atomic",
        [FFIParamSpec.simple("size", "usize")],
        "*mut u8",
        "// For now, use same as regular malloc\n" +
        "// bdwgc has atomic allocation but not exposed in bdwgc-alloc crate yet\n" +
        "rt_gc_malloc(size)"
    )
    spec.doc = "Allocate atomic memory (no pointers, won't be scanned)"
    spec

fn fn_rt_gc_collect() -> FFIFnSpec:
    var spec = FFIFnSpec.extern_c("rt_gc_collect", [], "()",
        "// bdwgc-alloc doesn't expose explicit collection\n" +
        "// Collection happens automatically"
    )
    spec.doc = "Force garbage collection"
    spec

fn fn_rt_gc_get_heap_size() -> FFIFnSpec:
    var spec = FFIFnSpec.extern_c("rt_gc_get_heap_size", [], "usize",
        "// Not available in bdwgc-alloc\n0"
    )
    spec.doc = "Get heap size"
    spec

fn fn_rt_gc_get_free_bytes() -> FFIFnSpec:
    var spec = FFIFnSpec.extern_c("rt_gc_get_free_bytes", [], "usize",
        "// Not available in bdwgc-alloc\n0"
    )
    spec.doc = "Get free bytes"
    spec

# ============================================================================
# Test Specifications
# ============================================================================

fn test_gc_malloc() -> TestSpec:
    TestSpec.ignored_test("test_gc_malloc",
        "TODO: bdwgc has issues in test environment - test in integration tests instead",
        "rt_gc_init();\n" +
        "unsafe {\n" +
        "    let ptr = rt_gc_malloc(1024);\n" +
        "    assert!(!ptr.is_null());\n" +
        "    // Write some data\n" +
        "    *ptr = 42;\n" +
        "    assert_eq!(*ptr, 42);\n" +
        "}"
    )

fn test_gc_malloc_atomic() -> TestSpec:
    TestSpec.ignored_test("test_gc_malloc_atomic",
        "TODO: bdwgc has issues in test environment - test in integration tests instead",
        "unsafe {\n" +
        "    let ptr = rt_gc_malloc_atomic(512);\n" +
        "    assert!(!ptr.is_null());\n" +
        "}"
    )
export gc_module
