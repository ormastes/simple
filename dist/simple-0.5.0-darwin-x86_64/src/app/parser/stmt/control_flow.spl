# Statement Parser - Control Flow Module
#
# Parsing for control flow statements: if, for, while, loop, match,
# context, with, and defer statements.
# Extracted from statements.spl (Control Flow section)

from token import {Span, Token, TokenKind}
from ast import {Node, Block, Expr, Pattern,
                 IfStmt, ForStmt, WhileStmt, LoopStmt, MatchStmt,
                 ContextStmt, WithStmt, DeferStmt}
from error import {ParseError}

export ControlFlowParser

impl Parser:
    # Parse if statement (block form)
    fn parse_if_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        val is_suspended = self.check(TokenKind.IfSuspend)

        if is_suspended:
            self.advance()
        else:
            self.expect(TokenKind.If)

        val condition = self.parse_expression()
        self.expect(TokenKind.Colon)
        val then_block = self.parse_block()

        val elif_branches = []
        while self.check(TokenKind.Elif) or self.check(TokenKind.ElifSuspend):
            val elif_suspended = self.check(TokenKind.ElifSuspend)
            self.advance()
            val elif_cond = self.parse_expression()
            self.expect(TokenKind.Colon)
            val elif_block = self.parse_block()
            elif_branches.append((elif_cond, elif_block, elif_suspended))

        val else_block = None
        if self.check(TokenKind.Else):
            self.advance()
            self.expect(TokenKind.Colon)
            else_block = Some(self.parse_block())

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.If(IfStmt(
            span: span,
            condition: condition,
            then_block: then_block,
            elif_branches: elif_branches,
            else_block: else_block,
            is_suspended: is_suspended,
        )))

    # Parse for statement: for x in iterable: block
    fn parse_for_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        val is_suspended = self.check(TokenKind.ForSuspend)

        if is_suspended:
            self.advance()
        else:
            self.expect(TokenKind.For)

        # Check for enumerate shorthand: for i, item in iterable
        val pattern = self.parse_pattern()

        self.expect(TokenKind.In)
        val iterable = self.parse_expression()
        self.expect(TokenKind.Colon)
        val body = self.parse_block()

        # Optional else clause
        val else_block = None
        if self.check(TokenKind.Else):
            self.advance()
            self.expect(TokenKind.Colon)
            else_block = Some(self.parse_block())

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.For(ForStmt(
            span: span,
            pattern: pattern,
            iterable: iterable,
            body: body,
            else_block: else_block,
            is_suspended: is_suspended,
        )))

    # Parse while statement: while condition: block
    fn parse_while_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        val is_suspended = self.check(TokenKind.WhileSuspend)

        if is_suspended:
            self.advance()
        else:
            self.expect(TokenKind.While)

        # Support while val pattern = expr (pattern binding)
        val condition = None
        val pattern = None
        if self.check(TokenKind.Val) or self.check(TokenKind.Var) or self.check(TokenKind.Let):
            val kw = self.current.kind
            self.advance()
            pattern = Some(self.parse_pattern())
            self.expect(TokenKind.Assign)
            condition = Some(self.parse_expression())
        else:
            condition = Some(self.parse_expression())

        self.expect(TokenKind.Colon)
        val body = self.parse_block()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.While(WhileStmt(
            span: span,
            condition: condition,
            pattern: pattern,
            body: body,
            is_suspended: is_suspended,
        )))

    # Parse loop statement: loop: block
    fn parse_loop_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Loop)
        self.expect(TokenKind.Colon)
        val body = self.parse_block()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Loop(LoopStmt(
            span: span,
            body: body,
        )))

    # Parse match statement (block form): match expr: arms...
    fn parse_match_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        val is_suspended = self.check(TokenKind.MatchSuspend)

        if is_suspended:
            self.advance()
        else:
            self.expect(TokenKind.Match)

        val scrutinee = self.parse_expression()
        self.expect(TokenKind.Colon)
        self.expect(TokenKind.Newline)
        self.expect(TokenKind.Indent)

        val arms = []
        while not self.check(TokenKind.Dedent) and not self.is_at_end():
            while self.check(TokenKind.Newline):
                self.advance()
            if self.check(TokenKind.Dedent) or self.is_at_end():
                break

            val arm_pattern = self.parse_pattern()

            # Optional guard: if condition
            val guard = None
            if self.check(TokenKind.If):
                self.advance()
                guard = Some(self.parse_expression())

            self.expect(TokenKind.Colon)

            # Arm body: inline expr or block
            val arm_body = if self.check(TokenKind.Newline):
                self.parse_block()
            else:
                val expr = self.parse_expression()
                Block(statements: [Node.Expression(expr)])

            arms.append((arm_pattern, guard, arm_body))

            if self.check(TokenKind.Newline):
                self.advance()

        if self.check(TokenKind.Dedent):
            self.advance()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Match(MatchStmt(
            span: span,
            scrutinee: scrutinee,
            arms: arms,
            is_suspended: is_suspended,
        )))

    # Parse context statement: context expr: block
    fn parse_context_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Context)
        val expr = self.parse_expression()
        self.expect(TokenKind.Colon)
        val body = self.parse_block()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Context(ContextStmt(
            span: span,
            expr: expr,
            body: body,
        )))

    # Parse with statement: with resource = expr: block
    fn parse_with_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.With)

        val name = self.expect_identifier()
        self.expect(TokenKind.Assign)
        val resource = self.parse_expression()
        self.expect(TokenKind.Colon)
        val body = self.parse_block()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.With(WithStmt(
            span: span,
            name: name,
            resource: resource,
            body: body,
        )))

    # Parse defer statement: defer: block or defer expr
    fn parse_defer_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Defer)

        val body = if self.check(TokenKind.Colon):
            self.advance()
            self.parse_block()
        else:
            val expr = self.parse_expression()
            Block(statements: [Node.Expression(expr)])

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Defer(DeferStmt(
            span: span,
            body: body,
        )))
