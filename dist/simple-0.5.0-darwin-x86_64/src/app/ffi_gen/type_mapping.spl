# FFI Wrapper Generator - Type Mapping
#
# Maps Simple types to Rust types and C ABI types for FFI wrapper generation.

# ============================================================================
# Type Mapping Functions
# ============================================================================

# Map a Simple type name to its Rust equivalent
fn simple_to_rust(simple_type: text) -> text:
    match simple_type:
        case "i32":
            "i32"
        case "i64":
            "i64"
        case "f32":
            "f32"
        case "f64":
            "f64"
        case "bool":
            "bool"
        case "text" | "str" | "String":
            "String"
        case "()":
            "()"
        case _:
            # Check for Option<T>
            if simple_type.starts_with("Option<") and simple_type.ends_with(">"):
                val inner = simple_type[7:-1]
                val rust_inner = simple_to_rust(inner)
                "Option<{rust_inner}>"
            # Check for array [T]
            elif simple_type.starts_with("[") and simple_type.ends_with("]"):
                val inner = simple_type[1:-1]
                val rust_inner = simple_to_rust(inner)
                "Vec<{rust_inner}>"
            else:
                # Assume it's a class name (opaque handle)
                simple_type

# Map a Simple type to its C ABI representation for extern "C" functions
fn simple_to_c_abi(simple_type: text) -> text:
    match simple_type:
        case "i32":
            "i32"
        case "i64":
            "i64"
        case "f32":
            "f32"
        case "f64":
            "f64"
        case "bool":
            "u8"
        case "text" | "str" | "String":
            "*const u8, len: u64"
        case "()":
            "()"
        case _:
            if simple_type.starts_with("Option<"):
                # Nullable pointer for optional object handles
                "*mut std::ffi::c_void"
            elif simple_type.starts_with("["):
                # Arrays passed as opaque runtime values
                "*mut std::ffi::c_void"
            else:
                # Object handle
                "*mut {simple_type}"

# Check if a type is a primitive (passed by value through C ABI)
fn is_primitive(simple_type: text) -> bool:
    match simple_type:
        case "i32" | "i64" | "f32" | "f64" | "bool":
            true
        case _:
            false

# Check if a type is a string type
fn is_string(simple_type: text) -> bool:
    match simple_type:
        case "text" | "str" | "String":
            true
        case _:
            false

# Check if a type is an object handle (needs Box<T> wrapping)
fn is_object_handle(simple_type: text) -> bool:
    not is_primitive(simple_type) and not is_string(simple_type) and simple_type != "()" and not simple_type.starts_with("Option<") and not simple_type.starts_with("[")

# Get the Rust type for a function parameter in extern "C" context
fn param_c_type(simple_type: text) -> text:
    if is_primitive(simple_type):
        simple_to_rust(simple_type)
    elif simple_type == "bool":
        "u8"
    elif is_string(simple_type):
        "ptr: *const u8, len: u64"
    elif is_object_handle(simple_type):
        "*mut {simple_type}"
    else:
        simple_to_c_abi(simple_type)

# Get the Rust return type for extern "C" context
fn return_c_type(simple_type: text) -> text:
    if simple_type == "" or simple_type == "()":
        "()"
    elif is_primitive(simple_type):
        simple_to_rust(simple_type)
    elif simple_type == "bool":
        "u8"
    elif is_string(simple_type):
        "FfiString"
    elif is_object_handle(simple_type):
        "*mut {simple_type}"
    else:
        simple_to_c_abi(simple_type)
