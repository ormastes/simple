# Test Database Performance Benchmarks
#
# Benchmarks for database parsing, serialization, and I/O operations.

use test_db_parser.{parse_stable_db, parse_volatile_db}
use test_db_parser_robust.{parse_stable_db_robust, parse_volatile_db_robust}
use test_db_serializer.{serialize_stable_db, serialize_volatile_db}
use test_db_io.{DB_PATH, RUNS_PATH, read_db_file}
use app.io.mod (time_now_unix_micros)

# =========================================================================
# Benchmark Results
# =========================================================================

struct BenchmarkResult:
    name: text
    iterations: i64
    total_time_ms: f64
    avg_time_ms: f64
    min_time_ms: f64
    max_time_ms: f64
    throughput_ops_per_sec: f64

impl BenchmarkResult:
    fn summary() -> text:
        "{self.name}:\n" +
        "  Iterations: {self.iterations}\n" +
        "  Avg time: {self.avg_time_ms:.3} ms\n" +
        "  Min time: {self.min_time_ms:.3} ms\n" +
        "  Max time: {self.max_time_ms:.3} ms\n" +
        "  Throughput: {self.throughput_ops_per_sec:.1} ops/sec"

# =========================================================================
# Benchmark Helpers
# =========================================================================

fn benchmark(name: text, iterations: i64, f: fn() -> ()) -> BenchmarkResult:
    """Run a function multiple times and measure performance."""
    var times: List<f64> = []

    var i = 0
    while i < iterations:
        val start = time_now_unix_micros()
        f()
        val end = time_now_unix_micros()
        val duration_ms = (end - start).to_float() / 1000.0
        times.push(duration_ms)
        i = i + 1

    val total_time = times.sum()
    val avg_time = total_time / iterations.to_float()
    val min_time = times.min() ?? 0.0
    val max_time = times.max() ?? 0.0
    val throughput = if avg_time > 0.0: 1000.0 / avg_time else: 0.0

    BenchmarkResult(
        name: name,
        iterations: iterations,
        total_time_ms: total_time,
        avg_time_ms: avg_time,
        min_time_ms: min_time,
        max_time_ms: max_time,
        throughput_ops_per_sec: throughput
    )

# =========================================================================
# Database Benchmarks
# =========================================================================

fn benchmark_stable_parse(content: text, iterations: i64) -> BenchmarkResult:
    """Benchmark stable database parsing (standard parser)."""
    benchmark("Stable DB Parse (Standard)", iterations, || {
        val _ = parse_stable_db(content)
    })

fn benchmark_stable_parse_robust(content: text, iterations: i64) -> BenchmarkResult:
    """Benchmark stable database parsing (robust parser)."""
    benchmark("Stable DB Parse (Robust)", iterations, || {
        val _ = parse_stable_db_robust(content)
    })

fn benchmark_volatile_parse(content: text, iterations: i64) -> BenchmarkResult:
    """Benchmark volatile database parsing (standard parser)."""
    benchmark("Volatile DB Parse (Standard)", iterations, || {
        val _ = parse_volatile_db(content)
    })

fn benchmark_volatile_parse_robust(content: text, iterations: i64) -> BenchmarkResult:
    """Benchmark volatile database parsing (robust parser)."""
    benchmark("Volatile DB Parse (Robust)", iterations, || {
        val _ = parse_volatile_db_robust(content)
    })

fn benchmark_full_load(iterations: i64) -> BenchmarkResult:
    """Benchmark full database load (both files)."""
    benchmark("Full DB Load", iterations, || {
        val stable_result = read_db_file(DB_PATH)
        if stable_result.ok.?:
            val content = stable_result.unwrap()
            if content.trim() != "":
                val _ = parse_stable_db_robust(content)

        val volatile_result = read_db_file(RUNS_PATH)
        if volatile_result.ok.?:
            val content = volatile_result.unwrap()
            if content.trim() != "":
                val _ = parse_volatile_db_robust(content)
    })

# =========================================================================
# CLI Interface
# =========================================================================

fn run_benchmarks():
    """Run all database benchmarks."""
    print "Test Database Performance Benchmarks"
    print "====================================\n"

    val iterations = 100

    # Load database content
    print "Loading databases..."
    val stable_content = read_db_file(DB_PATH).unwrap_or("")
    val volatile_content = read_db_file(RUNS_PATH).unwrap_or("")

    print "Stable DB size: {stable_content.len()} bytes"
    print "Volatile DB size: {volatile_content.len()} bytes\n"

    # Run benchmarks
    print "Running benchmarks ({iterations} iterations each)...\n"

    if stable_content.trim() != "":
        val result1 = benchmark_stable_parse(stable_content, iterations)
        print result1.summary()
        print ""

        val result2 = benchmark_stable_parse_robust(stable_content, iterations)
        print result2.summary()
        print ""

    if volatile_content.trim() != "":
        val result3 = benchmark_volatile_parse(volatile_content, iterations)
        print result3.summary()
        print ""

        val result4 = benchmark_volatile_parse_robust(volatile_content, iterations)
        print result4.summary()
        print ""

    val result5 = benchmark_full_load(iterations)
    print result5.summary()
    print ""

    print "Benchmark complete!"

# =========================================================================
# Exports
# =========================================================================

export benchmark, run_benchmarks
export benchmark_stable_parse, benchmark_stable_parse_robust
export benchmark_volatile_parse, benchmark_volatile_parse_robust
export benchmark_full_load
export BenchmarkResult
