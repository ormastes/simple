#!/usr/bin/env simple
# Generate Markdown Documentation from Simple Spec Files
# Migrated from script/build/gen_spec_docs.sh

use app.io
use app.utils.colors (success, error, warning, info)
use app.utils.markdown (MarkdownBuilder)

export main, gen_spec_docs

struct SpecInfo:
    file_path: text
    feature_name: text
    test_count: i64
    relative_path: text

fn main():
    gen_spec_docs()

fn gen_spec_docs():
    """Generate documentation from spec files"""
    val repo_root = cwd()
    val docs_dir = "{repo_root}/doc/spec"
    val test_dir = "{repo_root}/simple/std_lib/test"

    print "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    print "â•‘         Generating Markdown Documentation from Spec Files                 â•‘"
    print "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    print ""

    # Create docs directory
    if not is_dir(docs_dir):
        dir_create(docs_dir, recursive: true)

    print "ðŸ“ Processing spec files..."
    print ""

    # Generate MIXIN_FEATURES.md
    print "  âžœ Generating MIXIN_FEATURES.md..."
    generate_mixin_features(docs_dir, test_dir)
    print success("    âœ… MIXIN_FEATURES.md generated")

    # Generate SPEC_CATALOG.md
    print "  âžœ Generating SPEC_CATALOG.md..."
    generate_spec_catalog(docs_dir, test_dir)
    print success("    âœ… SPEC_CATALOG.md generated")

    # Update README.md
    print "  âžœ Updating README.md..."
    update_readme(docs_dir, test_dir)
    print success("    âœ… README.md updated")

    print ""
    print "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    print "â•‘                    Documentation Generation Complete                       â•‘"
    print "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    print ""
    print "ðŸ“„ Generated files in doc/spec/:"
    print "   - MIXIN_FEATURES.md"
    print "   - SPEC_CATALOG.md"
    print "   - README.md (updated)"
    print ""
    print success("âœ… All documentation up to date!")

fn generate_mixin_features(docs_dir: text, test_dir: text):
    """Generate MIXIN_FEATURES.md"""
    var md = MarkdownBuilder(content: "")

    md.h1("Mixin and Static Polymorphism Features")
    md.paragraph("**Generated:** {current_datetime()}")
    md.paragraph("**Status:** âœ… All Tests Passing")
    md.paragraph("**Source:** Auto-generated from Simple spec files")
    md.h2("Overview")
    md.paragraph("This document provides comprehensive documentation for Simple's mixin and static polymorphism features, automatically generated from executable test specifications.")
    md.h2("Test Specifications")

    # Process mixin specs
    val mixin_dir = "{test_dir}/system/mixins"
    if is_dir(mixin_dir):
        val specs = find_spec_files(mixin_dir)
        for spec in specs:
            add_spec_section(md, spec, "simple/std_lib/test/system/mixins")

    # Process static polymorphism specs
    val static_poly_dir = "{test_dir}/system/static_poly"
    if is_dir(static_poly_dir):
        val specs = find_spec_files(static_poly_dir)
        for spec in specs:
            add_spec_section(md, spec, "simple/std_lib/test/system/static_poly")

    # Write to file
    file_write("{docs_dir}/MIXIN_FEATURES.md", md.to_string())

fn generate_spec_catalog(docs_dir: text, test_dir: text):
    """Generate SPEC_CATALOG.md"""
    var md = MarkdownBuilder(content: "")

    md.h1("Simple Specification Catalog")

    val total_specs = count_total_specs(test_dir)
    md.paragraph("**Generated:** {current_datetime()}")
    md.paragraph("**Total Specs:** {total_specs}")
    md.paragraph("**Status:** âœ… All Passing")

    md.h2("Specification Index")

    # System specifications
    md.h3("System Specifications")
    val system_dir = "{test_dir}/system"
    if is_dir(system_dir):
        val specs = find_spec_files_recursive(system_dir)
        for spec in specs:
            val rel_path = spec.relative_path.replace(test_dir + "/", "")
            md.append("- **[{spec.feature_name}]({rel_path})** - {spec.test_count} tests\n")

    # Integration specifications
    md.append("\n")
    md.h3("Integration Specifications")
    val integration_dir = "{test_dir}/integration"
    if is_dir(integration_dir):
        val specs = find_spec_files_recursive(integration_dir)
        for spec in specs:
            val rel_path = spec.relative_path.replace(test_dir + "/", "")
            md.append("- **[{spec.feature_name}]({rel_path})** - {spec.test_count} tests\n")

    # Unit specifications (first 20)
    md.append("\n")
    md.h3("Unit Specifications")
    val unit_dir = "{test_dir}/unit"
    if is_dir(unit_dir):
        val specs = find_spec_files_recursive(unit_dir)
        var count = 0
        for spec in specs:
            if count >= 20:
                break
            val rel_path = spec.relative_path.replace(test_dir + "/", "")
            md.append("- **[{spec.feature_name}]({rel_path})** - {spec.test_count} tests\n")
            count = count + 1

    # Write to file
    file_write("{docs_dir}/SPEC_CATALOG.md", md.to_string())

fn update_readme(docs_dir: text, test_dir: text):
    """Update README.md with latest stats"""
    val total_specs = count_total_specs(test_dir)
    val total_tests = get_total_test_count()

    var content = "# Simple Compiler Test Documentation Index\n\n"
    content = content + "**Last Updated:** {current_datetime()}\n"
    content = content + "**Total Specs:** {total_specs}\n"
    content = content + "**Total Tests:** {total_tests}\n"
    content = content + "**Status:** âœ… ALL PASSING\n\n"
    content = content + "## Quick Links\n\n"
    content = content + "- ðŸ“Š [Latest Test Report](TEST_REPORT_2026-01-08.md)\n"
    content = content + "- ðŸ§ª [BDD Test Specification](BDD_TEST_SPEC.md)\n"
    content = content + "- ðŸŽ¯ [Mixin Features](MIXIN_FEATURES.md)\n"
    content = content + "- ðŸ“š [Full Spec Catalog](SPEC_CATALOG.md)\n"
    content = content + "- ðŸ“ [Test Summary](TEST_SUMMARY.txt)\n\n"

    # Keep the rest of the original README if it exists
    val readme_path = "{docs_dir}/README.md"
    if file_exists(readme_path):
        val old_content = file_read(readme_path)
        val lines = old_content.split("\n")
        if lines.len() > 10:
            for i in 10..lines.len():
                content = content + lines[i] + "\n"

    file_write(readme_path, content)

fn find_spec_files(directory: text) -> [SpecInfo]:
    """Find all spec files in a directory"""
    var specs = []

    val (stdout, _, code) = process_run("find",
        [directory, "-maxdepth", "1", "-name", "*_spec.spl", "-type", "f"])

    if code != 0:
        return specs

    val lines = stdout.split("\n")
    for line in lines:
        val path = line.trim()
        if path.len() > 0 and file_exists(path):
            val info = extract_spec_info(path)
            specs = specs + [info]

    specs

fn find_spec_files_recursive(directory: text) -> [SpecInfo]:
    """Find all spec files recursively"""
    var specs = []

    val (stdout, _, code) = process_run("find",
        [directory, "-name", "*_spec.spl", "-type", "f"])

    if code != 0:
        return specs

    val lines = stdout.split("\n")
    var sorted = []
    for line in lines:
        val path = line.trim()
        if path.len() > 0:
            sorted = sorted + [path]

    # Simple sort
    sorted = sort_paths(sorted)

    for path in sorted:
        if file_exists(path):
            val info = extract_spec_info(path)
            specs = specs + [info]

    specs

fn extract_spec_info(file_path: text) -> SpecInfo:
    """Extract information from a spec file"""
    val feature_name = get_feature_name(file_path)
    val test_count = count_tests(file_path)

    SpecInfo(
        file_path: file_path,
        feature_name: feature_name,
        test_count: test_count,
        relative_path: file_path
    )

fn get_feature_name(file_path: text) -> text:
    """Extract feature/describe name from spec file"""
    val content = file_read(file_path)
    val lines = content.split("\n")

    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("describe \"") or trimmed.starts_with("feature \""):
            val start = trimmed.find("\"")
            val end = trimmed.rfind("\"")
            if start >= 0 and end > start:
                return trimmed.substring(start + 1, end)

    "Unknown Feature"

fn count_tests(file_path: text) -> i64:
    """Count test cases in a spec file"""
    val (stdout, _, code) = process_run("grep",
        ["-E", "^\\s*(it|scenario) \"", file_path])

    if code != 0:
        return 0

    val lines = stdout.split("\n")
    var count = 0
    for line in lines:
        if line.trim().len() > 0:
            count = count + 1
    count

fn count_total_specs(test_dir: text) -> i64:
    """Count total number of spec files"""
    val (stdout, _, code) = process_run("find",
        [test_dir, "-name", "*_spec.spl", "-type", "f"])

    if code != 0:
        return 0

    val lines = stdout.split("\n")
    var count = 0
    for line in lines:
        if line.trim().len() > 0:
            count = count + 1
    count

fn get_total_test_count() -> text:
    """Get total test count from cargo test"""
    val (stdout, _, _) = process_run("cargo",
        ["test", "-p", "simple-driver", "--test", "simple_stdlib_tests"])

    val lines = stdout.split("\n")
    for line in lines:
        if line.contains("test result:"):
            val parts = line.split(" ")
            for i in 0..parts.len():
                if parts[i] == "passed":
                    if i > 0:
                        return parts[i - 1]

    "Unknown"

fn add_spec_section(md: MarkdownBuilder, spec: SpecInfo, base_path: text):
    """Add a spec section to markdown"""
    val filename = extract_filename(spec.file_path)

    md.h3(spec.feature_name)
    md.paragraph("**Source:** `{base_path}/{filename}`")
    md.paragraph("**Tests:** {spec.test_count} passing âœ…")

    # Add code preview (first 20 lines, non-empty)
    val preview = get_code_preview(spec.file_path, 20)
    md.code_block(preview, "simple")

    md.append("---\n\n")

fn get_code_preview(file_path: text, max_lines: i64) -> text:
    """Get first N non-empty lines from file"""
    val content = file_read(file_path)
    val lines = content.split("\n")

    var preview = ""
    var count = 0

    for line in lines:
        if count >= max_lines:
            break
        if line.trim().len() > 0:
            preview = preview + line + "\n"
            count = count + 1

    preview

fn extract_filename(path: text) -> text:
    """Extract filename from path"""
    val parts = path.split("/")
    if parts.len() > 0:
        return parts[parts.len() - 1]
    path

fn sort_paths(paths: [text]) -> [text]:
    """Simple bubble sort for paths"""
    var sorted = paths
    var n = sorted.len()

    for i in 0..n:
        for j in 0..(n - i - 1):
            if sorted[j] > sorted[j + 1]:
                val temp = sorted[j]
                sorted[j] = sorted[j + 1]
                sorted[j + 1] = temp

    sorted

fn current_datetime() -> text:
    """Get current date/time in UTC format"""
    val year = timestamp_year()
    val month = timestamp_month()
    val day = timestamp_day()
    val hour = timestamp_hour()
    val minute = timestamp_minute()

    "{year}-{month:02}-{day:02} {hour:02}:{minute:02} UTC"
