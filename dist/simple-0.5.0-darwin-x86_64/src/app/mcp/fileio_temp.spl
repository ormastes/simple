# Temporary File Manager
# Manages session-based temporary directories for file I/O redirection

export TempManager, TempSession, create_temp_manager

# Temporary session
struct TempSession:
    session_id: text
    base_dir: text
    created_at: i64
    files: [text]

# Temporary file manager
class TempManager:
    base_dir: text
    session_prefix: text
    cleanup_on_exit: bool
    max_age_hours: i64
    current_session: TempSession?

    # Create a new temp session
    me create_session() -> TempSession:
        val timestamp = self.get_timestamp()
        val session_id = self.session_prefix + timestamp.to_string()
        val session_dir = self.base_dir + "/" + session_id

        # Create session directory
        self.ensure_dir(session_dir)

        val session = TempSession(
            session_id: session_id,
            base_dir: session_dir,
            created_at: timestamp,
            files: []
        )

        self.current_session = Some(session)
        session

    # Get current session or create new one
    me get_session() -> TempSession:
        if self.current_session.?:
            self.current_session.unwrap()
        else:
            self.create_session()

    # Get temp directory for current session
    fn get_temp_dir() -> text:
        val session = self.get_session()
        session.base_dir

    # Get temp path for a file
    me get_temp_path(original_path: text) -> text:
        val session = self.get_session()

        # Extract filename from original path
        val parts = original_path.split("/")
        val filename = if parts.len() > 0:
            parts[parts.len() - 1]
        else:
            original_path

        val temp_path = session.base_dir + "/" + filename

        # Track file in session
        if not session.files.contains(temp_path):
            session.files.push(temp_path)

        temp_path

    # List all temp files in current session
    fn list_temp_files() -> [text]:
        if not self.current_session.?:
            return []

        val session = self.current_session.unwrap()
        session.files

    # Cleanup current session
    me cleanup_session():
        if not self.current_session.?:
            return

        val session = self.current_session.unwrap()

        # Remove session directory
        self.remove_dir(session.base_dir)

        self.current_session = None

    # Cleanup old sessions based on max age
    me cleanup_old_sessions():
        val now = self.get_timestamp()
        val max_age_seconds = self.max_age_hours * 3600

        # List all session directories
        val sessions = self.list_sessions()

        for session_dir in sessions:
            # Get session creation time from directory name
            val parts = session_dir.split("_")
            if parts.len() < 2:
                continue

            val timestamp_str = parts[parts.len() - 1]
            val timestamp = parse_i64_safe(timestamp_str)

            if timestamp == 0:
                continue
            val age_seconds = now - timestamp

            # Remove old session
            if age_seconds > max_age_seconds:
                self.remove_dir(self.base_dir + "/" + session_dir)

    # List all session directories
    fn list_sessions() -> [text]:
        if not self.dir_exists(self.base_dir):
            return []

        val output = shell("ls -1 '{self.base_dir}' 2>/dev/null || echo ''")
        if output.len() == 0:
            return []

        output.split("\n").filter(\line: line.trim().len() > 0)

    # Ensure directory exists
    me ensure_dir(path: text):
        shell("mkdir -p '{path}'")

    # Check if directory exists
    fn dir_exists(path: text) -> bool:
        val result = shell("test -d '{path}' && echo yes || echo no")
        result.trim() == "yes"

    # Remove directory recursively
    me remove_dir(path: text):
        shell("rm -rf '{path}'")

    # Get current timestamp (seconds since epoch)
    fn get_timestamp() -> i64:
        val output = shell("date +%s")
        parse_i64_safe(output.trim())

# Create temp manager from config
fn create_temp_manager(base_dir: text, session_prefix: text, cleanup_on_exit: bool, max_age_hours: i64) -> TempManager:
    val manager = TempManager(
        base_dir: base_dir,
        session_prefix: session_prefix,
        cleanup_on_exit: cleanup_on_exit,
        max_age_hours: max_age_hours,
        current_session: None
    )

    # Ensure base directory exists
    manager.ensure_dir(base_dir)

    # Cleanup old sessions
    manager.cleanup_old_sessions()

    manager

# Helper function to run shell command
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn shell(cmd: text) -> text:
    val (stdout, stderr, exit_code) = rt_process_run("sh", ["-c", cmd])
    if exit_code == 0:
        stdout
    else:
        ""

# Helper to parse i64 from string (bootstrap runtime compatible)
fn parse_i64_safe(s: text) -> i64:
    # Simple digit-by-digit parsing
    var result = 0
    var sign = 1

    var start = 0
    if s.len() > 0 and s[0:1] == "-":
        sign = -1
        start = 1

    for i in start..s.len():
        val ch = s[i:i+1]
        if ch >= "0" and ch <= "9":
            val digit = char_to_digit(ch)
            result = result * 10 + digit
        else:
            break

    result * sign

# Helper to convert char to digit
fn char_to_digit(ch: text) -> i64:
    if ch == "0": 0
    else if ch == "1": 1
    else if ch == "2": 2
    else if ch == "3": 3
    else if ch == "4": 4
    else if ch == "5": 5
    else if ch == "6": 6
    else if ch == "7": 7
    else if ch == "8": 8
    else if ch == "9": 9
    else: 0
