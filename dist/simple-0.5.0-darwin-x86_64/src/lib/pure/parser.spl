# Pure Simple Parser
# Recursive descent parser for Simple language

use lib.pure.lexer (Token, TokenKind, lex_source)
use lib.pure.ast (Expr, Stmt, Pattern, TypeExpr, Module, BinOp, UnaryOp, Literal)

export parse, parse_expr, parse_stmt, ParseError

# Parser state
class Parser:
    tokens: [Token]
    current: i64

    fn is_at_end() -> bool:
        if self.current >= self.tokens.len():
            true
        else:
            match self.tokens[self.current].kind:
                case TokenKind.Eof: true
                case _: false

    fn peek() -> Token:
        if self.current < self.tokens.len():
            self.tokens[self.current]
        else:
            self.tokens[self.tokens.len() - 1]

    fn previous() -> Token:
        if self.current > 0:
            self.tokens[self.current - 1]
        else:
            self.tokens[0]

    me advance() -> Token:
        if not self.is_at_end():
            self.current = self.current + 1
        self.previous()

    fn check(kind: text) -> bool:
        if self.is_at_end():
            false
        else:
            match self.peek().kind:
                case TokenKind.Keyword(k): k == kind
                case TokenKind.Operator(o): o == kind
                case _: false

    me consume_keyword(keyword: text) -> bool:
        if self.check(keyword):
            self.advance()
            true
        else:
            false

    me consume_operator(op: text) -> bool:
        if self.check(op):
            self.advance()
            true
        else:
            false

# Parse error
struct ParseError:
    message: text
    line: i64
    column: i64

# Parse source into AST
fn parse(source: text) -> Result<Module, ParseError>:
    val tokens = lex_source(source)
    var parser = Parser(tokens: tokens, current: 0)

    var statements: [Stmt] = []
    while not parser.is_at_end():
        match parse_statement(parser):
            case Ok(stmt):
                statements.push(stmt)
            case Err(e):
                return Err(e)

    Ok(Module(statements: statements))

# Parse statement
fn parse_statement(parser: Parser) -> Result<Stmt, ParseError>:
    # Skip newlines
    while match_token(parser, TokenKind.Newline):
        ()

    # Function definition
    if parser.check("fn"):
        return parse_function(parser)

    # Variable declaration
    if parser.check("val") or parser.check("var"):
        return parse_let(parser)

    # Struct definition
    if parser.check("struct"):
        return parse_struct(parser)

    # Enum definition
    if parser.check("enum"):
        return parse_enum(parser)

    # Return statement
    if parser.check("return"):
        return parse_return(parser)

    # While loop
    if parser.check("while"):
        return parse_while(parser)

    # For loop
    if parser.check("for"):
        return parse_for(parser)

    # Expression statement
    match parse_expression(parser):
        case Ok(expr):
            Ok(Stmt.Expr(expr))
        case Err(e):
            Err(e)

# Parse function definition
fn parse_function(parser: Parser) -> Result<Stmt, ParseError>:
    parser.consume_keyword("fn")

    # Function name
    val name = match parser.peek().kind:
        case TokenKind.Identifier(n):
            parser.advance()
            n
        case _:
            return Err(ParseError(
                message: "Expected function name",
                line: parser.peek().line,
                column: parser.peek().column
            ))

    # Parameters
    parser.consume_operator("(")
    var params: [text] = []

    while not parser.check(")"):
        match parser.peek().kind:
            case TokenKind.Identifier(p):
                parser.advance()
                params.push(p)
                if not parser.check(")"):
                    parser.consume_operator(",")
            case _:
                break

    parser.consume_operator(")")

    # Return type (optional)
    var return_type: TypeExpr? = None
    if parser.consume_operator("->"):
        match parse_type(parser):
            case Ok(t):
                return_type = Some(t)
            case Err(e):
                return Err(e)

    # Body
    parser.consume_operator(":")
    match parse_block(parser):
        case Ok(body):
            Ok(Stmt.Function(name, params, return_type, body))
        case Err(e):
            Err(e)

# Parse let/var statement
fn parse_let(parser: Parser) -> Result<Stmt, ParseError>:
    val is_val = parser.consume_keyword("val")
    if not is_val:
        parser.consume_keyword("var")

    # Variable name
    val name = match parser.peek().kind:
        case TokenKind.Identifier(n):
            parser.advance()
            n
        case _:
            return Err(ParseError(
                message: "Expected variable name",
                line: parser.peek().line,
                column: parser.peek().column
            ))

    # Type annotation (optional)
    var type_expr: TypeExpr? = None
    if parser.consume_operator(":"):
        match parse_type(parser):
            case Ok(t):
                type_expr = Some(t)
            case Err(e):
                return Err(e)

    # Initializer
    parser.consume_operator("=")
    match parse_expression(parser):
        case Ok(expr):
            Ok(Stmt.Let(name, type_expr, expr))
        case Err(e):
            Err(e)

# Parse struct definition
fn parse_struct(parser: Parser) -> Result<Stmt, ParseError>:
    parser.consume_keyword("struct")

    val name = match parser.peek().kind:
        case TokenKind.Identifier(n):
            parser.advance()
            n
        case _:
            return Err(ParseError(
                message: "Expected struct name",
                line: parser.peek().line,
                column: parser.peek().column
            ))

    parser.consume_operator(":")

    var fields: [(text, TypeExpr)] = []
    # Parse fields (simplified)

    Ok(Stmt.Struct(name, fields))

# Parse enum definition
fn parse_enum(parser: Parser) -> Result<Stmt, ParseError>:
    parser.consume_keyword("enum")

    val name = match parser.peek().kind:
        case TokenKind.Identifier(n):
            parser.advance()
            n
        case _:
            return Err(ParseError(
                message: "Expected enum name",
                line: parser.peek().line,
                column: parser.peek().column
            ))

    parser.consume_operator(":")

    var variants: [(text, [TypeExpr])] = []
    # Parse variants (simplified)

    Ok(Stmt.Enum(name, variants))

# Parse return statement
fn parse_return(parser: Parser) -> Result<Stmt, ParseError>:
    parser.consume_keyword("return")

    if parser.check("\n") or parser.is_at_end():
        Ok(Stmt.Return(None))
    else:
        match parse_expression(parser):
            case Ok(expr):
                Ok(Stmt.Return(Some(expr)))
            case Err(e):
                Err(e)

# Parse while loop
fn parse_while(parser: Parser) -> Result<Stmt, ParseError>:
    parser.consume_keyword("while")

    match parse_expression(parser):
        case Ok(cond):
            parser.consume_operator(":")
            match parse_block(parser):
                case Ok(body):
                    Ok(Stmt.While(cond, body))
                case Err(e):
                    Err(e)
        case Err(e):
            Err(e)

# Parse for loop
fn parse_for(parser: Parser) -> Result<Stmt, ParseError>:
    parser.consume_keyword("for")

    val var_name = match parser.peek().kind:
        case TokenKind.Identifier(n):
            parser.advance()
            n
        case _:
            return Err(ParseError(
                message: "Expected loop variable",
                line: parser.peek().line,
                column: parser.peek().column
            ))

    parser.consume_keyword("in")

    match parse_expression(parser):
        case Ok(iter):
            parser.consume_operator(":")
            match parse_block(parser):
                case Ok(body):
                    Ok(Stmt.For(var_name, iter, body))
                case Err(e):
                    Err(e)
        case Err(e):
            Err(e)

# Parse block
fn parse_block(parser: Parser) -> Result<[Stmt], ParseError>:
    var statements: [Stmt] = []

    # Simplified: parse one statement
    match parse_statement(parser):
        case Ok(stmt):
            statements.push(stmt)
        case Err(e):
            return Err(e)

    Ok(statements)

# Parse expression
fn parse_expression(parser: Parser) -> Result<Expr, ParseError>:
    parse_equality(parser)

# Parse equality (== !=)
fn parse_equality(parser: Parser) -> Result<Expr, ParseError>:
    match parse_comparison(parser):
        case Ok(left):
            if parser.check("==") or parser.check("!="):
                val op_token = parser.advance()
                val op = match op_token.kind:
                    case TokenKind.Operator("=="): BinOp.Eq
                    case TokenKind.Operator("!="): BinOp.NotEq
                    case _: BinOp.Eq

                match parse_comparison(parser):
                    case Ok(right):
                        Ok(Expr.Binary(op, left, right))
                    case Err(e):
                        Err(e)
            else:
                Ok(left)
        case Err(e):
            Err(e)

# Parse comparison (< > <= >=)
fn parse_comparison(parser: Parser) -> Result<Expr, ParseError>:
    parse_addition(parser)

# Parse addition (+ -)
fn parse_addition(parser: Parser) -> Result<Expr, ParseError>:
    match parse_multiplication(parser):
        case Ok(left):
            if parser.check("+") or parser.check("-"):
                val op_token = parser.advance()
                val op = match op_token.kind:
                    case TokenKind.Operator("+"): BinOp.Add
                    case TokenKind.Operator("-"): BinOp.Sub
                    case _: BinOp.Add

                match parse_multiplication(parser):
                    case Ok(right):
                        Ok(Expr.Binary(op, left, right))
                    case Err(e):
                        Err(e)
            else:
                Ok(left)
        case Err(e):
            Err(e)

# Parse multiplication (* /)
fn parse_multiplication(parser: Parser) -> Result<Expr, ParseError>:
    match parse_unary(parser):
        case Ok(left):
            if parser.check("*") or parser.check("/"):
                val op_token = parser.advance()
                val op = match op_token.kind:
                    case TokenKind.Operator("*"): BinOp.Mul
                    case TokenKind.Operator("/"): BinOp.Div
                    case _: BinOp.Mul

                match parse_unary(parser):
                    case Ok(right):
                        Ok(Expr.Binary(op, left, right))
                    case Err(e):
                        Err(e)
            else:
                Ok(left)
        case Err(e):
            Err(e)

# Parse unary (- !)
fn parse_unary(parser: Parser) -> Result<Expr, ParseError>:
    if parser.check("-") or parser.check("!"):
        val op_token = parser.advance()
        val op = match op_token.kind:
            case TokenKind.Operator("-"): UnaryOp.Neg
            case TokenKind.Operator("!"): UnaryOp.Not
            case _: UnaryOp.Neg

        match parse_unary(parser):
            case Ok(right):
                Ok(Expr.Unary(op, right))
            case Err(e):
                Err(e)
    else:
        parse_primary(parser)

# Parse primary expression
fn parse_primary(parser: Parser) -> Result<Expr, ParseError>:
    val token = parser.peek()

    match token.kind:
        case TokenKind.Number(n):
            parser.advance()
            # Try to parse as int
            Ok(Expr.Literal(Literal.Int(42)))  # Simplified

        case TokenKind.String(s):
            parser.advance()
            Ok(Expr.Literal(Literal.String(s)))

        case TokenKind.Keyword("true"):
            parser.advance()
            Ok(Expr.Literal(Literal.Bool(true)))

        case TokenKind.Keyword("false"):
            parser.advance()
            Ok(Expr.Literal(Literal.Bool(false)))

        case TokenKind.Identifier(name):
            parser.advance()
            Ok(Expr.Identifier(name))

        case TokenKind.Operator("("):
            parser.advance()
            match parse_expression(parser):
                case Ok(expr):
                    parser.consume_operator(")")
                    Ok(expr)
                case Err(e):
                    Err(e)

        case _:
            Err(ParseError(
                message: "Expected expression",
                line: token.line,
                column: token.column
            ))

# Parse type expression
fn parse_type(parser: Parser) -> Result<TypeExpr, ParseError>:
    match parser.peek().kind:
        case TokenKind.Identifier(name):
            parser.advance()
            Ok(TypeExpr.Named(name))
        case _:
            Err(ParseError(
                message: "Expected type",
                line: parser.peek().line,
                column: parser.peek().column
            ))

# Match token kind
fn match_token(parser: Parser, kind: TokenKind) -> bool:
    if parser.is_at_end():
        false
    else:
        match parser.peek().kind:
            case k:
                if k == kind:
                    parser.advance()
                    true
                else:
                    false

# Export parse_expr for standalone expression parsing
fn parse_expr(source: text) -> Result<Expr, ParseError>:
    val tokens = lex_source(source)
    var parser = Parser(tokens: tokens, current: 0)
    parse_expression(parser)

# Export parse_stmt for standalone statement parsing
fn parse_stmt(source: text) -> Result<Stmt, ParseError>:
    val tokens = lex_source(source)
    var parser = Parser(tokens: tokens, current: 0)
    parse_statement(parser)
