# Tensor Factory - Workaround for interpreter limitations
#
# Provides factory functions for creating tensors without using
# static methods on generic types, which the interpreter doesn't support yet.
#
# TODO: Remove this file once interpreter supports:
# - Static methods on generic classes (PureTensor<T>.from_data)
# - Direct construction of generic classes (PureTensor(...))

use lib.pure.tensor (PureTensor, compute_strides)

fn from_data_f64(data: [f64], shape: [i64]) -> PureTensor<f64>:
    """Create f64 tensor from data array."""
    PureTensor(data: data, shape: shape, strides: compute_strides(shape))

fn from_data_i64(data: [i64], shape: [i64]) -> PureTensor<i64>:
    """Create i64 tensor from data array."""
    PureTensor(data: data, shape: shape, strides: compute_strides(shape))

fn zeros(shape: [i64]) -> PureTensor<f64>:
    """Create tensor filled with zeros."""
    var numel = 1
    for dim in shape:
        numel = numel * dim
    var data: [f64] = []
    var i = 0
    while i < numel:
        data.push(0.0)
        i = i + 1
    PureTensor(data: data, shape: shape, strides: compute_strides(shape))

fn ones(shape: [i64]) -> PureTensor<f64>:
    """Create tensor filled with ones."""
    var numel = 1
    for dim in shape:
        numel = numel * dim
    var data: [f64] = []
    var i = 0
    while i < numel:
        data.push(1.0)
        i = i + 1
    PureTensor(data: data, shape: shape, strides: compute_strides(shape))

fn randn(shape: [i64]) -> PureTensor<f64>:
    """Create tensor with random values."""
    var numel = 1
    for dim in shape:
        numel = numel * dim
    var data: [f64] = []
    var i = 0
    while i < numel:
        val rand = ((i * 2654435761) % 1000000) / 1000000.0
        data.push(rand - 0.5)
        i = i + 1
    PureTensor(data: data, shape: shape, strides: compute_strides(shape))

export from_data_f64, from_data_i64, zeros, ones, randn
