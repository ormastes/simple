# Semantic Diff
#
# Compares two versions of a module's API surface to detect
# breaking changes, additions, removals, and modifications.
# Used for incremental compilation and API compatibility checking.
#
# Port of rust/compiler/src/semantic_diff.rs (770 lines)

export ChangeKind, ImpactLevel, SemanticChange, DiffSummary
export SemanticDiffer, SymbolInfo

# ============================================================================
# Types
# ============================================================================

enum ChangeKind:
    Added
    Removed
    TypeChanged
    SignatureChanged
    VisibilityChanged
    DefaultValueChanged
    ReturnTypeChanged
    ParamAdded
    ParamRemoved
    ParamTypeChanged
    ParamRenamed
    FieldAdded
    FieldRemoved
    FieldTypeChanged
    VariantAdded
    VariantRemoved
    ImplementationChanged
    DocChanged

enum ImpactLevel:
    Breaking     # Requires dependents to recompile and possibly change code
    Major        # Requires dependents to recompile
    Minor        # No action needed for dependents
    Info         # Informational only (doc changes, etc.)

impl ImpactLevel:
    fn is_breaking() -> bool:
        match self:
            case Breaking: true
            case _: false

fn change_impact(kind: ChangeKind) -> ImpactLevel:
    match kind:
        case Removed: ImpactLevel.Breaking
        case TypeChanged: ImpactLevel.Breaking
        case SignatureChanged: ImpactLevel.Breaking
        case ReturnTypeChanged: ImpactLevel.Breaking
        case ParamRemoved: ImpactLevel.Breaking
        case ParamTypeChanged: ImpactLevel.Breaking
        case FieldRemoved: ImpactLevel.Breaking
        case FieldTypeChanged: ImpactLevel.Breaking
        case VariantRemoved: ImpactLevel.Breaking
        case VisibilityChanged: ImpactLevel.Major
        case Added: ImpactLevel.Minor
        case DefaultValueChanged: ImpactLevel.Minor
        case ParamAdded: ImpactLevel.Minor
        case ParamRenamed: ImpactLevel.Minor
        case FieldAdded: ImpactLevel.Minor
        case VariantAdded: ImpactLevel.Minor
        case ImplementationChanged: ImpactLevel.Minor
        case DocChanged: ImpactLevel.Info

# ============================================================================
# Symbol Info
# ============================================================================

struct SymbolInfo:
    name: text
    kind: text           # "function", "struct", "class", "enum", "trait"
    visibility: text     # "public", "private", "internal"
    signature: text?     # For functions: full signature text
    fields: [text]       # For structs/classes: field names
    variants: [text]     # For enums: variant names
    return_type: text?
    param_names: [text]
    param_types: [text]

# ============================================================================
# Semantic Change
# ============================================================================

struct SemanticChange:
    symbol: text
    kind: ChangeKind
    impact: ImpactLevel
    old_value: text?
    new_value: text?
    message: text

impl SemanticChange:
    fn requires_recompile() -> bool:
        match self.impact:
            case Breaking: true
            case Major: true
            case _: false

# ============================================================================
# Diff Summary
# ============================================================================

struct DiffSummary:
    changes: [SemanticChange]
    breaking_count: i64
    major_count: i64
    minor_count: i64
    info_count: i64

impl DiffSummary:
    static fn from_changes(changes: [SemanticChange]) -> DiffSummary:
        var breaking = 0
        var major = 0
        var minor = 0
        var info = 0
        for c in changes:
            match c.impact:
                case Breaking: breaking = breaking + 1
                case Major: major = major + 1
                case Minor: minor = minor + 1
                case Info: info = info + 1
        DiffSummary(changes: changes, breaking_count: breaking,
                     major_count: major, minor_count: minor, info_count: info)

    fn has_breaking_changes() -> bool:
        self.breaking_count > 0

    fn requires_recompile() -> bool:
        self.breaking_count > 0 or self.major_count > 0

# ============================================================================
# Semantic Differ
# ============================================================================

class SemanticDiffer:
    """Compares two versions of symbols to produce semantic diff."""
    changes: [SemanticChange]

impl SemanticDiffer:
    static fn create() -> SemanticDiffer:
        SemanticDiffer(changes: [])

    me diff_symbols(old_symbols: [SymbolInfo], new_symbols: [SymbolInfo]):
        """Compare old and new symbol lists."""
        val old_names = old_symbols.map(\s: s.name)
        val new_names = new_symbols.map(\s: s.name)

        # Detect removals
        for old in old_symbols:
            if not new_names.contains(old.name):
                self.add_change(old.name, ChangeKind.Removed, ImpactLevel.Breaking,
                    Some(old.kind), nil, "symbol '{old.name}' was removed")

        # Detect additions
        for new_sym in new_symbols:
            if not old_names.contains(new_sym.name):
                self.add_change(new_sym.name, ChangeKind.Added, ImpactLevel.Minor,
                    nil, Some(new_sym.kind), "symbol '{new_sym.name}' was added")

        # Detect modifications
        for old in old_symbols:
            for new_sym in new_symbols:
                if old.name == new_sym.name:
                    self.diff_symbol(old, new_sym)

    me diff_symbol(old: SymbolInfo, new_sym: SymbolInfo):
        """Compare two versions of the same symbol."""
        # Visibility change
        if old.visibility != new_sym.visibility:
            self.add_change(old.name, ChangeKind.VisibilityChanged, ImpactLevel.Major,
                Some(old.visibility), Some(new_sym.visibility),
                "visibility changed from '{old.visibility}' to '{new_sym.visibility}'")

        # Return type change
        if old.return_type != new_sym.return_type:
            self.add_change(old.name, ChangeKind.ReturnTypeChanged, ImpactLevel.Breaking,
                old.return_type, new_sym.return_type,
                "return type changed")

        # Parameter changes
        self.diff_params(old.name, old.param_names, old.param_types,
                         new_sym.param_names, new_sym.param_types)

        # Field changes (structs/classes)
        self.diff_fields(old.name, old.fields, new_sym.fields)

        # Variant changes (enums)
        self.diff_variants(old.name, old.variants, new_sym.variants)

    me diff_params(name: text, old_names: [text], old_types: [text],
                    new_names: [text], new_types: [text]):
        if old_names.len() > new_names.len():
            self.add_change(name, ChangeKind.ParamRemoved, ImpactLevel.Breaking,
                nil, nil, "parameter removed")
        elif new_names.len() > old_names.len():
            self.add_change(name, ChangeKind.ParamAdded, ImpactLevel.Minor,
                nil, nil, "parameter added")

        val min_len = if old_names.len() < new_names.len(): old_names.len() else: new_names.len()
        for i in 0..min_len:
            if old_types.len() > i and new_types.len() > i:
                if old_types[i] != new_types[i]:
                    self.add_change(name, ChangeKind.ParamTypeChanged, ImpactLevel.Breaking,
                        Some(old_types[i]), Some(new_types[i]),
                        "parameter type changed at position {i}")

    me diff_fields(name: text, old_fields: [text], new_fields: [text]):
        for f in old_fields:
            if not new_fields.contains(f):
                self.add_change(name, ChangeKind.FieldRemoved, ImpactLevel.Breaking,
                    Some(f), nil, "field '{f}' removed")
        for f in new_fields:
            if not old_fields.contains(f):
                self.add_change(name, ChangeKind.FieldAdded, ImpactLevel.Minor,
                    nil, Some(f), "field '{f}' added")

    me diff_variants(name: text, old_variants: [text], new_variants: [text]):
        for v in old_variants:
            if not new_variants.contains(v):
                self.add_change(name, ChangeKind.VariantRemoved, ImpactLevel.Breaking,
                    Some(v), nil, "variant '{v}' removed")
        for v in new_variants:
            if not old_variants.contains(v):
                self.add_change(name, ChangeKind.VariantAdded, ImpactLevel.Minor,
                    nil, Some(v), "variant '{v}' added")

    me add_change(symbol: text, kind: ChangeKind, impact: ImpactLevel,
                   old_value: text?, new_value: text?, message: text):
        self.changes = self.changes.push(
            SemanticChange(symbol: symbol, kind: kind, impact: impact,
                           old_value: old_value, new_value: new_value, message: message))

    fn summary() -> DiffSummary:
        DiffSummary.from_changes(self.changes)
