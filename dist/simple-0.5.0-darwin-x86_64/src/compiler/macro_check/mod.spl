# Macro Type Checking
#
# Complete macro type checking system with:
# - Hygiene: Prevents accidental name capture during expansion
# - Template validation: Ensures macro templates are well-formed
# - Type checking: Validates types flow correctly through macros
#
# Architecture:
# - hygiene.spl: Hygienic macro expansion with syntax marks
# - template.spl: Template pattern validation
# - mod.spl: Integration and main API
#
# Usage:
#   val checker = MacroChecker.create()
#   checker.define_macro("log!", matcher, transcriber)
#   val result = checker.check_call("log!", args)

use compiler.macro_check.hygiene.*
use compiler.macro_check.template.*
use compiler.hir_types.*

# ============================================================================
# Macro Definition
# ============================================================================

struct MacroRule:
    """A single macro rule (pattern => expansion)."""
    matcher: [TemplateToken]
    transcriber: [TemplateToken]
    expansion_type: text?

impl MacroRule:
    static fn create(matcher: [TemplateToken], transcriber: [TemplateToken]) -> MacroRule:
        MacroRule(
            matcher: matcher,
            transcriber: transcriber,
            expansion_type: nil
        )

class MacroDef:
    """Complete macro definition with rules."""
    name: text
    rules: [MacroRule]
    is_hygienic: bool
    export_level: i64  # 0 = private, 1 = crate, 2 = public

    static fn create(name: text) -> MacroDef:
        MacroDef(
            name: name,
            rules: [],
            is_hygienic: true,
            export_level: 0
        )

    me add_rule(rule: MacroRule):
        """Add a rule to this macro."""
        self.rules = self.rules.push(rule)

    me set_unhygienic():
        """Mark this macro as unhygienic (advanced use)."""
        self.is_hygienic = false

    me set_export(level: i64):
        """Set export level."""
        self.export_level = level

# ============================================================================
# Macro Call
# ============================================================================

struct MacroArg:
    """Argument in a macro call."""
    tokens: [TemplateToken]
    span: i64?

struct MacroCall:
    """A macro invocation."""
    name: text
    args: [MacroArg]
    span: i64?

impl MacroCall:
    static fn create(name: text, args: [MacroArg]) -> MacroCall:
        MacroCall(name: name, args: args, span: nil)

# ============================================================================
# Type Check Result
# ============================================================================

enum MacroCheckResult:
    """Result of macro type checking."""
    Ok(expansion_type: text)
    UndefinedMacro(name: text)
    NoMatchingRule(name: text, args: [MacroArg])
    TypeError(message: text)
    HygieneError(message: text)
    TemplateError(errors: [TemplateError])

impl MacroCheckResult:
    fn is_ok() -> bool:
        match self:
            case Ok(_): true
            case _: false

    fn get_type() -> text?:
        match self:
            case Ok(ty): Some(ty)
            case _: None

    fn get_error() -> text?:
        match self:
            case UndefinedMacro(name): Some("Undefined macro: {name}")
            case NoMatchingRule(name, _): Some("No matching rule for macro: {name}")
            case TypeError(msg): Some("Type error: {msg}")
            case HygieneError(msg): Some("Hygiene error: {msg}")
            case TemplateError(errors):
                if errors.len() > 0:
                    Some("Template error: {errors[0].message}")
                else:
                    Some("Template error")
            case _: None

# ============================================================================
# Macro Checker
# ============================================================================

class MacroChecker:
    """Main macro type checking interface.

    Handles:
    - Macro definition registration
    - Macro call type checking
    - Hygiene enforcement
    - Template validation
    """
    macros: Dict<text, MacroDef>
    hygiene: HygieneTransformer
    template_checker: TemplateTypeChecker
    errors: [text]

    static fn create() -> MacroChecker:
        MacroChecker(
            macros: {},
            hygiene: HygieneTransformer.create(),
            template_checker: TemplateTypeChecker.create(),
            errors: []
        )

    me define_macro(name: text, rules: [MacroRule]) -> bool:
        """Register a macro definition.

        Returns false if validation fails.
        """
        # Validate each rule
        for rule in rules:
            val validator = TemplateValidator.create()

            if not validator.validate_matcher(rule.matcher):
                for err in validator.get_errors():
                    self.errors = self.errors.push("In macro '{name}': {err.message}")
                return false

            if not validator.validate_transcriber(rule.transcriber):
                for err in validator.get_errors():
                    self.errors = self.errors.push("In macro '{name}': {err.message}")
                return false

        # Create and store definition
        var def = MacroDef.create(name)
        for rule in rules:
            def.add_rule(rule)

        self.macros[name] = def
        true

    me check_call(call: MacroCall) -> MacroCheckResult:
        """Type check a macro call.

        Matches arguments against rules and infers expansion type.
        """
        # Look up macro
        match self.macros.get(call.name):
            case None:
                return MacroCheckResult.UndefinedMacro(call.name)

            case Some(def):
                # Try to match rules
                for rule in def.rules:
                    match self.try_match_rule(rule, call.args, def.is_hygienic):
                        case Some(expansion_type):
                            return MacroCheckResult.Ok(expansion_type)
                        case None:
                            pass  # Try next rule

                MacroCheckResult.NoMatchingRule(call.name, call.args)

    me try_match_rule(rule: MacroRule, args: [MacroArg], is_hygienic: bool) -> text?:
        """Try to match arguments against a rule.

        Returns expansion type if match succeeds.
        """
        # Simple matching: check arg count matches expected params
        val validator = TemplateValidator.create()
        validator.validate_matcher(rule.matcher)

        val expected_params = validator.params.len()
        if args.len() != expected_params:
            return nil

        # If hygienic, set up expansion context
        if is_hygienic:
            val mark = self.hygiene.start_expansion()
            # Would mark all identifiers in expansion
            self.hygiene.end_expansion()

        # Infer expansion type
        val type_checker = TemplateTypeChecker.create()
        type_checker.check_rule(rule.matcher, rule.transcriber)
        type_checker.infer_expansion_type(rule.transcriber)

    me check_hygiene(call: MacroCall) -> text?:
        """Check for hygiene violations in a macro call.

        Returns error message if violation detected.
        """
        # Check each argument for potential capture
        for arg in call.args:
            for token in arg.tokens:
                match token:
                    case Param(name, _):
                        match self.hygiene.check_hygiene_violation(name):
                            case Some(err):
                                return Some(err)
                            case None:
                                pass
                    case _:
                        pass
        nil

    fn get_macro(name: text) -> MacroDef?:
        """Get a macro definition."""
        self.macros.get(name)

    fn list_macros() -> [text]:
        """List all registered macros."""
        var names: [text] = []
        for name, _ in self.macros:
            names = names.push(name)
        names

    fn get_errors() -> [text]:
        """Get all accumulated errors."""
        self.errors

# ============================================================================
# Integration with HIR
# ============================================================================

fn check_macro_in_hir(checker: MacroChecker, expr: HirExpr) -> MacroCheckResult:
    """Check a macro call in HIR context.

    Extracts macro call from HIR expression and type checks it.
    """
    match expr.kind:
        case MacroCall(name, args):
            # Convert HIR args to MacroArgs
            var macro_args: [MacroArg] = []
            for arg in args:
                # Convert HirExpr to tokens (simplified)
                val tokens: [TemplateToken] = [TemplateToken.Literal(text: "arg")]
                macro_args = macro_args.push(MacroArg(tokens: tokens, span: nil))

            val call = MacroCall.create(name, macro_args)
            checker.check_call(call)

        case _:
            MacroCheckResult.TypeError("Not a macro call")

# ============================================================================
# Exports
# ============================================================================

# Re-export from submodules
export SyntaxMark, MarkedIdent from hygiene
export ScopeKind, HygieneScope from hygiene
export HygieneContext, HygieneTransformer from hygiene

export FragmentKind, TemplateToken, RepetitionKind from template
export TemplateParam, TemplateError from template
export TemplateValidator, TemplateTypeChecker from template

# Export this module's types
export MacroRule, MacroDef
export MacroArg, MacroCall
export MacroCheckResult
export MacroChecker
export check_macro_in_hir
