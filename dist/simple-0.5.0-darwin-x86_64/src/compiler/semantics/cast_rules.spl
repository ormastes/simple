# Cast Rules
#
# Unified cast rules for interpreter and codegen.
# This module provides a single source of truth for type casting semantics
# that must be consistent between the interpreter and compiled code.
#
# Port of rust/compiler/src/semantics/cast_rules.rs (264 lines)

export NumericType, CastNumericResult
export cast_int_to_numeric, cast_float_to_numeric, cast_bool_to_numeric
export BoolCast, StringCast

# ============================================================================
# Numeric Type Categories
# ============================================================================

enum NumericType:
    I8
    I16
    I32
    I64
    U8
    U16
    U32
    U64
    F32
    F64

impl NumericType:
    static fn from_name(name: text) -> NumericType?:
        """Parse a type name into a NumericType."""
        match name:
            case "i8": Some(NumericType.I8)
            case "i16": Some(NumericType.I16)
            case "i32": Some(NumericType.I32)
            case "i64": Some(NumericType.I64)
            case "int": Some(NumericType.I64)
            case "u8": Some(NumericType.U8)
            case "u16": Some(NumericType.U16)
            case "u32": Some(NumericType.U32)
            case "u64": Some(NumericType.U64)
            case "f32": Some(NumericType.F32)
            case "f64": Some(NumericType.F64)
            case "float": Some(NumericType.F64)
            case _: None

    fn name() -> text:
        """Get the type name."""
        match self:
            case I8: "i8"
            case I16: "i16"
            case I32: "i32"
            case I64: "i64"
            case U8: "u8"
            case U16: "u16"
            case U32: "u32"
            case U64: "u64"
            case F32: "f32"
            case F64: "f64"

    fn is_float() -> bool:
        """Check if this is a floating point type."""
        self in [NumericType.F32, NumericType.F64]

    fn is_signed() -> bool:
        """Check if this is a signed integer type."""
        self in [NumericType.I8, NumericType.I16, NumericType.I32, NumericType.I64]

    fn is_unsigned() -> bool:
        """Check if this is an unsigned integer type."""
        self in [NumericType.U8, NumericType.U16, NumericType.U32, NumericType.U64]

    fn is_integer() -> bool:
        """Check if this is any integer type."""
        not self.is_float()

# ============================================================================
# Cast Result
# ============================================================================

enum CastNumericResult:
    Int(i64)
    Float(f64)

# ============================================================================
# Cast Functions
# ============================================================================

fn cast_int_to_numeric(value: i64, target: NumericType) -> CastNumericResult:
    """Cast an i64 to a target numeric type, returning the result as i64 or f64.

    This handles truncation and sign extension according to Simple's semantics.

    CRITICAL: Truncation semantics must be preserved exactly.
    Example: 300 as i8 as i64 = 44 (wraps around)
    Example: -1 as u8 as i64 = 255 (wraps around)
    """
    match target:
        # Signed integers (truncation + sign extension)
        case I8: CastNumericResult.Int(value as i8 as i64)
        case I16: CastNumericResult.Int(value as i16 as i64)
        case I32: CastNumericResult.Int(value as i32 as i64)
        case I64: CastNumericResult.Int(value)
        # Unsigned integers (truncation + zero extension)
        case U8: CastNumericResult.Int(value as u8 as i64)
        case U16: CastNumericResult.Int(value as u16 as i64)
        case U32: CastNumericResult.Int(value as u32 as i64)
        case U64: CastNumericResult.Int(value as u64 as i64)
        # Floats (int to float conversion)
        case F32: CastNumericResult.Float(value as f32 as f64)
        case F64: CastNumericResult.Float(value as f64)

fn cast_float_to_numeric(value: f64, target: NumericType) -> CastNumericResult:
    """Cast an f64 to a target numeric type.

    CRITICAL: Float to int truncates (rounds toward zero).
    CRITICAL: Float to smaller float may lose precision.
    """
    match target:
        # Signed integers (truncation)
        case I8: CastNumericResult.Int(value as i8 as i64)
        case I16: CastNumericResult.Int(value as i16 as i64)
        case I32: CastNumericResult.Int(value as i32 as i64)
        case I64: CastNumericResult.Int(value as i64)
        # Unsigned integers (truncation)
        case U8: CastNumericResult.Int(value as u8 as i64)
        case U16: CastNumericResult.Int(value as u16 as i64)
        case U32: CastNumericResult.Int(value as u32 as i64)
        case U64: CastNumericResult.Int(value as u64 as i64)
        # Floats (precision loss possible)
        case F32: CastNumericResult.Float(value as f32 as f64)
        case F64: CastNumericResult.Float(value)

fn cast_bool_to_numeric(value: bool, target: NumericType) -> CastNumericResult:
    """Cast a bool to a target numeric type.

    true → 1 or 1.0
    false → 0 or 0.0
    """
    if target.is_float():
        CastNumericResult.Float(if value: 1.0 else: 0.0)
    else:
        CastNumericResult.Int(if value: 1 else: 0)

# ============================================================================
# Bool Cast Rules
# ============================================================================

struct BoolCast

impl BoolCast:
    static fn from_int(i: i64) -> bool:
        """Convert an integer to bool: non-zero is true."""
        i != 0

    static fn from_float(f: f64) -> bool:
        """Convert a float to bool: non-zero is true."""
        f != 0.0

    static fn from_str(s: text) -> bool:
        """Convert a string to bool: non-empty is true."""
        not s.is_empty()

# ============================================================================
# String Cast Rules
# ============================================================================

struct StringCast

impl StringCast:
    static fn from_int(i: i64) -> text:
        """Convert an integer to string."""
        i.to_string()

    static fn from_float(f: f64) -> text:
        """Convert a float to string."""
        f.to_string()

    static fn from_bool(b: bool) -> text:
        """Convert a bool to string."""
        b.to_string()
