#!/usr/bin/env bin/simple
# GOT/PLT Full Workflow Demonstration
#
# This demonstrates the complete GOT/PLT support for native x86_64 backend:
# 1. Create builder and add external symbols
# 2. Generate GOT and PLT section data
# 3. Create ELF sections
# 4. Build complete ELF object file
# 5. Verify output

use compiler.backend.native.got_plt_builder.{GotPltBuilder, create_got_section_data, create_plt_section_data}
use compiler.backend.native.elf_writer.{
    elf_writer_x86_64, elf_add_section, elf_add_symbol,
    new_text_section, new_got_section, new_plt_section,
    new_extern_symbol, new_func_symbol,
    write_elf64
}

print "═══════════════════════════════════════════════════════════"
print "  GOT/PLT Support - Native x86_64 Backend Demo"
print "═══════════════════════════════════════════════════════════\n"

# ============================================================================
# Step 1: Build GOT/PLT for external libc functions
# ============================================================================

print "Step 1: Building GOT/PLT entries"
print "─────────────────────────────────\n"

var builder = GotPltBuilder(
    got_entries: [],
    plt_entries: [],
    got_size: 0,
    plt_size: 0,
    next_got_offset: 0,
    next_plt_index: 0
)

# Add common libc functions that a Simple program might call
val syms = ["printf", "malloc", "free", "memcpy", "strlen", "exit"]
var indices: [i64] = []

for sym in syms:
    val idx = builder.add_symbol(sym)
    indices = indices + [idx]
    print "  [{idx}] {sym} @ GOT offset {idx * 8}"

print "\n  Total: {builder.get_plt_entries().len()} symbols"
print "  GOT size: {builder.get_got_size()} bytes"
print "  PLT size: {builder.get_plt_size()} bytes (entries only)\n"

# ============================================================================
# Step 2: Generate section data
# ============================================================================

print "Step 2: Generating section data"
print "────────────────────────────────\n"

val got_data = create_got_section_data(builder)
val plt_data = create_plt_section_data(builder)

print "  .got section: {got_data.len()} bytes"
print "    → {builder.get_got_entries().len()} entries × 8 bytes = {builder.get_got_entries().len() * 8} bytes"
print "    → All zeros (filled by dynamic linker)\n"

print "  .plt section: {plt_data.len()} bytes"
print "    → PLT[0] (resolver): 16 bytes"
print "    → {builder.get_plt_entries().len()} entries × 16 bytes = {builder.get_plt_entries().len() * 16} bytes"
print "    → Total: {16 + builder.get_plt_entries().len() * 16} bytes\n"

# ============================================================================
# Step 3: Build ELF object file
# ============================================================================

print "Step 3: Building ELF object file"
print "─────────────────────────────────\n"

var elf = elf_writer_x86_64()

# Add minimal .text section (just a simple function that calls printf)
# This is a stub - real compiler would generate actual code
val text_code = [
    0x55,                      # push %rbp
    0x48, 0x89, 0xe5,          # mov %rsp,%rbp
    0xb8, 0x00, 0x00, 0x00, 0x00,  # mov $0x0,%eax
    0x5d,                      # pop %rbp
    0xc3                       # ret
]
elf = elf_add_section(elf, new_text_section(text_code))
print "  ✓ Added .text section ({text_code.len()} bytes)"

# Add GOT section
elf = elf_add_section(elf, new_got_section(got_data))
print "  ✓ Added .got section ({got_data.len()} bytes)"

# Add PLT section
elf = elf_add_section(elf, new_plt_section(plt_data))
print "  ✓ Added .plt section ({plt_data.len()} bytes)"

# Add symbols for external functions
for sym in syms:
    elf = elf_add_symbol(elf, new_extern_symbol(sym))
print "  ✓ Added {syms.len()} external symbols"

# Add main function symbol
elf = elf_add_symbol(elf, new_func_symbol("simple_main", 1, 0, text_code.len()))
print "  ✓ Added simple_main function symbol\n"

# ============================================================================
# Step 4: Write ELF bytes
# ============================================================================

print "Step 4: Generating ELF binary"
print "──────────────────────────────\n"

val elf_bytes = write_elf64(elf)

print "  ELF file size: {elf_bytes.len()} bytes"
print "  Magic: 0x{elf_bytes[0]:02x} {elf_bytes[1]:02x} {elf_bytes[2]:02x} {elf_bytes[3]:02x}"

# Verify ELF magic
val magic_ok = elf_bytes[0] == 0x7F and elf_bytes[1] == 0x45 and elf_bytes[2] == 0x4C and elf_bytes[3] == 0x46
if magic_ok:
    print "  ✓ Valid ELF magic number"
else:
    print "  ✗ Invalid ELF magic"

# Show ELF class (should be 64-bit)
if elf_bytes.len() >= 5:
    val elf_class = elf_bytes[4]
    if elf_class == 2:
        print "  ✓ ELF64 (64-bit)"
    else:
        print "  ✗ Not ELF64"

print ""

# ============================================================================
# Step 5: Summary
# ============================================================================

print "═══════════════════════════════════════════════════════════"
print "  Summary"
print "═══════════════════════════════════════════════════════════\n"

print "External Symbols:"
for i in 0..syms.len():
    print "  • {syms[i]}"

print "\nSection Layout:"
print "  .text  → {text_code.len()} bytes (executable code)"
print "  .got   → {got_data.len()} bytes (global offset table)"
print "  .plt   → {plt_data.len()} bytes (procedure linkage table)"
print "  Total  → {elf_bytes.len()} bytes (complete ELF object)"

print "\nRelocation Strategy:"
print "  • GOT entries: Position-independent data references"
print "  • PLT stubs:   Lazy-bindable function calls"
print "  • Each PLT entry: 16 bytes (jmpq + pushq + jmpq)"
print "  • Each GOT entry: 8 bytes (64-bit function pointer)"

print "\nDynamic Linking:"
print "  • Runtime fills GOT with actual addresses"
print "  • PLT[0] resolves to dynamic linker's resolver"
print "  • Subsequent PLT entries jump through GOT"
print "  • First call: Resolves symbol via dynamic linker"
print "  • Later calls: Direct jump through GOT (fast path)"

print "\n✓ GOT/PLT support fully functional!"
print "═══════════════════════════════════════════════════════════\n"
