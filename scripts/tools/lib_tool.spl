#!/usr/bin/env simple
# Library SMF Management Tool
#
# Command-line tool for working with .lsm library archives.
#
# Usage:
#   simple scripts/lib_tool.spl list <library.lsm>
#   simple scripts/lib_tool.spl info <library.lsm>
#   simple scripts/lib_tool.spl verify <library.lsm>
#   simple scripts/lib_tool.spl extract <library.lsm> <module_name> [--output=path]
#   simple scripts/lib_tool.spl create <output.lsm> <input1.smf> [input2.smf ...]

use compiler.linker.lib_smf_reader.{LibSmfReader}
use compiler.linker.lib_smf_writer.{LibSmfBuilder}
use compiler.linker.smf_getter.{SmfGetter}
use app.io.{file_exists, shell, file_write}

fn main():
    val args = get_args()

    if args.len() < 2:
        print_usage()
        exit(1)

    val command = args[0]

    match command:
        case "list":
            if args.len() < 2:
                print "Error: 'list' requires library path"
                exit(1)
            cmd_list(args[1])

        case "info":
            if args.len() < 2:
                print "Error: 'info' requires library path"
                exit(1)
            cmd_info(args[1])

        case "verify":
            if args.len() < 2:
                print "Error: 'verify' requires library path"
                exit(1)
            cmd_verify(args[1])

        case "extract":
            if args.len() < 3:
                print "Error: 'extract' requires library path and module name"
                exit(1)
            var output = ""
            if args.len() >= 4 and args[3].starts_with("--output="):
                output = args[3][9:]
            cmd_extract(args[1], args[2], output)

        case "create":
            if args.len() < 3:
                print "Error: 'create' requires output path and at least one input file"
                exit(1)
            val output_path = args[1]
            var inputs: [text] = []
            var i = 2
            while i < args.len():
                inputs.push(args[i])
                i = i + 1
            cmd_create(output_path, inputs)

        case "help" | "--help" | "-h":
            print_usage()

        case _:
            print "Error: Unknown command '{command}'"
            print ""
            print_usage()
            exit(1)

# ============================================================================
# Commands
# ============================================================================

fn cmd_list(library_path: text):
    """List all modules in a library."""
    if not file_exists(library_path):
        print "Error: Library not found: {library_path}"
        exit(1)

    print "Listing modules in: {library_path}"
    print ""

    # Use SmfGetter to read library
    var getter = SmfGetter.new()
    val add_result = getter.add_library(library_path)

    if add_result.is_err():
        print "Error: Could not open library: {add_result.unwrap_err()}"
        exit(1)

    val modules = getter.list_modules()

    if modules.len() == 0:
        print "  (empty library)"
    else:
        print "Modules ({modules.len()}):"
        for module_name in modules:
            print "  - {module_name}"

    print ""

fn cmd_info(library_path: text):
    """Show detailed information about a library."""
    if not file_exists(library_path):
        print "Error: Library not found: {library_path}"
        exit(1)

    print "Library Information"
    print "==================="
    print ""
    print "Path: {library_path}"

    # Get file size
    val size_result = shell("stat -f%z '{library_path}' 2>/dev/null || stat -c%s '{library_path}' 2>/dev/null")
    if size_result.exit_code == 0:
        print "Size: {size_result.stdout.trim()} bytes"

    print ""

    # Open library
    val open_result = LibSmfReader.open(library_path)
    if open_result.is_err():
        print "Error: Could not open library: {open_result.unwrap_err()}"
        exit(1)

    val reader = open_result.unwrap()

    # Get header
    val header = reader.get_header()
    val (major, minor) = header.version

    print "Format: Library SMF v{major}.{minor}"
    print "Modules: {header.module_count}"
    print ""

    # List modules
    val modules = reader.list_modules()
    if modules.len() > 0:
        print "Module List:"
        for module_name in modules:
            # Get module info
            val info_result = reader.get_module_info(module_name)
            if info_result.is_ok():
                val info = info_result.unwrap()
                print "  {module_name}"
                print "    Offset: {info.offset}"
                print "    Size: {info.size} bytes"
                print "    Hash: 0x{info.hash}"
            else:
                print "  {module_name} (info unavailable)"

    reader.close()
    print ""

fn cmd_verify(library_path: text):
    """Verify integrity of a library."""
    if not file_exists(library_path):
        print "Error: Library not found: {library_path}"
        exit(1)

    print "Verifying library: {library_path}"
    print ""

    val open_result = LibSmfReader.open(library_path)
    if open_result.is_err():
        print "✗ Failed to open library: {open_result.unwrap_err()}"
        exit(1)

    val reader = open_result.unwrap()
    val modules = reader.list_modules()

    print "Checking {modules.len()} modules..."
    var verified_count = 0
    var failed_count = 0

    for module_name in modules:
        # Try to get module (this verifies hash)
        val get_result = reader.get_module(module_name)

        if get_result.is_ok():
            print "  ✓ {module_name}"
            verified_count = verified_count + 1
        else:
            print "  ✗ {module_name}: {get_result.unwrap_err()}"
            failed_count = failed_count + 1

    reader.close()

    print ""
    print "Results:"
    print "  Verified: {verified_count}"
    print "  Failed: {failed_count}"
    print ""

    if failed_count > 0:
        print "✗ Verification failed"
        exit(1)
    else:
        print "✓ All modules verified"

fn cmd_extract(library_path: text, module_name: text, output_path: text):
    """Extract a module from a library."""
    if not file_exists(library_path):
        print "Error: Library not found: {library_path}"
        exit(1)

    var actual_output = output_path
    if actual_output == "":
        # Default output: module_name with slashes replaced
        actual_output = module_name.replace("/", "_") + ".smf"

    print "Extracting module: {module_name}"
    print "From library: {library_path}"
    print "To file: {actual_output}"
    print ""

    val open_result = LibSmfReader.open(library_path)
    if open_result.is_err():
        print "Error: Could not open library: {open_result.unwrap_err()}"
        exit(1)

    val reader = open_result.unwrap()

    # Get module
    val get_result = reader.get_module(module_name)
    if get_result.is_err():
        print "Error: Could not extract module: {get_result.unwrap_err()}"
        reader.close()
        exit(1)

    val smf_data = get_result.unwrap()

    # Write to file
    val write_ok = write_smf_to_file(actual_output, smf_data)
    if not write_ok:
        print "Error: Could not write output file"
        reader.close()
        exit(1)

    reader.close()

    print "✓ Module extracted successfully"
    print "  Size: {smf_data.len()} bytes"

fn cmd_create(output_path: text, input_paths: [text]):
    """Create a new library from SMF files."""
    print "Creating library: {output_path}"
    print "Input files: {input_paths.len()}"
    print ""

    var builder = LibSmfBuilder.new()

    for input_path in input_paths:
        if not file_exists(input_path):
            print "Warning: File not found, skipping: {input_path}"
            continue

        # Derive module name from path
        var module_name = input_path

        # Remove directories
        val last_slash = module_name.rfind("/")
        if last_slash >= 0:
            module_name = module_name[(last_slash + 1):]

        # Remove .smf extension
        if module_name.ends_with(".smf"):
            module_name = module_name[0:(module_name.len() - 4)]

        print "  Adding: {module_name} ({input_path})"

        val add_result = builder.add_module(module_name, input_path)
        if add_result.is_err():
            print "    Error: {add_result.unwrap_err()}"

    # Write library
    print ""
    print "Writing library..."
    val write_result = builder.write(output_path)

    if write_result.is_err():
        print "Error: Failed to write library: {write_result.unwrap_err()}"
        exit(1)

    print "✓ Library created successfully"
    print "  Output: {output_path}"

# ============================================================================
# Helpers
# ============================================================================

fn write_smf_to_file(path: text, data: [u8]) -> bool:
    """Write SMF bytes to file using hex encoding."""
    if data.len() == 0:
        val result = shell("touch '{path}'")
        return result.exit_code == 0

    # Convert to hex
    var hex_str = ""
    for byte in data:
        val b = byte & 0xFF
        val hi = "0123456789abcdef"[(b >> 4):((b >> 4) + 1)]
        val lo = "0123456789abcdef"[(b & 0xF):((b & 0xF) + 1)]
        hex_str = hex_str + hi + lo

    val result = shell("echo '{hex_str}' | xxd -r -p > '{path}'")
    result.exit_code == 0

fn print_usage():
    print "Library SMF Management Tool"
    print ""
    print "Usage:"
    print "  simple scripts/lib_tool.spl <command> [args...]"
    print ""
    print "Commands:"
    print "  list <library.lsm>"
    print "      List all modules in a library"
    print ""
    print "  info <library.lsm>"
    print "      Show detailed library information"
    print ""
    print "  verify <library.lsm>"
    print "      Verify integrity of all modules"
    print ""
    print "  extract <library.lsm> <module_name> [--output=path]"
    print "      Extract a module from library to SMF file"
    print ""
    print "  create <output.lsm> <input1.smf> [input2.smf ...]"
    print "      Create a new library from SMF files"
    print ""
    print "  help"
    print "      Show this help message"
    print ""
    print "Examples:"
    print "  # List modules"
    print "  simple scripts/lib_tool.spl list build/lib/libstd.lsm"
    print ""
    print "  # Extract a module"
    print "  simple scripts/lib_tool.spl extract libstd.lsm std/io/mod"
    print ""
    print "  # Create a library"
    print "  simple scripts/lib_tool.spl create mylib.lsm mod1.smf mod2.smf"

fn get_args() -> [text]:
    # Get command line arguments (skip program name)
    # For now, return empty array as placeholder
    []
