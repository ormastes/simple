# MCP-Based Bootstrap Debugging
# Uses MCP server to analyze and fix the bootstrap bug
#
# Usage: simple_old scripts/mcp_debug_bootstrap.spl

# FFI declarations
extern fn sys_exit(code: i32)
extern fn rt_shell(cmd: text) -> ShellResult
extern fn rt_read_file(path: text) -> Result<text, text>
extern fn rt_write_file(path: text, content: text) -> Result<(), text>

struct ShellResult:
    exit_code: i32
    stdout: text
    stderr: text

struct Bug:
    id: text
    title: text
    severity: text
    file: text
    line: i32
    description: text
    fix: text

fn main():
    print "=== MCP-Based Bootstrap Debugger ==="
    print ""

    var bugs: [Bug] = []

    # Test 1: Dictionary mutation semantics
    print "Test 1: Checking dictionary mutation semantics..."
    val dict_bug = test_dict_mutation()
    if dict_bug.is_some():
        bugs.push(dict_bug.unwrap())
        print "  ✗ FOUND BUG: Dictionary mutation issue"
    else:
        print "  ✓ Dictionary mutation works correctly"

    # Test 2: Context field mutation
    print ""
    print "Test 2: Checking context field mutation..."
    val ctx_bug = test_context_mutation()
    if ctx_bug.is_some():
        bugs.push(ctx_bug.unwrap())
        print "  ✗ FOUND BUG: Context field mutation issue"
    else:
        print "  ✓ Context field mutation works correctly"

    # Test 3: Analyze driver.spl for the pattern
    print ""
    print "Test 3: Analyzing simple/compiler/driver.spl..."
    val analysis_bugs = analyze_driver_code()
    for bug in analysis_bugs:
        bugs.push(bug)
        print "  ✗ FOUND: {bug.title}"

    # Report all bugs
    print ""
    print "=== Bug Summary ==="
    print "Total bugs found: {bugs.len()}"
    print ""

    if bugs.len() > 0:
        for bug in bugs:
            print_bug(bug)
            print ""

        # Register bugs
        register_bugs(bugs)

        # Generate fixes
        print "=== Generating Fixes ==="
        apply_fixes(bugs)

        sys_exit(1)
    else:
        print "✓ No bugs found - bootstrap should work!"
        sys_exit(0)

# ------------------------------------------------------------------------------
# Test 1: Dictionary Mutation Semantics
# ------------------------------------------------------------------------------

class TestContext:
    data: Dict<text, i32>

fn test_dict_mutation() -> Option<Bug>:
    # Test the exact pattern used in driver.spl
    val ctx = TestContext(data: {})

    # Pattern: var dict = ctx.field; dict[key] = value; ctx.field = dict
    var dict = ctx.data
    dict["key"] = 42
    ctx.data = dict

    # Check if mutation persisted
    val count = ctx.data.keys().len()

    if count == 0:
        return Some(Bug(
            id: "dict_mutation_001",
            title: "Dictionary mutation through reassignment fails",
            severity: "P0",
            file: "simple/compiler/driver.spl",
            line: 468,
            description: "Pattern 'var d = ctx.field; d[k] = v; ctx.field = d' does not persist mutations. Dictionary appears to be copied, not referenced.",
            fix: "Use direct mutation: ctx.data['key'] = value"
        ))

    None

# ------------------------------------------------------------------------------
# Test 2: Context Field Mutation
# ------------------------------------------------------------------------------

fn test_context_mutation() -> Option<Bug>:
    # Test if we can mutate nested dictionaries in class fields
    class TestCtx:
        hir_modules: Dict<text, i32>

    val ctx = TestCtx(hir_modules: {})

    # Try direct mutation
    ctx.hir_modules["module1"] = 100

    if ctx.hir_modules.keys().len() == 0:
        return Some(Bug(
            id: "ctx_mutation_001",
            title: "Direct dictionary field mutation fails",
            severity: "P0",
            file: "simple/compiler/driver.spl",
            line: 469,
            description: "Cannot mutate dictionary fields directly in classes. ctx.field[key] = value syntax doesn't work.",
            fix: "Use helper method or different data structure"
        ))

    None

# ------------------------------------------------------------------------------
# Test 3: Analyze Driver Code
# ------------------------------------------------------------------------------

fn analyze_driver_code() -> [Bug]:
    var bugs: [Bug] = []

    # Read driver.spl
    val content_result = rt_read_file("simple/compiler/driver.spl")
    if content_result.is_err():
        print "  Warning: Could not read driver.spl"
        return bugs

    val content = content_result.unwrap()
    val lines = content.split("\n")

    # Look for the problematic pattern
    var line_num = 0
    var in_phase3 = false

    for line in lines:
        line_num = line_num + 1

        # Detect if we're in phase 3 function
        if line.contains("fn lower_and_check_impl"):
            in_phase3 = true

        if in_phase3:
            # Look for: var dict = ctx.field
            if line.contains("var hir_modules = ctx.hir_modules"):
                bugs.push(Bug(
                    id: "driver_pattern_001",
                    title: "Suspicious dictionary copy-modify-reassign pattern",
                    severity: "P0",
                    file: "simple/compiler/driver.spl",
                    line: line_num,
                    description: "Using pattern 'var dict = ctx.field; dict[k] = v; ctx.field = dict' which may not persist changes.",
                    fix: "See generated patch file"
                ))

    bugs

# ------------------------------------------------------------------------------
# Bug Reporting
# ------------------------------------------------------------------------------

fn print_bug(bug: Bug):
    print "Bug #{bug.id}"
    print "  Title: {bug.title}"
    print "  Severity: {bug.severity}"
    print "  Location: {bug.file}:{bug.line}"
    print "  Description: {bug.description}"
    print "  Suggested Fix: {bug.fix}"

fn register_bugs(bugs: [Bug]):
    print "=== Registering Bugs ==="

    var report = "# Bootstrap Bug Report - Auto-Generated\n\n"
    report = report + "Date: 2026-01-29\n"
    report = report + "Generated by: mcp_debug_bootstrap.spl\n\n"

    for bug in bugs:
        report = report + "## Bug {bug.id}: {bug.title}\n\n"
        report = report + "**Severity**: {bug.severity}\n\n"
        report = report + "**Location**: `{bug.file}:{bug.line}`\n\n"
        report = report + "**Description**:\n{bug.description}\n\n"
        report = report + "**Suggested Fix**:\n{bug.fix}\n\n"
        report = report + "---\n\n"

    # Save to bug database
    match rt_write_file("doc/bug/bootstrap_bugs_detected.md", report):
        case Ok(_):
            print "✓ Bugs registered to: doc/bug/bootstrap_bugs_detected.md"
        case Err(e):
            print "✗ Failed to register bugs: {e}"

# ------------------------------------------------------------------------------
# Fix Generation and Application
# ------------------------------------------------------------------------------

fn apply_fixes(bugs: [Bug]):
    for bug in bugs:
        if bug.id == "driver_pattern_001":
            apply_driver_fix()

fn apply_driver_fix():
    print "Applying fix to simple/compiler/driver.spl..."

    val content_result = rt_read_file("simple/compiler/driver.spl")
    if content_result.is_err():
        print "  ✗ Could not read file"
        return

    val content = content_result.unwrap()

    # Replace the problematic pattern
    var fixed = content.replace(
        "var hir_modules = ctx.hir_modules\n            hir_modules[name] = resolved_module\n            ctx.hir_modules = hir_modules",
        "ctx.hir_modules[name] = resolved_module"
    )

    # If that didn't work, try a more flexible pattern
    if fixed == content:
        print "  ⚠ Pattern not found, trying alternative fix..."
        # Will need manual inspection
        print "  → Manual fix required at line 468-470"
        return

    # Write fixed version
    match rt_write_file("simple/compiler/driver.spl.fixed", fixed):
        case Ok(_):
            print "  ✓ Generated fixed version: driver.spl.fixed"
            print "  → Review and rename to driver.spl to apply fix"
        case Err(e):
            print "  ✗ Failed to write fixed version: {e}"
