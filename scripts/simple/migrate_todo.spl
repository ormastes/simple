# TODO Migration Script
# Converts old TODO/FIXME comments to new format:
#   TODO: [area][priority] description [#issue] [blocked:#n,#m]
#
# Usage:
#   ./target/debug/simple scripts/simple/migrate_todo.spl <file> [--dry-run] [--verbose]
#
# Examples:
#   ./target/debug/simple scripts/simple/migrate_todo.spl src/compiler/src/mock.rs --dry-run

# Native I/O functions
extern fn native_fs_read_string(path: String) -> Any
extern fn native_fs_write_string(path: String, content: String) -> Any
extern fn native_fs_exists(path: String) -> Bool
extern fn sys_get_args() -> List[String]
extern fn println(msg: String) -> ()

# Detect area from file path
fn detect_area(file_path: String) -> String:
    if file_path.contains("src/runtime"):
        return "runtime"
    if file_path.contains("src/compiler/src/codegen"):
        return "codegen"
    if file_path.contains("src/compiler/src/mir"):
        return "codegen"
    if file_path.contains("src/compiler/src/hir"):
        return "compiler"
    if file_path.contains("src/compiler"):
        return "compiler"
    if file_path.contains("src/parser"):
        return "parser"
    if file_path.contains("src/type"):
        return "type"
    if file_path.contains("src/driver"):
        return "driver"
    if file_path.contains("src/loader"):
        return "loader"
    if file_path.contains("src/pkg"):
        return "pkg"
    if file_path.contains("src/sdn"):
        return "sdn"
    if file_path.contains("src/ui"):
        return "ui"
    if file_path.contains("simple/std_lib"):
        return "stdlib"
    if file_path.contains("simple/app"):
        return "stdlib"
    return "compiler"

# Detect priority from description keywords
fn detect_priority(description: String) -> String:
    # Check for critical keywords (case-sensitive for simplicity)
    if description.contains("crash") or description.contains("memory leak"):
        return "P0"
    if description.contains("Crash") or description.contains("Memory leak"):
        return "P0"
    if description.contains("broken") or description.contains("corrupt"):
        return "P0"
    if description.contains("Implement") or description.contains("implement"):
        return "P1"
    if description.contains("Fix") or description.contains("fix"):
        return "P1"
    if description.contains("Handle") or description.contains("handle"):
        return "P1"
    if description.contains("Optimize") or description.contains("optimize"):
        return "P2"
    if description.contains("Refactor") or description.contains("refactor"):
        return "P2"
    if description.contains("Track") or description.contains("track"):
        return "P2"
    if description.contains("Parse") or description.contains("parse"):
        return "P2"
    return "P3"

# Process a line and return new line (or same line if no change)
fn process_line(line: String, is_rust: Bool, detected_area: String, verbose: Bool, line_num: Int, file_path: String) -> String:
    # Check for TODO or FIXME
    if not line.contains("TODO") and not line.contains("FIXME"):
        return line

    # Determine keyword
    let mut keyword = "TODO"
    let mut start_idx: Int = 0
    if line.contains("TODO"):
        keyword = "TODO"
        start_idx = line.find("TODO").unwrap()
    elif line.contains("FIXME"):
        keyword = "FIXME"
        start_idx = line.find("FIXME").unwrap()
    else:
        return line

    # Get content after keyword
    let after_keyword = line[start_idx + keyword.len():]
    let mut description = after_keyword.strip()

    # Check if it starts with :
    if not description.starts_with(":"):
        return line

    description = description[1:].strip()

    # Already formatted?
    if description.starts_with("["):
        return line

    # Build new comment
    let detected_priority = detect_priority(description)
    let new_comment = "{keyword}: [{detected_area}][{detected_priority}] {description}"

    # Find where comment starts (before //)
    let mut comment_start: Int = start_idx
    # Look backwards to find // or #
    if is_rust:
        let slash_pos = line.find("//")
        match slash_pos:
            case Some(p):
                comment_start = p
            case None:
                comment_start = start_idx
    else:
        let hash_pos = line.find("#")
        match hash_pos:
            case Some(p):
                comment_start = p
            case None:
                comment_start = start_idx

    let indent = line[0..comment_start]
    let mut comment_char = "# "
    if is_rust:
        comment_char = "// "
    let new_line = indent + comment_char + new_comment

    if verbose:
        println("")
        println("{file_path}:{line_num}")
        println("  OLD: {line.strip()}")
        println("  NEW: {new_line.strip()}")

    return new_line

# Main entry point
fn main() -> Int:
    let args = sys_get_args()

    if args.len() < 2:
        println("TODO Migration Script")
        println("")
        println("Usage: simple scripts/simple/migrate_todo.spl <file> [--dry-run] [--verbose]")
        println("")
        println("Format: TODO: [area][priority] description [#issue] [blocked:#n,#m]")
        println("Priorities: P0/critical, P1/high, P2/medium, P3/low")
        println("Areas: runtime, codegen, compiler, parser, type, stdlib, gpu, ui, test")
        return 1

    let target = args[1]
    let dry_run = args.contains("--dry-run")
    let verbose = args.contains("--verbose")

    if dry_run:
        println("DRY RUN - no files will be modified")
        println("")

    if not native_fs_exists(target):
        println("Error: File not found: {target}")
        return 1

    # Check file extension
    let is_rust = target.ends_with(".rs")
    let is_simple = target.ends_with(".spl")

    if not is_rust and not is_simple:
        println("Error: File must be .rs or .spl")
        return 1

    # Read file
    let content_result = native_fs_read_string(target)
    let mut content_str = ""
    match content_result:
        case Ok(c):
            content_str = c
        case Err(e):
            println("Error reading {target}")
            return 1

    let lines = content_str.split("\n")
    let detected_area = detect_area(target)

    # Process each line
    let mut new_lines: List[String] = []
    let mut count: Int = 0
    let mut i: Int = 0

    while i < lines.len():
        let line = lines[i]
        let line_num: Int = i + 1
        let new_line = process_line(line, is_rust, detected_area, verbose, line_num, target)

        if new_line != line:
            count = count + 1

        new_lines.push(new_line)
        i = i + 1

    # Output results
    if count > 0:
        if dry_run:
            println("Would update {target} ({count} TODOs)")
        else:
            let new_content = new_lines.join("\n")
            native_fs_write_string(target, new_content)
            println("Updated {target} ({count} TODOs)")
    else:
        println("No TODOs to migrate in {target}")

    return 0
