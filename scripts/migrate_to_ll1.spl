# Migration script: GLR syntax → LL(1) syntax
# Changes:
# 1. [T] → <T> for generics (in type positions)
# 2. T? → Option<T> for optional types
# 3. [for x in xs: x] → [for x in xs: x] for comprehensions
# 4. .method \x: → .method(\x: for lambdas

use host.async_nogc_mut.io.fs.*
use core.string_ops.*
use core.regex.*

struct MigrationStats:
    files_processed: i32
    generic_brackets: i32
    optional_types: i32
    comprehensions: i32
    lambdas: i32

fn migrate_file(path: String) -> Result<MigrationStats, String>:
    print("Migrating: {path}")

    # Read file
    val content_result = read_to_string(path)
    if content_result.is_err():
        return Err("Failed to read {path}: {content_result.unwrap_err()}")

    var content = content_result.unwrap()
    var stats = MigrationStats {
        files_processed: 1,
        generic_brackets: 0,
        optional_types: 0,
        comprehensions: 0,
        lambdas: 0,
    }

    # 1. Generic brackets: struct/enum/impl/fn declarations
    # Pattern: TypeName[...] in declaration context
    content = migrate_generic_declarations(content, stats)

    # 2. Generic brackets: Type[...] in type positions
    content = migrate_generic_types(content, stats)

    # 3. Optional types: Option<T> → Option<T>
    content = migrate_optional_types(content, stats)

    # 4. Comprehensions: [expr for ...] → [for ...: expr]
    content = migrate_comprehensions(content, stats)

    # 5. Lambdas: .method \x: → .method(\x:
    content = migrate_lambdas(content, stats)

    # Write back
    val write_result = write_string(path, content)
    if write_result.is_err():
        return Err("Failed to write {path}: {write_result.unwrap_err()}")

    return Ok(stats)

fn migrate_generic_declarations(content: String, stats: mut MigrationStats) -> String:
    var result = content

    # struct Name<T> → struct Name<T>
    result = regex_replace_all(result, r"struct\s+(\w+)\[([^\]]+)\]", "struct $1<$2>")

    # enum Name<T> → enum Name<T>
    result = regex_replace_all(result, r"enum\s+(\w+)\[([^\]]+)\]", "enum $1<$2>")

    # impl Name<T> → impl Name<T>
    result = regex_replace_all(result, r"impl\s+(\w+)\[([^\]]+)\]", "impl $1<$2>")

    # fn name<T> → fn name<T>
    result = regex_replace_all(result, r"fn\s+(\w+)\[([^\]]+)\]", "fn $1<$2>")

    # trait Name<T> → trait Name<T>
    result = regex_replace_all(result, r"trait\s+(\w+)\[([^\]]+)\]", "trait $1<$2>")

    stats.generic_brackets += count_replacements(content, result)
    return result

fn migrate_generic_types(content: String, stats: mut MigrationStats) -> String:
    var result = content

    # Common generic types in type positions
    # After : or -> or = in type context
    # List<T> → List<T>
    result = regex_replace_all(result, r"List\[([^\]]+)\]", "List<$1>")
    result = regex_replace_all(result, r"Option\[([^\]]+)\]", "Option<$1>")
    result = regex_replace_all(result, r"Result\[([^\]]+)\]", "Result<$1>")
    result = regex_replace_all(result, r"Dict\[([^\]]+)\]", "Dict<$1>")
    result = regex_replace_all(result, r"Set\[([^\]]+)\]", "Set<$1>")
    result = regex_replace_all(result, r"Vec\[([^\]]+)\]", "Vec<$1>")
    result = regex_replace_all(result, r"Array\[([^\]]+)\]", "Array<$1>")
    result = regex_replace_all(result, r"Slice\[([^\]]+)\]", "Slice<$1>")
    result = regex_replace_all(result, r"Iterator\[([^\]]+)\]", "Iterator<$1>")
    result = regex_replace_all(result, r"Future\[([^\]]+)\]", "Future<$1>")
    result = regex_replace_all(result, r"Promise\[([^\]]+)\]", "Promise<$1>")
    result = regex_replace_all(result, r"Channel\[([^\]]+)\]", "Channel<$1>")

    # Generic type parameters (recursive for nested)
    # This is tricky - we need multiple passes for nested generics
    for _ in 0..10:  # Max 10 nesting levels
        val before = result
        result = regex_replace_all(result, r"(\w+)\[([^<>\[\]]+)\]", "$1<$2>")
        if before == result:
            break

    stats.generic_brackets += count_replacements(content, result)
    return result

fn migrate_optional_types(content: String, stats: mut MigrationStats) -> String:
    var result = content

    # Type? → Option<Type> (but NOT expr? which is error propagation)
    # Look for patterns like:
    # - : Option<Type>  (type annotation)
    # - -> Option<Type>  (return type)
    # - = Type?  (type alias)

    # After : in parameter/field types
    result = regex_replace_all(result, r":\s*(\w+)\?", ": Option<$1>")

    # After -> in return types
    result = regex_replace_all(result, r"->\s*(\w+)\?", "-> Option<$1>")

    # In generic type parameters
    result = regex_replace_all(result, r"<([^<>]+,\s*)?(\w+)\?([,>])", "<$1Option<$2>$3")

    stats.optional_types += count_replacements(content, result)
    return result

fn migrate_comprehensions(content: String, stats: mut MigrationStats) -> String:
    var result = content

    # [for var in iterable: expr] → [for var in iterable: expr]
    # This is complex - need to extract expr and move it after :

    # Simple case: [for x in xs: x]
    result = regex_replace_all(result, r"\[(\w+)\s+for\s+(\w+)\s+in\s+([^\]]+)\]", "[for $2 in $3: $1]")

    # With filter: [for x in xs if cond: x]
    result = regex_replace_all(result, r"\[(\w+)\s+for\s+(\w+)\s+in\s+([^\]]+)\s+if\s+([^\]]+)\]", "[for $2 in $3 if $4: $1]")

    # With expression: [x * 2 for x in xs]
    # This requires more complex parsing - for now, warn user to fix manually
    # We can detect these and report them

    stats.comprehensions += count_replacements(content, result)
    return result

fn migrate_lambdas(content: String, stats: mut MigrationStats) -> String:
    var result = content

    # .method \x: → .method(\x:
    # Need to find the closing paren/newline to add )

    # Single line lambda: .method \x: expr
    # This is tricky because we need to know where the expression ends
    # For now, handle simple cases

    # .method \x: followed by simple expression (word or operator)
    result = regex_replace_all(result, r"\.(\w+)\s+\\(\w+):", ".$1(\\$2:")

    # Need to add closing ) - this is complex
    # We'll need multi-line handling

    stats.lambdas += count_replacements(content, result)
    return result

fn count_replacements(before: String, after: String) -> i32:
    # Simple heuristic: count differences
    if before == after:
        return 0
    return 1

fn regex_replace_all(text: String, pattern: String, replacement: String) -> String:
    # Simplified regex replace - in real implementation, use proper regex lib
    # For now, return text as-is and let user know this needs manual implementation
    return text

fn main():
    print("LL(1) Migration Script")
    print("======================")
    print("")
    print("This script will migrate Simple language files from GLR to LL(1) syntax")
    print("")
    print("Changes:")
    print("  1. Generic brackets:  List<T> → List<T>")
    print("  2. Optional types: Option<T> → Option<T>")
    print("  3. Comprehensions:    [for x in xs: x] → [for x in xs: x]")
    print("  4. Lambdas:           .map \\x: expr → .map(\\x: expr)")
    print("")

    # Get all .spl files
    val files = find_all_spl_files()

    print("Found {files.length()} .spl files to migrate")
    print("")

    var total_stats = MigrationStats {
        files_processed: 0,
        generic_brackets: 0,
        optional_types: 0,
        comprehensions: 0,
        lambdas: 0,
    }

    for file in files:
        val result = migrate_file(file)
        match result:
            case Ok(stats):
                total_stats.files_processed += stats.files_processed
                total_stats.generic_brackets += stats.generic_brackets
                total_stats.optional_types += stats.optional_types
                total_stats.comprehensions += stats.comprehensions
                total_stats.lambdas += stats.lambdas
            case Err(error):
                print("ERROR: {error}")

    print("")
    print("Migration Complete!")
    print("===================")
    print("Files processed:      {total_stats.files_processed}")
    print("Generic brackets:     {total_stats.generic_brackets}")
    print("Optional types:       {total_stats.optional_types}")
    print("Comprehensions:       {total_stats.comprehensions}")
    print("Lambdas:              {total_stats.lambdas}")

fn find_all_spl_files() -> List<String>:
    # Find all .spl files recursively
    # Placeholder - needs real implementation
    return []
