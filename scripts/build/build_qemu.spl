#!/usr/bin/env simple
# QEMU Build Script
# Builds QEMU from source with selected architectures

use app.io.{rt_process_run, rt_file_exists, rt_dir_create, rt_env_get}

# Configuration
val QEMU_VERSION = "8.2.0"
val DOWNLOADS_DIR = "resources/qemu/downloads"
val BUILD_DIR = "resources/qemu/build"
val INSTALL_DIR = "resources/qemu/install/{QEMU_VERSION}"
val BIN_DIR = "resources/qemu/bin"

# Default architectures to build
val default_archs = ["i386", "x86_64", "arm", "aarch64", "riscv32", "riscv64"]

fn main():
    print "QEMU Build Script"
    print "================="
    print "Version: {QEMU_VERSION}"
    print ""

    # Step 1: Check if source tarball exists
    val tarball = "{DOWNLOADS_DIR}/qemu-{QEMU_VERSION}.tar.xz"
    if not rt_file_exists(tarball):
        print "Error: QEMU source tarball not found!"
        print "Expected: {tarball}"
        print ""
        print "Please run: simple run scripts/download_qemu.spl"
        return

    print "✓ Source tarball found: {tarball}"

    # Step 2: Check build dependencies
    print ""
    print "Checking build dependencies..."
    if not check_dependencies():
        return

    # Step 3: Extract source
    val source_dir = "{BUILD_DIR}/qemu-{QEMU_VERSION}"
    if not rt_file_exists(source_dir):
        print ""
        print "Extracting source..."
        if not extract_tarball(tarball, BUILD_DIR):
            return
        print "✓ Source extracted to: {source_dir}"
    else:
        print "✓ Source already extracted: {source_dir}"

    # Step 4: Configure
    print ""
    print "Configuring build..."
    print "Architectures: {default_archs.join(\", \")}"
    print "Install prefix: {INSTALL_DIR}"
    print ""

    if not configure_qemu(source_dir):
        return

    # Step 5: Build
    print ""
    print "Building QEMU (this may take 15-30 minutes)..."
    print "Using {get_cpu_count()} parallel jobs"
    print ""

    if not build_qemu(source_dir):
        return

    # Step 6: Install
    print ""
    print "Installing to {INSTALL_DIR}..."
    if not install_qemu(source_dir):
        return

    # Step 7: Create symlinks
    print ""
    print "Creating symlinks in {BIN_DIR}..."
    create_symlinks()

    # Done!
    print ""
    print "========================================="
    print "SUCCESS! QEMU {QEMU_VERSION} installed"
    print "========================================="
    print ""
    print "Binaries installed to:"
    print "  {INSTALL_DIR}/bin/"
    print ""
    print "Symlinks created in:"
    print "  {BIN_DIR}/"
    print ""
    print "Add to PATH:"
    print "  export PATH=\"{BIN_DIR}:\$PATH\""
    print ""
    print "Or use absolute path:"
    print "  {BIN_DIR}/qemu-system-x86_64 --version"

fn check_dependencies() -> bool:
    val required_deps = [
        ("ninja", "ninja-build", "ninja build system"),
        ("python3", "python3", "Python 3"),
        ("pkg-config", "pkg-config", "package config")
    ]

    val required_libs = [
        ("glib-2.0", "libglib2.0-dev", "GLib library"),
        ("pixman-1", "libpixman-1-dev", "Pixman library")
    ]

    var all_ok = true

    # Check commands
    for (cmd, package, desc) in required_deps:
        if not command_exists(cmd):
            print "✗ Missing: {cmd} ({desc})"
            print "  Install: sudo apt install {package}"
            all_ok = false
        else:
            print "✓ Found: {cmd}"

    # Check libraries with pkg-config
    if command_exists("pkg-config"):
        for (lib, package, desc) in required_libs:
            if not check_pkg_config(lib):
                print "✗ Missing: {lib} ({desc})"
                print "  Install: sudo apt install {package}"
                all_ok = false
            else:
                print "✓ Found: {lib}"

    if not all_ok:
        print ""
        print "Error: Missing dependencies"
        print ""
        print "Install all dependencies:"
        print "  Ubuntu/Debian:"
        print "    sudo apt install build-essential ninja-build python3 \\"
        print "                     pkg-config libglib2.0-dev libpixman-1-dev \\"
        print "                     zlib1g-dev libslirp-dev"
        print ""
        print "  macOS:"
        print "    brew install ninja python@3.11 glib pixman pkg-config"

    all_ok

fn extract_tarball(tarball: text, dest_dir: text) -> bool:
    ensure_dir_exists(dest_dir)

    val args = ["-xf", tarball, "-C", dest_dir]
    val (stdout, stderr, exit_code) = rt_process_run("tar", args)

    if exit_code != 0:
        print "Error extracting tarball:"
        print stderr
        return false

    true

fn configure_qemu(source_dir: text) -> bool:
    # Build target list
    val targets = default_archs.map(\arch: "{arch}-softmmu").join(",")

    val configure_args = [
        "--prefix={INSTALL_DIR}",
        "--target-list={targets}",
        "--enable-slirp",         # User-mode networking
        "--disable-werror"        # Don't fail on warnings
    ]

    val cmd_str = "./configure {configure_args.join(\" \")}"

    val (stdout, stderr, exit_code) = run_in_dir(source_dir, "./configure", configure_args)

    if exit_code != 0:
        print "Configure failed:"
        print stderr
        return false

    print "✓ Configuration complete"
    true

fn build_qemu(source_dir: text) -> bool:
    val jobs = get_cpu_count()
    val (stdout, stderr, exit_code) = run_in_dir(source_dir, "make", ["-j{jobs}"])

    if exit_code != 0:
        print "Build failed:"
        print stderr
        return false

    print "✓ Build complete"
    true

fn install_qemu(source_dir: text) -> bool:
    val (stdout, stderr, exit_code) = run_in_dir(source_dir, "make", ["install"])

    if exit_code != 0:
        print "Install failed:"
        print stderr
        return false

    print "✓ Install complete"
    true

fn create_symlinks():
    ensure_dir_exists(BIN_DIR)

    for arch in default_archs:
        val emulator = "qemu-system-{arch}"
        val src = "{INSTALL_DIR}/bin/{emulator}"
        val dst = "{BIN_DIR}/{emulator}"

        # Remove old symlink
        run_command("rm", ["-f", dst])

        # Create new symlink
        val (stdout, stderr, exit_code) = run_command("ln", ["-s", src, dst])

        if exit_code == 0:
            print "  ✓ {emulator}"
        else:
            print "  ✗ {emulator} (symlink failed)"

fn run_in_dir(dir: text, cmd: text, args: [text]) -> (text, text, i64):
    # Change to directory and run command
    # Note: We can't actually change directory in SFFI, so we use shell
    val full_cmd = "cd {dir} && {cmd} {args.join(\" \")}"
    val (stdout, stderr, exit_code) = rt_process_run("sh", ["-c", full_cmd])
    (stdout, stderr, exit_code)

fn run_command(cmd: text, args: [text]) -> (text, text, i64):
    rt_process_run(cmd, args)

fn command_exists(cmd: text) -> bool:
    val (stdout, stderr, exit_code) = rt_process_run("which", [cmd])
    exit_code == 0

fn check_pkg_config(lib: text) -> bool:
    val (stdout, stderr, exit_code) = rt_process_run("pkg-config", ["--exists", lib])
    exit_code == 0

fn get_cpu_count() -> i64:
    # Try nproc (Linux)
    val (stdout, stderr, exit_code) = rt_process_run("nproc", [])
    if exit_code == 0:
        val count_str = stdout.trim()
        return parse_i64(count_str)

    # Try sysctl (macOS)
    val (stdout2, stderr2, exit_code2) = rt_process_run("sysctl", ["-n", "hw.ncpu"])
    if exit_code2 == 0:
        val count_str = stdout2.trim()
        return parse_i64(count_str)

    # Default to 4
    4

fn parse_i64(s: text) -> i64:
    var result: i64 = 0
    for c in s:
        if c >= '0' and c <= '9':
            result = result * 10 + (c as i64 - 48)
        else:
            break
    result

fn ensure_dir_exists(dir_path: text):
    if not rt_file_exists(dir_path):
        rt_dir_create(dir_path)
