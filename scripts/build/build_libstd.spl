#!/usr/bin/env simple
# Build Standard Library Archive
#
# This script creates libstd.lsm - a library archive containing all compiled
# standard library SMF modules. The library can be used for:
# - Module loading (ModuleLoaderWithLibs)
# - Native linking (linker_wrapper_lib_support)
# - Distribution packaging
#
# Usage:
#   simple scripts/build_libstd.spl [--output=path] [--verbose]
#
# Default output: build/lib/libstd.lsm

use compiler.linker.lib_smf_writer.{LibSmfBuilder}
use app.io.{file_exists, shell, cwd, env_get}

fn main():
    # Parse arguments
    val args = get_args()
    var output_path = "build/lib/libstd.lsm"
    var verbose = false
    var with_objects = false
    var obj_dir = "build/obj"

    for arg in args:
        if arg.starts_with("--output="):
            output_path = arg[9:]
        elif arg.starts_with("--obj-dir="):
            obj_dir = arg[10:]
        elif arg == "--with-objects":
            with_objects = true
        elif arg == "--verbose" or arg == "-v":
            verbose = true
        elif arg == "--help" or arg == "-h":
            print_usage()
            exit(0)

    print "========================================="
    print "Building Standard Library Archive"
    print "========================================="
    print ""

    if verbose:
        print "Output: {output_path}"
        print "Object files: {with_objects}"
        if with_objects:
            print "Object directory: {obj_dir}"
        print ""

    # Step 1: Create output directory
    print "[1/5] Creating output directory..."
    val dir_result = shell("mkdir -p build/lib")
    if dir_result.exit_code != 0:
        print "Error: Failed to create build/lib directory"
        exit(1)

    # Step 2: Find all SMF files in src/std
    print "[2/5] Scanning for standard library modules..."
    val find_result = shell("find src/std -name '*.smf' -type f 2>/dev/null")

    var smf_files: [text] = []
    if find_result.exit_code == 0:
        val lines = find_result.stdout.split("\n")
        for line in lines:
            val trimmed = line.trim()
            if trimmed != "" and trimmed.ends_with(".smf"):
                smf_files.push(trimmed)

    if smf_files.len() == 0:
        print "Warning: No SMF files found in src/std/"
        print ""
        print "Note: Standard library modules may need to be compiled first."
        print "Run: simple build"
        print ""
        print "Creating empty library as placeholder..."
    else:
        print "Found {smf_files.len()} modules"
        if verbose:
            for smf in smf_files:
                print "  - {smf}"
        print ""

    # Step 3: Create library builder
    print "[3/5] Creating library builder..."
    var builder = LibSmfBuilder.new()
    builder.set_verbose(verbose)

    if verbose:
        print "Library builder created"
        print ""

    # Step 4: Add modules to library
    print "[4/5] Adding modules to library..."
    var added_count = 0
    var with_obj_count = 0

    for smf_path in smf_files:
        # Convert file path to module name
        # Example: src/std/io/mod.smf -> std/io/mod
        var module_name = smf_path

        # Remove src/ prefix if present
        if module_name.starts_with("src/"):
            module_name = module_name[4:]

        # Remove .smf extension
        if module_name.ends_with(".smf"):
            module_name = module_name[0:(module_name.len() - 4)]

        # Check for companion object file if requested
        var add_result = Err("")
        if with_objects:
            val obj_path = find_object_for_module(module_name, obj_dir)
            if obj_path != "":
                # Add with object file
                add_result = builder.add_module_with_object(module_name, smf_path, obj_path)
                if add_result.is_ok():
                    added_count = added_count + 1
                    with_obj_count = with_obj_count + 1
                    if verbose:
                        print "  Added (with object): {module_name}"
                else:
                    print "  Warning: Could not add {smf_path} with object: {add_result.unwrap_err()}"
            else:
                # No object file, add SMF only
                add_result = builder.add_module(module_name, smf_path)
                if add_result.is_ok():
                    added_count = added_count + 1
                    if verbose:
                        print "  Added (SMF only): {module_name}"
                else:
                    print "  Warning: Could not add {smf_path}: {add_result.unwrap_err()}"
        else:
            # Add SMF only (original behavior)
            add_result = builder.add_module(module_name, smf_path)
            if add_result.is_ok():
                added_count = added_count + 1
                if verbose:
                    print "  Added: {module_name}"
            else:
                print "  Warning: Could not add {smf_path}: {add_result.unwrap_err()}"

    print "Added {added_count} modules"
    if with_objects and with_obj_count > 0:
        print "  {with_obj_count} modules with object files"
        print "  {added_count - with_obj_count} modules SMF only"
    print ""

    # Step 5: Write library to file
    print "[5/5] Writing library archive..."
    val write_result = builder.write(output_path)

    if write_result.is_err():
        print "Error: Failed to write library: {write_result.unwrap_err()}"
        exit(1)

    # Get file size
    val size_result = shell("stat -f%z '{output_path}' 2>/dev/null || stat -c%s '{output_path}' 2>/dev/null")
    var size_str = "unknown"
    if size_result.exit_code == 0:
        size_str = size_result.stdout.trim()

    print "âœ“ Library created: {output_path}"
    print "  Size: {size_str} bytes"
    print "  Modules: {added_count}"
    print ""

    print "========================================="
    print "Standard Library Archive Complete"
    print "========================================="
    print ""

    # Show usage information
    print "Usage:"
    print "  1. Module Loading:"
    print "     var loader = ModuleLoaderWithLibs.new(config)"
    print "     loader.add_library(\"{output_path}\")"
    print ""
    print "  2. Native Linking:"
    print "     config.library_paths = [\"build/lib\"]"
    print "     link_with_libraries(objects, output, config)"
    print ""
    print "  3. List modules:"
    print "     simple lib list {output_path}"

fn find_object_for_module(module_name: text, obj_dir: text) -> text:
    """Find object file for a module.

    Tries multiple naming conventions:
    - std/io/mod -> build/obj/std/io/mod.o
    - std/io/mod -> build/obj/std_io_mod.o
    - std/io/mod -> build/obj/mod.o

    Returns empty string if not found.
    """
    # Try full path variant
    val path1 = "{obj_dir}/{module_name}.o"
    if file_exists(path1):
        return path1

    # Try underscore variant
    val underscored = module_name.replace("/", "_")
    val path2 = "{obj_dir}/{underscored}.o"
    if file_exists(path2):
        return path2

    # Try last component only
    val last_slash = module_name.rfind("/")
    if last_slash >= 0:
        val last_comp = module_name[(last_slash + 1):]
        val path3 = "{obj_dir}/{last_comp}.o"
        if file_exists(path3):
            return path3

    # Not found
    ""

fn print_usage():
    print "Build Standard Library Archive"
    print ""
    print "Usage:"
    print "  simple scripts/build_libstd.spl [options]"
    print ""
    print "Options:"
    print "  --output=PATH      Output path (default: build/lib/libstd.lsm)"
    print "  --with-objects     Include object files for native linking"
    print "  --obj-dir=PATH     Object files directory (default: build/obj)"
    print "  --verbose, -v      Verbose output"
    print "  --help, -h         Show this help"
    print ""
    print "Description:"
    print "  Creates libstd.lsm containing all compiled standard library"
    print "  SMF modules. When --with-objects is specified, also includes"
    print "  compiled object files for direct native linking."
    print ""
    print "Requirements:"
    print "  - Standard library must be compiled to SMF first"
    print "  - Run 'simple build' before running this script"
    print "  - For --with-objects: compile modules to object files"
    print ""
    print "Examples:"
    print "  # Basic library (SMF only)"
    print "  simple scripts/build_libstd.spl"
    print ""
    print "  # With object files for linking"
    print "  simple scripts/build_libstd.spl --with-objects"

fn get_args() -> [text]:
    # Get command line arguments
    # For now, return empty array as a placeholder
    # In real implementation, this would use sys.args or similar
    []
