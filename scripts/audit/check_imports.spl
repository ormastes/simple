#!/usr/bin/env simple
# Import Checker - Detect and suggest fixes for common import errors
#
# Usage:
#   scripts/check_imports.spl <file>
#   scripts/check_imports.spl test/lib/
#   scripts/check_imports.spl --fix <file>

use app.io.{file_read, file_write, file_exists, dir_walk, get_args}

# Issue types
class ImportIssue:
    file: text
    line: i64
    issue_type: text
    current: text
    suggested: text
    severity: text  # error, warning, info

fn main():
    val args = get_args()

    if args.len() < 2:
        print_usage()
        return

    val fix_mode = args[1] == "--fix"
    val target = if fix_mode:
        if args.len() < 3:
            print "Error: --fix requires a file path"
            return
        args[2]
    else:
        args[1]

    # Collect files to check
    val files = collect_files(target)

    print "Checking {files.len()} files for import issues...\n"

    var total_issues = 0
    var files_with_issues = 0

    for file_path in files:
        val issues = check_file(file_path)

        if issues.len() > 0:
            files_with_issues = files_with_issues + 1
            total_issues = total_issues + issues.len()

            print_file_issues(file_path, issues)

            if fix_mode:
                apply_fixes(file_path, issues)

    print "\n" + "=".repeat(70)
    print "Summary:"
    print "  Files checked: {files.len()}"
    print "  Files with issues: {files_with_issues}"
    print "  Total issues: {total_issues}"

    if total_issues > 0 and not fix_mode:
        print "\nRun with --fix to automatically fix issues"

fn print_usage():
    print "Import Checker - Detect common import errors"
    print ""
    print "Usage:"
    print "  scripts/check_imports.spl <file_or_dir>"
    print "  scripts/check_imports.spl --fix <file>"
    print ""
    print "Examples:"
    print "  scripts/check_imports.spl test/lib/database_spec.spl"
    print "  scripts/check_imports.spl test/lib/"
    print "  scripts/check_imports.spl --fix test/lib/database_spec.spl"

fn collect_files(target: text) -> [text]:
    if file_exists(target):
        # Single file
        [target]
    else:
        # Directory - walk and find .spl files
        val all_files = dir_walk(target)
        var spl_files = []
        for f in all_files:
            if f.ends_with(".spl"):
                spl_files = spl_files + [f]
        spl_files

fn check_file(file_path: text) -> [ImportIssue]:
    val content = file_read(file_path)
    val lines = content.split("\n")

    var issues = []
    var line_num = 0

    for line in lines:
        line_num = line_num + 1
        val trimmed = line.trim()

        # Check 1: Deprecated 'import' keyword
        if trimmed.starts_with("import "):
            val suggested = trimmed.replace("import ", "use ") + ".*"
            issues = issues + [ImportIssue(
                file: file_path,
                line: line_num,
                issue_type: "deprecated_import",
                current: trimmed,
                suggested: suggested,
                severity: "warning"
            )]

        # Check 2: Bare module import (no .{} or .*)
        if trimmed.starts_with("use ") and not trimmed.contains(".{") and not trimmed.ends_with(".*"):
            # Extract module name
            val parts = trimmed.split(" ")
            if parts.len() >= 2:
                val module = parts[1]
                # Skip if it's a relative import with clear intent
                if not module.starts_with(".") or module.contains("/"):
                    val suggested = "use {module}.*  # Or: use {module}.{{func1, func2}}"
                    issues = issues + [ImportIssue(
                        file: file_path,
                        line: line_num,
                        issue_type: "bare_import",
                        current: trimmed,
                        suggested: suggested,
                        severity: "error"
                    )]

        # Check 3: Common module imports without explicit functions
        if trimmed == "use app.io":
            issues = issues + [ImportIssue(
                file: file_path,
                line: line_num,
                issue_type: "app_io_bare",
                current: trimmed,
                suggested: "use app.io.{file_read, file_write, file_exists}  # Common functions",
                severity: "error"
            )]

        if trimmed == "use std.spec":
            issues = issues + [ImportIssue(
                file: file_path,
                line: line_num,
                issue_type: "std_spec_bare",
                current: trimmed,
                suggested: "use std.spec.{describe, it, expect}  # Or: use std.spec.*",
                severity: "error"
            )]

    issues

fn print_file_issues(file_path: text, issues: [ImportIssue]):
    print "\n{file_path}:"

    for issue in issues:
        val icon = match issue.severity:
            "error": "❌"
            "warning": "⚠️ "
            _: "ℹ️ "

        val type_desc = match issue.issue_type:
            "deprecated_import": "Deprecated 'import' keyword"
            "bare_import": "Bare module import (functions not accessible)"
            "app_io_bare": "app.io bare import"
            "std_spec_bare": "std.spec bare import"
            _: issue.issue_type

        print "  {icon} Line {issue.line}: {type_desc}"
        print "    Current:   {issue.current}"
        print "    Suggested: {issue.suggested}"

fn apply_fixes(file_path: text, issues: [ImportIssue]):
    val content = file_read(file_path)
    var lines = content.split("\n")

    # Apply fixes in reverse order (to preserve line numbers)
    var sorted_issues = issues
    # Simple bubble sort by line number (descending)
    var n = sorted_issues.len()
    for i in 0..n:
        for j in 0..(n - i - 1):
            if sorted_issues[j].line < sorted_issues[j + 1].line:
                val temp = sorted_issues[j]
                sorted_issues[j] = sorted_issues[j + 1]
                sorted_issues[j + 1] = temp

    for issue in sorted_issues:
        val line_idx = issue.line - 1
        if line_idx >= 0 and line_idx < lines.len():
            # Extract suggested fix (remove comment part)
            var fix = issue.suggested
            if fix.contains("#"):
                val parts = fix.split("#")
                fix = parts[0].trim()

            lines[line_idx] = fix

    # Write back
    val new_content = lines.join("\n")
    file_write(file_path, new_content)
    print "  ✅ Fixed {issues.len()} issues in {file_path}"

fn text.repeat(count: i64) -> text:
    var result = ""
    for i in 0..count:
        result = result + self
    result

fn text.split(sep: text) -> [text]:
    # Stub implementation - would need runtime support
    [self]

fn text.trim() -> text:
    # Stub - would use runtime trim
    self

fn text.starts_with(prefix: text) -> bool:
    # Stub - would use runtime starts_with
    false

fn text.ends_with(suffix: text) -> bool:
    # Stub - would use runtime ends_with
    false

fn text.contains(substr: text) -> bool:
    # Stub - would use runtime contains
    false

fn text.replace(from: text, to: text) -> text:
    # Stub - would use runtime replace
    self

main()
