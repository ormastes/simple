#!/usr/bin/env simple
# OS Image Download Script
# Downloads test OS images and kernels for QEMU testing

use app.io.{rt_process_run, rt_file_exists, rt_dir_create}

# Configuration
val IMAGES_DIR = "resources/images"

# Available images (curated list)
struct ImageInfo:
    name: text
    url: text
    sha256: text
    size_mb: i64
    arch: text
    description: text

val AVAILABLE_IMAGES = [
    # Debian minimal images (small, good for testing)
    ImageInfo(
        name: "debian-12-arm64-netinst",
        url: "https://cdimage.debian.org/debian-cd/current/arm64/iso-cd/debian-12.4.0-arm64-netinst.iso",
        sha256: "TBD",  # User should verify
        size_mb: 650,
        arch: "aarch64",
        description: "Debian 12 ARM64 network installer"
    ),

    ImageInfo(
        name: "debian-12-amd64-netinst",
        url: "https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-12.4.0-amd64-netinst.iso",
        sha256: "TBD",
        size_mb: 650,
        arch: "x86_64",
        description: "Debian 12 x86_64 network installer"
    ),

    # Ubuntu Server (ARM64)
    ImageInfo(
        name: "ubuntu-22.04-server-arm64",
        url: "https://cdimage.ubuntu.com/releases/22.04/release/ubuntu-22.04.3-live-server-arm64.iso",
        sha256: "TBD",
        size_mb: 1800,
        arch: "aarch64",
        description: "Ubuntu 22.04 LTS Server ARM64"
    ),

    # Fedora Workstation (x86_64)
    ImageInfo(
        name: "fedora-39-workstation-x86_64",
        url: "https://download.fedoraproject.org/pub/fedora/linux/releases/39/Workstation/x86_64/iso/Fedora-Workstation-Live-x86_64-39-1.5.iso",
        sha256: "TBD",
        size_mb: 2000,
        arch: "x86_64",
        description: "Fedora 39 Workstation Live"
    ),

    # Alpine Linux (minimal, all architectures)
    ImageInfo(
        name: "alpine-3.19-x86_64",
        url: "https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/x86_64/alpine-standard-3.19.0-x86_64.iso",
        sha256: "TBD",
        size_mb: 170,
        arch: "x86_64",
        description: "Alpine Linux 3.19 (minimal)"
    ),

    ImageInfo(
        name: "alpine-3.19-aarch64",
        url: "https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/aarch64/alpine-standard-3.19.0-aarch64.iso",
        sha256: "TBD",
        size_mb: 160,
        arch: "aarch64",
        description: "Alpine Linux 3.19 ARM64 (minimal)"
    )
]

fn main():
    print "OS Image Download Script"
    print "========================"
    print ""

    # Create directories
    ensure_dir_exists(IMAGES_DIR)
    ensure_dir_exists("{IMAGES_DIR}/linux")

    # List available images
    print "Available images:"
    print ""

    var idx = 1
    for img in AVAILABLE_IMAGES:
        val status = if image_exists(img): "✓" else: " "
        print "{idx}. [{status}] {img.name}"
        print "     {img.description}"
        print "     Size: {img.size_mb} MB, Arch: {img.arch}"
        print ""
        idx = idx + 1

    # Interactive selection
    print "Enter image number to download (or 'all' for all images, 'q' to quit):"
    # Note: Simple doesn't have stdin yet, so this is a TODO
    # For now, just download the first small image

    print "Downloading recommended minimal image: alpine-3.19-x86_64"
    print ""

    val alpine_x64 = AVAILABLE_IMAGES[4]  # Alpine x86_64
    download_image(alpine_x64)

fn download_image(img: ImageInfo):
    val output_dir = "{IMAGES_DIR}/linux"
    val output_path = "{output_dir}/{img.name}.iso"

    if rt_file_exists(output_path):
        print "✓ {img.name} already downloaded"
        print "  Location: {output_path}"
        return

    print "Downloading {img.name}..."
    print "URL: {img.url}"
    print "Size: {img.size_mb} MB"
    print "Destination: {output_path}"
    print ""
    print "This may take a while depending on your internet connection..."
    print ""

    val success = download_file(img.url, output_path)

    if success:
        print ""
        print "✓ Download complete: {img.name}"
        print "  Location: {output_path}"
        print ""
        print "You can now use this image with QEMU:"
        print "  qemu-system-{img.arch} -cdrom {output_path} -m 2048"
    else:
        print "✗ Download failed"

fn download_file(url: text, output_path: text) -> bool:
    if command_exists("curl"):
        return download_with_curl(url, output_path)

    if command_exists("wget"):
        return download_with_wget(url, output_path)

    print "Error: Neither curl nor wget found!"
    false

fn download_with_curl(url: text, output_path: text) -> bool:
    val args = [
        "-L",
        "-C", "-",
        "--progress-bar",
        "-o", output_path,
        url
    ]

    val (stdout, stderr, exit_code) = rt_process_run("curl", args)
    exit_code == 0

fn download_with_wget(url: text, output_path: text) -> bool:
    val args = [
        "-c",
        "--progress=bar",
        "-O", output_path,
        url
    ]

    val (stdout, stderr, exit_code) = rt_process_run("wget", args)
    exit_code == 0

fn command_exists(cmd: text) -> bool:
    val (stdout, stderr, exit_code) = rt_process_run("which", [cmd])
    exit_code == 0

fn ensure_dir_exists(dir_path: text):
    if not rt_file_exists(dir_path):
        rt_dir_create(dir_path)

fn image_exists(img: ImageInfo) -> bool:
    val path = "{IMAGES_DIR}/linux/{img.name}.iso"
    rt_file_exists(path)
