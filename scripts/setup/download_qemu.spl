#!/usr/bin/env simple
# Simple QEMU Download Script
# Downloads and verifies QEMU source tarballs

use app.io.{rt_process_run, rt_file_exists, rt_file_read_text, rt_file_write_text, rt_dir_create}

# Configuration
val DOWNLOAD_DIR = "resources/qemu/downloads"
val CATALOG_PATH = "resources/qemu/catalog.sdn"

# QEMU versions (hardcoded for bootstrap)
val QEMU_8_2_0_URL = "https://download.qemu.org/qemu-8.2.0.tar.xz"
val QEMU_8_2_0_SHA256 = "4a9ce7a16a1606ee3def0e92ddfe1500ebb82bfd5d7216138d831f0b91f6b892"

fn main():
    print "QEMU Download Script"
    print "===================="
    print ""

    # Create download directory
    ensure_dir_exists(DOWNLOAD_DIR)

    # Download QEMU 8.2.0 (recommended version)
    val version = "8.2.0"
    val filename = "qemu-{version}.tar.xz"
    val output_path = "{DOWNLOAD_DIR}/{filename}"

    if rt_file_exists(output_path):
        print "✓ {filename} already exists"

        # Verify checksum
        if verify_checksum(output_path, QEMU_8_2_0_SHA256):
            print "✓ Checksum verified"
            return
        else:
            print "✗ Checksum mismatch, re-downloading..."
            delete_file(output_path)

    # Download
    print "Downloading QEMU {version}..."
    print "URL: {QEMU_8_2_0_URL}"
    print "Destination: {output_path}"
    print ""

    val success = download_file(QEMU_8_2_0_URL, output_path)

    if success:
        print ""
        print "✓ Download complete"

        # Verify checksum
        if verify_checksum(output_path, QEMU_8_2_0_SHA256):
            print "✓ Checksum verified"
            print ""
            print "Success! QEMU {version} downloaded to:"
            print "  {output_path}"
        else:
            print "✗ Checksum verification failed!"
            print "Expected: {QEMU_8_2_0_SHA256}"
            delete_file(output_path)
    else:
        print "✗ Download failed"

fn download_file(url: text, output_path: text) -> bool:
    # Try curl first
    if command_exists("curl"):
        return download_with_curl(url, output_path)

    # Fallback to wget
    if command_exists("wget"):
        return download_with_wget(url, output_path)

    print "Error: Neither curl nor wget found!"
    print "Please install one of them:"
    print "  Ubuntu/Debian: sudo apt install curl"
    print "  macOS: curl is pre-installed"
    print "  Windows: choco install curl"
    false

fn download_with_curl(url: text, output_path: text) -> bool:
    val args = [
        "-L",              # Follow redirects
        "-C", "-",         # Resume if interrupted
        "--progress-bar",  # Show progress
        "-o", output_path, # Output file
        url
    ]

    val (stdout, stderr, exit_code) = rt_process_run("curl", args)

    exit_code == 0

fn download_with_wget(url: text, output_path: text) -> bool:
    val args = [
        "-c",              # Resume if interrupted
        "--progress=bar",  # Show progress
        "-O", output_path, # Output file
        url
    ]

    val (stdout, stderr, exit_code) = rt_process_run("wget", args)

    exit_code == 0

fn verify_checksum(file_path: text, expected_sha256: text) -> bool:
    print "Verifying checksum..."

    # Try sha256sum
    if command_exists("sha256sum"):
        val (stdout, stderr, exit_code) = rt_process_run("sha256sum", [file_path])
        if exit_code == 0:
            val actual = stdout.split(" ")[0]
            return actual == expected_sha256

    # Try shasum (macOS)
    if command_exists("shasum"):
        val (stdout, stderr, exit_code) = rt_process_run("shasum", ["-a", "256", file_path])
        if exit_code == 0:
            val actual = stdout.split(" ")[0]
            return actual == expected_sha256

    print "Warning: No checksum tool found (sha256sum/shasum)"
    true  # Skip verification

fn command_exists(cmd: text) -> bool:
    val (stdout, stderr, exit_code) = rt_process_run("which", [cmd])
    exit_code == 0

fn ensure_dir_exists(dir_path: text):
    if not rt_file_exists(dir_path):
        rt_dir_create(dir_path)

fn delete_file(file_path: text):
    val (stdout, stderr, exit_code) = rt_process_run("rm", ["-f", file_path])
