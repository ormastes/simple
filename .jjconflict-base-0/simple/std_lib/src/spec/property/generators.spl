# Property Testing - Input Generators
# Feature #895: Generator framework for random test inputs

module std.spec.property.generators:
    use core.result.{Result, Ok, Err}
    use core.option.{Option, Some, None}
    
    # Generator trait - produces random values
    pub trait Generator<T>:
        fn generate(seed: i64) -> T
        fn shrink(value: T) -> [T]
    
    # Built-in generators for primitive types
    
    # Integer generators
    pub fn i64() -> impl Generator<i64>:
        return I64Generator()
    
    pub fn i64_range(min: i64, max: i64) -> impl Generator<i64>:
        return I64RangeGenerator(min: min, max: max)
    
    pub fn u64() -> impl Generator<u64>:
        return U64Generator()
    
    # Boolean generator
    pub fn bool() -> impl Generator<bool>:
        return BoolGenerator()
    
    # String generators
    pub fn string() -> impl Generator<String>:
        return StringGenerator()
    
    pub fn string_with_length(min: i64, max: i64) -> impl Generator<String>:
        return StringLengthGenerator(min: min, max: max)
    
    pub fn ascii() -> impl Generator<String>:
        return AsciiGenerator()
    
    # Collection generators
    pub fn list<T>(elem_gen: impl Generator<T>) -> impl Generator<[T]>:
        return ListGenerator(elem_gen: elem_gen)
    
    pub fn list_with_length<T>(
        elem_gen: impl Generator<T>,
        min: i64,
        max: i64
    ) -> impl Generator<[T]>:
        return ListLengthGenerator(
            elem_gen: elem_gen,
            min: min,
            max: max
        )
    
    # Option generator
    pub fn option<T>(elem_gen: impl Generator<T>) -> impl Generator<Option<T>>:
        return OptionGenerator(elem_gen: elem_gen)
    
    # Result generator
    pub fn result<T, E>(
        ok_gen: impl Generator<T>,
        err_gen: impl Generator<E>
    ) -> impl Generator<Result<T, E>>:
        return ResultGenerator(ok_gen: ok_gen, err_gen: err_gen)
    
    # Generator combinators
    
    # Choose one of several generators
    pub fn one_of<T>(generators: [impl Generator<T>]) -> impl Generator<T>:
        return OneOfGenerator(generators: generators)
    
    # Frequency-based choice
    pub fn frequency<T>(weighted: [(i64, impl Generator<T>)]) -> impl Generator<T>:
        return FrequencyGenerator(weighted: weighted)
    
    # Map generator output
    pub fn map<T, U>(
        gen: impl Generator<T>,
        f: fn(T) -> U
    ) -> impl Generator<U>:
        return MappedGenerator(gen: gen, f: f)
    
    # Bind/flatMap for dependent generation
    pub fn flat_map<T, U>(
        gen: impl Generator<T>,
        f: fn(T) -> impl Generator<U>
    ) -> impl Generator<U>:
        return FlatMappedGenerator(gen: gen, f: f)
    
    # Filter generated values
    pub fn filter<T>(
        gen: impl Generator<T>,
        predicate: fn(T) -> bool
    ) -> impl Generator<T>:
        return FilteredGenerator(gen: gen, predicate: predicate, max_tries: 100)
    
    # Tuple generators
    pub fn tuple2<T1, T2>(
        gen1: impl Generator<T1>,
        gen2: impl Generator<T2>
    ) -> impl Generator<(T1, T2)>:
        return Tuple2Generator(gen1: gen1, gen2: gen2)
    
    pub fn tuple3<T1, T2, T3>(
        gen1: impl Generator<T1>,
        gen2: impl Generator<T2>,
        gen3: impl Generator<T3>
    ) -> impl Generator<(T1, T2, T3)>:
        return Tuple3Generator(gen1: gen1, gen2: gen2, gen3: gen3)
    
    # Concrete generator implementations
    
    struct I64Generator:
        pass
    
    impl Generator<i64> for I64Generator:
        fn generate(seed: i64) -> i64:
            # Simple LCG random number generator
            let a = 1103515245
            let c = 12345
            let m = 2147483648
            return ((a * seed + c) % m)
        
        fn shrink(value: i64) -> [i64]:
            if value == 0:
                return []
            let candidates = [0, value / 2]
            if value < 0:
                candidates.push(value + 1)
            else:
                candidates.push(value - 1)
            return candidates
    
    struct I64RangeGenerator:
        min: i64
        max: i64
    
    impl Generator<i64> for I64RangeGenerator:
        fn generate(seed: i64) -> i64:
            let range = self.max - self.min
            let raw = I64Generator().generate(seed)
            return self.min + (raw % range)
        
        fn shrink(value: i64) -> [i64]:
            # Shrink towards minimum value in range
            if value == self.min:
                return []
            return [self.min, (self.min + value) / 2]
    
    struct BoolGenerator:
        pass
    
    impl Generator<bool> for BoolGenerator:
        fn generate(seed: i64) -> bool:
            return (I64Generator().generate(seed) % 2) == 0
        
        fn shrink(value: bool) -> [bool]:
            # Shrink true to false
            if value:
                return [false]
            return []
    
    struct StringGenerator:
        pass
    
    impl Generator<String> for StringGenerator:
        fn generate(seed: i64) -> String:
            let length_gen = I64RangeGenerator(min: 0, max: 20)
            let length = length_gen.generate(seed)
            let mut result = ""
            for i in 0..length:
                let char_code = I64RangeGenerator(min: 97, max: 123).generate(seed + i)
                result += char.from_code(char_code)
            return result
        
        fn shrink(value: String) -> [String]:
            if value.length() == 0:
                return []
            # Shrink by removing characters
            return [
                "",
                value.substring(0, value.length() / 2),
                value.substring(1, value.length())
            ]
    
    struct U64Generator:
        pass

    impl Generator<u64> for U64Generator:
        fn generate(seed: i64) -> u64:
            let raw = I64Generator().generate(seed)
            return raw.abs() as u64

        fn shrink(value: u64) -> [u64]:
            if value == 0:
                return []
            return [0, value / 2, value - 1]

    struct AsciiGenerator:
        pass

    impl Generator<String> for AsciiGenerator:
        fn generate(seed: i64) -> String:
            let length_gen = I64RangeGenerator(min: 0, max: 20)
            let length = length_gen.generate(seed)
            let mut result = ""
            for i in 0..length:
                # ASCII printable characters: 32-126
                let char_code = I64RangeGenerator(min: 32, max: 127).generate(seed + i)
                result += char.from_code(char_code)
            return result

        fn shrink(value: String) -> [String]:
            if value.length() == 0:
                return []
            return [
                "",
                value.substring(0, value.length() / 2),
                value.substring(1, value.length())
            ]

    struct StringLengthGenerator:
        min: i64
        max: i64

    impl Generator<String> for StringLengthGenerator:
        fn generate(seed: i64) -> String:
            let length_gen = I64RangeGenerator(min: self.min, max: self.max)
            let length = length_gen.generate(seed)
            let mut result = ""
            for i in 0..length:
                let char_code = I64RangeGenerator(min: 97, max: 123).generate(seed + i)
                result += char.from_code(char_code)
            return result

        fn shrink(value: String) -> [String]:
            if value.length() <= self.min:
                return []
            return [
                value.substring(0, self.min),
                value.substring(0, value.length() / 2),
                value.substring(1, value.length())
            ]

    struct ListGenerator<T>:
        elem_gen: impl Generator<T>

    impl<T> Generator<[T]> for ListGenerator<T>:
        fn generate(seed: i64) -> [T]:
            let size_gen = I64RangeGenerator(min: 0, max: 20)
            let size = size_gen.generate(seed)
            let mut result = []
            for i in 0..size:
                result.push(self.elem_gen.generate(seed + i))
            return result

        fn shrink(value: [T]) -> [[T]]:
            if value.is_empty():
                return []
            let mut candidates = [[]]
            let mid = value.length() / 2
            if mid > 0:
                candidates.push(value[0..mid])
                candidates.push(value[mid..value.length()])
            candidates.push(value[1..value.length()])
            if value.length() > 1:
                candidates.push(value[0..value.length()-1])
            return candidates

    struct ListLengthGenerator<T>:
        elem_gen: impl Generator<T>
        min: i64
        max: i64

    impl<T> Generator<[T]> for ListLengthGenerator<T>:
        fn generate(seed: i64) -> [T]:
            let size_gen = I64RangeGenerator(min: self.min, max: self.max)
            let size = size_gen.generate(seed)
            let mut result = []
            for i in 0..size:
                result.push(self.elem_gen.generate(seed + i))
            return result

        fn shrink(value: [T]) -> [[T]]:
            if value.length() <= self.min:
                return []
            let mut candidates = []
            let mid = (self.min + value.length()) / 2
            if mid > self.min:
                candidates.push(value[0..mid])
            if value.length() > self.min:
                candidates.push(value[0..value.length()-1])
            return candidates

    struct OptionGenerator<T>:
        elem_gen: impl Generator<T>

    impl<T> Generator<Option<T>> for OptionGenerator<T>:
        fn generate(seed: i64) -> Option<T>:
            let bool_gen = BoolGenerator()
            if bool_gen.generate(seed):
                return Some(self.elem_gen.generate(seed + 1))
            return None

        fn shrink(value: Option<T>) -> [Option<T>]:
            match value:
                Some(_) -> return [None]
                None -> return []

    struct ResultGenerator<T, E>:
        ok_gen: impl Generator<T>
        err_gen: impl Generator<E>

    impl<T, E> Generator<Result<T, E>> for ResultGenerator<T, E>:
        fn generate(seed: i64) -> Result<T, E>:
            let bool_gen = BoolGenerator()
            if bool_gen.generate(seed):
                return Ok(self.ok_gen.generate(seed + 1))
            return Err(self.err_gen.generate(seed + 1))

        fn shrink(value: Result<T, E>) -> [Result<T, E>]:
            # Try to shrink to Ok with default value
            match value:
                Err(_) -> return [Ok(self.ok_gen.generate(0))]
                Ok(_) -> return []

    struct OneOfGenerator<T>:
        generators: [impl Generator<T>]

    impl<T> Generator<T> for OneOfGenerator<T>:
        fn generate(seed: i64) -> T:
            let idx_gen = I64RangeGenerator(min: 0, max: self.generators.length())
            let idx = idx_gen.generate(seed)
            return self.generators[idx].generate(seed)

        fn shrink(value: T) -> [T]:
            # Try first generator's shrinks
            if !self.generators.is_empty():
                return self.generators[0].shrink(value)
            return []

    struct FrequencyGenerator<T>:
        weighted: [(i64, impl Generator<T>)]

    impl<T> Generator<T> for FrequencyGenerator<T>:
        fn generate(seed: i64) -> T:
            # Calculate total weight
            let mut total = 0
            for (weight, _) in self.weighted:
                total += weight

            # Pick random index based on weight
            let rand_gen = I64RangeGenerator(min: 0, max: total)
            let mut rand = rand_gen.generate(seed)

            for (weight, gen) in self.weighted:
                if rand < weight:
                    return gen.generate(seed)
                rand -= weight

            # Fallback to last generator
            return self.weighted[self.weighted.length() - 1].1.generate(seed)

        fn shrink(value: T) -> [T]:
            # Try first generator's shrinks
            if !self.weighted.is_empty():
                return self.weighted[0].1.shrink(value)
            return []

    struct MappedGenerator<T, U>:
        gen: impl Generator<T>
        f: fn(T) -> U

    impl<T, U> Generator<U> for MappedGenerator<T, U>:
        fn generate(seed: i64) -> U:
            let value = self.gen.generate(seed)
            return self.f(value)

        fn shrink(value: U) -> [U]:
            # Cannot shrink without inverse of f
            return []

    struct FilteredGenerator<T>:
        gen: impl Generator<T>
        predicate: fn(T) -> bool
        max_tries: i64

    impl<T> Generator<T> for FilteredGenerator<T>:
        fn generate(seed: i64) -> T:
            # Try up to max_tries times to generate a value that passes predicate
            for i in 0..self.max_tries:
                let value = self.gen.generate(seed + i)
                if self.predicate(value):
                    return value

            # Fallback: return last attempt even if it doesn't pass
            return self.gen.generate(seed + self.max_tries)

        fn shrink(value: T) -> [T]:
            let candidates = self.gen.shrink(value)
            # Filter shrinks to only those that pass predicate
            return candidates.filter(|c| self.predicate(c))

    struct FlatMappedGenerator<T, U>:
        gen: impl Generator<T>
        f: fn(T) -> impl Generator<U>

    impl<T, U> Generator<U> for FlatMappedGenerator<T, U>:
        fn generate(seed: i64) -> U:
            let value = self.gen.generate(seed)
            let next_gen = self.f(value)
            return next_gen.generate(seed + 1)

        fn shrink(value: U) -> [U]:
            # Cannot shrink without knowing T
            return []

    struct Tuple2Generator<T1, T2>:
        gen1: impl Generator<T1>
        gen2: impl Generator<T2>

    impl<T1, T2> Generator<(T1, T2)> for Tuple2Generator<T1, T2>:
        fn generate(seed: i64) -> (T1, T2):
            return (
                self.gen1.generate(seed),
                self.gen2.generate(seed + 1)
            )

        fn shrink(value: (T1, T2)) -> [(T1, T2)]:
            let mut candidates = []
            # Shrink first component
            for c1 in self.gen1.shrink(value.0):
                candidates.push((c1, value.1))
            # Shrink second component
            for c2 in self.gen2.shrink(value.1):
                candidates.push((value.0, c2))
            return candidates

    struct Tuple3Generator<T1, T2, T3>:
        gen1: impl Generator<T1>
        gen2: impl Generator<T2>
        gen3: impl Generator<T3>

    impl<T1, T2, T3> Generator<(T1, T2, T3)> for Tuple3Generator<T1, T2, T3>:
        fn generate(seed: i64) -> (T1, T2, T3):
            return (
                self.gen1.generate(seed),
                self.gen2.generate(seed + 1),
                self.gen3.generate(seed + 2)
            )

        fn shrink(value: (T1, T2, T3)) -> [(T1, T2, T3)]:
            let mut candidates = []
            # Shrink each component
            for c1 in self.gen1.shrink(value.0):
                candidates.push((c1, value.1, value.2))
            for c2 in self.gen2.shrink(value.1):
                candidates.push((value.0, c2, value.2))
            for c3 in self.gen3.shrink(value.2):
                candidates.push((value.0, value.1, c3))
            return candidates

    # Example usage:
    # let gen = generators.i64_range(0, 100)
    # let value = gen.generate(42)  # Returns i64 in [0, 100)
