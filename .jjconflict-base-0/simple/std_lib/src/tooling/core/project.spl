# Multi-Language Project Detection & Configuration
# Detects language roots, reads config files, manages project structure

use host.async_nogc_mut.io.fs
use core.json
use core.result.{Result, Ok, Err}

# Project language type
pub enum Language:
    Simple
    Rust
    Python
    JavaScript
    TypeScript
    Go
    C
    Cpp

# Project configuration
pub class ProjectConfig:
    pub name: String
    pub version: String
    pub root: String
    pub languages: List[LanguageConfig]
    pub build_dir: String
    pub test_dir: String
    pub deploy_dir: String

    pub fn new(root: String): ProjectConfig =
        """Create default project configuration.

        Args:
            root: Project root directory

        Returns:
            Default configuration
        """
        ProjectConfig {
            name: "unnamed",
            version: "0.1.0",
            root: root,
            languages: [],
            build_dir: "target",
            test_dir: "tests",
            deploy_dir: "dist"
        }

    pub fn load_from_file(path: String): Result[ProjectConfig, String] =
        """Load project config from simple.toml.

        Args:
            path: Path to simple.toml

        Returns:
            Loaded configuration or error
        """
        # TODO: Implement TOML parsing when available
        # For now, return default config
        let config = ProjectConfig.new(".")
        Ok(config)

    pub fn add_language(self, lang_config: LanguageConfig):
        """Add language configuration.

        Args:
            lang_config: Language configuration to add
        """
        self.languages.append(lang_config)

    pub fn get_language_config(self, language: Language): LanguageConfig? =
        """Get configuration for specific language.

        Args:
            language: Language to get config for

        Returns:
            Language config if found
        """
        for config in self.languages:
            if config.language == language:
                return some(config)
        none

# Language-specific configuration
pub class LanguageConfig:
    pub language: Language
    pub root: String
    pub source_dirs: List[String]
    pub exclude_patterns: List[String]
    pub compiler_flags: List[String]
    pub test_command: String

    pub fn new(language: Language, root: String): LanguageConfig =
        """Create language configuration.

        Args:
            language: Language type
            root: Language root directory

        Returns:
            Default language configuration
        """
        LanguageConfig {
            language: language,
            root: root,
            source_dirs: ["src"],
            exclude_patterns: ["target", "node_modules", "__pycache__", ".git"],
            compiler_flags: [],
            test_command: ""
        }

# Project detector - finds language roots in project
pub class ProjectDetector:
    pub root: String

    pub fn new(root: String): ProjectDetector =
        """Create project detector.

        Args:
            root: Project root directory
        """
        ProjectDetector { root: root }

    pub fn detect_all_languages(self): List[LanguageConfig] =
        """Detect all languages in project.

        Returns:
            List of detected language configurations

        Example:
            let detector = ProjectDetector.new(".")
            let languages = detector.detect_all_languages()
            for config in languages:
                print(f"Found {config.language} at {config.root}")
        """
        let configs: List[LanguageConfig] = []

        # Detect Simple
        if self.has_simple_project():
            configs.append(LanguageConfig.new(Language::Simple, self.root))

        # Detect Rust
        let rust_roots = self.find_cargo_projects()
        for root in rust_roots:
            configs.append(LanguageConfig.new(Language::Rust, root))

        # Detect Python
        let python_roots = self.find_python_projects()
        for root in python_roots:
            configs.append(LanguageConfig.new(Language::Python, root))

        # Detect JavaScript/TypeScript
        let js_roots = self.find_javascript_projects()
        for root in js_roots:
            if self.has_typescript(root):
                configs.append(LanguageConfig.new(Language::TypeScript, root))
            else:
                configs.append(LanguageConfig.new(Language::JavaScript, root))

        # Detect Go
        let go_roots = self.find_go_projects()
        for root in go_roots:
            configs.append(LanguageConfig.new(Language::Go, root))

        configs

    pub fn has_simple_project(self): bool =
        """Check if directory contains Simple project.

        Returns:
            True if simple.toml or .spl files exist
        """
        self.file_exists("simple.toml") or self.has_files_with_extension(".spl")

    pub fn find_cargo_projects(self): List[String] =
        """Find all Rust/Cargo projects.

        Returns:
            List of directories containing Cargo.toml
        """
        self.find_files_named("Cargo.toml")

    pub fn find_python_projects(self): List[String] =
        """Find all Python projects.

        Returns:
            List of directories containing setup.py, pyproject.toml, or requirements.txt
        """
        let roots: List[String] = []

        roots.extend(self.find_files_named("setup.py"))
        roots.extend(self.find_files_named("pyproject.toml"))
        roots.extend(self.find_files_named("requirements.txt"))

        # Deduplicate
        self.deduplicate_paths(roots)

    pub fn find_javascript_projects(self): List[String] =
        """Find all JavaScript/Node projects.

        Returns:
            List of directories containing package.json
        """
        self.find_files_named("package.json")

    pub fn find_go_projects(self): List[String] =
        """Find all Go projects.

        Returns:
            List of directories containing go.mod
        """
        self.find_files_named("go.mod")

    pub fn has_typescript(self, root: String): bool =
        """Check if project uses TypeScript.

        Args:
            root: Project root to check

        Returns:
            True if tsconfig.json exists
        """
        self.file_exists_in(root, "tsconfig.json")

    # Helper methods (simplified - full implementation would use fs module)

    fn file_exists(self, name: String): bool =
        """Check if file exists in project root."""
        # TODO: Use fs module when available
        false

    fn file_exists_in(self, dir: String, name: String): bool =
        """Check if file exists in directory."""
        # TODO: Use fs module
        false

    fn has_files_with_extension(self, ext: String): bool =
        """Check if any files with extension exist."""
        # TODO: Use fs module
        false

    fn find_files_named(self, name: String): List[String] =
        """Find all files with given name recursively."""
        # TODO: Use fs module for recursive search
        []

    fn deduplicate_paths(self, paths: List[String]): List[String] =
        """Remove duplicate paths."""
        # TODO: Implement deduplication
        paths

# Project context - unified view of multi-language project
pub class ProjectContext:
    pub config: ProjectConfig
    pub languages: List[LanguageConfig]

    pub fn new(root: String): ProjectContext =
        """Create project context.

        Args:
            root: Project root directory

        Returns:
            Project context with auto-detected languages

        Example:
            let project = ProjectContext.new(".")
            for lang_config in project.languages:
                print(f"Language: {lang_config.language}")
                print(f"Root: {lang_config.root}")
        """
        let detector = ProjectDetector.new(root)
        let languages = detector.detect_all_languages()

        let config = ProjectConfig.new(root)
        for lang_config in languages:
            config.add_language(lang_config)

        ProjectContext {
            config: config,
            languages: languages
        }

    pub fn from_config_file(path: String): Result[ProjectContext, String] =
        """Load project from simple.toml.

        Args:
            path: Path to simple.toml

        Returns:
            Project context or error
        """
        match ProjectConfig.load_from_file(path):
            Ok(config):
                Ok(ProjectContext {
                    config: config,
                    languages: config.languages
                })
            Err(err):
                Err(err)

    pub fn get_build_dir(self): String =
        """Get build output directory.

        Returns:
            Build directory path
        """
        self.config.build_dir

    pub fn get_test_dir(self): String =
        """Get test directory.

        Returns:
            Test directory path
        """
        self.config.test_dir

    pub fn get_language_roots(self): Dict[Language, String] =
        """Get map of languages to their root directories.

        Returns:
            Dictionary mapping languages to roots
        """
        let roots: Dict[Language, String] = {}
        for lang_config in self.languages:
            roots[lang_config.language] = lang_config.root
        roots

    pub fn has_language(self, language: Language): bool =
        """Check if project uses given language.

        Args:
            language: Language to check

        Returns:
            True if language is used in project
        """
        for lang_config in self.languages:
            if lang_config.language == language:
                return true
        false

    pub fn get_all_source_files(self, language: Language): List[String] =
        """Get all source files for given language.

        Args:
            language: Language to get files for

        Returns:
            List of source file paths
        """
        # TODO: Implement recursive file discovery with exclusion patterns
        []
