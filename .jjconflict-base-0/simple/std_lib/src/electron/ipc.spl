# Electron IPC (Inter-Process Communication)
# Communication between main and renderer processes

# External FFI declarations
extern fn electron_ipc_send(channel: String, data_json: String): void
extern fn electron_ipc_send_sync(channel: String, data_json: String): String
extern fn electron_ipc_on(channel: String, callback_id: i64): void
extern fn electron_ipc_remove_listener(channel: String, callback_id: i64): void

# Callback registry
let ipc_callbacks: Dict[String, List[fn(data: String): void]] = {}
let next_callback_id: i64 = 0

# Send asynchronous message
pub fn send(channel: String, data: String):
    """Send asynchronous IPC message.

    Args:
        channel: Channel name
        data: JSON-serialized data

    Example:
        ipc.send("window-action", '{"action":"minimize"}')
    """
    electron_ipc_send(channel, data)

# Send synchronous message and wait for response
pub fn send_sync(channel: String, data: String): String =
    """Send synchronous IPC message and wait for response.

    Args:
        channel: Channel name
        data: JSON-serialized data

    Returns:
        Response from other process (JSON string)

    Example:
        response = ipc.send_sync("get-config", '{"key":"theme"}')
        print("Config: {response}")
    """
    electron_ipc_send_sync(channel, data)

# Register message handler
pub fn on(channel: String, handler: fn(data: String): void):
    """Register handler for IPC messages.

    Args:
        channel: Channel name to listen on
        handler: Callback function receiving message data

    Example:
        ipc.on("process-file", fn(data):
            # data is JSON string
            print("Processing: {data}")
        )
    """
    # Store callback
    if not ipc_callbacks.has_key(channel):
        ipc_callbacks[channel] = []

    ipc_callbacks[channel].append(handler)

    # Register with native
    let callback_id = next_callback_id
    next_callback_id = next_callback_id + 1

    electron_ipc_on(channel, callback_id)

# Remove message handler
pub fn off(channel: String):
    """Remove all handlers for a channel.

    Example:
        ipc.off("process-file")
    """
    if ipc_callbacks.has_key(channel):
        ipc_callbacks.remove(channel)

    # Note: Callback IDs would need tracking for proper removal
    # Simplified version removes all

# Trigger callback from FFI
pub fn _trigger_callback(channel: String, callback_id: i64, data: String):
    """Internal: Called by FFI when message received."""
    if ipc_callbacks.has_key(channel):
        handlers = ipc_callbacks[channel]
        if callback_id < handlers.len():
            handler = handlers[callback_id]
            handler(data)

# Convenience wrappers for structured data
pub fn send_message(channel: String, message_type: String, payload: String):
    """Send structured message.

    Wraps data in standard format: {"type": ..., "payload": ...}
    """
    let json = '{"type":"' + message_type + '","payload":' + payload + '}'
    send(channel, json)

pub fn on_message(channel: String, handler: fn(message_type: String, payload: String): void):
    """Register handler for structured messages.

    Expects messages in format: {"type": ..., "payload": ...}
    """
    on(channel, fn(data):
        # Parse message type and payload
        # Simplified JSON parsing (assumes valid format)
        if data.contains('"type":"') and data.contains('"payload":'):
            # Extract type
            let type_start = data.index_of('"type":"') + 8
            let type_end = data.index_of('"', type_start)
            let msg_type = data.substring(type_start, type_end)

            # Extract payload
            let payload_start = data.index_of('"payload":') + 10
            let payload_end = data.last_index_of('}')
            let payload = data.substring(payload_start, payload_end)

            handler(msg_type, payload)
    )
