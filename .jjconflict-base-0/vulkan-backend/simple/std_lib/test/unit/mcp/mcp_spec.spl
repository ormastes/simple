# MCP Protocol Tests
# Tests for MCP (Minimal Code Preview) core functionality

use spec.*
use mcp.*

describe "MCP Types":
    it "creates block marks":
        mark = BlockMark.ClassCollapsed
        expect(mark).to_equal(BlockMark.ClassCollapsed)

    it "converts block marks to strings":
        class_mark = block_mark_to_string(BlockMark.ClassCollapsed)
        expect(class_mark).to_equal("C>")

        func_mark = block_mark_to_string(BlockMark.FunctionExpanded)
        expect(func_mark).to_equal("F▼")

        virtual_mark = block_mark_to_string(BlockMark.VirtualInfo)
        expect(virtual_mark).to_equal("V•")

describe "MCP Parser":
    it "parses public class":
        source = "pub class User:\n    name: String"
        symbols = parse_file(source)

        expect(symbols.len()).to_equal(1)
        expect(symbols[0].kind).to_equal(SymbolKind.Class)
        expect(symbols[0].name).to_equal("User")
        expect(symbols[0].visibility).to_equal(Visibility.Public)

    it "parses public function":
        source = "pub fn login(name: String) -> bool:\n    return true"
        symbols = parse_file(source)

        expect(symbols.len()).to_equal(1)
        expect(symbols[0].kind).to_equal(SymbolKind.Function)
        expect(symbols[0].name).to_equal("login")
        expect(symbols[0].visibility).to_equal(Visibility.Public)

    it "parses trait":
        source = "trait Display:\n    fn show() -> String"
        symbols = parse_file(source)

        expect(symbols.len()).to_equal(1)
        expect(symbols[0].kind).to_equal(SymbolKind.Trait)
        expect(symbols[0].name).to_equal("Display")

    it "parses pointcut":
        source = "pointcut logging @ User.login"
        symbols = parse_file(source)

        expect(symbols.len()).to_equal(1)
        expect(symbols[0].kind).to_equal(SymbolKind.Pointcut)

    it "filters public symbols":
        source = "pub class User:\n    name: String\n\nclass Internal:\n    data: i64"
        symbols = parse_file(source)
        pub_symbols = filter_public_symbols(symbols)

        expect(symbols.len()).to_equal(2)
        expect(pub_symbols.len()).to_equal(1)
        expect(pub_symbols[0].name).to_equal("User")

describe "MCP Formatter":
    it "formats collapsed class":
        source = "pub class User:\n    name: String"
        symbols = parse_file(source)
        text = format_symbols(symbols, false)

        expect(text).to_contain("C> pub class User")
        expect(text).to_contain("{ … }")

    it "formats collapsed function":
        source = "pub fn login(name: String) -> bool:\n    return true"
        symbols = parse_file(source)
        text = format_symbols(symbols, false)

        expect(text).to_contain("F> pub fn login")
        expect(text).to_contain("{ … }")

    it "generates virtual info":
        source = "pub fn foo():\n    pass\n\nfn bar():\n    pass"
        symbols = parse_file(source)
        text = format_symbols(symbols, true)

        expect(text).to_contain("V• methods:")

    it "expands symbol signature":
        source = "pub fn login(name: String) -> bool:\n    return true"
        symbols = parse_file(source)
        symbol = symbols[0]
        text = format_single_symbol(symbol, "signature")

        expect(text).to_contain("F▼")
        expect(text).not_to_contain("{ … }")

describe "MCP JSON Output":
    it "generates simple JSON":
        text = "C> pub class User { … }"
        json = to_json(text, None)

        expect(json).to_contain("\"text\":")
        expect(json).to_contain("C> pub class User")
        expect(json).not_to_contain("\"meta\":")

    it "generates JSON with metadata":
        text = "C> pub class User { … }"
        meta = McpMetadata.default()
        json = to_json(text, Some(meta))

        expect(json).to_contain("\"text\":")
        expect(json).to_contain("\"meta\":")
        expect(json).to_contain("\"mode\": \"mcp\"")

    it "escapes JSON strings":
        text = "Line with \"quotes\" and \n newline"
        json = to_json(text, None)

        expect(json).to_contain("\\\"")
        expect(json).to_contain("\\n")

describe "MCP API":
    it "generates MCP from source":
        source = "pub class User:\n    name: String\n\npub fn login():\n    pass"
        text = mcp_from_source(source, false)

        expect(text).to_contain("C> pub class User")
        expect(text).to_contain("F> pub fn login")

    it "finds symbol by name":
        source = "pub class User:\n    name: String"
        symbols = parse_file(source)
        found = find_symbol(symbols, "User")

        expect(found.is_some()).to_equal(true)
        expect(found.unwrap().name).to_equal("User")
