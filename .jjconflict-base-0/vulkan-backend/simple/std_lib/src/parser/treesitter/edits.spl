# Edit tracking for incremental parsing
# Tracks document changes to enable efficient reparse

import core.{Option, Result}
import parser.treesitter.tree.{Span, NodeId, Node, Tree}

# Source position (line, column)
struct Point:
    line: i64
    column: i64

    fn new(line: i64, column: i64) -> Point:
        return Point(line: line, column: column)

    fn compare(self, other: Point) -> i64:
        if self.line != other.line:
            return self.line - other.line
        else:
            return self.column - other.column

    fn is_before(self, other: Point) -> bool:
        return self.compare(other) < 0

    fn is_after(self, other: Point) -> bool:
        return self.compare(other) > 0

    fn equals(self, other: Point) -> bool:
        return self.line == other.line and self.column == other.column

# Document edit (replacement of text range)
struct InputEdit:
    # Old document positions
    start_byte: i64
    old_end_byte: i64
    # New document positions
    new_end_byte: i64
    # Position tracking
    start_point: Point
    old_end_point: Point
    new_end_point: Point

    fn new(
        start_byte: i64,
        old_end_byte: i64,
        new_end_byte: i64,
        start_point: Point,
        old_end_point: Point,
        new_end_point: Point
    ) -> InputEdit:
        return InputEdit(
            start_byte: start_byte,
            old_end_byte: old_end_byte,
            new_end_byte: new_end_byte,
            start_point: start_point,
            old_end_point: old_end_point,
            new_end_point: new_end_point
        )

    # Check if this edit affects a span
    fn affects_span(self, span: Span) -> bool:
        # Edit starts before span ends AND edit ends after span starts
        return self.start_byte < span.end_byte and self.old_end_byte > span.start_byte

    # Adjust a byte offset after this edit
    fn adjust_byte(self, byte: i64) -> i64:
        if byte < self.start_byte:
            # Before edit: unchanged
            return byte
        elif byte <= self.old_end_byte:
            # Inside old range: map to edit start
            return self.start_byte
        else:
            # After edit: shift by delta
            let delta = self.new_end_byte - self.old_end_byte
            return byte + delta

    # Adjust a point after this edit
    fn adjust_point(self, point: Point) -> Point:
        if point.is_before(self.start_point):
            # Before edit: unchanged
            return point
        elif point.is_before(self.old_end_point) or point.equals(self.old_end_point):
            # Inside old range: map to edit start
            return self.start_point
        else:
            # After edit: shift by delta
            if self.old_end_point.line == self.new_end_point.line:
                # Single-line edit
                if point.line == self.old_end_point.line:
                    let column_delta = self.new_end_point.column - self.old_end_point.column
                    return Point(line: point.line, column: point.column + column_delta)
                else:
                    return point
            else:
                # Multi-line edit
                let line_delta = self.new_end_point.line - self.old_end_point.line
                if point.line == self.old_end_point.line:
                    # Same line as old end: adjust both line and column
                    let new_line = point.line + line_delta
                    let column_offset = point.column - self.old_end_point.column
                    let new_column = self.new_end_point.column + column_offset
                    return Point(line: new_line, column: new_column)
                else:
                    # Different line: just adjust line
                    return Point(line: point.line + line_delta, column: point.column)

# Compute edits between two texts
fn compute_edits(old_text: str, new_text: str) -> [InputEdit]:
    # Phase 2.1: Simple full-document replacement
    # Phase 2.2: Myers diff for minimal edits (TODO)

    if old_text == new_text:
        # No changes
        return []

    # Count lines in old text
    let old_lines = count_lines(old_text)
    let old_end_point = compute_end_point(old_text)

    # Count lines in new text
    let new_lines = count_lines(new_text)
    let new_end_point = compute_end_point(new_text)

    # Full document replacement
    return [InputEdit.new(
        start_byte: 0,
        old_end_byte: old_text.len(),
        new_end_byte: new_text.len(),
        start_point: Point.new(1, 1),
        old_end_point: old_end_point,
        new_end_point: new_end_point
    )]

# Count lines in text
fn count_lines(text: str) -> i64:
    let mut count = 1
    let mut i = 0
    while i < text.len():
        if text[i] == '\n':
            count = count + 1
        i = i + 1
    return count

# Compute end point (line, column) of text
fn compute_end_point(text: str) -> Point:
    if text.len() == 0:
        return Point.new(1, 1)

    let mut line = 1
    let mut column = 1
    let mut i = 0

    while i < text.len():
        if text[i] == '\n':
            line = line + 1
            column = 1
        else:
            column = column + 1
        i = i + 1

    return Point.new(line, column)

# Find nodes affected by edits
fn find_affected_nodes(tree: Tree, edits: [InputEdit]) -> [NodeId]:
    let mut affected: [NodeId] = []

    # For Phase 2.1: If any edit exists, mark root as affected
    # For Phase 2.2: Walk tree and check each node's span

    if edits.len() > 0:
        # Simple approach: entire tree is affected
        affected.push(tree.root_node)

    return affected

# Find reparse boundary (nearest stable parent node)
fn find_reparse_boundary(tree: Tree, affected_nodes: [NodeId]) -> Option[NodeId]:
    # Phase 2.1: Always reparse from root
    # Phase 2.2: Find minimal stable parent

    if affected_nodes.len() > 0:
        return Some(tree.root_node)
    else:
        return None

# Apply edits to a span
fn apply_edits_to_span(span: Span, edits: [InputEdit]) -> Span:
    let mut new_span = span

    for edit in edits:
        # Adjust start
        let new_start_byte = edit.adjust_byte(new_span.start_byte)
        let new_start_point = edit.adjust_point(Point.new(new_span.start_line, new_span.start_column))

        # Adjust end
        let new_end_byte = edit.adjust_byte(new_span.end_byte)
        let new_end_point = edit.adjust_point(Point.new(new_span.end_line, new_span.end_column))

        new_span = Span(
            start_byte: new_start_byte,
            end_byte: new_end_byte,
            start_line: new_start_point.line,
            end_line: new_end_point.line,
            start_column: new_start_point.column,
            end_column: new_end_point.column
        )

    return new_span
