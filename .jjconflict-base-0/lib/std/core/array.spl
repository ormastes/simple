# Array[T, N] - Fixed-size array
# Syntax: [T; N] creates an Array
# Implements collection traits except Growable (fixed size)

use core.traits.*
use core.collections.*

# ============================================
# Array Type Definition
# ============================================

struct Array[T, const N: usize]:
    data: [T; N]

# ============================================
# Constructors
# ============================================

impl Array[T, const N: usize]:
    # Create with default values
    fn new() -> Array[T, N] where T: Default:
        Array { data: [T::default(); N] }

    # Create from inline array
    fn of(items: [T; N]) -> Array[T, N]:
        Array { data: items }

    # Create filled with single value
    fn filled(value: T) -> Array[T, N] where T: Clone:
        var data: [T; N]
        for i in 0..N:
            data[i] = value.clone()
        Array { data: data }

    # Create filled with function
    fn filled_with(f: fn(usize) -> T) -> Array[T, N]:
        var data: [T; N]
        for i in 0..N:
            data[i] = f(i)
        Array { data: data }

    # Create zeroed (for numeric types)
    fn zeroed() -> Array[T, N] where T: Default:
        Array::new()

# ============================================
# Len trait
# ============================================

impl Len for Array[T, const N: usize]:
    fn len(self) -> usize:
        N

# ============================================
# Capacity trait (always full for fixed arrays)
# ============================================

impl Capacity for Array[T, const N: usize]:
    fn capacity(self) -> usize:
        N

    fn is_full(self) -> bool:
        true  # Fixed arrays are always "full"

# ============================================
# Iterable trait
# ============================================

impl Iterable[T] for Array[T, const N: usize]:
    type Iter = ArrayIter[T, N]

    fn iter(self) -> Self::Iter:
        ArrayIter { array: self, index: 0 }

    fn into_iter(self) -> Self::Iter:
        self.iter()

# ============================================
# Collection trait
# ============================================

impl Collection[T] for Array[T, const N: usize]

# ============================================
# Sequence trait
# ============================================

impl Sequence[T] for Array[T, const N: usize]:
    fn get(self, idx: usize) -> Option[T]:
        if idx < N:
            Some(self.data[idx])
        else:
            None

    fn slice(self, start: usize, end: usize) -> Slice[T]:
        if start > end or end > N:
            Slice::empty()
        else:
            danger:
                Slice::new(&self.data[start] as *T, end - start)

# ============================================
# MutSequence trait
# ============================================

impl MutSequence[T] for Array[T, const N: usize]:
    fn get_mut(self, idx: usize) -> Option[&mut T]:
        if idx < N:
            Some(&mut self.data[idx])
        else:
            None

    fn set(self, idx: usize, value: T) -> Result[(), IndexError]:
        if idx >= N:
            return Err(IndexError::OutOfBounds(idx, N))
        self.data[idx] = value
        Ok(())

    fn sort(self) where T: Ord:
        # Insertion sort for fixed arrays
        for i in 1..N:
            var j = i
            while j > 0 and self.data[j].lt(&self.data[j - 1]):
                let tmp = self.data[j]
                self.data[j] = self.data[j - 1]
                self.data[j - 1] = tmp
                j = j - 1

    fn retain(self, predicate: fn(&T) -> bool):
        # Fixed arrays cannot change size, this is a no-op
        # For filtering, use filtered() which returns a List
        pass

    fn as_mut_slice(self) -> MutSlice[T]:
        danger:
            MutSlice::new(&mut self.data[0] as *mut T, N)

# ============================================
# ImmutSequence trait
# ============================================

impl ImmutSequence[T] for Array[T, const N: usize] where T: Clone:
    type Output = Array[T, N]

    fn with_index(self, idx: usize, value: T) -> Option[Self::Output]:
        if idx >= N:
            return None
        var new_data = self.data
        new_data[idx] = value
        Some(Array { data: new_data })

    fn sorted(self) -> Self::Output where T: Ord:
        var new_array = Array { data: self.data }
        new_array.sort()
        new_array

    fn reversed(self) -> Self::Output:
        var new_data = self.data
        var left: usize = 0
        var right = N - 1
        while left < right:
            let tmp = new_data[left]
            new_data[left] = new_data[right]
            new_data[right] = tmp
            left = left + 1
            right = right - 1
        Array { data: new_data }

    fn filtered(self, predicate: fn(&T) -> bool) -> List[T]:
        # Returns List because result size is unknown at compile time
        var result = List::new()
        for i in 0..N:
            if predicate(&self.data[i]):
                result.push(self.data[i].clone())
        result

    fn mapped[U](self, f: fn(T) -> U) -> Array[U, N] where U: Default:
        var new_data: [U; N] = [U::default(); N]
        for i in 0..N:
            new_data[i] = f(self.data[i].clone())
        Array { data: new_data }

    fn appended(self, item: T) -> List[T]:
        # Returns List because size increases
        var result = List::with_capacity(N + 1)
        for i in 0..N:
            result.push(self.data[i].clone())
        result.push(item)
        result

    fn prepended(self, item: T) -> List[T]:
        # Returns List because size increases
        var result = List::with_capacity(N + 1)
        result.push(item)
        for i in 0..N:
            result.push(self.data[i].clone())
        result

    fn taken(self, n: usize) -> List[T]:
        var result = List::new()
        let take_count = if n < N: n else: N
        for i in 0..take_count:
            result.push(self.data[i].clone())
        result

    fn dropped(self, n: usize) -> List[T]:
        var result = List::new()
        if n < N:
            for i in n..N:
                result.push(self.data[i].clone())
        result

    fn taken_while(self, predicate: fn(&T) -> bool) -> List[T]:
        var result = List::new()
        for i in 0..N:
            if not predicate(&self.data[i]):
                break
            result.push(self.data[i].clone())
        result

    fn dropped_while(self, predicate: fn(&T) -> bool) -> List[T]:
        var result = List::new()
        var dropping = true
        for i in 0..N:
            if dropping and predicate(&self.data[i]):
                continue
            dropping = false
            result.push(self.data[i].clone())
        result

# ============================================
# Sliceable trait
# ============================================

impl Sliceable[T] for Array[T, const N: usize]:
    fn as_slice(self) -> Slice[T]:
        danger:
            Slice::new(&self.data[0] as *T, N)

impl MutSliceable[T] for Array[T, const N: usize]:
    fn as_mut_slice(self) -> MutSlice[T]:
        danger:
            MutSlice::new(&mut self.data[0] as *mut T, N)

# ============================================
# Danger operations (unchecked, C-like)
# ============================================

impl Array[T, const N: usize]:
    # Unchecked get - requires danger block
    danger fn get_unchecked(self, idx: usize) -> T:
        self.data[idx]

    # Unchecked set - requires danger block
    danger fn set_unchecked(self, idx: usize, value: T):
        self.data[idx] = value

    # Raw pointer - requires danger block
    danger fn as_ptr(self) -> *T:
        &self.data[0] as *T

    # Mutable raw pointer - requires danger block
    danger fn as_mut_ptr(self) -> *mut T:
        &mut self.data[0] as *mut T

    # Copy from slice (unchecked) - requires danger block
    danger fn copy_from_slice(self, src: Slice[T]) where T: Copy:
        let copy_len = if src.len() < N: src.len() else: N
        for i in 0..copy_len:
            self.data[i] = src.get(i).expect("valid")

# ============================================
# Standard trait implementations
# ============================================

impl Clone for Array[T, const N: usize] where T: Clone:
    fn clone(self) -> Self:
        var new_data: [T; N]
        for i in 0..N:
            new_data[i] = self.data[i].clone()
        Array { data: new_data }

impl Copy for Array[T, const N: usize] where T: Copy

impl Default for Array[T, const N: usize] where T: Default:
    fn default() -> Self:
        Array::new()

impl Eq for Array[T, const N: usize] where T: Eq:
    fn eq(self, other: &Self) -> bool:
        for i in 0..N:
            if not self.data[i].eq(&other.data[i]):
                return false
        true

impl Ord for Array[T, const N: usize] where T: Ord:
    fn cmp(self, other: &Self) -> Ordering:
        for i in 0..N:
            match self.data[i].cmp(&other.data[i]):
                case Ordering::Less: return Ordering::Less
                case Ordering::Greater: return Ordering::Greater
                case Ordering::Equal: continue
        Ordering::Equal

impl Hash for Array[T, const N: usize] where T: Hash:
    fn hash(self) -> u64:
        var h: u64 = 0
        for i in 0..N:
            h = h * 31 + self.data[i].hash()
        h

impl Display for Array[T, const N: usize] where T: Display:
    fn fmt(self) -> str:
        var s = "["
        for i in 0..N:
            if i > 0:
                s = s + ", "
            s = s + self.data[i].fmt()
        s + "]"

impl Index[usize] for Array[T, const N: usize]:
    type Output = T

    fn index(self, idx: usize) -> &Self::Output:
        if idx >= N:
            panic(f"index {idx} out of bounds (len={N})")
        &self.data[idx]

impl IndexMut[usize] for Array[T, const N: usize]:
    fn index_mut(self, idx: usize) -> &mut Self::Output:
        if idx >= N:
            panic(f"index {idx} out of bounds (len={N})")
        &mut self.data[idx]

impl IntoIterator for Array[T, const N: usize]:
    type Item = T
    type IntoIter = ArrayIter[T, N]
    fn into_iter(self) -> Self::IntoIter:
        self.iter()

# ============================================
# Array Iterator
# ============================================

struct ArrayIter[T, const N: usize]:
    array: Array[T, N]
    index: usize

impl Iterator for ArrayIter[T, const N: usize]:
    type Item = T

    fn next(self) -> Option[Self::Item]:
        if self.index < N:
            let item = self.array.data[self.index]
            self.index = self.index + 1
            Some(item)
        else:
            None

impl ExactSizeIterator for ArrayIter[T, const N: usize]:
    fn len(self) -> usize:
        N - self.index

impl DoubleEndedIterator for ArrayIter[T, const N: usize]:
    fn next_back(self) -> Option[Self::Item]:
        if self.index < N:
            Some(self.array.data[N - 1])
        else:
            None

# ============================================
# Conversion to List
# ============================================

impl Array[T, const N: usize]:
    fn to_list(self) -> List[T] where T: Clone:
        var list = List::with_capacity(N)
        for i in 0..N:
            list.push(self.data[i].clone())
        list

    # Convenience methods
    fn map_with_index[U](self, f: fn(usize, T) -> U) -> Array[U, N] where T: Clone, U: Default:
        var new_data: [U; N] = [U::default(); N]
        for i in 0..N:
            new_data[i] = f(i, self.data[i].clone())
        Array { data: new_data }

    # Ruby-style tap
    fn tap(self, f: fn(&Array[T, N])) -> Array[T, N]:
        f(&self)
        self

    # Ruby-style then
    fn then[U](self, f: fn(Array[T, N]) -> U) -> U:
        f(self)

    # Zip with another array of same size
    fn zip[U](self, other: Array[U, N]) -> Array[(T, U), N] where T: Clone, U: Clone:
        var new_data: [(T, U); N]
        for i in 0..N:
            new_data[i] = (self.data[i].clone(), other.data[i].clone())
        Array { data: new_data }

    # Enumerate as array of (index, value)
    fn enumerated(self) -> Array[(usize, T), N] where T: Clone:
        var new_data: [(usize, T); N]
        for i in 0..N:
            new_data[i] = (i, self.data[i].clone())
        Array { data: new_data }

# ============================================
# Type aliases for common sizes
# ============================================

type Array2[T] = Array[T, 2]
type Array3[T] = Array[T, 3]
type Array4[T] = Array[T, 4]
type Array8[T] = Array[T, 8]
type Array16[T] = Array[T, 16]
type Array32[T] = Array[T, 32]
type Array64[T] = Array[T, 64]
type Array128[T] = Array[T, 128]
type Array256[T] = Array[T, 256]

# Vector types (common in graphics/math)
type Vec2 = Array[f32, 2]
type Vec3 = Array[f32, 3]
type Vec4 = Array[f32, 4]
type Vec2d = Array[f64, 2]
type Vec3d = Array[f64, 3]
type Vec4d = Array[f64, 4]

# Integer vector types
type IVec2 = Array[i32, 2]
type IVec3 = Array[i32, 3]
type IVec4 = Array[i32, 4]

# Matrix type aliases
type Mat2 = Array[Array[f32, 2], 2]
type Mat3 = Array[Array[f32, 3], 3]
type Mat4 = Array[Array[f32, 4], 4]
