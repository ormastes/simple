# Simple Language Lexer and Parser Specification

## Overview

This document specifies the complete lexer and parser implementation for the Simple programming language using Tree-sitter with GLR (Generalized LR) parsing for optimal performance. The implementation consists of:

1. **Tree-sitter Grammar** (`grammar.js`) - Complete GLR grammar definition
2. **External Scanner** (`scanner.c`) - Indentation and context-sensitive token handling
3. **Rust Bindings** - Integration code for embedding in Rust applications
4. **Token Specification** - Complete lexical token definitions

---

## Token Specification

### Reserved Keywords

```
# Type & Structure Keywords
struct      class       enum        trait       actor
impl        fn          let         mut         immut
type        where       as          in          is

# Control Flow
if          else        elif        match       case
for         while       loop        break       continue
return      yield

# Memory & Ownership
new         move        ref         self        Self

# Concurrency
spawn       send        receive     on          state

# Effects & Modifiers
waitless    async       await       extern      static
pub         priv        const       global

# Logical & Values
and         or          not         true        false        nil

# Special
context     macro       handle_pool gen_code
```

### Operators and Punctuation

```
# Arithmetic
+       -       *       /       %       **

# Comparison
==      !=      <       >       <=      >=

# Assignment & Update
=       ->      <-

# Logical (symbolic alternatives)
&&      ||      !

# Bitwise
&       |       ^       ~       <<      >>

# Punctuation
(       )       [       ]       {       }
:       ;       ,       .       ..      ...
@       #       \       ?       _

# Pointer Type Prefixes (in type context)
&       *       -       +
```

### Literals

| Type | Pattern | Examples |
|------|---------|----------|
| Integer | `[0-9][0-9_]*` | `42`, `1_000_000` |
| Hex Integer | `0x[0-9a-fA-F_]+` | `0xFF`, `0x1A_2B` |
| Binary Integer | `0b[01_]+` | `0b1010`, `0b1111_0000` |
| Octal Integer | `0o[0-7_]+` | `0o755`, `0o777` |
| Float | `[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?` | `3.14`, `1.0e-10` |
| String | `"([^"\\]|\\.)*"` | `"hello"`, `"line\n"` |
| Raw String | `r"[^"]*"` | `r"no\escape"` |
| Char | `'([^'\\]|\\.)'` | `'a'`, `'\n'` |
| Symbol/Atom | `:[a-zA-Z_][a-zA-Z0-9_]*` | `:ok`, `:error` |

### Identifiers

```
# Regular identifier
[a-zA-Z_][a-zA-Z0-9_]*

# Type identifier (starts with uppercase by convention)
[A-Z][a-zA-Z0-9_]*
```

### Comments

```
# Line comment - extends to end of line
# This is a comment

# Block comment (if supported)
/* Multi-line
   comment */
```

### Whitespace and Indentation

- Significant indentation (Python-style)
- INDENT and DEDENT tokens generated by external scanner
- NEWLINE token separates statements
- Spaces preferred over tabs (4 spaces = 1 indent level)

---

## Tree-sitter Grammar (`grammar.js`)

```javascript
// grammar.js - Complete Tree-sitter grammar for Simple language
// Uses GLR parsing for ambiguity resolution

module.exports = grammar({
  name: 'simple',

  // External scanner handles indentation
  externals: $ => [
    $._indent,
    $._dedent,
    $._newline,
    $._string_start,
    $._string_content,
    $._string_end,
  ],

  // Token precedence for GLR conflict resolution
  precedences: $ => [
    [
      'call',
      'unary',
      'power',
      'multiplicative',
      'additive',
      'shift',
      'bitwise_and',
      'bitwise_xor',
      'bitwise_or',
      'comparison',
      'logical_and',
      'logical_or',
      'functional_update',
      'assignment',
    ],
    ['type_args', 'comparison'],
    ['primary', 'lambda'],
  ],

  // Inline rules for performance
  inline: $ => [
    $._statement,
    $._simple_statement,
    $._compound_statement,
    $._expression,
  ],

  // Conflict resolution for GLR parsing
  conflicts: $ => [
    // Type vs expression ambiguity
    [$.type, $.primary_expression],
    // Generic type vs comparison
    [$.generic_type, $.comparison_expression],
    // Lambda vs block
    [$.lambda_expression, $.block],
    // Pattern vs expression
    [$.pattern, $.primary_expression],
    // Struct literal vs block
    [$.struct_literal, $.block],
  ],

  // Word token for keyword extraction
  word: $ => $.identifier,

  rules: {
    //=========================================================================
    // SOURCE FILE
    //=========================================================================
    
    source_file: $ => repeat($._definition),

    _definition: $ => choice(
      $.function_definition,
      $.struct_definition,
      $.class_definition,
      $.enum_definition,
      $.trait_definition,
      $.impl_block,
      $.actor_definition,
      $.handle_pool_definition,
      $.macro_definition,
      $.global_declaration,
      $.type_alias,
    ),

    //=========================================================================
    // TYPE SYSTEM
    //=========================================================================

    type: $ => choice(
      $.simple_type,
      $.generic_type,
      $.pointer_type,
      $.tuple_type,
      $.array_type,
      $.dict_type,
      $.function_type,
      $.union_type,
      $.optional_type,
    ),

    simple_type: $ => $.type_identifier,

    type_identifier: $ => /[A-Z][a-zA-Z0-9_]*/,

    generic_type: $ => prec('type_args', seq(
      $.type_identifier,
      '[',
      commaSep1($.type),
      ']',
    )),

    // Pointer types: &T (unique), *T (shared), -T (weak), +T (handle)
    pointer_type: $ => choice(
      seq('&', $.type),      // Unique pointer
      seq('*', $.type),      // Shared pointer
      seq('-', $.type),      // Weak pointer
      seq('+', $.type),      // Handle pointer
    ),

    tuple_type: $ => seq(
      '(',
      commaSep($.type),
      ')',
    ),

    array_type: $ => seq(
      '[',
      $.type,
      optional(seq(';', $.expression)),  // Fixed-size array
      ']',
    ),

    dict_type: $ => seq(
      '{',
      $.type,
      ':',
      $.type,
      '}',
    ),

    function_type: $ => seq(
      'Fn',
      '(',
      commaSep($.type),
      ')',
      optional(seq('->', $.type)),
    ),

    union_type: $ => prec.left(seq(
      $.type,
      '|',
      $.type,
    )),

    optional_type: $ => seq(
      $.type,
      '?',
    ),

    type_parameters: $ => seq(
      '[',
      commaSep1($.type_parameter),
      ']',
    ),

    type_parameter: $ => seq(
      $.identifier,
      optional(seq(':', $.type_bounds)),
    ),

    type_bounds: $ => sep1($.type, '+'),

    //=========================================================================
    // STRUCT DEFINITION
    //=========================================================================

    struct_definition: $ => seq(
      optional('mut'),
      'struct',
      $.type_identifier,
      optional($.type_parameters),
      ':',
      $._indent,
      repeat1($.field_definition),
      $._dedent,
    ),

    field_definition: $ => seq(
      $.identifier,
      ':',
      $.type,
      optional(seq('=', $.expression)),
      $._newline,
    ),

    //=========================================================================
    // CLASS DEFINITION
    //=========================================================================

    class_definition: $ => seq(
      optional('immut'),
      'class',
      $.type_identifier,
      optional($.type_parameters),
      optional($.superclass),
      ':',
      $._indent,
      repeat(choice(
        $.field_definition,
        $.method_definition,
      )),
      $._dedent,
    ),

    superclass: $ => seq(
      '(',
      $.type,
      ')',
    ),

    method_definition: $ => seq(
      optional('pub'),
      'fn',
      $.identifier,
      $.parameters,
      optional($.effect_modifier),
      optional(seq('->', $.type)),
      ':',
      $.block,
    ),

    //=========================================================================
    // ENUM DEFINITION
    //=========================================================================

    enum_definition: $ => seq(
      'enum',
      $.type_identifier,
      optional($.type_parameters),
      ':',
      $._indent,
      repeat1($.enum_variant),
      $._dedent,
    ),

    enum_variant: $ => seq(
      $.type_identifier,
      optional($.variant_fields),
      $._newline,
    ),

    variant_fields: $ => seq(
      '(',
      commaSep($.variant_field),
      ')',
    ),

    variant_field: $ => seq(
      optional(seq($.identifier, ':')),
      $.type,
    ),

    //=========================================================================
    // TRAIT DEFINITION
    //=========================================================================

    trait_definition: $ => seq(
      'trait',
      $.type_identifier,
      optional($.type_parameters),
      optional($.trait_bounds),
      ':',
      $._indent,
      repeat($.trait_method),
      $._dedent,
    ),

    trait_bounds: $ => seq(
      '(',
      commaSep1($.type),
      ')',
    ),

    trait_method: $ => seq(
      'fn',
      $.identifier,
      $.parameters,
      optional($.effect_modifier),
      optional(seq('->', $.type)),
      optional(seq(':', $.block)),
      $._newline,
    ),

    //=========================================================================
    // IMPL BLOCK
    //=========================================================================

    impl_block: $ => seq(
      'impl',
      optional($.type_parameters),
      $.type,
      optional(seq('for', $.type)),
      ':',
      $._indent,
      repeat($.method_definition),
      $._dedent,
    ),

    //=========================================================================
    // ACTOR DEFINITION
    //=========================================================================

    actor_definition: $ => seq(
      'actor',
      $.type_identifier,
      optional($.type_parameters),
      ':',
      $._indent,
      optional($.state_block),
      repeat($.message_handler),
      $._dedent,
    ),

    state_block: $ => seq(
      'state',
      ':',
      $._indent,
      repeat1($.field_definition),
      $._dedent,
    ),

    message_handler: $ => seq(
      'on',
      $.type_identifier,
      optional($.handler_parameters),
      $.effect_modifier,  // must be 'waitless' for stackless actors
      ':',
      $.block,
    ),

    handler_parameters: $ => seq(
      '(',
      commaSep($.parameter),
      ')',
    ),

    //=========================================================================
    // HANDLE POOL DEFINITION
    //=========================================================================

    handle_pool_definition: $ => seq(
      'handle_pool',
      $.type_identifier,
      ':',
      $._indent,
      repeat1($.pool_option),
      $._dedent,
    ),

    pool_option: $ => seq(
      $.identifier,
      ':',
      $.expression,
      $._newline,
    ),

    //=========================================================================
    // FUNCTION DEFINITION
    //=========================================================================

    function_definition: $ => seq(
      optional($.visibility),
      optional('extern'),
      'fn',
      $.identifier,
      optional($.type_parameters),
      $.parameters,
      optional($.effect_modifier),
      optional(seq('->', $.type)),
      ':',
      $.block,
    ),

    visibility: $ => choice('pub', 'priv'),

    parameters: $ => seq(
      '(',
      commaSep($.parameter),
      ')',
    ),

    parameter: $ => seq(
      optional('mut'),
      $.identifier,
      optional(seq(':', $.type)),
      optional(seq('=', $.expression)),
    ),

    effect_modifier: $ => choice(
      'waitless',
      'async',
    ),

    //=========================================================================
    // MACRO DEFINITION
    //=========================================================================

    macro_definition: $ => seq(
      'macro',
      $.identifier,
      $.macro_parameters,
      ':',
      $._indent,
      $.macro_body,
      $._dedent,
    ),

    macro_parameters: $ => seq(
      '(',
      commaSep($.macro_parameter),
      ')',
    ),

    macro_parameter: $ => seq(
      $.identifier,
      ':',
      $.macro_type,
    ),

    macro_type: $ => choice(
      'Ident',
      'Type',
      'Expr',
      'Block',
      'Pattern',
      seq('[', $.macro_type, ']'),
    ),

    macro_body: $ => seq(
      'gen_code',
      ':',
      $._indent,
      repeat($._statement),
      $._dedent,
    ),

    //=========================================================================
    // GLOBAL DECLARATIONS
    //=========================================================================

    global_declaration: $ => choice(
      $.const_declaration,
      $.static_declaration,
    ),

    const_declaration: $ => seq(
      'const',
      $.identifier,
      optional(seq(':', $.type)),
      '=',
      $.expression,
      $._newline,
    ),

    static_declaration: $ => seq(
      optional('mut'),
      'static',
      $.identifier,
      ':',
      $.type,
      '=',
      $.expression,
      $._newline,
    ),

    type_alias: $ => seq(
      'type',
      $.type_identifier,
      optional($.type_parameters),
      '=',
      $.type,
      $._newline,
    ),

    //=========================================================================
    // STATEMENTS
    //=========================================================================

    block: $ => seq(
      $._indent,
      repeat1($._statement),
      $._dedent,
    ),

    _statement: $ => choice(
      $._simple_statement,
      $._compound_statement,
    ),

    _simple_statement: $ => seq(
      choice(
        $.expression_statement,
        $.assignment_statement,
        $.let_statement,
        $.return_statement,
        $.break_statement,
        $.continue_statement,
        $.pass_statement,
        $.send_statement,
      ),
      $._newline,
    ),

    _compound_statement: $ => choice(
      $.if_statement,
      $.match_statement,
      $.for_statement,
      $.while_statement,
      $.loop_statement,
      $.receive_block,
      $.context_block,
    ),

    expression_statement: $ => $.expression,

    assignment_statement: $ => seq(
      $.expression,
      '=',
      $.expression,
    ),

    let_statement: $ => seq(
      optional('mut'),
      'let',
      $.pattern,
      optional(seq(':', $.type)),
      optional(seq('=', $.expression)),
    ),

    return_statement: $ => seq(
      'return',
      optional($.expression),
    ),

    break_statement: $ => seq(
      'break',
      optional($.identifier),
    ),

    continue_statement: $ => seq(
      'continue',
      optional($.identifier),
    ),

    pass_statement: $ => 'pass',

    send_statement: $ => seq(
      'send',
      $.expression,
      ',',
      $.expression,
    ),

    //=========================================================================
    // COMPOUND STATEMENTS
    //=========================================================================

    if_statement: $ => seq(
      'if',
      $.expression,
      ':',
      $.block,
      repeat($.elif_clause),
      optional($.else_clause),
    ),

    elif_clause: $ => seq(
      'elif',
      $.expression,
      ':',
      $.block,
    ),

    else_clause: $ => seq(
      'else',
      ':',
      $.block,
    ),

    match_statement: $ => seq(
      'match',
      $.expression,
      ':',
      $._indent,
      repeat1($.case_clause),
      $._dedent,
    ),

    case_clause: $ => seq(
      'case',
      $.pattern,
      optional($.guard),
      ':',
      $.block,
    ),

    guard: $ => seq(
      'if',
      $.expression,
    ),

    for_statement: $ => seq(
      'for',
      $.pattern,
      'in',
      $.expression,
      ':',
      $.block,
    ),

    while_statement: $ => seq(
      'while',
      $.expression,
      ':',
      $.block,
    ),

    loop_statement: $ => seq(
      'loop',
      optional(seq(':', $.identifier)),
      ':',
      $.block,
    ),

    receive_block: $ => seq(
      'receive',
      ':',
      $._indent,
      repeat1($.case_clause),
      optional($.timeout_clause),
      $._dedent,
    ),

    timeout_clause: $ => seq(
      'after',
      $.expression,
      ':',
      $.block,
    ),

    context_block: $ => seq(
      'context',
      $.expression,
      ':',
      $.block,
    ),

    //=========================================================================
    // PATTERNS
    //=========================================================================

    pattern: $ => choice(
      $.identifier_pattern,
      $.literal_pattern,
      $.wildcard_pattern,
      $.tuple_pattern,
      $.struct_pattern,
      $.enum_pattern,
      $.or_pattern,
      $.typed_pattern,
    ),

    identifier_pattern: $ => $.identifier,

    literal_pattern: $ => choice(
      $.integer,
      $.float,
      $.string,
      $.boolean,
      $.nil,
      $.symbol,
    ),

    wildcard_pattern: $ => '_',

    tuple_pattern: $ => seq(
      '(',
      commaSep($.pattern),
      ')',
    ),

    struct_pattern: $ => seq(
      $.type_identifier,
      '(',
      commaSep($.field_pattern),
      ')',
    ),

    field_pattern: $ => seq(
      $.identifier,
      ':',
      $.pattern,
    ),

    enum_pattern: $ => seq(
      $.type_identifier,
      optional(seq('(', commaSep($.pattern), ')')),
    ),

    or_pattern: $ => prec.left(seq(
      $.pattern,
      '|',
      $.pattern,
    )),

    typed_pattern: $ => seq(
      $.identifier,
      ':',
      $.type,
    ),

    //=========================================================================
    // EXPRESSIONS
    //=========================================================================

    expression: $ => choice(
      $.primary_expression,
      $.unary_expression,
      $.binary_expression,
      $.comparison_expression,
      $.logical_expression,
      $.functional_update_expression,
      $.if_expression,
      $.match_expression,
      $.lambda_expression,
      $.spawn_expression,
      $.new_expression,
    ),

    primary_expression: $ => prec('primary', choice(
      $.identifier,
      $.literal,
      $.grouped_expression,
      $.tuple_expression,
      $.array_expression,
      $.dict_expression,
      $.struct_literal,
      $.call_expression,
      $.method_call_expression,
      $.field_access,
      $.index_expression,
    )),

    identifier: $ => /[a-zA-Z_][a-zA-Z0-9_]*/,

    literal: $ => choice(
      $.integer,
      $.float,
      $.string,
      $.char,
      $.boolean,
      $.nil,
      $.symbol,
    ),

    integer: $ => choice(
      /[0-9][0-9_]*/,
      /0x[0-9a-fA-F_]+/,
      /0b[01_]+/,
      /0o[0-7_]+/,
    ),

    float: $ => /[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?/,

    string: $ => seq(
      $._string_start,
      repeat(choice(
        $._string_content,
        $.interpolation,
        $.escape_sequence,
      )),
      $._string_end,
    ),

    interpolation: $ => seq(
      '{',
      $.expression,
      '}',
    ),

    escape_sequence: $ => token.immediate(seq(
      '\\',
      choice(
        /[\\'"nrtbfv0]/,
        /x[0-9a-fA-F]{2}/,
        /u[0-9a-fA-F]{4}/,
        /U[0-9a-fA-F]{8}/,
      ),
    )),

    char: $ => seq(
      "'",
      choice(
        /[^'\\]/,
        $.escape_sequence,
      ),
      "'",
    ),

    boolean: $ => choice('true', 'false'),

    nil: $ => 'nil',

    symbol: $ => /:[a-zA-Z_][a-zA-Z0-9_]*/,

    grouped_expression: $ => seq('(', $.expression, ')'),

    tuple_expression: $ => seq(
      '(',
      $.expression,
      ',',
      commaSep($.expression),
      ')',
    ),

    array_expression: $ => seq(
      '[',
      commaSep($.expression),
      ']',
    ),

    dict_expression: $ => seq(
      '{',
      commaSep($.dict_entry),
      '}',
    ),

    dict_entry: $ => seq(
      $.expression,
      ':',
      $.expression,
    ),

    struct_literal: $ => seq(
      $.type_identifier,
      '(',
      commaSep($.field_argument),
      ')',
    ),

    field_argument: $ => seq(
      $.identifier,
      ':',
      $.expression,
    ),

    call_expression: $ => prec('call', seq(
      $.primary_expression,
      '(',
      commaSep($.argument),
      ')',
    )),

    method_call_expression: $ => prec('call', seq(
      $.primary_expression,
      '.',
      $.identifier,
      optional(seq('(', commaSep($.argument), ')')),
      optional($.trailing_block),
    )),

    argument: $ => choice(
      $.expression,
      $.named_argument,
    ),

    named_argument: $ => seq(
      $.identifier,
      ':',
      $.expression,
    ),

    trailing_block: $ => seq(
      $.lambda_params,
      ':',
      $.block,
    ),

    field_access: $ => prec('call', seq(
      $.primary_expression,
      '.',
      $.identifier,
    )),

    index_expression: $ => prec('call', seq(
      $.primary_expression,
      '[',
      $.expression,
      ']',
    )),

    //=========================================================================
    // OPERATOR EXPRESSIONS
    //=========================================================================

    unary_expression: $ => prec('unary', choice(
      seq('-', $.expression),
      seq('not', $.expression),
      seq('!', $.expression),
      seq('~', $.expression),
      seq('&', $.expression),  // Reference
      seq('*', $.expression),  // Dereference
    )),

    binary_expression: $ => choice(
      prec.left('power', seq($.expression, '**', $.expression)),
      prec.left('multiplicative', seq($.expression, choice('*', '/', '%'), $.expression)),
      prec.left('additive', seq($.expression, choice('+', '-'), $.expression)),
      prec.left('shift', seq($.expression, choice('<<', '>>'), $.expression)),
      prec.left('bitwise_and', seq($.expression, '&', $.expression)),
      prec.left('bitwise_xor', seq($.expression, '^', $.expression)),
      prec.left('bitwise_or', seq($.expression, '|', $.expression)),
    ),

    comparison_expression: $ => prec.left('comparison', seq(
      $.expression,
      choice('==', '!=', '<', '>', '<=', '>=', 'is', 'in'),
      $.expression,
    )),

    logical_expression: $ => choice(
      prec.left('logical_and', seq($.expression, choice('and', '&&'), $.expression)),
      prec.left('logical_or', seq($.expression, choice('or', '||'), $.expression)),
    ),

    // Functional update: obj->method()
    functional_update_expression: $ => prec.left('functional_update', seq(
      $.expression,
      '->',
      $.identifier,
      '(',
      commaSep($.argument),
      ')',
    )),

    //=========================================================================
    // SPECIAL EXPRESSIONS
    //=========================================================================

    if_expression: $ => seq(
      'if',
      $.expression,
      ':',
      $.expression,
      'else',
      ':',
      $.expression,
    ),

    match_expression: $ => seq(
      'match',
      $.expression,
      ':',
      $._indent,
      repeat1($.case_arm),
      $._dedent,
    ),

    case_arm: $ => seq(
      'case',
      $.pattern,
      optional($.guard),
      ':',
      $.expression,
      $._newline,
    ),

    // Lambda: \x: body or \x, y: body
    lambda_expression: $ => prec('lambda', seq(
      $.lambda_params,
      ':',
      choice(
        $.expression,
        $.block,
      ),
    )),

    lambda_params: $ => seq(
      '\\',
      choice(
        // Simple params: \x or \x, y
        commaSep1($.lambda_param),
        // Typed params: \(x: Int, y: Int)
        seq('(', commaSep($.typed_lambda_param), ')'),
      ),
      optional(seq('->', $.type)),  // Return type
    ),

    lambda_param: $ => $.identifier,

    typed_lambda_param: $ => seq(
      $.identifier,
      ':',
      $.type,
    ),

    spawn_expression: $ => seq(
      'spawn',
      choice(
        $.call_expression,
        $.lambda_expression,
        $.type_identifier,  // Actor spawn
        seq($.type_identifier, '(', commaSep($.argument), ')'),
      ),
    ),

    // Memory allocation expressions
    new_expression: $ => choice(
      $.new_unique,
      $.new_shared,
      $.new_weak,
      $.new_handle,
    ),

    // new(&) T(...) -> &T
    new_unique: $ => seq(
      'new',
      '(',
      '&',
      ')',
      $.type_identifier,
      '(',
      commaSep($.argument),
      ')',
    ),

    // new* T(...) -> *T
    new_shared: $ => seq(
      'new',
      '*',
      $.type_identifier,
      '(',
      commaSep($.argument),
      ')',
    ),

    // new- T(...) -> -T
    new_weak: $ => seq(
      'new',
      '-',
      $.type_identifier,
      '(',
      commaSep($.argument),
      ')',
    ),

    // new+ T(...) -> +T
    new_handle: $ => seq(
      'new',
      '+',
      $.type_identifier,
      '(',
      commaSep($.argument),
      ')',
    ),

    //=========================================================================
    // COMMENTS
    //=========================================================================

    comment: $ => token(seq('#', /.*/)),
  },

  extras: $ => [
    $.comment,
    /[ \t]+/,
  ],
});

// Helper functions
function commaSep(rule) {
  return optional(commaSep1(rule));
}

function commaSep1(rule) {
  return seq(rule, repeat(seq(',', rule)), optional(','));
}

function sep1(rule, separator) {
  return seq(rule, repeat(seq(separator, rule)));
}
```

---

## External Scanner (`scanner.c`)

The external scanner handles context-sensitive tokens like INDENT, DEDENT, and NEWLINE.

```c
// scanner.c - External scanner for Simple language
// Handles indentation-sensitive parsing

#include <tree_sitter/parser.h>
#include <wctype.h>
#include <string.h>

enum TokenType {
    INDENT,
    DEDENT,
    NEWLINE,
    STRING_START,
    STRING_CONTENT,
    STRING_END,
};

#define MAX_INDENT_DEPTH 100

typedef struct {
    uint16_t indent_stack[MAX_INDENT_DEPTH];
    uint8_t indent_depth;
    bool inside_string;
    char string_delimiter;
    uint8_t pending_dedents;
} Scanner;

// Initialize scanner state
void *tree_sitter_simple_external_scanner_create() {
    Scanner *scanner = calloc(1, sizeof(Scanner));
    scanner->indent_stack[0] = 0;
    scanner->indent_depth = 1;
    return scanner;
}

void tree_sitter_simple_external_scanner_destroy(void *payload) {
    free(payload);
}

// Serialize scanner state
unsigned tree_sitter_simple_external_scanner_serialize(
    void *payload,
    char *buffer
) {
    Scanner *scanner = payload;
    size_t size = 0;
    
    buffer[size++] = scanner->indent_depth;
    buffer[size++] = scanner->inside_string;
    buffer[size++] = scanner->string_delimiter;
    buffer[size++] = scanner->pending_dedents;
    
    for (uint8_t i = 0; i < scanner->indent_depth; i++) {
        buffer[size++] = scanner->indent_stack[i] & 0xFF;
        buffer[size++] = (scanner->indent_stack[i] >> 8) & 0xFF;
    }
    
    return size;
}

// Deserialize scanner state
void tree_sitter_simple_external_scanner_deserialize(
    void *payload,
    const char *buffer,
    unsigned length
) {
    Scanner *scanner = payload;
    
    if (length == 0) {
        scanner->indent_stack[0] = 0;
        scanner->indent_depth = 1;
        scanner->inside_string = false;
        scanner->string_delimiter = 0;
        scanner->pending_dedents = 0;
        return;
    }
    
    size_t idx = 0;
    scanner->indent_depth = buffer[idx++];
    scanner->inside_string = buffer[idx++];
    scanner->string_delimiter = buffer[idx++];
    scanner->pending_dedents = buffer[idx++];
    
    for (uint8_t i = 0; i < scanner->indent_depth; i++) {
        scanner->indent_stack[i] = 
            ((uint16_t)buffer[idx]) | 
            ((uint16_t)buffer[idx + 1] << 8);
        idx += 2;
    }
}

// Count leading whitespace (spaces + tabs*4)
static uint16_t count_indent(TSLexer *lexer) {
    uint16_t indent = 0;
    while (lexer->lookahead == ' ' || lexer->lookahead == '\t') {
        if (lexer->lookahead == ' ') {
            indent++;
        } else {
            indent += 4;  // Tab = 4 spaces
        }
        lexer->advance(lexer, false);
    }
    return indent;
}

// Skip whitespace but not newlines
static void skip_whitespace(TSLexer *lexer) {
    while (lexer->lookahead == ' ' || lexer->lookahead == '\t') {
        lexer->advance(lexer, true);
    }
}

// Main scan function
bool tree_sitter_simple_external_scanner_scan(
    void *payload,
    TSLexer *lexer,
    const bool *valid_symbols
) {
    Scanner *scanner = payload;
    
    // Handle pending dedents
    if (scanner->pending_dedents > 0 && valid_symbols[DEDENT]) {
        scanner->pending_dedents--;
        scanner->indent_depth--;
        lexer->result_symbol = DEDENT;
        return true;
    }
    
    // Handle string tokens
    if (scanner->inside_string) {
        if (valid_symbols[STRING_END] && 
            lexer->lookahead == scanner->string_delimiter) {
            lexer->advance(lexer, false);
            scanner->inside_string = false;
            lexer->result_symbol = STRING_END;
            return true;
        }
        
        if (valid_symbols[STRING_CONTENT]) {
            bool has_content = false;
            while (lexer->lookahead != 0 &&
                   lexer->lookahead != scanner->string_delimiter &&
                   lexer->lookahead != '{' &&
                   lexer->lookahead != '\\') {
                lexer->advance(lexer, false);
                has_content = true;
            }
            if (has_content) {
                lexer->result_symbol = STRING_CONTENT;
                return true;
            }
        }
        return false;
    }
    
    // Handle string start
    if (valid_symbols[STRING_START] && 
        (lexer->lookahead == '"' || lexer->lookahead == '\'')) {
        scanner->string_delimiter = lexer->lookahead;
        scanner->inside_string = true;
        lexer->advance(lexer, false);
        lexer->result_symbol = STRING_START;
        return true;
    }
    
    // Handle newline and indentation
    if (lexer->lookahead == '\n' || lexer->lookahead == '\r') {
        // Skip the newline
        if (lexer->lookahead == '\r') {
            lexer->advance(lexer, true);
        }
        if (lexer->lookahead == '\n') {
            lexer->advance(lexer, true);
        }
        
        // Skip blank lines and comments
        while (true) {
            uint16_t indent = count_indent(lexer);
            
            // Skip blank lines
            if (lexer->lookahead == '\n' || lexer->lookahead == '\r') {
                if (lexer->lookahead == '\r') lexer->advance(lexer, true);
                if (lexer->lookahead == '\n') lexer->advance(lexer, true);
                continue;
            }
            
            // Skip comment lines
            if (lexer->lookahead == '#') {
                while (lexer->lookahead != '\n' && 
                       lexer->lookahead != '\r' && 
                       lexer->lookahead != 0) {
                    lexer->advance(lexer, true);
                }
                if (lexer->lookahead == '\r') lexer->advance(lexer, true);
                if (lexer->lookahead == '\n') lexer->advance(lexer, true);
                continue;
            }
            
            // Handle indentation change
            uint16_t current_indent = scanner->indent_stack[scanner->indent_depth - 1];
            
            if (indent > current_indent) {
                // INDENT
                if (valid_symbols[INDENT]) {
                    scanner->indent_stack[scanner->indent_depth++] = indent;
                    lexer->result_symbol = INDENT;
                    return true;
                }
            } else if (indent < current_indent) {
                // DEDENT(s)
                while (scanner->indent_depth > 1 &&
                       scanner->indent_stack[scanner->indent_depth - 1] > indent) {
                    scanner->pending_dedents++;
                    scanner->indent_depth--;
                }
                
                if (scanner->pending_dedents > 0 && valid_symbols[DEDENT]) {
                    scanner->pending_dedents--;
                    lexer->result_symbol = DEDENT;
                    return true;
                }
            }
            
            // NEWLINE (same indentation level)
            if (valid_symbols[NEWLINE]) {
                lexer->result_symbol = NEWLINE;
                return true;
            }
            
            break;
        }
    }
    
    // Handle NEWLINE at end of file
    if (lexer->eof(lexer)) {
        if (valid_symbols[DEDENT] && scanner->indent_depth > 1) {
            scanner->indent_depth--;
            lexer->result_symbol = DEDENT;
            return true;
        }
        if (valid_symbols[NEWLINE]) {
            lexer->result_symbol = NEWLINE;
            return true;
        }
    }
    
    return false;
}
```

---

## Rust Bindings

### Cargo.toml

```toml
[package]
name = "tree-sitter-simple"
version = "0.1.0"
edition = "2021"
description = "Tree-sitter grammar for the Simple programming language"
license = "MIT"
repository = "https://github.com/simple-lang/tree-sitter-simple"
keywords = ["tree-sitter", "parser", "simple"]
categories = ["parsing", "development-tools"]

[lib]
path = "src/lib.rs"
crate-type = ["cdylib", "rlib"]

[dependencies]
tree-sitter = "0.22"

[build-dependencies]
cc = "1.0"
```

### build.rs

```rust
// build.rs - Build script for compiling Tree-sitter grammar

fn main() {
    let src_dir = std::path::Path::new("src");

    let mut c_config = cc::Build::new();
    c_config.include(src_dir);
    c_config
        .flag_if_supported("-Wno-unused-parameter")
        .flag_if_supported("-Wno-unused-but-set-variable")
        .flag_if_supported("-Wno-trigraphs");

    let parser_path = src_dir.join("parser.c");
    c_config.file(&parser_path);

    let scanner_path = src_dir.join("scanner.c");
    if scanner_path.exists() {
        c_config.file(&scanner_path);
    }

    c_config.compile("tree-sitter-simple");
}
```

### src/lib.rs

```rust
//! Tree-sitter grammar for the Simple programming language
//!
//! This crate provides Rust bindings for parsing Simple source code
//! using the Tree-sitter parsing library.

use tree_sitter::Language;

extern "C" {
    fn tree_sitter_simple() -> Language;
}

/// Returns the Tree-sitter Language for Simple.
///
/// # Safety
///
/// This function calls into C code but is safe because the
/// tree-sitter-simple grammar is generated and compiled correctly.
pub fn language() -> Language {
    unsafe { tree_sitter_simple() }
}

/// The content of the [`node-types.json`] file for this grammar.
pub const NODE_TYPES: &str = include_str!("../src/node-types.json");

/// The syntax highlighting queries for Simple.
pub const HIGHLIGHTS_QUERY: &str = include_str!("../queries/highlights.scm");

/// The indentation queries for Simple.
pub const INDENTS_QUERY: &str = include_str!("../queries/indents.scm");

/// The injection queries for Simple.
pub const INJECTIONS_QUERY: &str = include_str!("../queries/injections.scm");

/// The local variable queries for Simple.
pub const LOCALS_QUERY: &str = include_str!("../queries/locals.scm");

#[cfg(test)]
mod tests {
    use super::*;
    use tree_sitter::Parser;

    #[test]
    fn test_can_load_grammar() {
        let mut parser = Parser::new();
        parser.set_language(language()).expect("Error loading Simple grammar");
    }

    #[test]
    fn test_parse_function() {
        let mut parser = Parser::new();
        parser.set_language(language()).unwrap();

        let source = r#"
fn add(a: i64, b: i64) -> i64:
    return a + b
"#;

        let tree = parser.parse(source, None).unwrap();
        assert!(!tree.root_node().has_error());
    }

    #[test]
    fn test_parse_struct() {
        let mut parser = Parser::new();
        parser.set_language(language()).unwrap();

        let source = r#"
struct Point:
    x: f64
    y: f64
"#;

        let tree = parser.parse(source, None).unwrap();
        assert!(!tree.root_node().has_error());
    }

    #[test]
    fn test_parse_actor() {
        let mut parser = Parser::new();
        parser.set_language(language()).unwrap();

        let source = r#"
actor Counter:
    state:
        value: i64 = 0

    on Inc(by: i64) waitless:
        self.value = self.value + by
"#;

        let tree = parser.parse(source, None).unwrap();
        assert!(!tree.root_node().has_error());
    }

    #[test]
    fn test_parse_lambda() {
        let mut parser = Parser::new();
        parser.set_language(language()).unwrap();

        let source = r#"
let square = \x: x * x
items.map \item: item.name
"#;

        let tree = parser.parse(source, None).unwrap();
        assert!(!tree.root_node().has_error());
    }

    #[test]
    fn test_parse_handle_pool() {
        let mut parser = Parser::new();
        parser.set_language(language()).unwrap();

        let source = r#"
handle_pool Enemy:
    capacity: 1024

let h: +Enemy = new+ Enemy(hp: 100)
"#;

        let tree = parser.parse(source, None).unwrap();
        assert!(!tree.root_node().has_error());
    }

    #[test]
    fn test_parse_pattern_matching() {
        let mut parser = Parser::new();
        parser.set_language(language()).unwrap();

        let source = r#"
match result:
    case Ok(value):
        print value
    case Err(msg):
        print "Error: {msg}"
"#;

        let tree = parser.parse(source, None).unwrap();
        assert!(!tree.root_node().has_error());
    }
}
```

---

## Parser Integration Module (`src/parser.rs`)

```rust
//! High-level parser interface for Simple language
//!
//! Provides a convenient API for parsing Simple source code and
//! working with the resulting syntax tree.

use std::collections::HashMap;
use tree_sitter::{Language, Node, Parser, Query, QueryCursor, Tree};

/// A parsed Simple source file.
pub struct ParsedSource {
    pub tree: Tree,
    pub source: String,
}

/// Simple language parser with caching and error recovery.
pub struct SimpleParser {
    parser: Parser,
    query_cache: HashMap<String, Query>,
}

impl SimpleParser {
    /// Create a new Simple parser.
    pub fn new() -> Result<Self, String> {
        let mut parser = Parser::new();
        parser
            .set_language(crate::language())
            .map_err(|e| format!("Failed to set language: {}", e))?;
        
        Ok(Self {
            parser,
            query_cache: HashMap::new(),
        })
    }

    /// Parse a Simple source file.
    pub fn parse(&mut self, source: &str) -> Result<ParsedSource, ParseError> {
        let tree = self.parser
            .parse(source, None)
            .ok_or(ParseError::ParserError)?;

        if tree.root_node().has_error() {
            let errors = self.collect_errors(&tree, source);
            return Err(ParseError::SyntaxErrors(errors));
        }

        Ok(ParsedSource {
            tree,
            source: source.to_string(),
        })
    }

    /// Parse with incremental update from previous tree.
    pub fn parse_incremental(
        &mut self,
        source: &str,
        old_tree: Option<&Tree>,
    ) -> Result<ParsedSource, ParseError> {
        let tree = self.parser
            .parse(source, old_tree)
            .ok_or(ParseError::ParserError)?;

        if tree.root_node().has_error() {
            let errors = self.collect_errors(&tree, source);
            return Err(ParseError::SyntaxErrors(errors));
        }

        Ok(ParsedSource {
            tree,
            source: source.to_string(),
        })
    }

    /// Collect all syntax errors from the tree.
    fn collect_errors(&self, tree: &Tree, source: &str) -> Vec<SyntaxError> {
        let mut errors = Vec::new();
        let mut cursor = tree.walk();
        
        self.collect_errors_recursive(&mut cursor, source, &mut errors);
        errors
    }

    fn collect_errors_recursive(
        &self,
        cursor: &mut tree_sitter::TreeCursor,
        source: &str,
        errors: &mut Vec<SyntaxError>,
    ) {
        let node = cursor.node();
        
        if node.is_error() {
            let start = node.start_position();
            let end = node.end_position();
            let text = &source[node.byte_range()];
            
            errors.push(SyntaxError {
                message: format!("Unexpected token: {}", text.chars().take(20).collect::<String>()),
                line: start.row + 1,
                column: start.column + 1,
                end_line: end.row + 1,
                end_column: end.column + 1,
            });
        } else if node.is_missing() {
            let pos = node.start_position();
            errors.push(SyntaxError {
                message: format!("Missing {}", node.kind()),
                line: pos.row + 1,
                column: pos.column + 1,
                end_line: pos.row + 1,
                end_column: pos.column + 1,
            });
        }

        if cursor.goto_first_child() {
            loop {
                self.collect_errors_recursive(cursor, source, errors);
                if !cursor.goto_next_sibling() {
                    break;
                }
            }
            cursor.goto_parent();
        }
    }

    /// Execute a query on the syntax tree.
    pub fn query(
        &mut self,
        parsed: &ParsedSource,
        query_source: &str,
    ) -> Result<Vec<QueryMatch>, String> {
        let query = self.get_or_create_query(query_source)?;
        let mut cursor = QueryCursor::new();
        
        let matches: Vec<QueryMatch> = cursor
            .matches(&query, parsed.tree.root_node(), parsed.source.as_bytes())
            .map(|m| QueryMatch {
                pattern_index: m.pattern_index,
                captures: m.captures
                    .iter()
                    .map(|c| Capture {
                        name: query.capture_names()[c.index as usize].to_string(),
                        node_kind: c.node.kind().to_string(),
                        text: parsed.source[c.node.byte_range()].to_string(),
                        start: Position {
                            line: c.node.start_position().row + 1,
                            column: c.node.start_position().column + 1,
                        },
                        end: Position {
                            line: c.node.end_position().row + 1,
                            column: c.node.end_position().column + 1,
                        },
                    })
                    .collect(),
            })
            .collect();
        
        Ok(matches)
    }

    fn get_or_create_query(&mut self, source: &str) -> Result<Query, String> {
        if let Some(query) = self.query_cache.get(source) {
            return Ok(query.clone());
        }

        let query = Query::new(crate::language(), source)
            .map_err(|e| format!("Query error: {:?}", e))?;
        
        self.query_cache.insert(source.to_string(), query.clone());
        Ok(query)
    }
}

impl Default for SimpleParser {
    fn default() -> Self {
        Self::new().expect("Failed to create parser")
    }
}

/// Parse error types.
#[derive(Debug, Clone)]
pub enum ParseError {
    ParserError,
    SyntaxErrors(Vec<SyntaxError>),
}

/// A syntax error in the source.
#[derive(Debug, Clone)]
pub struct SyntaxError {
    pub message: String,
    pub line: usize,
    pub column: usize,
    pub end_line: usize,
    pub end_column: usize,
}

impl std::fmt::Display for SyntaxError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}:{}: {}",
            self.line, self.column, self.message
        )
    }
}

/// A query match result.
#[derive(Debug, Clone)]
pub struct QueryMatch {
    pub pattern_index: usize,
    pub captures: Vec<Capture>,
}

/// A captured node from a query.
#[derive(Debug, Clone)]
pub struct Capture {
    pub name: String,
    pub node_kind: String,
    pub text: String,
    pub start: Position,
    pub end: Position,
}

/// A position in the source.
#[derive(Debug, Clone, Copy)]
pub struct Position {
    pub line: usize,
    pub column: usize,
}
```

---

## AST Visitor Module (`src/visitor.rs`)

```rust
//! AST visitor pattern for Simple language syntax trees
//!
//! Provides traits and utilities for traversing and transforming
//! parsed Simple code.

use tree_sitter::Node;

/// Trait for visiting Simple AST nodes.
pub trait Visitor {
    /// Visit a source file (root node).
    fn visit_source_file(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit a function definition.
    fn visit_function_definition(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit a struct definition.
    fn visit_struct_definition(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit a class definition.
    fn visit_class_definition(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit an enum definition.
    fn visit_enum_definition(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit a trait definition.
    fn visit_trait_definition(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit an impl block.
    fn visit_impl_block(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit an actor definition.
    fn visit_actor_definition(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit a handle pool definition.
    fn visit_handle_pool_definition(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit a macro definition.
    fn visit_macro_definition(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit an expression.
    fn visit_expression(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit a statement.
    fn visit_statement(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit a pattern.
    fn visit_pattern(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit a type.
    fn visit_type(&mut self, node: Node, source: &str) {
        self.visit_children(node, source);
    }

    /// Visit an identifier.
    fn visit_identifier(&mut self, _node: Node, _source: &str) {}

    /// Visit a literal.
    fn visit_literal(&mut self, _node: Node, _source: &str) {}

    /// Default child visitor.
    fn visit_children(&mut self, node: Node, source: &str) {
        let mut cursor = node.walk();
        for child in node.children(&mut cursor) {
            self.visit(child, source);
        }
    }

    /// Main dispatch method.
    fn visit(&mut self, node: Node, source: &str) {
        match node.kind() {
            "source_file" => self.visit_source_file(node, source),
            "function_definition" => self.visit_function_definition(node, source),
            "struct_definition" => self.visit_struct_definition(node, source),
            "class_definition" => self.visit_class_definition(node, source),
            "enum_definition" => self.visit_enum_definition(node, source),
            "trait_definition" => self.visit_trait_definition(node, source),
            "impl_block" => self.visit_impl_block(node, source),
            "actor_definition" => self.visit_actor_definition(node, source),
            "handle_pool_definition" => self.visit_handle_pool_definition(node, source),
            "macro_definition" => self.visit_macro_definition(node, source),
            "identifier" | "type_identifier" => self.visit_identifier(node, source),
            "integer" | "float" | "string" | "boolean" | "nil" | "symbol" => {
                self.visit_literal(node, source)
            }
            kind if kind.ends_with("_expression") => self.visit_expression(node, source),
            kind if kind.ends_with("_statement") => self.visit_statement(node, source),
            kind if kind.ends_with("_pattern") => self.visit_pattern(node, source),
            kind if kind.ends_with("_type") || kind == "type" => self.visit_type(node, source),
            _ => self.visit_children(node, source),
        }
    }
}

/// Walk the AST with a visitor.
pub fn walk<V: Visitor>(visitor: &mut V, node: Node, source: &str) {
    visitor.visit(node, source);
}

/// Example: Collect all function names
pub struct FunctionCollector {
    pub functions: Vec<FunctionInfo>,
}

pub struct FunctionInfo {
    pub name: String,
    pub is_waitless: bool,
    pub line: usize,
}

impl FunctionCollector {
    pub fn new() -> Self {
        Self { functions: Vec::new() }
    }
}

impl Visitor for FunctionCollector {
    fn visit_function_definition(&mut self, node: Node, source: &str) {
        let mut name = String::new();
        let mut is_waitless = false;
        
        let mut cursor = node.walk();
        for child in node.children(&mut cursor) {
            match child.kind() {
                "identifier" => {
                    name = source[child.byte_range()].to_string();
                }
                "effect_modifier" => {
                    is_waitless = source[child.byte_range()] == *"waitless";
                }
                _ => {}
            }
        }

        if !name.is_empty() {
            self.functions.push(FunctionInfo {
                name,
                is_waitless,
                line: node.start_position().row + 1,
            });
        }

        self.visit_children(node, source);
    }
}

/// Example: Collect all handle pool types
pub struct HandlePoolCollector {
    pub pools: Vec<HandlePoolInfo>,
}

pub struct HandlePoolInfo {
    pub type_name: String,
    pub capacity: Option<u64>,
    pub line: usize,
}

impl HandlePoolCollector {
    pub fn new() -> Self {
        Self { pools: Vec::new() }
    }
}

impl Visitor for HandlePoolCollector {
    fn visit_handle_pool_definition(&mut self, node: Node, source: &str) {
        let mut type_name = String::new();
        let mut capacity = None;

        let mut cursor = node.walk();
        for child in node.children(&mut cursor) {
            match child.kind() {
                "type_identifier" => {
                    type_name = source[child.byte_range()].to_string();
                }
                "pool_option" => {
                    // Parse capacity: value pairs
                    let mut opt_cursor = child.walk();
                    let mut key = String::new();
                    for opt_child in child.children(&mut opt_cursor) {
                        match opt_child.kind() {
                            "identifier" => {
                                key = source[opt_child.byte_range()].to_string();
                            }
                            "integer" if key == "capacity" => {
                                if let Ok(val) = source[opt_child.byte_range()].parse() {
                                    capacity = Some(val);
                                }
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
        }

        if !type_name.is_empty() {
            self.pools.push(HandlePoolInfo {
                type_name,
                capacity,
                line: node.start_position().row + 1,
            });
        }
    }
}
```

---

## Syntax Highlighting Queries (`queries/highlights.scm`)

```scheme
; highlights.scm - Syntax highlighting for Simple language

; Keywords
[
  "struct" "class" "enum" "trait" "actor" "impl"
  "fn" "let" "mut" "immut" "type"
  "if" "else" "elif" "match" "case"
  "for" "while" "loop" "break" "continue" "return"
  "spawn" "send" "receive" "on" "state"
  "waitless" "async" "await"
  "new" "move"
  "context" "macro" "handle_pool" "gen_code"
  "pub" "priv" "extern" "static" "const" "global"
  "where" "as" "in" "is"
] @keyword

; Operators
[
  "and" "or" "not"
] @keyword.operator

; Boolean literals
[
  "true" "false"
] @boolean

; Nil literal
"nil" @constant.builtin

; Self
"self" @variable.builtin
"Self" @type.builtin

; Types
(type_identifier) @type
(simple_type) @type

; Pointer type prefixes
(pointer_type
  ["&" "*" "-" "+"] @type.qualifier)

; Functions
(function_definition
  name: (identifier) @function)

(method_definition
  name: (identifier) @function.method)

(call_expression
  function: (identifier) @function.call)

(method_call_expression
  method: (identifier) @function.method.call)

; Parameters
(parameter
  name: (identifier) @variable.parameter)

(lambda_param) @variable.parameter
(typed_lambda_param
  name: (identifier) @variable.parameter)

; Variables
(identifier) @variable

; Fields
(field_definition
  name: (identifier) @property)

(field_access
  field: (identifier) @property)

(field_argument
  name: (identifier) @property)

; Struct/Class names
(struct_definition
  name: (type_identifier) @type.definition)

(class_definition
  name: (type_identifier) @type.definition)

; Enum
(enum_definition
  name: (type_identifier) @type.definition)

(enum_variant
  name: (type_identifier) @constructor)

; Trait
(trait_definition
  name: (type_identifier) @type.definition)

; Actor
(actor_definition
  name: (type_identifier) @type.definition)

(message_handler
  message: (type_identifier) @constructor)

; Handle pool
(handle_pool_definition
  type: (type_identifier) @type.definition)

; Literals
(integer) @number
(float) @number.float
(string) @string
(char) @character
(symbol) @symbol

; String interpolation
(interpolation
  "{" @punctuation.special
  "}" @punctuation.special)

(escape_sequence) @string.escape

; Comments
(comment) @comment

; Operators
[
  "+" "-" "*" "/" "%" "**"
  "==" "!=" "<" ">" "<=" ">="
  "=" "->" "<-"
  "&&" "||" "!"
  "&" "|" "^" "~" "<<" ">>"
] @operator

; Punctuation
[ "(" ")" "[" "]" "{" "}" ] @punctuation.bracket
[ ":" ";" "," "." ".." "..." "@" "#" "\\" "?" ] @punctuation.delimiter

; Effect modifiers
(effect_modifier) @attribute

; Macros
(macro_definition
  name: (identifier) @function.macro)
```

---

## Local Variables Queries (`queries/locals.scm`)

```scheme
; locals.scm - Scope and reference tracking for Simple

; Scopes
(source_file) @scope
(function_definition) @scope
(method_definition) @scope
(block) @scope
(lambda_expression) @scope
(for_statement) @scope
(match_statement) @scope
(case_clause) @scope
(actor_definition) @scope
(message_handler) @scope

; Definitions
(function_definition
  name: (identifier) @definition.function)

(method_definition
  name: (identifier) @definition.method)

(struct_definition
  name: (type_identifier) @definition.type)

(class_definition
  name: (type_identifier) @definition.type)

(enum_definition
  name: (type_identifier) @definition.type)

(trait_definition
  name: (type_identifier) @definition.type)

(actor_definition
  name: (type_identifier) @definition.type)

(handle_pool_definition
  type: (type_identifier) @definition.type)

(let_statement
  pattern: (identifier_pattern) @definition.var)

(parameter
  name: (identifier) @definition.parameter)

(lambda_param) @definition.parameter

(typed_lambda_param
  name: (identifier) @definition.parameter)

(for_statement
  pattern: (identifier_pattern) @definition.var)

(field_definition
  name: (identifier) @definition.field)

; References
(identifier) @reference
(type_identifier) @reference
```

---

## Indentation Queries (`queries/indents.scm`)

```scheme
; indents.scm - Automatic indentation rules for Simple

; Indent after these nodes
[
  (function_definition)
  (method_definition)
  (struct_definition)
  (class_definition)
  (enum_definition)
  (trait_definition)
  (impl_block)
  (actor_definition)
  (handle_pool_definition)
  (macro_definition)
  (if_statement)
  (elif_clause)
  (else_clause)
  (for_statement)
  (while_statement)
  (loop_statement)
  (match_statement)
  (case_clause)
  (receive_block)
  (context_block)
  (state_block)
  (message_handler)
] @indent

; Dedent at block end
(block) @dedent

; Align case clauses
(case_clause) @aligned_indent
```

---

## Example Usage

### Basic Parsing

```rust
use tree_sitter_simple::{language, SimpleParser};

fn main() {
    let mut parser = SimpleParser::new().unwrap();

    let source = r#"
struct Point:
    x: f64
    y: f64

fn distance(p1: Point, p2: Point) -> f64:
    let dx = p2.x - p1.x
    let dy = p2.y - p1.y
    return sqrt(dx * dx + dy * dy)

actor GameWorld:
    state:
        players: List[+Player] = []

    on Tick(dt: f64) waitless:
        for handle in self.players:
            match Player.handle_get_mut(handle):
                case Some(player):
                    player.update(dt)
                case None:
                    pass
"#;

    match parser.parse(source) {
        Ok(parsed) => {
            println!("Parse successful!");
            println!("Root node: {}", parsed.tree.root_node().to_sexp());
        }
        Err(e) => {
            eprintln!("Parse error: {:?}", e);
        }
    }
}
```

### Function Extraction

```rust
use tree_sitter_simple::{SimpleParser, visitor::{FunctionCollector, walk}};

fn main() {
    let mut parser = SimpleParser::new().unwrap();
    
    let source = r#"
fn regular_function(x: i64) -> i64:
    return x * 2

fn async_operation() async -> Result[Data]:
    let data = await fetch_data()
    return data

actor Counter:
    state:
        value: i64 = 0

    on Inc(by: i64) waitless:
        self.value = self.value + by
"#;

    let parsed = parser.parse(source).unwrap();
    
    let mut collector = FunctionCollector::new();
    walk(&mut collector, parsed.tree.root_node(), &parsed.source);
    
    for func in &collector.functions {
        println!(
            "Function '{}' at line {} (waitless: {})",
            func.name, func.line, func.is_waitless
        );
    }
}
```

### Handle Pool Analysis

```rust
use tree_sitter_simple::{SimpleParser, visitor::{HandlePoolCollector, walk}};

fn main() {
    let mut parser = SimpleParser::new().unwrap();
    
    let source = r#"
handle_pool Enemy:
    capacity: 10000

handle_pool Projectile:
    capacity: 50000

handle_pool Particle:
    capacity: 100000
"#;

    let parsed = parser.parse(source).unwrap();
    
    let mut collector = HandlePoolCollector::new();
    walk(&mut collector, parsed.tree.root_node(), &parsed.source);
    
    for pool in &collector.pools {
        println!(
            "Handle pool for '{}' at line {} with capacity {:?}",
            pool.type_name, pool.line, pool.capacity
        );
    }
}
```

---

## GLR Parsing Notes

### Why GLR?

Tree-sitter uses GLR (Generalized LR) parsing to handle:

1. **Ambiguous grammar constructs** - Simple has several points where the grammar is locally ambiguous:
   - Type expressions vs comparison expressions (`List[T]` vs `a[b]`)
   - Lambda expressions vs other constructs
   - Struct literals vs blocks

2. **Fast error recovery** - GLR maintains multiple parse states, allowing quick recovery from syntax errors while still producing useful partial parse trees.

3. **Incremental parsing** - The GLR algorithm enables efficient re-parsing of edited files by reusing unchanged subtrees.

### Conflict Resolution

The grammar uses several mechanisms to resolve GLR conflicts:

1. **Precedence declarations** - Explicit precedence levels for operators and constructs
2. **Associativity** - Left/right associativity for binary operators
3. **Inline rules** - Certain rules are inlined to reduce parser states
4. **Conflict declarations** - Explicit listing of acceptable conflicts with automatic resolution

### Performance Characteristics

| Metric | Typical Value |
|--------|---------------|
| Parse throughput | ~10 MB/s on modern hardware |
| Memory per tree | O(n) where n = source size |
| Incremental re-parse | O(log n + changed region) |
| Query time | O(matches) |

---

## File Structure

```
tree-sitter-simple/
 Cargo.toml
 build.rs
 grammar.js
 src/
    lib.rs
    parser.rs
    visitor.rs
    parser.c          (generated)
    scanner.c
    node-types.json   (generated)
 queries/
    highlights.scm
    locals.scm
    indents.scm
    injections.scm
 test/
     corpus/
        definitions.txt
        expressions.txt
        statements.txt
        patterns.txt
        actors.txt
        memory.txt
     highlight/
         sample.simple
```

---

## Building and Testing

```bash
# Generate parser from grammar.js
npx tree-sitter generate

# Build Rust library
cargo build --release

# Run tests
cargo test

# Run Tree-sitter tests
npx tree-sitter test

# Parse a file
npx tree-sitter parse example.simple

# Generate highlighting
npx tree-sitter highlight example.simple
```

---

## Summary

This specification provides a complete lexer and parser implementation for the Simple language:

| Component | Purpose |
|-----------|---------|
| `grammar.js` | Complete GLR grammar with 100+ rules |
| `scanner.c` | External scanner for indentation handling |
| `lib.rs` | Rust bindings and language function |
| `parser.rs` | High-level parsing API with error handling |
| `visitor.rs` | AST visitor pattern for tree traversal |
| `highlights.scm` | Syntax highlighting queries |
| `locals.scm` | Scope and reference tracking |
| `indents.scm` | Auto-indentation rules |

The GLR approach provides fast, robust parsing with excellent error recovery, making it suitable for both batch compilation and interactive IDE use.

