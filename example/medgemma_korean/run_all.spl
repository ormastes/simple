# Run All Training Phases
#
# This script runs the complete progressive LoRA training pipeline:
#   Phase 0: Plain text (Korean fluency)
#   Phase 1: Medical dictionary (terminology)
#   Phase 2: MCQ (medical reasoning)
#
# Each phase builds on the previous one using progressive LoRA to
# prevent catastrophic forgetting.
#
# Usage:
#   ./target/release/simple example/medgemma_korean/run_all.spl

import config
import ml.tracking as Track
import validation.{test_all_phases, ValidationReport}


# ============================================================================
# Configuration
# ============================================================================

fn print_header(title: str):
    """Print formatted header."""
    print("\n")
    print("╔" + "=" * 68 + "╗")
    print("║" + " " * ((68 - title.len()) / 2) + title + " " * ((68 - title.len() + 1) / 2) + "║")
    print("╚" + "=" * 68 + "╝")
    print()


fn print_phase_divider(phase: i32, name: str):
    """Print phase divider."""
    print("\n")
    print("=" * 70)
    print(f"PHASE {phase}: {name}")
    print("=" * 70)
    print()


# ============================================================================
# Phase Runners
# ============================================================================

fn run_phase_0():
    """Run Phase 0: Plain text training."""
    print_phase_divider(0, "PLAIN TEXT TRAINING")

    # TODO: Import and run train_phase0
    # import train_phase0
    # train_phase0.main()

    print("Phase 0 training script would run here")
    print("Output: models/phase0/lora_0")
    print("✓ Phase 0 complete")


fn run_phase_1():
    """Run Phase 1: Medical dictionary training."""
    print_phase_divider(1, "MEDICAL DICTIONARY TRAINING")

    # TODO: Import and run train_phase1
    # import train_phase1
    # train_phase1.main()

    print("Phase 1 training script would run here")
    print("Progressive LoRA:")
    print("  - Merge: models/phase0/lora_0")
    print("  - Add: LoRA_1 (trainable)")
    print("Output: models/phase1/lora_1")
    print("✓ Phase 1 complete")


fn run_phase_2():
    """Run Phase 2: MCQ training."""
    print_phase_divider(2, "MCQ TRAINING (MEDICAL REASONING)")

    # TODO: Import and run train_phase2
    # import train_phase2
    # train_phase2.main()

    print("Phase 2 training script would run here")
    print("Progressive LoRA:")
    print("  - Merge: models/phase0/lora_0")
    print("  - Merge: models/phase1/lora_1")
    print("  - Add: LoRA_2 (trainable)")
    print("Output: models/phase2/lora_2")
    print("✓ Phase 2 complete")


# ============================================================================
# Validation After Each Phase
# ============================================================================

fn validate_after_phase(
    phase: i32,
    model: any,
    tokenizer: any,
    device: str
) -> bool:
    """Validate knowledge retention after training phase.

    Args:
        phase: Phase number (0, 1, 2)
        model: Trained model
        tokenizer: Tokenizer
        device: Device

    Returns:
        True if validation passed
    """
    print("\n" + "-" * 70)
    print(f"VALIDATION AFTER PHASE {phase}")
    print("-" * 70)

    # TODO: Implement actual validation
    # val report = test_all_phases(model, tokenizer, [], device)
    # report.print()
    # return not report.has_catastrophic_forgetting()

    # Mock validation
    print(f"Running validation tests...")

    if phase >= 0:
        print("  [✓] Phase 0: Korean fluency - PASS")

    if phase >= 1:
        print("  [✓] Phase 1: Medical dictionary - PASS")

    if phase >= 2:
        print("  [✓] Phase 2: MCQ reasoning - PASS")

    print("\n✓ All tests passed - No catastrophic forgetting!")
    return true


# ============================================================================
# Progress Tracking
# ============================================================================

class PipelineProgress:
    """Track overall pipeline progress.

    Attributes:
        total_phases: Total number of phases
        completed_phases: Number of completed phases
        failed_phase: Phase that failed (or -1)
        start_time: Pipeline start time
        phase_times: Time taken per phase
    """
    total_phases: i32
    completed_phases: i32
    failed_phase: i32
    start_time: f64
    phase_times: [f64]

    fn __init__(total_phases: i32):
        self.total_phases = total_phases
        self.completed_phases = 0
        self.failed_phase = -1
        self.start_time = 0.0  # TODO: Get actual time
        self.phase_times = []

    fn start_phase(phase: i32):
        """Mark phase as started."""
        print(f"\n[Pipeline] Starting Phase {phase}/{self.total_phases - 1}")

    fn complete_phase(phase: i32, elapsed: f64):
        """Mark phase as completed."""
        self.completed_phases += 1
        self.phase_times.append(elapsed)
        print(f"[Pipeline] Phase {phase} completed in {elapsed:.1f}s")

    fn fail_phase(phase: i32, error: str):
        """Mark phase as failed."""
        self.failed_phase = phase
        print(f"[Pipeline] Phase {phase} FAILED: {error}")

    fn print_summary():
        """Print pipeline summary."""
        print("\n" + "=" * 70)
        print("PIPELINE SUMMARY")
        print("=" * 70)
        print(f"Total phases: {self.total_phases}")
        print(f"Completed: {self.completed_phases}")

        if self.failed_phase >= 0:
            print(f"Failed at: Phase {self.failed_phase}")
        else:
            print("Status: ✓ ALL PHASES COMPLETE")

        print()
        print("Phase timings:")
        for (i, time) in self.phase_times.enumerate():
            print(f"  Phase {i}: {time:.1f}s")

        if self.phase_times.len() > 0:
            val total_time = sum(self.phase_times)
            print(f"\nTotal time: {total_time:.1f}s")

        print("=" * 70)


# ============================================================================
# Main Pipeline
# ============================================================================

fn main():
    """Main entry point for complete training pipeline."""
    print_header("MEDGEMMA KOREAN - PROGRESSIVE LORA TRAINING")

    print("This pipeline will train a Korean medical LM in 3 phases:")
    print("  Phase 0: Plain text (Korean fluency)")
    print("  Phase 1: Medical dictionary (terminology)")
    print("  Phase 2: MCQ (medical reasoning)")
    print()
    print("Each phase uses progressive LoRA to prevent catastrophic forgetting.")
    print()

    # Initialize progress tracking
    val progress = PipelineProgress(total_phases=3)

    # Configuration
    val device = "cuda:0"
    val model = 0  # TODO: Load actual model
    val tokenizer = 0  # TODO: Load actual tokenizer

    # ========================================================================
    # Phase 0: Plain Text
    # ========================================================================
    try:
        progress.start_phase(0)
        val start_time = 0.0  # TODO: Get actual time

        run_phase_0()

        # Validate
        if not validate_after_phase(0, model, tokenizer, device):
            progress.fail_phase(0, "Validation failed")
            return 1

        val elapsed = 100.0  # TODO: Calculate actual elapsed time
        progress.complete_phase(0, elapsed)

    except Exception as e:
        progress.fail_phase(0, f"Training error: {e}")
        return 1

    # ========================================================================
    # Phase 1: Medical Dictionary
    # ========================================================================
    try:
        progress.start_phase(1)
        val start_time = 0.0

        run_phase_1()

        # Validate (should retain Phase 0 + learn Phase 1)
        if not validate_after_phase(1, model, tokenizer, device):
            progress.fail_phase(1, "Validation failed - catastrophic forgetting!")
            return 1

        val elapsed = 150.0
        progress.complete_phase(1, elapsed)

    except Exception as e:
        progress.fail_phase(1, f"Training error: {e}")
        return 1

    # ========================================================================
    # Phase 2: MCQ
    # ========================================================================
    try:
        progress.start_phase(2)
        val start_time = 0.0

        run_phase_2()

        # Validate (should retain Phase 0 + 1 + learn Phase 2)
        if not validate_after_phase(2, model, tokenizer, device):
            progress.fail_phase(2, "Validation failed - catastrophic forgetting!")
            return 1

        val elapsed = 200.0
        progress.complete_phase(2, elapsed)

    except Exception as e:
        progress.fail_phase(2, f"Training error: {e}")
        return 1

    # ========================================================================
    # Pipeline Complete
    # ========================================================================
    print("\n" + "=" * 70)
    print("SUCCESS: ALL PHASES COMPLETED!")
    print("=" * 70)
    print()
    print("Final model capabilities:")
    print("  ✓ Korean language fluency (Phase 0)")
    print("  ✓ Medical terminology (Phase 1)")
    print("  ✓ Medical reasoning with MCQ (Phase 2)")
    print()
    print("Progressive LoRA prevented catastrophic forgetting!")
    print()
    print("Final model:")
    print("  Base: google/medgemma-4b-it")
    print("  LoRA_0: models/phase0/lora_0 (Korean fluency)")
    print("  LoRA_1: models/phase1/lora_1 (Medical terms)")
    print("  LoRA_2: models/phase2/lora_2 (MCQ reasoning)")
    print()
    print("To use final model:")
    print("  1. Load base model")
    print("  2. Merge LoRA_0")
    print("  3. Merge LoRA_1")
    print("  4. Merge LoRA_2")
    print("  -> Full model with all knowledge!")
    print("=" * 70)

    # Print summary
    progress.print_summary()

    return 0


# ============================================================================
# Entry Point
# ============================================================================

val exit_code = main()
if exit_code == 0:
    print("\n✓ Pipeline completed successfully!")
else:
    print("\n✗ Pipeline failed with exit code {exit_code}")

# Return exit code (for shell integration)
# TODO: Implement actual exit() when available
print(f"\nExit code: {exit_code}")
