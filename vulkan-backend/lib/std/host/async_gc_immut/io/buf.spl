# Buffered I/O - Immutable Variant
# All buffer operations return new buffer instances

use units.size.*

# Immutable buffer - operations return new buffers
struct Buffer:
    data: Bytes
    capacity: ByteCount

impl Buffer:
    # Create empty buffer with capacity
    fn with_capacity(cap: ByteCount) -> Buffer:
        Buffer { data: Bytes::empty(), capacity: cap }

    # Create from bytes
    fn from_bytes(bytes: Bytes) -> Buffer:
        Buffer { data: bytes, capacity: (bytes.len() as ByteCount) }

    fn len() -> ByteCount:
        self.data.len() as ByteCount

    fn capacity() -> ByteCount:
        self.capacity

    fn is_empty() -> bool:
        self.data.is_empty()

    fn remaining() -> ByteCount:
        self.capacity - self.len()

    # Append data, return new buffer
    fn append(data: Bytes) -> Option[Buffer]:
        val new_len = self.len() + (data.len() as ByteCount)
        if new_len > self.capacity:
            return None
        Some(Buffer { data: self.data.append(data), capacity: self.capacity })

    # Clear buffer, return empty buffer with same capacity
    fn cleared() -> Buffer:
        Buffer { data: Bytes::empty(), capacity: self.capacity }

    # Take first n bytes, return (taken, remaining)
    fn take(n: ByteCount) -> (Bytes, Buffer):
        val take_count = min(n, self.len())
        val taken = self.data.slice(0, take_count as u64)
        val remaining = self.data.slice(take_count as u64, self.data.len())
        (taken, Buffer { data: remaining, capacity: self.capacity })

    # Get data as byte slice (cheap borrow)
    fn as_bytes() -> &[u8]:
        &self.data

    # Get a copy of data as Bytes (allocates)
    fn to_bytes() -> Bytes:
        self.data.clone()

    # Consume buffer and return data
    fn into_bytes() -> Bytes:
        self.data

# Immutable read buffer with fill tracking
struct ReadBuffer:
    inner: Buffer
    read_pos: ByteCount

impl ReadBuffer:
    fn new(capacity: ByteCount) -> ReadBuffer:
        ReadBuffer { inner: Buffer::with_capacity(capacity), read_pos: 0_bytes }

    fn from_bytes(bytes: Bytes) -> ReadBuffer:
        ReadBuffer { inner: Buffer::from_bytes(bytes), read_pos: 0_bytes }

    fn available() -> ByteCount:
        self.inner.len() - self.read_pos

    fn is_empty() -> bool:
        self.available() == 0_bytes

    # Read n bytes, return (bytes, new_buffer)
    fn read(n: ByteCount) -> (Bytes, ReadBuffer):
        val take_count = min(n, self.available())
        val data = self.inner.data.slice(
            self.read_pos as u64,
            (self.read_pos + take_count) as u64
        )
        (data, ReadBuffer { inner: self.inner, read_pos: self.read_pos + take_count })

    # Fill buffer with more data, return new buffer
    fn fill(data: Bytes) -> Option[ReadBuffer]:
        # Compact: move unread data to front
        val unread = self.inner.data.slice(self.read_pos as u64, self.inner.data.len())
        val compacted = Buffer { data: unread.append(data), capacity: self.inner.capacity }
        if compacted.len() > self.inner.capacity:
            return None
        Some(ReadBuffer { inner: compacted, read_pos: 0_bytes })

# Immutable write buffer
struct WriteBuffer:
    inner: Buffer
    flushed: ByteCount

impl WriteBuffer:
    fn new(capacity: ByteCount) -> WriteBuffer:
        WriteBuffer { inner: Buffer::with_capacity(capacity), flushed: 0_bytes }

    fn buffered() -> ByteCount:
        self.inner.len()

    fn total_written() -> ByteCount:
        self.flushed + self.buffered()

    fn remaining() -> ByteCount:
        self.inner.remaining()

    # Write data to buffer, return new buffer or None if full
    fn write(data: Bytes) -> Option[WriteBuffer]:
        match self.inner.append(data):
            case Some(new_inner):
                Some(WriteBuffer { inner: new_inner, flushed: self.flushed })
            case None:
                None

    # Get buffered data and return flushed buffer
    fn flush() -> (Bytes, WriteBuffer):
        val data = self.inner.data
        val new_flushed = self.flushed + self.inner.len()
        (data, WriteBuffer {
            inner: self.inner.cleared(),
            flushed: new_flushed
        })

# Helper
fn min(a: ByteCount, b: ByteCount) -> ByteCount:
    if a < b: a else: b
