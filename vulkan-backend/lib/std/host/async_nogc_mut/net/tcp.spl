# TCP Networking - Async TCP streams and listeners

use units.net.*
use units.size.*
use units.time.*
use host.common.io.error.IoError
use host.common.net.types.Shutdown

# TCP Listener - accepts incoming connections
pub struct TcpListener:
    handle: i64
    local_addr: SocketAddr

impl TcpListener:
    # Bind to address and start listening
    pub async fn bind(addr: SocketAddr) -> Result<TcpListener, IoError>:
        val handle = native_tcp_bind(addr)?
        return Ok(TcpListener {
            handle: handle,
            local_addr: addr
        })

    # Bind to IP and port
    pub async fn bind_to(ip: IpAddr, port: Port) -> Result<TcpListener, IoError>:
        return TcpListener::bind(SocketAddr::new(ip, port))

    # Accept incoming connection
    pub async fn accept(self) -> Result<(TcpStream, SocketAddr), IoError>:
        val (stream_handle, peer_addr) = native_tcp_accept(self.handle)?
        val stream = TcpStream {
            handle: stream_handle,
            peer_addr: peer_addr,
            local_addr: self.local_addr
        }
        return Ok((stream, peer_addr))

    # Get local address
    pub fn local_addr(self) -> SocketAddr:
        return self.local_addr

    # Set connection backlog
    pub fn set_backlog(self, backlog: u32) -> Result<(), IoError>:
        return native_tcp_set_backlog(self.handle, backlog)

    # Close listener
    pub async fn close(self) -> Result<(), IoError>:
        return native_tcp_close(self.handle)

# TCP Stream - bidirectional connection
pub struct TcpStream:
    handle: i64
    peer_addr: SocketAddr
    local_addr: SocketAddr

impl TcpStream:
    # Connect to remote address
    pub async fn connect(addr: SocketAddr) -> Result<TcpStream, IoError>:
        val (handle, local) = native_tcp_connect(addr)?
        return Ok(TcpStream {
            handle: handle,
            peer_addr: addr,
            local_addr: local
        })

    # Connect to IP and port
    pub async fn connect_to(ip: IpAddr, port: Port) -> Result<TcpStream, IoError>:
        return TcpStream::connect(SocketAddr::new(ip, port))

    # Connect with timeout
    pub async fn connect_timeout(addr: SocketAddr, timeout: Duration) -> Result<TcpStream, IoError>:
        val (handle, local) = native_tcp_connect_timeout(addr, timeout)?
        return Ok(TcpStream {
            handle: handle,
            peer_addr: addr,
            local_addr: local
        })

    # Read data
    pub async fn read(self, buf: &mut Bytes) -> Result<ByteCount, IoError>:
        return native_tcp_read(self.handle, buf)

    # Read exact number of bytes
    pub async fn read_exact(self, buf: &mut Bytes) -> Result<(), IoError>:
        var read_total: u64 = 0
        val target = buf.len()
        while read_total < target:
            val slice = buf.slice_mut(read_total, target)
            val n = await self.read(&mut slice)?
            if (n as u64) == 0:
                return Err(IoError::UnexpectedEof)
            read_total = read_total + (n as u64)
        return Ok(())

    # Write data
    pub async fn write(self, data: &Bytes) -> Result<ByteCount, IoError>:
        return native_tcp_write(self.handle, data)

    # Write all data
    pub async fn write_all(self, data: &Bytes) -> Result<(), IoError>:
        var written: u64 = 0
        while written < data.len():
            val n = await self.write(&data.slice(written, data.len()))?
            written = written + (n as u64)
        return Ok(())

    # Flush output buffer
    pub async fn flush(self) -> Result<(), IoError>:
        return native_tcp_flush(self.handle)

    # Shutdown connection
    pub async fn shutdown(self, how: Shutdown) -> Result<(), IoError>:
        return native_tcp_shutdown(self.handle, how)

    # Close connection
    pub async fn close(self) -> Result<(), IoError>:
        return native_tcp_close(self.handle)

    # Get peer address
    pub fn peer_addr(self) -> SocketAddr:
        return self.peer_addr

    # Get local address
    pub fn local_addr(self) -> SocketAddr:
        return self.local_addr

    # Set options
    pub fn set_nodelay(self, nodelay: bool) -> Result<(), IoError>:
        return native_tcp_set_nodelay(self.handle, nodelay)

    pub fn set_keepalive(self, keepalive: Option<Duration>) -> Result<(), IoError>:
        return native_tcp_set_keepalive(self.handle, keepalive)

    pub fn set_read_timeout(self, timeout: Option<Duration>) -> Result<(), IoError>:
        return native_tcp_set_read_timeout(self.handle, timeout)

    pub fn set_write_timeout(self, timeout: Option<Duration>) -> Result<(), IoError>:
        return native_tcp_set_write_timeout(self.handle, timeout)

    # Get options
    pub fn nodelay(self) -> Result<bool, IoError>:
        return native_tcp_get_nodelay(self.handle)

    # Peek data without consuming
    pub async fn peek(self, buf: &mut Bytes) -> Result<ByteCount, IoError>:
        return native_tcp_peek(self.handle, buf)

# Native function declarations
extern fn native_tcp_bind(addr: SocketAddr) -> Result<i64, IoError>
extern fn native_tcp_accept(handle: i64) -> Result<(i64, SocketAddr), IoError>
extern fn native_tcp_connect(addr: SocketAddr) -> Result<(i64, SocketAddr), IoError>
extern fn native_tcp_connect_timeout(addr: SocketAddr, timeout: Duration) -> Result<(i64, SocketAddr), IoError>
extern fn native_tcp_read(handle: i64, buf: &mut Bytes) -> Result<ByteCount, IoError>
extern fn native_tcp_write(handle: i64, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_tcp_flush(handle: i64) -> Result<(), IoError>
extern fn native_tcp_shutdown(handle: i64, how: Shutdown) -> Result<(), IoError>
extern fn native_tcp_close(handle: i64) -> Result<(), IoError>
extern fn native_tcp_set_backlog(handle: i64, backlog: u32) -> Result<(), IoError>
extern fn native_tcp_set_nodelay(handle: i64, nodelay: bool) -> Result<(), IoError>
extern fn native_tcp_set_keepalive(handle: i64, keepalive: Option<Duration>) -> Result<(), IoError>
extern fn native_tcp_set_read_timeout(handle: i64, timeout: Option<Duration>) -> Result<(), IoError>
extern fn native_tcp_set_write_timeout(handle: i64, timeout: Option<Duration>) -> Result<(), IoError>
extern fn native_tcp_get_nodelay(handle: i64) -> Result<bool, IoError>
extern fn native_tcp_peek(handle: i64, buf: &mut Bytes) -> Result<ByteCount, IoError>

# ============================================
# Trait Implementations
# ============================================

use core.traits.*

impl Read for TcpStream:
    fn read(buf: &mut [u8]) -> Result<usize, IoError>:
        var bytes = Bytes::from_slice(buf)
        match native_tcp_read(self.handle, &mut bytes):
            case Ok(count):
                buf.copy_from_slice(&bytes.as_slice())
                Ok(count as usize)
            case Err(e): Err(e)

impl Write for TcpStream:
    fn write(buf: &[u8]) -> Result<usize, IoError>:
        val bytes = Bytes::from_slice(buf)
        match native_tcp_write(self.handle, &bytes):
            case Ok(count): Ok(count as usize)
            case Err(e): Err(e)

    fn flush() -> Result<(), IoError>:
        native_tcp_flush(self.handle)

impl Drop for TcpStream:
    fn drop():
        native_tcp_close(self.handle)

impl Drop for TcpListener:
    fn drop():
        native_tcp_close(self.handle)

