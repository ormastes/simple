# String - UTF-8 string type
# Syntax: str and "..." create String objects
# Implements collection traits for character access

use core.traits.*
use core.collections.*

# ============================================
# String Type Definition
# ============================================

struct String:
    data: *u8
    len: usize       # Byte length
    cap: usize

# ============================================
# String Error Types
# ============================================

enum Utf8Error:
    InvalidByte(position: usize, byte: u8)
    UnexpectedEnd

impl Display for Utf8Error:
    fn fmt() -> str:
        match self:
            case InvalidByte(pos, b): f"invalid UTF-8 byte {b} at position {pos}"
            case UnexpectedEnd: "unexpected end of UTF-8 sequence"

impl Error for Utf8Error

# ============================================
# Constructors
# ============================================

impl String:
    # Create empty string
    static fn new() -> String:
        String { data: nil, len: 0, cap: 0 }

    # Create with pre-allocated capacity
    fn with_capacity(cap: usize) -> String:
        if cap == 0:
            return String::new()
        val data = alloc[u8](cap)
        String { data: data, len: 0, cap: cap }

    # Create from string literal (already UTF-8)
    fn from(s: &str) -> String:
        if s.len() == 0:
            return String::new()
        val len = s.len()
        val data = alloc[u8](len)
        danger:
            copy_mem(data, s.as_ptr(), len)
        String { data: data, len: len, cap: len }

    # Create from UTF-8 bytes (may fail)
    fn from_utf8(bytes: Slice<u8>) -> Result<String, Utf8Error>:
        # Validate UTF-8
        var i: usize = 0
        while i < bytes.len():
            val b = bytes.get(i).expect("valid")
            if b < 0x80:
                # ASCII
                i = i + 1
            else if b < 0xC0:
                return Err(Utf8Error::InvalidByte(i, b))
            else if b < 0xE0:
                # 2-byte sequence
                if i + 1 >= bytes.len():
                    return Err(Utf8Error::UnexpectedEnd)
                i = i + 2
            else if b < 0xF0:
                # 3-byte sequence
                if i + 2 >= bytes.len():
                    return Err(Utf8Error::UnexpectedEnd)
                i = i + 3
            else if b < 0xF8:
                # 4-byte sequence
                if i + 3 >= bytes.len():
                    return Err(Utf8Error::UnexpectedEnd)
                i = i + 4
            else:
                return Err(Utf8Error::InvalidByte(i, b))

        # Valid UTF-8, copy bytes
        val data = alloc[u8](bytes.len())
        danger:
            for j in 0..bytes.len():
                data.offset(j as isize).write(bytes.get(j).expect("valid"))
        Ok(String { data: data, len: bytes.len(), cap: bytes.len() })

    # Create from UTF-8 bytes, replacing invalid sequences
    fn from_utf8_lossy(bytes: Slice<u8>) -> String:
        match String::from_utf8(bytes):
            case Ok(s): s
            case Err(_):
                # Fallback: copy valid ASCII, replace invalid with ?
                var result = String::with_capacity(bytes.len())
                for i in 0..bytes.len():
                    val b = bytes.get(i).expect("valid")
                    if b < 0x80:
                        result.push_byte(b)
                    else:
                        result.push_byte('?' as u8)
                result

    # Create filled with character
    fn filled(c: char, count: usize) -> String:
        var s = String::with_capacity(count * 4)  # Max 4 bytes per char
        for _ in 0..count:
            s.push(c)
        s

# ============================================
# Internal helpers
# ============================================

impl String:
    fn reserve(additional: usize):
        val required = self.len + additional
        if required <= self.cap:
            return

        var new_cap = if self.cap == 0: 16 else: self.cap * 2
        while new_cap < required:
            new_cap = new_cap * 2

        val new_data = alloc[u8](new_cap)
        if self.data != nil:
            danger:
                copy_mem(new_data, self.data, self.len)
                dealloc(self.data)
        self.data = new_data
        self.cap = new_cap

    fn push_byte(b: u8):
        self.reserve(1)
        danger:
            self.data.offset(self.len as isize).write(b)
        self.len = self.len + 1

# ============================================
# Len trait (byte length)
# ============================================

impl Len for String:
    fn len() -> usize:
        self.len

# ============================================
# String-specific size methods
# ============================================

impl String:
    # Number of Unicode characters
    fn char_count() -> usize:
        var count: usize = 0
        var i: usize = 0
        while i < self.len:
            danger:
                val b = self.data.offset(i as isize).read()
                if b < 0x80:
                    i = i + 1
                else if b < 0xE0:
                    i = i + 2
                else if b < 0xF0:
                    i = i + 3
                else:
                    i = i + 4
            count = count + 1
        count

    # Byte length (same as len())
    fn byte_len() -> usize:
        self.len

# ============================================
# Iterable trait (iterates over chars)
# ============================================

impl Iterable<char> for String:
    type Iter = StringCharIter

    fn iter() -> Self::Iter:
        StringCharIter { string: self, byte_index: 0 }

    fn into_iter() -> Self::Iter:
        self.iter()

# ============================================
# Collection trait
# ============================================

impl Collection<char> for String

# ============================================
# Sequence trait (character access)
# ============================================

impl Sequence<char> for String:
    fn get(idx: usize) -> Option<char>:
        # Get character at character index (not byte index)
        var char_idx: usize = 0
        var byte_idx: usize = 0
        while byte_idx < self.len:
            if char_idx == idx:
                return Some(self.char_at_byte(byte_idx))
            byte_idx = byte_idx + self.char_width_at(byte_idx)
            char_idx = char_idx + 1
        None

    fn slice(start: usize, end: usize) -> Slice<u8>:
        # Slice by byte indices
        if start > end or end > self.len:
            Slice::empty()
        else:
            danger:
                Slice::new(self.data.offset(start as isize), end - start)

# ============================================
# ImmutSequence trait (strings are immutable-style)
# ============================================

impl ImmutSequence<char> for String:
    type Output = String

    fn with_index(idx: usize, value: char) -> Option<Self::Output>:
        # Replace character at index
        var new_str = String::new()
        var char_idx: usize = 0
        for c in self.iter():
            if char_idx == idx:
                new_str.push(value)
            else:
                new_str.push(c)
            char_idx = char_idx + 1
        if char_idx <= idx:
            None
        else:
            Some(new_str)

    fn sorted() -> Self::Output:
        # Sort characters
        var chars = List<char>::new()
        for c in self.iter():
            chars.push(c)
        chars.sort()
        var result = String::new()
        for c in chars:
            result.push(c)
        result

    fn reversed() -> Self::Output:
        var chars = List<char>::new()
        for c in self.iter():
            chars.push(c)
        chars.reverse()
        var result = String::new()
        for c in chars:
            result.push(c)
        result

    fn filtered(predicate: fn(&char) -> bool) -> Self::Output:
        var result = String::new()
        for c in self.iter():
            if predicate(&c):
                result.push(c)
        result

    fn mapped<U>(self, f: fn(char) -> U) -> List<U>:
        var result = List::new()
        for c in self.iter():
            result.push(f(c))
        result

    fn appended(item: char) -> Self::Output:
        var result = self.clone()
        result.push(item)
        result

    fn prepended(item: char) -> Self::Output:
        var result = String::new()
        result.push(item)
        result.push_str(self.as_str())
        result

    fn taken(n: usize) -> Self::Output:
        var result = String::new()
        var count: usize = 0
        for c in self.iter():
            if count >= n:
                break
            result.push(c)
            count = count + 1
        result

    fn dropped(n: usize) -> Self::Output:
        var result = String::new()
        var count: usize = 0
        for c in self.iter():
            if count >= n:
                result.push(c)
            count = count + 1
        result

    fn taken_while(predicate: fn(&char) -> bool) -> Self::Output:
        var result = String::new()
        for c in self.iter():
            if not predicate(&c):
                break
            result.push(c)
        result

    fn dropped_while(predicate: fn(&char) -> bool) -> Self::Output:
        var result = String::new()
        var dropping = true
        for c in self.iter():
            if dropping and predicate(&c):
                continue
            dropping = false
            result.push(c)
        result

# ============================================
# Sliceable trait (byte slices)
# ============================================

impl Sliceable<u8> for String:
    fn as_slice() -> Slice<u8>:
        danger:
            Slice::new(self.data, self.len)

# ============================================
# String mutation methods
# ============================================

impl String:
    # Push single character
    fn push(c: char):
        val width = c.len_utf8()
        self.reserve(width)
        danger:
            c.encode_utf8_to(self.data.offset(self.len as isize))
        self.len = self.len + width

    # Push string slice
    fn push_str(s: &str):
        self.reserve(s.len())
        danger:
            copy_mem(self.data.offset(self.len as isize), s.as_ptr(), s.len())
        self.len = self.len + s.len()

    # Pop last character
    fn pop() -> Option<char>:
        if self.len == 0:
            return None
        # Find start of last character
        var i = self.len - 1
        danger:
            while i > 0 and (self.data.offset(i as isize).read() & 0xC0) == 0x80:
                i = i - 1
        val c = self.char_at_byte(i)
        self.len = i
        Some(c)

    # Clear string
    fn clear():
        self.len = 0

    # Truncate to byte length
    fn truncate(new_len: usize):
        if new_len < self.len:
            self.len = new_len

# ============================================
# String search methods
# ============================================

impl String:
    fn contains(needle: &str) -> bool:
        self.find_str(needle).is_some()

    fn starts_with(prefix: &str) -> bool:
        if prefix.len() > self.len:
            return false
        danger:
            for i in 0..prefix.len():
                if self.data.offset(i as isize).read() != prefix.as_ptr().offset(i as isize).read():
                    return false
        true

    fn ends_with(suffix: &str) -> bool:
        if suffix.len() > self.len:
            return false
        val offset = self.len - suffix.len()
        danger:
            for i in 0..suffix.len():
                if self.data.offset((offset + i) as isize).read() != suffix.as_ptr().offset(i as isize).read():
                    return false
        true

    fn find_str(needle: &str) -> Option<usize>:
        if needle.len() > self.len or needle.is_empty():
            return None
        val end = self.len - needle.len() + 1
        for i in 0..end:
            var found = true
            danger:
                for j in 0..needle.len():
                    if self.data.offset((i + j) as isize).read() != needle.as_ptr().offset(j as isize).read():
                        found = false
                        break
            if found:
                return Some(i)
        None

# ============================================
# String transformation methods (return new)
# ============================================

impl String:
    fn trimmed() -> String:
        var start: usize = 0
        var end = self.len
        danger:
            while start < end and is_whitespace(self.data.offset(start as isize).read()):
                start = start + 1
            while end > start and is_whitespace(self.data.offset((end - 1) as isize).read()):
                end = end - 1
        self.substring(start, end)

    fn trim_start() -> String:
        var start: usize = 0
        danger:
            while start < self.len and is_whitespace(self.data.offset(start as isize).read()):
                start = start + 1
        self.substring(start, self.len)

    fn trim_end() -> String:
        var end = self.len
        danger:
            while end > 0 and is_whitespace(self.data.offset((end - 1) as isize).read()):
                end = end - 1
        self.substring(0, end)

    fn uppercased() -> String:
        var result = String::with_capacity(self.len)
        danger:
            for i in 0..self.len:
                val b = self.data.offset(i as isize).read()
                if b >= 'a' as u8 and b <= 'z' as u8:
                    result.push_byte(b - 32)
                else:
                    result.push_byte(b)
        result

    fn lowercased() -> String:
        var result = String::with_capacity(self.len)
        danger:
            for i in 0..self.len:
                val b = self.data.offset(i as isize).read()
                if b >= 'A' as u8 and b <= 'Z' as u8:
                    result.push_byte(b + 32)
                else:
                    result.push_byte(b)
        result

    fn replaced(old: &str, new: &str) -> String:
        if old.is_empty():
            return self.clone()
        var result = String::new()
        var i: usize = 0
        while i < self.len:
            match self.find_str_from(old, i):
                case Some(pos):
                    result.push_str(self.substring(i, pos).as_str())
                    result.push_str(new)
                    i = pos + old.len()
                case None:
                    result.push_str(self.substring(i, self.len).as_str())
                    break
        result

    fn substring(start: usize, end: usize) -> String:
        if start >= end or start >= self.len:
            return String::new()
        val actual_end = if end > self.len: self.len else: end
        val len = actual_end - start
        var result = String::with_capacity(len)
        danger:
            copy_mem(result.data, self.data.offset(start as isize), len)
        result.len = len
        result

# ============================================
# String split methods
# ============================================

impl String:
    fn split(sep: &str) -> List<String>:
        var result = List::new()
        if sep.is_empty():
            # Split into characters
            for c in self.iter():
                var s = String::new()
                s.push(c)
                result.push(s)
            return result

        var start: usize = 0
        while start < self.len:
            match self.find_str_from(sep, start):
                case Some(pos):
                    result.push(self.substring(start, pos))
                    start = pos + sep.len()
                case None:
                    result.push(self.substring(start, self.len))
                    break
        result

    fn split_once(sep: &str) -> Option<(String, String)>:
        match self.find_str(sep):
            case Some(pos):
                Some((self.substring(0, pos), self.substring(pos + sep.len(), self.len)))
            case None:
                None

    fn lines() -> List<String>:
        self.split("\n")

# ============================================
# Internal helper methods
# ============================================

impl String:
    fn char_at_byte(byte_idx: usize) -> char:
        danger:
            val b0 = self.data.offset(byte_idx as isize).read()
            if b0 < 0x80:
                return b0 as char
            else if b0 < 0xE0:
                val b1 = self.data.offset((byte_idx + 1) as isize).read()
                return (((b0 & 0x1F) as u32 << 6) | ((b1 & 0x3F) as u32)) as char
            else if b0 < 0xF0:
                val b1 = self.data.offset((byte_idx + 1) as isize).read()
                val b2 = self.data.offset((byte_idx + 2) as isize).read()
                return (((b0 & 0x0F) as u32 << 12) | ((b1 & 0x3F) as u32 << 6) | ((b2 & 0x3F) as u32)) as char
            else:
                val b1 = self.data.offset((byte_idx + 1) as isize).read()
                val b2 = self.data.offset((byte_idx + 2) as isize).read()
                val b3 = self.data.offset((byte_idx + 3) as isize).read()
                return (((b0 & 0x07) as u32 << 18) | ((b1 & 0x3F) as u32 << 12) | ((b2 & 0x3F) as u32 << 6) | ((b3 & 0x3F) as u32)) as char

    fn char_width_at(byte_idx: usize) -> usize:
        danger:
            val b = self.data.offset(byte_idx as isize).read()
            if b < 0x80: 1
            else if b < 0xE0: 2
            else if b < 0xF0: 3
            else: 4

    fn find_str_from(needle: &str, start: usize) -> Option<usize>:
        if needle.len() > self.len - start or needle.is_empty():
            return None
        val end = self.len - needle.len() + 1
        for i in start..end:
            var found = true
            danger:
                for j in 0..needle.len():
                    if self.data.offset((i + j) as isize).read() != needle.as_ptr().offset(j as isize).read():
                        found = false
                        break
            if found:
                return Some(i)
        None

    fn as_str() -> &str:
        danger:
            &*(self.data as *str)

    fn as_bytes() -> Slice<u8>:
        danger:
            Slice::new(self.data, self.len)

# ============================================
# Standard trait implementations
# ============================================

impl Clone for String:
    fn clone() -> Self:
        if self.len == 0:
            return String::new()
        val data = alloc[u8](self.len)
        danger:
            copy_mem(data, self.data, self.len)
        String { data: data, len: self.len, cap: self.len }

impl Default for String:
    static fn default() -> Self:
        String::new()

impl Eq for String:
    fn eq(other: &Self) -> bool:
        if self.len != other.len:
            return false
        danger:
            for i in 0..self.len:
                if self.data.offset(i as isize).read() != other.data.offset(i as isize).read():
                    return false
        true

impl Ord for String:
    fn cmp(other: &Self) -> Ordering:
        val min_len = if self.len < other.len: self.len else: other.len
        danger:
            for i in 0..min_len:
                val a = self.data.offset(i as isize).read()
                val b = other.data.offset(i as isize).read()
                if a < b:
                    return Ordering::Less
                if a > b:
                    return Ordering::Greater
        if self.len < other.len:
            Ordering::Less
        else if self.len > other.len:
            Ordering::Greater
        else:
            Ordering::Equal

impl Hash for String:
    fn hash() -> u64:
        var h: u64 = 0
        danger:
            for i in 0..self.len:
                h = h * 31 + (self.data.offset(i as isize).read() as u64)
        h

impl Display for String:
    fn fmt() -> str:
        self.as_str()

impl Drop for String:
    fn drop():
        if self.data != nil:
            danger:
                dealloc(self.data)

impl Add<&str> for String:
    type Output = String

    fn add(rhs: &str) -> Self::Output:
        var result = self.clone()
        result.push_str(rhs)
        result

impl Add<String> for String:
    type Output = String

    fn add(rhs: String) -> Self::Output:
        var result = self.clone()
        result.push_str(rhs.as_str())
        result

# ============================================
# String Character Iterator
# ============================================

struct StringCharIter:
    string: String
    byte_index: usize

impl Iterator for StringCharIter:
    type Item = char

    fn next() -> Option<Self::Item>:
        if self.byte_index >= self.string.len:
            return None
        val c = self.string.char_at_byte(self.byte_index)
        self.byte_index = self.byte_index + self.string.char_width_at(self.byte_index)
        Some(c)

impl ExactSizeIterator for StringCharIter:
    fn len() -> usize:
        # Count remaining characters
        var count: usize = 0
        var i = self.byte_index
        while i < self.string.len:
            i = i + self.string.char_width_at(i)
            count = count + 1
        count

# ============================================
# Bytes Type (binary data)
# ============================================

type Bytes = List<u8>

impl Bytes:
    fn from_string(s: String) -> Bytes:
        var bytes = List::with_capacity(s.len)
        danger:
            for i in 0..s.len:
                bytes.push(s.data.offset(i as isize).read())
        bytes

# ============================================
# Helper functions
# ============================================

fn is_whitespace(b: u8) -> bool:
    b == ' ' as u8 or b == '\t' as u8 or b == '\n' as u8 or b == '\r' as u8

# Character methods (would be in a separate char module)
impl char:
    fn len_utf8() -> usize:
        val code = self as u32
        if code < 0x80: 1
        else if code < 0x800: 2
        else if code < 0x10000: 3
        else: 4

    fn encode_utf8_to(ptr: *u8):
        val code = self as u32
        danger:
            if code < 0x80:
                ptr.write(code as u8)
            else if code < 0x800:
                ptr.write((0xC0 | (code >> 6)) as u8)
                ptr.offset(1).write((0x80 | (code & 0x3F)) as u8)
            else if code < 0x10000:
                ptr.write((0xE0 | (code >> 12)) as u8)
                ptr.offset(1).write((0x80 | ((code >> 6) & 0x3F)) as u8)
                ptr.offset(2).write((0x80 | (code & 0x3F)) as u8)
            else:
                ptr.write((0xF0 | (code >> 18)) as u8)
                ptr.offset(1).write((0x80 | ((code >> 12) & 0x3F)) as u8)
                ptr.offset(2).write((0x80 | ((code >> 6) & 0x3F)) as u8)
                ptr.offset(3).write((0x80 | (code & 0x3F)) as u8)

    fn is_ascii() -> bool:
        (self as u32) < 0x80

    fn is_alphabetic() -> bool:
        val c = self as u32
        (c >= 'a' as u32 and c <= 'z' as u32) or (c >= 'A' as u32 and c <= 'Z' as u32)

    fn is_numeric() -> bool:
        val c = self as u32
        c >= '0' as u32 and c <= '9' as u32

    fn is_alphanumeric() -> bool:
        self.is_alphabetic() or self.is_numeric()

    fn is_whitespace() -> bool:
        val c = self as u32
        c == ' ' as u32 or c == '\t' as u32 or c == '\n' as u32 or c == '\r' as u32

    fn uppercased() -> char:
        val c = self as u32
        if c >= 'a' as u32 and c <= 'z' as u32:
            (c - 32) as char
        else:
            self

    fn lowercased() -> char:
        val c = self as u32
        if c >= 'A' as u32 and c <= 'Z' as u32:
            (c + 32) as char
        else:
            self

# ============================================
# Global string functions
# ============================================

# Join list of strings
fn join(sep: &str, parts: List<String>) -> String:
    var result = String::new()
    for (i, part) in parts.enumerate():
        if i > 0:
            result.push_str(sep)
        result.push_str(part.as_str())
    result

# Format string (simplified)
fn format(template: &str, args: List<String>) -> String:
    var result = String::new()
    var arg_idx: usize = 0
    var i: usize = 0
    while i < template.len():
        danger:
            val b = template.as_ptr().offset(i as isize).read()
            if b == '{' as u8 and i + 1 < template.len():
                val next = template.as_ptr().offset((i + 1) as isize).read()
                if next == '}' as u8:
                    if arg_idx < args.len():
                        result.push_str(args.get(arg_idx).expect("valid").as_str())
                        arg_idx = arg_idx + 1
                    i = i + 2
                    continue
            result.push_byte(b)
        i = i + 1
    result
