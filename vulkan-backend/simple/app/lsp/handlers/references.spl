# References Handler
# Provides find-all-references functionality for symbols

import lsp.protocol as protocol
import lsp.transport as transport
import parser.treesitter.{Tree, Node, NodeId, Span}

# Reference location
class Reference:
    span: Span
    node_id: NodeId
    context: String  # "definition" or "reference"

    fn new(span: Span, node_id: NodeId, context: String) -> Reference:
        Reference(span: span, node_id: node_id, context: context)

# Find node at specific position (reused from hover/definition)
fn find_node_at_position(tree: Tree, line: Int, column: Int) -> Option<Node>:
    fn position_in_span(span: Span, line: Int, column: Int) -> Bool:
        if line < span.start_line or line > span.end_line:
            return false
        if line == span.start_line and column < span.start_column:
            return false
        if line == span.end_line and column > span.end_column:
            return false
        true

    fn traverse(node_id: NodeId, best: Option<Node>) -> Option<Node>:
        match tree.arena.get(node_id):
            case None:
                best
            case Some(node):
                if not position_in_span(node.span, line, column):
                    return best
                var new_best = Some(node)
                for child_id in node.children:
                    new_best = traverse(child_id, new_best)
                new_best

    traverse(tree.root_node, None)

# Find all references to a symbol in the tree
fn find_all_references(tree: Tree, symbol_name: String, include_declaration: Bool) -> List<Reference>:
    var references: List<Reference> = []

    # Traverse tree and collect all identifier nodes matching symbol_name
    fn traverse(node_id: NodeId):
        match tree.arena.get(node_id):
            case None:
                return
            case Some(node):
                # Check if this node is a reference to the symbol
                val is_reference = match node.kind:
                    case "identifier":
                        node.text == symbol_name
                    case _:
                        false

                if is_reference:
                    # Determine if this is a definition or reference
                    val context = determine_context(tree, node_id)

                    # Add to references list
                    if include_declaration or context == "reference":
                        val ref = Reference.new(node.span, node_id, context)
                        references.push(ref)

                # Traverse children
                for child_id in node.children:
                    traverse(child_id)

    traverse(tree.root_node)
    references

# Determine if an identifier is a definition or reference
fn determine_context(tree: Tree, identifier_id: NodeId) -> String:
    # Look at parent node to determine context
    match tree.arena.get(identifier_id):
        case None:
            "reference"
        case Some(identifier_node):
            # Find parent node
            val parent_id = find_parent(tree, identifier_id)

            match parent_id:
                case None:
                    "reference"
                case Some(parent):
                    match tree.arena.get(parent):
                        case None:
                            "reference"
                        case Some(parent_node):
                            # Check parent node kind
                            match parent_node.kind:
                                case "function_def":
                                    # Check if identifier is the function name
                                    match parent_node.fields.get("name"):
                                        case Some(name_id):
                                            if name_id == identifier_id:
                                                "definition"
                                            else:
                                                "reference"
                                        case None:
                                            "reference"

                                case "let_stmt":
                                    # Check if identifier is the pattern (definition)
                                    match parent_node.fields.get("pattern"):
                                        case Some(pattern_id):
                                            if pattern_id == identifier_id:
                                                "definition"
                                            else:
                                                "reference"
                                        case None:
                                            "reference"

                                case "parameter":
                                    # Parameters are definitions
                                    match parent_node.fields.get("name"):
                                        case Some(name_id):
                                            if name_id == identifier_id:
                                                "definition"
                                            else:
                                                "reference"
                                        case None:
                                            "reference"

                                case "struct_def":
                                    # Struct names are definitions
                                    match parent_node.fields.get("name"):
                                        case Some(name_id):
                                            if name_id == identifier_id:
                                                "definition"
                                            else:
                                                "reference"
                                        case None:
                                            "reference"

                                case _:
                                    # Default to reference
                                    "reference"

# Find parent node of a given node (simplified - O(n) search)
fn find_parent(tree: Tree, target_id: NodeId) -> Option<NodeId>:
    fn search(node_id: NodeId) -> Option<NodeId>:
        match tree.arena.get(node_id):
            case None:
                None
            case Some(node):
                # Check if any child matches target
                for child_id in node.children:
                    if child_id == target_id:
                        return Some(node_id)

                # Recursively search children
                for child_id in node.children:
                    match search(child_id):
                        case Some(parent):
                            return Some(parent)
                        case None:
                            continue

                None

    search(tree.root_node)

# Convert references to LSP locations
fn references_to_locations(references: List<Reference>) -> List<Dict>:
    var locations: List<Dict> = []

    for ref in references:
        val location = {
            "range": {
                "start": {
                    "line": ref.span.start_line,
                    "character": ref.span.start_column
                },
                "end": {
                    "line": ref.span.end_line,
                    "character": ref.span.end_column
                }
            }
        }

        locations.push(location)

    locations

# Handle textDocument/references request
fn handle_references(
    tree: Tree,
    source: String,
    line: Int,
    column: Int,
    include_declaration: Bool
) -> Result<Option<List<Dict>>, String>:
    # Find node at cursor
    match find_node_at_position(tree, line, column):
        case None:
            Ok(None)
        case Some(node):
            # Check if this is an identifier
            if node.kind != "identifier":
                return Ok(None)

            val symbol_name = node.text

            # Find all references to this symbol
            val references = find_all_references(tree, symbol_name, include_declaration)

            if references.len() == 0:
                return Ok(None)

            # Convert to LSP locations
            val locations = references_to_locations(references)

            Ok(Some(locations))

# Filter references by scope (for more accurate results)
fn filter_by_scope(references: List<Reference>, tree: Tree, original_node_id: NodeId) -> List<Reference>:
    # Simplified: For now, return all references
    # TODO: Implement proper scope-based filtering
    # - Find the scope of the original node
    # - Filter references to only those in the same scope or child scopes
    references
