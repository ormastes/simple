# Simple Language Canonical Formatter
# Complete formatter with intelligent line breaking and method chaining
# Usage: simple_fmt <file.spl> [--check] [--write] [--diff]

import sys
import io.fs as fs

# Formatting rules
const INDENT_SIZE = 4
const MAX_LINE_LENGTH = 100
const CONTINUATION_INDENT = 8
const BLANK_LINES_BETWEEN_ITEMS = 2

class FormatConfig:
    indent_size: Int
    max_line_length: Int
    use_tabs: Bool
    blank_lines_between_items: Int
    continuation_indent: Int

    static fn new() -> FormatConfig:
        FormatConfig(
            indent_size: INDENT_SIZE,
            max_line_length: MAX_LINE_LENGTH,
            use_tabs: false,
            blank_lines_between_items: BLANK_LINES_BETWEEN_ITEMS,
            continuation_indent: CONTINUATION_INDENT
        )

class Formatter:
    config: FormatConfig
    indent_level: Int

    fn new(config: FormatConfig) -> Formatter:
        Formatter(config: config, indent_level: 0)

    fn format_file(path: String) -> Result<String, String>:
        # Read file
        val content = fs.read_to_string(path)?

        # Parse and format
        val formatted = self.format_source(content)?

        Ok(formatted)

    fn format_source(source: String) -> Result<String, String>:
        val lines = source.split("\n")

        # Separate imports from other content
        var imports = []
        var other_lines = []
        var in_import_section = true

        for line in lines:
            val trimmed = line.trim()

            if trimmed.starts_with("import "):
                imports.push(trimmed)
            elif trimmed.is_empty() and in_import_section:
                # Skip blank lines in import section
                continue
            else:
                if not trimmed.is_empty():
                    in_import_section = false
                other_lines.push(line)

        # Sort imports alphabetically
        imports.sort()

        # Format non-import code
        val formatted_code = self.format_code_lines(other_lines)?

        # Combine sorted imports + blank lines + formatted code
        var result = []

        if imports.len() > 0:
            for imp in imports:
                result.push(imp)

            # Add blank lines between imports and code
            if other_lines.len() > 0:
                for _ in 0..self.config.blank_lines_between_items:
                    result.push("")

        result.extend(formatted_code)

        Ok(result.join("\n"))

    fn format_code_lines(lines: List<String>) -> Result<List<String>, String>:
        var result = []
        var current_indent = 0
        var last_was_def = false
        var blank_line_count = 0

        for line in lines:
            val trimmed = line.trim()

            # Skip empty lines but track them
            if trimmed.is_empty():
                blank_line_count = blank_line_count + 1
                if blank_line_count <= self.config.blank_lines_between_items:
                    result.push("")
                continue

            # Reset blank line counter
            blank_line_count = 0

            # Add blank lines before top-level definitions
            if current_indent == 0 and self.is_definition(trimmed) and last_was_def:
                for _ in 0..self.config.blank_lines_between_items:
                    result.push("")

            # Adjust indent for closing brackets/keywords
            if self.is_dedent_line(trimmed):
                current_indent = max(0, current_indent - 1)

            # Format line with current indent and proper spacing
            val formatted_lines = self.format_line(trimmed, current_indent)

            # Add all formatted lines (may be multiple if line breaking occurred)
            for fmt_line in formatted_lines:
                result.push(fmt_line)

            # Track if this was a definition
            last_was_def = current_indent == 0 and self.is_definition(trimmed)

            # Adjust indent for opening brackets/keywords
            if self.is_indent_line(trimmed):
                current_indent = current_indent + 1

        Ok(result)

    fn is_definition(line: String) -> Bool:
        return line.starts_with("fn ") or line.starts_with("class ") or line.starts_with("struct ") or line.starts_with("enum ") or line.starts_with("trait ") or line.starts_with("impl ")

    fn format_line(line: String, indent: Int) -> List<String>:
        # Apply indentation
        val indent_str = " ".repeat(indent * self.config.indent_size)

        # Apply expression spacing
        val spaced = self.add_expression_spacing(line)

        # Check if line needs breaking
        val full_line = indent_str + spaced

        if full_line.len() > self.config.max_line_length:
            # Line too long - apply intelligent breaking
            return self.break_long_line(spaced, indent)
        else:
            return [full_line]

    fn break_long_line(line: String, base_indent: Int) -> List<String>:
        val indent_str = " ".repeat(base_indent * self.config.indent_size)
        val continuation_str = " ".repeat((base_indent * self.config.indent_size) + self.config.continuation_indent)

        # Check for method chaining (contains multiple dots)
        if self.is_method_chain(line):
            return self.break_method_chain(line, indent_str, continuation_str)

        # Check for function signature (contains "fn " and "->")
        if line.starts_with("fn ") and line.contains("->"):
            return self.break_function_signature(line, indent_str, continuation_str)

        # Check for function call with many arguments
        if line.contains("(") and line.contains(")"):
            return self.break_function_call(line, indent_str, continuation_str)

        # Check for list/dict literal
        if (line.contains("[") or line.contains("{")) and (line.contains("]") or line.contains("}")):
            return self.break_collection(line, indent_str, continuation_str)

        # Default: break at logical operators
        return self.break_at_operators(line, indent_str, continuation_str)

    fn is_method_chain(line: String) -> Bool:
        # Check if line has multiple dots (method chaining)
        val dot_count = 0
        for char in line:
            if char == '.':
                dot_count = dot_count + 1

        return dot_count >= 2

    fn break_method_chain(line: String, indent_str: String, continuation_str: String) -> List<String>:
        # Break method chains so each method call is on its own line
        # Example: obj.method1().method2().method3()
        # Becomes:
        #     obj
        #         .method1()
        #         .method2()
        #         .method3()

        var result = []
        val parts = line.split(".")
        var first = true

        for part in parts:
            if first:
                result.push(indent_str + part)
                first = false
            else:
                result.push(continuation_str + "." + part.trim())

        return result

    fn break_function_signature(line: String, indent_str: String, continuation_str: String) -> List<String>:
        # Break function signature at parameter list
        # Example: fn long_function(param1: Type1, param2: Type2, param3: Type3) -> ReturnType:
        # Becomes:
        #     fn long_function(
        #         param1: Type1,
        #         param2: Type2,
        #         param3: Type3
        #     ) -> ReturnType:

        if not line.contains("(") or not line.contains(")"):
            return [indent_str + line]

        val paren_start = line.index_of("(")
        val paren_end = line.index_of(")")

        val before_params = line[0..paren_start + 1]  # "fn name("
        val params_str = line[paren_start + 1..paren_end]  # "param1: Type1, param2: Type2"
        val after_params = line[paren_end..]  # ") -> ReturnType:"

        # Check if parameters fit on one line
        val params_line = indent_str + before_params + params_str + after_params
        if params_line.len() <= self.config.max_line_length:
            return [params_line]

        # Break parameters across multiple lines
        var result = []
        result.push(indent_str + before_params)

        val params = params_str.split(",")
        for param in params:
            result.push(continuation_str + param.trim() + ",")

        # Remove trailing comma from last parameter
        if result.len() > 1:
            val last_idx = result.len() - 1
            val last_line = result[last_idx]
            if last_line.ends_with(","):
                result[last_idx] = last_line[0..last_line.len() - 1]

        result.push(indent_str + after_params)

        return result

    fn break_function_call(line: String, indent_str: String, continuation_str: String) -> List<String>:
        # Break long function calls across multiple lines
        # Similar to function signature breaking

        if not line.contains("("):
            return [indent_str + line]

        val paren_start = line.index_of("(")
        val paren_end = line.rindex_of(")")

        if paren_end < paren_start:
            return [indent_str + line]

        val before_args = line[0..paren_start + 1]
        val args_str = line[paren_start + 1..paren_end]
        val after_args = line[paren_end..]

        # Check if it fits on one line
        val one_line = indent_str + before_args + args_str + after_args
        if one_line.len() <= self.config.max_line_length:
            return [one_line]

        # Break arguments
        var result = []
        result.push(indent_str + before_args)

        val args = args_str.split(",")
        for arg in args:
            val trimmed = arg.trim()
            if not trimmed.is_empty():
                result.push(continuation_str + trimmed + ",")

        # Remove trailing comma
        if result.len() > 1:
            val last_idx = result.len() - 1
            val last_line = result[last_idx]
            if last_line.ends_with(","):
                result[last_idx] = last_line[0..last_line.len() - 1]

        result.push(indent_str + after_args)

        return result

    fn break_collection(line: String, indent_str: String, continuation_str: String) -> List<String>:
        # Break collections (lists, dicts, arrays) across multiple lines
        # Example: [1, 2, 3, 4, 5]
        # Becomes:
        #     [
        #         1,
        #         2,
        #         3,
        #         4,
        #         5
        #     ]

        val open_bracket = if line.contains("[") then "[" else "{"
        val close_bracket = if line.contains("]") then "]" else "}"

        val bracket_start = line.index_of(open_bracket)
        val bracket_end = line.rindex_of(close_bracket)

        if bracket_end < bracket_start:
            return [indent_str + line]

        val before = line[0..bracket_start + 1]
        val content = line[bracket_start + 1..bracket_end]
        val after = line[bracket_end..]

        # Check if it fits
        val one_line = indent_str + before + content + after
        if one_line.len() <= self.config.max_line_length:
            return [one_line]

        # Break items
        var result = []
        result.push(indent_str + before)

        val items = content.split(",")
        for item in items:
            val trimmed = item.trim()
            if not trimmed.is_empty():
                result.push(continuation_str + trimmed + ",")

        # Remove trailing comma
        if result.len() > 1:
            val last_idx = result.len() - 1
            val last_line = result[last_idx]
            if last_line.ends_with(","):
                result[last_idx] = last_line[0..last_line.len() - 1]

        result.push(indent_str + close_bracket + after)

        return result

    fn break_at_operators(line: String, indent_str: String, continuation_str: String) -> List<String>:
        # Default line breaking: break at logical operators (and, or)
        # or at comparison operators if line is still too long

        val operators = [" and ", " or ", " + ", " - ", " * ", " / "]
        var best_break = -1
        var best_op = ""

        for op in operators:
            if line.contains(op):
                val idx = line.rindex_of(op)  # Break at rightmost operator
                if idx > best_break:
                    best_break = idx
                    best_op = op

        if best_break > 0:
            val first_part = line[0..best_break]
            val second_part = line[best_break + best_op.len()..]

            return [
                indent_str + first_part + best_op,
                continuation_str + second_part
            ]

        # No good break point found - return as is
        return [indent_str + line]

    fn add_expression_spacing(line: String) -> String:
        # Add spaces around binary operators
        var result = line

        # Operators that need spacing
        val operators = ["+", "-", "*", "/", "%", "==", "!=", "<=", ">=", "<", ">", "and", "or", "in", "not in"]

        for op in operators:
            # Add spaces around operator if not already present
            result = result.replace(op, " " + op + " ")

            # Clean up multiple spaces
            while result.contains("  "):
                result = result.replace("  ", " ")

        # Clean up spaces in specific contexts
        result = result.replace("( ", "(")      # No space after opening paren
        result = result.replace(" )", ")")      # No space before closing paren
        result = result.replace("[ ", "[")      # No space after opening bracket
        result = result.replace(" ]", "]")      # No space before closing bracket
        result = result.replace(" ,", ",")      # No space before comma
        result = result.replace(",", ", ")      # Space after comma

        # Clean up function signatures
        result = result.replace(" :", ":")      # No space before colon
        result = result.replace("->", " -> ")   # Spaces around arrow
        result = result.replace("=>", " => ")   # Spaces around fat arrow

        # Clean up dots (no spaces around dots in method calls)
        result = result.replace(" .", ".")
        result = result.replace(". ", ".")

        result.trim()

    fn is_indent_line(line: String) -> Bool:
        # Check if line should increase indent level
        return line.ends_with(":") or line.ends_with("{") or line.ends_with("(") or line.ends_with("[")

    fn is_dedent_line(line: String) -> Bool:
        # Check if line should decrease indent level
        return line.starts_with("}") or line.starts_with(")") or line.starts_with("]") or line.starts_with("else") or line.starts_with("elif") or line.starts_with("except") or line.starts_with("finally")

fn format_file_inplace(path: String) -> Result<Nil, String>:
    val config = FormatConfig.new()
    val formatter = Formatter.new(config)

    val formatted = formatter.format_file(path)?

    fs.write(path, formatted)?

    Ok(nil)

fn check_formatting(path: String) -> Result<Bool, String>:
    val config = FormatConfig.new()
    val formatter = Formatter.new(config)

    val original = fs.read_to_string(path)?
    val formatted = formatter.format_source(original)?

    Ok(original == formatted)

fn main():
    val args = sys.args()

    if args.len() < 2:
        print("Simple Language Canonical Formatter")
        print("=====================================")
        print("")
        print("Usage: simple_fmt <file.spl> [OPTIONS]")
        print("")
        print("Options:")
        print("  --check     Check if file is formatted (exit 1 if not)")
        print("  --write     Format file in place")
        print("  --diff      Show formatting diff")
        print("  --stdout    Print formatted output to stdout (default)")
        print("")
        print("Features:")
        print("  ✓ Automatic import sorting (alphabetical)")
        print("  ✓ Expression spacing (x + y, not x+y)")
        print("  ✓ Blank lines between definitions (2 lines)")
        print("  ✓ Consistent indentation (4 spaces)")
        print("  ✓ Intelligent line breaking (100 char limit)")
        print("  ✓ Method chaining alignment")
        print("  ✓ Function signature formatting")
        print("  ✓ Collection formatting (arrays, dicts)")
        print("")
        print("Examples:")
        print("  simple_fmt app.spl            # Print formatted to stdout")
        print("  simple_fmt app.spl --write    # Format in-place")
        print("  simple_fmt app.spl --check    # Check formatting (CI)")
        print("  simple_fmt app.spl --diff     # Show diff")
        print("")
        print("Formatting Rules:")
        print("  - Max line length: 100 characters")
        print("  - Indentation: 4 spaces (no tabs)")
        print("  - Continuation indent: 8 spaces")
        print("  - Blank lines: 2 between top-level items")
        sys.exit(1)

    val file_path = args[1]
    val check_mode = args.contains("--check")
    val write_mode = args.contains("--write")
    val diff_mode = args.contains("--diff")
    val stdout_mode = args.contains("--stdout") or (!check_mode and !write_mode and !diff_mode)

    # Verify file exists
    if not fs.exists(file_path):
        print("Error: File not found: " + file_path)
        sys.exit(1)

    if check_mode:
        # Check mode: verify formatting
        match check_formatting(file_path):
            case Ok(is_formatted):
                if is_formatted:
                    print("✓ " + file_path + " is formatted")
                    sys.exit(0)
                else:
                    print("✗ " + file_path + " needs formatting")
                    sys.exit(1)
            case Err(error):
                print("Error: " + error)
                sys.exit(1)

    elif write_mode:
        # Write mode: format in place
        match format_file_inplace(file_path):
            case Ok(_):
                print("✓ Formatted " + file_path)
                sys.exit(0)
            case Err(error):
                print("Error: " + error)
                sys.exit(1)

    elif diff_mode:
        # Diff mode: show formatting diff
        val config = FormatConfig.new()
        val formatter = Formatter.new(config)

        match formatter.format_file(file_path):
            case Ok(formatted):
                val original = fs.read_to_string(file_path)?
                if original == formatted:
                    print("✓ " + file_path + " is correctly formatted")
                    sys.exit(0)
                else:
                    print_diff(original, formatted, file_path)
                    sys.exit(1)
            case Err(error):
                print("Error: " + error)
                sys.exit(1)

    else:
        # Default/stdout mode: print to stdout
        val config = FormatConfig.new()
        val formatter = Formatter.new(config)

        match formatter.format_file(file_path):
            case Ok(formatted):
                print(formatted)
                sys.exit(0)
            case Err(error):
                print("Error: " + error)
                sys.exit(1)

fn print_diff(original: String, formatted: String, file_path: String):
    """Print unified diff between original and formatted code"""
    print("--- " + file_path + " (original)")
    print("+++ " + file_path + " (formatted)")
    print("")

    val orig_lines = original.split("\n")
    val fmt_lines = formatted.split("\n")

    # Simple line-by-line diff
    for i in 0..max(orig_lines.len(), fmt_lines.len()):
        if i < orig_lines.len() and i < fmt_lines.len():
            if orig_lines[i] != fmt_lines[i]:
                print(f"@@ Line {i + 1} @@")
                print(f"-{orig_lines[i]}")
                print(f"+{fmt_lines[i]}")
        elif i < orig_lines.len():
            print(f"@@ Line {i + 1} @@")
            print(f"-{orig_lines[i]}")
        else:
            print(f"@@ Line {i + 1} @@")
            print(f"+{fmt_lines[i]}")
