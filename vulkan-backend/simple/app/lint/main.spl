# Simple Language Linter
# Semantic lints for code quality and safety
# Usage: simple_lint <file.spl> [--deny-all] [--warn-all]

import sys
import io.fs as fs

# Lint levels
enum LintLevel:
    Allow
    Warn
    Deny

# Lint categories
enum LintCategory:
    Safety      # Memory safety, null checks
    Correctness # Logic errors, type mismatches
    Warning     # Potential issues
    Style       # Code style recommendations
    Concurrency # Concurrency-related issues

class Lint:
    code: String
    level: LintLevel
    category: LintCategory
    message: String
    fix_hint: Option<String>
    
    fn new(code: String, level: LintLevel, category: LintCategory, message: String) -> Lint:
        Lint(
            code: code,
            level: level,
            category: category,
            message: message,
            fix_hint: None
        )
    
    fn with_fix(hint: String) -> Lint:
        Lint(
            code: self.code,
            level: self.level,
            category: self.category,
            message: self.message,
            fix_hint: Some(hint)
        )

class LintResult:
    file_path: String
    line: Int
    column: Int
    lint: Lint
    
    fn new(file_path: String, line: Int, column: Int, lint: Lint) -> LintResult:
        LintResult(
            file_path: file_path,
            line: line,
            column: column,
            lint: lint
        )
    
    fn format() -> String:
        val level_str = match self.lint.level:
            case Allow: "allow"
            case Warn: "warning"
            case Deny: "error"
        
        var output = f"{self.file_path}:{self.line}:{self.column}: {level_str}[{self.lint.code}]: {self.lint.message}"
        
        match self.lint.fix_hint:
            case Some(hint):
                output = output + f"\n  hint: {hint}"
            case None:
                pass
        
        output

class Linter:
    lints: List<Lint>
    results: List<LintResult>
    
    static fn new() -> Linter:
        var lints = []
        
        # Safety lints
        lints.push(Lint.new("S001", LintLevel.Deny, LintCategory.Safety, 
            "Unused Result type (must use .unwrap(), .expect(), or match)"))
        lints.push(Lint.new("S002", LintLevel.Deny, LintCategory.Safety,
            "Potential null pointer dereference"))
        lints.push(Lint.new("S003", LintLevel.Warn, LintCategory.Safety,
            "Unsafe block without safety comment"))
        
        # Correctness lints
        lints.push(Lint.new("C001", LintLevel.Deny, LintCategory.Correctness,
            "Unreachable code after return/break/continue"))
        lints.push(Lint.new("C002", LintLevel.Warn, LintCategory.Correctness,
            "Non-exhaustive match (add catch-all case)"))
        lints.push(Lint.new("C003", LintLevel.Warn, LintCategory.Correctness,
            "Comparison of incompatible types"))
        
        # Warning lints
        lints.push(Lint.new("W001", LintLevel.Warn, LintCategory.Warning,
            "Unused variable (prefix with _ to silence)"))
        lints.push(Lint.new("W002", LintLevel.Warn, LintCategory.Warning,
            "Unused import"))
        lints.push(Lint.new("W003", LintLevel.Warn, LintCategory.Warning,
            "Dead code"))
        
        # Style lints
        lints.push(Lint.new("ST001", LintLevel.Allow, LintCategory.Style,
            "Function name should be snake_case"))
        lints.push(Lint.new("ST002", LintLevel.Allow, LintCategory.Style,
            "Class name should be PascalCase"))
        lints.push(Lint.new("ST003", LintLevel.Allow, LintCategory.Style,
            "Constant should be UPPER_SNAKE_CASE"))
        
        # Concurrency lints
        lints.push(Lint.new("CC001", LintLevel.Deny, LintCategory.Concurrency,
            "Shared mutable state without synchronization"))
        lints.push(Lint.new("CC002", LintLevel.Warn, LintCategory.Concurrency,
            "Send type used without thread safety guarantee"))
        
        Linter(lints: lints, results: [])
    
    fn lint_file(path: String) -> Result<List<LintResult>, String>:
        # Read file
        val content = fs.read_to_string(path)?
        
        # Run simple pattern-based lints
        # TODO: Use AST-based linting when compiler integration is available
        val lines = content.split("\n")
        
        for (line_num, line) in lines.enumerate():
            self.check_line(path, line_num + 1, line)
        
        Ok(self.results)
    
    fn check_line(path: String, line_num: Int, line: String):
        val trimmed = line.trim()
        
        # Check for unused variables (simple heuristic)
        if trimmed.starts_with("val ") and not trimmed.contains("="):
            val lint = Lint.new("W001", LintLevel.Warn, LintCategory.Warning,
                "Variable declared but never assigned")
                .with_fix("Remove declaration or assign a value")
            self.results.push(LintResult.new(path, line_num, 0, lint))
        
        # Check for unreachable code
        if trimmed.starts_with("return "):
            # Next non-empty line after return is potentially unreachable
            # (This is oversimplified - needs proper control flow analysis)
            pass
        
        # Check naming conventions (if enabled)
        if trimmed.starts_with("fn "):
            val fn_name = self.extract_function_name(trimmed)
            if not self.is_snake_case(fn_name):
                val lint = Lint.new("ST001", LintLevel.Allow, LintCategory.Style,
                    f"Function name '{fn_name}' should be snake_case")
                    .with_fix(f"Rename to '{self.to_snake_case(fn_name)}'")
                self.results.push(LintResult.new(path, line_num, 0, lint))
        
        if trimmed.starts_with("class "):
            val class_name = self.extract_class_name(trimmed)
            if not self.is_pascal_case(class_name):
                val lint = Lint.new("ST002", LintLevel.Allow, LintCategory.Style,
                    f"Class name '{class_name}' should be PascalCase")
                self.results.push(LintResult.new(path, line_num, 0, lint))
    
    fn extract_function_name(line: String) -> String:
        # Extract function name from "fn name(...)" pattern
        val parts = line.split("(")
        if parts.len() > 0:
            val name_part = parts[0].replace("fn ", "").trim()
            return name_part
        ""
    
    fn extract_class_name(line: String) -> String:
        # Extract class name from "class Name:" pattern
        val parts = line.replace("class ", "").split(":")
        if parts.len() > 0:
            return parts[0].trim()
        ""
    
    fn is_snake_case(name: String) -> Bool:
        # Simple check: lowercase with underscores
        name == name.to_lowercase() and not name.contains("-")
    
    fn is_pascal_case(name: String) -> Bool:
        # Simple check: starts with uppercase
        if name.is_empty():
            return false
        val first_char = name.chars().first()
        match first_char:
            case Some(c): c.is_uppercase()
            case None: false
    
    fn to_snake_case(name: String) -> String:
        # Convert to snake_case (simplified)
        name.to_lowercase()

fn main():
    val args = sys.args()
    
    if args.len() < 2:
        print("Usage: simple_lint <file.spl> [options]")
        print("")
        print("Options:")
        print("  --deny-all   Treat all warnings as errors")
        print("  --warn-all   Enable all style lints")
        print("  --json       Output in JSON format")
        print("")
        print("Lint categories:")
        print("  Safety (S): Memory safety and null checks")
        print("  Correctness (C): Logic errors")
        print("  Warning (W): Potential issues")
        print("  Style (ST): Code style")
        print("  Concurrency (CC): Thread safety")
        sys.exit(1)
    
    val file_path = args[1]
    val deny_all = args.contains("--deny-all")
    
    # Verify file exists
    if not fs.exists(file_path):
        print(f"Error: File not found: {file_path}")
        sys.exit(1)
    
    # Run linter
    val linter = Linter.new()
    
    match linter.lint_file(file_path):
        case Ok(results):
            if results.is_empty():
                print(f"âœ“ No issues found in {file_path}")
                sys.exit(0)
            else:
                var error_count = 0
                var warning_count = 0
                
                for result in results:
                    print(result.format())
                    
                    match result.lint.level:
                        case Deny: error_count = error_count + 1
                        case Warn: 
                            warning_count = warning_count + 1
                            if deny_all:
                                error_count = error_count + 1
                        case Allow: pass
                
                print("")
                print(f"Found {error_count} error(s) and {warning_count} warning(s)")
                
                if error_count > 0:
                    sys.exit(1)
                else:
                    sys.exit(0)
        
        case Err(error):
            print(f"Error: {error}")
            sys.exit(1)
