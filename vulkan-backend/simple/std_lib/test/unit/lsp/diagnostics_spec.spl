# Unit tests for LSP diagnostics handler

import spec.{describe, it, expect}
import lsp.handlers.diagnostics as diagnostics
import lsp.protocol as protocol
import parser.treesitter.{TreeSitterParser, Node}

describe("Diagnostics Handler"):
    it("finds error nodes in tree"):
        val parser = TreeSitterParser.new("simple").unwrap()
        # Parse broken syntax
        val source = "fn broken("  # Missing closing paren and colon
        val tree = parser.parse(source).unwrap()

        val error_nodes = diagnostics.find_error_nodes(tree)

        # Should have found error nodes
        expect(error_nodes.len()).to_be_greater_than(0)

    it("generates diagnostics from error nodes"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn foo() return 1"  # Missing colon
        val tree = parser.parse(source).unwrap()

        val diagnostics_list = diagnostics.generate_diagnostics(tree)

        # Should have diagnostics
        expect(diagnostics_list.len()).to_be_greater_than(0)

    it("converts error node to diagnostic with range"):
        # Create a test error node
        val node = Node(
            id: NodeId(index: 0, generation: 0),
            kind: "ERROR",
            span: Span(
                start_byte: 0,
                end_byte: 5,
                start_line: 0,
                end_line: 0,
                start_column: 0,
                end_column: 5
            ),
            children: [],
            fields: {},
            has_error: true,
            text: "error"
        )

        val diagnostic = diagnostics.node_to_diagnostic(node)

        # Should have range
        expect(diagnostic.contains_key("range")).to_be(true)
        expect(diagnostic.contains_key("severity")).to_be(true)
        expect(diagnostic.contains_key("message")).to_be(true)
        expect(diagnostic.contains_key("source")).to_be(true)

        # Check severity is Error
        expect(diagnostic["severity"]).to_equal(protocol.DiagnosticSeverity.Error.to_int())

        # Check source
        expect(diagnostic["source"]).to_equal("simple-lsp")

    it("creates helpful error messages"):
        # Node with text
        val node_with_text = Node(
            id: NodeId(index: 0, generation: 0),
            kind: "ERROR",
            span: Span(start_byte: 0, end_byte: 3, start_line: 0, end_line: 0, start_column: 0, end_column: 3),
            children: [],
            fields: {},
            has_error: true,
            text: "foo"
        )

        val diagnostic = diagnostics.node_to_diagnostic(node_with_text)
        expect(diagnostic["message"]).to_contain("foo")

        # Node without text
        val node_no_text = Node(
            id: NodeId(index: 1, generation: 0),
            kind: "ERROR",
            span: Span(start_byte: 0, end_byte: 0, start_line: 0, end_line: 0, start_column: 0, end_column: 0),
            children: [],
            fields: {},
            has_error: true,
            text: ""
        )

        val diagnostic2 = diagnostics.node_to_diagnostic(node_no_text)
        expect(diagnostic2["message"]).to_equal("Syntax error")

    it("handles valid source with no errors"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn foo(): return 1"
        val tree = parser.parse(source).unwrap()

        val error_nodes = diagnostics.find_error_nodes(tree)

        # Valid source should have no errors
        expect(error_nodes.len()).to_equal(0)

    it("generates empty diagnostics for valid source"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 42"
        val tree = parser.parse(source).unwrap()

        val diagnostics_list = diagnostics.generate_diagnostics(tree)

        # No errors = no diagnostics
        expect(diagnostics_list.len()).to_equal(0)

    it("traverses nested error nodes"):
        val parser = TreeSitterParser.new("simple").unwrap()
        # Multiple syntax errors
        val source = "fn foo(\nfn bar("
        val tree = parser.parse(source).unwrap()

        val error_nodes = diagnostics.find_error_nodes(tree)

        # Should find multiple errors
        expect(error_nodes.len()).to_be_greater_than(0)

describe("Error Node Detection"):
    it("detects nodes with ERROR kind"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn incomplete"  # Missing params and body
        val tree = parser.parse(source).unwrap()

        val errors = diagnostics.find_error_nodes(tree)

        # Should detect ERROR nodes
        for error_node in errors:
            val is_error = error_node.kind == "ERROR" or error_node.has_error
            expect(is_error).to_be(true)

    it("includes position information"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "bad syntax here"
        val tree = parser.parse(source).unwrap()

        val diagnostics_list = diagnostics.generate_diagnostics(tree)

        if diagnostics_list.len() > 0:
            val diagnostic = diagnostics_list[0]
            val range = diagnostic["range"]

            # Should have start and end positions
            expect(range.contains_key("start")).to_be(true)
            expect(range.contains_key("end")).to_be(true)

            val start = range["start"]
            expect(start.contains_key("line")).to_be(true)
            expect(start.contains_key("character")).to_be(true)
