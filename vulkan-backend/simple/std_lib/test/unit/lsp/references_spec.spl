# Unit tests for LSP references handler

import spec.{describe, it, expect}
import lsp.handlers.references as references
import parser.treesitter.{TreeSitterParser, Span, NodeId}

describe("References Handler"):
    it("finds all references to a variable"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1\nlet y = x + 2\nreturn x"
        val tree = parser.parse(source).unwrap()

        # Find references to "x"
        val refs = references.find_all_references(tree, "x", true)

        # Should find: definition (val x) + 2 references (x + 2, return x)
        expect(refs.len()).to_be_greater_than_or_equal(1)

    it("finds all references to a function"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn foo(): return 1\nlet x = foo()\nlet y = foo()"
        val tree = parser.parse(source).unwrap()

        val refs = references.find_all_references(tree, "foo", true)

        # Should find: definition (fn foo) + 2 calls (foo(), foo())
        expect(refs.len()).to_be_greater_than_or_equal(1)

    it("excludes declaration when requested"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1\nreturn x"
        val tree = parser.parse(source).unwrap()

        # Without declaration
        val refs_no_decl = references.find_all_references(tree, "x", false)

        # With declaration
        val refs_with_decl = references.find_all_references(tree, "x", true)

        # Should have at least one more reference when including declaration
        expect(refs_with_decl.len()).to_be_greater_than_or_equal(refs_no_decl.len())

    it("handles symbol not found"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1"
        val tree = parser.parse(source).unwrap()

        # Find references to non-existent symbol
        val refs = references.find_all_references(tree, "nonexistent", true)

        expect(refs.len()).to_equal(0)

    it("handles empty source"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = ""
        val tree = parser.parse(source).unwrap()

        val refs = references.find_all_references(tree, "x", true)

        expect(refs.len()).to_equal(0)

    it("determines definition context correctly"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1\nreturn x"
        val tree = parser.parse(source).unwrap()

        val refs = references.find_all_references(tree, "x", true)

        # At least one should be a definition
        var has_definition = false
        for ref in refs:
            if ref.context == "definition":
                has_definition = true

        expect(has_definition).to_be(true)

    it("determines reference context correctly"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1\nlet y = x + 1"
        val tree = parser.parse(source).unwrap()

        val refs = references.find_all_references(tree, "x", true)

        # At least one should be a reference (not definition)
        var has_reference = false
        for ref in refs:
            if ref.context == "reference":
                has_reference = true

        expect(has_reference).to_be(true)

    it("converts references to LSP locations"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1\nreturn x"
        val tree = parser.parse(source).unwrap()

        val refs = references.find_all_references(tree, "x", true)
        val locations = references.references_to_locations(refs)

        expect(locations.len()).to_equal(refs.len())

        # Each location should have a range
        for location in locations:
            expect(location.contains_key("range")).to_be(true)

            val range = location["range"]
            expect(range.contains_key("start")).to_be(true)
            expect(range.contains_key("end")).to_be(true)

    it("handles references request for valid position"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1\nreturn x"
        val tree = parser.parse(source).unwrap()

        # Position at "x" in "val x = 1" (line 0, column 4)
        val result = references.handle_references(tree, source, 0, 4, true).unwrap()

        expect(result.is_some()).to_be(true)

    it("returns None for references outside source"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1"
        val tree = parser.parse(source).unwrap()

        val result = references.handle_references(tree, source, 100, 100, true).unwrap()

        expect(result.is_none()).to_be(true)

    it("returns None for non-identifier nodes"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 42"
        val tree = parser.parse(source).unwrap()

        # Position at "42" (not an identifier)
        val result = references.handle_references(tree, source, 0, 8, true).unwrap()

        # Should return None for non-identifier
        # (or Some([]) if it finds the number literal)
        # Either is acceptable

describe("Reference Context Detection"):
    it("detects function definition context"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn foo(): return 1"
        val tree = parser.parse(source).unwrap()

        val refs = references.find_all_references(tree, "foo", true)

        # Should find the function name as a definition
        var found_definition = false
        for ref in refs:
            if ref.context == "definition":
                found_definition = true

        expect(found_definition).to_be(true)

    it("detects variable definition context"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1"
        val tree = parser.parse(source).unwrap()

        val refs = references.find_all_references(tree, "x", true)

        # Should find the variable as a definition
        expect(refs.len()).to_be_greater_than(0)

        val first_ref = refs[0]
        expect(first_ref.context).to_equal("definition")

    it("detects parameter definition context"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn foo(x: i32): return x"
        val tree = parser.parse(source).unwrap()

        val refs = references.find_all_references(tree, "x", true)

        # Should find: parameter definition + reference in return
        expect(refs.len()).to_be_greater_than_or_equal(1)

describe("Reference Locations"):
    it("includes correct span information"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val foo = 1\nlet bar = foo"
        val tree = parser.parse(source).unwrap()

        val refs = references.find_all_references(tree, "foo", true)

        expect(refs.len()).to_be_greater_than(0)

        # All references should have valid spans
        for ref in refs:
            expect(ref.span.start_line).to_be_greater_than_or_equal(0)
            expect(ref.span.start_column).to_be_greater_than_or_equal(0)
            expect(ref.span.end_line).to_be_greater_than_or_equal(ref.span.start_line)

    it("distinguishes between different symbols"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1\nlet y = 2\nreturn x + y"
        val tree = parser.parse(source).unwrap()

        val x_refs = references.find_all_references(tree, "x", true)
        val y_refs = references.find_all_references(tree, "y", true)

        # x and y should have different reference counts
        # (each appears at least once)
        expect(x_refs.len()).to_be_greater_than(0)
        expect(y_refs.len()).to_be_greater_than(0)
