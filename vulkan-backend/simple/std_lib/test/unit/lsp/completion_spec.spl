# Unit tests for LSP completion handler

import spec.{describe, it, expect}
import lsp.handlers.completion as completion
import parser.treesitter.{TreeSitterParser}

describe("Completion Handler"):
    it("generates completions for empty source"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = ""
        val tree = parser.parse(source).unwrap()

        val result = completion.handle_completion(tree, source, 0, 0).unwrap()

        expect(result.is_some()).to_be(true)

        match result:
            case Some(items):
                # Should have keywords and types at minimum
                expect(items.len()).to_be_greater_than(0)
            case None:
                expect(false).to_be(true)

    it("generates completions at cursor position"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1\n"
        val tree = parser.parse(source).unwrap()

        # Position at end of line 2
        val result = completion.handle_completion(tree, source, 1, 0).unwrap()

        expect(result.is_some()).to_be(true)

    it("includes keywords in completions"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = ""
        val tree = parser.parse(source).unwrap()

        val result = completion.handle_completion(tree, source, 0, 0).unwrap()

        match result:
            case Some(items):
                # Should have keyword completions
                var has_fn = false
                var has_let = false

                for item in items:
                    if item["label"] == "fn":
                        has_fn = true
                    if item["label"] == "val":
                        has_let = true

                expect(has_fn or has_let).to_be(true)
            case None:
                expect(false).to_be(true)

    it("includes types in completions"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = ""
        val tree = parser.parse(source).unwrap()

        val result = completion.handle_completion(tree, source, 0, 0).unwrap()

        match result:
            case Some(items):
                # Should have type completions
                var has_int = false
                var has_string = false

                for item in items:
                    if item["label"] == "Int":
                        has_int = true
                    if item["label"] == "String":
                        has_string = true

                expect(has_int or has_string).to_be(true)
            case None:
                expect(false).to_be(true)

    it("includes symbols from source"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn foo(): return 1\nlet x = 1"
        val tree = parser.parse(source).unwrap()

        val result = completion.handle_completion(tree, source, 2, 0).unwrap()

        match result:
            case Some(items):
                # Should include "foo" and "x"
                var has_foo = false
                var has_x = false

                for item in items:
                    if item["label"] == "foo":
                        has_foo = true
                    if item["label"] == "x":
                        has_x = true

                # At least one should be present
                expect(has_foo or has_x).to_be(true)
            case None:
                expect(false).to_be(true)

describe("Keyword Completions"):
    it("provides all control flow keywords"):
        val keywords = completion.get_keyword_completions()

        # Check for essential keywords
        var has_fn = false
        var has_return = false
        var has_if = false
        var has_match = false

        for kw in keywords:
            match kw.label:
                case "fn": has_fn = true
                case "return": has_return = true
                case "if": has_if = true
                case "match": has_match = true
                case _: pass

        expect(has_fn).to_be(true)
        expect(has_return).to_be(true)
        expect(has_if).to_be(true)
        expect(has_match).to_be(true)

    it("provides loop keywords"):
        val keywords = completion.get_keyword_completions()

        var has_for = false
        var has_while = false
        var has_loop = false

        for kw in keywords:
            match kw.label:
                case "for": has_for = true
                case "while": has_while = true
                case "loop": has_loop = true
                case _: pass

        expect(has_for or has_while or has_loop).to_be(true)

    it("provides declaration keywords"):
        val keywords = completion.get_keyword_completions()

        var has_let = false
        var has_struct = false

        for kw in keywords:
            match kw.label:
                case "val": has_let = true
                case "struct": has_struct = true
                case _: pass

        expect(has_let).to_be(true)
        expect(has_struct).to_be(true)

    it("includes documentation for keywords"):
        val keywords = completion.get_keyword_completions()

        # All keywords should have documentation
        for kw in keywords:
            expect(kw.documentation.is_some()).to_be(true)

describe("Type Completions"):
    it("provides all built-in types"):
        val types = completion.get_type_completions()

        # Check for essential types
        var has_int = false
        var has_string = false
        var has_bool = false
        var has_list = false

        for ty in types:
            match ty.label:
                case "Int": has_int = true
                case "String": has_string = true
                case "Bool": has_bool = true
                case "List": has_list = true
                case _: pass

        expect(has_int).to_be(true)
        expect(has_string).to_be(true)
        expect(has_bool).to_be(true)
        expect(has_list).to_be(true)

    it("includes generic types"):
        val types = completion.get_type_completions()

        var has_option = false
        var has_result = false

        for ty in types:
            match ty.label:
                case "Option": has_option = true
                case "Result": has_result = true
                case _: pass

        expect(has_option).to_be(true)
        expect(has_result).to_be(true)

    it("includes type details"):
        val types = completion.get_type_completions()

        # All types should have details
        for ty in types:
            expect(ty.detail.is_some()).to_be(true)

describe("Symbol Collection"):
    it("collects function symbols"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn foo(): return 1\nfn bar(): return 2"
        val tree = parser.parse(source).unwrap()

        val symbols = completion.collect_symbols(tree)

        # Should find both functions
        var has_foo = false
        var has_bar = false

        for sym in symbols:
            if sym.label == "foo":
                has_foo = true
            if sym.label == "bar":
                has_bar = true

        expect(has_foo).to_be(true)
        expect(has_bar).to_be(true)

    it("collects variable symbols"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1\nlet y = 2"
        val tree = parser.parse(source).unwrap()

        val symbols = completion.collect_symbols(tree)

        # Should find both variables
        var has_x = false
        var has_y = false

        for sym in symbols:
            if sym.label == "x":
                has_x = true
            if sym.label == "y":
                has_y = true

        expect(has_x).to_be(true)
        expect(has_y).to_be(true)

    it("handles empty source"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = ""
        val tree = parser.parse(source).unwrap()

        val symbols = completion.collect_symbols(tree)

        # Empty source should have no symbols
        expect(symbols.len()).to_equal(0)

describe("Completion Item"):
    it("creates basic completion item"):
        val item = completion.CompletionItem.new("foo", completion.CompletionItemKind.Function)

        expect(item.label).to_equal("foo")
        expect(item.kind).to_equal(completion.CompletionItemKind.Function)

    it("adds detail to completion item"):
        val item = completion.CompletionItem.new("foo", completion.CompletionItemKind.Function)
            .with_detail("function")

        expect(item.detail.is_some()).to_be(true)

        match item.detail:
            case Some(d):
                expect(d).to_equal("function")
            case None:
                expect(false).to_be(true)

    it("adds documentation to completion item"):
        val item = completion.CompletionItem.new("foo", completion.CompletionItemKind.Function)
            .with_documentation("A test function")

        expect(item.documentation.is_some()).to_be(true)

    it("converts to JSON correctly"):
        val item = completion.CompletionItem.new("foo", completion.CompletionItemKind.Function)
            .with_detail("function")
            .with_documentation("A test function")

        val json = item.to_json()

        expect(json.contains_key("label")).to_be(true)
        expect(json.contains_key("kind")).to_be(true)
        expect(json.contains_key("detail")).to_be(true)
        expect(json.contains_key("documentation")).to_be(true)

describe("Completion Item Kinds"):
    it("has correct kind values"):
        expect(completion.CompletionItemKind.Text).to_equal(1)
        expect(completion.CompletionItemKind.Function).to_equal(3)
        expect(completion.CompletionItemKind.Variable).to_equal(6)
        expect(completion.CompletionItemKind.Class).to_equal(7)
        expect(completion.CompletionItemKind.Keyword).to_equal(14)

describe("Prefix Filtering"):
    it("filters completions by prefix"):
        val items = [
            completion.CompletionItem.new("foo", completion.CompletionItemKind.Function),
            completion.CompletionItem.new("bar", completion.CompletionItemKind.Function),
            completion.CompletionItem.new("foobar", completion.CompletionItemKind.Function)
        ]

        val filtered = completion.filter_by_prefix(items, "fo")

        # Should only have "foo" and "foobar"
        expect(filtered.len()).to_equal(2)

    it("returns all completions for empty prefix"):
        val items = [
            completion.CompletionItem.new("foo", completion.CompletionItemKind.Function),
            completion.CompletionItem.new("bar", completion.CompletionItemKind.Function)
        ]

        val filtered = completion.filter_by_prefix(items, "")

        expect(filtered.len()).to_equal(2)

    it("returns empty for non-matching prefix"):
        val items = [
            completion.CompletionItem.new("foo", completion.CompletionItemKind.Function),
            completion.CompletionItem.new("bar", completion.CompletionItemKind.Function)
        ]

        val filtered = completion.filter_by_prefix(items, "xyz")

        expect(filtered.len()).to_equal(0)

describe("Edge Cases"):
    it("handles malformed source"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn broken("
        val tree = parser.parse(source).unwrap()

        # Should not crash
        val result = completion.handle_completion(tree, source, 0, 0).unwrap()

        # Should still provide completions
        expect(result.is_some()).to_be(true)

    it("handles position at end of file"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 1"
        val tree = parser.parse(source).unwrap()

        val result = completion.handle_completion(tree, source, 0, 9).unwrap()

        expect(result.is_some()).to_be(true)
