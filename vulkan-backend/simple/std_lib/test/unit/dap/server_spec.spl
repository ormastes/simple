# Unit tests for DAP server logic

import spec.{describe, it, expect}
import dap.server as server
import dap.protocol as protocol
import dap.breakpoints as breakpoints

describe("DebuggerState"):
    it("has correct state values"):
        val state1 = server.DebuggerState.Uninitialized
        val state2 = server.DebuggerState.Initialized
        val state3 = server.DebuggerState.Launched
        val state4 = server.DebuggerState.Running
        val state5 = server.DebuggerState.Stopped
        val state6 = server.DebuggerState.Terminated

        # States are distinct
        expect(state1 != state2).to_be(true)
        expect(state2 != state3).to_be(true)

describe("DapServer"):
    it("creates server in uninitialized state"):
        val server = server.DapServer.new()

        expect(server.state).to_equal(server.DebuggerState.Uninitialized)
        expect(server.current_thread_id).to_equal(1)
        expect(server.current_frame_id).to_equal(1)
        expect(server.stop_reason.is_none()).to_be(true)

    it("initializes breakpoint manager"):
        val srv = server.DapServer.new()

        expect(srv.breakpoint_manager.count()).to_equal(0)

describe("State Transitions"):
    it("transitions from uninitialized to initialized"):
        var srv = server.DapServer.new()

        expect(srv.state).to_equal(server.DebuggerState.Uninitialized)

        # Simulate initialize (would call handle_initialize)
        srv.state = server.DebuggerState.Initialized

        expect(srv.state).to_equal(server.DebuggerState.Initialized)

    it("transitions through launch sequence"):
        var srv = server.DapServer.new()

        # Uninitialized → Initialized
        srv.state = server.DebuggerState.Initialized
        expect(srv.state).to_equal(server.DebuggerState.Initialized)

        # Initialized → Launched
        srv.state = server.DebuggerState.Launched
        expect(srv.state).to_equal(server.DebuggerState.Launched)

        # Launched → Running
        srv.state = server.DebuggerState.Running
        expect(srv.state).to_equal(server.DebuggerState.Running)

    it("transitions to stopped state"):
        var srv = server.DapServer.new()
        srv.state = server.DebuggerState.Running

        # Running → Stopped
        srv.state = server.DebuggerState.Stopped
        srv.stop_reason = Some(protocol.StopReason.Breakpoint)

        expect(srv.state).to_equal(server.DebuggerState.Stopped)
        expect(srv.stop_reason.is_some()).to_be(true)

    it("transitions to terminated state"):
        var srv = server.DapServer.new()
        srv.state = server.DebuggerState.Running

        # Any state → Terminated
        srv.state = server.DebuggerState.Terminated

        expect(srv.state).to_equal(server.DebuggerState.Terminated)

describe("Stop Reasons"):
    it("stores stop reason for step"):
        var srv = server.DapServer.new()
        srv.state = server.DebuggerState.Running

        srv.state = server.DebuggerState.Stopped
        srv.stop_reason = Some(protocol.StopReason.Step)

        expect(srv.stop_reason.unwrap()).to_equal(protocol.StopReason.Step)

    it("stores stop reason for breakpoint"):
        var srv = server.DapServer.new()

        srv.state = server.DebuggerState.Stopped
        srv.stop_reason = Some(protocol.StopReason.Breakpoint)

        expect(srv.stop_reason.unwrap()).to_equal(protocol.StopReason.Breakpoint)

    it("stores stop reason for pause"):
        var srv = server.DapServer.new()

        srv.state = server.DebuggerState.Stopped
        srv.stop_reason = Some(protocol.StopReason.Pause)

        expect(srv.stop_reason.unwrap()).to_equal(protocol.StopReason.Pause)

    it("stores stop reason for exception"):
        var srv = server.DapServer.new()

        srv.state = server.DebuggerState.Stopped
        srv.stop_reason = Some(protocol.StopReason.Exception)

        expect(srv.stop_reason.unwrap()).to_equal(protocol.StopReason.Exception)

describe("Thread Management"):
    it("maintains current thread ID"):
        val srv = server.DapServer.new()

        expect(srv.current_thread_id).to_equal(1)

    it("allows thread ID updates"):
        var srv = server.DapServer.new()

        srv.current_thread_id = 42

        expect(srv.current_thread_id).to_equal(42)

describe("Frame Management"):
    it("maintains current frame ID"):
        val srv = server.DapServer.new()

        expect(srv.current_frame_id).to_equal(1)

    it("allows frame ID updates"):
        var srv = server.DapServer.new()

        srv.current_frame_id = 100

        expect(srv.current_frame_id).to_equal(100)

describe("Breakpoint Integration"):
    it("integrates with breakpoint manager"):
        var srv = server.DapServer.new()

        # Set breakpoints through manager
        val source_bps = [
            protocol.SourceBreakpoint.new(10),
            protocol.SourceBreakpoint.new(20)
        ]

        srv.breakpoint_manager.set_breakpoints("test.spl", source_bps)

        expect(srv.breakpoint_manager.count()).to_equal(2)

    it("checks breakpoints during execution"):
        var srv = server.DapServer.new()

        srv.breakpoint_manager.set_breakpoints("test.spl", [
            protocol.SourceBreakpoint.new(42)
        ])

        # Simulate execution reaching line 42
        val should_stop = srv.breakpoint_manager.should_stop_at_line("test.spl", 42)

        expect(should_stop.is_some()).to_be(true)

describe("Server Lifecycle"):
    it("follows complete lifecycle"):
        var srv = server.DapServer.new()

        # 1. Uninitialized
        expect(srv.state).to_equal(server.DebuggerState.Uninitialized)

        # 2. Initialize
        srv.state = server.DebuggerState.Initialized
        expect(srv.state).to_equal(server.DebuggerState.Initialized)

        # 3. Launch
        srv.state = server.DebuggerState.Launched
        expect(srv.state).to_equal(server.DebuggerState.Launched)

        # 4. Set breakpoints
        srv.breakpoint_manager.set_breakpoints("main.spl", [
            protocol.SourceBreakpoint.new(10)
        ])
        expect(srv.breakpoint_manager.count()).to_equal(1)

        # 5. Start running
        srv.state = server.DebuggerState.Running
        expect(srv.state).to_equal(server.DebuggerState.Running)

        # 6. Hit breakpoint
        srv.state = server.DebuggerState.Stopped
        srv.stop_reason = Some(protocol.StopReason.Breakpoint)
        expect(srv.state).to_equal(server.DebuggerState.Stopped)

        # 7. Continue
        srv.state = server.DebuggerState.Running
        expect(srv.state).to_equal(server.DebuggerState.Running)

        # 8. Terminate
        srv.state = server.DebuggerState.Terminated
        expect(srv.state).to_equal(server.DebuggerState.Terminated)

describe("Mock Responses"):
    it("provides thread information"):
        val srv = server.DapServer.new()

        # Server can provide thread info
        val thread = protocol.Thread.new(srv.current_thread_id, "Main Thread")

        expect(thread.id).to_equal(1)
        expect(thread.name).to_equal("Main Thread")

    it("provides stack frame information"):
        val srv = server.DapServer.new()

        # Server can provide stack frame
        val frame = protocol.StackFrame.new(
            srv.current_frame_id,
            "main",
            1,
            0
        )

        expect(frame.id).to_equal(1)
        expect(frame.name).to_equal("main")

    it("provides scope information"):
        val srv = server.DapServer.new()

        # Server can provide scopes
        val local_scope = protocol.Scope.new("Local", 1)
        val global_scope = protocol.Scope.new("Global", 2)

        expect(local_scope.name).to_equal("Local")
        expect(global_scope.name).to_equal("Global")

    it("provides variable information"):
        val srv = server.DapServer.new()

        # Server can provide variables
        val var1 = protocol.Variable.new("x", "42").with_type("Int")
        val var2 = protocol.Variable.new("name", "\"test\"").with_type("String")

        expect(var1.name).to_equal("x")
        expect(var1.value).to_equal("42")
        expect(var2.type_name.unwrap()).to_equal("String")

describe("Execution Control"):
    it("supports continue operation"):
        var srv = server.DapServer.new()
        srv.state = server.DebuggerState.Stopped

        # Continue changes state to running
        srv.state = server.DebuggerState.Running

        expect(srv.state).to_equal(server.DebuggerState.Running)

    it("supports pause operation"):
        var srv = server.DapServer.new()
        srv.state = server.DebuggerState.Running

        # Pause changes state to stopped
        srv.state = server.DebuggerState.Stopped
        srv.stop_reason = Some(protocol.StopReason.Pause)

        expect(srv.state).to_equal(server.DebuggerState.Stopped)
        expect(srv.stop_reason.unwrap()).to_equal(protocol.StopReason.Pause)

    it("supports step operations"):
        var srv = server.DapServer.new()
        srv.state = server.DebuggerState.Stopped

        # Step operation: stopped → (step) → stopped
        srv.stop_reason = Some(protocol.StopReason.Step)

        expect(srv.state).to_equal(server.DebuggerState.Stopped)
        expect(srv.stop_reason.unwrap()).to_equal(protocol.StopReason.Step)
