# Diff Spec - Tests for Keyed Diffing Algorithm
#
# Tests the diff algorithm that computes minimal patches.

use spec.*
use ui.element.*
use ui.patchset.*
use ui.diff.*

describe "diff":
    it "returns empty patches for identical trees":
        val id = NodeId::new(1)
        val elem1 = Element::div(id)
        val elem2 = Element::div(id)

        val result = diff(&elem1, &elem2)
        expect(result.patches().is_empty()).to(be_true())

    it "detects text changes":
        val id = NodeId::new(1)
        val old = Element::text(id, "Hello")
        val new = Element::text(id, "World")

        val result = diff(&old, &new)
        expect(result.patches().len()).to(equal(1))

    it "detects attribute additions":
        val id = NodeId::new(1)
        val old = Element::div(id)
        val new = Element::div(id).with_attr("data-value", "123")

        val result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

    it "detects attribute removals":
        val id = NodeId::new(1)
        val old = Element::div(id).with_attr("data-value", "123")
        val new = Element::div(id)

        val result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

    it "detects attribute changes":
        val id = NodeId::new(1)
        val old = Element::div(id).with_attr("data-value", "old")
        val new = Element::div(id).with_attr("data-value", "new")

        val result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

    it "detects class additions":
        val id = NodeId::new(1)
        val old = Element::div(id)
        val new = Element::div(id).with_class("active")

        val result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

    it "detects class removals":
        val id = NodeId::new(1)
        val old = Element::div(id).with_class("active")
        val new = Element::div(id)

        val result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

describe "diff children":
    it "handles empty children":
        val id = NodeId::new(1)
        val old = Element::div(id)
        val new = Element::div(id)

        val result = diff(&old, &new)
        expect(result.patches().is_empty()).to(be_true())

    it "detects new children":
        val parent_id = NodeId::new(1)
        val child_id = NodeId::new(2)

        val old = Element::div(parent_id)
        val child = Element::text(child_id, "New Child")
        val new = Element::div(parent_id).with_child(child)

        val result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

    it "detects removed children":
        val parent_id = NodeId::new(1)
        val child_id = NodeId::new(2)

        val child = Element::text(child_id, "Child")
        val old = Element::div(parent_id).with_child(child)
        val new = Element::div(parent_id)

        val result = diff(&old, &new)
        expect(result.patches().len()).to(be_greater_than(0))

    it "matches keyed children":
        val parent_id = NodeId::new(1)

        val child1 = Element::text(NodeId::new(2), "A").with_key("key-a")
        val child2 = Element::text(NodeId::new(3), "B").with_key("key-b")
        val child3 = Element::text(NodeId::new(4), "C").with_key("key-c")

        val old = Element::div(parent_id)
            .with_child(child1.clone())
            .with_child(child2.clone())
            .with_child(child3.clone())

        # Reorder: A, B, C -> C, A, B
        val new = Element::div(parent_id)
            .with_child(child3)
            .with_child(child1)
            .with_child(child2)

        val result = diff(&old, &new)
        # Should detect moves, not remove/insert pairs
        expect(result.patches().len()).to(be_greater_than(0))

describe "LIS algorithm":
    it "computes longest increasing subsequence":
        val arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
        val lis = longest_increasing_subsequence(&arr)

        # Verify result is increasing
        var prev: Option[u64] = None
        for idx in &lis:
            val val = arr[idx]
            if val Some(p) = prev:
                expect(val).to(be_greater_than(p))
            prev = Some(val)

    it "handles empty array":
        val arr: Array[u64] = []
        val lis = longest_increasing_subsequence(&arr)
        expect(lis.len()).to(equal(0))

    it "handles single element":
        val arr = [42]
        val lis = longest_increasing_subsequence(&arr)
        expect(lis.len()).to(equal(1))

    it "handles already sorted":
        val arr = [1, 2, 3, 4, 5]
        val lis = longest_increasing_subsequence(&arr)
        expect(lis.len()).to(equal(5))

    it "handles reverse sorted":
        val arr = [5, 4, 3, 2, 1]
        val lis = longest_increasing_subsequence(&arr)
        expect(lis.len()).to(equal(1))
