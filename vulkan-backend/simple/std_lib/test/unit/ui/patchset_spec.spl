# PatchSet Spec - Tests for Patch Operations
#
# Tests the PatchSet system for reactive UI updates.

use spec.*
use ui.element.*
use ui.patchset.*

describe "PatchOp":
    it "identifies target node":
        val id = NodeId::new(42)

        val op1 = PatchOp::SetText { node_id: id, text: "Hello".to_string() }
        expect(op1.target_id()).to(equal(id))

        val op2 = PatchOp::SetAttr { node_id: id, name: "class".to_string(), value: "active".to_string() }
        expect(op2.target_id()).to(equal(id))

    it "identifies structural operations":
        val id = NodeId::new(1)
        val elem = Element::text(id, "test")

        val op1 = PatchOp::InsertChild { parent_id: id, index: 0, element: elem }
        expect(op1.is_structural()).to(be_true())

        val op2 = PatchOp::RemoveChild { parent_id: id, child_id: id }
        expect(op2.is_structural()).to(be_true())

        val op3 = PatchOp::SetText { node_id: id, text: "new".to_string() }
        expect(op3.is_structural()).to(be_false())

        val op4 = PatchOp::AddClass { node_id: id, class: "foo".to_string() }
        expect(op4.is_structural()).to(be_false())

describe "PatchSet":
    it "starts empty":
        val patches = PatchSet::new()
        expect(patches.len()).to(equal(0))
        expect(patches.is_empty()).to(be_true())

    it "adds patches":
        var patches = PatchSet::new()
        val id = NodeId::new(1)

        patches.set_text(id, "Hello")
        patches.set_attr(id, "class", "active")

        expect(patches.len()).to(equal(2))
        expect(patches.is_empty()).to(be_false())

    it "provides helper methods":
        var patches = PatchSet::new()
        val id = NodeId::new(1)

        patches.set_text(id, "text")
        patches.set_attr(id, "href", "/home")
        patches.remove_attr(id, "disabled")
        patches.add_class(id, "visible")
        patches.remove_class(id, "hidden")
        patches.focus(id)

        expect(patches.len()).to(equal(6))

    it "clears all patches":
        var patches = PatchSet::new()
        val id = NodeId::new(1)

        patches.set_text(id, "A")
        patches.set_text(id, "B")
        expect(patches.len()).to(equal(2))

        patches.clear()
        expect(patches.len()).to(equal(0))

    it "extends with multiple operations":
        var patches = PatchSet::new()
        val id = NodeId::new(1)

        val ops = [
            PatchOp::SetText { node_id: id, text: "A".to_string() },
            PatchOp::SetText { node_id: id, text: "B".to_string() }
        ]

        patches.extend(ops)
        expect(patches.len()).to(equal(2))

describe "PatchSet optimization":
    it "removes redundant text updates":
        var patches = PatchSet::new()
        val id = NodeId::new(1)

        patches.set_text(id, "First")
        patches.set_text(id, "Second")
        patches.set_text(id, "Third")

        val optimized = patches.optimize()
        # Should keep only last text update per node
        # Note: actual count depends on optimization implementation
        expect(optimized.len()).to(be_less_than_or_equal(patches.len()))

    it "removes redundant attr updates":
        var patches = PatchSet::new()
        val id = NodeId::new(1)

        patches.set_attr(id, "class", "a")
        patches.set_attr(id, "class", "b")
        patches.set_attr(id, "class", "c")

        val optimized = patches.optimize()
        expect(optimized.len()).to(be_less_than_or_equal(patches.len()))

    it "preserves structural operations order":
        var patches = PatchSet::new()
        val parent_id = NodeId::new(1)
        val child1_id = NodeId::new(2)
        val child2_id = NodeId::new(3)

        val child1 = Element::text(child1_id, "A")
        val child2 = Element::text(child2_id, "B")

        patches.insert_child(parent_id, 0, child1)
        patches.insert_child(parent_id, 1, child2)
        patches.remove_child(parent_id, child1_id)

        val optimized = patches.optimize()
        # Structural ops should be preserved
        expect(optimized.len()).to(equal(3))
