describe "Concurrency":
    describe "Generators":
        describe "Basic generator operations":
            it "creates and yields single value":
                val gen = generator(\: yield 42)
                expect next(gen) == 42

            it "yields multiple values in sequence":
                val gen = generator(\: [yield 1, yield 2, yield 3])
                expect next(gen) == 1
                expect next(gen) == 2
                expect next(gen) == 3

            it "returns nil when exhausted":
                val gen = generator(\: yield 10)
                val first = next(gen)
                val second = next(gen)
                expect first == 10
                expect second == nil

        describe "Generator with captures":
            it "captures outer variables":
                val base = 100
                val gen = generator(\: [yield base, yield (base + 1)])
                expect next(gen) == 100
                expect next(gen) == 101

            it "captures multiple variables":
                val a = 10
                val b = 20
                val c = 30
                val gen = generator(\: [yield a, yield b, yield c])
                expect next(gen) + next(gen) + next(gen) == 60

        describe "Generator with computation":
            it "computes values before yield":
                val val = 2 * 3
                val gen = generator(\: yield val)
                expect next(gen) == 6

            it "performs arithmetic in yield":
                val x = 5
                val y = 3
                val gen = generator(\: yield (x * y + x))
                expect next(gen) == 20

        describe "Generator state machine":
            it "preserves state across yields":
                val gen = generator(\: (yield 10, yield 15)[1])
                val a = next(gen)
                val b = next(gen)
                expect a + b == 25

            it "handles nested iteration":
                val gen = generator(\: [yield 1, yield 2, yield 3, yield 4])
                val sum = next(gen) + next(gen) + next(gen) + next(gen)
                expect sum == 10

            it "handles exhaustion with capture":
                val val = 42
                val gen = generator(\: yield val)
                val first = next(gen)
                val second = next(gen)
                expect first == 42

    describe "Futures":
        describe "Basic future operations":
            it "creates and awaits a value":
                val f = future(42)
                expect await f == 42

            it "awaits computation result":
                val f = future(10 + 20 + 30)
                expect await f == 60

            it "awaits non-future value directly":
                val x = 42
                expect await x == 42

        describe "Multiple futures":
            it "awaits multiple futures":
                val f1 = future(10)
                val f2 = future(20)
                val f3 = future(30)
                expect await f1 + await f2 + await f3 == 60

        describe "Future with captures":
            it "captures outer variable":
                val base = 40
                val f = future(base + 2)
                expect await f == 42

            it "captures multiple variables":
                val a = 10
                val b = 20
                val c = 12
                val f = future(a + b + c)
                expect await f == 42

    describe "Interpreter/Codegen Parity":
        describe "Generators":
            it "parity: basic sequence":
                val gen = generator(\: [yield 1, yield 2, yield 3])
                expect next(gen) + next(gen) + next(gen) == 6

            it "parity: single value":
                val gen = generator(\: yield 42)
                expect next(gen) == 42

            it "parity: multiple captures":
                val a = 10
                val b = 20
                val c = 30
                val gen = generator(\: [yield a, yield b, yield c])
                expect next(gen) + next(gen) + next(gen) == 60

        describe "Futures":
            it "parity: basic future":
                val f = future(42)
                expect await f == 42

            it "parity: future with capture":
                val base = 40
                val f = future(base + 2)
                expect await f == 42

            it "parity: multiple captures":
                val a = 10
                val b = 20
                val c = 12
                val f = future(a + b + c)
                expect await f == 42

    describe "Async Execution Modes":
        describe "Threaded Mode (default)":
            it "is in threaded mode by default":
                val mode = async_mode()
                expect mode == "threaded"

            it "futures execute in background":
                val f = future(42)
                expect await f == 42

            it "multiple concurrent futures":
                val f1 = future(10)
                val f2 = future(20)
                val f3 = future(30)
                expect await f1 + await f2 + await f3 == 60

            it "futures with computation":
                val f = future(10 + 20 + 30)
                expect await f == 60

            it "futures with captures":
                val base = 40
                val f = future(base + 2)
                expect await f == 42

        describe "Resolved and Rejected Futures":
            it "creates already-resolved future":
                val f = resolved(100)
                expect is_ready(f)
                expect await f == 100

            it "resolved future with different types":
                val f1 = resolved(42)
                val f2 = resolved("hello")
                expect await f1 == 42
                expect await f2 == "hello"

        describe "is_ready check":
            it "resolved future is ready immediately":
                val f = resolved(42)
                expect is_ready(f)

            it "can check and await":
                val f = future(42)
                val result = await f
                expect is_ready(f)
                expect result == 42

        describe "Worker Configuration":
            it "can configure worker count":
                async_workers(2)
                val f = future(42)
                expect await f == 42
                # Reset to default
                async_workers(4)

    describe "Isolated Threads":
        # Note: Full thread tests require interpreter FFI integration
        # which is implemented at the runtime level. These tests are
        # placeholders until the interpreter can call rt_thread_* functions.
        describe "Basic thread operations":
            skip "reports available parallelism":
                # Requires FFI: rt_thread_available_parallelism
                val cores = available_parallelism()
                expect cores >= 1

            skip "can sleep thread":
                # Requires FFI: rt_thread_sleep
                val start = time_now()
                sleep(10)
                val elapsed = time_now() - start
                expect elapsed >= 5

            skip "can yield thread":
                # Requires FFI: rt_thread_yield
                yield_thread()
                expect true

        describe "Thread spawning":
            skip "spawns isolated thread and joins":
                # Requires FFI: rt_thread_spawn_isolated2, rt_thread_join
                val ch = Channel.new()
                val handle = spawn_isolated2([1, 2, 3], ch) \data, result_ch:
                    val sum = 0
                    for x in data:
                        sum = sum + x
                    result_ch.send(sum)
                    return nil

                val result = ch.recv()
                handle.join()
                expect result == 6

        describe "Channel FFI":
            # Channel tests using runtime FFI
            skip "creates channel":
                # Requires FFI: rt_channel_new
                val ch = Channel.new()
                expect ch != nil

            skip "sends and receives on channel":
                # Requires FFI: rt_channel_send, rt_channel_try_recv
                val ch = Channel.new()
                ch.send(42)
                val result = ch.try_recv()
                expect result == 42

            skip "try_recv returns nil on empty channel":
                val ch = Channel.new()
                val result = ch.try_recv()
                expect result == nil

            skip "sends multiple values":
                val ch = Channel.new()
                ch.send(1)
                ch.send(2)
                ch.send(3)
                expect ch.try_recv() == 1
                expect ch.try_recv() == 2
                expect ch.try_recv() == 3

            skip "closes channel":
                # Requires FFI: rt_channel_close, rt_channel_is_closed
                val ch = Channel.new()
                ch.send(42)
                ch.close()
                expect ch.is_closed()
