# Unit tests for incremental parsing
# Phase 2: Incremental update tests

import spec.{describe, it, expect}
import parser.treesitter.{TreeSitterParser, Tree}
import parser.treesitter.edits.{InputEdit, Point, compute_edits}

describe("Incremental Parsing"):
    it("returns same tree when no edits"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 42"
        val old_tree = parser.parse(source).unwrap()

        # No edits
        val edits: [InputEdit] = []
        val new_tree = parser.parse_incremental(source, old_tree, edits).unwrap()

        expect(new_tree.version).to_equal(old_tree.version + 1)
        expect(new_tree.source).to_equal(source)

    it("reparses after single character change"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val old_source = "val x = 42"
        val old_tree = parser.parse(old_source).unwrap()

        # Change 42 to 43
        val new_source = "val x = 43"
        val edits = compute_edits(old_source, new_source)

        val new_tree = parser.parse_incremental(new_source, old_tree, edits).unwrap()

        expect(new_tree.version).to_equal(old_tree.version + 1)
        expect(new_tree.source).to_equal(new_source)
        expect(new_tree.root().is_some()).to_be(true)

    it("reparses after adding new statement"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val old_source = "val x = 1"
        val old_tree = parser.parse(old_source).unwrap()

        # Add new statement
        val new_source = "val x = 1\nlet y = 2"
        val edits = compute_edits(old_source, new_source)

        val new_tree = parser.parse_incremental(new_source, old_tree, edits).unwrap()

        expect(new_tree.version).to_equal(old_tree.version + 1)
        expect(new_tree.source).to_equal(new_source)

    it("reparses after removing statement"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val old_source = "val x = 1\nlet y = 2"
        val old_tree = parser.parse(old_source).unwrap()

        # Remove second statement
        val new_source = "val x = 1"
        val edits = compute_edits(old_source, new_source)

        val new_tree = parser.parse_incremental(new_source, old_tree, edits).unwrap()

        expect(new_tree.version).to_equal(old_tree.version + 1)
        expect(new_tree.source).to_equal(new_source)

    it("reparses after changing function name"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val old_source = "fn foo(): return 1"
        val old_tree = parser.parse(old_source).unwrap()

        # Rename function
        val new_source = "fn bar(): return 1"
        val edits = compute_edits(old_source, new_source)

        val new_tree = parser.parse_incremental(new_source, old_tree, edits).unwrap()

        expect(new_tree.version).to_equal(old_tree.version + 1)
        expect(new_tree.source).to_equal(new_source)

    it("handles multiple sequential edits"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source1 = "val x = 1"
        val tree1 = parser.parse(source1).unwrap()

        # First edit: change value
        val source2 = "val x = 2"
        val edits1 = compute_edits(source1, source2)
        val tree2 = parser.parse_incremental(source2, tree1, edits1).unwrap()

        # Second edit: add statement
        val source3 = "val x = 2\nlet y = 3"
        val edits2 = compute_edits(source2, source3)
        val tree3 = parser.parse_incremental(source3, tree2, edits2).unwrap()

        expect(tree3.version).to_equal(2)  # Two incremental parses
        expect(tree3.source).to_equal(source3)

describe("compute_edits"):
    it("returns empty for identical texts"):
        val edits = compute_edits("hello", "hello")
        expect(edits.len()).to_equal(0)

    it("computes full document replacement"):
        val old_text = "val x = 1"
        val new_text = "val y = 2"
        val edits = compute_edits(old_text, new_text)

        expect(edits.len()).to_equal(1)

        val edit = edits[0]
        expect(edit.start_byte).to_equal(0)
        expect(edit.old_end_byte).to_equal(old_text.len())
        expect(edit.new_end_byte).to_equal(new_text.len())

    it("tracks line and column positions"):
        val old_text = "line1\nline2"
        val new_text = "line1\nmodified"
        val edits = compute_edits(old_text, new_text)

        expect(edits.len()).to_equal(1)

        val edit = edits[0]
        expect(edit.start_point.line).to_equal(1)
        expect(edit.start_point.column).to_equal(1)

describe("InputEdit"):
    it("detects affected spans"):
        val edit = InputEdit.new(
            start_byte: 5,
            old_end_byte: 10,
            new_end_byte: 15,
            start_point: Point.new(1, 5),
            old_end_point: Point.new(1, 10),
            new_end_point: Point.new(1, 15)
        )

        # Span before edit: not affected
        val span_before = Span(
            start_byte: 0, end_byte: 4,
            start_line: 1, end_line: 1,
            start_column: 0, end_column: 4
        )
        expect(edit.affects_span(span_before)).to_be(false)

        # Span during edit: affected
        val span_during = Span(
            start_byte: 5, end_byte: 10,
            start_line: 1, end_line: 1,
            start_column: 5, end_column: 10
        )
        expect(edit.affects_span(span_during)).to_be(true)

        # Span after edit: not affected
        val span_after = Span(
            start_byte: 20, end_byte: 25,
            start_line: 1, end_line: 1,
            start_column: 20, end_column: 25
        )
        expect(edit.affects_span(span_after)).to_be(false)

    it("adjusts byte offsets correctly"):
        val edit = InputEdit.new(
            start_byte: 10,
            old_end_byte: 15,
            new_end_byte: 20,
            start_point: Point.new(1, 10),
            old_end_point: Point.new(1, 15),
            new_end_point: Point.new(1, 20)
        )

        # Before edit: unchanged
        expect(edit.adjust_byte(5)).to_equal(5)

        # Inside edit: maps to start
        expect(edit.adjust_byte(12)).to_equal(10)

        # After edit: shifted by delta (+5)
        expect(edit.adjust_byte(20)).to_equal(25)

    it("adjusts points correctly for single-line edits"):
        val edit = InputEdit.new(
            start_byte: 10,
            old_end_byte: 15,
            new_end_byte: 18,
            start_point: Point.new(1, 10),
            old_end_point: Point.new(1, 15),
            new_end_point: Point.new(1, 18)
        )

        # Before edit
        val before = Point.new(1, 5)
        val adjusted_before = edit.adjust_point(before)
        expect(adjusted_before.line).to_equal(1)
        expect(adjusted_before.column).to_equal(5)

        # After edit (same line)
        val after = Point.new(1, 20)
        val adjusted_after = edit.adjust_point(after)
        expect(adjusted_after.line).to_equal(1)
        expect(adjusted_after.column).to_equal(23)  # 20 + (18 - 15) = 23

describe("Point"):
    it("compares points correctly"):
        val p1 = Point.new(1, 5)
        val p2 = Point.new(1, 10)
        val p3 = Point.new(2, 5)

        expect(p1.is_before(p2)).to_be(true)
        expect(p2.is_after(p1)).to_be(true)
        expect(p1.is_before(p3)).to_be(true)
        expect(p3.is_after(p1)).to_be(true)

    it("detects equality"):
        val p1 = Point.new(1, 5)
        val p2 = Point.new(1, 5)
        val p3 = Point.new(1, 6)

        expect(p1.equals(p2)).to_be(true)
        expect(p1.equals(p3)).to_be(false)
