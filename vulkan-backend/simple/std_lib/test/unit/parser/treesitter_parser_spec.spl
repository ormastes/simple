# Unit tests for tree-sitter parser
# Phase 1: Basic parsing tests

import spec.{describe, it, expect}
import parser.treesitter.{TreeSitterParser, Tree, Node}

describe("TreeSitterParser"):
    it("creates parser for Simple language"):
        val result = TreeSitterParser.new("simple")
        expect(result.is_ok()).to_be(true)

    it("rejects unsupported languages"):
        val result = TreeSitterParser.new("python")
        expect(result.is_err()).to_be(true)

    it("parses empty source"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val result = parser.parse("")
        expect(result.is_ok()).to_be(true)

    it("parses simple integer literal"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "42"
        val result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

        val tree = result.unwrap()
        expect(tree.source).to_equal(source)

    it("parses identifier"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "foo"
        val result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it("parses binary expression"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "1 + 2"
        val result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it("parses val statement"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "val x = 42"
        val result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it("parses return statement"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "return 42"
        val result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it("parses simple function - Phase 1 deliverable"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn add(x: i32): return x + 1"
        val result = parser.parse(source)

        # This is the Phase 1 deliverable: parse this successfully
        expect(result.is_ok()).to_be(true)

        val tree = result.unwrap()
        expect(tree.source).to_equal(source)

        # Verify we have a root node
        match tree.root():
            case Some(root):
                expect(root.kind).to_equal("module")
            case None:
                # Fail the test
                expect(false).to_be(true)

    it("parses function with multiple parameters"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn multiply(x: i32, y: i32): return x * y"
        val result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it("parses function with no return type"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "fn print_hello(): return nil"
        val result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it("parses nested expressions"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "(1 + 2) * 3"
        val result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

    it("parses comparison operators"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val source = "x < 10"
        val result = parser.parse(source)
        expect(result.is_ok()).to_be(true)

describe("Tree"):
    it("provides root node access"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("42").unwrap()

        match tree.root():
            case Some(root):
                expect(root.kind).to_equal("module")
            case None:
                expect(false).to_be(true)

    it("allows node traversal"):
        val parser = TreeSitterParser.new("simple").unwrap()
        val tree = parser.parse("1 + 2").unwrap()

        val cursor = tree.walk()
        match cursor.node():
            case Some(node):
                expect(node.kind).to_equal("module")
                expect(node.child_count()).to_be_greater_than(0)
            case None:
                expect(false).to_be(true)
