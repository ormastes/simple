///
SDN Parser Tests

Tests for LL(2) recursive descent parser.

Covers:
- Primitive parsing (all value types)
- Inline collections (short form with =)
- Block collections (long form with :)
- Tables (named with |fields|, typed with table{types})
- Dict vs array block disambiguation (LL(2) lookahead)
- Error handling
///

import std.spec
import sdn.parser.parse
import sdn.value.SdnValue

describe "SDN Parser":
    context "simple values":
        it "parses key-value pairs":
            let result = parse("name: Alice")
            match result:
                case Ok(doc):
                    match doc.get("name"):
                        case Some(val):
                            expect val.as_str() == Some("Alice")
                        case None:
                            fail("Expected name field")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses multiple values":
            let result = parse("x: 10\ny: 20")
            match result:
                case Ok(doc):
                    expect doc.get("x").flatmap(|v| v.as_i64()) == Some(10)
                    expect doc.get("y").flatmap(|v| v.as_i64()) == Some(20)
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses quoted strings":
            let result = parse("msg: \"Hello, World!\"")
            match result:
                case Ok(doc):
                    match doc.get("msg"):
                        case Some(val):
                            expect val.as_str() == Some("Hello, World!")
                        case None:
                            fail("Expected msg field")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses floats":
            let result = parse("pi: 3.14")
            match result:
                case Ok(doc):
                    match doc.get("pi"):
                        case Some(val):
                            match val.as_f64():
                                case Some(f):
                                    expect f > 3.13 and f < 3.15
                                case None:
                                    fail("Expected float value")
                        case None:
                            fail("Expected pi field")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses null values":
            let result = parse("empty: null")
            match result:
                case Ok(doc):
                    match doc.get("empty"):
                        case Some(val):
                            expect val.is_null() == True
                        case None:
                            fail("Expected empty field")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

    context "inline collections":
        it "parses inline dicts":
            let result = parse("point = {x: 10, y: 20}")
            match result:
                case Ok(doc):
                    match doc.get("point"):
                        case Some(point):
                            expect point.is_dict() == True
                            expect point.get("x").flatmap(|v| v.as_i64()) == Some(10)
                            expect point.get("y").flatmap(|v| v.as_i64()) == Some(20)
                        case None:
                            fail("Expected point field")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses inline arrays":
            let result = parse("items = [1, 2, 3]")
            match result:
                case Ok(doc):
                    match doc.get("items"):
                        case Some(arr):
                            expect arr.is_array() == True
                            match arr.as_array():
                                case Some(list):
                                    expect list.len == 3
                                case None:
                                    fail("Expected array")
                        case None:
                            fail("Expected items field")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses nested inline structures":
            let result = parse("data = {inner: {value: 42}}")
            match result:
                case Ok(doc):
                    let val = doc.get_path("data.inner.value")
                    expect val.flatmap(|v| v.as_i64()) == Some(42)
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

    context "block collections":
        it "parses block dicts":
            let source = "server:\n    host: localhost\n    port: 8080"
            let result = parse(source)

            match result:
                case Ok(doc):
                    expect doc.get_path("server.host").flatmap(|v| v.as_str()) == Some("localhost")
                    expect doc.get_path("server.port").flatmap(|v| v.as_i64()) == Some(8080)
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses block arrays":
            let source = "items:\n    foo\n    bar\n    baz"
            let result = parse(source)

            match result:
                case Ok(doc):
                    match doc.get("items"):
                        case Some(arr):
                            expect arr.is_array() == True
                            match arr.as_array():
                                case Some(list):
                                    expect list.len == 3
                                case None:
                                    fail("Expected array")
                        case None:
                            fail("Expected items field")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses deeply nested blocks":
            let source = "a:\n    b:\n        c:\n            value: 42"
            let result = parse(source)

            match result:
                case Ok(doc):
                    expect doc.get_path("a.b.c.value").flatmap(|v| v.as_i64()) == Some(42)
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

    context "tables":
        it "parses named tables":
            let source = "users |id, name|\n    1, Alice\n    2, Bob"
            let result = parse(source)

            match result:
                case Ok(doc):
                    match doc.get("users"):
                        case Some(table):
                            expect table.is_table() == True
                        case None:
                            fail("Expected users table")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses typed tables (short form)":
            let source = "coords: table{i32, i32} = [(10, 20), (30, 40)]"
            let result = parse(source)

            match result:
                case Ok(doc):
                    match doc.get("coords"):
                        case Some(table):
                            expect table.is_table() == True
                        case None:
                            fail("Expected coords table")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "parses typed tables (long form)":
            let source = "matrix: table{i32, i32, i32}\n    1, 0, 0\n    0, 1, 0\n    0, 0, 1"
            let result = parse(source)

            match result:
                case Ok(doc):
                    match doc.get("matrix"):
                        case Some(table):
                            expect table.is_table() == True
                        case None:
                            fail("Expected matrix table")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

    context "comments":
        it "ignores comments during parsing":
            let source = "# This is a comment\nvalue: 42  # inline comment\n# another comment"
            let result = parse(source)

            match result:
                case Ok(doc):
                    expect doc.get("value").flatmap(|v| v.as_i64()) == Some(42)
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

    context "LL(2) lookahead":
        it "disambiguates dict blocks from array blocks":
            # Dict block (has colon after identifier)
            let dict_source = "data:\n    key: value"
            match parse(dict_source):
                case Ok(doc):
                    match doc.get("data"):
                        case Some(val):
                            expect val.is_dict() == True
                        case None:
                            fail("Expected data field")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

            # Array block (no colon after identifier)
            let array_source = "data:\n    item1\n    item2"
            match parse(array_source):
                case Ok(doc):
                    match doc.get("data"):
                        case Some(val):
                            expect val.is_array() == True
                        case None:
                            fail("Expected data field")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

    context "real-world examples":
        it "parses config files":
            let source = """
app:
    name: MyService
    version: 2.1.0

server:
    host: 0.0.0.0
    port: 8080

features = [auth, logging, metrics]
"""
            let result = parse(source)

            match result:
                case Ok(doc):
                    expect doc.get_path("app.name").flatmap(|v| v.as_str()) == Some("MyService")
                    expect doc.get_path("server.port").flatmap(|v| v.as_i64()) == Some(8080)
                    match doc.get("features"):
                        case Some(arr):
                            expect arr.is_array() == True
                        case None:
                            fail("Expected features array")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

    context "error handling":
        it "reports syntax errors with location":
            let result = parse("invalid syntax @#$")
            match result:
                case Ok(_):
                    fail("Should have failed to parse")
                case Err(e):
                    # Error should contain location info
                    let msg = e.to_string()
                    expect msg.len > 0

        it "reports missing colon":
            let result = parse("key value")  # Missing colon
            match result:
                case Ok(_):
                    fail("Should have failed to parse")
                case Err(_):
                    pass  # Expected error
