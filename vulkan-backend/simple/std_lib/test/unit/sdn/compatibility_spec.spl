///
SDN Compatibility Tests

Tests that compare Simple SDN implementation with Rust SDN implementation.

Ensures:
- Parse output matches between implementations
- Serialization is compatible
- CLI commands produce identical results
- Edge cases handled consistently
///

import std.spec
import std.process
import std.fs
import std.json
import sdn.parser.parse
import sdn.serializer.{to_sdn, to_json}
import sdn.document.SdnDocument

describe "SDN Rust Compatibility":
    context "primitives":
        it "matches Rust for integers":
            val input = "value: 42"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

        it "matches Rust for floats":
            val input = "value: 3.14159"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

        it "matches Rust for strings":
            val input = "name: Alice\ngreeting: Hello, World!"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

        it "matches Rust for booleans":
            val input = "enabled: true\ndisabled: false"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

        it "matches Rust for null":
            val input = "value: null"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

    context "inline collections":
        it "matches Rust for inline arrays":
            val input = "items = [1, 2, 3, 4, 5]"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

        it "matches Rust for inline dicts":
            val input = "point = {x: 10, y: 20}"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

        it "matches Rust for nested inline":
            val input = "data = {items: [1, 2, 3], meta: {count: 3}}"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

    context "block collections":
        it "matches Rust for dict blocks":
            val input = "server:\n    host: localhost\n    port: 8080"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

        it "matches Rust for array blocks":
            val input = "items:\n    1\n    2\n    3"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

        it "matches Rust for nested blocks":
            val input = "app:\n    name: MyService\n    config:\n        debug: true\n        level: 5"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

    context "tables":
        it "matches Rust for named tables":
            val input = "users |id, name|\n    1, Alice\n    2, Bob"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

        it "matches Rust for typed tables":
            val input = "data table{int, string}\n    1, Alice\n    2, Bob"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

    context "edge cases":
        it "matches Rust for empty collections":
            val input = "empty_array = []\nempty_dict = {}"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

        it "matches Rust for special characters":
            val input = "msg: \"Hello\\nWorld\\t!\""
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

        it "matches Rust for unicode":
            val input = "greeting: ä½ å¥½\nemoji: ðŸš€"
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

    context "real-world examples":
        it "matches Rust for config file":
            val input = """
app:
    name: MyService
    version: 2.1.0

server:
    host: 0.0.0.0
    port: 8080

features = [auth, logging, metrics]
"""
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

        it "matches Rust for data file":
            val input = """
users |id, name, email|
    1, Alice, alice@example.com
    2, Bob, bob@example.com
    3, Carol, carol@example.com
"""
            val (matches, diff) = compare_with_rust(input)
            expect matches, "Output differs from Rust:\n${diff}"

### Helper Functions

fn compare_with_rust(sdn_source: String) -> (Bool, String):
    """
    Compare Simple SDN implementation with Rust implementation

    Returns: (matches: Bool, diff: String)
    """
    # Parse with Simple
    val simple_value = match parse(sdn_source):
        case Ok(v):
            v
        case Err(e):
            return (False, "Simple parse error: ${e.to_string()}")

    val simple_json = to_json(simple_value)

    # Parse with Rust CLI (if available)
    val rust_result = run_rust_sdn_cli(sdn_source)

    match rust_result:
        case Ok(rust_json):
            # Normalize both JSON outputs
            val simple_norm = normalize_json(simple_json)
            val rust_norm = normalize_json(rust_json)

            if simple_norm == rust_norm:
                return (True, "")
            else:
                val diff = format_diff(rust_norm, simple_norm)
                return (False, diff)
        case Err(e):
            # Rust CLI not available - skip comparison
            # (This is expected in CI/testing environments without Rust binary)
            return (True, "Rust CLI not available (skipped)")

fn run_rust_sdn_cli(input: String) -> Result<String, String>:
    """
    Run Rust SDN CLI to convert SDN to JSON

    Returns JSON output from Rust implementation
    """
    # Check if Rust sdn binary exists
    val sdn_path = find_rust_sdn_binary()

    match sdn_path:
        case Some(path):
            # Create temp file for input
            val temp_file = "/tmp/sdn_test_${process.pid()}.sdn"

            match fs.write(temp_file, input):
                case Ok(_):
                    pass
                case Err(e):
                    return Err("Failed to write temp file: ${e.to_string()}")

            # Run: sdn to-json <temp_file>
            val result = process.run([path, "to-json", temp_file])

            # Clean up temp file
            fs.remove(temp_file)

            match result:
                case Ok(output):
                    if output.exit_code == 0:
                        return Ok(output.stdout)
                    else:
                        return Err("Rust CLI failed: ${output.stderr}")
                case Err(e):
                    return Err("Failed to run Rust CLI: ${e.to_string()}")
        case None:
            return Err("Rust sdn binary not found")

fn find_rust_sdn_binary() -> Option<String>:
    """
    Find Rust sdn binary in common locations

    Checks:
    - ./target/debug/sdn
    - ./target/release/sdn
    - PATH (sdn)
    """
    val candidates = [
        "target/debug/sdn",
        "target/release/sdn",
        "sdn"
    ]

    for path in candidates:
        if fs.exists(path):
            return Some(path)

    return None

fn normalize_json(json_str: String) -> String:
    """
    Normalize JSON for comparison

    - Parse and re-serialize to canonical form
    - Sort object keys
    - Consistent whitespace
    """
    match json.parse(json_str):
        case Ok(value):
            # Re-serialize with sorted keys
            return json.stringify(value, sorted_keys: True)
        case Err(_):
            # Return original if parse fails
            return json_str

fn format_diff(expected: String, actual: String) -> String:
    """Format diff between expected and actual"""
    var result = ""
    result += "Expected (Rust):\n"
    result += expected
    result += "\n\n"
    result += "Actual (Simple):\n"
    result += actual
    result += "\n"
    return result
