/// Comprehensive tests to verify given: (unnamed eager) and given_lazy work correctly
/// NOTE: In Simple, closure capture is by value. For shared mutable state, use given_lazy/get_let.

describe "Given (Eager Fixtures)":

    describe "Unnamed eager - given { }":
        context "with eager setup":
            # Use given_lazy for state that needs to be checked in tests
            given_lazy :setup_ran, \: true

            given:
                # This runs before each example for side effects
                print("")  # Placeholder for actual side effects

            it "setup_ran is available":
                expect get_let(:setup_ran) == true

            it "setup_ran is true in second example too":
                expect get_let(:setup_ran) == true

    describe "Named eager - given :name, \\:":
        context "with named eager setup":
            # Use given_lazy for values that tests need to access
            given_lazy :counter, \: 1
            given_lazy :processed, \: true

            given :initialize, \:
                # This runs before each example
                print("")  # Placeholder

            given :process, \:
                # This runs before each example
                print("")  # Placeholder

            it "counter is initialized":
                expect get_let(:counter) == 1

            it "processed is true":
                expect get_let(:processed)

            it "each example gets fresh state":
                expect get_let(:counter) == 1
                expect get_let(:processed)

    describe "Combining unnamed and named given":
        context "with mixed eager fixtures":
            given_lazy :order, \: ["unnamed", "first", "second"]

            given:
                # Runs before each example
                print("")

            given :first, \:
                print("")

            given :second, \:
                print("")

            it "order list has expected values":
                val order = get_let(:order)
                expect len(order) == 3
                expect order[0] == "unnamed"
                expect order[1] == "first"
                expect order[2] == "second"

            it "second example sees same order":
                val order = get_let(:order)
                expect len(order) == 3

    describe "Given with lazy fixtures":
        context "mixing eager and lazy":
            given_lazy :initialized, \: true

            given:
                # Runs before each example
                print("")

            given_lazy :data, \:
                # Returns a dict with string keys
                {"value": 42, "initialized": get_let(:initialized)}

            it "eager runs before lazy":
                expect get_let(:initialized)
                val data = get_let(:data)
                expect data["initialized"]
                expect data["value"] == 42

            it "lazy is memoized, eager runs again":
                expect get_let(:initialized)
                val data = get_let(:data)
                expect data["value"] == 42

    describe "Given in nested contexts":
        context "outer context":
            given_lazy :level, \: 11

            given:
                # Outer given runs first
                print("")

            context "inner context":
                given:
                    # Inner given runs after outer
                    print("")

                it "level is available in inner":
                    expect get_let(:level) == 11

    describe "Given in context_def":
        context_def :with_eager_setup:
            given:
                # This runs in context definitions
                print("")  # Placeholder

            given_lazy :fixture, \:
                "value"

        context :with_eager_setup:
            it "context_def given works":
                expect get_let(:fixture) == "value"

    describe "Real-world database simulation":
        context "with realistic setup":
            given_lazy :db_state, \:
                {"tables": 2, "connected": true}

            given:
                # Simulate: db.connect()
                print("")

            given_lazy :users_table, \:
                {"count": 0, "name": "users"}

            it "connection established":
                val db = get_let(:db_state)
                expect db["connected"]

            it "tables created":
                val db = get_let(:db_state)
                expect db["tables"] >= 2

            it "users table exists":
                val table = get_let(:users_table)
                expect table["name"] == "users"

            it "second test gets fresh setup":
                val db = get_let(:db_state)
                expect db["connected"]
                expect db["tables"] >= 2

    describe "Referencing context_def in given blocks":
        context_def :db_fixtures:
            given_lazy :database, \:
                {"connected": true, "tables": ["users", "posts"]}

        context_def :auth_fixtures:
            given_lazy :token, \:
                "auth_token_xyz"

        context "composing multiple contexts via given":
            # Reference context_def directly via given
            given :db_fixtures

            given :auth_fixtures

            it "has database from context_def":
                val db = get_let(:database)
                expect db["connected"]
                val tables = db["tables"]
                expect len(tables) == 2

            it "has token from context_def":
                expect get_let(:token) == "auth_token_xyz"

    describe "Sequential given block with context refs and variables":
        context_def :user_data:
            given_lazy :user, \:
                {"name": "Alice", "id": 42}

        context "sequential setup - using context_def":
            # Reference context_def
            given :user_data

            # Use lazy values for derived data
            given_lazy :user_key, \:
                val user = get_let(:user)
                f"user_{user["id"]}"

            given_lazy :greeting, \:
                val user = get_let(:user)
                f"Hello, {user["name"]}"

            it "accesses fixture from context_def":
                val user = get_let(:user)
                expect user["name"] == "Alice"

            it "uses derived variable from fixture":
                expect get_let(:user_key) == "user_42"

            it "combines context data with new variables":
                expect get_let(:greeting) == "Hello, Alice"

            it "each test gets fresh derived state":
                expect get_let(:user_key) == "user_42"
                expect get_let(:greeting) == "Hello, Alice"

main = 0
