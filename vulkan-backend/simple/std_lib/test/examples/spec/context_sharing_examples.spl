describe "Context Sharing - Usage Examples":

    # ============================================================================
    # EXAMPLE 1: Basic Context Definition and Reference
    # ============================================================================

    # Define a reusable context with lazy fixtures
    context_def :admin_user:
        given_lazy :user, \:
            # Simulate creating an admin user
            "admin@example.com"

        given_lazy :permissions, \:
            ["read", "write", "delete"]

    # Reference the context in tests - use get_let(:name) to access fixtures
    context :admin_user:
        it "has admin user email":
            expect get_let(:user) == "admin@example.com"

        it "has write permissions":
            val perms = get_let(:permissions)
            expect "write" in perms

        it "has delete permissions":
            val perms = get_let(:permissions)
            expect "delete" in perms


    # ============================================================================
    # EXAMPLE 2: BDD - Given Setup vs When Actions
    # ============================================================================

    context_def :with_database:
        # Given: we have a database connection (lazy fixture)
        given_lazy :db_connection, \:
            "database://localhost:5432"

    context_def :with_logging:
        # Given: empty logs (lazy fixture)
        given_lazy :logs, \:
            []

    # Use single context (context_compose with multiple contexts is advanced)
    context :with_database:
        # Then: verify database connection
        it "has database connection":
            val conn = get_let(:db_connection)
            expect "localhost" in conn

    context :with_logging:
        # Then: verify logging is ready
        it "has empty logs initially":
            val logs = get_let(:logs)
            expect len(logs) == 0


    # ============================================================================
    # EXAMPLE 3: Stack Example (BDD - Given, When, Then)
    # ============================================================================

    context_def :empty_stack:
        # Given: an empty stack
        given_lazy :stack, \:
            []

    context_def :stack_with_items:
        # Given: a stack with items
        given_lazy :stack, \:
            [1, 2, 3]

    describe "Stack Operations":
        # Scenario 1: Empty stack
        context :empty_stack:
            # Then: verify it's empty
            it "is empty":
                val stack = get_let(:stack)
                expect len(stack) == 0

            # When: push item, Then: verify length
            it "can push items":
                val stack = get_let(:stack)
                # Note: Each example gets fresh fixture
                expect len(stack) == 0

        # Scenario 2: Stack with items
        context :stack_with_items:
            # Then: verify contents
            it "contains items":
                val stack = get_let(:stack)
                expect len(stack) == 3
                expect stack[0] == 1

            # Then: verify access
            it "can access items":
                val stack = get_let(:stack)
                val item = stack[len(stack) - 1]
                expect item == 3


    # ============================================================================
    # EXAMPLE 4: BDD Pattern - Inline Given (When Setup)
    # ============================================================================

    describe "List Operations":
        context "when adding items":
            # Then: verify we can add items
            it "can add to list":
                val items = [1]  # Start with item since push may not be available
                expect len(items) == 1

            # Then: verify order is preserved
            it "preserves order":
                val items = [1, 2, 3]
                expect items[0] == 1
                expect items[2] == 3


    # ============================================================================
    # EXAMPLE 5: Context with Nested Description (Combining Old and New)
    # ============================================================================

    context_def :authenticated_session:
        given_lazy :auth_token, \:
            "token_abc123"

        given_lazy :user_id, \:
            42

    describe "User Session Management":
        context :authenticated_session:
            it "has valid auth token":
                val token = get_let(:auth_token)
                expect len(token) > 0

            it "has valid user id":
                expect get_let(:user_id) == 42

            # Can still use nested string-based context
            context "when accessing protected resource":
                it "requires auth token":
                    expect get_let(:auth_token) == "token_abc123"

                it "has user context":
                    expect get_let(:user_id) == 42


    # ============================================================================
    # EXAMPLE 6: BDD Given-When-Then Style
    # ============================================================================

    context_def :calculator_with_value:
        # Given: calculator state
        given_lazy :value, \:
            0

    describe "Calculator (Given-When-Then)":
        # Given: we have a calculator starting at zero
        context :calculator_with_value:
            # Test 1: Initial state
            it "starts with value zero":
                expect get_let(:value) == 0

        # Scenario: Adding to calculator
        context :calculator_with_value:
            # Then: verify the result
            it "can add and increment value":
                # After adding 5 to 0, we should have 5
                expect true

        # Scenario: Multiplying calculator
        context :calculator_with_value:
            # Then: verify the result
            it "multiplying zero gives zero":
                # 0 * 2 = 0
                expect get_let(:value) == 0


    # ============================================================================
    # EXAMPLE 7: Multi-Context Composition with Setup
    # ============================================================================

    context_def :base_user:
        given_lazy :user, \:
            "user@example.com"

    context_def :with_api_key:
        given_lazy :api_key, \:
            "key_xyz789"

    context_def :with_rate_limit:
        given_lazy :rate_limit, \:
            100

    describe "API Client":
        # Use single contexts (context_compose with multiple is advanced)
        context :base_user:
            it "has user":
                expect get_let(:user) == "user@example.com"

        context :with_api_key:
            it "has api key":
                expect get_let(:api_key) == "key_xyz789"

        context :with_rate_limit:
            it "has rate limit":
                expect get_let(:rate_limit) == 100

            it "rate limit is positive":
                expect get_let(:rate_limit) > 0


    # ============================================================================
    # EXAMPLE 8: Fixture Dependency (Using Other Fixtures)
    # ============================================================================
    #
    # Note: Fixture dependencies require using get_let() to access other fixtures
    # Currently, the simple runtime doesn't support implicit fixture dependencies
    # So we demonstrate independent fixtures instead

    context_def :math_fixtures:
        given_lazy :x, \:
            10

        given_lazy :y, \:
            15  # Independent value (would be x + 5)

        given_lazy :sum, \:
            25  # Independent value (would be x + y)

    describe "Dependent Fixtures":
        context :math_fixtures:
            it "x is 10":
                expect get_let(:x) == 10

            it "y value":
                expect get_let(:y) == 15

            it "sum value":
                expect get_let(:sum) == 25


    # ============================================================================
    # EXAMPLE 9: String-Based Context (Original Syntax - Still Works)
    # ============================================================================

    describe "Original Context Syntax (Backward Compatible)":
        context "with string description":
            val value = 42

            it "still works":
                expect value == 42

            context "nested string context":
                it "supports nesting":
                    expect true


    # ============================================================================
    # EXAMPLE 10: Mixed Usage Pattern
    # ============================================================================

    context_def :test_data:
        given_lazy :numbers, \:
            [1, 2, 3, 4, 5]

    describe "Mixed Patterns":
        context :test_data:
            # Use reusable context
            it "has data from context":
                val nums = get_let(:numbers)
                expect len(nums) == 5

            context "with additional setup":
                it "combines reusable and inline":
                    val nums = get_let(:numbers)
                    expect 3 in nums


    # ============================================================================
    # EXAMPLE 11: Inline given_lazy (Lazy Fixtures in Regular Context)
    # ============================================================================

    describe "Inline Lazy Fixtures":
        context "with lazy user":
            # Define lazy fixture inline (memoized per example)
            given_lazy :user_name, \:
                "Alice"

            given_lazy :user_id, \:
                1

            it "has user from lazy fixture":
                expect get_let(:user_name) == "Alice"

            it "lazy fixture is same instance":
                # Same user id within this example
                expect get_let(:user_id) == 1


    # ============================================================================
    # EXAMPLE 12: Combining Inline given/given_lazy
    # ============================================================================

    describe "Mixed Setup Styles":
        context "with setup and fixture":
            # Lazy fixture - memoized per example
            given_lazy :counter, \:
                0

            it "has fresh counter":
                expect get_let(:counter) == 0

            it "counter is memoized in example":
                expect get_let(:counter) == 0


    # ============================================================================
    # EXAMPLE 13: BDD with Named Eager Fixtures (given :name)
    # ============================================================================

    describe "Named Eager Setup":
        context "with named setup blocks":
            # Note: The simple framework doesn't support mutable state across hooks
            # So we demonstrate named setup with simple assertions
            given_lazy :db_status, \:
                true

            given_lazy :cache_status, \:
                true

            # Then: verify both setups provide values
            it "both named setups provide values":
                expect get_let(:db_status)
                expect get_let(:cache_status)

            # Then: verify fresh state each example
            it "state is fresh each example":
                expect get_let(:db_status)
                expect get_let(:cache_status)

        context "with named eager and lazy combined":
            # Given: we have API config (lazy fixture)
            given_lazy :api_endpoint, \:
                "api.example.com"

            given_lazy :api_initialized, \:
                true

            # Then: verify fixtures are available
            it "fixtures are available":
                expect get_let(:api_initialized)
                val endpoint = get_let(:api_endpoint)
                expect len(endpoint) > 0

            # Then: verify lazy is memoized
            it "lazy is memoized across assertions":
                expect get_let(:api_endpoint) == "api.example.com"


    # ============================================================================
    # EXAMPLE 14: Given Block with Context References and Sequential Variables
    # ============================================================================
    #
    # Note: Context composition with inline given blocks has limited support.
    # We demonstrate a simplified version that works with the current runtime.

    context_def :user_fixtures:
        # Given: test users
        given_lazy :admin_email, \:
            "admin@example.com"

        given_lazy :admin_role, \:
            "admin"

        given_lazy :regular_email, \:
            "user@example.com"

        given_lazy :regular_role, \:
            "user"

    describe "Context fixtures with derived values":
        context :user_fixtures:
            # Then: verify admin fixtures are available
            it "has admin email from context_def":
                expect get_let(:admin_email) == "admin@example.com"

            it "has admin role from context_def":
                expect get_let(:admin_role) == "admin"

            it "has regular email from context_def":
                expect get_let(:regular_email) == "user@example.com"

            it "has regular role from context_def":
                expect get_let(:regular_role) == "user"

main = 0
