///
SDN Workflow System Tests

End-to-end tests for real-world SDN workflows.
Tests complete use cases and scenarios.

No mocks - tests realistic workflows:
- Configuration management
- Data migration (JSON â†” SDN)
- Batch operations
- Pipeline transformations
- Error recovery
///

import std.spec
import std.fs
import std.process
import std.random
import sdn.document.SdnDocument
import sdn.parser.parse
import sdn.serializer.{to_sdn, to_json}
import sdn.value.SdnValue

describe "SDN Workflow System Tests":
    context "configuration management":
        it "loads config, updates settings, and saves":
            # Create initial config
            val config = """
app:
    name: MyService
    version: 1.0.0
    debug: false

server:
    host: localhost
    port: 8080
    workers: 4

database:
    host: localhost
    port: 5432
    name: mydb
"""
            val path = create_test_file(config)

            # Load and update config
            match SdnDocument.from_file(path):
                case Ok(mut doc):
                    # Update version
                    doc.set("app.version", SdnValue.String("1.1.0"))

                    # Enable debug mode
                    doc.set("app.debug", SdnValue.Bool(True))

                    # Change server port
                    doc.set("server.port", SdnValue.Int(9000))

                    # Add new database setting
                    doc.set("database.pool_size", SdnValue.Int(20))

                    # Save
                    match doc.write_file(path):
                        case Ok(_):
                            pass
                        case Err(e):
                            fail("Failed to save config: ${e}")
                case Err(e):
                    fail("Failed to load config: ${e}")

            # Verify changes
            match SdnDocument.from_file(path):
                case Ok(doc):
                    expect doc.get("app.version").flatmap(|v| v.as_str()) == Some("1.1.0")
                    expect doc.get("app.debug").flatmap(|v| v.as_bool()) == Some(True)
                    expect doc.get("server.port").flatmap(|v| v.as_i64()) == Some(9000)
                    expect doc.get("database.pool_size").flatmap(|v| v.as_i64()) == Some(20)
                case Err(e):
                    fail("Failed to verify config: ${e}")

            cleanup_file(path)

        it "manages multiple config files":
            # Create dev config
            val dev_config = "env: development\nport: 8080\ndebug: true"
            val dev_path = create_test_file(dev_config)

            # Create prod config
            val prod_config = "env: production\nport: 80\ndebug: false"
            val prod_path = create_test_file(prod_config)

            # Load both
            val dev_doc = SdnDocument.from_file(dev_path)
            val prod_doc = SdnDocument.from_file(prod_path)

            match (dev_doc, prod_doc):
                case (Ok(dev), Ok(prod)):
                    # Verify dev config
                    expect dev.get("env").flatmap(|v| v.as_str()) == Some("development")
                    expect dev.get("debug").flatmap(|v| v.as_bool()) == Some(True)

                    # Verify prod config
                    expect prod.get("env").flatmap(|v| v.as_str()) == Some("production")
                    expect prod.get("debug").flatmap(|v| v.as_bool()) == Some(False)
                case _:
                    fail("Failed to load configs")

            cleanup_file(dev_path)
            cleanup_file(prod_path)

    context "data migration":
        it "migrates JSON config to SDN":
            # Create JSON config
            val json_config = """
{
  "app": {
    "name": "MyApp",
    "version": "2.0.0"
  },
  "features": ["auth", "logging", "metrics"]
}
"""
            val json_path = create_test_file(json_config)

            # Parse JSON
            match json.parse(json_config):
                case Ok(json_value):
                    # Convert to SDN
                    val sdn_value = json_to_sdn(json_value)
                    val sdn_content = to_sdn(sdn_value)

                    # Save as SDN
                    val sdn_path = "${json_path}.sdn"
                    match fs.write(sdn_path, sdn_content):
                        case Ok(_):
                            # Verify SDN file
                            match SdnDocument.from_file(sdn_path):
                                case Ok(doc):
                                    expect doc.get("app.name").flatmap(|v| v.as_str()) == Some("MyApp")
                                    expect doc.get("app.version").flatmap(|v| v.as_str()) == Some("2.0.0")
                                case Err(e):
                                    fail("Failed to load SDN: ${e}")

                            cleanup_file(sdn_path)
                        case Err(e):
                            fail("Failed to write SDN: ${e}")
                case Err(e):
                    fail("Failed to parse JSON: ${e}")

            cleanup_file(json_path)

        it "migrates SDN data to JSON":
            # Create SDN data
            val sdn_data = """
users:
    alice:
        age: 30
        role: admin
    bob:
        age: 25
        role: user
"""
            val sdn_path = create_test_file(sdn_data)

            # Load and convert to JSON
            match SdnDocument.from_file(sdn_path):
                case Ok(doc):
                    val json_content = doc.to_json()

                    # Save as JSON
                    val json_path = "${sdn_path}.json"
                    match fs.write(json_path, json_content):
                        case Ok(_):
                            # Verify JSON is valid
                            match fs.read_to_string(json_path):
                                case Ok(content):
                                    match json.parse(content):
                                        case Ok(_):
                                            pass  # Valid JSON
                                        case Err(e):
                                            fail("Invalid JSON output: ${e}")
                                case Err(e):
                                    fail("Failed to read JSON: ${e}")

                            cleanup_file(json_path)
                        case Err(e):
                            fail("Failed to write JSON: ${e}")
                case Err(e):
                    fail("Failed to load SDN: ${e}")

            cleanup_file(sdn_path)

    context "batch operations":
        it "updates multiple values in batch":
            val config = """
service_a:
    port: 8001
    enabled: true

service_b:
    port: 8002
    enabled: true

service_c:
    port: 8003
    enabled: true
"""
            val path = create_test_file(config)

            match SdnDocument.from_file(path):
                case Ok(mut doc):
                    # Disable all services
                    doc.set("service_a.enabled", SdnValue.Bool(False))
                    doc.set("service_b.enabled", SdnValue.Bool(False))
                    doc.set("service_c.enabled", SdnValue.Bool(False))

                    # Update all ports
                    doc.set("service_a.port", SdnValue.Int(9001))
                    doc.set("service_b.port", SdnValue.Int(9002))
                    doc.set("service_c.port", SdnValue.Int(9003))

                    match doc.write_file(path):
                        case Ok(_):
                            pass
                        case Err(e):
                            fail("Failed to save: ${e}")
                case Err(e):
                    fail("Failed to load: ${e}")

            # Verify all updates
            match SdnDocument.from_file(path):
                case Ok(doc):
                    expect doc.get("service_a.enabled").flatmap(|v| v.as_bool()) == Some(False)
                    expect doc.get("service_b.enabled").flatmap(|v| v.as_bool()) == Some(False)
                    expect doc.get("service_c.enabled").flatmap(|v| v.as_bool()) == Some(False)
                    expect doc.get("service_a.port").flatmap(|v| v.as_i64()) == Some(9001)
                    expect doc.get("service_b.port").flatmap(|v| v.as_i64()) == Some(9002)
                    expect doc.get("service_c.port").flatmap(|v| v.as_i64()) == Some(9003)
                case Err(e):
                    fail("Failed to verify: ${e}")

            cleanup_file(path)

        it "processes multiple files in sequence":
            # Create multiple config files
            val configs = [
                ("config1.sdn", "app: app1\nport: 8001"),
                ("config2.sdn", "app: app2\nport: 8002"),
                ("config3.sdn", "app: app3\nport: 8003")
            ]

            var paths = []

            # Process each config
            for (name, content) in configs:
                val path = create_test_file(content)
                paths.push(path)

                # Update port
                match SdnDocument.from_file(path):
                    case Ok(mut doc):
                        val current_port = doc.get("port").flatmap(|v| v.as_i64()).unwrap_or(0)
                        doc.set("port", SdnValue.Int(current_port + 1000))
                        doc.write_file(path)
                    case Err(e):
                        fail("Failed to process ${name}: ${e}")

            # Verify all updates
            for path in paths:
                match SdnDocument.from_file(path):
                    case Ok(doc):
                        val port = doc.get("port").flatmap(|v| v.as_i64()).unwrap_or(0)
                        expect port >= 9001 && port <= 9003
                    case Err(e):
                        fail("Failed to verify: ${e}")

                cleanup_file(path)

    context "pipeline transformations":
        it "transforms data through multiple stages":
            # Stage 1: Create initial data
            val initial = "items = [1, 2, 3, 4, 5]"
            val path = create_test_file(initial)

            # Stage 2: Double all values
            match SdnDocument.from_file(path):
                case Ok(mut doc):
                    match doc.get("items"):
                        case Some(arr):
                            match arr.as_array():
                                case Some(list):
                                    var doubled = []
                                    for item in list:
                                        match item.as_i64():
                                            case Some(n):
                                                doubled.push(SdnValue.Int(n * 2))
                                            case None:
                                                doubled.push(item)
                                    doc.set("items", SdnValue.Array(doubled))
                                case None:
                                    fail("Expected array")
                        case None:
                            fail("Expected items")

                    doc.write_file(path)
                case Err(e):
                    fail("Stage 2 failed: ${e}")

            # Stage 3: Add sum
            match SdnDocument.from_file(path):
                case Ok(mut doc):
                    match doc.get("items"):
                        case Some(arr):
                            match arr.as_array():
                                case Some(list):
                                    var sum = 0
                                    for item in list:
                                        match item.as_i64():
                                            case Some(n):
                                                sum += n
                                            case None:
                                                pass

                                    doc.set("sum", SdnValue.Int(sum))
                                case None:
                                    fail("Expected array")
                        case None:
                            fail("Expected items")

                    doc.write_file(path)
                case Err(e):
                    fail("Stage 3 failed: ${e}")

            # Verify final result
            match SdnDocument.from_file(path):
                case Ok(doc):
                    # Items should be [2, 4, 6, 8, 10]
                    # Sum should be 30
                    expect doc.get("sum").flatmap(|v| v.as_i64()) == Some(30)
                case Err(e):
                    fail("Failed to verify: ${e}")

            cleanup_file(path)

    context "error recovery":
        it "handles partial failures gracefully":
            val config = "a: 1\nb: 2\nc: 3"
            val path = create_test_file(config)

            match SdnDocument.from_file(path):
                case Ok(mut doc):
                    # Try valid update
                    match doc.set("a", SdnValue.Int(10)):
                        case Ok(_):
                            expect doc.is_modified() == True
                        case Err(e):
                            fail("Valid update failed: ${e}")

                    # Try invalid update (should fail)
                    match doc.set("nonexistent.nested", SdnValue.Int(20)):
                        case Ok(_):
                            fail("Invalid update should have failed")
                        case Err(_):
                            pass  # Expected

                    # Document should still have valid changes
                    expect doc.get("a").flatmap(|v| v.as_i64()) == Some(10)
                    expect doc.get("b").flatmap(|v| v.as_i64()) == Some(2)
                case Err(e):
                    fail("Failed to load: ${e}")

            cleanup_file(path)

        it "recovers from write failures":
            val config = "name: Alice"
            val path = create_test_file(config)

            match SdnDocument.from_file(path):
                case Ok(mut doc):
                    doc.set("name", SdnValue.String("Bob"))

                    # Try to write to invalid path
                    match doc.write_file("/invalid/path/file.sdn"):
                        case Ok(_):
                            fail("Should have failed")
                        case Err(_):
                            pass  # Expected

                    # Should still be able to write to valid path
                    match doc.write_file(path):
                        case Ok(_):
                            pass
                        case Err(e):
                            fail("Valid write failed: ${e}")
                case Err(e):
                    fail("Failed to load: ${e}")

            # Verify recovery
            match SdnDocument.from_file(path):
                case Ok(doc):
                    expect doc.get("name").flatmap(|v| v.as_str()) == Some("Bob")
                case Err(e):
                    fail("Failed to verify: ${e}")

            cleanup_file(path)

### Helper Functions

fn create_test_file(content: String) -> String:
    """Create temporary test file"""
    val temp_dir = "/tmp/sdn_workflow_test"
    fs.create_dir_all(temp_dir)

    val random_id = random.random_int(10000, 99999)
    val pid = process.pid()
    val file_path = "${temp_dir}/test_${pid}_${random_id}.sdn"

    match fs.write(file_path, content):
        case Ok(_):
            return file_path
        case Err(e):
            fail("Failed to create test file: ${e}")

fn cleanup_file(path: String):
    """Remove test file"""
    fs.remove(path)

fn json_to_sdn(json_value: json.Value) -> SdnValue:
    """Convert JSON value to SDN value"""
    match json_value:
        case json.Value.Null:
            return SdnValue.Null
        case json.Value.Bool(b):
            return SdnValue.Bool(b)
        case json.Value.Number(n):
            if n.floor() == n:
                return SdnValue.Int(n.to_i64())
            else:
                return SdnValue.Float(n)
        case json.Value.String(s):
            return SdnValue.String(s)
        case json.Value.Array(arr):
            var sdn_arr = []
            for item in arr:
                sdn_arr.push(json_to_sdn(item))
            return SdnValue.Array(sdn_arr)
        case json.Value.Object(obj):
            var sdn_dict = {}
            for (key, val) in obj.items():
                sdn_dict[key] = json_to_sdn(val)
            return SdnValue.Dict(sdn_dict)
