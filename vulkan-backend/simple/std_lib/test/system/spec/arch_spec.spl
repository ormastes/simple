/// Architecture Testing Framework Specification
/// Tests the layer-based dependency validation DSL
///
/// Features tested:
/// - #942: @arch_test decorator
/// - #943: Layer definition DSL
/// - Layer access rules
/// - No-mock-in-production check
/// - Skip-layer prevention

import spec.*

describe "Architecture Testing":
    context "Layer Definition":
        it "creates a layer with name and patterns":
            val layer = Layer.new("ui", ["src/ui/**", "src/controllers/**"])
            expect layer.name to eq "ui"
            expect layer.patterns to have_length 2

        it "checks if module matches layer patterns":
            val layer = Layer.new("ui", ["src/ui/**"])
            expect layer.contains("src/ui/view.spl") to be true
            expect layer.contains("src/services/auth.spl") to be false

        it "supports multiple glob patterns":
            val layer = Layer.new("presentation", ["src/ui/**", "src/controllers/**", "src/views/**"])
            expect layer.contains("src/ui/main.spl") to be true
            expect layer.contains("src/controllers/home.spl") to be true
            expect layer.contains("src/views/layout.spl") to be true
            expect layer.contains("src/models/user.spl") to be false

    context "LayerRef Builder":
        it "creates a layer reference for rule building":
            val ref = layer("presentation")
            expect ref.layer_name to eq "presentation"
            expect ref.rules to be_empty

        it "supports chaining may_only_access":
            val ref = layer("ui").may_only_access(["service"])
            expect ref.rules to have_length 1

        it "supports chaining may_not_access":
            val ref = layer("service").may_not_access(["ui"])
            expect ref.rules to have_length 1

        it "supports chaining multiple rules":
            val ref = layer("ui")
                .may_only_access(["service"])
                .may_not_access(["data"])
            expect ref.rules to have_length 2

    context "Architecture Definition":
        it "creates an empty architecture":
            val arch = Architecture.new()
            expect arch.layers to be_empty

        it "defines layers fluently":
            val arch = Architecture.new()
                .layer("ui", ["src/ui/**"])
                .layer("service", ["src/service/**"])
                .layer("data", ["src/data/**"])
            expect arch.layers to have_size 3

        it "finds layer containing a module":
            val arch = Architecture.new()
                .layer("ui", ["src/ui/**"])
                .layer("service", ["src/service/**"])

            expect arch.layer_of("src/ui/view.spl") to eq Some("ui")
            expect arch.layer_of("src/service/auth.spl") to eq Some("service")
            expect arch.layer_of("external/lib.spl") to eq None

    context "Access Rules - MayOnlyAccess":
        it "passes when layer only accesses allowed layers":
            val arch = Architecture.new()
                .layer("ui", ["src/ui/**"])
                .layer("service", ["src/service/**"])
            arch.dependencies = {
                "src/ui/view.spl": ["src/service/auth.spl"]
            }

            val rules = [AccessRule.MayOnlyAccess("ui", ["service"])]
            val result = arch.check_rules(rules)
            expect result.is_ok() to be true

        it "fails when layer accesses forbidden layer":
            val arch = Architecture.new()
                .layer("ui", ["src/ui/**"])
                .layer("service", ["src/service/**"])
                .layer("data", ["src/data/**"])
            arch.dependencies = {
                "src/ui/view.spl": ["src/data/repo.spl"]
            }

            val rules = [AccessRule.MayOnlyAccess("ui", ["service"])]
            val result = arch.check_rules(rules)
            expect result.is_ok() to be false
            expect result.violations() to have_length 1

    context "Access Rules - MayNotAccess":
        it "passes when layer does not access forbidden layers":
            val arch = Architecture.new()
                .layer("service", ["src/service/**"])
                .layer("ui", ["src/ui/**"])
            arch.dependencies = {
                "src/service/auth.spl": []
            }

            val rules = [AccessRule.MayNotAccess("service", ["ui"])]
            val result = arch.check_rules(rules)
            expect result.is_ok() to be true

        it "fails when layer accesses forbidden layer":
            val arch = Architecture.new()
                .layer("service", ["src/service/**"])
                .layer("ui", ["src/ui/**"])
            arch.dependencies = {
                "src/service/auth.spl": ["src/ui/view.spl"]
            }

            val rules = [AccessRule.MayNotAccess("service", ["ui"])]
            val result = arch.check_rules(rules)
            expect result.is_ok() to be false

    context "Access Rules - MayNotBeAccessedBy":
        it "passes when forbidden layers do not access target":
            val arch = Architecture.new()
                .layer("data", ["src/data/**"])
                .layer("ui", ["src/ui/**"])
            arch.dependencies = {
                "src/ui/view.spl": []
            }

            val rules = [AccessRule.MayNotBeAccessedBy("data", ["ui"])]
            val result = arch.check_rules(rules)
            expect result.is_ok() to be true

        it "fails when forbidden layer accesses target":
            val arch = Architecture.new()
                .layer("data", ["src/data/**"])
                .layer("ui", ["src/ui/**"])
            arch.dependencies = {
                "src/ui/view.spl": ["src/data/repo.spl"]
            }

            val rules = [AccessRule.MayNotBeAccessedBy("data", ["ui"])]
            val result = arch.check_rules(rules)
            expect result.is_ok() to be false

    context "No Mock in Production":
        it "passes when no mocks in production code":
            val arch = Architecture.new()
            arch.file_contents = {
                "src/service/auth.spl": "fn authenticate(user): ..."
            }
            current_arch = Some(arch)

            val result = no_mock_in_production(["src/**"])
            expect result.is_ok() to be true

            current_arch = None

        it "fails when mock annotation in production code":
            val arch = Architecture.new()
            arch.file_contents = {
                "src/service/auth.spl": "@mock\nfn authenticate(user): ..."
            }
            current_arch = Some(arch)

            val result = no_mock_in_production(["src/**"])
            expect result.is_ok() to be false
            expect result.violations()[0].rule to eq "NoMockInProduction"

            current_arch = None

        it "ignores mocks in test code":
            val arch = Architecture.new()
            arch.file_contents = {
                "src/service/auth.spl": "fn authenticate(user): ...",
                "test/service/auth_test.spl": "@mock\nfn mock_auth(): ..."
            }
            current_arch = Some(arch)

            # Only check src/ as production
            val result = no_mock_in_production(["src/**"])
            expect result.is_ok() to be true

            current_arch = None

    context "No Skip Layer":
        it "passes when layers are accessed in order":
            val arch = Architecture.new()
                .layer("ui", ["src/ui/**"])
                .layer("service", ["src/service/**"])
                .layer("data", ["src/data/**"])
            arch.dependencies = {
                "src/ui/view.spl": ["src/service/auth.spl"],
                "src/service/auth.spl": ["src/data/user.spl"]
            }
            current_arch = Some(arch)

            val result = no_skip_layer(["ui", "service", "data"])
            expect result.is_ok() to be true

            current_arch = None

        it "fails when layer is skipped":
            val arch = Architecture.new()
                .layer("ui", ["src/ui/**"])
                .layer("service", ["src/service/**"])
                .layer("data", ["src/data/**"])
            arch.dependencies = {
                "src/ui/view.spl": ["src/data/user.spl"]  # Skips service layer
            }
            current_arch = Some(arch)

            val result = no_skip_layer(["ui", "service", "data"])
            expect result.is_ok() to be false
            expect result.violations()[0].rule to eq "NoSkipLayer"

            current_arch = None

    context "ArchCheckResult":
        it "is_ok returns true for Pass":
            val result = ArchCheckResult.Pass
            expect result.is_ok() to be true

        it "is_ok returns false for Fail":
            val violations = [Violation {
                rule: "Test",
                message: "test violation",
                source: None,
                target: None
            }]
            val result = ArchCheckResult.Fail(violations)
            expect result.is_ok() to be false

        it "violations returns empty list for Pass":
            val result = ArchCheckResult.Pass
            expect result.violations() to be_empty

        it "violations returns list for Fail":
            val violations = [Violation {
                rule: "Test",
                message: "test",
                source: None,
                target: None
            }]
            val result = ArchCheckResult.Fail(violations)
            expect result.violations() to have_length 1

    context "Violation":
        it "formats violation message":
            val v = Violation {
                rule: "MayNotAccess",
                message: "forbidden access",
                source: Some("src/ui/view.spl"),
                target: Some("src/data/repo.spl")
            }
            val s = v.to_string()
            expect s to include "[MayNotAccess]"
            expect s to include "forbidden access"
            expect s to include "src/ui/view.spl"
            expect s to include "src/data/repo.spl"

    context "Integration - Layer Architecture Example":
        it "validates a typical layered architecture":
            # Setup typical 3-tier architecture
            val arch = Architecture.new()
                .layer("presentation", ["src/ui/**", "src/controllers/**"])
                .layer("business", ["src/services/**", "src/domain/**"])
                .layer("data", ["src/repos/**", "src/models/**"])

            # Define dependencies
            arch.dependencies = {
                "src/ui/view.spl": ["src/services/user_service.spl"],
                "src/controllers/home.spl": ["src/services/page_service.spl"],
                "src/services/user_service.spl": ["src/repos/user_repo.spl"],
                "src/repos/user_repo.spl": []
            }

            current_arch = Some(arch)

            # Verify layer rules
            val result1 = layer("presentation")
                .may_only_access(["business"])
                .check()
            expect result1.is_ok() to be true

            val result2 = layer("business")
                .may_not_access(["presentation"])
                .check()
            expect result2.is_ok() to be true

            val result3 = layer("data")
                .may_not_be_accessed_by(["presentation"])
                .check()
            expect result3.is_ok() to be true

            current_arch = None
