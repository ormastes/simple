# URL Unit Types
# Generic URLs and protocol-specific URL types

# Generic URL
unit Url: str as url

# Protocol-specific URLs
unit HttpUrl: str as http       # http:// or https://
unit FtpUrl: str as ftp         # ftp://
unit FileUrl: str as fileurl    # file://

# URL components
unit Scheme: str as scheme      # "http", "https", "ftp"
unit Host: str as host          # domain or IP
unit UrlPath: str as urlpath    # path component
unit Query: str as query        # query string (after ?)
unit Fragment: str as fragment  # fragment/anchor (after #)

# URL error type
enum UrlError:
    InvalidFormat
    InvalidScheme
    MissingHost
    InvalidPort
    InvalidPath
    InvalidQuery
    EmptyUrl

# Url implementation
impl Url:
    fn from_str(s: str) -> Result<Url, UrlError>:
        if s.is_empty():
            return Err(UrlError::EmptyUrl)
        # Basic validation: must have scheme://
        if not s.contains("://"):
            return Err(UrlError::InvalidFormat)
        return Ok(s_url)

    fn builder() -> UrlBuilder:
        return UrlBuilder::new()

    # Components
    fn scheme() -> Scheme:
        val s = self as str
        val sep = s.find("://").unwrap_or(0)
        return s.slice(0, sep)_scheme

    fn host() -> Option<Host>:
        val s = self as str
        val scheme_end = s.find("://").unwrap_or(0) + 3
        val rest = s.slice(scheme_end, s.len())

        # Skip userinfo if present
        val at = rest.find("@")
        val host_start = match at:
            case Some(idx): idx + 1
            case None: 0

        val host_part = rest.slice(host_start, rest.len())

        # Find end of host (before :port, /path, ?query, or #fragment)
        var end = host_part.len()
        for delim in [":", "/", "?", "#"]:
            match host_part.find(delim):
                case Some(idx):
                    if idx < end:
                        end = idx
                case None:
                    pass

        if end == 0:
            return None
        return Some(host_part.slice(0, end)_host)

    fn port() -> Option<Port>:
        val s = self as str
        val scheme_end = s.find("://").unwrap_or(0) + 3
        val rest = s.slice(scheme_end, s.len())

        # Find colon after host (not in userinfo)
        val at = rest.find("@").unwrap_or(0)
        val after_userinfo = rest.slice(at, rest.len())

        val colon = after_userinfo.find(":")
        match colon:
            case Some(idx):
                val port_start = idx + 1
                val after_colon = after_userinfo.slice(port_start, after_userinfo.len())

                # Find end of port (before /path, ?query, or #fragment)
                var end = after_colon.len()
                for delim in ["/", "?", "#"]:
                    match after_colon.find(delim):
                        case Some(i):
                            if i < end:
                                end = i
                        case None:
                            pass

                val port_str = after_colon.slice(0, end)
                match port_str.parse_u16():
                    case Ok(p): return Some(p_port)
                    case Err(_): return None
            case None:
                return None

    fn path() -> UrlPath:
        val s = self as str
        val scheme_end = s.find("://").unwrap_or(0) + 3
        val rest = s.slice(scheme_end, s.len())

        val path_start = rest.find("/").unwrap_or(rest.len())
        val after_path_start = rest.slice(path_start, rest.len())

        # Find end of path (before ?query or #fragment)
        val query = after_path_start.find("?")
        val frag = after_path_start.find("#")

        val end = match (query, frag):
            case (Some(q), Some(f)): if q < f then q else f
            case (Some(q), None): q
            case (None, Some(f)): f
            case (None, None): after_path_start.len()

        if end == 0:
            return "/"_urlpath
        return after_path_start.slice(0, end)_urlpath

    fn query() -> Option<Query>:
        val s = self as str
        val q = s.find("?")
        match q:
            case Some(idx):
                val after_q = s.slice(idx + 1, s.len())
                val frag = after_q.find("#").unwrap_or(after_q.len())
                val query_str = after_q.slice(0, frag)
                if query_str.is_empty():
                    return None
                return Some(query_str_query)
            case None:
                return None

    fn fragment() -> Option<Fragment>:
        val s = self as str
        val f = s.find("#")
        match f:
            case Some(idx):
                val frag_str = s.slice(idx + 1, s.len())
                if frag_str.is_empty():
                    return None
                return Some(frag_str_fragment)
            case None:
                return None

    fn username() -> Option<str>:
        val s = self as str
        val scheme_end = s.find("://").unwrap_or(0) + 3
        val rest = s.slice(scheme_end, s.len())

        val at = rest.find("@")
        match at:
            case Some(idx):
                val userinfo = rest.slice(0, idx)
                val colon = userinfo.find(":")
                match colon:
                    case Some(c): return Some(userinfo.slice(0, c))
                    case None: return Some(userinfo)
            case None:
                return None

    fn password() -> Option<str>:
        val s = self as str
        val scheme_end = s.find("://").unwrap_or(0) + 3
        val rest = s.slice(scheme_end, s.len())

        val at = rest.find("@")
        match at:
            case Some(idx):
                val userinfo = rest.slice(0, idx)
                val colon = userinfo.find(":")
                match colon:
                    case Some(c): return Some(userinfo.slice(c + 1, userinfo.len()))
                    case None: return None
            case None:
                return None

    # Operations
    fn join(path: UrlPath) -> Url:
        val s = self as str
        val p = path as str

        # Remove query and fragment from base
        val q = s.find("?").unwrap_or(s.len())
        val f = s.find("#").unwrap_or(s.len())
        val base_end = if q < f then q else f
        val base = s.slice(0, base_end)

        # Join path
        if p.starts_with("/"):
            # Absolute path - find host end
            val scheme_end = s.find("://").unwrap_or(0) + 3
            val rest = s.slice(scheme_end, base_end)
            val host_end = rest.find("/").unwrap_or(rest.len())
            return (s.slice(0, scheme_end + host_end) + p)_url
        else:
            # Relative path
            if base.ends_with("/"):
                return (base + p)_url
            return (base + "/" + p)_url

    fn with_query(query: Query) -> Url:
        val s = self as str
        val q = s.find("?").unwrap_or(s.len())
        val f = s.find("#").unwrap_or(s.len())
        val base = s.slice(0, if q < f then q else f)
        val frag = if f < s.len() then s.slice(f, s.len()) else ""
        return (base + "?" + (query as str) + frag)_url

    fn with_fragment(fragment: Fragment) -> Url:
        val s = self as str
        val f = s.find("#").unwrap_or(s.len())
        val base = s.slice(0, f)
        return (base + "#" + (fragment as str))_url

    fn as_str() -> &str:
        return &(self as str)

# UrlBuilder for constructing URLs
struct UrlBuilder:
    scheme: Option<Scheme>
    host: Option<Host>
    port: Option<Port>
    path: Option<UrlPath>
    query_params: Array<(str, str)>
    fragment: Option<Fragment>
    username: Option<str>
    password: Option<str>

impl UrlBuilder:
    static fn new() -> UrlBuilder:
        return UrlBuilder {
            scheme: None,
            host: None,
            port: None,
            path: None,
            query_params: [],
            fragment: None,
            username: None,
            password: None
        }

    fn scheme(s: Scheme) -> UrlBuilder:
        self.scheme = Some(s)
        return self

    fn host(h: Host) -> UrlBuilder:
        self.host = Some(h)
        return self

    fn port(p: Port) -> UrlBuilder:
        self.port = Some(p)
        return self

    fn path(p: UrlPath) -> UrlBuilder:
        self.path = Some(p)
        return self

    fn query_param(key: str, value: str) -> UrlBuilder:
        self.query_params.push((key, value))
        return self

    fn fragment(f: Fragment) -> UrlBuilder:
        self.fragment = Some(f)
        return self

    fn auth(username: str, password: str) -> UrlBuilder:
        self.username = Some(username)
        self.password = Some(password)
        return self

    fn build() -> Result<Url, UrlError>:
        val scheme = match self.scheme:
            case Some(s): s as str
            case None: return Err(UrlError::InvalidScheme)

        val host = match self.host:
            case Some(h): h as str
            case None: return Err(UrlError::MissingHost)

        var url = scheme + "://"

        # Add userinfo
        match (self.username, self.password):
            case (Some(u), Some(p)):
                url = url + u + ":" + p + "@"
            case (Some(u), None):
                url = url + u + "@"
            case _:
                pass

        url = url + host

        # Add port
        match self.port:
            case Some(p):
                url = url + ":" + (p as u16).to_str()
            case None:
                pass

        # Add path
        match self.path:
            case Some(p):
                val path_str = p as str
                if not path_str.starts_with("/"):
                    url = url + "/"
                url = url + path_str
            case None:
                url = url + "/"

        # Add query
        if self.query_params.len() > 0:
            url = url + "?"
            var first = true
            for (k, v) in self.query_params:
                if not first:
                    url = url + "&"
                url = url + k + "=" + v
                first = false

        # Add fragment
        match self.fragment:
            case Some(f):
                url = url + "#" + (f as str)
            case None:
                pass

        return Ok(url_url)

# HttpUrl implementation
impl HttpUrl:
    fn from_str(s: str) -> Result<HttpUrl, UrlError>:
        if not (s.starts_with("http://") or s.starts_with("https://")):
            return Err(UrlError::InvalidScheme)
        return Ok(s_http)

    fn is_secure() -> bool:
        return (self as str).starts_with("https://")

    fn to_url() -> Url:
        return (self as str)_url

    fn host() -> Option<Host>:
        return self.to_url().host()

    fn port() -> Port:
        match self.to_url().port():
            case Some(p): return p
            case None:
                if self.is_secure():
                    return 443_port
                return 80_port

    fn path() -> UrlPath:
        return self.to_url().path()

# FtpUrl implementation
impl FtpUrl:
    fn from_str(s: str) -> Result<FtpUrl, UrlError>:
        if not s.starts_with("ftp://"):
            return Err(UrlError::InvalidScheme)
        return Ok(s_ftp)

    fn to_url() -> Url:
        return (self as str)_url

    fn host() -> Host:
        return self.to_url().host().unwrap_or("localhost"_host)

    fn port() -> Port:
        return self.to_url().port().unwrap_or(21_port)

    fn path() -> UrlPath:
        return self.to_url().path()

    fn username() -> Option<str>:
        return self.to_url().username()

    fn password() -> Option<str>:
        return self.to_url().password()

# FileUrl implementation
impl FileUrl:
    fn from_str(s: str) -> Result<FileUrl, UrlError>:
        if not s.starts_with("file://"):
            return Err(UrlError::InvalidScheme)
        return Ok(s_fileurl)

    fn to_file_path() -> FilePath:
        val s = self as str
        # Remove file:// prefix
        val path = s.slice(7, s.len())
        # Handle localhost: file://localhost/path -> /path
        if path.starts_with("localhost"):
            return path.slice(9, path.len())_file
        return path_file

    fn from_file_path(path: FilePath) -> FileUrl:
        val p = path as str
        return ("file://" + p)_fileurl

# Host implementation
impl Host:
    fn from_str(s: str) -> Result<Host, UrlError>:
        if s.is_empty():
            return Err(UrlError::MissingHost)
        return Ok(s_host)

    fn is_ip() -> bool:
        val s = self as str
        # Simple check: contains dots and digits only (IPv4) or colons (IPv6)
        return s.contains(".") or s.contains(":")

    fn is_domain() -> bool:
        return not self.is_ip()

    fn to_ip() -> Option<IpAddr>:
        if self.is_ip():
            return Some((self as str)_ip)
        return None

# Scheme implementation
impl Scheme:
    fn http() -> Scheme:
        return "http"_scheme

    fn https() -> Scheme:
        return "https"_scheme

    fn ftp() -> Scheme:
        return "ftp"_scheme

    fn file() -> Scheme:
        return "file"_scheme

    fn is_secure() -> bool:
        val s = self as str
        return s == "https" or s == "ftps" or s == "sftp"

    fn default_port() -> Option<Port>:
        match self as str:
            case "http": return Some(80_port)
            case "https": return Some(443_port)
            case "ftp": return Some(21_port)
            case "ssh": return Some(22_port)
            case "sftp": return Some(22_port)
            case _: return None
