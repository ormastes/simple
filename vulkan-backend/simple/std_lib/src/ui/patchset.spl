# PatchSet - Structural UI Update Operations
#
# This module defines patch operations for reactive UI updates.
# Rather than re-rendering the entire UI, patches describe minimal
# changes needed to update the view.

use core.*
use ui.element.*
use ui.attrs.*

# A patch operation to apply to the UI tree
pub enum PatchOp:
    # Text/content updates
    SetText {
        node_id: NodeId
        text: String
    }

    # Attribute updates
    SetAttr {
        node_id: NodeId
        name: String
        value: String
    }
    RemoveAttr {
        node_id: NodeId
        name: String
    }

    # Class updates
    AddClass {
        node_id: NodeId
        class: String
    }
    RemoveClass {
        node_id: NodeId
        class: String
    }

    # Style updates
    SetStyle {
        node_id: NodeId
        property: String
        value: String
    }
    RemoveStyle {
        node_id: NodeId
        property: String
    }

    # Child manipulation
    InsertChild {
        parent_id: NodeId
        index: u64
        element: Element
    }
    RemoveChild {
        parent_id: NodeId
        child_id: NodeId
    }
    ReplaceChild {
        parent_id: NodeId
        old_id: NodeId
        element: Element
    }
    MoveChild {
        parent_id: NodeId
        child_id: NodeId
        from_index: u64
        to_index: u64
    }

    # Full subtree replacement
    ReplaceSubtree {
        node_id: NodeId
        element: Element
    }

    # Focus changes
    SetFocus {
        node_id: NodeId
    }
    ClearFocus {
        node_id: NodeId
    }

    # Event binding
    BindEvent {
        node_id: NodeId
        event: String
        handler_id: u64
    }
    UnbindEvent {
        node_id: NodeId
        event: String
    }

impl PatchOp:
    # Get the target node ID for this patch
    pub fn target_id(self) -> NodeId:
        match self:
            case SetText { node_id, .. }: return node_id
            case SetAttr { node_id, .. }: return node_id
            case RemoveAttr { node_id, .. }: return node_id
            case AddClass { node_id, .. }: return node_id
            case RemoveClass { node_id, .. }: return node_id
            case SetStyle { node_id, .. }: return node_id
            case RemoveStyle { node_id, .. }: return node_id
            case InsertChild { parent_id, .. }: return parent_id
            case RemoveChild { parent_id, .. }: return parent_id
            case ReplaceChild { parent_id, .. }: return parent_id
            case MoveChild { parent_id, .. }: return parent_id
            case ReplaceSubtree { node_id, .. }: return node_id
            case SetFocus { node_id }: return node_id
            case ClearFocus { node_id }: return node_id
            case BindEvent { node_id, .. }: return node_id
            case UnbindEvent { node_id, .. }: return node_id

    # Check if this patch modifies children
    pub fn is_structural(self) -> bool:
        match self:
            case InsertChild { .. } | RemoveChild { .. } | ReplaceChild { .. }:
                return true
            case MoveChild { .. } | ReplaceSubtree { .. }:
                return true
            case _:
                return false

# A set of patches to apply atomically
pub struct PatchSet:
    patches: Array[PatchOp]

impl PatchSet:
    # Create an empty patch set
    pub fn new() -> PatchSet:
        return PatchSet { patches: [] }

    # Add a patch operation
    pub fn add(self, op: PatchOp):
        self.patches.push(op)

    # Add multiple operations
    pub fn extend(self, ops: Array[PatchOp]):
        for op in ops:
            self.patches.push(op)

    # Get number of patches
    pub fn len(self) -> u64:
        return self.patches.len()

    # Check if empty
    pub fn is_empty(self) -> bool:
        return self.patches.is_empty()

    # Iterate over patches
    pub fn iter(self) -> &Array[PatchOp]:
        return &self.patches

    # Clear all patches
    pub fn clear(self):
        self.patches.clear()

    # Helper: add text update
    pub fn set_text(self, node_id: NodeId, text: &str):
        self.add(PatchOp::SetText {
            node_id: node_id,
            text: text.to_string()
        })

    # Helper: add attribute update
    pub fn set_attr(self, node_id: NodeId, name: &str, value: &str):
        self.add(PatchOp::SetAttr {
            node_id: node_id,
            name: name.to_string(),
            value: value.to_string()
        })

    # Helper: remove attribute
    pub fn remove_attr(self, node_id: NodeId, name: &str):
        self.add(PatchOp::RemoveAttr {
            node_id: node_id,
            name: name.to_string()
        })

    # Helper: add class
    pub fn add_class(self, node_id: NodeId, class: &str):
        self.add(PatchOp::AddClass {
            node_id: node_id,
            class: class.to_string()
        })

    # Helper: remove class
    pub fn remove_class(self, node_id: NodeId, class: &str):
        self.add(PatchOp::RemoveClass {
            node_id: node_id,
            class: class.to_string()
        })

    # Helper: insert child
    pub fn insert_child(self, parent_id: NodeId, index: u64, element: Element):
        self.add(PatchOp::InsertChild {
            parent_id: parent_id,
            index: index,
            element: element
        })

    # Helper: remove child
    pub fn remove_child(self, parent_id: NodeId, child_id: NodeId):
        self.add(PatchOp::RemoveChild {
            parent_id: parent_id,
            child_id: child_id
        })

    # Helper: replace subtree
    pub fn replace(self, node_id: NodeId, element: Element):
        self.add(PatchOp::ReplaceSubtree {
            node_id: node_id,
            element: element
        })

    # Helper: move child
    pub fn move_child(self, parent_id: NodeId, child_id: NodeId, from: u64, to: u64):
        self.add(PatchOp::MoveChild {
            parent_id: parent_id,
            child_id: child_id,
            from_index: from,
            to_index: to
        })

    # Helper: set focus
    pub fn focus(self, node_id: NodeId):
        self.add(PatchOp::SetFocus { node_id: node_id })

    # Helper: bind event
    pub fn bind_event(self, node_id: NodeId, event: &str, handler_id: u64):
        self.add(PatchOp::BindEvent {
            node_id: node_id,
            event: event.to_string(),
            handler_id: handler_id
        })

    # Optimize the patch set by merging/eliminating redundant operations
    pub fn optimize(self) -> PatchSet:
        # Track latest operations per node
        var text_ops: Dict[u64, PatchOp] = Dict::new()
        var attr_ops: Dict[String, PatchOp] = Dict::new()
        var class_ops: Dict[String, PatchOp] = Dict::new()
        var structural_ops: Array[PatchOp] = []

        for op in &self.patches:
            val target = op.target_id().value()
            match op:
                case SetText { node_id, text }:
                    # Only keep latest text update per node
                    text_ops.set(target, op)
                case SetAttr { node_id, name, value }:
                    val key = f"{target}:{name}"
                    attr_ops.set(key, op)
                case RemoveAttr { node_id, name }:
                    val key = f"{target}:{name}"
                    # Remove any pending SetAttr
                    attr_ops.remove(&key)
                    attr_ops.set(key, op)
                case AddClass { node_id, class }:
                    val key = f"{target}:{class}"
                    class_ops.set(key, op)
                case RemoveClass { node_id, class }:
                    val key = f"{target}:{class}"
                    # Remove any pending AddClass
                    class_ops.remove(&key)
                    class_ops.set(key, op)
                case _:
                    # Keep structural ops in order
                    structural_ops.push(op)

        # Build optimized patch set
        var result = PatchSet::new()

        # Add structural ops first (order matters)
        for op in structural_ops:
            result.add(op)

        # Add text ops
        for (_, op) in text_ops:
            result.add(op)

        # Add attr ops
        for (_, op) in attr_ops:
            result.add(op)

        # Add class ops
        for (_, op) in class_ops:
            result.add(op)

        return result
