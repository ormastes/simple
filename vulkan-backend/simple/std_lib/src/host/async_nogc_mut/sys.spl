# System module - Process control and standard streams
# Provides access to stdin, stdout, stderr, arguments, and process control

import host.io.term

# Standard output stream
pub class Stdout:
    term: term.Terminal

    pub fn new() -> Stdout:
        return Stdout { term: term.Terminal.default() }

    @io
    pub fn write(self, s: String) -> Result<Int, String>:
        match self.term.write(s):
            case Ok(count):
                return Ok(count.bytes as Int)
            case Err(e):
                return Err(f"Write error: {e}")

    @io
    pub fn flush(self) -> Result<(), String>:
        match self.term.flush():
            case Ok(_):
                return Ok(())
            case Err(e):
                return Err(f"Flush error: {e}")

# Standard error stream
pub class Stderr:
    term: term.Terminal

    pub fn new() -> Stderr:
        return Stderr { term: term.Terminal.default() }

    @io
    pub fn write(self, s: String) -> Result<Int, String>:
        match self.term.write_err(s):
            case Ok(count):
                return Ok(count.bytes as Int)
            case Err(e):
                return Err(f"Write error: {e}")

# Command line arguments
pub class Args:
    @pure
    pub fn get_args() -> List<String>:
        # TODO: Get actual command line arguments
        # For now, return empty list
        return []

# Global stdout instance
pub val stdout: Stdout = Stdout.new()

# Global stderr instance
pub val stderr: Stderr = Stderr.new()

# Global args instance
pub val args: Args = Args.new()

# Exit the process with the given code
@io
pub fn exit(code: Int) -> Never:
    # TODO: Call actual process exit
    # For now, this is a placeholder
    loop:
        pass
