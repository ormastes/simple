# Buffered I/O - Buffered readers and writers

use units.size.*
use io.fs.*

# Default buffer size
const DEFAULT_BUF_SIZE: u64 = 8192

# Buffered reader
struct BufReader:
    inner: File
    buffer: Bytes
    pos: u64
    cap: u64

impl BufReader:
    fn new(file: File) -> BufReader:
        return BufReader::with_capacity(file, DEFAULT_BUF_SIZE)

    fn with_capacity(file: File, capacity: u64) -> BufReader:
        return BufReader {
            inner: file,
            buffer: Bytes::with_capacity(capacity),
            pos: 0,
            cap: 0
        }

    # Fill buffer from underlying reader
    async fn fill_buf(self) -> Result[&Bytes, IoError]:
        if self.pos >= self.cap:
            self.cap = (await self.inner.read(&mut self.buffer)?) as u64
            self.pos = 0
        return Ok(&self.buffer.slice(self.pos, self.cap))

    # Consume n bytes from buffer
    fn consume(n: u64):
        self.pos = self.pos + n.min(self.cap - self.pos)

    # Read into buffer
    pub async fn read(self, buf: &mut Bytes) -> Result[ByteCount, IoError]:
        # If buffer is empty, read directly for large requests
        if self.pos == self.cap and buf.len() >= self.buffer.capacity():
            return self.inner.read(buf)

        # Otherwise use buffered read
        val available = await self.fill_buf()?
        val to_copy = available.len().min(buf.len())
        buf.copy_from(available, 0, to_copy)
        self.consume(to_copy)
        return Ok(to_copy_bytes)

    # Read line (until newline or EOF)
    pub async fn read_line(self) -> Result[Text, IoError]:
        var result = ""
        loop:
            val available = await self.fill_buf()?
            if available.len() == 0:
                break

            val newline = available.find_byte('\n' as u8)
            match newline:
                case Some(idx):
                    result = result + available.slice(0, idx + 1).to_utf8().unwrap_or("")
                    self.consume(idx + 1)
                    break
                case None:
                    result = result + available.to_utf8().unwrap_or("")
                    self.consume(available.len())

        return Ok(result_text)

    # Read all lines
    pub async fn lines(self) -> Result[Array[Text], IoError]:
        var lines: Array[Text] = []
        loop:
            val line = await self.read_line()?
            if (line as str).is_empty():
                break
            lines.push(line)
        return Ok(lines)

    # Get underlying file
    fn into_inner() -> File:
        return self.inner

# Buffered writer
struct BufWriter:
    inner: File
    buffer: Bytes
    pos: u64

impl BufWriter:
    fn new(file: File) -> BufWriter:
        return BufWriter::with_capacity(file, DEFAULT_BUF_SIZE)

    fn with_capacity(file: File, capacity: u64) -> BufWriter:
        return BufWriter {
            inner: file,
            buffer: Bytes::with_capacity(capacity),
            pos: 0
        }

    # Flush buffer to underlying writer
    pub async fn flush(self) -> Result[(), IoError]:
        if self.pos > 0:
            await self.inner.write_all(&self.buffer.slice(0, self.pos))?
            self.pos = 0
        return self.inner.flush()

    # Write data
    pub async fn write(self, data: &Bytes) -> Result[ByteCount, IoError]:
        # If data is larger than buffer, flush and write directly
        if data.len() >= self.buffer.capacity():
            await self.flush()?
            return self.inner.write(data)

        # If data would overflow buffer, flush first
        if self.pos + data.len() > self.buffer.capacity():
            await self.flush()?

        # Copy to buffer
        self.buffer.copy_from(data, self.pos, data.len())
        self.pos = self.pos + data.len()
        return Ok(data.len()_bytes)

    # Write all data
    pub async fn write_all(self, data: &Bytes) -> Result[(), IoError]:
        var written: u64 = 0
        while written < data.len():
            val n = await self.write(&data.slice(written, data.len()))?
            written = written + (n as u64)
        return Ok(())

    # Write line (with newline)
    pub async fn write_line(self, text: &Text) -> Result[ByteCount, IoError]:
        val bytes = (text as str).to_bytes()
        val n1 = await self.write(&bytes)?
        val n2 = await self.write(&"\n".to_bytes())?
        return Ok(((n1 as u64) + (n2 as u64))_bytes)

    # Get underlying file
    async fn into_inner(self) -> Result[File, IoError]:
        await self.flush()?
        return Ok(self.inner)

# Line writer - buffers until newline
struct LineWriter:
    inner: BufWriter

impl LineWriter:
    fn new(file: File) -> LineWriter:
        return LineWriter { inner: BufWriter::new(file) }

    pub async fn write(self, data: &Bytes) -> Result[ByteCount, IoError]:
        val n = await self.inner.write(data)?

        # Flush if we wrote a newline
        if data.contains_byte('\n' as u8):
            await self.inner.flush()?

        return Ok(n)

    pub async fn flush(self) -> Result[(), IoError]:
        return self.inner.flush()
