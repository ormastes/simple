# Terminal Styling - ANSI colors, styles, and formatting
# Cross-platform terminal text formatting

# ANSI color codes
pub enum Color:
    Black
    Red
    Green
    Yellow
    Blue
    Magenta
    Cyan
    White
    BrightBlack
    BrightRed
    BrightGreen
    BrightYellow
    BrightBlue
    BrightMagenta
    BrightCyan
    BrightWhite
    Rgb(u8, u8, u8)
    Ansi256(u8)

impl Color:
    # Get ANSI foreground code
    pub fn fg_code(self) -> u8:
        match self:
            case Black: return 30
            case Red: return 31
            case Green: return 32
            case Yellow: return 33
            case Blue: return 34
            case Magenta: return 35
            case Cyan: return 36
            case White: return 37
            case BrightBlack: return 90
            case BrightRed: return 91
            case BrightGreen: return 92
            case BrightYellow: return 93
            case BrightBlue: return 94
            case BrightMagenta: return 95
            case BrightCyan: return 96
            case BrightWhite: return 97
            case Rgb(_, _, _): return 38
            case Ansi256(_): return 38

    # Get ANSI background code
    pub fn bg_code(self) -> u8:
        match self:
            case Black: return 40
            case Red: return 41
            case Green: return 42
            case Yellow: return 43
            case Blue: return 44
            case Magenta: return 45
            case Cyan: return 46
            case White: return 47
            case BrightBlack: return 100
            case BrightRed: return 101
            case BrightGreen: return 102
            case BrightYellow: return 103
            case BrightBlue: return 104
            case BrightMagenta: return 105
            case BrightCyan: return 106
            case BrightWhite: return 107
            case Rgb(_, _, _): return 48
            case Ansi256(_): return 48

# Text style attributes
pub struct Style:
    fg: Option<Color>
    bg: Option<Color>
    bold: bool
    dim: bool
    italic: bool
    underline: bool
    blink: bool
    reverse: bool
    hidden: bool
    strikethrough: bool

impl Style:
    # Create default style (no formatting)
    pub fn new() -> Style:
        return Style {
            fg: None,
            bg: None,
            bold: false,
            dim: false,
            italic: false,
            underline: false,
            blink: false,
            reverse: false,
            hidden: false,
            strikethrough: false
        }

    # Set foreground color
    pub fn fg(self, color: Color) -> Style:
        self.fg = Some(color)
        return self

    # Set background color
    pub fn bg(self, color: Color) -> Style:
        self.bg = Some(color)
        return self

    # Enable bold
    pub fn bold(self) -> Style:
        self.bold = true
        return self

    # Enable dim
    pub fn dim(self) -> Style:
        self.dim = true
        return self

    # Enable italic
    pub fn italic(self) -> Style:
        self.italic = true
        return self

    # Enable underline
    pub fn underline(self) -> Style:
        self.underline = true
        return self

    # Enable blink
    pub fn blink(self) -> Style:
        self.blink = true
        return self

    # Enable reverse video
    pub fn reverse(self) -> Style:
        self.reverse = true
        return self

    # Enable hidden
    pub fn hidden(self) -> Style:
        self.hidden = true
        return self

    # Enable strikethrough
    pub fn strikethrough(self) -> Style:
        self.strikethrough = true
        return self

    # Generate ANSI escape sequence
    pub fn to_ansi(self) -> String:
        var codes: Array<String> = []

        if self.bold:
            codes.push("1")
        if self.dim:
            codes.push("2")
        if self.italic:
            codes.push("3")
        if self.underline:
            codes.push("4")
        if self.blink:
            codes.push("5")
        if self.reverse:
            codes.push("7")
        if self.hidden:
            codes.push("8")
        if self.strikethrough:
            codes.push("9")

        match self.fg:
            case Some(color):
                match color:
                    case Rgb(r, g, b):
                        codes.push(f"38;2;{r};{g};{b}")
                    case Ansi256(n):
                        codes.push(f"38;5;{n}")
                    case _:
                        codes.push(f"{color.fg_code()}")
            case None: pass

        match self.bg:
            case Some(color):
                match color:
                    case Rgb(r, g, b):
                        codes.push(f"48;2;{r};{g};{b}")
                    case Ansi256(n):
                        codes.push(f"48;5;{n}")
                    case _:
                        codes.push(f"{color.bg_code()}")
            case None: pass

        if codes.is_empty():
            return ""

        return f"\x1b[{codes.join(';')}m"

    # Apply style to text and return styled string
    pub fn apply(self, text: &str) -> String:
        val prefix = self.to_ansi()
        if prefix.is_empty():
            return text.to_string()
        return f"{prefix}{text}\x1b[0m"

# Reset all formatting
pub fn reset() -> String:
    return "\x1b[0m"

# Convenience functions for common styles
pub fn red(text: &str) -> String:
    return Style::new().fg(Color::Red).apply(text)

pub fn green(text: &str) -> String:
    return Style::new().fg(Color::Green).apply(text)

pub fn yellow(text: &str) -> String:
    return Style::new().fg(Color::Yellow).apply(text)

pub fn blue(text: &str) -> String:
    return Style::new().fg(Color::Blue).apply(text)

pub fn magenta(text: &str) -> String:
    return Style::new().fg(Color::Magenta).apply(text)

pub fn cyan(text: &str) -> String:
    return Style::new().fg(Color::Cyan).apply(text)

pub fn white(text: &str) -> String:
    return Style::new().fg(Color::White).apply(text)

pub fn bold(text: &str) -> String:
    return Style::new().bold().apply(text)

pub fn dim(text: &str) -> String:
    return Style::new().dim().apply(text)

pub fn italic(text: &str) -> String:
    return Style::new().italic().apply(text)

pub fn underline(text: &str) -> String:
    return Style::new().underline().apply(text)

pub fn strikethrough(text: &str) -> String:
    return Style::new().strikethrough().apply(text)

# Error styling (red + bold)
pub fn error(text: &str) -> String:
    return Style::new().fg(Color::Red).bold().apply(text)

# Warning styling (yellow + bold)
pub fn warning(text: &str) -> String:
    return Style::new().fg(Color::Yellow).bold().apply(text)

# Success styling (green + bold)
pub fn success(text: &str) -> String:
    return Style::new().fg(Color::Green).bold().apply(text)

# Info styling (cyan)
pub fn info(text: &str) -> String:
    return Style::new().fg(Color::Cyan).apply(text)

# Styled string builder for complex formatting
pub struct StyledString:
    parts: Array<String>

impl StyledString:
    pub fn new() -> StyledString:
        return StyledString { parts: [] }

    pub fn push(self, text: &str) -> &mut StyledString:
        self.parts.push(text.to_string())
        return self

    pub fn push_styled(self, text: &str, style: Style) -> &mut StyledString:
        self.parts.push(style.apply(text))
        return self

    pub fn red(self, text: &str) -> &mut StyledString:
        return self.push_styled(text, Style::new().fg(Color::Red))

    pub fn green(self, text: &str) -> &mut StyledString:
        return self.push_styled(text, Style::new().fg(Color::Green))

    pub fn yellow(self, text: &str) -> &mut StyledString:
        return self.push_styled(text, Style::new().fg(Color::Yellow))

    pub fn blue(self, text: &str) -> &mut StyledString:
        return self.push_styled(text, Style::new().fg(Color::Blue))

    pub fn cyan(self, text: &str) -> &mut StyledString:
        return self.push_styled(text, Style::new().fg(Color::Cyan))

    pub fn bold(self, text: &str) -> &mut StyledString:
        return self.push_styled(text, Style::new().bold())

    pub fn to_string(self) -> String:
        return self.parts.join("")

# Progress bar styling
pub struct ProgressStyle:
    filled: char
    empty: char
    left_bracket: char
    right_bracket: char
    width: u16

impl ProgressStyle:
    pub fn default() -> ProgressStyle:
        return ProgressStyle {
            filled: '#',
            empty: '-',
            left_bracket: '[',
            right_bracket: ']',
            width: 40
        }

    pub fn unicode() -> ProgressStyle:
        return ProgressStyle {
            filled: '\u2588',  # Full block
            empty: '\u2591',   # Light shade
            left_bracket: '\u2595',  # Right one eighth block
            right_bracket: '\u258F', # Left one eighth block
            width: 40
        }

    pub fn render(self, progress: f64) -> String:
        val clamped = progress.clamp(0.0, 1.0)
        val filled_count = ((clamped * (self.width as f64)) as u16)
        val empty_count = self.width - filled_count

        var result = String::new()
        result.push(self.left_bracket)

        for _ in 0..filled_count:
            result.push(self.filled)
        for _ in 0..empty_count:
            result.push(self.empty)

        result.push(self.right_bracket)
        return result

    pub fn render_with_percent(self, progress: f64) -> String:
        val bar = self.render(progress)
        val percent = ((progress * 100.0) as i32)
        return f"{bar} {percent}%"

# Spinner animation frames
pub struct Spinner:
    frames: Array<&str>
    current: u64

impl Spinner:
    pub fn dots() -> Spinner:
        return Spinner {
            frames: [".", "..", "...", ".."],
            current: 0
        }

    pub fn line() -> Spinner:
        return Spinner {
            frames: ["-", "\\", "|", "/"],
            current: 0
        }

    pub fn braille() -> Spinner:
        return Spinner {
            frames: ["\u2801", "\u2802", "\u2804", "\u2840", "\u2880", "\u2820", "\u2810", "\u2808"],
            current: 0
        }

    pub fn next(self) -> &str:
        val frame = self.frames[self.current]
        self.current = (self.current + 1) % self.frames.len()
        return frame

    pub fn reset(self):
        self.current = 0

# Box drawing characters for TUI
pub struct BoxChars:
    top_left: char
    top_right: char
    bottom_left: char
    bottom_right: char
    horizontal: char
    vertical: char
    t_down: char
    t_up: char
    t_right: char
    t_left: char
    cross: char

impl BoxChars:
    pub fn ascii() -> BoxChars:
        return BoxChars {
            top_left: '+',
            top_right: '+',
            bottom_left: '+',
            bottom_right: '+',
            horizontal: '-',
            vertical: '|',
            t_down: '+',
            t_up: '+',
            t_right: '+',
            t_left: '+',
            cross: '+'
        }

    pub fn single() -> BoxChars:
        return BoxChars {
            top_left: '\u250C',
            top_right: '\u2510',
            bottom_left: '\u2514',
            bottom_right: '\u2518',
            horizontal: '\u2500',
            vertical: '\u2502',
            t_down: '\u252C',
            t_up: '\u2534',
            t_right: '\u251C',
            t_left: '\u2524',
            cross: '\u253C'
        }

    pub fn double() -> BoxChars:
        return BoxChars {
            top_left: '\u2554',
            top_right: '\u2557',
            bottom_left: '\u255A',
            bottom_right: '\u255D',
            horizontal: '\u2550',
            vertical: '\u2551',
            t_down: '\u2566',
            t_up: '\u2569',
            t_right: '\u2560',
            t_left: '\u2563',
            cross: '\u256C'
        }

    pub fn rounded() -> BoxChars:
        return BoxChars {
            top_left: '\u256D',
            top_right: '\u256E',
            bottom_left: '\u2570',
            bottom_right: '\u256F',
            horizontal: '\u2500',
            vertical: '\u2502',
            t_down: '\u252C',
            t_up: '\u2534',
            t_right: '\u251C',
            t_left: '\u2524',
            cross: '\u253C'
        }

    # Draw a horizontal line
    pub fn h_line(self, width: u16) -> String:
        var s = String::new()
        for _ in 0..width:
            s.push(self.horizontal)
        return s

    # Draw a vertical line
    pub fn v_line(self, height: u16) -> String:
        var lines: Array<String> = []
        for _ in 0..height:
            lines.push(self.vertical.to_string())
        return lines.join("\n")

    # Draw a box
    pub fn box_frame(self, width: u16, height: u16) -> String:
        val inner_width = width - 2
        var lines: Array<String> = []

        # Top border
        var top = String::new()
        top.push(self.top_left)
        top.push_str(&self.h_line(inner_width))
        top.push(self.top_right)
        lines.push(top)

        # Middle rows
        for _ in 1..(height - 1):
            var mid = String::new()
            mid.push(self.vertical)
            for _ in 0..inner_width:
                mid.push(' ')
            mid.push(self.vertical)
            lines.push(mid)

        # Bottom border
        var bottom = String::new()
        bottom.push(self.bottom_left)
        bottom.push_str(&self.h_line(inner_width))
        bottom.push(self.bottom_right)
        lines.push(bottom)

        return lines.join("\n")
