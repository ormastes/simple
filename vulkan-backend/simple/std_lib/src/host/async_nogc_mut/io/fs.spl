# File System API - Async file operations (Mutable Variant)
# All functions use semantic types - no bare strings!

use units.file.*
use units.size.*
use units.time.*
use host.common.io.error.IoError
use host.common.io.types.*
use core.traits.*

# Directory entries iterator (mutable variant)
struct DirEntries:
    entries: Array<DirEntry>
    index: u64

impl DirEntries:
    fn next() -> Option<DirEntry>:
        if self.index >= self.entries.len():
            return None
        val entry = self.entries[self.index]
        self.index = self.index + 1
        return Some(entry)

# ===============================
# File System Operations
# ===============================

# Read entire file as bytes
pub async fn read(path: FilePath) -> Result<Bytes, IoError>:
    return native_fs_read(path)

# Read entire file as text (UTF-8)
pub async fn read_text(path: FilePath) -> Result<Text, IoError>:
    val bytes = await read(path)?
    match bytes.to_utf8():
        case Ok(s): return Ok(s_text)
        case Err(_): return Err(IoError::InvalidData)

# Write bytes to file (creates or overwrites)
pub async fn write(path: FilePath, data: &Bytes) -> Result<ByteCount, IoError>:
    return native_fs_write(path, data)

# Write text to file (UTF-8)
pub async fn write_text(path: FilePath, text: &Text) -> Result<ByteCount, IoError>:
    val bytes = (text as str).to_bytes()
    return await write(path, &bytes)

# Append bytes to file
pub async fn append(path: FilePath, data: &Bytes) -> Result<ByteCount, IoError>:
    return native_fs_append(path, data)

# Append text to file
pub async fn append_text(path: FilePath, text: &Text) -> Result<ByteCount, IoError>:
    val bytes = (text as str).to_bytes()
    return await append(path, &bytes)

# ===============================
# Directory Operations
# ===============================

# Create directory
pub async fn create_dir(path: DirPath) -> Result<(), IoError>:
    return native_fs_create_dir(path, false)

# Create directory and all parent directories
pub async fn create_dir_all(path: DirPath) -> Result<(), IoError>:
    return native_fs_create_dir(path, true)

# Remove file
pub async fn remove(path: FilePath) -> Result<(), IoError>:
    return native_fs_remove_file(path)

# Remove empty directory
pub async fn remove_dir(path: DirPath) -> Result<(), IoError>:
    return native_fs_remove_dir(path, false)

# Remove directory and all contents
pub async fn remove_dir_all(path: DirPath) -> Result<(), IoError>:
    return native_fs_remove_dir(path, true)

# Rename file or directory
pub async fn rename(src: FilePath, dst: FilePath) -> Result<(), IoError>:
    return native_fs_rename(src, dst)

# Copy file
pub async fn copy(src: FilePath, dst: FilePath) -> Result<ByteCount, IoError>:
    return native_fs_copy(src, dst)

# ===============================
# Metadata Operations
# ===============================

# Check if path exists
pub async fn exists(path: FilePath) -> bool:
    match native_fs_metadata(path):
        case Ok(_): return true
        case Err(_): return false

# Get file metadata
pub async fn metadata(path: FilePath) -> Result<FileMetadata, IoError>:
    return native_fs_metadata(path)

# List directory contents
pub async fn read_dir(path: DirPath) -> Result<DirEntries, IoError>:
    return native_fs_read_dir(path)

# ===============================
# File Handle Operations
# ===============================

# File handle for streaming operations
struct File:
    handle: i64
    path: FilePath
    mode: OpenMode

impl File:
    # Open file with mode
    pub async fn open(path: FilePath, mode: OpenMode) -> Result<File, IoError>:
        val handle = native_fs_open(path, mode)?
        return Ok(File { handle: handle, path: path, mode: mode })

    # Read convenience methods
    pub async fn open_read(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Read)

    pub async fn open_write(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Write)

    pub async fn create(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Create)

    # Read up to `buf.len()` bytes
    pub async fn read(self, buf: &mut Bytes) -> Result<ByteCount, IoError>:
        return native_file_read(self.handle, buf)

    # Read exact number of bytes
    pub async fn read_exact(self, buf: &mut Bytes) -> Result<(), IoError>:
        var read_total: u64 = 0
        val target = buf.len()
        while read_total < target:
            val remaining = target - read_total
            val slice = buf.slice_mut(read_total, target)
            val n = await self.read(&mut slice)?
            if (n as u64) == 0:
                return Err(IoError::UnexpectedEof)
            read_total = read_total + (n as u64)
        return Ok(())

    # Write bytes
    pub async fn write(self, data: &Bytes) -> Result<ByteCount, IoError>:
        return native_file_write(self.handle, data)

    # Write all bytes
    pub async fn write_all(self, data: &Bytes) -> Result<(), IoError>:
        var written: u64 = 0
        val total = data.len()
        while written < total:
            val slice = data.slice(written, total)
            val n = await self.write(&slice)?
            written = written + (n as u64)
        return Ok(())

    # Flush buffers
    pub async fn flush(self) -> Result<(), IoError>:
        return native_file_flush(self.handle)

    # Seek position
    pub async fn seek(self, pos: SeekFrom) -> Result<ByteCount, IoError>:
        return native_file_seek(self.handle, pos)

    # Get current position
    pub async fn position(self) -> Result<ByteCount, IoError>:
        return self.seek(SeekFrom::Current(0))

    # Get file size
    pub async fn size(self) -> Result<ByteCount, IoError>:
        val current = await self.position()?
        val end = await self.seek(SeekFrom::End(0))?
        await self.seek(SeekFrom::Start(current as u64))?
        return Ok(end)

    # Sync to disk
    pub async fn sync_all(self) -> Result<(), IoError>:
        return native_file_sync(self.handle)

    # Close file
    pub async fn close(self) -> Result<(), IoError>:
        return native_file_close(self.handle)

# ===============================
# Native function declarations
# ===============================

extern fn native_fs_read(path: FilePath) -> Result<Bytes, IoError>
extern fn native_fs_write(path: FilePath, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_fs_append(path: FilePath, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_fs_create_dir(path: DirPath, recursive: bool) -> Result<(), IoError>
extern fn native_fs_remove_file(path: FilePath) -> Result<(), IoError>
extern fn native_fs_remove_dir(path: DirPath, recursive: bool) -> Result<(), IoError>
extern fn native_fs_rename(src: FilePath, dst: FilePath) -> Result<(), IoError>
extern fn native_fs_copy(src: FilePath, dst: FilePath) -> Result<ByteCount, IoError>
extern fn native_fs_metadata(path: FilePath) -> Result<FileMetadata, IoError>
extern fn native_fs_read_dir(path: DirPath) -> Result<DirEntries, IoError>
extern fn native_fs_open(path: FilePath, mode: OpenMode) -> Result<i64, IoError>
extern fn native_file_read(handle: i64, buf: &mut Bytes) -> Result<ByteCount, IoError>
extern fn native_file_write(handle: i64, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_file_flush(handle: i64) -> Result<(), IoError>
extern fn native_file_seek(handle: i64, pos: SeekFrom) -> Result<ByteCount, IoError>
extern fn native_file_sync(handle: i64) -> Result<(), IoError>
extern fn native_file_close(handle: i64) -> Result<(), IoError>

# ============================================
# Trait Implementations
# ============================================

impl Read for File:
    fn read(buf: &mut [u8]) -> Result<usize, IoError>:
        var bytes = Bytes::from_slice(buf)
        match native_file_read(self.handle, &mut bytes):
            case Ok(count):
                buf.copy_from_slice(&bytes.as_slice())
                Ok(count as usize)
            case Err(e): Err(e)

impl Write for File:
    fn write(buf: &[u8]) -> Result<usize, IoError>:
        val bytes = Bytes::from_slice(buf)
        match native_file_write(self.handle, &bytes):
            case Ok(count): Ok(count as usize)
            case Err(e): Err(e)

    fn flush() -> Result<(), IoError>:
        native_file_flush(self.handle)

impl Seek for File:
    fn seek(pos: core.traits.SeekFrom) -> Result<u64, IoError>:
        val local_pos = match pos:
            case core.traits.SeekFrom::Start(n): SeekFrom::Start(n)
            case core.traits.SeekFrom::End(n): SeekFrom::End(n)
            case core.traits.SeekFrom::Current(n): SeekFrom::Current(n)
        match native_file_seek(self.handle, local_pos):
            case Ok(count): Ok(count as u64)
            case Err(e): Err(e)

impl Drop for File:
    fn drop():
        native_file_close(self.handle)

# DirEntries implements Iterator
impl Iterator for DirEntries:
    type Item = DirEntry
    fn next() -> Option<Self::Item>:
        if self.index >= self.entries.len() as u64:
            return None
        val entry = self.entries[self.index as usize]
        self.index = self.index + 1
        return Some(entry)
