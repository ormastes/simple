# MCP Protocol Types
# Implements Anthropic's Model Context Protocol message structures

# Client information
pub class ClientInfo:
    name: String
    version: String

# Server information
pub class ServerInfo:
    name: String
    version: String

# Tool definition
pub class Tool:
    name: String
    description: String
    input_schema: Dict       # JSON Schema for tool inputs

# Resource definition
pub class Resource:
    uri: String
    name: String
    description: Option[String]
    mime_type: Option[String]

# Prompt definition
pub class Prompt:
    name: String
    description: Option[String]
    arguments: Option[List[Dict]]  # Argument schema

# Server capabilities
pub class ServerCapabilities:
    tools: Option[ToolsCapability]
    resources: Option[ResourcesCapability]
    prompts: Option[PromptsCapability]

pub class ToolsCapability:
    list_changed: Option[Bool]   # Whether tool list can change

pub class ResourcesCapability:
    subscribe: Option[Bool]       # Whether supports subscriptions
    list_changed: Option[Bool]    # Whether resource list can change

pub class PromptsCapability:
    list_changed: Option[Bool]    # Whether prompt list can change

# Client capabilities
pub class ClientCapabilities:
    roots: Option[RootsCapability]
    sampling: Option[Dict]

pub class RootsCapability:
    list_changed: Option[Bool]    # Whether root list changes

# Initialize request parameters
pub class InitializeParams:
    protocol_version: String
    capabilities: ClientCapabilities
    client_info: ClientInfo

# Initialize response result
pub class InitializeResult:
    protocol_version: String
    capabilities: ServerCapabilities
    server_info: ServerInfo

# Tool call request parameters
pub class ToolCallParams:
    name: String
    arguments: Option[Dict]

# Tool call result
pub class ToolCallResult:
    content: List[Content]
    is_error: Option[Bool]

# Content types for tool results
pub enum Content:
    Text(TextContent)
    Image(ImageContent)
    Resource(ResourceContent)

pub class TextContent:
    content_type: String      # Always "text"
    text: String

pub class ImageContent:
    content_type: String      # Always "image"
    data: String              # Base64 encoded
    mime_type: String

pub class ResourceContent:
    content_type: String      # Always "resource"
    resource: ResourceReference

pub class ResourceReference:
    uri: String
    text: Option[String]

# Resource read request
pub class ReadResourceParams:
    uri: String

# Resource read result
pub class ReadResourceResult:
    contents: List[ResourceContents]

pub class ResourceContents:
    uri: String
    mime_type: Option[String]
    text: Option[String]
    blob: Option[String]      # Base64 encoded

# List tools result
pub class ListToolsResult:
    tools: List[Tool]

# List resources result
pub class ListResourcesResult:
    resources: List[Resource]

# List prompts result
pub class ListPromptsResult:
    prompts: List[Prompt]

# Helper functions to create common message types

pub fn create_initialize_response(server_info: ServerInfo, capabilities: ServerCapabilities) -> Dict:
    val server_info_dict = {"name": server_info.name, "version": server_info.version}
    return {"protocolVersion": "2024-11-05", "capabilities": capabilities_to_dict(capabilities), "serverInfo": server_info_dict}

pub fn capabilities_to_dict(caps: ServerCapabilities) -> Dict:
    var result = {}

    match caps.tools:
        Some(tools_cap) ->
            result["tools"] = {"listChanged": tools_cap.list_changed.unwrap_or(false)}
        None ->
            pass

    match caps.resources:
        Some(res_cap) ->
            result["resources"] = {"subscribe": res_cap.subscribe.unwrap_or(false), "listChanged": res_cap.list_changed.unwrap_or(false)}
        None ->
            pass

    match caps.prompts:
        Some(prompt_cap) ->
            result["prompts"] = {"listChanged": prompt_cap.list_changed.unwrap_or(false)}
        None ->
            pass

    result

pub fn tool_to_dict(tool: Tool) -> Dict:
    return {"name": tool.name, "description": tool.description, "inputSchema": tool.input_schema}

pub fn resource_to_dict(resource: Resource) -> Dict:
    var result = {"uri": resource.uri, "name": resource.name}

    match resource.description:
        Some(desc) ->
            result["description"] = desc
        None ->
            pass

    match resource.mime_type:
        Some(mime) ->
            result["mimeType"] = mime
        None ->
            pass

    result
