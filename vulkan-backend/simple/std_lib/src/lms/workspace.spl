# Multi-file Workspace Handling for LMS
# Tracks file changes, dependencies, and provides workspace-wide operations

import sys
import protocol
import session

# File status enumeration
pub enum FileStatus:
    Clean           # File unchanged since last sync
    Modified        # File has local changes
    Deleted         # File marked for deletion
    Added           # New file added to workspace

# File metadata
pub class FileMetadata:
    uri: String
    version: Int
    status: FileStatus
    content_hash: String        # SHA-256 hash for change detection
    last_modified: Int          # Timestamp in milliseconds
    size: Int                   # File size in bytes
    language: Option[String]    # Detected language (e.g., "simple", "rust")

    pub fn new(uri: String, version: Int, content: String) -> FileMetadata:
        FileMetadata {
            uri: uri,
            version: version,
            status: FileStatus.Clean,
            content_hash: compute_hash(content),
            last_modified: sys.time.now_ms(),
            size: content.len(),
            language: detect_language(uri)
        }

    pub fn update(mut self, new_content: String, new_version: Int):
        val new_hash = compute_hash(new_content)
        if new_hash != self.content_hash:
            self.status = FileStatus.Modified
            self.content_hash = new_hash
            self.version = new_version
            self.last_modified = sys.time.now_ms()
            self.size = new_content.len()

    pub fn mark_deleted(mut self):
        self.status = FileStatus.Deleted
        self.last_modified = sys.time.now_ms()

# Workspace manager for multi-file tracking
pub class WorkspaceManager:
    root: String
    files: Dict[String, FileMetadata]      # uri -> metadata
    content_cache: Dict[String, String]    # uri -> content
    dependencies: Dict[String, List[String]]  # uri -> list of dependent uris
    dirty_files: Set[String]               # uris with unsaved changes

    pub fn new(root: String) -> WorkspaceManager:
        WorkspaceManager {
            root: root,
            files: {},
            content_cache: {},
            dependencies: {},
            dirty_files: Set.new()
        }

    # Add or update a file in the workspace
    pub fn add_file(mut self, uri: String, content: String, version: Int):
        # Create or update metadata
        match self.files.get(uri):
            Some(existing) ->
                existing.update(content, version)
            None ->
                self.files[uri] = FileMetadata.new(uri, version, content)

        # Cache content
        self.content_cache[uri] = content

        # Mark as dirty if modified
        val metadata = self.files[uri]
        match metadata.status:
            FileStatus.Modified ->
                self.dirty_files.insert(uri)
            FileStatus.Added ->
                self.dirty_files.insert(uri)
            _ ->
                pass

    # Remove a file from the workspace
    pub fn remove_file(mut self, uri: String):
        match self.files.get_mut(uri):
            Some(metadata) ->
                metadata.mark_deleted()
                self.dirty_files.insert(uri)
            None ->
                pass

    # Get file content from cache
    pub fn get_content(self, uri: String) -> Option[String]:
        self.content_cache.get(uri)

    # Get file metadata
    pub fn get_metadata(self, uri: String) -> Option[FileMetadata]:
        self.files.get(uri)

    # Get all files in workspace
    pub fn get_all_files(self) -> List[String]:
        var result = []
        for (uri, metadata) in self.files:
            match metadata.status:
                FileStatus.Deleted ->
                    pass  # Skip deleted files
                _ ->
                    result.push(uri)
        result

    # Get modified files since last sync
    pub fn get_dirty_files(self) -> List[String]:
        self.dirty_files.to_list()

    # Mark all files as clean (after successful sync)
    pub fn mark_all_clean(mut self):
        for (uri, metadata) in self.files:
            match metadata.status:
                FileStatus.Modified ->
                    metadata.status = FileStatus.Clean
                FileStatus.Added ->
                    metadata.status = FileStatus.Clean
                FileStatus.Deleted ->
                    # Remove deleted files completely
                    self.files.remove(uri)
                    self.content_cache.remove(uri)
                _ ->
                    pass

        self.dirty_files.clear()

    # Track dependencies between files
    pub fn add_dependency(mut self, uri: String, depends_on: String):
        match self.dependencies.get_mut(uri):
            Some(deps) ->
                if not deps.contains(depends_on):
                    deps.push(depends_on)
            None ->
                self.dependencies[uri] = [depends_on]

    # Get files that depend on a given file
    pub fn get_dependents(self, uri: String) -> List[String]:
        var result = []
        for (dependent_uri, deps) in self.dependencies:
            if deps.contains(uri):
                result.push(dependent_uri)
        result

    # Get transitive closure of files affected by a change
    pub fn get_affected_files(self, uri: String) -> Set[String]:
        var affected = Set.new()
        var to_process = [uri]

        while to_process.len() > 0:
            val current = to_process.pop()
            if affected.contains(current):
                continue

            affected.insert(current)

            # Add all dependents to processing queue
            val dependents = self.get_dependents(current)
            for dependent in dependents:
                if not affected.contains(dependent):
                    to_process.push(dependent)

        affected

    # Get workspace statistics
    pub fn get_stats(self) -> Dict:
        var total = 0
        var modified = 0
        var added = 0
        var deleted = 0

        for (uri, metadata) in self.files:
            total = total + 1
            match metadata.status:
                FileStatus.Modified ->
                    modified = modified + 1
                FileStatus.Added ->
                    added = added + 1
                FileStatus.Deleted ->
                    deleted = deleted + 1
                _ ->
                    pass

        {
            "total_files": total,
            "modified": modified,
            "added": added,
            "deleted": deleted,
            "dirty": self.dirty_files.len()
        }

# Compute SHA-256 hash of content
fn compute_hash(content: String) -> String:
    # Simplified hash - in real implementation would use crypto library
    var hash = 0
    for ch in content.chars():
        hash = (hash * 31 + ch.to_int()) % 1000000007
    hash.to_string()

# Detect language from file extension
fn detect_language(uri: String) -> Option[String]:
    if uri.ends_with(".spl"):
        Some("simple")
    else if uri.ends_with(".rs"):
        Some("rust")
    else if uri.ends_with(".py"):
        Some("python")
    else if uri.ends_with(".js"):
        Some("javascript")
    else if uri.ends_with(".ts"):
        Some("typescript")
    else:
        None
