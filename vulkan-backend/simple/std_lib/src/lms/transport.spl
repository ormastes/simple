# JSON-RPC Transport Layer for Language Model Server (MCP)
# Handles Content-Length protocol over stdin/stdout

import sys
import io.stdio as stdio
import core.json as json

# Read a JSON-RPC message from stdin
# Messages use Content-Length header protocol:
#   Content-Length: 123\r\n
#   \r\n
#   {json payload}
pub fn read_message() -> Result<Dict, String>:
    # Read headers until we find Content-Length
    let mut content_length = None

    loop:
        let line = stdio.read_line()?
        let trimmed = line.trim()

        # Empty line signals end of headers
        if trimmed.is_empty():
            break

        # Parse Content-Length header
        if trimmed.starts_with("Content-Length:"):
            let parts = trimmed.split(":")
            if parts.len() >= 2:
                let length_str = parts[1].trim()
                match length_str.parse_int():
                    case Ok(length):
                        content_length = Some(length)
                    case Err(e):
                        return Err(f"Invalid Content-Length: {e}")

    # Ensure we got Content-Length
    match content_length:
        case None:
            return Err("Missing Content-Length header")
        case Some(length):
            # Read exactly 'length' bytes of JSON content
            let content = stdio.read_exact(length)?

            # Parse JSON
            match json.parse(content):
                case Ok(parsed):
                    # Ensure it's a dictionary
                    match parsed:
                        case Dict(dict):
                            return Ok(dict)
                        case _:
                            return Err("JSON payload is not an object")
                case Err(e):
                    return Err(f"JSON parse error: {e}")

# Write a JSON-RPC message to stdout
# Adds Content-Length header and proper formatting
pub fn write_message(data: Dict) -> Result<Nil, String>:
    # Serialize to JSON
    let json_str = json.stringify(data)?
    let content_bytes = json_str.as_bytes()
    let content_length = content_bytes.len()

    # Build message with headers
    let mut message = f"Content-Length: {content_length}\r\n"
    message = message + "\r\n"
    message = message + json_str

    # Write to stdout
    stdio.write(message)?
    stdio.flush()?

    Ok(nil)

# Write a JSON-RPC response
pub fn write_response(id: Int, data: Dict) -> Result<Nil, String>:
    let response = {"jsonrpc": "2.0", "id": id, "result": data}
    write_message(response)

# Write a JSON-RPC error response
pub fn write_error(id: Int, code: Int, message: String) -> Result<Nil, String>:
    let error_obj = {"code": code, "message": message}
    let response = {"jsonrpc": "2.0", "id": id, "error": error_obj}
    write_message(response)

# Write a JSON-RPC notification
pub fn write_notification(method: String, params: Dict) -> Result<Nil, String>:
    let notification = {"jsonrpc": "2.0", "method": method, "params": params}
    write_message(notification)

# Debug logging helper (only if SIMPLE_LMS_DEBUG is set)
pub fn log_debug(message: String):
    match sys.env().get("SIMPLE_LMS_DEBUG"):
        case Some(_):
            sys.stderr_write(f"[LMS DEBUG] {message}\n")
        case None:
            let _ = message  # Placeholder for pass

# Log error to stderr
pub fn log_error(message: String):
    sys.stderr_write(f"[LMS ERROR] {message}\n")
