# Snapshot Testing - Test Runner
# Core execution engine for snapshot tests

module std.spec.snapshot.runner:
    use core.result.{Result, Ok, Err}
    use core.option.{Option, Some, None}
    use snapshot.config.{SnapshotConfig, from_env}
    use snapshot.storage.{SnapshotFile, load_snapshot, save_snapshot, snapshot_exists}
    use snapshot.formats.{get_formatter, apply_normalizations}
    use snapshot.comparison.{compare_snapshots, ComparisonResult, format_comparison_result}

    # Snapshot test result
    pub enum SnapshotTestResult:
        Pass(test_name: String)
        Fail(test_name: String, diff: String)
        Updated(test_name: String)
        Created(test_name: String)

    impl SnapshotTestResult:
        pub fn is_pass(self) -> bool:
            match self:
                SnapshotTestResult.Pass(_) -> return true
                _ -> return false

        pub fn is_fail(self) -> bool:
            match self:
                SnapshotTestResult.Fail(_, _) -> return true
                _ -> return false

    # Main snapshot test function
    pub fn expect_snapshot(
        value: Any,
        config: SnapshotConfig
    ) -> SnapshotTestResult:
        # Get test context (file and function name)
        val test_file = get_current_test_file()
        val test_name = config.name.unwrap_or(get_current_test_name())

        # Serialize value to string using format
        val formatter = get_formatter(config.format)
        val actual_content = match formatter.serialize(value):
            Ok(content) -> content
            Err(err) ->
                return SnapshotTestResult.Fail(
                    test_name: test_name,
                    diff: f"Serialization error: {err}"
                )

        # Apply normalizations
        val normalized_actual = if config.normalize:
            apply_normalizations(
                actual_content,
                config.normalize_timestamps,
                config.normalize_ids
            )
        else:
            actual_content

        # Apply custom normalizer
        val final_actual = if val Some(normalizer) = config.normalizer:
            normalizer(normalized_actual)
        else:
            normalized_actual

        # Check if snapshot exists
        if !snapshot_exists(test_file, test_name, config.snapshot_dir):
            # First run - create snapshot
            if config.update_snapshots:
                val snapshot = SnapshotFile.new(
                    test_file,
                    test_name,
                    final_actual,
                    config.format
                )
                match save_snapshot(snapshot, config.snapshot_dir):
                    Ok(_) ->
                        return SnapshotTestResult.Created(test_name: test_name)
                    Err(err) ->
                        return SnapshotTestResult.Fail(
                            test_name: test_name,
                            diff: f"Failed to create snapshot: {err}"
                        )
            else:
                return SnapshotTestResult.Fail(
                    test_name: test_name,
                    diff: "Snapshot does not exist. Run with --snapshot-update to create it."
                )

        # Load existing snapshot
        val expected_snapshot = match load_snapshot(test_file, test_name, config.snapshot_dir):
            Ok(snap) -> snap
            Err(err) ->
                return SnapshotTestResult.Fail(
                    test_name: test_name,
                    diff: f"Failed to load snapshot: {err}"
                )

        # Compare snapshots
        val comparison = compare_snapshots(
            expected_snapshot.content,
            final_actual,
            test_name,
            config.format
        )

        match comparison:
            ComparisonResult.Match ->
                return SnapshotTestResult.Pass(test_name: test_name)

            ComparisonResult.Mismatch(diff, context) ->
                # Snapshot mismatch
                if config.update_snapshots:
                    # Update mode - save new snapshot
                    if config.interactive:
                        # Interactive mode - ask user
                        if prompt_update(test_name, diff):
                            val updated = SnapshotFile.new(
                                test_file,
                                test_name,
                                final_actual,
                                config.format
                            )
                            match save_snapshot(updated, config.snapshot_dir):
                                Ok(_) ->
                                    return SnapshotTestResult.Updated(test_name: test_name)
                                Err(err) ->
                                    return SnapshotTestResult.Fail(
                                        test_name: test_name,
                                        diff: f"Failed to update snapshot: {err}"
                                    )
                        else:
                            return SnapshotTestResult.Fail(
                                test_name: test_name,
                                diff: format_comparison_result(comparison)
                            )
                    else:
                        # Non-interactive - update automatically
                        val updated = SnapshotFile.new(
                            test_file,
                            test_name,
                            final_actual,
                            config.format
                        )
                        match save_snapshot(updated, config.snapshot_dir):
                            Ok(_) ->
                                return SnapshotTestResult.Updated(test_name: test_name)
                            Err(err) ->
                                return SnapshotTestResult.Fail(
                                    test_name: test_name,
                                    diff: f"Failed to update snapshot: {err}"
                                )
                else:
                    # Not in update mode - fail test
                    return SnapshotTestResult.Fail(
                        test_name: test_name,
                        diff: format_comparison_result(comparison)
                    )

    # Convenience function with default config
    pub fn expect_snapshot_default(value: Any) -> SnapshotTestResult:
        val config = from_env()
        return expect_snapshot(value, config)

    # Convenience function with custom name
    pub fn expect_snapshot_named(
        value: Any,
        name: String
    ) -> SnapshotTestResult:
        val config = from_env().with_name(name)
        return expect_snapshot(value, config)

    # Convenience function with format
    pub fn expect_snapshot_json(value: Any) -> SnapshotTestResult:
        val config = from_env().with_format("json")
        return expect_snapshot(value, config)

    pub fn expect_snapshot_yaml(value: Any) -> SnapshotTestResult:
        val config = from_env().with_format("yaml")
        return expect_snapshot(value, config)

    # Helper: Get current test file path
    fn get_current_test_file() -> String:
        # TODO: Get from runtime/reflection
        return std.reflect.current_file()

    # Helper: Get current test function name
    fn get_current_test_name() -> String:
        # TODO: Get from runtime/reflection
        return std.reflect.current_function()

    # Helper: Prompt user for interactive update
    fn prompt_update(test_name: String, diff: String) -> bool:
        println(diff)
        println(f"\nUpdate snapshot '{test_name}'?")
        print("[y/N] ")

        val response = std.io.read_line()
        return response.trim().to_lowercase() == "y"

    # Batch run snapshot tests
    pub fn run_snapshot_tests(
        tests: [fn() -> SnapshotTestResult],
        config: SnapshotConfig
    ) -> SnapshotSummary:
        var passed = 0
        var failed = 0
        var updated = 0
        var created = 0
        var failures = []

        for test in tests:
            val result = test()
            match result:
                SnapshotTestResult.Pass(_) ->
                    passed += 1
                SnapshotTestResult.Fail(name, diff) ->
                    failed += 1
                    failures.push((name, diff))
                SnapshotTestResult.Updated(_) ->
                    updated += 1
                SnapshotTestResult.Created(_) ->
                    created += 1

        return SnapshotSummary(
            passed: passed,
            failed: failed,
            updated: updated,
            created: created,
            failures: failures
        )

    # Summary of snapshot test run
    pub struct SnapshotSummary:
        passed: i64
        failed: i64
        updated: i64
        created: i64
        failures: [(String, String)]

    impl SnapshotSummary:
        pub fn is_success(self) -> bool:
            return self.failed == 0

        pub fn format(self) -> String:
            var output = ""
            output += f"\nSnapshot Test Results:\n"
            output += f"  ✓ Passed: {self.passed}\n"
            if self.failed > 0:
                output += f"  ✗ Failed: {self.failed}\n"
            if self.updated > 0:
                output += f"  ↻ Updated: {self.updated}\n"
            if self.created > 0:
                output += f"  ⊕ Created: {self.created}\n"

            if !self.failures.is_empty():
                output += "\nFailures:\n"
                for (name, diff) in self.failures:
                    output += f"\n{name}:\n{diff}\n"

            return output
