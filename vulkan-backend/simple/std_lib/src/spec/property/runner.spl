# Property Testing - Test Runner
# Core execution engine for property-based tests

module std.spec.property.runner:
    use core.result.{Result, Ok, Err}
    use core.option.{Option, Some, None}
    use property.generators.Generator
    use property.config.PropertyConfig
    use property.shrinking.{shrink, ShrinkResult, ShrinkConfig}

    # Test result types
    pub enum PropertyTestResult<T>:
        Success(iterations: i64)
        Failure(
            iteration: i64,
            original_input: T,
            minimal_input: T,
            shrinks: i64,
            error_message: String
        )
        Timeout(iterations_completed: i64)

    impl<T> PropertyTestResult<T>:
        pub fn is_success(self) -> bool:
            match self:
                PropertyTestResult.Success(_) -> return true
                _ -> return false

        pub fn is_failure(self) -> bool:
            match self:
                PropertyTestResult.Failure(_, _, _, _, _) -> return true
                _ -> return false

    # Main property test runner
    pub fn run_property_test<T>(
        test_fn: fn(T) -> bool,
        generator: impl Generator<T>,
        config: PropertyConfig
    ) -> PropertyTestResult<T>:
        val start_time = time.now()
        val seed_value = config.seed.unwrap_or(time.now_nanos() % 2147483647)

        # Run iterations
        for i in 0..config.iterations:
            # Check timeout
            if config.total_timeout > 0.0:
                val elapsed = time.now() - start_time
                if elapsed > config.total_timeout:
                    return PropertyTestResult.Timeout(
                        iterations_completed: i
                    )

            # Generate test input
            val input = generator.generate(seed_value + i)

            # Run test with timeout
            val test_result = if config.timeout_per_iteration > 0.0:
                run_with_timeout(|| test_fn(input), config.timeout_per_iteration)
            else:
                test_fn(input)

            # Check if test passed
            if !test_result:
                if config.verbose:
                    println(f"Property test failed at iteration {i}")
                    println(f"Original input: {input}")

                # Shrink to find minimal failing case
                val minimal = if config.max_shrinks > 0:
                    shrink_to_minimal(
                        failing_value: input,
                        test_fn: test_fn,
                        generator: generator,
                        max_shrinks: config.max_shrinks,
                        max_depth: config.max_shrink_depth,
                        verbose: config.verbose
                    )
                else:
                    (input, 0)

                if config.verbose:
                    println(f"Minimal failing input: {minimal.0}")
                    println(f"Shrinks performed: {minimal.1}")

                return PropertyTestResult.Failure(
                    iteration: i,
                    original_input: input,
                    minimal_input: minimal.0,
                    shrinks: minimal.1,
                    error_message: "Property violation"
                )

        # All iterations passed
        if config.verbose:
            println(f"Property test passed {config.iterations} iterations")

        return PropertyTestResult.Success(iterations: config.iterations)

    # Helper: Shrink to minimal failing case
    fn shrink_to_minimal<T>(
        failing_value: T,
        test_fn: fn(T) -> bool,
        generator: impl Generator<T>,
        max_shrinks: i64,
        max_depth: i64,
        verbose: bool
    ) -> (T, i64):
        val shrink_config = ShrinkConfig(
            max_shrinks: max_shrinks,
            max_depth: max_depth
        )

        val result = shrink(
            failing_value: failing_value,
            test_fn: test_fn,
            generator: generator,
            config: shrink_config
        )

        match result:
            ShrinkResult.MinimalFailure(value, shrinks) ->
                if verbose:
                    println(f"Shrunk to minimal case after {shrinks} attempts")
                return (value, shrinks)
            ShrinkResult.NoShrinkPossible(value) ->
                if verbose:
                    println("Could not shrink further")
                return (value, 0)
            ShrinkResult.MaxShrinksExceeded(value, shrinks) ->
                if verbose:
                    println(f"Max shrinks ({max_shrinks}) exceeded")
                return (value, shrinks)

    # Helper: Run function with timeout
    fn run_with_timeout<T>(f: fn() -> T, timeout_secs: f64) -> T:
        # TODO: Implement actual timeout mechanism
        # For now, just run the function
        return f()

    # Convenience function for simple property tests
    pub fn check_property<T>(
        property: fn(T) -> bool,
        generator: impl Generator<T>
    ) -> bool:
        val config = PropertyConfig.default()
        val result = run_property_test(property, generator, config)
        return result.is_success()

    # Quick test with reduced iterations
    pub fn quick_check<T>(
        property: fn(T) -> bool,
        generator: impl Generator<T>
    ) -> bool:
        val config = PropertyConfig.quick()
        val result = run_property_test(property, generator, config)
        return result.is_success()

    # Thorough test with many iterations
    pub fn thorough_check<T>(
        property: fn(T) -> bool,
        generator: impl Generator<T>
    ) -> bool:
        val config = PropertyConfig.thorough()
        val result = run_property_test(property, generator, config)
        return result.is_success()

    # Example usage:
    # val result = run_property_test(
    #     test_fn: |x| x + 0 == x,
    #     generator: generators.i64(),
    #     config: PropertyConfig.default()
    # )
    #
    # match result:
    #     PropertyTestResult.Success(n) ->
    #         println(f"✓ Property holds for {n} cases")
    #     PropertyTestResult.Failure(i, orig, minimal, shrinks, msg) ->
    #         println(f"✗ Failed at iteration {i}")
    #         println(f"  Minimal: {minimal} (from {shrinks} shrinks)")
