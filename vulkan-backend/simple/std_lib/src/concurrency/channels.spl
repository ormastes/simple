/**
Channel Utilities

Channels provide typed communication between concurrent actors.
They are safer than raw send/recv with explicit sender/receiver.

Basic Channel Usage:
```sdoctest
>>> val (tx, rx) = channel()
>>> tx.send(42)
>>> rx.recv()
Some(42)
```
*/

/**
Bounded channel with capacity limit
*/
struct BoundedChannel[T]:
    capacity: Int
    buffer: List[T]
    closed: Bool

    fn new(capacity: Int) -> BoundedChannel[T]:
        return BoundedChannel(
            capacity: capacity,
            buffer: [],
            closed: false
        )

    fn send(value: T) -> Bool:
        if self.closed:
            return false
        if len(self.buffer) >= self.capacity:
            # In full impl, would block
            return false
        self.buffer.push(value)
        return true

    fn recv() -> Option[T]:
        if self.buffer.is_empty:
            if self.closed:
                return Option.None
            # In full impl, would block
            return Option.None
        return Option.Some(self.buffer.pop_front())

    fn close():
        self.closed = true

/**
Unbounded channel (no capacity limit)
*/
struct UnboundedChannel[T]:
    buffer: List[T]
    closed: Bool

    static fn new() -> UnboundedChannel[T]:
        return UnboundedChannel(
            buffer: [],
            closed: false
        )

    fn send(value: T):
        if not self.closed:
            self.buffer.push(value)

    fn recv() -> Option[T]:
        if self.buffer.is_empty:
            return Option.None
        return Option.Some(self.buffer.pop_front())

    fn close():
        self.closed = true

/**
One-shot channel for single value transfer
*/
struct Oneshot[T]:
    value: Option[T]
    completed: Bool

    static fn new() -> Oneshot[T]:
        return Oneshot(value: Option.None, completed: false)

    fn send(value: T) -> Bool:
        if self.completed:
            return false
        self.value = Option.Some(value)
        self.completed = true
        return true

    fn recv() -> Option[T]:
        if self.completed:
            return self.value
        return Option.None

/**
Create a sender/receiver pair (sugar for channel creation)

```sdoctest
>>> val (tx, rx) = channel()
>>> tx.send(42)
>>> rx.recv()
Some(42)
```
*/
fn channel():
    val ch = UnboundedChannel.new()
    return (ch, ch)  # Same object, but conceptually tx/rx

/**
Create a bounded channel pair
*/
fn bounded_channel(capacity: Int):
    val ch = BoundedChannel.new(capacity)
    return (ch, ch)

/**
Create a oneshot channel pair
*/
fn oneshot():
    val ch = Oneshot.new()
    return (ch, ch)
