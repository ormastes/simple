/**
Actor Utilities

Actors are concurrent entities that communicate via message passing.
Use `spawn` to create actors and `send`/`recv` for communication.

Basic Actor:
```sdoctest
>>> fn worker():
...     return 42
>>> let h = spawn worker()
```

The actor runs concurrently and can be communicated with via messages.
*/

/**
Actor state wrapper for stateful actors
*/
struct ActorState[T]:
    value: T

    fn get(self) -> T:
        return self.value

    fn set(self, new_value: T):
        self.value = new_value

/**
Create an actor that processes messages with a handler function

The handler receives (state, message) and returns new state.
*/
fn stateful_actor(initial_state, handler):
    let state = ActorState(value: initial_state)
    return spawn (\:
        while true:
            let msg = recv()
            state.set(handler(state.get(), msg))
    )()

/**
Supervisor pattern - restart actors on failure

Wraps an actor function with restart logic.
*/
struct Supervisor:
    child_fn: fn()
    max_restarts: Int
    restart_count: Int

    fn new(child_fn, max_restarts: Int = 3) -> Supervisor:
        return Supervisor(
            child_fn: child_fn,
            max_restarts: max_restarts,
            restart_count: 0
        )

    fn start(self):
        return spawn (\:
            while self.restart_count < self.max_restarts:
                try:
                    return self.child_fn()
                catch e:
                    self.restart_count += 1
                    print("Actor crashed, restarting ({self.restart_count}/{self.max_restarts})")
        )()

/**
Simple one-shot request-response pattern

Sends a request to an actor and waits for response.
*/
fn ask(actor, message, timeout_ms: Int = 5000):
    send(actor, message)
    return recv()  # In full impl, would use reply channel

/**
Broadcast a message to multiple actors
*/
fn broadcast(actors: List, message):
    for actor in actors:
        send(actor, message)
