# MCP Parser - Extract symbols from Simple source code

use core.*
use mcp.types.*

# Parse Simple source code and extract symbols
pub fn parse_file(source: String) -> List<Symbol>:
    symbols = []
    lines = source.split("\n")
    
    i = 0
    while i < lines.len():
        line = lines[i]
        stripped = line.strip()
        
        # Parse class/struct definitions
        if stripped.starts_with("pub class ") or stripped.starts_with("class "):
            symbol = parse_class(lines, i)
            symbols.append(symbol)
            i = symbol.line_end
        
        # Parse function definitions  
        elif stripped.starts_with("pub fn ") or stripped.starts_with("fn "):
            symbol = parse_function(lines, i)
            symbols.append(symbol)
            i = symbol.line_end
        
        # Parse trait definitions
        elif stripped.starts_with("pub trait ") or stripped.starts_with("trait "):
            symbol = parse_trait(lines, i)
            symbols.append(symbol)
            i = symbol.line_end
        
        # Parse pointcut definitions
        elif stripped.starts_with("pointcut "):
            symbol = parse_pointcut(lines, i)
            symbols.append(symbol)
            i = symbol.line_end
        
        else:
            i = i + 1
    
    return symbols

# Parse a class definition
fn parse_class(lines: List<String>, start_idx: i64) -> Symbol:
    line = lines[start_idx]
    stripped = line.strip()
    
    # Determine visibility
    vis = Visibility.Private
    if stripped.starts_with("pub "):
        vis = Visibility.Public
    
    # Extract class name (simple version)
    parts = stripped.split(" ")
    name = "Unknown"
    i = 0
    while i < parts.len():
        if parts[i] == "class" and i + 1 < parts.len():
            name_part = parts[i + 1]
            # Remove colon if present
            if name_part.ends_with(":"):
                name = name_part.substring(0, name_part.len() - 1)
            else:
                name = name_part
            break
        i = i + 1
    
    # Find end of class
    end_idx = find_block_end(lines, start_idx)
    
    # Extract body
    body_lines = []
    j = start_idx + 1
    while j <= end_idx and j < lines.len():
        body_lines.append(lines[j])
        j = j + 1
    
    symbol = Symbol.new(SymbolKind.Class, name, vis)
    symbol.signature = stripped
    symbol.body = "\n".join(body_lines)
    symbol.line_start = start_idx
    symbol.line_end = end_idx
    symbol.is_collapsed = true
    
    return symbol

# Parse a function definition
fn parse_function(lines: List<String>, start_idx: i64) -> Symbol:
    line = lines[start_idx]
    stripped = line.strip()
    
    # Determine visibility
    vis = Visibility.Private
    if stripped.starts_with("pub "):
        vis = Visibility.Public
    
    # Extract function name (simple version)
    parts = stripped.split(" ")
    name = "unknown"
    i = 0
    while i < parts.len():
        if parts[i] == "fn" and i + 1 < parts.len():
            name_part = parts[i + 1]
            # Extract name before parenthesis or colon
            paren_idx = 0
            while paren_idx < name_part.len():
                ch = name_part.char_at(paren_idx)
                if ch == "(" or ch == ":":
                    break
                paren_idx = paren_idx + 1
            
            if paren_idx > 0:
                name = name_part.substring(0, paren_idx)
            else:
                name = name_part
            break
        i = i + 1
    
    # Find end of function
    end_idx = find_block_end(lines, start_idx)
    
    # Extract body
    body_lines = []
    j = start_idx + 1
    while j <= end_idx and j < lines.len():
        body_lines.append(lines[j])
        j = j + 1
    
    symbol = Symbol.new(SymbolKind.Function, name, vis)
    symbol.signature = stripped
    symbol.body = "\n".join(body_lines)
    symbol.line_start = start_idx
    symbol.line_end = end_idx
    symbol.is_collapsed = true
    
    return symbol

# Parse a trait definition
fn parse_trait(lines: List<String>, start_idx: i64) -> Symbol:
    line = lines[start_idx]
    stripped = line.strip()
    
    # Determine visibility
    vis = Visibility.Private
    if stripped.starts_with("pub "):
        vis = Visibility.Public
    
    # Extract trait name
    parts = stripped.split(" ")
    name = "Unknown"
    i = 0
    while i < parts.len():
        if parts[i] == "trait" and i + 1 < parts.len():
            name_part = parts[i + 1]
            if name_part.ends_with(":"):
                name = name_part.substring(0, name_part.len() - 1)
            else:
                name = name_part
            break
        i = i + 1
    
    # Find end of trait
    end_idx = find_block_end(lines, start_idx)
    
    symbol = Symbol.new(SymbolKind.Trait, name, vis)
    symbol.signature = stripped
    symbol.line_start = start_idx
    symbol.line_end = end_idx
    symbol.is_collapsed = true
    
    return symbol

# Parse a pointcut definition
fn parse_pointcut(lines: List<String>, start_idx: i64) -> Symbol:
    line = lines[start_idx]
    stripped = line.strip()
    
    # Extract pointcut pattern (everything after "pointcut ")
    pattern = stripped
    if stripped.starts_with("pointcut "):
        pattern = stripped.substring(9, stripped.len())
    
    # Find end of pointcut
    end_idx = find_block_end(lines, start_idx)
    
    symbol = Symbol.new(SymbolKind.Pointcut, pattern, Visibility.Public)
    symbol.signature = stripped
    symbol.line_start = start_idx
    symbol.line_end = end_idx
    symbol.is_collapsed = true
    
    return symbol

# Find the end of an indented block
fn find_block_end(lines: List<String>, start_idx: i64) -> i64:
    if start_idx >= lines.len():
        return start_idx
    
    # Get indentation of the definition line
    def_line = lines[start_idx]
    base_indent = count_leading_spaces(def_line)
    
    # Find first line with same or less indentation
    i = start_idx + 1
    while i < lines.len():
        line = lines[i]
        
        # Skip empty lines
        if line.strip() == "":
            i = i + 1
            continue
        
        # Check indentation
        indent = count_leading_spaces(line)
        if indent <= base_indent:
            return i - 1
        
        i = i + 1
    
    return lines.len() - 1

# Count leading spaces in a line
fn count_leading_spaces(line: String) -> i64:
    count = 0
    i = 0
    while i < line.len():
        ch = line.char_at(i)
        if ch == " ":
            count = count + 1
        elif ch == "\t":
            count = count + 4
        else:
            break
        i = i + 1
    
    return count

# Filter symbols by visibility
pub fn filter_public_symbols(symbols: List<Symbol>) -> List<Symbol>:
    result = []
    for symbol in symbols:
        if symbol.visibility == Visibility.Public:
            result.append(symbol)
    
    return result

# Find symbol by name
pub fn find_symbol(symbols: List<Symbol>, name: String) -> Option<Symbol>:
    for symbol in symbols:
        if symbol.name == name:
            return Some(symbol)
    
    return None

# Find symbol by line number
pub fn find_symbol_at_line(symbols: List<Symbol>, line: i64) -> Option<Symbol>:
    for symbol in symbols:
        if line >= symbol.line_start and line <= symbol.line_end:
            return Some(symbol)
    
    return None
