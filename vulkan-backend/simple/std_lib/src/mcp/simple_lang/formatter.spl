# MCP Formatter - Generate MCP text with block marks

use core.*
use mcp.types.*

# Format symbols as MCP text (collapsed by default)
pub fn format_symbols(symbols: List[Symbol], show_all: bool) -> String:
    lines = []
    
    for symbol in symbols:
        # Skip private symbols unless show_all is true
        if not show_all and symbol.visibility == Visibility.Private:
            continue
        
        if symbol.is_collapsed:
            line = format_collapsed_symbol(symbol)
        else:
            line = format_expanded_symbol(symbol)
        
        lines.append(line)
    
    # Add virtual information
    virtual_lines = generate_virtual_info(symbols)
    for vline in virtual_lines:
        lines.append(vline)
    
    return "\n".join(lines)

# Format a collapsed symbol (with { … })
fn format_collapsed_symbol(symbol: Symbol) -> String:
    mark = get_block_mark(symbol, true)
    mark_str = block_mark_to_string(mark)
    
    # Extract just the signature without body
    sig = symbol.signature
    
    # Add collapsed body indicator
    if symbol.kind == SymbolKind.Class or symbol.kind == SymbolKind.Struct:
        return mark_str + " " + sig + " { … }"
    elif symbol.kind == SymbolKind.Function or symbol.kind == SymbolKind.Method:
        return mark_str + " " + sig + " { … }"
    elif symbol.kind == SymbolKind.Trait:
        return mark_str + " " + sig + " { … }"
    elif symbol.kind == SymbolKind.Pointcut:
        return mark_str + " " + sig
    else:
        return mark_str + " " + sig

# Format an expanded symbol (with full body)
fn format_expanded_symbol(symbol: Symbol) -> String:
    mark = get_block_mark(symbol, false)
    mark_str = block_mark_to_string(mark)
    
    lines = []
    
    # Add signature
    sig = symbol.signature
    lines.append(mark_str + " " + sig)
    
    # Add body with proper indentation
    if symbol.body != "":
        body_lines = symbol.body.split("\n")
        for bline in body_lines:
            if bline.strip() != "":
                lines.append("    " + bline)
    
    return "\n".join(lines)

# Get the appropriate block mark for a symbol
fn get_block_mark(symbol: Symbol, collapsed: bool) -> BlockMark:
    if symbol.kind == SymbolKind.Class or symbol.kind == SymbolKind.Struct:
        if collapsed:
            return BlockMark.ClassCollapsed
        else:
            return BlockMark.ClassExpanded
    
    elif symbol.kind == SymbolKind.Function or symbol.kind == SymbolKind.Method:
        if collapsed:
            return BlockMark.FunctionCollapsed
        else:
            return BlockMark.FunctionExpanded
    
    elif symbol.kind == SymbolKind.Trait:
        if collapsed:
            return BlockMark.TraitCollapsed
        else:
            return BlockMark.TraitExpanded
    
    elif symbol.kind == SymbolKind.Pointcut:
        if collapsed:
            return BlockMark.PointcutCollapsed
        else:
            return BlockMark.PointcutExpanded
    
    else:
        return BlockMark.VirtualInfo

# Generate virtual information lines
fn generate_virtual_info(symbols: List[Symbol]) -> List[String]:
    lines = []
    
    # Count public methods
    pub_method_count = 0
    priv_method_count = 0
    
    for symbol in symbols:
        if symbol.kind == SymbolKind.Function or symbol.kind == SymbolKind.Method:
            if symbol.visibility == Visibility.Public:
                pub_method_count = pub_method_count + 1
            else:
                priv_method_count = priv_method_count + 1
    
    # Add virtual info if applicable
    if pub_method_count > 0 or priv_method_count > 0:
        info = "V• methods: " + pub_method_count.to_string() + " public, " + priv_method_count.to_string() + " private"
        lines.append(info)
    
    return lines

# Format a single symbol (for expansion)
pub fn format_single_symbol(symbol: Symbol, what: String) -> String:
    if what == "signature":
        # Just the signature
        mark = get_block_mark(symbol, false)
        mark_str = block_mark_to_string(mark)
        return mark_str + " " + symbol.signature
    
    elif what == "body":
        # Just the body
        return symbol.body
    
    elif what == "all":
        # Full expanded form
        symbol.is_collapsed = false
        return format_expanded_symbol(symbol)
    
    else:
        # Default: collapsed
        symbol.is_collapsed = true
        return format_collapsed_symbol(symbol)

# Generate JSON output
pub fn to_json(text: String, meta: Option[McpMetadata]) -> String:
    # Escape quotes and newlines in text
    escaped_text = escape_json_string(text)
    
    if meta.is_some():
        m = meta.unwrap()
        json = "{\n"
        json = json + "  \"text\": \"" + escaped_text + "\",\n"
        json = json + "  \"meta\": {\n"
        json = json + "    \"mode\": \"" + m.mode + "\",\n"
        json = json + "    \"line_numbers\": \"" + m.line_numbers + "\",\n"
        json = json + "    \"show_coverage\": " + m.show_coverage.to_string() + ",\n"
        json = json + "    \"show_block_guides\": " + m.show_block_guides.to_string() + "\n"
        json = json + "  }\n"
        json = json + "}"
        return json
    else:
        # Simple JSON with just text field
        return "{\n  \"text\": \"" + escaped_text + "\"\n}"

# Escape string for JSON
fn escape_json_string(s: String) -> String:
    result = ""
    i = 0
    while i < s.len():
        ch = s.char_at(i)
        
        if ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        elif ch == "\n":
            result = result + "\\n"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\t":
            result = result + "\\t"
        else:
            result = result + ch
        
        i = i + 1
    
    return result
