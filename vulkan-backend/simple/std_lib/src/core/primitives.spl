# Primitive Type Extensions
# Feature #1387: Integer/Float/Bool object methods

"""
Extension methods for primitive types.

This module provides object-oriented methods for primitive types,
allowing syntax like `42.abs()` and `3.14.round()`.

These are implemented as extension methods that work with the
primitive types without boxing/wrapping.
"""

# ============================================
# Integer Extensions (i8, i16, i32, i64, u8, u16, u32, u64)
# ============================================

impl i64:
    """Integer extension methods"""

    fn abs() -> i64:
        """Absolute value"""
        if self < 0: -self else: self

    fn sign() -> i64:
        """Sign: -1, 0, or 1"""
        if self < 0: -1
        elif self > 0: 1
        else: 0

    fn pow(exp: u32) -> i64:
        """Raise to power"""
        var result = 1
        for _ in 0..exp:
            result *= self
        result

    fn min(other: i64) -> i64:
        """Minimum of two values"""
        if self < other: self else: other

    fn max(other: i64) -> i64:
        """Maximum of two values"""
        if self > other: self else: other

    fn clamp(min: i64, max: i64) -> i64:
        """Clamp value between min and max"""
        if self < min: min
        elif self > max: max
        else: self

    fn is_even() -> bool:
        """Check if even"""
        self % 2 == 0

    fn is_odd() -> bool:
        """Check if odd"""
        self % 2 != 0

    fn is_positive() -> bool:
        """Check if positive"""
        self > 0

    fn is_negative() -> bool:
        """Check if negative"""
        self < 0

    fn div_euclid(rhs: i64) -> i64:
        """Euclidean division (always non-negative remainder)"""
        val q = self / rhs
        val r = self % rhs
        if r < 0:
            if rhs > 0: q - 1 else: q + 1
        else:
            q

    fn rem_euclid(rhs: i64) -> i64:
        """Euclidean remainder (always non-negative)"""
        val r = self % rhs
        if r < 0:
            if rhs > 0: r + rhs else: r - rhs
        else:
            r

# ============================================
# Float Extensions (f32, f64)
# ============================================

impl f64:
    """Float extension methods"""

    fn abs() -> f64:
        """Absolute value"""
        if self < 0.0: -self else: self

    fn floor() -> f64:
        """Round down to integer"""
        # Compiler intrinsic or stdlib implementation
        __builtin_floor(self)

    fn ceil() -> f64:
        """Round up to integer"""
        # Compiler intrinsic or stdlib implementation
        __builtin_ceil(self)

    fn round() -> f64:
        """Round to nearest integer"""
        # Compiler intrinsic or stdlib implementation
        __builtin_round(self)

    fn trunc() -> f64:
        """Round toward zero"""
        if self >= 0.0: self.floor() else: self.ceil()

    fn sqrt() -> f64:
        """Square root"""
        __builtin_sqrt(self)

    fn powi(exp: i32) -> f64:
        """Raise to integer power"""
        __builtin_powi(self, exp)

    fn powf(exp: f64) -> f64:
        """Raise to float power"""
        __builtin_powf(self, exp)

    fn sin() -> f64:
        """Sine"""
        __builtin_sin(self)

    fn cos() -> f64:
        """Cosine"""
        __builtin_cos(self)

    fn tan() -> f64:
        """Tangent"""
        __builtin_tan(self)

    fn min(other: f64) -> f64:
        """Minimum of two values"""
        if self < other: self else: other

    fn max(other: f64) -> f64:
        """Maximum of two values"""
        if self > other: self else: other

    fn clamp(min: f64, max: f64) -> f64:
        """Clamp value between min and max"""
        if self < min: min
        elif self > max: max
        else: self

    fn is_nan() -> bool:
        """Check if NaN"""
        self != self

    fn is_infinite() -> bool:
        """Check if infinite"""
        self == f64::INFINITY or self == f64::NEG_INFINITY

    fn is_finite() -> bool:
        """Check if finite"""
        not self.is_infinite() and not self.is_nan()

# ============================================
# Bool Extensions
# ============================================

impl bool:
    """Boolean extension methods"""

    fn then[T](self, value: T) -> Option[T]:
        """Return Some(value) if true, None if false"""
        if self: Some(value) else: None

    fn then_some[T](self, f: fn() -> T) -> Option[T]:
        """Evaluate and return Some(result) if true"""
        if self: Some(f()) else: None

    fn to_int() -> i64:
        """Convert to integer (0 or 1)"""
        if self: 1 else: 0

    fn to_string() -> str:
        """Convert to string"""
        if self: "true" else: "false"

# ============================================
# Constants
# ============================================

impl f64:
    const PI: f64 = 3.14159265358979323846
    const E: f64 = 2.71828182845904523536
    const INFINITY: f64 = 1.0 / 0.0
    const NEG_INFINITY: f64 = -1.0 / 0.0
    const NAN: f64 = 0.0 / 0.0

impl i64:
    const MIN: i64 = -9223372036854775808
    const MAX: i64 = 9223372036854775807

# ============================================
# Example Usage
# ============================================

"""
Example usage of primitive extensions:

    # Integer methods
    val x = -42
    assert x.abs() == 42
    assert x.is_negative()
    assert 10.pow(3) == 1000
    assert 5.min(10) == 5
    assert 7.clamp(0, 5) == 5

    # Float methods
    val y = 3.7
    assert y.floor() == 3.0
    assert y.ceil() == 4.0
    assert y.round() == 4.0
    assert 2.0.sqrt() == 1.414...
    assert 9.0.sqrt() == 3.0

    # Boolean methods
    val b = true
    assert b.to_int() == 1
    assert b.then(42) == Some(42)
    assert false.then(42) == None

    # Constants
    val circle_area = r * r * f64::PI
    assert f64::INFINITY.is_infinite()
"""
