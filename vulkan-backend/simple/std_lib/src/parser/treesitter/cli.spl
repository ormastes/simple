# Tree-sitter CLI Tools
# Command-line interface for tree-sitter operations

import sys
import io.stdio as stdio
import parser.treesitter.{TreeSitterParser, Grammar}
import parser.treesitter.language_detect as detect
import parser.treesitter.grammar_test as gt
import parser.treesitter.grammar_compile as compile

# CLI command result
enum CliResult:
    Success(message: String)
    Error(error: String)
    Help

# CLI commands
enum Command:
    Parse(file_path: String, language: Option<String>, show_tree: Bool)
    Query(file_path: String, query_str: String, language: Option<String>)
    Test(test_file: String)
    Highlight(file_path: String, language: Option<String>)
    Validate(grammar_file: String)
    Languages
    Help
    Version

# Main CLI handler
class TreeSitterCli:
    static fn new() -> TreeSitterCli:
        TreeSitterCli()

    # Run CLI with arguments
    fn run(args: List<String>) -> CliResult:
        if args.len() < 2:
            return self.print_help()

        val command = self.parse_command(args)?

        match command:
            case Parse(file_path, language, show_tree):
                return self.cmd_parse(file_path, language, show_tree)
            case Query(file_path, query_str, language):
                return self.cmd_query(file_path, query_str, language)
            case Test(test_file):
                return self.cmd_test(test_file)
            case Highlight(file_path, language):
                return self.cmd_highlight(file_path, language)
            case Validate(grammar_file):
                return self.cmd_validate(grammar_file)
            case Languages:
                return self.cmd_languages()
            case Help:
                return self.print_help()
            case Version:
                return self.print_version()

    # Parse command-line arguments
    fn parse_command(args: List<String>) -> Result<Command, String>:
        val cmd = args[1]

        match cmd:
            case "parse":
                if args.len() < 3:
                    return Err("Usage: ts-cli parse <file> [--language <lang>] [--tree]")

                val file_path = args[2]
                var language: Option<String> = None
                var show_tree = false

                var i = 3
                while i < args.len():
                    match args[i]:
                        case "--language" | "-l":
                            if i + 1 < args.len():
                                language = Some(args[i + 1])
                                i = i + 2
                            else:
                                return Err("--language requires an argument")
                        case "--tree" | "-t":
                            show_tree = true
                            i = i + 1
                        case _:
                            return Err(f"Unknown option: {args[i]}")

                return Ok(Command.Parse(file_path, language, show_tree))

            case "query":
                if args.len() < 4:
                    return Err("Usage: ts-cli query <file> <query> [--language <lang>]")

                val file_path = args[2]
                val query_str = args[3]
                var language: Option<String> = None

                if args.len() > 4 and (args[4] == "--language" or args[4] == "-l"):
                    if args.len() > 5:
                        language = Some(args[5])

                return Ok(Command.Query(file_path, query_str, language))

            case "test":
                if args.len() < 3:
                    return Err("Usage: ts-cli test <test-file>")

                return Ok(Command.Test(args[2]))

            case "highlight":
                if args.len() < 3:
                    return Err("Usage: ts-cli highlight <file> [--language <lang>]")

                val file_path = args[2]
                var language: Option<String> = None

                if args.len() > 3 and (args[3] == "--language" or args[3] == "-l"):
                    if args.len() > 4:
                        language = Some(args[4])

                return Ok(Command.Highlight(file_path, language))

            case "validate":
                if args.len() < 3:
                    return Err("Usage: ts-cli validate <grammar-file>")

                return Ok(Command.Validate(args[2]))

            case "languages":
                return Ok(Command.Languages)

            case "help" | "--help" | "-h":
                return Ok(Command.Help)

            case "version" | "--version" | "-v":
                return Ok(Command.Version)

            case _:
                return Err(f"Unknown command: {cmd}")

    # Parse command: Parse a file and show results
    fn cmd_parse(file_path: String, language: Option<String>, show_tree: Bool) -> CliResult:
        # Read file
        val content = match stdio.read_file(file_path):
            case Ok(c): c
            case Err(e):
                return CliResult.Error(f"Failed to read file: {e}")

        # Detect or use specified language
        val lang = match language:
            case Some(l): l
            case None:
                match detect.detect_language(Some(file_path), Some(content)):
                    case Some(l): l
                    case None:
                        return CliResult.Error("Could not detect language. Use --language to specify.")

        # Create parser
        val parser = match TreeSitterParser.new(lang):
            case Ok(p): p
            case Err(e):
                return CliResult.Error(f"Failed to create parser: {e}")

        # Parse
        val start_time = sys.time.now_ms()
        val tree = match parser.parse(content):
            case Ok(t): t
            case Err(e):
                return CliResult.Error(f"Parse error: {e}")
        val parse_time = sys.time.now_ms() - start_time

        # Show results
        print(f"✅ Parsed successfully in {parse_time:.2f}ms")
        print(f"Language: {lang}")
        print(f"Root node: {tree.root_node.kind}")

        if tree.root_node.has_error:
            print("⚠️  Tree contains errors")

        if show_tree:
            print("\nParse tree:")
            print(gt.tree_to_string(tree.root_node, tree, 0))

        CliResult.Success("Parse complete")

    # Query command: Run a query against a file
    fn cmd_query(file_path: String, query_str: String, language: Option<String>) -> CliResult:
        # Read file
        val content = match stdio.read_file(file_path):
            case Ok(c): c
            case Err(e):
                return CliResult.Error(f"Failed to read file: {e}")

        # Detect or use specified language
        val lang = match language:
            case Some(l): l
            case None:
                match detect.detect_language(Some(file_path), Some(content)):
                    case Some(l): l
                    case None:
                        return CliResult.Error("Could not detect language. Use --language to specify.")

        # Create parser
        val parser = match TreeSitterParser.new(lang):
            case Ok(p): p
            case Err(e):
                return CliResult.Error(f"Failed to create parser: {e}")

        # Parse
        val tree = match parser.parse(content):
            case Ok(t): t
            case Err(e):
                return CliResult.Error(f"Parse error: {e}")

        # Execute query
        val cursor = match parser.query(tree, query_str):
            case Ok(c): c
            case Err(e):
                return CliResult.Error(f"Query error: {e}")

        # Show results
        print(f"Query: {query_str}")
        print(f"Matches:")

        var count = 0
        loop:
            match cursor.next_match():
                case None:
                    break
                case Some(m):
                    count = count + 1
                    print(f"  Match {count}:")
                    for capture in m.captures:
                        print(f"    {capture.name}: {capture.node.kind}")

        print(f"\nTotal matches: {count}")

        CliResult.Success("Query complete")

    # Test command: Run grammar tests
    fn cmd_test(test_file: String) -> CliResult:
        # Load and execute test file
        # This would typically load a test suite from the file
        print(f"Running tests from: {test_file}")

        # For now, just run a simple validation
        val content = match stdio.read_file(test_file):
            case Ok(c): c
            case Err(e):
                return CliResult.Error(f"Failed to read test file: {e}")

        print(f"✅ Test file loaded ({content.len()} bytes)")
        print("Note: Full test execution requires BDD framework integration")

        CliResult.Success("Test validation complete")

    # Highlight command: Show syntax highlighting tokens
    fn cmd_highlight(file_path: String, language: Option<String>) -> CliResult:
        # Read file
        val content = match stdio.read_file(file_path):
            case Ok(c): c
            case Err(e):
                return CliResult.Error(f"Failed to read file: {e}")

        # Detect or use specified language
        val lang = match language:
            case Some(l): l
            case None:
                match detect.detect_language(Some(file_path), Some(content)):
                    case Some(l): l
                    case None:
                        return CliResult.Error("Could not detect language. Use --language to specify.")

        # Create parser
        val parser = match TreeSitterParser.new(lang):
            case Ok(p): p
            case Err(e):
                return CliResult.Error(f"Failed to create parser: {e}")

        # Parse
        val tree = match parser.parse(content):
            case Ok(t): t
            case Err(e):
                return CliResult.Error(f"Parse error: {e}")

        # Show syntax highlighting (simplified - would use query system)
        print(f"Syntax highlighting for: {file_path}")
        print(f"Language: {lang}")
        print("\nTokens:")

        self.show_node_tokens(tree.root_node, tree, 0)

        CliResult.Success("Highlight complete")

    # Show node tokens (helper for highlight)
    fn show_node_tokens(node: Node, tree: Tree, depth: Int):
        val indent = "  ".repeat(depth)
        print(f"{indent}{node.kind} [{node.span.start_line}:{node.span.start_column}]")

        # Limit recursion depth for display
        if depth < 3:
            for child_id in node.children:
                match tree.get_node(child_id):
                    case Ok(child):
                        self.show_node_tokens(child, tree, depth + 1)
                    case Err(_):
                        pass

    # Validate command: Validate a grammar definition
    fn cmd_validate(grammar_file: String) -> CliResult:
        print(f"Validating grammar: {grammar_file}")

        # Load grammar file
        val content = match stdio.read_file(grammar_file):
            case Ok(c): c
            case Err(e):
                return CliResult.Error(f"Failed to read grammar file: {e}")

        print(f"✅ Grammar file loaded ({content.len()} bytes)")

        # Basic validation
        if content.contains("fn ") and content.contains("Grammar"):
            print("✅ Grammar structure looks valid")
        else:
            print("⚠️  Grammar structure may be invalid")

        print("Note: Full grammar validation requires compilation pipeline")

        CliResult.Success("Validation complete")

    # Languages command: List supported languages
    fn cmd_languages() -> CliResult:
        print("Supported languages:")
        print("")

        val languages = detect.get_supported_languages()

        for lang in languages:
            print(f"  - {lang}")

        print(f"\nTotal: {languages.len()} languages")

        CliResult.Success("Language list complete")

    # Print help
    fn print_help() -> CliResult:
        print("Tree-sitter CLI Tools")
        print("")
        print("Usage: ts-cli <command> [options]")
        print("")
        print("Commands:")
        print("  parse <file> [--language <lang>] [--tree]")
        print("      Parse a file and show parse statistics")
        print("      Options:")
        print("        --language, -l <lang>  Specify language (auto-detect if omitted)")
        print("        --tree, -t             Show full parse tree")
        print("")
        print("  query <file> <query> [--language <lang>]")
        print("      Run a tree-sitter query against a file")
        print("      Options:")
        print("        --language, -l <lang>  Specify language (auto-detect if omitted)")
        print("")
        print("  test <test-file>")
        print("      Run grammar tests from a test file")
        print("")
        print("  highlight <file> [--language <lang>]")
        print("      Show syntax highlighting tokens for a file")
        print("      Options:")
        print("        --language, -l <lang>  Specify language (auto-detect if omitted)")
        print("")
        print("  validate <grammar-file>")
        print("      Validate a grammar definition file")
        print("")
        print("  languages")
        print("      List all supported languages")
        print("")
        print("  help, --help, -h")
        print("      Show this help message")
        print("")
        print("  version, --version, -v")
        print("      Show version information")
        print("")
        print("Examples:")
        print("  ts-cli parse example.py")
        print("  ts-cli parse example.py --tree")
        print("  ts-cli query example.rs '(function_def)' ")
        print("  ts-cli highlight main.spl")
        print("  ts-cli languages")
        print("")

        CliResult.Help

    # Print version
    fn print_version() -> CliResult:
        print("Tree-sitter CLI Tools v0.1.0")
        print("Self-hosted tree-sitter implementation in Simple")
        print("")
        print("Features:")
        print("  - Multi-language parsing (Simple, Rust, Python)")
        print("  - Incremental parsing")
        print("  - Query system")
        print("  - Grammar testing framework")
        print("  - Language auto-detection")
        print("")

        CliResult.Success("Version info displayed")

# Main entry point
fn main():
    val args = sys.args()
    val cli = TreeSitterCli.new()

    match cli.run(args):
        case Success(message):
            sys.exit(0)
        case Error(error):
            stdio.write_stderr(f"Error: {error}\n")
            sys.exit(1)
        case Help:
            sys.exit(0)

# Convenience functions

# Parse a file from command line
fn parse_file(file_path: String, language: Option<String>) -> Result<Tree, String>:
    val content = stdio.read_file(file_path)?

    val lang = match language:
        case Some(l): l
        case None:
            detect.detect_language(Some(file_path), Some(content))
                .ok_or("Could not detect language")?

    val parser = TreeSitterParser.new(lang)?
    parser.parse(content)

# Run a query from command line
fn query_file(file_path: String, query_str: String, language: Option<String>) -> Result<QueryCursor, String>:
    val tree = parse_file(file_path, language)?

    val lang = language.unwrap_or("simple")
    val parser = TreeSitterParser.new(lang)?

    parser.query(tree, query_str)
