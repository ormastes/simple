# Grammar Testing Framework
# Systematic testing for tree-sitter grammars

import parser.treesitter.{TreeSitterParser, Tree, Node, Span}

# Test case for grammar testing
class GrammarTestCase:
    name: String
    language: String
    source: String
    expected_kind: String            # Expected root node kind
    expected_structure: Option<TreeStructure>  # Optional tree structure assertion
    should_error: Bool               # Expect parse errors?

    fn new(
        name: String,
        language: String,
        source: String,
        expected_kind: String
    ) -> GrammarTestCase:
        GrammarTestCase(
            name: name,
            language: language,
            source: source,
            expected_kind: expected_kind,
            expected_structure: None,
            should_error: false
        )

    var fn with_structure(structure: TreeStructure) -> GrammarTestCase:
        self.expected_structure = Some(structure)
        self

    var fn expect_error() -> GrammarTestCase:
        self.should_error = true
        self

# Tree structure for assertions
class TreeStructure:
    kind: String
    children: List<TreeStructure>
    fields: Dict<String, TreeStructure>

    fn new(kind: String) -> TreeStructure:
        TreeStructure(
            kind: kind,
            children: [],
            fields: {}
        )

    var fn with_child(child: TreeStructure) -> TreeStructure:
        self.children.push(child)
        self

    var fn with_field(name: String, child: TreeStructure) -> TreeStructure:
        self.fields[name] = child
        self

# Test result
class GrammarTestResult:
    test_name: String
    passed: Bool
    error_message: Option<String>
    parse_time_ms: Float

    fn new(
        test_name: String,
        passed: Bool,
        error_message: Option<String>,
        parse_time_ms: Float
    ) -> GrammarTestResult:
        GrammarTestResult(
            test_name: test_name,
            passed: passed,
            error_message: error_message,
            parse_time_ms: parse_time_ms
        )

    fn success(test_name: String, parse_time_ms: Float) -> GrammarTestResult:
        GrammarTestResult.new(test_name, true, None, parse_time_ms)

    fn failure(test_name: String, message: String, parse_time_ms: Float) -> GrammarTestResult:
        GrammarTestResult.new(test_name, false, Some(message), parse_time_ms)

    fn print_summary():
        if self.passed:
            print(f"✅ {self.test_name} ({self.parse_time_ms:.2f}ms)")
        else:
            print(f"❌ {self.test_name}")
            match self.error_message:
                case Some(msg):
                    print(f"   Error: {msg}")
                case None:
                    pass

# Test suite
class GrammarTestSuite:
    name: String
    tests: List<GrammarTestCase>

    fn new(name: String) -> GrammarTestSuite:
        GrammarTestSuite(
            name: name,
            tests: []
        )

    var fn add_test(test: GrammarTestCase):
        self.tests.push(test)

    fn run() -> GrammarTestSuiteResult:
        print(f"\n=== {self.name} ===\n")

        var results: List<GrammarTestResult> = []
        var passed_count = 0
        var failed_count = 0

        for test in self.tests:
            val result = run_test(test)
            result.print_summary()

            if result.passed:
                passed_count = passed_count + 1
            else:
                failed_count = failed_count + 1

            results.push(result)

        print(f"\n{passed_count} passed, {failed_count} failed\n")

        GrammarTestSuiteResult(
            suite_name: self.name,
            results: results,
            passed_count: passed_count,
            failed_count: failed_count
        )

# Test suite result
class GrammarTestSuiteResult:
    suite_name: String
    results: List<GrammarTestResult>
    passed_count: Int
    failed_count: Int

    fn all_passed() -> Bool:
        self.failed_count == 0

    fn print_summary():
        val total = self.passed_count + self.failed_count
        val pass_rate = (self.passed_count * 100) / total

        print(f"\n=== {self.suite_name} Summary ===")
        print(f"Total: {total} tests")
        print(f"Passed: {self.passed_count} ({pass_rate}%)")
        print(f"Failed: {self.failed_count}")

        if self.all_passed():
            print("✅ All tests passed!")
        else:
            print("❌ Some tests failed")

# Run a single test
fn run_test(test: GrammarTestCase) -> GrammarTestResult:
    # Create parser
    val parser = match TreeSitterParser.new(test.language):
        case Ok(p): p
        case Err(e):
            return GrammarTestResult.failure(
                test.name,
                f"Failed to create parser: {e}",
                0.0
            )

    # Parse source
    val start_time = sys.time.now_ms()
    val tree = match parser.parse(test.source):
        case Ok(t): t
        case Err(e):
            val parse_time = sys.time.now_ms() - start_time
            if test.should_error:
                # Expected to fail
                return GrammarTestResult.success(test.name, parse_time)
            else:
                return GrammarTestResult.failure(
                    test.name,
                    f"Parse failed: {e}",
                    parse_time
                )
    val parse_time = sys.time.now_ms() - start_time

    # Check if error was expected
    if test.should_error and not tree.root_node.has_error:
        return GrammarTestResult.failure(
            test.name,
            "Expected parse error but parsing succeeded",
            parse_time
        )

    # Check root node kind
    if tree.root_node.kind != test.expected_kind:
        return GrammarTestResult.failure(
            test.name,
            f"Expected root kind '{test.expected_kind}', got '{tree.root_node.kind}'",
            parse_time
        )

    # Check tree structure if provided
    match test.expected_structure:
        case Some(structure):
            match check_tree_structure(tree.root_node, structure, tree):
                case Ok(_):
                    return GrammarTestResult.success(test.name, parse_time)
                case Err(e):
                    return GrammarTestResult.failure(test.name, e, parse_time)
        case None:
            return GrammarTestResult.success(test.name, parse_time)

# Check tree structure matches expected
fn check_tree_structure(node: Node, expected: TreeStructure, tree: Tree) -> Result<Nil, String>:
    # Check node kind
    if node.kind != expected.kind:
        return Err(f"Expected node kind '{expected.kind}', got '{node.kind}'")

    # Check children count
    if node.children.len() != expected.children.len():
        return Err(f"Expected {expected.children.len()} children, got {node.children.len()}")

    # Check each child
    for i in 0..expected.children.len():
        val child_id = node.children[i]
        val child = tree.get_node(child_id)?
        val expected_child = expected.children[i]

        check_tree_structure(child, expected_child, tree)?

    # Check fields
    for field_name in expected.fields.keys():
        match node.fields.get(field_name):
            case None:
                return Err(f"Missing field '{field_name}'")
            case Some(field_id):
                val field_node = tree.get_node(field_id)?
                val expected_field = expected.fields[field_name]
                check_tree_structure(field_node, expected_field, tree)?

    Ok(nil)

# Grammar test builder (fluent API)
class GrammarTestBuilder:
    tests: List<GrammarTestCase>

    static fn new() -> GrammarTestBuilder:
        GrammarTestBuilder(tests: [])

    var fn test(name: String,
        language: String,
        source: String,
        expected_kind: String
    ) -> GrammarTestBuilder:
        self.tests.push(GrammarTestCase.new(name, language, source, expected_kind))
        self

    var fn test_with_structure(name: String,
        language: String,
        source: String,
        structure: TreeStructure
    ) -> GrammarTestBuilder:
        val test = GrammarTestCase.new(name, language, source, structure.kind)
            .with_structure(structure)
        self.tests.push(test)
        self

    var fn test_error(name: String,
        language: String,
        source: String
    ) -> GrammarTestBuilder:
        val test = GrammarTestCase.new(name, language, source, "source_file")
            .expect_error()
        self.tests.push(test)
        self

    fn build() -> GrammarTestSuite:
        val suite = GrammarTestSuite.new("Grammar Tests")
        for test in self.tests:
            suite.add_test(test)
        suite

# Snapshot testing support
class GrammarSnapshot:
    name: String
    source: String
    tree_repr: String  # Tree representation

    fn new(name: String, source: String, tree_repr: String) -> GrammarSnapshot:
        GrammarSnapshot(
            name: name,
            source: source,
            tree_repr: tree_repr
        )

    fn from_parse(name: String, source: String, language: String) -> Result<GrammarSnapshot, String>:
        val parser = TreeSitterParser.new(language)?
        val tree = parser.parse(source)?

        val tree_repr = tree_to_string(tree.root_node, tree, 0)

        Ok(GrammarSnapshot.new(name, source, tree_repr))

    fn verify(language: String) -> Result<Bool, String>:
        # Re-parse and compare
        val parser = TreeSitterParser.new(language)?
        val tree = parser.parse(self.source)?

        val current_repr = tree_to_string(tree.root_node, tree, 0)

        Ok(current_repr == self.tree_repr)

# Convert tree to string representation
fn tree_to_string(node: Node, tree: Tree, indent: Int) -> String:
    val indent_str = "  ".repeat(indent)
    var result = f"{indent_str}{node.kind}"

    # Add span info
    result = result + f" [{node.span.start_line}:{node.span.start_column}-{node.span.end_line}:{node.span.end_column}]"

    # Add children
    if node.children.len() > 0:
        result = result + "\n"
        for child_id in node.children:
            match tree.get_node(child_id):
                case Ok(child):
                    result = result + tree_to_string(child, tree, indent + 1) + "\n"
                case Err(_):
                    pass

    result

# Corpus testing (multiple test files)
class GrammarCorpus:
    name: String
    language: String
    test_files: List<CorpusTestFile>

    fn new(name: String, language: String) -> GrammarCorpus:
        GrammarCorpus(
            name: name,
            language: language,
            test_files: []
        )

    var fn add_file(file: CorpusTestFile):
        self.test_files.push(file)

    fn run() -> GrammarCorpusResult:
        print(f"\n=== {self.name} Corpus ===\n")

        var results: List<CorpusFileResult> = []
        var total_passed = 0
        var total_failed = 0

        for test_file in self.test_files:
            val result = run_corpus_file(test_file, self.language)

            if result.all_passed:
                total_passed = total_passed + 1
            else:
                total_failed = total_failed + 1

            results.push(result)

        print(f"\n{total_passed} files passed, {total_failed} files failed\n")

        GrammarCorpusResult(
            corpus_name: self.name,
            results: results,
            passed_count: total_passed,
            failed_count: total_failed
        )

# Corpus test file
class CorpusTestFile:
    path: String
    source: String
    expected_no_errors: Bool

    fn new(path: String, source: String) -> CorpusTestFile:
        CorpusTestFile(
            path: path,
            source: source,
            expected_no_errors: true
        )

    var fn allow_errors() -> CorpusTestFile:
        self.expected_no_errors = false
        self

# Corpus file result
class CorpusFileResult:
    file_path: String
    all_passed: Bool
    error_count: Int
    parse_time_ms: Float

    fn print_summary():
        if self.all_passed:
            print(f"✅ {self.file_path} ({self.parse_time_ms:.2f}ms)")
        else:
            print(f"❌ {self.file_path} - {self.error_count} errors")

# Corpus result
class GrammarCorpusResult:
    corpus_name: String
    results: List<CorpusFileResult>
    passed_count: Int
    failed_count: Int

    fn print_summary():
        print(f"\n=== {self.corpus_name} Summary ===")
        print(f"Files: {self.passed_count + self.failed_count}")
        print(f"Passed: {self.passed_count}")
        print(f"Failed: {self.failed_count}")

# Run corpus file test
fn run_corpus_file(file: CorpusTestFile, language: String) -> CorpusFileResult:
    val parser = match TreeSitterParser.new(language):
        case Ok(p): p
        case Err(e):
            return CorpusFileResult(
                file_path: file.path,
                all_passed: false,
                error_count: 1,
                parse_time_ms: 0.0
            )

    val start_time = sys.time.now_ms()
    val tree = match parser.parse(file.source):
        case Ok(t): t
        case Err(e):
            val parse_time = sys.time.now_ms() - start_time
            return CorpusFileResult(
                file_path: file.path,
                all_passed: false,
                error_count: 1,
                parse_time_ms: parse_time
            )
    val parse_time = sys.time.now_ms() - start_time

    # Count errors
    val error_count = count_errors(tree.root_node, tree)

    val all_passed = if file.expected_no_errors:
        error_count == 0
    else:
        true

    CorpusFileResult(
        file_path: file.path,
        all_passed: all_passed,
        error_count: error_count,
        parse_time_ms: parse_time
    )

# Count ERROR nodes in tree
fn count_errors(node: Node, tree: Tree) -> Int:
    var count = 0

    if node.kind == "ERROR":
        count = count + 1

    for child_id in node.children:
        match tree.get_node(child_id):
            case Ok(child):
                count = count + count_errors(child, tree)
            case Err(_):
                pass

    count
