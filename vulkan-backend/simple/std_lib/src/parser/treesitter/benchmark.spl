# Tree-sitter Performance Benchmarking
# Measure parsing and query performance

import sys.time as time
import parser.treesitter.{TreeSitterParser, Query, QueryCursor}

# Benchmark result
class BenchmarkResult:
    name: String
    iterations: Int
    total_time_ms: Float
    avg_time_ms: Float
    min_time_ms: Float
    max_time_ms: Float
    lines_of_code: Int

    fn new(name: String, iterations: Int, times_ms: List<Float>, lines: Int) -> BenchmarkResult:
        val total = times_ms.sum()
        val avg = total / iterations
        val min_time = times_ms.min().unwrap_or(0.0)
        val max_time = times_ms.max().unwrap_or(0.0)

        BenchmarkResult(
            name: name,
            iterations: iterations,
            total_time_ms: total,
            avg_time_ms: avg,
            min_time_ms: min_time,
            max_time_ms: max_time,
            lines_of_code: lines
        )

    fn print_summary():
        print(f"\n=== {self.name} ===")
        print(f"Iterations: {self.iterations}")
        print(f"Lines of code: {self.lines_of_code}")
        print(f"Average time: {self.avg_time_ms:.2f} ms")
        print(f"Min time: {self.min_time_ms:.2f} ms")
        print(f"Max time: {self.max_time_ms:.2f} ms")
        print(f"Total time: {self.total_time_ms:.2f} ms")

        if self.lines_of_code > 0:
            val lines_per_ms = self.lines_of_code / self.avg_time_ms
            print(f"Throughput: {lines_per_ms:.0f} lines/ms")

# Benchmark parsing performance
fn benchmark_parse(source: String, iterations: Int) -> BenchmarkResult:
    val parser = TreeSitterParser.new("simple").unwrap()
    var times_ms: List<Float> = []
    val line_count = source.split("\n").len()

    for i in 0..iterations:
        val start = time.now_ms()
        val tree = parser.parse(source).unwrap()
        val end = time.now_ms()

        val elapsed = end - start
        times_ms.push(elapsed)

    BenchmarkResult.new("Parse", iterations, times_ms, line_count)

# Benchmark incremental parsing performance
fn benchmark_incremental_parse(
    original: String,
    modified: String,
    iterations: Int
) -> BenchmarkResult:
    val parser = TreeSitterParser.new("simple").unwrap()
    val line_count = modified.split("\n").len()

    # Pre-parse original
    val old_tree = parser.parse(original).unwrap()

    var times_ms: List<Float> = []

    for i in 0..iterations:
        # Compute edits
        val edits = parser.treesitter.edits.compute_edits(original, modified)

        val start = time.now_ms()
        val new_tree = parser.parse_incremental(modified, old_tree, edits).unwrap()
        val end = time.now_ms()

        val elapsed = end - start
        times_ms.push(elapsed)

    BenchmarkResult.new("Incremental Parse", iterations, times_ms, line_count)

# Benchmark query execution performance
fn benchmark_query(source: String, iterations: Int) -> BenchmarkResult:
    val parser = TreeSitterParser.new("simple").unwrap()
    val tree = parser.parse(source).unwrap()
    val line_count = source.split("\n").len()

    # Create highlighting query
    val query = Query.new("simple", "").unwrap()

    var times_ms: List<Float> = []

    for i in 0..iterations:
        val start = time.now_ms()

        val cursor = QueryCursor.new(query, tree)
        val matches = cursor.all_matches()

        # Force evaluation
        val match_count = matches.len()

        val end = time.now_ms()

        val elapsed = end - start
        times_ms.push(elapsed)

    BenchmarkResult.new("Query Execution", iterations, times_ms, line_count)

# Generate test source code of specific size
fn generate_test_source(num_lines: Int) -> String:
    var source = ""

    # Generate functions
    for i in 0..(num_lines / 10):
        source = source + f"fn func_{i}(x: i32, y: i32):\n"
        source = source + f"    val result = x + y\n"
        source = source + f"    if result > 0:\n"
        source = source + f"        return result\n"
        source = source + f"    else:\n"
        source = source + f"        return 0\n"
        source = source + f"\n"

    # Generate variables
    for i in 0..(num_lines / 20):
        source = source + f"val var_{i} = {i}\n"

    # Generate match statements
    for i in 0..(num_lines / 30):
        source = source + f"match var_{i}:\n"
        source = source + f"    case 0: return 'zero'\n"
        source = source + f"    case 1: return 'one'\n"
        source = source + f"    case _: return 'other'\n"
        source = source + f"\n"

    source

# Run comprehensive benchmark suite
fn run_benchmarks():
    print("=== Tree-sitter Performance Benchmarks ===\n")

    # Small file (100 lines)
    print("\n--- Small File (100 lines) ---")
    val small_source = generate_test_source(100)
    val small_parse = benchmark_parse(small_source, 100)
    small_parse.print_summary()

    val small_query = benchmark_query(small_source, 100)
    small_query.print_summary()

    # Medium file (1000 lines)
    print("\n--- Medium File (1000 lines) ---")
    val medium_source = generate_test_source(1000)
    val medium_parse = benchmark_parse(medium_source, 50)
    medium_parse.print_summary()

    val medium_query = benchmark_query(medium_source, 50)
    medium_query.print_summary()

    # Large file (10000 lines)
    print("\n--- Large File (10000 lines) ---")
    val large_source = generate_test_source(10000)
    val large_parse = benchmark_parse(large_source, 10)
    large_parse.print_summary()

    val large_query = benchmark_query(large_source, 10)
    large_query.print_summary()

    # Incremental parsing benchmark
    print("\n--- Incremental Parsing (1-line edit in 1000-line file) ---")
    val original = generate_test_source(1000)
    val modified = original.replace("val result = x + y", "val result = x * y")
    val incremental = benchmark_incremental_parse(original, modified, 100)
    incremental.print_summary()

    # Performance targets
    print("\n=== Performance Targets ===")
    print("Target for 1000 lines: < 20ms")
    if medium_parse.avg_time_ms < 20.0:
        print(f"✅ PASS: {medium_parse.avg_time_ms:.2f} ms < 20 ms")
    else:
        print(f"❌ FAIL: {medium_parse.avg_time_ms:.2f} ms >= 20 ms")

    print("\nTarget for incremental parse: < 5ms")
    if incremental.avg_time_ms < 5.0:
        print(f"✅ PASS: {incremental.avg_time_ms:.2f} ms < 5 ms")
    else:
        print(f"❌ FAIL: {incremental.avg_time_ms:.2f} ms >= 5 ms")

# Hot spot profiling
fn profile_hot_spots(source: String):
    print("\n=== Profiling Hot Spots ===")

    val parser = TreeSitterParser.new("simple").unwrap()

    # Profile parsing phases
    val start_total = time.now_ms()

    val start_lex = time.now_ms()
    # Lexing happens inside parse
    val end_lex = time.now_ms()

    val start_parse = time.now_ms()
    val tree = parser.parse(source).unwrap()
    val end_parse = time.now_ms()

    val start_query = time.now_ms()
    val query = Query.new("simple", "").unwrap()
    val cursor = QueryCursor.new(query, tree)
    val matches = cursor.all_matches()
    val end_query = time.now_ms()

    val end_total = time.now_ms()

    print(f"Total time: {end_total - start_total:.2f} ms")
    print(f"Parsing: {end_parse - start_parse:.2f} ms")
    print(f"Query execution: {end_query - start_query:.2f} ms")

    # Breakdown
    val parse_percent = ((end_parse - start_parse) / (end_total - start_total)) * 100.0
    val query_percent = ((end_query - start_query) / (end_total - start_total)) * 100.0

    print(f"\nBreakdown:")
    print(f"Parsing: {parse_percent:.1f}%")
    print(f"Query: {query_percent:.1f}%")
