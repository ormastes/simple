# Rust Language Grammar for Tree-sitter
# Complete Rust grammar implementation

import parser.treesitter.{Grammar, Token}

class RustGrammar:
    grammar: Grammar

    fn new() -> RustGrammar:
        let mut grammar = Grammar.new("rust")

        # Set entry point
        grammar.entry_point = "source_file"

        # Build all grammar rules
        let mut builder = RustGrammarBuilder(grammar: grammar)
        builder.build_grammar()

        RustGrammar(grammar: builder.grammar)

class RustGrammarBuilder:
    grammar: Grammar

    fn build_grammar(mut self):
        # Entry point
        self.add_source_file()

        # Items (declarations)
        self.add_items()

        # Statements
        self.add_statements()

        # Expressions
        self.add_expressions()

        # Patterns
        self.add_patterns()

        # Types
        self.add_types()

        # Common elements
        self.add_common()

    # Source file (entry point)
    fn add_source_file(mut self):
        self.grammar.add_rule("source_file", repeat(choice([
            ref("item"),
            ref("attribute"),
            token(Newline)
        ])))

    # Items (top-level declarations)
    fn add_items(mut self):
        self.grammar.add_rule("item", choice([
            ref("function_item"),
            ref("struct_item"),
            ref("enum_item"),
            ref("trait_item"),
            ref("impl_item"),
            ref("mod_item"),
            ref("use_item"),
            ref("const_item"),
            ref("static_item"),
            ref("type_alias")
        ]))

        # Function
        self.grammar.add_rule("function_item", seq([
            optional(ref("visibility")),
            optional(token(Const)),
            optional(token(Async)),
            optional(token(Unsafe)),
            optional(ref("extern_abi")),
            token(Fn),
            field("name", ref("identifier")),
            optional(ref("generic_params")),
            token(LParen),
            optional(ref("parameters")),
            token(RParen),
            optional(seq([token(Arrow), field("return_type", ref("type"))])),
            optional(ref("where_clause")),
            ref("block")
        ]))

        # Struct
        self.grammar.add_rule("struct_item", seq([
            optional(ref("visibility")),
            token(Struct),
            field("name", ref("type_identifier")),
            optional(ref("generic_params")),
            optional(ref("where_clause")),
            choice([
                seq([token(Semicolon)]),  # Unit struct
                seq([  # Tuple struct
                    token(LParen),
                    optional(ref("tuple_fields")),
                    token(RParen),
                    token(Semicolon)
                ]),
                seq([  # Struct with fields
                    token(LBrace),
                    optional(ref("fields")),
                    token(RBrace)
                ])
            ])
        ]))

        # Enum
        self.grammar.add_rule("enum_item", seq([
            optional(ref("visibility")),
            token(Enum),
            field("name", ref("type_identifier")),
            optional(ref("generic_params")),
            optional(ref("where_clause")),
            token(LBrace),
            optional(ref("enum_variants")),
            token(RBrace)
        ]))

        self.grammar.add_rule("enum_variants", seq([
            ref("enum_variant"),
            repeat(seq([token(Comma), ref("enum_variant")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("enum_variant", seq([
            optional(ref("attribute")),
            ref("identifier"),
            optional(choice([
                seq([token(LParen), optional(ref("tuple_fields")), token(RParen)]),
                seq([token(LBrace), optional(ref("fields")), token(RBrace)])
            ]))
        ]))

        # Trait
        self.grammar.add_rule("trait_item", seq([
            optional(ref("visibility")),
            optional(token(Unsafe)),
            token(Trait),
            field("name", ref("type_identifier")),
            optional(ref("generic_params")),
            optional(ref("type_bounds")),
            optional(ref("where_clause")),
            token(LBrace),
            repeat(ref("trait_member")),
            token(RBrace)
        ]))

        self.grammar.add_rule("trait_member", choice([
            ref("function_signature"),
            ref("associated_type"),
            ref("const_item")
        ]))

        # Impl
        self.grammar.add_rule("impl_item", seq([
            optional(token(Unsafe)),
            token(Impl),
            optional(ref("generic_params")),
            choice([
                seq([ref("type"), token(For), ref("type")]),  # Trait impl
                ref("type")  # Inherent impl
            ]),
            optional(ref("where_clause")),
            token(LBrace),
            repeat(ref("impl_member")),
            token(RBrace)
        ]))

        self.grammar.add_rule("impl_member", choice([
            ref("function_item"),
            ref("const_item"),
            ref("type_alias")
        ]))

        # Module
        self.grammar.add_rule("mod_item", seq([
            optional(ref("visibility")),
            token(Mod),
            ref("identifier"),
            choice([
                token(Semicolon),
                seq([token(LBrace), repeat(ref("item")), token(RBrace)])
            ])
        ]))

        # Use
        self.grammar.add_rule("use_item", seq([
            optional(ref("visibility")),
            token(Use),
            ref("use_tree"),
            token(Semicolon)
        ]))

        self.grammar.add_rule("use_tree", choice([
            ref("use_path"),
            seq([ref("use_path"), token(As), ref("identifier")]),
            seq([ref("use_path"), token(ColonColon), token(Star)]),
            seq([ref("use_path"), token(ColonColon), token(LBrace), ref("use_list"), token(RBrace)])
        ]))

        # Const/static
        self.grammar.add_rule("const_item", seq([
            optional(ref("visibility")),
            token(Const),
            ref("identifier"),
            token(Colon),
            ref("type"),
            token(Equals),
            ref("expression"),
            token(Semicolon)
        ]))

        self.grammar.add_rule("static_item", seq([
            optional(ref("visibility")),
            token(Static),
            optional(token(Mut)),
            ref("identifier"),
            token(Colon),
            ref("type"),
            token(Equals),
            ref("expression"),
            token(Semicolon)
        ]))

        # Type alias
        self.grammar.add_rule("type_alias", seq([
            optional(ref("visibility")),
            token(Type),
            ref("type_identifier"),
            optional(ref("generic_params")),
            token(Equals),
            ref("type"),
            token(Semicolon)
        ]))

    # Statements
    fn add_statements(mut self):
        self.grammar.add_rule("statement", choice([
            ref("let_statement"),
            ref("expression_statement"),
            ref("item")
        ]))

        self.grammar.add_rule("let_statement", seq([
            token(Let),
            optional(token(Mut)),
            ref("pattern"),
            optional(seq([token(Colon), ref("type")])),
            optional(seq([token(Equals), ref("expression")])),
            token(Semicolon)
        ]))

        self.grammar.add_rule("expression_statement", seq([
            ref("expression"),
            optional(token(Semicolon))
        ]))

    # Expressions
    fn add_expressions(mut self):
        # Expression hierarchy (precedence order)
        self.grammar.add_rule("expression", choice([
            ref("return_expression"),
            ref("break_expression"),
            ref("continue_expression"),
            ref("range_expression")
        ]))

        self.grammar.add_rule("return_expression", seq([
            token(Return),
            optional(ref("expression"))
        ]))

        self.grammar.add_rule("break_expression", seq([
            token(Break),
            optional(ref("expression"))
        ]))

        self.grammar.add_rule("continue_expression", token(Continue))

        self.grammar.add_rule("range_expression", binary_op(
            ref("or_expression"),
            choice([token(DotDot), token(DotDotEquals)])
        ))

        self.grammar.add_rule("or_expression", binary_op(
            ref("and_expression"),
            token(PipePipe)
        ))

        self.grammar.add_rule("and_expression", binary_op(
            ref("comparison"),
            token(AmpersandAmpersand)
        ))

        self.grammar.add_rule("comparison", binary_op(
            ref("bitwise_or"),
            choice([
                token(Less), token(Greater), token(LessEquals),
                token(GreaterEquals), token(EqualsEquals), token(NotEquals)
            ])
        ))

        self.grammar.add_rule("bitwise_or", binary_op(
            ref("bitwise_xor"),
            token(Pipe)
        ))

        self.grammar.add_rule("bitwise_xor", binary_op(
            ref("bitwise_and"),
            token(Caret)
        ))

        self.grammar.add_rule("bitwise_and", binary_op(
            ref("shift_expression"),
            token(Ampersand)
        ))

        self.grammar.add_rule("shift_expression", binary_op(
            ref("additive_expression"),
            choice([token(LShift), token(RShift)])
        ))

        self.grammar.add_rule("additive_expression", binary_op(
            ref("multiplicative_expression"),
            choice([token(Plus), token(Minus)])
        ))

        self.grammar.add_rule("multiplicative_expression", binary_op(
            ref("cast_expression"),
            choice([token(Star), token(Slash), token(Percent)])
        ))

        self.grammar.add_rule("cast_expression", binary_op(
            ref("unary_expression"),
            token(As)
        ))

        self.grammar.add_rule("unary_expression", choice([
            seq([choice([token(Minus), token(Not), token(Star), token(Ampersand)]), ref("primary_expression")]),
            ref("primary_expression")
        ]))

        # Primary expressions
        self.grammar.add_rule("primary_expression", choice([
            ref("literal_expression"),
            ref("identifier"),
            ref("call_expression"),
            ref("field_expression"),
            ref("index_expression"),
            ref("macro_invocation"),
            ref("struct_expression"),
            ref("tuple_expression"),
            ref("array_expression"),
            ref("parenthesized_expression"),
            ref("block_expression"),
            ref("if_expression"),
            ref("match_expression"),
            ref("while_expression"),
            ref("for_expression"),
            ref("loop_expression"),
            ref("closure_expression")
        ]))

        # Literals
        self.grammar.add_rule("literal_expression", choice([
            token(Integer),
            token(Float),
            token(String),
            token(Char),
            token(True),
            token(False)
        ]))

        # Call/field/index
        self.grammar.add_rule("call_expression", seq([
            ref("expression"),
            token(LParen),
            optional(ref("argument_list")),
            token(RParen)
        ]))

        self.grammar.add_rule("field_expression", seq([
            ref("expression"),
            token(Dot),
            choice([ref("identifier"), token(Integer)])
        ]))

        self.grammar.add_rule("index_expression", seq([
            ref("expression"),
            token(LBracket),
            ref("expression"),
            token(RBracket)
        ]))

        # Struct/tuple/array
        self.grammar.add_rule("struct_expression", seq([
            ref("type"),
            token(LBrace),
            optional(ref("field_initializers")),
            token(RBrace)
        ]))

        self.grammar.add_rule("tuple_expression", seq([
            token(LParen),
            optional(ref("expression_list")),
            token(RParen)
        ]))

        self.grammar.add_rule("array_expression", seq([
            token(LBracket),
            optional(ref("array_elements")),
            token(RBracket)
        ]))

        # Control flow
        self.grammar.add_rule("block_expression", seq([
            token(LBrace),
            repeat(ref("statement")),
            optional(ref("expression")),
            token(RBrace)
        ]))

        self.grammar.add_rule("if_expression", seq([
            token(If),
            ref("expression"),
            ref("block"),
            optional(seq([token(Else), choice([ref("if_expression"), ref("block")])]))
        ]))

        self.grammar.add_rule("match_expression", seq([
            token(Match),
            ref("expression"),
            token(LBrace),
            repeat(ref("match_arm")),
            token(RBrace)
        ]))

        self.grammar.add_rule("while_expression", seq([
            token(While),
            ref("expression"),
            ref("block")
        ]))

        self.grammar.add_rule("for_expression", seq([
            token(For),
            ref("pattern"),
            token(In),
            ref("expression"),
            ref("block")
        ]))

        self.grammar.add_rule("loop_expression", seq([
            token(Loop),
            ref("block")
        ]))

        self.grammar.add_rule("closure_expression", seq([
            token(Pipe),
            optional(ref("closure_parameters")),
            token(Pipe),
            choice([ref("expression"), ref("block")])
        ]))

    # Patterns
    fn add_patterns(mut self):
        self.grammar.add_rule("pattern", choice([
            ref("literal_pattern"),
            ref("identifier_pattern"),
            ref("wildcard_pattern"),
            ref("tuple_pattern"),
            ref("struct_pattern"),
            ref("or_pattern"),
            ref("ref_pattern")
        ]))

        self.grammar.add_rule("literal_pattern", ref("literal_expression"))
        self.grammar.add_rule("identifier_pattern", ref("identifier"))
        self.grammar.add_rule("wildcard_pattern", token(Underscore))

        self.grammar.add_rule("tuple_pattern", seq([
            token(LParen),
            optional(ref("pattern_list")),
            token(RParen)
        ]))

        self.grammar.add_rule("struct_pattern", seq([
            ref("type"),
            token(LBrace),
            optional(ref("field_patterns")),
            token(RBrace)
        ]))

        self.grammar.add_rule("or_pattern", binary_op(
            ref("pattern"),
            token(Pipe)
        ))

        self.grammar.add_rule("ref_pattern", seq([
            token(Ref),
            optional(token(Mut)),
            ref("pattern")
        ]))

    # Types
    fn add_types(mut self):
        self.grammar.add_rule("type", choice([
            ref("primitive_type"),
            ref("type_identifier"),
            ref("generic_type"),
            ref("reference_type"),
            ref("pointer_type"),
            ref("tuple_type"),
            ref("array_type"),
            ref("function_type"),
            ref("impl_trait_type"),
            ref("dyn_trait_type")
        ]))

        self.grammar.add_rule("primitive_type", choice([
            token(I8), token(I16), token(I32), token(I64), token(I128),
            token(U8), token(U16), token(U32), token(U64), token(U128),
            token(F32), token(F64),
            token(Bool), token(Char), token(Str)
        ]))

        self.grammar.add_rule("generic_type", seq([
            ref("type"),
            token(Less),
            ref("type_list"),
            token(Greater)
        ]))

        self.grammar.add_rule("reference_type", seq([
            token(Ampersand),
            optional(ref("lifetime")),
            optional(token(Mut)),
            ref("type")
        ]))

        self.grammar.add_rule("pointer_type", seq([
            token(Star),
            choice([token(Const), token(Mut)]),
            ref("type")
        ]))

        self.grammar.add_rule("tuple_type", seq([
            token(LParen),
            optional(ref("type_list")),
            token(RParen)
        ]))

        self.grammar.add_rule("array_type", seq([
            token(LBracket),
            ref("type"),
            token(Semicolon),
            ref("expression"),
            token(RBracket)
        ]))

        self.grammar.add_rule("function_type", seq([
            token(Fn),
            token(LParen),
            optional(ref("type_list")),
            token(RParen),
            optional(seq([token(Arrow), ref("type")]))
        ]))

        self.grammar.add_rule("impl_trait_type", seq([
            token(Impl),
            ref("type_bounds")
        ]))

        self.grammar.add_rule("dyn_trait_type", seq([
            token(Dyn),
            ref("type_bounds")
        ]))

    # Common elements
    fn add_common(mut self):
        self.grammar.add_rule("identifier", token(Identifier))
        self.grammar.add_rule("type_identifier", token(TypeIdentifier))

        self.grammar.add_rule("visibility", choice([
            token(Pub),
            seq([token(Pub), token(LParen), ref("visibility_modifier"), token(RParen)])
        ]))

        self.grammar.add_rule("visibility_modifier", choice([
            token(Crate),
            token(Super),
            token(SelfValue),
            seq([token(In), ref("use_path")])
        ]))

        self.grammar.add_rule("generic_params", seq([
            token(Less),
            ref("generic_param_list"),
            token(Greater)
        ]))

        self.grammar.add_rule("where_clause", seq([
            token(Where),
            ref("where_predicates")
        ]))

        self.grammar.add_rule("type_bounds", seq([
            ref("type"),
            repeat(seq([token(Plus), ref("type")]))
        ]))

        self.grammar.add_rule("lifetime", token(Lifetime))

        self.grammar.add_rule("attribute", seq([
            token(Hash),
            token(LBracket),
            ref("attribute_item"),
            token(RBracket)
        ]))

        self.grammar.add_rule("parameters", seq([
            ref("parameter"),
            repeat(seq([token(Comma), ref("parameter")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("parameter", seq([
            optional(token(Mut)),
            ref("pattern"),
            token(Colon),
            ref("type")
        ]))

        self.grammar.add_rule("block", seq([
            token(LBrace),
            repeat(ref("statement")),
            optional(ref("expression")),
            token(RBrace)
        ]))

        self.grammar.add_rule("match_arm", seq([
            ref("pattern"),
            optional(seq([token(If), ref("expression")])),
            token(FatArrow),
            ref("expression"),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("fields", seq([
            ref("field"),
            repeat(seq([token(Comma), ref("field")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("field", seq([
            optional(ref("visibility")),
            ref("identifier"),
            token(Colon),
            ref("type")
        ]))

        self.grammar.add_rule("tuple_fields", seq([
            ref("tuple_field"),
            repeat(seq([token(Comma), ref("tuple_field")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("tuple_field", seq([
            optional(ref("visibility")),
            ref("type")
        ]))

        self.grammar.add_rule("expression_list", seq([
            ref("expression"),
            repeat(seq([token(Comma), ref("expression")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("type_list", seq([
            ref("type"),
            repeat(seq([token(Comma), ref("type")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("pattern_list", seq([
            ref("pattern"),
            repeat(seq([token(Comma), ref("pattern")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("use_path", seq([
            ref("identifier"),
            repeat(seq([token(ColonColon), ref("identifier")]))
        ]))

        self.grammar.add_rule("use_list", seq([
            ref("use_tree"),
            repeat(seq([token(Comma), ref("use_tree")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("argument_list", seq([
            ref("expression"),
            repeat(seq([token(Comma), ref("expression")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("field_initializers", seq([
            ref("field_initializer"),
            repeat(seq([token(Comma), ref("field_initializer")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("field_initializer", seq([
            ref("identifier"),
            token(Colon),
            ref("expression")
        ]))

        self.grammar.add_rule("field_patterns", seq([
            ref("field_pattern"),
            repeat(seq([token(Comma), ref("field_pattern")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("field_pattern", seq([
            ref("identifier"),
            optional(seq([token(Colon), ref("pattern")]))
        ]))

        self.grammar.add_rule("array_elements", choice([
            ref("expression_list"),
            seq([ref("expression"), token(Semicolon), ref("expression")])
        ]))

        self.grammar.add_rule("closure_parameters", seq([
            ref("closure_parameter"),
            repeat(seq([token(Comma), ref("closure_parameter")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("closure_parameter", seq([
            ref("pattern"),
            optional(seq([token(Colon), ref("type")]))
        ]))

        self.grammar.add_rule("macro_invocation", seq([
            ref("identifier"),
            token(Bang),
            choice([
                seq([token(LParen), token(RParen)]),
                seq([token(LBracket), token(RBracket)]),
                seq([token(LBrace), token(RBrace)])
            ])
        ]))

        self.grammar.add_rule("extern_abi", seq([
            token(Extern),
            optional(token(String))
        ]))

        self.grammar.add_rule("function_signature", seq([
            token(Fn),
            ref("identifier"),
            optional(ref("generic_params")),
            token(LParen),
            optional(ref("parameters")),
            token(RParen),
            optional(seq([token(Arrow), ref("type")])),
            token(Semicolon)
        ]))

        self.grammar.add_rule("associated_type", seq([
            token(Type),
            ref("type_identifier"),
            optional(ref("type_bounds")),
            token(Semicolon)
        ]))

        self.grammar.add_rule("generic_param_list", seq([
            ref("generic_param"),
            repeat(seq([token(Comma), ref("generic_param")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("generic_param", choice([
            seq([ref("lifetime"), optional(ref("lifetime_bounds"))]),
            seq([ref("type_identifier"), optional(ref("type_bounds"))]),
            seq([token(Const), ref("identifier"), token(Colon), ref("type")])
        ]))

        self.grammar.add_rule("lifetime_bounds", seq([
            token(Colon),
            ref("lifetime"),
            repeat(seq([token(Plus), ref("lifetime")]))
        ]))

        self.grammar.add_rule("where_predicates", seq([
            ref("where_predicate"),
            repeat(seq([token(Comma), ref("where_predicate")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("where_predicate", seq([
            choice([ref("lifetime"), ref("type")]),
            token(Colon),
            ref("type_bounds")
        ]))

        self.grammar.add_rule("attribute_item", ref("use_path"))

        self.grammar.add_rule("parenthesized_expression", seq([
            token(LParen),
            ref("expression"),
            token(RParen)
        ]))
