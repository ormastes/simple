# HTTP Request Parser
#
# Parses raw TCP bytes into structured HttpRequest.

use units.net.*
use units.size.*
use host.async_nogc_mut.net.tcp.TcpStream
use host.common.io.error.IoError

# HTTP Methods
pub enum HttpMethod:
    Get
    Post
    Put
    Delete
    Patch
    Head
    Options
    Connect
    Trace

impl HttpMethod:
    pub fn from_str(s: &str) -> Option[HttpMethod]:
        match s.to_upper():
            case "GET": Some(HttpMethod::Get)
            case "POST": Some(HttpMethod::Post)
            case "PUT": Some(HttpMethod::Put)
            case "DELETE": Some(HttpMethod::Delete)
            case "PATCH": Some(HttpMethod::Patch)
            case "HEAD": Some(HttpMethod::Head)
            case "OPTIONS": Some(HttpMethod::Options)
            case "CONNECT": Some(HttpMethod::Connect)
            case "TRACE": Some(HttpMethod::Trace)
            case _: None

    pub fn to_str(self) -> &str:
        match self:
            case Get: "GET"
            case Post: "POST"
            case Put: "PUT"
            case Delete: "DELETE"
            case Patch: "PATCH"
            case Head: "HEAD"
            case Options: "OPTIONS"
            case Connect: "CONNECT"
            case Trace: "TRACE"

# HTTP Error types
pub enum HttpError:
    # Parsing errors
    InvalidRequestLine
    InvalidHeader
    InvalidMethod
    InvalidPath
    InvalidVersion
    # Body errors
    NoBody
    InvalidJson
    InvalidForm
    BodyTooLarge
    # Connection errors
    ConnectionClosed
    ReadTimeout
    WriteTimeout
    # IO wrapper
    IoError(IoError)

impl HttpError:
    pub fn to_str(self) -> str:
        match self:
            case InvalidRequestLine: "Invalid request line"
            case InvalidHeader: "Invalid header"
            case InvalidMethod: "Invalid HTTP method"
            case InvalidPath: "Invalid path"
            case InvalidVersion: "Invalid HTTP version"
            case NoBody: "No request body"
            case InvalidJson: "Invalid JSON body"
            case InvalidForm: "Invalid form body"
            case BodyTooLarge: "Request body too large"
            case ConnectionClosed: "Connection closed"
            case ReadTimeout: "Read timeout"
            case WriteTimeout: "Write timeout"
            case IoError(e): f"IO error: {e}"

# Parsed HTTP Request
pub struct HttpRequest:
    method: HttpMethod
    path: str
    query: Dict[str, str]
    headers: Dict[str, str]
    body: Option[Bytes]
    version: str
    remote_addr: SocketAddr

impl HttpRequest:
    # Parse request from TCP stream
    pub async fn parse(stream: &TcpStream) -> Result[HttpRequest, HttpError]:
        # Read initial buffer (request line + headers)
        var buf = Bytes::with_capacity(8192)
        val n = await stream.read(&mut buf).map_err(|e| HttpError::IoError(e))?

        if n == 0:
            return Err(HttpError::ConnectionClosed)

        # Find end of headers (double CRLF)
        val header_end = find_header_end(&buf)
        if header_end.is_none():
            return Err(HttpError::InvalidRequestLine)

        val header_bytes = buf.slice(0, header_end.unwrap())
        val header_str = header_bytes.to_utf8().map_err(|_| HttpError::InvalidRequestLine)?

        # Parse request line
        val lines = header_str.split("\r\n")
        if lines.is_empty():
            return Err(HttpError::InvalidRequestLine)

        val request_line = lines[0]
        val (method, path, query, version) = parse_request_line(&request_line)?

        # Parse headers
        var headers: Dict[str, str] = Dict::new()
        for i in 1..lines.len():
            val line = lines[i]
            if line.is_empty():
                break
            if val Some((name, value)) = parse_header_line(&line):
                headers.insert(name.to_lower(), value)

        # Parse body if Content-Length present
        val body = if val Some(len_str) = headers.get("content-length"):
            val len = len_str.parse_u64().map_err(|_| HttpError::InvalidHeader)?
            if len > 0:
                val body_start = header_end.unwrap() + 4  # Skip \r\n\r\n
                var body_buf = Bytes::with_capacity(len as usize)

                # Copy already-read body bytes
                val already_read = buf.len() - body_start
                if already_read > 0:
                    body_buf.extend(buf.slice(body_start, buf.len()))

                # Read remaining body
                val remaining = len - (already_read as u64)
                if remaining > 0:
                    var rest = Bytes::with_capacity(remaining as usize)
                    await stream.read_exact(&mut rest).map_err(|e| HttpError::IoError(e))?
                    body_buf.extend(&rest)

                Some(body_buf)
            else:
                None
        else:
            None

        return Ok(HttpRequest {
            method: method,
            path: path,
            query: query,
            headers: headers,
            body: body,
            version: version,
            remote_addr: stream.peer_addr()
        })

    # Accessors
    pub fn method(self) -> HttpMethod:
        return self.method

    pub fn path(self) -> &str:
        return &self.path

    pub fn query_param(self, name: &str) -> Option[&str]:
        return self.query.get(name)

    pub fn header(self, name: &str) -> Option[&str]:
        return self.headers.get(&name.to_lower())

    pub fn content_type(self) -> Option[&str]:
        return self.header("content-type")

    pub fn content_length(self) -> Option[u64]:
        if val Some(s) = self.header("content-length"):
            return s.parse_u64().ok()
        return None

    pub fn remote_addr(self) -> SocketAddr:
        return self.remote_addr

    # Body parsing
    pub fn body_text(self) -> Result[str, HttpError]:
        match &self.body:
            case Some(bytes):
                bytes.to_utf8().map_err(|_| HttpError::InvalidJson)
            case None:
                Err(HttpError::NoBody)

    pub fn body_bytes(self) -> Option[&Bytes]:
        return self.body.as_ref()

    pub fn has_body(self) -> bool:
        return self.body.is_some()

# Helper: Find end of headers (double CRLF)
fn find_header_end(buf: &Bytes) -> Option[usize]:
    val pattern = "\r\n\r\n".as_bytes()
    for i in 0..(buf.len() - 3):
        if buf[i] == pattern[0] and buf[i+1] == pattern[1] and
           buf[i+2] == pattern[2] and buf[i+3] == pattern[3]:
            return Some(i)
    return None

# Helper: Parse request line "GET /path?query HTTP/1.1"
fn parse_request_line(line: &str) -> Result[(HttpMethod, str, Dict[str, str], str), HttpError]:
    val parts = line.split(" ")
    if parts.len() != 3:
        return Err(HttpError::InvalidRequestLine)

    val method = HttpMethod::from_str(parts[0]).ok_or(HttpError::InvalidMethod)?
    val path_query = parts[1]
    val version = parts[2].to_string()

    # Split path and query
    val (path, query) = if val Some(idx) = path_query.find('?'):
        val p = path_query.slice(0, idx)
        val q = parse_query_string(&path_query.slice(idx + 1, path_query.len()))
        (p.to_string(), q)
    else:
        (path_query.to_string(), Dict::new())

    return Ok((method, path, query, version))

# Helper: Parse header line "Name: Value"
fn parse_header_line(line: &str) -> Option[(str, str)]:
    if val Some(idx) = line.find(':'):
        val name = line.slice(0, idx).trim()
        val value = line.slice(idx + 1, line.len()).trim()
        return Some((name.to_string(), value.to_string()))
    return None

# Helper: Parse query string "key1=value1&key2=value2"
fn parse_query_string(query: &str) -> Dict[str, str]:
    var result: Dict[str, str] = Dict::new()
    if query.is_empty():
        return result

    val pairs = query.split('&')
    for pair in pairs:
        if val Some(idx) = pair.find('='):
            val key = url_decode(&pair.slice(0, idx))
            val value = url_decode(&pair.slice(idx + 1, pair.len()))
            result.insert(key, value)
        else:
            result.insert(url_decode(pair), "")

    return result

# Helper: URL decode
fn url_decode(s: &str) -> str:
    var result = String::new()
    var i = 0
    val bytes = s.as_bytes()

    while i < bytes.len():
        if bytes[i] == '%' as u8 and i + 2 < bytes.len():
            val hex = s.slice(i + 1, i + 3)
            if val Ok(byte) = u8::from_str_radix(&hex, 16):
                result.push(byte as char)
                i = i + 3
                continue
        else if bytes[i] == '+' as u8:
            result.push(' ')
            i = i + 1
            continue

        result.push(bytes[i] as char)
        i = i + 1

    return result
